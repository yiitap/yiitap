var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-Q5ockALA.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map[key] = 1;
      return (val) => val in map;
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO$1 = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el2) => {
      const i = arr.indexOf(el2);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$9 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$9.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props) return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length) return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b) return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a2;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].pause();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].resume();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].resume();
            }
          }
        }
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          this.effects.length = 0;
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeSub;
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn2) {
        this.fn = fn2;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= -65;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= -3;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= -2;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed = false) {
      sub.flags |= 8;
      if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head;
      let tail = sub.depsTail;
      let link = tail;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail) tail = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head;
      sub.depsTail = tail;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= -17;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= -3;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= -3;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= -5;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (false) ;
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      ""
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      ""
    );
    const ARRAY_ITERATE_KEY = Symbol(
      ""
    );
    function track(target, type, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        {
          dep.track();
        }
      }
    }
    function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run = (dep) => {
        if (dep) {
          {
            dep.trigger();
          }
        }
      };
      startBatch();
      if (type === "clear") {
        depsMap.forEach(run);
      } else {
        const targetIsArray = isArray$1(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
              run(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run(depsMap.get(key));
          }
          if (isArrayIndex) {
            run(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type) {
            case "add":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap(target)) {
                run(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function getDepFromReactive(object, key) {
      const depMap = targetMap.get(object);
      return depMap && depMap.get(key);
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn2, thisArg) {
        return apply$1(this, "every", fn2, thisArg, void 0, arguments);
      },
      filter(fn2, thisArg) {
        return apply$1(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn2, thisArg) {
        return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
      },
      findIndex(fn2, thisArg) {
        return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
      },
      findLast(fn2, thisArg) {
        return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
      },
      findLastIndex(fn2, thisArg) {
        return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn2, thisArg) {
        return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn2, thisArg) {
        return apply$1(this, "map", fn2, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn2, ...args) {
        return reduce(this, "reduce", fn2, args);
      },
      reduceRight(fn2, ...args) {
        return reduce(this, "reduceRight", fn2, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn2, thisArg) {
        return apply$1(this, "some", fn2, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto$1 = Array.prototype;
    function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto$1[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn2;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn2.call(this, toReactive(item), index, self2);
          };
        } else if (fn2.length > 2) {
          wrappedFn = function(item, index) {
            return fn2.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn2, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn2;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn2.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn2.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn2.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    function hasOwnProperty$8(key) {
      if (!isSymbol$1(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          let fn2;
          if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
            return fn2;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$8;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger$1(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger$1(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            const oldValue = get2.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger$1(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger$1(target, "set", key, value);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            get2 ? get2.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger$1(target, "delete", key, void 0);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const result = target.clear();
            if (hadItems) {
              trigger$1(
                target,
                "clear",
                void 0,
                void 0
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, isShallow2) {
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
      }
      get value() {
        {
          this.dep.track();
        }
        return this._value;
      }
      set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          {
            this.dep.trigger();
          }
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this["__v_isRef"] = true;
        this._value = void 0;
        const dep = this.dep = new Dep();
        const { get: get2, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
        this._get = get2;
        this._set = set;
      }
      get value() {
        return this._value = this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
      }
      get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
      }
      get value() {
        return this._value = this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(fn2, setter, isSSR) {
        this.fn = fn2;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        }
      }
      get value() {
        const link = this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction$1(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      return cRef;
    }
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      }
    }
    function watch$1(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, once, scheduler: scheduler2, augmentJob, call: call2 } = options;
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return call2 ? call2(s, 2) : s();
          } else ;
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = call2 ? () => call2(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope && scope.active) {
          remove(scope.effects, effect2);
        }
      };
      if (once && cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call2 ? call2(cb, 3, args) : (
                // @ts-expect-error
                cb(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler2 ? () => scheduler2(job, false) : job;
      boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call2) {
            call2(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler2) {
        scheduler2(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack$1 = [];
    let isWarning = false;
    function warn$1$1(msg2, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg2 + args.map((a) => {
              var _a2, _b2;
              return (_b2 = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b2 : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack$1[stack$1.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      try {
        return args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$1(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$1(fn2)) {
        const values = [];
        for (let i = 0; i < fn2.length; i++) {
          values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
      if (throwInProd) {
        throw err;
      } else {
        console.error(err);
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (activePostFlushCbs && cb.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
        } else if (!(cb.flags & 1)) {
          pendingPostFlushCbs.push(cb);
          cb.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.flags & 2) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          if (cb.flags & 4) {
            cb.flags &= -2;
          }
          cb();
          if (!(cb.flags & 4)) {
            cb.flags &= -2;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (cb.flags & 4) {
            cb.flags &= -2;
          }
          if (!(cb.flags & 8)) cb();
          cb.flags &= -2;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (false) ;
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= -2;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs();
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn2, ctx2 = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx2) return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx2);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n12 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const mount2 = (container2, anchor2) => {
            if (shapeFlag & 16) {
              if (parentComponent && parentComponent.isCE) {
                parentComponent.ce._teleportTarget = container2;
              }
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountToTarget = () => {
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = prepareAnchor(target, n2, createText, insert);
            if (target) {
              if (namespace2 !== "svg" && isTargetSVG(target)) {
                namespace2 = "svg";
              } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
                namespace2 = "mathml";
              }
              if (!disabled) {
                mount2(target, targetAnchor);
                updateCssVars(n2, false);
              }
            }
          };
          if (disabled) {
            mount2(container, mainAnchor);
            updateCssVars(n2, true);
          }
          if (isTeleportDeferred(n2.props)) {
            queuePostRenderEffect(() => {
              mountToTarget();
              n2.el.__isMounted = true;
            }, parentSuspense);
          } else {
            mountToTarget();
          }
        } else {
          if (isTeleportDeferred(n2.props) && !n12.el.__isMounted) {
            queuePostRenderEffect(() => {
              TeleportImpl.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
              delete n12.el.__isMounted;
            }, parentSuspense);
            return;
          }
          n2.el = n12.el;
          n2.targetStart = n12.targetStart;
          const mainAnchor = n2.anchor = n12.anchor;
          const target = n2.target = n12.target;
          const targetAnchor = n2.targetAnchor = n12.targetAnchor;
          const wasDisabled = isTeleportDisabled(n12.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace2 === "svg" || isTargetSVG(target)) {
            namespace2 = "svg";
          } else if (namespace2 === "mathml" || isTargetMathML(target)) {
            namespace2 = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            traverseStaticChildren(n12, n2, true);
          } else if (!optimized) {
            patchChildren(
              n12,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n12.props && n2.props.to !== n12.props.to) {
                n2.props.to = n12.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
          updateCssVars(n2, disabled);
        }
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount2(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el: el2, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el2, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (disabled) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode, disabled);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode, isDisabled) {
      const ctx2 = vnode.ctx;
      if (ctx2 && ctx2.ut) {
        let node, anchor;
        if (isDisabled) {
          node = vnode.el;
          anchor = vnode.anchor;
        } else {
          node = vnode.targetStart;
          anchor = vnode.targetAnchor;
        }
        while (node && node !== anchor) {
          if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx2.uid);
          node = node.nextSibling;
        }
        ctx2.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const child = findNonCommentChild(children);
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getInnerChild$1(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          if (innerChild.type !== Comment) {
            setTransitionHooks(innerChild, enterHooks);
          }
          let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            let leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (!(instance.job.flags & 8)) {
                  instance.update();
                }
                delete leavingHooks.afterLeave;
                oldInnerChild = void 0;
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el2[leaveCbKey] = () => {
                  earlyRemove();
                  el2[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
                enterHooks.delayedLeave = () => {
                  delayedLeave();
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
              };
            } else {
              oldInnerChild = void 0;
            }
          } else if (oldInnerChild) {
            oldInnerChild = void 0;
          }
          return child;
        };
      }
    };
    function findNonCommentChild(children) {
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      return child;
    }
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1)) done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el2) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el2[leaveCbKey]) {
            el2[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el2]);
        },
        enter(el2) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el2[enterCbKey$1] = (cancelled) => {
            if (called) return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el2]);
            } else {
              callHook2(afterHook, [el2]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el2[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el2, done]);
          } else {
            done();
          }
        },
        leave(el2, remove2) {
          const key2 = String(vnode.key);
          if (el2[enterCbKey$1]) {
            el2[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el2]);
          let called = false;
          const done = el2[leaveCbKey] = (cancelled) => {
            if (called) return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el2]);
            } else {
              callHook2(onAfterLeave, [el2]);
            }
            el2[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el2, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone) postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getInnerChild$1(vnode) {
      if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) {
          return findNonCommentChild(vnode.children);
        }
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$1(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128) keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8236: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
    getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderList(source, renderItem, cache2, index) {
      let ret;
      const cached = cache2;
      const sourceIsArray = isArray$1(source);
      if (sourceIsArray || isString(source)) {
        const sourceIsReactiveArray = sourceIsArray && isReactive(source);
        let needsWrap = false;
        if (sourceIsReactiveArray) {
          needsWrap = !isShallow(source);
          source = shallowReadArray(source);
        }
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(
            needsWrap ? toReactive(source[i]) : source[i],
            i,
            void 0,
            cached
          );
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached)
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            ret[i] = renderItem(source[key], key, i, cached);
          }
        }
      } else {
        ret = [];
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(
          Fragment,
          null,
          [createVNode("slot", props, fallback)],
          64
        );
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key;
      const rendered = createBlock(
        Fragment,
        {
          key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
          ""
        },
        validSlotContent || [],
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $host: (i) => i.ce,
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx: ctx2, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx2[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
            accessCache[key] = 4;
            return ctx2[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx: ctx2 } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx2[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx2 = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx2[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data)) ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set
          });
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx2, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx2[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx2, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx2[raw];
        if (isFunction$1(handler)) {
          {
            watch(getter, handler);
          }
        }
      } else if (isFunction$1(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$1(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from[key]) : from[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from) {
      if (!from) {
        return to2;
      }
      if (!to2) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to2) ? to2.call(this, this) : to2,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to2, from) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from) {
      return to2 ? [...new Set([].concat(to2, from))] : from;
    }
    function mergeObjectOptions(to2, from) {
      return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
    }
    function mergeEmitsOrPropsOptions(to2, from) {
      if (to2) {
        if (isArray$1(to2) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to2, from) {
      if (!to2) return from;
      if (!from) return to2;
      const merged = extend(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from) {
        merged[key] = mergeAsArray(to2[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO$1,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted2 = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin2, ...options) {
            if (installedPlugins.has(plugin2)) ;
            else if (plugin2 && isFunction$1(plugin2.install)) {
              installedPlugins.add(plugin2);
              plugin2.install(app2, ...options);
            } else if (isFunction$1(plugin2)) {
              installedPlugins.add(plugin2);
              plugin2(app2, ...options);
            } else ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace2) {
            if (!isMounted2) {
              const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace2 === true) {
                namespace2 = "svg";
              } else if (namespace2 === false) {
                namespace2 = void 0;
              }
              {
                render2(vnode, rootContainer, namespace2);
              }
              isMounted2 = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getComponentPublicInstance(vnode.component);
            }
          },
          onUnmount(cleanupFn) {
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted2) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app2._instance,
                16
              );
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn2) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn2();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
      }
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$1(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type = propType[index];
                const typeName = isFunction$1(type) && type.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$1(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx2) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false) ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx2);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx2 = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx2);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n12 === n2) {
          return;
        }
        if (n12 && !isSameVNodeType(n12, n2)) {
          anchor = getNextHostNode(n12);
          unmount2(n12, parentComponent, parentSuspense, true);
          n12 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n12, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n12, n2, container, anchor);
            break;
          case Static:
            if (n12 == null) {
              mountStaticNode(n2, container, anchor, namespace2);
            }
            break;
          case Fragment:
            processFragment(
              n12,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
        }
      };
      const processText = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el2 = n2.el = n12.el;
          if (n2.children !== n12.children) {
            hostSetText(el2, n2.children);
          }
        }
      };
      const processCommentNode = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n12.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostInsert(el2, container, nextSibling);
          el2 = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el: el2, anchor }) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostRemove(el2);
          el2 = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace2 = "svg";
        } else if (n2.type === "math") {
          namespace2 = "mathml";
        }
        if (n12 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n12,
            n2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
          vnode.type,
          namespace2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace2),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el2, key, null, props[key], namespace2, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el2, "value", null, props.value, namespace2);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el2);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el2, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el2,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n12, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const el2 = n2.el = n12.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n12.patchFlag & 16;
        const oldProps = n12.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el2, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n12.dynamicChildren,
            dynamicChildren,
            el2,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n12,
            n2,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el2, oldProps, newProps, parentComponent, namespace2);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el2, "class", null, newProps.class, namespace2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n12.children !== n2.children) {
              hostSetElementText(el2, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el2, oldProps, newProps, parentComponent, namespace2);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
            dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el2, oldProps, newProps, parentComponent, namespace2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el2,
                  key,
                  oldProps[key],
                  null,
                  namespace2,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace2);
          }
        }
      };
      const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n12 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n12.dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n12,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n12,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n12 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              optimized
            );
          }
        } else {
          updateComponent(n12, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      };
      const updateComponent = (n12, n2, optimized) => {
        const instance = n2.component = n12.component;
        if (shouldUpdateComponent(n12, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n12.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el: el2, props } = initialVNode;
            const { bm: bm2, m, parent, root: root2, type } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm2) {
              invokeArrayFns(bm2);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            {
              if (root2.ce) {
                root2.ce._injectChildStyle(type);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace2
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu: bu2, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu2) {
              invokeArrayFns(bu2);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
        const c12 = n12 && n12.children;
        const prevShapeFlag = n12 ? n12.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c12, parentComponent, parentSuspense);
          }
          if (c2 !== c12) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c12,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c12, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c12, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        c12 = c12 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c12.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c12[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c12,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c12, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e12 = c12.length - 1;
        let e2 = l2 - 1;
        while (i <= e12 && i <= e2) {
          const n12 = c12[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e12 && i <= e2) {
          const n12 = c12[e12];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e12--;
          e2--;
        }
        if (i > e12) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e12) {
            unmount2(c12[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s12 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
          for (i = s12; i <= e12; i++) {
            const prevChild = c12[i];
            if (patched >= toBePatched) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el2, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el2);
            hostInsert(el2, container, anchor);
            queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el2, container, anchor);
            const performLeave = () => {
              leave(el2, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el2, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el2, container, anchor);
        }
      };
      const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el: el2, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el2, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el2);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el2, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, job, subTree, um: um2, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (job) {
          job.flags |= 8;
          unmount2(subTree, instance, parentSuspense, doRemove);
        }
        if (um2) {
          queuePostRenderEffect(um2, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount2(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el2 = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el2 && el2[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el2;
      };
      let isFlushing = false;
      const render2 = (vnode, container, namespace2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount2(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace2
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount2,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= -33;
        job.flags &= -5;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n12, n2, shallow = false) {
      const ch1 = n12.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c12 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c12.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c12, c2);
          }
          if (c2.type === Text) {
            c2.el = c12.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c2;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c2 = u + v >> 1;
            if (arr[result[c2]] < arrI) {
              u = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].flags |= 8;
      }
    }
    const ssrContextKey$1 = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx2 = inject(ssrContextKey$1);
        return ctx2;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once } = options;
      const baseWatchOptions = extend({}, options);
      const runsImmediately = cb && immediate || !cb && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx2 = useSSRContext();
          ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx2, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx2;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx: ctx2,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx2
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false) ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        setTransitionHooks(root2, vnode.transition);
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el2) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el2;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n12, n2) {
      return n12.type === n2.type && n12.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style2)) {
          if (isProxy(style2) && !isArray$1(style2)) {
            style2 = extend({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup: setup2 } = Component;
      if (setup2) {
        pauseTracking();
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        const isAsyncSetup = isPromise(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult);
        }
      } else {
        finishComponentSetup(instance);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else ;
      finishComponentSetup(instance);
    }
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c2;
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.5.13";
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt = typeof window !== "undefined" && window.trustedTypes;
    if (tt) {
      try {
        policy = /* @__PURE__ */ tt.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace2, is2, props) => {
        const el2 = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el2.setAttribute("multiple", props.multiple);
        }
        return el2;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el2, text) => {
        el2.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el2, id2) {
        el2.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace2, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace2 === "svg" || namespace2 === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const decorate$1 = (t) => {
      t.displayName = "Transition";
      t.props = TransitionPropsValidators;
      return t;
    };
    const Transition = /* @__PURE__ */ decorate$1(
      (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration: duration2,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration2);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el2, isAppear, done, isCancelled) => {
        el2._enterCancelled = isCancelled;
        removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el2, done) => {
        el2._isLeaving = false;
        removeTransitionClass(el2, leaveFromClass);
        removeTransitionClass(el2, leaveToClass);
        removeTransitionClass(el2, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el2, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el2, isAppear, done);
          callHook(hook, [el2, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el2, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el2) {
          callHook(onBeforeEnter, [el2]);
          addTransitionClass(el2, enterFromClass);
          addTransitionClass(el2, enterActiveClass);
        },
        onBeforeAppear(el2) {
          callHook(onBeforeAppear, [el2]);
          addTransitionClass(el2, appearFromClass);
          addTransitionClass(el2, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el2, done) {
          el2._isLeaving = true;
          const resolve2 = () => finishLeave(el2, done);
          addTransitionClass(el2, leaveFromClass);
          if (!el2._enterCancelled) {
            forceReflow();
            addTransitionClass(el2, leaveActiveClass);
          } else {
            addTransitionClass(el2, leaveActiveClass);
            forceReflow();
          }
          nextFrame(() => {
            if (!el2._isLeaving) {
              return;
            }
            removeTransitionClass(el2, leaveFromClass);
            addTransitionClass(el2, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el2, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el2, resolve2]);
        },
        onEnterCancelled(el2) {
          finishEnter(el2, false, void 0, true);
          callHook(onEnterCancelled, [el2]);
        },
        onAppearCancelled(el2) {
          finishEnter(el2, true, void 0, true);
          callHook(onAppearCancelled, [el2]);
        },
        onLeaveCancelled(el2) {
          finishLeave(el2);
          callHook(onLeaveCancelled, [el2]);
        }
      });
    }
    function normalizeDuration(duration2) {
      if (duration2 == null) {
        return null;
      } else if (isObject$1(duration2)) {
        return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
      } else {
        const n = NumberOf(duration2);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.add(c2));
      (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.remove(c2));
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el2[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
      const id2 = el2._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el2._endId) {
          resolve2();
        }
      };
      if (explicitTimeout != null) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el2.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el2 && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el2.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el2, expectedType) {
      const styles = window.getComputedStyle(el2);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto") return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el2, value, isSVG2) {
      const transitionClasses = el2[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el2.removeAttribute("class");
      } else if (isSVG2) {
        el2.setAttribute("class", value);
      } else {
        el2.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el2, { value }, { transition }) {
        el2[vShowOriginalDisplay] = el2.style.display === "none" ? "" : el2.style.display;
        if (transition && value) {
          transition.beforeEnter(el2);
        } else {
          setDisplay(el2, value);
        }
      },
      mounted(el2, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el2);
        }
      },
      updated(el2, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el2);
            setDisplay(el2, true);
            transition.enter(el2);
          } else {
            transition.leave(el2, () => {
              setDisplay(el2, false);
            });
          }
        } else {
          setDisplay(el2, value);
        }
      },
      beforeUnmount(el2, { value }) {
        setDisplay(el2, value);
      }
    };
    function setDisplay(el2, value) {
      el2.style.display = value ? el2[vShowOriginalDisplay] : "none";
      el2[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el2, prev, next) {
      const style2 = el2.style;
      const isCssString = isString(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style2, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style2[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style2.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el2.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el2) {
        el2[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
        if (el2[vShowHidden]) {
          style2.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null) val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el2, key, value, isSVG2, instance, isBoolean = isSpecialBooleanAttr(key)) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el2.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el2.removeAttribute(key);
        } else {
          el2.setAttribute(
            key,
            isBoolean ? "" : isSymbol$1(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el2, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el2[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el2.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el2.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el2)) {
          el2.value = newValue;
        }
        if (value == null) {
          el2.removeAttribute(key);
        }
        el2._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el2[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el2[key] = value;
      } catch (e) {
      }
      needRemove && el2.removeAttribute(attrName || key);
    }
    function addEventListener(el2, event, handler, options) {
      el2.addEventListener(event, handler, options);
    }
    function removeEventListener(el2, event, handler, options) {
      el2.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
      const invokers = el2[veiKey] || (el2[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el2, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el2, key, prevValue, nextValue, namespace2, parentComponent) => {
      const isSVG2 = namespace2 === "svg";
      if (key === "class") {
        patchClass(el2, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG2)) {
        patchDOMProp(el2, key, nextValue);
        if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el2, key, nextValue, isSVG2, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el2._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
      ) {
        patchDOMProp(el2, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el2._trueValue = nextValue;
        } else if (key === "false-value") {
          el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el2, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el2 && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el2.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el2.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString(value)) {
        return false;
      }
      return key in el2;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const decorate = (t) => {
      delete t.props.mode;
      return t;
    };
    const TransitionGroupImpl = /* @__PURE__ */ decorate({
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el2 = c2.el;
            const style2 = el2.style;
            addTransitionClass(el2, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb = el2[moveCbKey] = (e) => {
              if (e && e.target !== el2) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el2.removeEventListener("transitionend", cb);
                el2[moveCbKey] = null;
                removeTransitionClass(el2, moveClass);
              }
            };
            el2.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    });
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el2 = c2.el;
      if (el2[moveCbKey]) {
        el2[moveCbKey]();
      }
      if (el2[enterCbKey]) {
        el2[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx2 = oldPos.left - newPos.left;
      const dy2 = oldPos.top - newPos.top;
      if (dx2 || dy2) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx2}px,${dy2}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el2, root2, moveClass) {
      const clone = el2.cloneNode();
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el2, { modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el2, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el2.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el2[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el2, "change", () => {
            el2.value = el2.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el2, "compositionstart", onCompositionStart);
          addEventListener(el2, "compositionend", onCompositionEnd);
          addEventListener(el2, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el2, { value }) {
        el2.value = value == null ? "" : value;
      },
      beforeUpdate(el2, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        if (el2.composing) return;
        const elValue = (number || el2.type === "number") && !/^0\d/.test(el2.value) ? looseToNumber(el2.value) : el2.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el2 && el2.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el2.value.trim() === newValue) {
            return;
          }
        }
        el2.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el2, _, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        addEventListener(el2, "change", () => {
          const modelValue = el2._modelValue;
          const elementValue = getValue$2(el2);
          const checked = el2.checked;
          const assign = el2[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el2, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el2, binding, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        setChecked(el2, binding, vnode);
      }
    };
    function setChecked(el2, { value, oldValue }, vnode) {
      el2._modelValue = value;
      let checked;
      if (isArray$1(value)) {
        checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        checked = value.has(vnode.props.value);
      } else {
        if (value === oldValue) return;
        checked = looseEqual(value, getCheckboxValue(el2, true));
      }
      if (el2.checked !== checked) {
        el2.checked = checked;
      }
    }
    function getValue$2(el2) {
      return "_value" in el2 ? el2._value : el2.value;
    }
    function getCheckboxValue(el2, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el2 ? el2[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache2 = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers)) return;
        }
        return fn2(event, ...args);
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render$1 = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount: mount2 } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount2(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    function plugin$1(options) {
      let _bPrefix = ".";
      let _ePrefix = "__";
      let _mPrefix = "--";
      let c2;
      if (options) {
        let t = options.blockPrefix;
        if (t) {
          _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
          _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
          _mPrefix = t;
        }
      }
      const _plugin = {
        install(instance) {
          c2 = instance.c;
          const ctx2 = instance.context;
          ctx2.bem = {};
          ctx2.bem.b = null;
          ctx2.bem.els = null;
        }
      };
      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx2) {
            memorizedB = ctx2.bem.b;
            memorizedE = ctx2.bem.els;
            ctx2.bem.els = null;
          },
          after(ctx2) {
            ctx2.bem.b = memorizedB;
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }
        };
      }
      function e(arg) {
        let memorizedE;
        return {
          before(ctx2) {
            memorizedE = ctx2.bem.els;
          },
          after(ctx2) {
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.els = arg.split(",").map((v) => v.trim());
            return context.bem.els.map((el2) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el2}`).join(", ");
          }
        };
      }
      function m(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const modifiers = arg.split(",").map((v) => v.trim());
            function elementToSelector(el2) {
              return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el2 !== void 0 ? `${_ePrefix}${el2}` : ""}${_mPrefix}${modifier}`).join(", ");
            }
            const els = context.bem.els;
            if (els !== null) {
              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }
        };
      }
      function notM(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const els = context.bem.els;
            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
          }
        };
      }
      const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
      const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
      const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
      const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
      Object.assign(_plugin, {
        cB: cB2,
        cE: cE2,
        cM: cM2,
        cNotM: cNotM2
      });
      return _plugin;
    }
    function ampCount(selector) {
      let cnt = 0;
      for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === "&")
          ++cnt;
      }
      return cnt;
    }
    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        let round = ampCount(partialSelector);
        if (!round) {
          amp.forEach((partialAmp) => {
            nextAmp.push(
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              (partialAmp && partialAmp + " ") + partialSelector
            );
          });
          return;
        } else if (round === 1) {
          amp.forEach((partialAmp) => {
            nextAmp.push(partialSelector.replace("&", partialAmp));
          });
          return;
        }
        let partialNextAmp = [
          partialSelector
        ];
        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach((selectorItr) => {
            amp.forEach((partialAmp) => {
              nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach((part) => nextAmp.push(part));
      });
      return nextAmp;
    }
    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        amp.forEach((partialAmp) => {
          nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
        });
      });
      return nextAmp;
    }
    function parseSelectorPath(selectorPaths) {
      let amp = [""];
      selectorPaths.forEach((selector) => {
        selector = selector && selector.trim();
        if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector
        ) {
          return;
        }
        if (selector.includes("&")) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(", ").replace(extraSpaceRegex, " ");
    }
    function removeElement(el2) {
      if (!el2)
        return;
      const parentElement = el2.parentElement;
      if (parentElement)
        parentElement.removeChild(el2);
    }
    function queryElement(id2, parent) {
      return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id2}"]`);
    }
    function createElement(id2) {
      const el2 = document.createElement("style");
      el2.setAttribute("cssr-id", id2);
      return el2;
    }
    function isMediaOrSupports(selector) {
      if (!selector)
        return false;
      return /^\s*@(s|m)/.test(selector);
    }
    const kebabRegex = /[A-Z]/g;
    function kebabCase(pattern) {
      return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
    }
    function unwrapProperty(prop, indent = "  ") {
      if (typeof prop === "object" && prop !== null) {
        return " {\n" + Object.entries(prop).map((v) => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join("\n") + "\n" + indent + "}";
      }
      return `: ${prop};`;
    }
    function unwrapProperties(props, instance, params) {
      if (typeof props === "function") {
        return props({
          context: instance.context,
          props: params
        });
      }
      return props;
    }
    function createStyle(selector, props, instance, params) {
      if (!props)
        return "";
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
        return "";
      if (typeof unwrappedProps === "string") {
        return `${selector} {
${unwrappedProps}
}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
          return selector + " {\n}";
        return "";
      }
      const statements = selector ? [
        selector + " {"
      ] : [];
      propertyNames.forEach((propertyName) => {
        const property = unwrappedProps[propertyName];
        if (propertyName === "raw") {
          statements.push("\n" + property + "\n");
          return;
        }
        propertyName = kebabCase(propertyName);
        if (property !== null && property !== void 0) {
          statements.push(`  ${propertyName}${unwrapProperty(property)}`);
        }
      });
      if (selector) {
        statements.push("}");
      }
      return statements.join("\n");
    }
    function loopCNodeListWithCallback(children, options, callback) {
      if (!children)
        return;
      children.forEach((child) => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === "function") {
          const grandChildren = child(options);
          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }
    function traverseCNode(node, selectorPaths, styles, instance, params) {
      const $2 = node.$;
      let blockSelector = "";
      if (!$2 || typeof $2 === "string") {
        if (isMediaOrSupports($2)) {
          blockSelector = $2;
        } else {
          selectorPaths.push($2);
        }
      } else if (typeof $2 === "function") {
        const selector2 = $2({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      } else {
        if ($2.before)
          $2.before(instance.context);
        if (!$2.$ || typeof $2.$ === "string") {
          if (isMediaOrSupports($2.$)) {
            blockSelector = $2.$;
          } else {
            selectorPaths.push($2.$);
          }
        } else if ($2.$) {
          const selector2 = $2.$({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style2 = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
        styles.push(`${blockSelector} {`);
      } else if (style2.length) {
        styles.push(style2);
      }
      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, (childNode) => {
          if (typeof childNode === "string") {
            const style3 = createStyle(selector, { raw: childNode }, instance, params);
            styles.push(style3);
          } else {
            traverseCNode(childNode, selectorPaths, styles, instance, params);
          }
        });
      }
      selectorPaths.pop();
      if (blockSelector) {
        styles.push("}");
      }
      if ($2 && $2.after)
        $2.after(instance.context);
    }
    function render(node, instance, props) {
      const styles = [];
      traverseCNode(node, [], styles, instance, props);
      return styles.join("\n\n");
    }
    function murmur2(str) {
      var h2 = 0;
      var k, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= /* k >>> r: */
        k >>> 24;
        h2 = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
    function unmount(instance, node, id2, parent) {
      const { els } = node;
      if (id2 === void 0) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id2, parent);
        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter((el2) => el2 !== target);
        }
      }
    }
    function addElementToList(els, target) {
      els.push(target);
    }
    function mount(instance, node, id2, props, head, force, anchorMetaName, parent, ssrAdapter2) {
      let style2;
      if (id2 === void 0) {
        style2 = node.render(props);
        id2 = murmur2(style2);
      }
      if (ssrAdapter2) {
        ssrAdapter2.adapter(id2, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
        return;
      }
      if (parent === void 0) {
        parent = document.head;
      }
      const queriedTarget = queryElement(id2, parent);
      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id2);
      if (style2 === void 0)
        style2 = node.render(props);
      target.textContent = style2;
      if (queriedTarget !== null)
        return queriedTarget;
      if (anchorMetaName) {
        const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
        if (anchorMetaEl) {
          parent.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }
      if (head) {
        parent.insertBefore(target, parent.querySelector("style, link"));
      } else {
        parent.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
    }
    function wrappedRender(props) {
      return render(this, this.instance, props);
    }
    function wrappedMount(options = {}) {
      const { id: id2, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
      const targetElement = mount(this.instance, this, id2, props, head, force, anchorMetaName, parent, ssr);
      return targetElement;
    }
    function wrappedUnmount(options = {}) {
      const { id: id2, parent } = options;
      unmount(this.instance, this, id2, parent);
    }
    const createCNode = function(instance, $2, props, children) {
      return {
        instance,
        $: $2,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    const c$1 = function(instance, $2, props, children) {
      if (Array.isArray($2)) {
        return createCNode(instance, { $: null }, null, $2);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $2, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $2, props, children);
      } else {
        return createCNode(instance, $2, props, null);
      }
    };
    function CssRender(config = {}) {
      const cssr2 = {
        c: (...args) => c$1(cssr2, ...args),
        use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
        find: queryElement,
        context: {},
        config
      };
      return cssr2;
    }
    function exists(id2, ssr) {
      if (id2 === void 0)
        return false;
      if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id2);
      }
      return queryElement(id2) !== null;
    }
    const namespace = "n";
    const prefix$1 = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix$1,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const {
      c,
      find
    } = cssr;
    const {
      cB,
      cE: cE$1,
      cM: cM$1,
      cNotM
    } = plugin;
    function createKey(prefix2, suffix2) {
      return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
    }
    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }
    function depx(value) {
      if (typeof value === "string") {
        if (value.endsWith("px")) {
          return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
      }
      return value;
    }
    function pxfy(value) {
      if (value === void 0 || value === null)
        return void 0;
      if (typeof value === "number")
        return `${value}px`;
      if (value.endsWith("px"))
        return value;
      return `${value}px`;
    }
    function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
        top: parts[0]
      };
      switch (parts.length) {
        case 1:
          margin.right = parts[0];
          margin.bottom = parts[0];
          margin.left = parts[0];
          break;
        case 2:
          margin.right = parts[1];
          margin.left = parts[1];
          margin.bottom = parts[0];
          break;
        case 3:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[1];
          break;
        case 4:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[3];
          break;
        default:
          throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
      }
      return margin;
    }
    function getGap(value, orient) {
      const [rowGap, colGap] = value.split(" ");
      return {
        row: rowGap,
        col: colGap || rowGap
      };
    }
    const colors = {
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#0FF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000",
      blanchedalmond: "#FFEBCD",
      blue: "#00F",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#0FF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgrey: "#A9A9A9",
      darkgreen: "#006400",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#F0F",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgrey: "#D3D3D3",
      lightgreen: "#90EE90",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#0F0",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#F0F",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#F00",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FF0",
      yellowgreen: "#9ACD32",
      transparent: "#0000"
    };
    function hsv2rgb(h2, s, v) {
      s /= 100;
      v /= 100;
      let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5) * 255, f(3) * 255, f(1) * 255];
    }
    function hsl2rgb(h2, s, l) {
      s /= 100;
      l /= 100;
      let a = s * Math.min(l, 1 - l);
      let f = (n, k = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0) * 255, f(8) * 255, f(4) * 255];
    }
    const prefix = "^\\s*";
    const suffix = "\\s*$";
    const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
    const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    const hex = "([0-9A-Fa-f])";
    const dhex = "([0-9A-Fa-f]{2})";
    const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
    function parseHex(value) {
      return parseInt(value, 16);
    }
    function hsla(color) {
      try {
        let i;
        if (i = hslaRegex.exec(color)) {
          return [
            roundDeg(i[1]),
            roundPercent(i[5]),
            roundPercent(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = hslRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function hsva(color) {
      try {
        let i;
        if (i = hsvaRegex.exec(color)) {
          return [
            roundDeg(i[1]),
            roundPercent(i[5]),
            roundPercent(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = hsvRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function rgba(color) {
      try {
        let i;
        if (i = hexRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        } else if (i = rgbRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        } else if (i = rgbaRegex.exec(color)) {
          return [
            roundChannel(i[1]),
            roundChannel(i[5]),
            roundChannel(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = sHexRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            1
          ];
        } else if (i = hexaRegex.exec(color)) {
          return [
            parseHex(i[1]),
            parseHex(i[2]),
            parseHex(i[3]),
            roundAlpha(parseHex(i[4]) / 255)
          ];
        } else if (i = sHexaRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            roundAlpha(parseHex(i[4] + i[4]) / 255)
          ];
        } else if (color in colors) {
          return rgba(colors[color]);
        } else if (hslRegex.test(color) || hslaRegex.test(color)) {
          const [h2, s, l, a] = hsla(color);
          return [...hsl2rgb(h2, s, l), a];
        } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
          const [h2, s, v, a] = hsva(color);
          return [...hsv2rgb(h2, s, v), a];
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function normalizeAlpha(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }
    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
    }
    function compositeChannel(v12, a12, v2, a2, a) {
      return roundChannel((v12 * a12 * (1 - a2) + v2 * a2) / a);
    }
    function composite(background, overlay2) {
      if (!Array.isArray(background))
        background = rgba(background);
      if (!Array.isArray(overlay2))
        overlay2 = rgba(overlay2);
      const a12 = background[3];
      const a2 = overlay2[3];
      const alpha = roundAlpha(a12 + a2 - a12 * a2);
      return stringifyRgba(compositeChannel(background[0], a12, overlay2[0], a2, alpha), compositeChannel(background[1], a12, overlay2[1], a2, alpha), compositeChannel(background[2], a12, overlay2[2], a2, alpha), alpha);
    }
    function changeColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      if (typeof options.alpha === "number") {
        return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
        return 1;
      if (v < 0)
        return 0;
      return v;
    }
    function roundDeg(value) {
      const v = Math.round(Number(value));
      if (v >= 360)
        return 0;
      if (v < 0)
        return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
        return 255;
      if (v < 0)
        return 0;
      return v;
    }
    function roundPercent(value) {
      const v = Math.round(Number(value));
      if (v > 100)
        return 100;
      if (v < 0)
        return 0;
      return v;
    }
    function toRgbaString(base2) {
      const [r, g, b] = base2;
      if (3 in base2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function createId(length = 8) {
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }
    const traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
    function createTrapHandler(name, el2, originalHandler) {
      if (name === "mousemoveoutside") {
        const moveHandler = (e) => {
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === "clickoutside") {
        let mouseDownOutside = false;
        const downHandler = (e) => {
          mouseDownOutside = !el2.contains(getEventTarget(e));
        };
        const upHanlder = (e) => {
          if (!mouseDownOutside)
            return;
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }
      console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
      );
      return {};
    }
    function ensureTrapHandlers(name, el2, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el2);
      if (elHandlers === void 0) {
        handlers.set(el2, elHandlers = /* @__PURE__ */ new WeakMap());
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === void 0) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el2, handler));
      }
      return trapHandler;
    }
    function trapOn(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          on(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function trapOff(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function createDelegate() {
      if (typeof window === "undefined") {
        return {
          on: () => {
          },
          off: () => {
          }
        };
      }
      const propagationStopped = /* @__PURE__ */ new WeakMap();
      const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
      function trackPropagation() {
        propagationStopped.set(this, true);
      }
      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn2) {
        const source = event[propName];
        event[propName] = function() {
          fn2.apply(event, arguments);
          return source.apply(event, arguments);
        };
        return event;
      }
      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }
      const currentTargets = /* @__PURE__ */ new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
      function getCurrentTarget() {
        var _a2;
        return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === void 0)
          return;
        Object.defineProperty(event, "currentTarget", {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }
      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
        const delegeteHandler = function(e) {
          const { type, eventPhase, bubbles } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2)
            return;
          const phase = eventPhase === 1 ? "capture" : "bubble";
          let cursor = target;
          const path = [];
          while (true) {
            if (cursor === null)
              cursor = window;
            path.push(cursor);
            if (cursor === window) {
              break;
            }
            cursor = cursor.parentNode || null;
          }
          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
          spy(e, "stopPropagation", trackPropagation);
          spy(e, "stopImmediatePropagation", trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);
          if (phase === "capture") {
            if (captureElToHandlers === void 0)
              return;
            for (let i = path.length - 1; i >= 0; --i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = captureElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
              if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                const bubbleHandlers = bubbleElToHandlers.get(target2);
                if (bubbleHandlers !== void 0) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === "bubble") {
            if (bubbleElToHandlers === void 0)
              return;
            for (let i = 0; i < path.length; ++i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = bubbleElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
          unspy(e, "stopPropagation");
          unspy(e, "stopImmediatePropagation");
          defineCurrentTarget(e);
        };
        delegeteHandler.displayName = "evtdUnifiedHandler";
        return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
        const delegateHandler = function(e) {
          const { type, eventPhase } = e;
          if (eventPhase !== 2)
            return;
          const handlers = typeToWindowEventHandlers[type];
          if (handlers === void 0)
            return;
          handlers.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
        return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type] === void 0) {
          phaseHandlers[type] = /* @__PURE__ */ new Map();
          window.addEventListener(type, unifiedHandler, phase === "capture");
        }
        return phaseHandlers[type];
      }
      function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        if (windowEventHandlers === void 0) {
          typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
          window.addEventListener(type, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type];
      }
      function ensureHandlers(elToHandlers, el2) {
        let elHandlers = elToHandlers.get(el2);
        if (elHandlers === void 0) {
          elToHandlers.set(el2, elHandlers = /* @__PURE__ */ new Set());
        }
        return elHandlers;
      }
      function handlerExist(el2, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type];
        if (elToHandlers !== void 0) {
          const handlers = elToHandlers.get(el2);
          if (handlers !== void 0) {
            if (handlers.has(handler))
              return true;
          }
        }
        return false;
      }
      function windowEventHandlerExist(type, handler) {
        const handlers = typeToWindowEventHandlers[type];
        if (handlers !== void 0) {
          if (handlers.has(handler)) {
            return true;
          }
        }
        return false;
      }
      function on2(type, el2, handler, options) {
        let mergedHandler;
        if (typeof options === "object" && options.once === true) {
          mergedHandler = (e) => {
            off2(type, el2, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }
        const trapped = trapOn(type, el2, mergedHandler, options);
        if (trapped)
          return;
        const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el2);
        if (!handlers.has(mergedHandler))
          handlers.add(mergedHandler);
        if (el2 === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type);
          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }
      function off2(type, el2, handler, options) {
        const trapped = trapOff(type, el2, handler, options);
        if (trapped)
          return;
        const capture = options === true || typeof options === "object" && options.capture === true;
        const phase = capture ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el2);
        if (el2 === window) {
          const mirrorPhase = capture ? "bubble" : "capture";
          if (!handlerExist(el2, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
            const windowEventHandlers = typeToWindowEventHandlers[type];
            windowEventHandlers.delete(handler);
            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type] = void 0;
            }
          }
        }
        if (handlers.has(handler))
          handlers.delete(handler);
        if (handlers.size === 0) {
          elToHandlers.delete(el2);
        }
        if (elToHandlers.size === 0) {
          window.removeEventListener(type, unifiedHandler, phase === "capture");
          phaseToTypeToElToHandlers[phase][type] = void 0;
        }
      }
      return {
        on: on2,
        off: off2
      };
    }
    const { on, off } = createDelegate();
    function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
        return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return readonly(currentRef);
    }
    function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
        valueRef.value = value;
      });
      if (typeof getterOrOptions === "function") {
        return valueRef;
      } else {
        return {
          __v_isRef: true,
          get value() {
            return valueRef.value;
          },
          set value(v) {
            getterOrOptions.set(v);
          }
        };
      }
    }
    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, (value) => {
        if (value !== void 0) {
          uncontrolledStateRef.value = value;
        }
      });
      return computed(() => {
        if (controlledStateRef.value === void 0) {
          return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
      });
    }
    function isMounted() {
      const isMounted2 = ref(false);
      onMounted(() => {
        isMounted2.value = true;
      });
      return readonly(isMounted2);
    }
    const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }
    function createInjectionKey(key) {
      return key;
    }
    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const drawerInjectionKey = createInjectionKey("n-drawer");
    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a2;
      const injection = inject(injectionName, null);
      if (injection === null) return;
      const vm2 = (_a2 = getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
        if (!injection) return;
        const collection = injection[collectionKey];
        if (oldKey !== void 0) removeInstance(collection, oldKey);
        if (key !== void 0) addInstance(collection, key);
      }
      function removeInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm2), 1);
      }
      function addInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm2)) {
          collection[key].push(vm2);
        }
      }
    }
    const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
    const isComposingRef = ref(false);
    function compositionStartHandler() {
      isComposingRef.value = true;
    }
    function compositionEndHandler() {
      isComposingRef.value = false;
    }
    let mountedCount = 0;
    function useIsComposing() {
      if (isBrowser$1) {
        onBeforeMount(() => {
          if (!mountedCount) {
            window.addEventListener("compositionstart", compositionStartHandler);
            window.addEventListener("compositionend", compositionEndHandler);
          }
          mountedCount++;
        });
        onBeforeUnmount(() => {
          if (mountedCount <= 1) {
            window.removeEventListener("compositionstart", compositionStartHandler);
            window.removeEventListener("compositionend", compositionEndHandler);
            mountedCount = 0;
          } else {
            mountedCount--;
          }
        });
      }
      return isComposingRef;
    }
    let lockCount = 0;
    let originalMarginRight = "";
    let originalOverflow = "";
    let originalOverflowX = "";
    let originalOverflowY = "";
    const lockHtmlScrollRightCompensationRef = ref("0px");
    function useLockHtmlScroll(lockRef) {
      if (typeof document === "undefined") return;
      const el2 = document.documentElement;
      let watchStopHandle;
      let activated = false;
      const unlock = () => {
        el2.style.marginRight = originalMarginRight;
        el2.style.overflow = originalOverflow;
        el2.style.overflowX = originalOverflowX;
        el2.style.overflowY = originalOverflowY;
        lockHtmlScrollRightCompensationRef.value = "0px";
      };
      onMounted(() => {
        watchStopHandle = watch(lockRef, (value) => {
          if (value) {
            if (!lockCount) {
              const scrollbarWidth = window.innerWidth - el2.offsetWidth;
              if (scrollbarWidth > 0) {
                originalMarginRight = el2.style.marginRight;
                el2.style.marginRight = `${scrollbarWidth}px`;
                lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
              }
              originalOverflow = el2.style.overflow;
              originalOverflowX = el2.style.overflowX;
              originalOverflowY = el2.style.overflowY;
              el2.style.overflow = "hidden";
              el2.style.overflowX = "hidden";
              el2.style.overflowY = "hidden";
            }
            activated = true;
            lockCount++;
          } else {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
        if (activated) {
          lockCount--;
          if (!lockCount) {
            unlock();
          }
          activated = false;
        }
      });
    }
    function useReactivated(callback) {
      const isDeactivatedRef = {
        isDeactivated: false
      };
      let activateStateInitialized = false;
      onActivated(() => {
        isDeactivatedRef.isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        callback();
      });
      onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }
    function getSlot$1(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
    }
    const ctxKey = "@@coContext";
    const clickoutside = {
      mounted(el2, { value, modifiers }) {
        el2[ctxKey] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el2[ctxKey].handler = value;
          on("clickoutside", el2, value, {
            capture: modifiers.capture
          });
        }
      },
      updated(el2, { value, modifiers }) {
        const ctx2 = el2[ctxKey];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("clickoutside", el2, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = value;
              on("clickoutside", el2, value, {
                capture: modifiers.capture
              });
            }
          } else {
            el2[ctxKey].handler = value;
            on("clickoutside", el2, value, {
              capture: modifiers.capture
            });
          }
        } else {
          if (ctx2.handler) {
            off("clickoutside", el2, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el2, { modifiers }) {
        const { handler } = el2[ctxKey];
        if (handler) {
          off("clickoutside", el2, handler, {
            capture: modifiers.capture
          });
        }
        el2[ctxKey].handler = void 0;
      }
    };
    function warn$2(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }
    class ZIndexManager {
      constructor() {
        this.elementZIndex = /* @__PURE__ */ new Map();
        this.nextZIndex = 2e3;
      }
      get elementCount() {
        return this.elementZIndex.size;
      }
      ensureZIndex(el2, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== void 0) {
          el2.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el2);
          return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el2)) {
          const currentZIndex = elementZIndex.get(el2);
          if (currentZIndex + 1 === this.nextZIndex)
            return;
        }
        el2.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el2, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }
      unregister(el2, zIndex) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el2)) {
          elementZIndex.delete(el2);
        } else if (zIndex === void 0) {
          warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
        }
        this.squashState();
      }
      squashState() {
        const { elementCount } = this;
        if (!elementCount) {
          this.nextZIndex = 2e3;
        }
        if (this.nextZIndex - elementCount > 2500)
          this.rearrange();
      }
      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2e3;
        elementZIndexPair.forEach((pair) => {
          const el2 = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el2.style.zIndex)
            el2.style.zIndex = `${zIndex}`;
        });
      }
    }
    const zIndexManager = new ZIndexManager();
    const ctx = "@@ziContext";
    const zindexable = {
      mounted(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        el2[ctx] = {
          enabled: !!enabled,
          initialized: false
        };
        if (enabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
      },
      updated(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el2[ctx].enabled;
        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
        el2[ctx].enabled = !!enabled;
      },
      unmounted(el2, bindings) {
        if (!el2[ctx].initialized)
          return;
        const { value = {} } = bindings;
        const { zIndex } = value;
        zIndexManager.unregister(el2, zIndex);
      }
    };
    const ssrContextKey = "@css-render/vue3-ssr";
    function createStyleString(id2, style2) {
      return `<style cssr-id="${id2}">
${style2}
</style>`;
    }
    function ssrAdapter(id2, style2, ssrContext) {
      const { styles, ids } = ssrContext;
      if (ids.has(id2))
        return;
      if (styles !== null) {
        ids.add(id2);
        styles.push(createStyleString(id2, style2));
      }
    }
    const isBrowser = typeof document !== "undefined";
    function useSsrAdapter() {
      if (isBrowser)
        return void 0;
      const context = inject(ssrContextKey, null);
      if (context === null)
        return void 0;
      return {
        adapter: (id2, style2) => ssrAdapter(id2, style2, context),
        context
      };
    }
    function warn$1(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }
    function resolveTo(selector) {
      if (typeof selector === "string") {
        return document.querySelector(selector);
      }
      return selector();
    }
    const LazyTeleport = /* @__PURE__ */ defineComponent({
      name: "LazyTeleport",
      props: {
        to: {
          type: [String, Object],
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(toRef(props, "show")),
          mergedTo: computed(() => {
            const { to: to2 } = props;
            return to2 !== null && to2 !== void 0 ? to2 : "body";
          })
        };
      },
      render() {
        return this.showTeleport ? this.disabled ? getSlot$1("lazy-teleport", this.$slots) : h(Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot$1("lazy-teleport", this.$slots)) : null;
      }
    });
    var resizeObservers = [];
    var hasActiveObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.activeTargets.length > 0;
      });
    };
    var hasSkippedObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.skippedTargets.length > 0;
      });
    };
    var msg = "ResizeObserver loop completed with undelivered notifications.";
    var deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
    var ResizeObserverBoxOptions;
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
    var freeze = function(obj) {
      return Object.freeze(obj);
    };
    var ResizeObserverSize = /* @__PURE__ */ function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
    var DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
    var isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    var isHidden = function(target) {
      if (isSVG(target)) {
        var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
        return !width && !height;
      }
      var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function(obj) {
      var _a2;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
    var global$1 = typeof window !== "undefined" ? window : {};
    var cache = /* @__PURE__ */ new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE$1 = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
    var parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    var size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs2 = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE$1 && cs2.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs2.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs2.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs2.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs2.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs2.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs2.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs2.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs2.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs2.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs2.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs2.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs2.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs2.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    var calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
    var ResizeObserverEntry = /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
    var calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
    var broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro2) {
        if (ro2.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro2.activeTargets.forEach(function processTarget(ot2) {
          var entry = new ResizeObserverEntry(ot2.target);
          var targetDepth = calculateDepthForNode(ot2.target);
          entries.push(entry);
          ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro2.callback.call(ro2.observer, entries, ro2.observer);
        });
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
      });
      for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
        var callback = callbacks_1[_i2];
        callback();
      }
      return shallowestDepth;
    };
    var gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro2) {
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
        ro2.skippedTargets.splice(0, ro2.skippedTargets.length);
        ro2.observationTargets.forEach(function processTarget(ot2) {
          if (ot2.isActive()) {
            if (calculateDepthForNode(ot2.target) > depth) {
              ro2.activeTargets.push(ot2);
            } else {
              ro2.skippedTargets.push(ot2);
            }
          }
        });
      });
    };
    var process = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
    var trigger;
    var callbacks = [];
    var notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    var queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
    var queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb);
      });
    };
    var watching = 0;
    var isWatching = function() {
      return !!watching;
    };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    var time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    var scheduler = new Scheduler();
    var updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
    var skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    var ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverDetail = /* @__PURE__ */ function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
    var observerMap = /* @__PURE__ */ new WeakMap();
    var getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot2) {
          return _this.unobserve(resizeObserver, ot2.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
        this.elHandlersMap = /* @__PURE__ */ new Map();
      }
      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);
          if (handler !== void 0) {
            handler(entry);
          }
        }
      }
      registerHandler(el2, handler) {
        this.elHandlersMap.set(el2, handler);
        this.observer.observe(el2);
      }
      unregisterHandler(el2) {
        if (!this.elHandlersMap.has(el2)) {
          return;
        }
        this.elHandlersMap.delete(el2);
        this.observer.unobserve(el2);
      }
    }
    const resizeObserverManager = new ResizeObserverDelegate();
    const VResizeObserver = /* @__PURE__ */ defineComponent({
      name: "ResizeObserver",
      props: {
        onResize: Function
      },
      setup(props) {
        let registered = false;
        const proxy = getCurrentInstance().proxy;
        function handleResize(entry) {
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        onMounted(() => {
          const el2 = proxy.$el;
          if (el2 === void 0) {
            warn$1("resize-observer", "$el does not exist.");
            return;
          }
          if (el2.nextElementSibling !== el2.nextSibling) {
            if (el2.nodeType === 3 && el2.nodeValue !== "") {
              warn$1("resize-observer", "$el can not be observed (it may be a text node).");
              return;
            }
          }
          if (el2.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el2.nextElementSibling, handleResize);
            registered = true;
          }
        });
        onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },
      render() {
        return renderSlot(this.$slots, "default");
      }
    });
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }
    function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }
      try {
        element.focus({ preventScroll: true });
      } catch (e) {
      }
      return document.activeElement === element;
    }
    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.getAttribute("disabled")) {
        return false;
      }
      switch (element.nodeName) {
        case "A":
          return !!element.href && element.rel !== "ignore";
        case "INPUT":
          return element.type !== "hidden" && element.type !== "file";
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
          return true;
        default:
          return false;
      }
    }
    let stack = [];
    const FocusTrap = /* @__PURE__ */ defineComponent({
      name: "FocusTrap",
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        const id2 = createId();
        const focusableStartRef = ref(null);
        const focusableEndRef = ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id2;
        }
        function handleDocumentKeydown(e) {
          var _a2;
          if (e.code === "Escape") {
            if (isCurrentActive()) {
              (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
            }
          }
        }
        onMounted(() => {
          watch(() => props.active, (value) => {
            if (value) {
              activate();
              on("keydown", document, handleDocumentKeydown);
            } else {
              off("keydown", document, handleDocumentKeydown);
              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          off("keydown", document, handleDocumentKeydown);
          if (activated)
            deactivate();
        });
        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (mainEl.contains(getPreciseEventTarget(e)))
              return;
            resetFocusTo("first");
          }
        }
        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null)
            return null;
          let mainEl = focusableStartEl;
          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null)
              break;
            if (mainEl instanceof Element && mainEl.tagName === "DIV") {
              break;
            }
          }
          return mainEl;
        }
        function activate() {
          var _a2;
          if (props.disabled)
            return;
          stack.push(id2);
          if (props.autoFocus) {
            const { initialFocusTo } = props;
            if (initialFocusTo === void 0) {
              resetFocusTo("first");
            } else {
              (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
            }
          }
          activated = true;
          document.addEventListener("focus", handleDocumentFocus, true);
        }
        function deactivate() {
          var _a2;
          if (props.disabled)
            return;
          document.removeEventListener("focus", handleDocumentFocus, true);
          stack = stack.filter((idInStack) => idInStack !== id2);
          if (isCurrentActive())
            return;
          const { finalFocusTo } = props;
          if (finalFocusTo !== void 0) {
            (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
        function resetFocusTo(target) {
          if (!isCurrentActive())
            return;
          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;
            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();
              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
                return;
              }
              ignoreInternalFocusChange = true;
              const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;
              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }
        function handleStartFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        function handleEndFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: "position: absolute; height: 0; width: 0;",
          handleStartFocus,
          handleEndFocus
        };
      },
      render() {
        const { default: defaultSlot } = this.$slots;
        if (defaultSlot === void 0)
          return null;
        if (this.disabled)
          return defaultSlot();
        const { active, focusableStyle } = this;
        return h(Fragment, null, [
          h("div", {
            "aria-hidden": "true",
            tabindex: active ? "0" : "-1",
            ref: "focusableStartRef",
            style: focusableStyle,
            onFocus: this.handleStartFocus
          }),
          defaultSlot(),
          h("div", {
            "aria-hidden": "true",
            style: focusableStyle,
            ref: "focusableEndRef",
            tabindex: active ? "0" : "-1",
            onFocus: this.handleEndFocus
          })
        ]);
      }
    });
    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s|\./g, "_");
    }
    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length, {
      c: c2 = 1,
      offset = 0,
      attachPx = true
    } = {}) {
      if (typeof length === "number") {
        const result = (length + offset) * c2;
        if (result === 0) return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c2;
          if (attachPx) {
            if (result === 0) return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result) return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
        }
      }
      return length;
    }
    function rtlInset(inset) {
      const {
        left,
        right,
        top,
        bottom
      } = getMargin(inset);
      return `${top} ${left} ${bottom} ${right}`;
    }
    const eventSet = /* @__PURE__ */ new WeakSet();
    function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
    }
    function warn(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }
    function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
      } else {
        return funcs(...args);
      }
    }
    function flatten(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null) return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment) {
          if (vNode.children === null) return;
          if (Array.isArray(vNode.children)) {
            flatten(vNode.children, filterCommentNode, result);
          }
        } else {
          if (vNode.type === Comment && filterCommentNode) return;
          result.push(vNode);
        }
      });
      return result;
    }
    function getSlot(instance, slotName = "default", fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0) return fallback;
      return slot();
    }
    function keysOf(obj) {
      return Object.keys(obj);
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) {
          return true;
        }
        if (child.type === Comment) {
          return false;
        }
        if (child.type === Fragment && !ensureValidVNode(child.children)) {
          return false;
        }
        return true;
      }) ? vnodes : null;
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      render() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    });
    const configProviderInjectionKey = createInjectionKey("n-config-provider");
    const defaultClsPrefix = "n";
    function useConfig(props = {}, options = {
      defaultBordered: true
    }) {
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      return {
        // NConfigProvider,
        inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
        mergedBorderedRef: computed(() => {
          var _a2, _b2;
          const {
            bordered
          } = props;
          if (bordered !== void 0) return bordered;
          return (_b2 = (_a2 = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
        }),
        mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
        namespaceRef: computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
      };
    }
    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
      const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
      const themeClassRef = ref("");
      const ssrAdapter2 = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash) finalThemeHash += `-${themeHash}`;
        if (hashValue) finalThemeHash += `-${hashValue}`;
        const {
          themeOverrides,
          builtinThemeOverrides
        } = props;
        if (themeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
        }
        if (builtinThemeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
        }
        themeClassRef.value = finalThemeHash;
        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style2 = "";
          for (const key in cssVars) {
            style2 += `${key}: ${cssVars[key]};`;
          }
          c(`.${finalThemeHash}`, style2).mount({
            id: finalThemeHash,
            ssr: ssrAdapter2,
            parent: styleMountTarget
          });
          renderCallback = void 0;
        };
      };
      watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
        }
      };
    }
    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props, {
      defaultSize = "medium",
      mergedSize,
      mergedDisabled
    } = {}) {
      const NFormItem2 = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
        const {
          size: size2
        } = props;
        if (size2) return size2;
        if (NFormItem2) {
          const {
            mergedSize: mergedSize2
          } = NFormItem2;
          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }
        return defaultSize;
      });
      const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
        const {
          disabled
        } = props;
        if (disabled !== void 0) {
          return disabled;
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      });
      const mergedStatusRef = computed(() => {
        const {
          status
        } = props;
        if (status) return status;
        return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
        if (NFormItem2) {
          NFormItem2.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur() {
          if (NFormItem2) {
            NFormItem2.handleContentBlur();
          }
        },
        nTriggerFormChange() {
          if (NFormItem2) {
            NFormItem2.handleContentChange();
          }
        },
        nTriggerFormFocus() {
          if (NFormItem2) {
            NFormItem2.handleContentFocus();
          }
        },
        nTriggerFormInput() {
          if (NFormItem2) {
            NFormItem2.handleContentInput();
          }
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$9.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$8 = Object.prototype;
    var nativeObjectToString = objectProto$8.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$1 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return false ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsZWJ$1 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      {
        return buffer.slice();
      }
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const cssrAnchorMetaName = "naive-ui-style";
    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef) return void 0;
      const ssrAdapter2 = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
        const {
          value: rtlState
        } = rtlStateRef;
        if (!rtlState) {
          return void 0;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
          return void 0;
        }
        return componentRtlState;
      });
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        watchEffect(() => {
          const {
            value: clsPrefix
          } = clsPrefixRef;
          const id2 = `${clsPrefix}${mountId}Rtl`;
          if (exists(id2, ssrAdapter2)) return;
          const {
            value: componentRtlState
          } = componentRtlStateRef;
          if (!componentRtlState) return;
          componentRtlState.style.mount({
            id: id2,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        });
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
    }
    const commonVariables$n = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      // private now, it's too small
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };
    const {
      fontSize,
      fontFamily,
      lineHeight
    } = commonVariables$n;
    const globalStyle = c("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
    function useStyle(mountId, style2, clsPrefixRef) {
      if (!style2) {
        return;
      }
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
        if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    function createTheme(theme) {
      return theme;
    }
    function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      if (style2) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          onBeforeMount(mountStyle);
        }
      }
      const mergedThemeRef = computed(() => {
        var _a2;
        const {
          theme: {
            common: selfCommon,
            self: self2,
            peers = {}
          } = {},
          themeOverrides: selfOverrides = {},
          builtinThemeOverrides: builtinOverrides = {}
        } = props;
        const {
          common: selfCommonOverrides,
          peers: peersOverrides
        } = selfOverrides;
        const {
          common: globalCommon = void 0,
          [resolveId]: {
            common: globalSelfCommon = void 0,
            self: globalSelf = void 0,
            peers: globalPeers = {}
          } = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
        const {
          common: globalCommonOverrides = void 0,
          [resolveId]: globalSelfOverrides = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
        const {
          common: globalSelfCommonOverrides,
          peers: globalPeersOverrides = {}
        } = globalSelfOverrides;
        const mergedCommon = merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = merge(
          // {}, executed every time, no need for empty obj
          (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
          builtinOverrides,
          globalSelfOverrides,
          selfOverrides
        );
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: merge({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: merge({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }
    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };
    const style$b = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c("svg", `
 height: 1em;
 width: 1em;
 `)]);
    const NBaseIcon = /* @__PURE__ */ defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$b, toRef(props, "clsPrefix"));
      },
      render() {
        return h("i", {
          class: `${this.clsPrefix}-base-icon`,
          onClick: this.onClick,
          onMousedown: this.onMousedown,
          onMouseup: this.onMouseup,
          role: this.role,
          "aria-label": this.ariaLabel,
          "aria-hidden": this.ariaHidden,
          "aria-disabled": this.ariaDisabled
        }, this.$slots);
      }
    });
    const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, {
        slots
      }) {
        const isMountedRef = isMounted();
        return () => h(Transition, {
          name: "icon-switch-transition",
          appear: isMountedRef.value
        }, slots);
      }
    });
    function replaceable(name, icon) {
      const IconComponent = /* @__PURE__ */ defineComponent({
        render() {
          return icon();
        }
      });
      return /* @__PURE__ */ defineComponent({
        name: upperFirst(name),
        setup() {
          var _a2;
          const mergedIconsRef = (_a2 = inject(configProviderInjectionKey, null)) === null || _a2 === void 0 ? void 0 : _a2.mergedIconsRef;
          return () => {
            var _a3;
            const iconOverride = (_a3 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a3 === void 0 ? void 0 : _a3[name];
            return iconOverride ? iconOverride() : h(IconComponent, null);
          };
        }
      });
    }
    const ErrorIcon = replaceable("close", () => h("svg", {
      viewBox: "0 0 12 12",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": true
    }, h("g", {
      stroke: "none",
      "stroke-width": "1",
      fill: "none",
      "fill-rule": "evenodd"
    }, h("g", {
      fill: "currentColor",
      "fill-rule": "nonzero"
    }, h("path", {
      d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
    })))));
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$n;
    function iconSwitchTransition({
      originalTransform = "",
      left = 0,
      top = 0,
      transition = `all .3s ${cubicBezierEaseInOut$3} !important`
    } = {}) {
      return [c("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: `${originalTransform} scale(0.75)`,
        left,
        top,
        opacity: 0
      }), c("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }
    const style$a = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM$1("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM$1("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM$1("round", [c("&::before", `
 border-radius: 50%;
 `)])]);
    const NBaseClose = /* @__PURE__ */ defineComponent({
      name: "BaseClose",
      props: {
        isButtonTag: {
          type: Boolean,
          default: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$a, toRef(props, "clsPrefix"));
        return () => {
          const {
            clsPrefix,
            disabled,
            absolute,
            round,
            isButtonTag
          } = props;
          const Tag = isButtonTag ? "button" : "div";
          return h(Tag, {
            type: isButtonTag ? "button" : void 0,
            tabindex: disabled || !props.focusable ? -1 : 0,
            "aria-disabled": disabled,
            "aria-label": "close",
            role: isButtonTag ? void 0 : "button",
            disabled,
            class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round && `${clsPrefix}-base-close--round`],
            onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            },
            onClick: props.onClick
          }, h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => h(ErrorIcon, null)
          }));
        };
      }
    });
    const NFadeInExpandTransition = /* @__PURE__ */ defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
      },
      setup(props, {
        slots
      }) {
        function handleBeforeLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = `${el2.offsetWidth}px`;
          } else {
            el2.style.maxHeight = `${el2.offsetHeight}px`;
          }
          void el2.offsetWidth;
        }
        function handleLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "0";
          } else {
            el2.style.maxHeight = "0";
          }
          void el2.offsetWidth;
          const {
            onLeave
          } = props;
          if (onLeave) onLeave();
        }
        function handleAfterLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            el2.style.maxHeight = "";
          }
          const {
            onAfterLeave
          } = props;
          if (onAfterLeave) onAfterLeave();
        }
        function handleEnter(el2) {
          el2.style.transition = "none";
          if (props.width) {
            const memorizedWidth = el2.offsetWidth;
            el2.style.maxWidth = "0";
            void el2.offsetWidth;
            el2.style.transition = "";
            el2.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el2.style.maxHeight = `${el2.offsetHeight}px`;
              void el2.offsetHeight;
              el2.style.transition = "";
              el2.style.maxHeight = "0";
            } else {
              const memorizedHeight = el2.offsetHeight;
              el2.style.maxHeight = "0";
              void el2.offsetWidth;
              el2.style.transition = "";
              el2.style.maxHeight = `${memorizedHeight}px`;
            }
          }
          void el2.offsetWidth;
        }
        function handleAfterEnter(el2) {
          var _a2;
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el2.style.maxHeight = "";
            }
          }
          (_a2 = props.onAfterEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        return () => {
          const {
            group,
            width,
            appear,
            mode
          } = props;
          const type = group ? TransitionGroup : Transition;
          const resolvedProps = {
            name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          };
          if (!group) {
            resolvedProps.mode = mode;
          }
          return h(type, resolvedProps, slots);
        };
      }
    });
    const style$9 = c([c("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE$1("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE$1("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("container", `
 animation: rotator 3s linear infinite both;
 `, [cE$1("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
    const duration = "1.6s";
    const exposedLoadingProps = {
      strokeWidth: {
        type: Number,
        default: 28
      },
      stroke: {
        type: String,
        default: void 0
      }
    };
    const NBaseLoading = /* @__PURE__ */ defineComponent({
      name: "BaseLoading",
      props: Object.assign({
        clsPrefix: {
          type: String,
          required: true
        },
        show: {
          type: Boolean,
          default: true
        },
        scale: {
          type: Number,
          default: 1
        },
        radius: {
          type: Number,
          default: 100
        }
      }, exposedLoadingProps),
      setup(props) {
        useStyle("-base-loading", style$9, toRef(props, "clsPrefix"));
      },
      render() {
        const {
          clsPrefix,
          radius,
          strokeWidth,
          stroke,
          scale
        } = this;
        const scaledRadius = radius / scale;
        return h("div", {
          class: `${clsPrefix}-base-loading`,
          role: "img",
          "aria-label": "loading"
        }, h(NIconSwitchTransition, null, {
          default: () => this.show ? h("div", {
            key: "icon",
            class: `${clsPrefix}-base-loading__transition-wrapper`
          }, h("div", {
            class: `${clsPrefix}-base-loading__container`
          }, h("svg", {
            class: `${clsPrefix}-base-loading__icon`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: {
              color: stroke
            }
          }, h("g", null, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("circle", {
            class: `${clsPrefix}-base-loading__icon`,
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 5.67 * radius,
            "stroke-dashoffset": 18.48 * radius
          }, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("animate", {
            attributeName: "stroke-dashoffset",
            values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          })))))) : h("div", {
            key: "placeholder",
            class: `${clsPrefix}-base-loading__placeholder`
          }, this.$slots)
        }));
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$n;
    function fadeInTransition({
      name = "fade-in",
      enterDuration = "0.2s",
      leaveDuration = "0.2s",
      enterCubicBezier = cubicBezierEaseInOut$2,
      leaveCubicBezier = cubicBezierEaseInOut$2
    } = {}) {
      return [c(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }
    const base$1 = {
      neutralBase: "#000",
      neutralInvertBase: "#fff",
      neutralTextBase: "#fff",
      neutralPopover: "rgb(72, 72, 78)",
      neutralCard: "rgb(24, 24, 28)",
      neutralModal: "rgb(44, 44, 50)",
      neutralBody: "rgb(16, 16, 20)",
      alpha1: "0.9",
      alpha2: "0.82",
      alpha3: "0.52",
      alpha4: "0.38",
      alpha5: "0.28",
      alphaClose: "0.52",
      alphaDisabled: "0.38",
      alphaDisabledInput: "0.06",
      alphaPending: "0.09",
      alphaTablePending: "0.06",
      alphaTableStriped: "0.05",
      alphaPressed: "0.05",
      alphaAvatar: "0.18",
      alphaRail: "0.2",
      alphaProgressRail: "0.12",
      alphaBorder: "0.24",
      alphaDivider: "0.09",
      alphaInput: "0.1",
      alphaAction: "0.06",
      alphaTab: "0.04",
      alphaScrollbar: "0.2",
      alphaScrollbarHover: "0.3",
      alphaCode: "0.12",
      alphaTag: "0.2",
      // primary
      primaryHover: "#7fe7c4",
      primaryDefault: "#63e2b7",
      primaryActive: "#5acea7",
      primarySuppl: "rgb(42, 148, 125)",
      // info
      infoHover: "#8acbec",
      infoDefault: "#70c0e8",
      infoActive: "#66afd3",
      infoSuppl: "rgb(56, 137, 197)",
      // error
      errorHover: "#e98b8b",
      errorDefault: "#e88080",
      errorActive: "#e57272",
      errorSuppl: "rgb(208, 58, 82)",
      // warning
      warningHover: "#f5d599",
      warningDefault: "#f2c97d",
      warningActive: "#e6c260",
      warningSuppl: "rgb(240, 138, 0)",
      // success
      successHover: "#7fe7c4",
      successDefault: "#63e2b7",
      successActive: "#5acea7",
      successSuppl: "rgb(42, 148, 125)"
    };
    const baseBackgroundRgb$1 = rgba(base$1.neutralBase);
    const baseInvertBackgroundRgb$1 = rgba(base$1.neutralInvertBase);
    const overlayPrefix$1 = `rgba(${baseInvertBackgroundRgb$1.slice(0, 3).join(", ")}, `;
    function overlay$1(alpha) {
      return `${overlayPrefix$1 + String(alpha)})`;
    }
    function neutral$1(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb$1, overlayRgba);
    }
    const derived$1 = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base$1.neutralBase,
      // primary color
      primaryColor: base$1.primaryDefault,
      primaryColorHover: base$1.primaryHover,
      primaryColorPressed: base$1.primaryActive,
      primaryColorSuppl: base$1.primarySuppl,
      // info color
      infoColor: base$1.infoDefault,
      infoColorHover: base$1.infoHover,
      infoColorPressed: base$1.infoActive,
      infoColorSuppl: base$1.infoSuppl,
      // success color
      successColor: base$1.successDefault,
      successColorHover: base$1.successHover,
      successColorPressed: base$1.successActive,
      successColorSuppl: base$1.successSuppl,
      // warning color
      warningColor: base$1.warningDefault,
      warningColorHover: base$1.warningHover,
      warningColorPressed: base$1.warningActive,
      warningColorSuppl: base$1.warningSuppl,
      // error color
      errorColor: base$1.errorDefault,
      errorColorHover: base$1.errorHover,
      errorColorPressed: base$1.errorActive,
      errorColorSuppl: base$1.errorSuppl,
      // text color
      textColorBase: base$1.neutralTextBase,
      textColor1: overlay$1(base$1.alpha1),
      textColor2: overlay$1(base$1.alpha2),
      textColor3: overlay$1(base$1.alpha3),
      // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
      // textColor5: overlay(base.alpha5),
      textColorDisabled: overlay$1(base$1.alpha4),
      placeholderColor: overlay$1(base$1.alpha4),
      placeholderColorDisabled: overlay$1(base$1.alpha5),
      iconColor: overlay$1(base$1.alpha4),
      iconColorDisabled: overlay$1(base$1.alpha5),
      iconColorHover: overlay$1(Number(base$1.alpha4) * 1.25),
      iconColorPressed: overlay$1(Number(base$1.alpha4) * 0.8),
      opacity1: base$1.alpha1,
      opacity2: base$1.alpha2,
      opacity3: base$1.alpha3,
      opacity4: base$1.alpha4,
      opacity5: base$1.alpha5,
      dividerColor: overlay$1(base$1.alphaDivider),
      borderColor: overlay$1(base$1.alphaBorder),
      // close
      closeIconColorHover: overlay$1(Number(base$1.alphaClose)),
      closeIconColor: overlay$1(Number(base$1.alphaClose)),
      closeIconColorPressed: overlay$1(Number(base$1.alphaClose)),
      closeColorHover: "rgba(255, 255, 255, .12)",
      closeColorPressed: "rgba(255, 255, 255, .08)",
      // clear
      clearColor: overlay$1(base$1.alpha4),
      clearColorHover: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 1.25
      }),
      clearColorPressed: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 0.8
      }),
      scrollbarColor: overlay$1(base$1.alphaScrollbar),
      scrollbarColorHover: overlay$1(base$1.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: overlay$1(base$1.alphaProgressRail),
      railColor: overlay$1(base$1.alphaRail),
      popoverColor: base$1.neutralPopover,
      tableColor: base$1.neutralCard,
      cardColor: base$1.neutralCard,
      modalColor: base$1.neutralModal,
      bodyColor: base$1.neutralBody,
      tagColor: neutral$1(base$1.alphaTag),
      avatarColor: overlay$1(base$1.alphaAvatar),
      invertedColor: base$1.neutralBase,
      inputColor: overlay$1(base$1.alphaInput),
      codeColor: overlay$1(base$1.alphaCode),
      tabColor: overlay$1(base$1.alphaTab),
      actionColor: overlay$1(base$1.alphaAction),
      tableHeaderColor: overlay$1(base$1.alphaAction),
      hoverColor: overlay$1(base$1.alphaPending),
      tableColorHover: overlay$1(base$1.alphaTablePending),
      tableColorStriped: overlay$1(base$1.alphaTableStriped),
      pressedColor: overlay$1(base$1.alphaPressed),
      opacityDisabled: base$1.alphaDisabled,
      inputColorDisabled: overlay$1(base$1.alphaDisabledInput),
      buttonColor2: "rgba(255, 255, 255, .08)",
      buttonColor2Hover: "rgba(255, 255, 255, .12)",
      buttonColor2Pressed: "rgba(255, 255, 255, .08)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const base = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      // disabled text, placeholder, icon
      alpha5: "0.18",
      // disabled placeholder
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaAvatar: "0.2",
      alphaProgressRail: ".08",
      alphaInput: "0",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      // primary
      primaryHover: "#36ad6a",
      primaryDefault: "#18a058",
      primaryActive: "#0c7a43",
      primarySuppl: "#36ad6a",
      // info
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      // error
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      // warning
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      // success
      successHover: "#36ad6a",
      successDefault: "#18a058",
      successActive: "#0c7a43",
      successSuppl: "#36ad6a"
    };
    const baseBackgroundRgb = rgba(base.neutralBase);
    const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
    const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
    function overlay(alpha) {
      return `${overlayPrefix + String(alpha)})`;
    }
    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }
    const derived = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base.neutralBase,
      // primary color
      primaryColor: base.primaryDefault,
      primaryColorHover: base.primaryHover,
      primaryColorPressed: base.primaryActive,
      primaryColorSuppl: base.primarySuppl,
      // info color
      infoColor: base.infoDefault,
      infoColorHover: base.infoHover,
      infoColorPressed: base.infoActive,
      infoColorSuppl: base.infoSuppl,
      // success color
      successColor: base.successDefault,
      successColorHover: base.successHover,
      successColorPressed: base.successActive,
      successColorSuppl: base.successSuppl,
      // warning color
      warningColor: base.warningDefault,
      warningColorHover: base.warningHover,
      warningColorPressed: base.warningActive,
      warningColorSuppl: base.warningSuppl,
      // error color
      errorColor: base.errorDefault,
      errorColorHover: base.errorHover,
      errorColorPressed: base.errorActive,
      errorColorSuppl: base.errorSuppl,
      // text color
      textColorBase: base.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base.alpha4),
      placeholderColor: neutral(base.alpha4),
      placeholderColorDisabled: neutral(base.alpha5),
      iconColor: neutral(base.alpha4),
      iconColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      iconColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      iconColorDisabled: neutral(base.alpha5),
      opacity1: base.alpha1,
      opacity2: base.alpha2,
      opacity3: base.alpha3,
      opacity4: base.alpha4,
      opacity5: base.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      // close
      closeIconColor: neutral(Number(base.alphaClose)),
      closeIconColorHover: neutral(Number(base.alphaClose)),
      closeIconColorPressed: neutral(Number(base.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      // clear
      clearColor: neutral(base.alpha4),
      clearColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      clearColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      scrollbarColor: overlay(base.alphaScrollbar),
      scrollbarColorHover: overlay(base.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base.neutralPopover,
      tableColor: base.neutralCard,
      cardColor: base.neutralCard,
      modalColor: base.neutralModal,
      bodyColor: base.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const commonVars$d = {
      railInsetHorizontalBottom: "auto 2px 4px 2px",
      railInsetHorizontalTop: "4px 2px auto 2px",
      railInsetVerticalRight: "2px 4px 2px auto",
      railInsetVerticalLeft: "2px auto 2px 4px",
      railColor: "transparent"
    };
    function self$S(vars) {
      const {
        scrollbarColor,
        scrollbarColorHover,
        scrollbarHeight,
        scrollbarWidth,
        scrollbarBorderRadius
      } = vars;
      return Object.assign(Object.assign({}, commonVars$d), {
        height: scrollbarHeight,
        width: scrollbarWidth,
        borderRadius: scrollbarBorderRadius,
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      });
    }
    const scrollbarLight = {
      name: "Scrollbar",
      common: derived,
      self: self$S
    };
    const scrollbarDark = {
      name: "Scrollbar",
      common: derived$1,
      self: self$S
    };
    const style$8 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c(">", [
      // We can't set overflow hidden since it affects positioning.
      cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
    ])])]), c(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM$1("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c(">", [cE$1("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM$1("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM$1("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM$1("vertical", `
 width: var(--n-scrollbar-width);
 `, [c(">", [cE$1("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM$1("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM$1("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM$1("disabled", [c(">", [cE$1("scrollbar", "pointer-events: none;")])]), c(">", [cE$1("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
    const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      // If container is set, resize observer won't not attached
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: [String, Array],
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean,
      yPlacement: {
        type: String,
        default: "right"
      },
      xPlacement: {
        type: String,
        default: "bottom"
      }
    });
    const Scrollbar = /* @__PURE__ */ defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      inheritAttrs: false,
      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = ref(null);
        const containerRef = ref(null);
        const contentRef = ref(null);
        const yRailRef = ref(null);
        const xRailRef = ref(null);
        const contentHeightRef = ref(null);
        const contentWidthRef = ref(null);
        const containerHeightRef = ref(null);
        const containerWidthRef = ref(null);
        const yRailSizeRef = ref(null);
        const xRailSizeRef = ref(null);
        const containerScrollTopRef = ref(0);
        const containerScrollLeftRef = ref(0);
        const isShowXBarRef = ref(false);
        const isShowYBarRef = ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos2 = useIsIos();
        const themeRef = useTheme("Scrollbar", "-scrollbar", style$8, scrollbarLight, props, mergedClsPrefixRef);
        const yBarSizeRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
          }
        });
        const yBarSizePxRef = computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
          }
        });
        const xBarSizePxRef = computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: containerScrollTop
          } = containerScrollTopRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff) return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: containerScrollLeft
          } = containerScrollLeftRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff) return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = computed(() => {
          const {
            container
          } = props;
          if (container) return container();
          return containerRef.value;
        });
        const mergedContentRef = computed(() => {
          const {
            content
          } = props;
          if (content) return content();
          return contentRef.value;
        });
        const scrollTo = (options, y) => {
          if (!props.scrollable) return;
          if (typeof options === "number") {
            scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
            return;
          }
          const {
            left,
            top,
            index,
            elSize,
            position,
            behavior,
            el: el2,
            debounce = true
          } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
          }
          if (el2 !== void 0) {
            scrollToPosition(0, el2.offsetTop, el2.offsetHeight, debounce, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated) return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated) return;
          const {
            onResize
          } = props;
          if (onResize) onResize(e);
          sync();
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable) return;
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (debounce) {
            const {
              scrollTop,
              offsetHeight
            } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight) ;
              else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const {
            onScroll
          } = props;
          if (onScroll) onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          }
        }
        function syncPositionState() {
          const {
            value: content
          } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable) return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          var _a2;
          return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on("mousemove", window, handleXScrollMouseMove, true);
          on("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xBarSize
          } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null) return;
          const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            const {
              internalOnUpdateScrollLeft
            } = props;
            if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on("mousemove", window, handleYScrollMouseMove, true);
          on("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yBarSize
          } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null) return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        watchEffect(() => {
          const {
            value: needXBar
          } = needXBarRef;
          const {
            value: needYBar
          } = needYBarRef;
          const {
            value: mergedClsPrefix
          } = mergedClsPrefixRef;
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
        });
        onMounted(() => {
          if (props.container) return;
          sync();
        });
        onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              color,
              colorHover,
              height,
              width,
              borderRadius,
              railInsetHorizontalTop,
              railInsetHorizontalBottom,
              railInsetVerticalRight,
              railInsetVerticalLeft,
              railColor
            }
          } = themeRef.value;
          const {
            top: railTopHorizontalTop,
            right: railRightHorizontalTop,
            bottom: railBottomHorizontalTop,
            left: railLeftHorizontalTop
          } = getMargin(railInsetHorizontalTop);
          const {
            top: railTopHorizontalBottom,
            right: railRightHorizontalBottom,
            bottom: railBottomHorizontalBottom,
            left: railLeftHorizontalBottom
          } = getMargin(railInsetHorizontalBottom);
          const {
            top: railTopVerticalRight,
            right: railRightVerticalRight,
            bottom: railBottomVerticalRight,
            left: railLeftVerticalRight
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
          const {
            top: railTopVerticalLeft,
            right: railRightVerticalLeft,
            bottom: railBottomVerticalLeft,
            left: railLeftVerticalLeft
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut2,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": borderRadius,
            "--n-scrollbar-width": width,
            "--n-scrollbar-height": height,
            "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
            "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
            "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
            "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
            "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
            "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
            "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
            "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
            "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
            "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
            "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
            "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
            "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
            "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
            "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
            "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
            "--n-scrollbar-rail-color": railColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos: isIos2,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a2;
        const {
          $slots,
          mergedClsPrefix,
          triggerDisplayManually,
          rtlEnabled,
          internalHoistYRail,
          yPlacement,
          xPlacement,
          xScrollable
        } = this;
        if (!this.scrollable) return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        const triggerIsNone = this.trigger === "none";
        const createYRail = (className, style2) => {
          return h("div", {
            ref: "yRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
            "data-scrollbar-rail": true,
            style: [style2 || "", this.verticalRailStyle],
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                height: this.yBarSizePx,
                top: this.yBarTopPx
              },
              onMousedown: this.handleYScrollMouseDown
            }) : null
          }));
        };
        const createChildren = () => {
          var _a3, _b2;
          (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
          return h("div", mergeProps(this.$attrs, {
            role: "none",
            ref: "wrapperRef",
            class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
            style: this.cssVars,
            onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
            onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
          }), [this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h("div", {
            role: "none",
            ref: "containerRef",
            class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
            style: this.containerStyle,
            onScroll: this.handleScroll,
            onWheel: this.onWheel
          }, h(VResizeObserver, {
            onResize: this.handleContentResize
          }, {
            default: () => h("div", {
              ref: "contentRef",
              role: "none",
              style: [{
                width: this.xScrollable ? "fit-content" : null
              }, this.contentStyle],
              class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
            }, $slots)
          })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && h("div", {
            ref: "xRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
            style: this.horizontalRailStyle,
            "data-scrollbar-rail": true,
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                width: this.xBarSizePx,
                right: rtlEnabled ? this.xBarLeftPx : void 0,
                left: rtlEnabled ? void 0 : this.xBarLeftPx
              },
              onMousedown: this.handleXScrollMouseDown
            }) : null
          }))]);
        };
        const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, {
          onResize: this.handleContainerResize
        }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return h(Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
        } else {
          return scrollbarNode;
        }
      }
    });
    const commonVars$c = {
      iconSizeTiny: "28px",
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };
    function self$R(vars) {
      const {
        textColorDisabled,
        iconColor,
        textColor2,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVars$c), {
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      });
    }
    const emptyLight = {
      name: "Empty",
      common: derived,
      self: self$R
    };
    const emptyDark = {
      name: "Empty",
      common: derived$1,
      self: self$R
    };
    const commonVariables$m = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingTiny: "4px 0",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingTiny: "0 12px",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };
    function self$Q(vars) {
      const {
        borderRadius,
        popoverColor,
        textColor3,
        dividerColor,
        textColor2,
        primaryColorPressed,
        textColorDisabled,
        primaryColor,
        opacityDisabled,
        hoverColor,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$m), {
        optionFontSizeTiny: fontSizeTiny,
        optionFontSizeSmall: fontSizeSmall,
        optionFontSizeMedium: fontSizeMedium,
        optionFontSizeLarge: fontSizeLarge,
        optionFontSizeHuge: fontSizeHuge,
        optionHeightTiny: heightTiny,
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        color: popoverColor,
        groupHeaderTextColor: textColor3,
        actionDividerColor: dividerColor,
        optionTextColor: textColor2,
        optionTextColorPressed: primaryColorPressed,
        optionTextColorDisabled: textColorDisabled,
        optionTextColorActive: primaryColor,
        optionOpacityDisabled: opacityDisabled,
        optionCheckColor: primaryColor,
        optionColorPending: hoverColor,
        optionColorActive: "rgba(0, 0, 0, 0)",
        optionColorActivePending: hoverColor,
        actionTextColor: textColor2,
        loadingColor: primaryColor
      });
    }
    const internalSelectMenuDark = {
      name: "InternalSelectMenu",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self: self$Q
    };
    const commonVariables$l = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };
    function self$P(vars) {
      const {
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        fontSize: fontSize2,
        dividerColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$l), {
        fontSize: fontSize2,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const popoverDark = {
      name: "Popover",
      common: derived$1,
      self: self$P
    };
    const commonVariables$k = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px"
    };
    const tagDark = {
      name: "Tag",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          primaryColorHover,
          primaryColorPressed,
          primaryColor,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          baseColor,
          borderColor,
          tagColor,
          opacityDisabled,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderRadiusSmall: borderRadius,
          fontSizeMini,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          heightMini,
          heightTiny,
          heightSmall,
          heightMedium,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$k), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          // checked
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          // default
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "#0000",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          colorBorderedPrimary: "#0000",
          closeIconColorPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorHoverPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorPressedPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeColorHoverPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          closeColorPressedPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          borderInfo: `1px solid ${changeColor(infoColor, {
            alpha: 0.3
          })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          colorBorderedInfo: "#0000",
          closeIconColorInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorHoverInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorPressedInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeColorHoverInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          closeColorPressedInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          borderSuccess: `1px solid ${changeColor(successColor, {
            alpha: 0.3
          })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          colorBorderedSuccess: "#0000",
          closeIconColorSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorHoverSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorPressedSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeColorHoverSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          closeColorPressedSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          borderWarning: `1px solid ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          colorBorderedWarning: "#0000",
          closeIconColorWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorHoverWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorPressedWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeColorHoverWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          closeColorPressedWarning: changeColor(warningColor, {
            alpha: 0.11
          }),
          borderError: `1px solid ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, {
            alpha: 0.16
          }),
          colorBorderedError: "#0000",
          closeIconColorError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorHoverError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorPressedError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeColorHoverError: changeColor(errorColor, {
            alpha: 0.16
          }),
          closeColorPressedError: changeColor(errorColor, {
            alpha: 0.12
          })
        });
      }
    };
    const commonVariables$j = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };
    const internalSelectionDark = {
      name: "InternalSelection",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          textColor2,
          textColorDisabled,
          inputColor,
          inputColorDisabled,
          primaryColor,
          primaryColorHover,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          iconColor,
          iconColorDisabled,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$j), {
          fontWeight,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          // default
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: changeColor(primaryColor, {
            alpha: 0.1
          }),
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          // warning
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          colorActiveWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          caretColorWarning: warningColor,
          // error
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          colorActiveError: changeColor(errorColor, {
            alpha: 0.1
          }),
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      }
    };
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1
    } = commonVariables$n;
    function fadeInWidthExpandTransition({
      duration: duration2 = ".2s",
      delay = ".1s"
    } = {}) {
      return [c("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1},
 max-width ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-left ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-right ${duration2} ${cubicBezierEaseInOut$1} ${delay};
 `), c("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 max-width ${duration2} ${cubicBezierEaseInOut$1},
 margin-left ${duration2} ${cubicBezierEaseInOut$1},
 margin-right ${duration2} ${cubicBezierEaseInOut$1};
 `)];
    }
    const style$7 = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
    const NBaseWave = /* @__PURE__ */ defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$7, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const activeRef = ref(false);
        let animationTimerId = null;
        onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void nextTick(() => {
              var _a2;
              void ((_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight);
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const {
          clsPrefix
        } = this;
        return h("div", {
          ref: "selfRef",
          "aria-hidden": true,
          class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
        });
      }
    });
    const commonVars$b = {
      iconMargin: "11px 8px 0 12px",
      iconMarginRtl: "11px 12px 0 8px",
      iconSize: "24px",
      closeIconSize: "16px",
      closeSize: "20px",
      closeMargin: "13px 14px 0 0",
      closeMarginRtl: "13px 0 0 14px",
      padding: "13px"
    };
    const alertDark = {
      name: "Alert",
      common: derived$1,
      self(vars) {
        const {
          lineHeight: lineHeight2,
          borderRadius,
          fontWeightStrong,
          dividerColor,
          inputColor,
          textColor1,
          textColor2,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$b), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: inputColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${changeColor(infoColorSuppl, {
            alpha: 0.35
          })}`,
          colorInfo: changeColor(infoColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColorSuppl,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${changeColor(successColorSuppl, {
            alpha: 0.35
          })}`,
          colorSuccess: changeColor(successColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColorSuppl,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${changeColor(warningColorSuppl, {
            alpha: 0.35
          })}`,
          colorWarning: changeColor(warningColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColorSuppl,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${changeColor(errorColorSuppl, {
            alpha: 0.35
          })}`,
          colorError: changeColor(errorColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorError: textColor1,
          iconColorError: errorColorSuppl,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        });
      }
    };
    const commonVars$a = {
      linkFontSize: "13px",
      linkPadding: "0 0 0 16px",
      railWidth: "4px"
    };
    function self$O(vars) {
      const {
        borderRadius,
        railColor,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$a), {
        borderRadius,
        railColor,
        railColorActive: primaryColor,
        linkColor: changeColor(primaryColor, {
          alpha: 0.15
        }),
        linkTextColor: textColor2,
        linkTextColorHover: primaryColorHover,
        linkTextColorPressed: primaryColorPressed,
        linkTextColorActive: primaryColor
      });
    }
    const anchorDark = {
      name: "Anchor",
      common: derived$1,
      self: self$O
    };
    const isChrome = isBrowser$1 && "chrome" in window;
    isBrowser$1 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$1 && navigator.userAgent.includes("Safari") && !isChrome;
    const commonVariables$i = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };
    const inputDark = {
      name: "Input",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          textColor3,
          textColorDisabled,
          primaryColor,
          primaryColorHover,
          inputColor,
          inputColorDisabled,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderRadius,
          lineHeight: lineHeight2,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$i), {
          fontWeight,
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: inputColor,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          groupLabelTextColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: changeColor(primaryColor, {
            alpha: 0.1
          }),
          groupLabelBorder: "1px solid #0000",
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: "1px solid #0000",
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          loadingColor: primaryColor,
          // warning
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          caretColorWarning: warningColor,
          // error
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: changeColor(errorColor, {
            alpha: 0.1
          }),
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      }
    };
    function self$N(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const autoCompleteDark = {
      name: "AutoComplete",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self: self$N
    };
    function self$M(vars) {
      const {
        borderRadius,
        avatarColor,
        cardColor,
        fontSize: fontSize2,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        modalColor,
        popoverColor
      } = vars;
      return {
        borderRadius,
        fontSize: fontSize2,
        border: `2px solid ${cardColor}`,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        color: composite(cardColor, avatarColor),
        colorModal: composite(modalColor, avatarColor),
        colorPopover: composite(popoverColor, avatarColor)
      };
    }
    const avatarDark = {
      name: "Avatar",
      common: derived$1,
      self: self$M
    };
    function self$L() {
      return {
        gap: "-12px"
      };
    }
    const avatarGroupDark = {
      name: "AvatarGroup",
      common: derived$1,
      peers: {
        Avatar: avatarDark
      },
      self: self$L
    };
    const commonVariables$h = {
      width: "44px",
      height: "44px",
      borderRadius: "22px",
      iconSize: "26px"
    };
    const backTopDark = {
      name: "BackTop",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          primaryColorHover,
          primaryColorPressed
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$h), {
          color: popoverColor,
          textColor: textColor2,
          iconColor: textColor2,
          iconColorHover: primaryColorHover,
          iconColorPressed: primaryColorPressed,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
        });
      }
    };
    const badgeDark = {
      name: "Badge",
      common: derived$1,
      self(vars) {
        const {
          errorColorSuppl,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          fontFamily: fontFamily2
        } = vars;
        return {
          color: errorColorSuppl,
          colorInfo: infoColorSuppl,
          colorSuccess: successColorSuppl,
          colorError: errorColorSuppl,
          colorWarning: warningColorSuppl,
          fontSize: "12px",
          fontFamily: fontFamily2
        };
      }
    };
    const commonVariables$g = {
      fontWeightActive: "400"
    };
    function self$K(vars) {
      const {
        fontSize: fontSize2,
        textColor3,
        textColor2,
        borderRadius,
        buttonColor2Hover,
        buttonColor2Pressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$g), {
        fontSize: fontSize2,
        itemLineHeight: "1.25",
        itemTextColor: textColor3,
        itemTextColorHover: textColor2,
        itemTextColorPressed: textColor2,
        itemTextColorActive: textColor2,
        itemBorderRadius: borderRadius,
        itemColorHover: buttonColor2Hover,
        itemColorPressed: buttonColor2Pressed,
        separatorColor: textColor3
      });
    }
    const breadcrumbDark = {
      name: "Breadcrumb",
      common: derived$1,
      self: self$K
    };
    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }
    const buttonGroupInjectionKey = createInjectionKey("n-button-group");
    const commonVariables$f = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };
    function self$J(vars) {
      const {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        textColor2,
        textColor3,
        primaryColorHover,
        primaryColorPressed,
        borderColor,
        primaryColor,
        baseColor,
        infoColor,
        infoColorHover,
        infoColorPressed,
        successColor,
        successColorHover,
        successColorPressed,
        warningColor,
        warningColorHover,
        warningColorPressed,
        errorColor,
        errorColorHover,
        errorColorPressed,
        fontWeight,
        buttonColor2,
        buttonColor2Hover,
        buttonColor2Pressed,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$f), {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        // secondary
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        // tertiary
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        // quaternary
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        // default type
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        // primary
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        // info
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        // success
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        // warning
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        // error
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      });
    }
    const buttonLight = {
      common: derived,
      self: self$J
    };
    const buttonDark = {
      name: "Button",
      common: derived$1,
      self(vars) {
        const commonSelf = self$J(vars);
        commonSelf.waveOpacity = "0.8";
        commonSelf.colorOpacitySecondary = "0.16";
        commonSelf.colorOpacitySecondaryHover = "0.2";
        commonSelf.colorOpacitySecondaryPressed = "0.12";
        return commonSelf;
      }
    };
    const style$6 = c([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM$1("color", [cE$1("border", {
      borderColor: "var(--n-border-color)"
    }), cM$1("disabled", [cE$1("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c("&:focus", [cE$1("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c("&:hover", [cE$1("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c("&:active", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM$1("pressed", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM$1("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE$1("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE$1("state-border", {
      border: "var(--n-border-focus)"
    })]), c("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE$1("state-border", {
      border: "var(--n-border-hover)"
    })]), c("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM$1("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM$1("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM$1("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$1 && "MozBoxSizing" in document.createElement("div").style ? c("&::moz-focus-inner", {
      border: 0
    }) : null, cE$1("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE$1("border", {
      border: "var(--n-border)"
    }), cE$1("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE$1("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE$1("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c("~", [cE$1("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM$1("block", `
 display: flex;
 width: 100%;
 `), cM$1("dashed", [cE$1("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM$1("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        // don't use exact 5px since chrome will display the animation with glitches
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);
    const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
      color: String,
      textColor: String,
      text: Boolean,
      block: Boolean,
      loading: Boolean,
      disabled: Boolean,
      circle: Boolean,
      size: String,
      ghost: Boolean,
      round: Boolean,
      secondary: Boolean,
      tertiary: Boolean,
      quaternary: Boolean,
      strong: Boolean,
      focusable: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      tag: {
        type: String,
        default: "button"
      },
      type: {
        type: String,
        default: "default"
      },
      dashed: Boolean,
      renderIcon: Function,
      iconPlacement: {
        type: String,
        default: "left"
      },
      attrType: {
        type: String,
        default: "button"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      onClick: [Function, Array],
      nativeFocusBehavior: {
        type: Boolean,
        default: !isSafari
      }
    });
    const Button = /* @__PURE__ */ defineComponent({
      name: "Button",
      props: buttonProps,
      slots: Object,
      setup(props) {
        const selfElRef = ref(null);
        const waveElRef = ref(null);
        const enterPressedRef = ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup = inject(buttonGroupInjectionKey, {});
        const {
          mergedSizeRef
        } = useFormItem({}, {
          defaultSize: "medium",
          mergedSize: (NFormItem2) => {
            const {
              size: size2
            } = props;
            if (size2) return size2;
            const {
              size: buttonGroupSize
            } = NButtonGroup;
            if (buttonGroupSize) return buttonGroupSize;
            const {
              mergedSize: formItemSize2
            } = NFormItem2 || {};
            if (formItemSize2) {
              return formItemSize2.value;
            }
            return "medium";
          }
        });
        const mergedFocusableRef = computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          var _a2;
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            (_a2 = selfElRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus({
              preventScroll: true
            });
          }
        };
        const handleClick = (e) => {
          var _a2;
          if (!props.disabled && !props.loading) {
            const {
              onClick
            } = props;
            if (onClick) call(onClick, e);
            if (!props.text) {
              (_a2 = waveElRef.value) === null || _a2 === void 0 ? void 0 : _a2.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Button", "-button", style$6, buttonLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const theme = themeRef.value;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: self2
          } = theme;
          const {
            rippleDuration,
            opacityDisabled,
            fontWeight,
            fontWeightStrong
          } = self2;
          const size2 = mergedSizeRef.value;
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          const fontProps = {
            "--n-font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type === "tertiary";
          const typeIsDefault = type === "default";
          const mergedType = typeIsTertiary ? "default" : type;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type !== "default" && type !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondary)
              }) : self2.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryPressed)
              }) : self2.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-disabled": self2.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self2.colorTertiary;
              colorProps["--n-color-hover"] = self2.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self2.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self2.colorTertiary;
            } else {
              colorProps["--n-color"] = self2.colorQuaternary;
              colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self2.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self2[createKey("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
              "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self2[createKey("border", mergedType)],
              "--n-border-hover": self2[createKey("borderHover", mergedType)],
              "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
              "--n-border-focus": self2[createKey("borderFocus", mergedType)],
              "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
            };
          }
          const {
            [createKey("height", size2)]: height,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("padding", size2)]: padding,
            [createKey("paddingRound", size2)]: paddingRound,
            [createKey("iconSize", size2)]: iconSize,
            [createKey("borderRadius", size2)]: borderRadius,
            [createKey("iconMargin", size2)]: iconMargin,
            waveOpacity
          } = self2;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize2,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-ease-out": cubicBezierEaseOut2,
            "--n-ripple-duration": rippleDuration,
            "--n-opacity-disabled": opacityDisabled,
            "--n-wave-opacity": waveOpacity
          }, fontProps), colorProps), borderProps), sizeProps);
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
          let hash = "";
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          if (dashed) hash += "a";
          if (ghost) hash += "b";
          if (text) hash += "c";
          if (round) hash += "d";
          if (circle) hash += "e";
          if (secondary) hash += "f";
          if (tertiary) hash += "g";
          if (quaternary) hash += "h";
          if (strong) hash += "i";
          if (color) hash += `j${color2Class(color)}`;
          if (textColor) hash += `k${color2Class(textColor)}`;
          const {
            value: size2
          } = mergedSizeRef;
          hash += `l${size2[0]}`;
          hash += `m${type[0]}`;
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: computed(() => {
            const {
              color
            } = props;
            if (!color) return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          tag: Component,
          onRender
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", {
          class: `${mergedClsPrefix}-button__content`
        }, children2));
        return h(Component, {
          ref: "selfElRef",
          class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
            // required for button group border collapse
          ],
          tabindex: this.mergedFocusable ? 0 : -1,
          type: this.attrType,
          style: this.cssVars,
          disabled: this.disabled,
          onClick: this.handleClick,
          onBlur: this.handleBlur,
          onMousedown: this.handleMousedown,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, this.iconPlacement === "right" && children, h(NFadeInExpandTransition, {
          width: true
        }, {
          default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h("span", {
            class: `${mergedClsPrefix}-button__icon`,
            style: {
              margin: isSlotEmpty(this.$slots.default) ? "0" : ""
            }
          }, h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              clsPrefix: mergedClsPrefix,
              key: "loading",
              class: `${mergedClsPrefix}-icon-slot`,
              strokeWidth: 20
            }) : h("div", {
              key: "icon",
              class: `${mergedClsPrefix}-icon-slot`,
              role: "none"
            }, this.renderIcon ? this.renderIcon() : children2)
          })))
        }), this.iconPlacement === "left" && children, !this.text ? h(NBaseWave, {
          ref: "waveElRef",
          clsPrefix: mergedClsPrefix
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__border`,
          style: this.customColorCssVars
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__state-border`,
          style: this.customColorCssVars
        }) : null);
      }
    });
    const commonVariables$e = {
      titleFontSize: "22px"
    };
    function self$I(vars) {
      const {
        borderRadius,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        textColor2,
        textColor1,
        textColorDisabled,
        dividerColor,
        fontWeightStrong,
        primaryColor,
        baseColor,
        hoverColor,
        cardColor,
        modalColor,
        popoverColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$e), {
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        textColor: textColor2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        dayTextColor: textColorDisabled,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        dateColorCurrent: primaryColor,
        dateTextColorCurrent: baseColor,
        cellColorHover: composite(cardColor, hoverColor),
        cellColorHoverModal: composite(modalColor, hoverColor),
        cellColorHoverPopover: composite(popoverColor, hoverColor),
        cellColor: cardColor,
        cellColorModal: modalColor,
        cellColorPopover: popoverColor,
        barColor: primaryColor
      });
    }
    const calendarDark = {
      name: "Calendar",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$I
    };
    const commonVariables$d = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };
    function self$H(vars) {
      const {
        primaryColor,
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        cardColor,
        textColor2,
        textColor1,
        dividerColor,
        fontWeightStrong,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        modalColor,
        boxShadow1,
        popoverColor,
        actionColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$d), {
        lineHeight: lineHeight2,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        colorEmbeddedModal: actionColor,
        colorEmbeddedPopover: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize2,
        fontSizeMedium: fontSize2,
        fontSizeLarge: fontSize2,
        fontSizeHuge: fontSize2,
        boxShadow: boxShadow1,
        borderRadius
      });
    }
    const cardDark = {
      name: "Card",
      common: derived$1,
      self(vars) {
        const commonSelf = self$H(vars);
        const {
          cardColor,
          modalColor,
          popoverColor
        } = vars;
        commonSelf.colorEmbedded = cardColor;
        commonSelf.colorEmbeddedModal = modalColor;
        commonSelf.colorEmbeddedPopover = popoverColor;
        return commonSelf;
      }
    };
    function self$G() {
      return {
        dotSize: "8px",
        dotColor: "rgba(255, 255, 255, .3)",
        dotColorActive: "rgba(255, 255, 255, 1)",
        dotColorFocus: "rgba(255, 255, 255, .5)",
        dotLineWidth: "16px",
        dotLineWidthActive: "24px",
        arrowColor: "#eee"
      };
    }
    const carouselDark = {
      name: "Carousel",
      common: derived$1,
      self: self$G
    };
    const commonVariables$c = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    function self$F(vars) {
      const {
        baseColor,
        inputColorDisabled,
        cardColor,
        modalColor,
        popoverColor,
        textColorDisabled,
        borderColor,
        primaryColor,
        textColor2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadiusSmall,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), {
        labelLineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        textColor: textColor2,
        textColorDisabled
      });
    }
    const checkboxDark = {
      name: "Checkbox",
      common: derived$1,
      self(vars) {
        const {
          cardColor
        } = vars;
        const commonSelf = self$F(vars);
        commonSelf.color = "#0000";
        commonSelf.checkMarkColor = cardColor;
        return commonSelf;
      }
    };
    function self$E(vars) {
      const {
        borderRadius,
        boxShadow2,
        popoverColor,
        textColor2,
        textColor3,
        primaryColor,
        textColorDisabled,
        dividerColor,
        hoverColor,
        fontSizeMedium,
        heightMedium
      } = vars;
      return {
        menuBorderRadius: borderRadius,
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuDividerColor: dividerColor,
        menuHeight: "calc(var(--n-option-height) * 6.6)",
        optionArrowColor: textColor3,
        optionHeight: heightMedium,
        optionFontSize: fontSizeMedium,
        optionColorHover: hoverColor,
        optionTextColor: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorDisabled: textColorDisabled,
        optionCheckMarkColor: primaryColor,
        loadingColor: primaryColor,
        columnWidth: "180px"
      };
    }
    const cascaderDark = {
      name: "Cascader",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        InternalSelection: internalSelectionDark,
        Scrollbar: scrollbarDark,
        Checkbox: checkboxDark,
        Empty: emptyLight
      },
      self: self$E
    };
    const codeDark = {
      name: "Code",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          textColor3
        } = vars;
        return {
          textColor: textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          // extracted from hljs atom-one-dark.scss
          "mono-3": "#5c6370",
          "hue-1": "#56b6c2",
          "hue-2": "#61aeee",
          "hue-3": "#c678dd",
          "hue-4": "#98c379",
          "hue-5": "#e06c75",
          "hue-5-2": "#be5046",
          "hue-6": "#d19a66",
          "hue-6-2": "#e6c07b",
          // line-number styles
          lineNumberTextColor: textColor3
        };
      }
    };
    function self$D(vars) {
      const {
        fontWeight,
        textColor1,
        textColor2,
        textColorDisabled,
        dividerColor,
        fontSize: fontSize2
      } = vars;
      return {
        titleFontSize: fontSize2,
        titleFontWeight: fontWeight,
        dividerColor,
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        fontSize: fontSize2,
        textColor: textColor2,
        arrowColor: textColor2,
        arrowColorDisabled: textColorDisabled,
        itemMargin: "16px 0 0 0",
        titlePadding: "16px 0 0 0"
      };
    }
    const collapseDark = {
      name: "Collapse",
      common: derived$1,
      self: self$D
    };
    function self$C(vars) {
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut2
      } = vars;
      return {
        bezier: cubicBezierEaseInOut2
      };
    }
    const collapseTransitionDark = {
      name: "CollapseTransition",
      common: derived$1,
      self: self$C
    };
    function self$B(vars) {
      const {
        fontSize: fontSize2,
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        borderColor,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      } = vars;
      return {
        panelFontSize: fontSize2,
        boxShadow: boxShadow2,
        color: popoverColor,
        textColor: textColor2,
        borderRadius,
        border: `1px solid ${borderColor}`,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      };
    }
    const colorPickerDark = {
      name: "ColorPicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self: self$B
    };
    const configProviderProps = {
      abstract: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: String,
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
        type: String,
        default: "div"
      },
      hljs: Object,
      katex: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      styleMountTarget: Object,
      inlineThemeDisabled: {
        type: Boolean,
        default: void 0
      },
      // deprecated
      as: {
        type: String,
        validator: () => {
          warn("config-provider", "`as` is deprecated, please use `tag` instead.");
          return true;
        },
        default: void 0
      }
    };
    const NConfigProvider = /* @__PURE__ */ defineComponent({
      name: "ConfigProvider",
      alias: ["App"],
      props: configProviderProps,
      setup(props) {
        const NConfigProvider2 = inject(configProviderInjectionKey, null);
        const mergedThemeRef = computed(() => {
          const {
            theme
          } = props;
          if (theme === null) return void 0;
          const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
          return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = computed(() => {
          const {
            themeOverrides
          } = props;
          if (themeOverrides === null) return void 0;
          if (themeOverrides === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
          } else {
            const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            if (inheritedThemeOverrides === void 0) {
              return themeOverrides;
            } else {
              return merge({}, inheritedThemeOverrides, themeOverrides);
            }
          }
        });
        const mergedNamespaceRef = useMemo(() => {
          const {
            namespace: namespace2
          } = props;
          return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
        });
        const mergedBorderedRef = useMemo(() => {
          const {
            bordered
          } = props;
          return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
        });
        const mergedIconsRef = computed(() => {
          const {
            icons
          } = props;
          return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = computed(() => {
          const {
            componentOptions
          } = props;
          if (componentOptions !== void 0) return componentOptions;
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = computed(() => {
          const {
            clsPrefix
          } = props;
          if (clsPrefix !== void 0) return clsPrefix;
          if (NConfigProvider2) return NConfigProvider2.mergedClsPrefixRef.value;
          return defaultClsPrefix;
        });
        const mergedRtlRef = computed(() => {
          var _a2;
          const {
            rtl
          } = props;
          if (rtl === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
          }
          const rtlEnabledState = {};
          for (const rtlInfo of rtl) {
            rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
            (_a2 = rtlInfo.peers) === null || _a2 === void 0 ? void 0 : _a2.forEach((peerRtlInfo) => {
              if (!(peerRtlInfo.name in rtlEnabledState)) {
                rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
              }
            });
          }
          return rtlEnabledState;
        });
        const mergedBreakpointsRef = computed(() => {
          return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
        });
        const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
        const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
        const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
        const mergedThemeHashRef = computed(() => {
          const {
            value: theme
          } = mergedThemeRef;
          const {
            value: mergedThemeOverrides
          } = mergedThemeOverridesRef;
          const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
          const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
          if (themeName) {
            if (hasThemeOverrides) {
              return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
            }
            return themeName;
          } else {
            if (hasThemeOverrides) {
              return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
            }
            return "";
          }
        });
        provide(configProviderInjectionKey, {
          mergedThemeHashRef,
          mergedBreakpointsRef,
          mergedRtlRef,
          mergedIconsRef,
          mergedComponentPropsRef,
          mergedBorderedRef,
          mergedNamespaceRef,
          mergedClsPrefixRef,
          mergedLocaleRef: computed(() => {
            const {
              locale
            } = props;
            if (locale === null) return void 0;
            return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
          }),
          mergedDateLocaleRef: computed(() => {
            const {
              dateLocale
            } = props;
            if (dateLocale === null) return void 0;
            return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
          }),
          mergedHljsRef: computed(() => {
            const {
              hljs
            } = props;
            return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
          }),
          mergedKatexRef: computed(() => {
            const {
              katex
            } = props;
            return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
          }),
          mergedThemeRef,
          mergedThemeOverridesRef,
          inlineThemeDisabled: inlineThemeDisabled || false,
          preflightStyleDisabled: preflightStyleDisabled || false,
          styleMountTarget
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedNamespace: mergedNamespaceRef,
          mergedTheme: mergedThemeRef,
          mergedThemeOverrides: mergedThemeOverridesRef
        };
      },
      render() {
        var _a2, _b2, _c2, _d2;
        return !this.abstract ? h(this.as || this.tag, {
          class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
        }, (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) : (_d2 = (_c2 = this.$slots).default) === null || _d2 === void 0 ? void 0 : _d2.call(_c2);
      }
    });
    const popselect = {
      name: "Popselect",
      common: derived$1,
      peers: {
        Popover: popoverDark,
        InternalSelectMenu: internalSelectMenuDark
      }
    };
    function self$A(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectDark = {
      name: "Select",
      common: derived$1,
      peers: {
        InternalSelection: internalSelectionDark,
        InternalSelectMenu: internalSelectMenuDark
      },
      self: self$A
    };
    const commonVariables$b = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };
    function self$z(vars) {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        // item font size
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        // item size
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), {
        buttonColor: "#0000",
        buttonColorHover: "#0000",
        buttonColorPressed: "#0000",
        buttonBorder: `1px solid ${borderColor}`,
        buttonBorderHover: `1px solid ${borderColor}`,
        buttonBorderPressed: `1px solid ${borderColor}`,
        buttonIconColor: textColor2,
        buttonIconColorHover: textColor2,
        buttonIconColorPressed: textColor2,
        itemTextColor: textColor2,
        itemTextColorHover: primaryColorHover,
        itemTextColorPressed: primaryColorPressed,
        itemTextColorActive: primaryColor,
        itemTextColorDisabled: textColorDisabled,
        itemColor: "#0000",
        itemColorHover: "#0000",
        itemColorPressed: "#0000",
        itemColorActive: "#0000",
        itemColorActiveHover: "#0000",
        itemColorDisabled: inputColorDisabled,
        itemBorder: "1px solid #0000",
        itemBorderHover: "1px solid #0000",
        itemBorderPressed: "1px solid #0000",
        itemBorderActive: `1px solid ${primaryColor}`,
        itemBorderDisabled: `1px solid ${borderColor}`,
        itemBorderRadius: borderRadius,
        itemSizeSmall: heightTiny,
        itemSizeMedium: heightSmall,
        itemSizeLarge: heightMedium,
        itemFontSizeSmall: fontSizeTiny,
        itemFontSizeMedium: fontSizeSmall,
        itemFontSizeLarge: fontSizeMedium,
        jumperFontSizeSmall: fontSizeTiny,
        jumperFontSizeMedium: fontSizeSmall,
        jumperFontSizeLarge: fontSizeMedium,
        jumperTextColor: textColor2,
        jumperTextColorDisabled: textColorDisabled
      });
    }
    const paginationDark = {
      name: "Pagination",
      common: derived$1,
      peers: {
        Select: selectDark,
        Input: inputDark,
        Popselect: popselect
      },
      self(vars) {
        const {
          primaryColor,
          opacity3
        } = vars;
        const borderColorActive = changeColor(primaryColor, {
          alpha: Number(opacity3)
        });
        const commonSelf = self$z(vars);
        commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
        commonSelf.itemBorderDisabled = "1px solid #0000";
        return commonSelf;
      }
    };
    const commonVariables$a = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };
    function self$y(vars) {
      const {
        primaryColor,
        textColor2,
        dividerColor,
        hoverColor,
        popoverColor,
        invertedColor,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        textColor3,
        opacityDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), {
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        // non-inverted
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        groupHeaderTextColor: textColor3,
        // inverted
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      });
    }
    const dropdownDark = {
      name: "Dropdown",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          primaryColorSuppl,
          primaryColor,
          popoverColor
        } = vars;
        const commonSelf = self$y(vars);
        commonSelf.colorInverted = popoverColor;
        commonSelf.optionColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.optionColorActiveInverted = primaryColorSuppl;
        commonSelf.optionColorHoverInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const commonVars$9 = {
      padding: "8px 14px"
    };
    const tooltipDark = {
      name: "Tooltip",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          boxShadow2,
          popoverColor,
          textColor2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$9), {
          borderRadius,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2
        });
      }
    };
    const ellipsisDark = {
      name: "Ellipsis",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      }
    };
    const commonVariables$9 = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const radioDark = {
      name: "Radio",
      common: derived$1,
      self(vars) {
        const {
          borderColor,
          primaryColor,
          baseColor,
          textColorDisabled,
          inputColorDisabled,
          textColor2,
          opacityDisabled,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightSmall,
          heightMedium,
          heightLarge,
          lineHeight: lineHeight2
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$9), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: "#0000",
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: primaryColor,
          buttonColor: "#0000",
          buttonColorActive: primaryColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: baseColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      }
    };
    function self$x(vars) {
      const {
        borderColor,
        primaryColor,
        baseColor,
        textColorDisabled,
        inputColorDisabled,
        textColor2,
        opacityDisabled,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightSmall,
        heightMedium,
        heightLarge,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), {
        labelLineHeight: lineHeight2,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        colorActive: "#0000",
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      });
    }
    const radioLight = {
      common: derived,
      self: self$x
    };
    const commonVariables$8 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      resizableContainerSize: "8px",
      resizableSize: "2px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };
    function self$w(vars) {
      const {
        cardColor,
        modalColor,
        popoverColor,
        textColor2,
        textColor1,
        tableHeaderColor,
        tableColorHover,
        iconColor,
        primaryColor,
        fontWeightStrong,
        borderRadius,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor,
        heightSmall,
        opacityDisabled,
        tableColorStriped
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), {
        actionDividerColor: dividerColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorSorting: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        thColorSorting: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        // modal
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorSortingModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        thColorSortingModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        // popover
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorSortingPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        thColorSortingPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        // loading
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      });
    }
    const dataTableDark = {
      name: "DataTable",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Checkbox: checkboxDark,
        Radio: radioDark,
        Pagination: paginationDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark,
        Popover: popoverDark,
        Ellipsis: ellipsisDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const commonSelf = self$w(vars);
        commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
        commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
        return commonSelf;
      }
    };
    const style$5 = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM$1("checked", [cE$1("dot", `
 background-color: var(--n-color-active);
 `)]), cE$1("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE$1("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM$1("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE$1("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM$1("disabled", `
 cursor: not-allowed;
 `, [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM$1("checked", `
 opacity: 1;
 `)]), cE$1("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
    const radioBaseProps = {
      name: String,
      value: {
        type: [String, Number, Boolean],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      // deprecated
      checkedValue: {
        type: Boolean,
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");
    function setup(props) {
      const NRadioGroup2 = inject(radioGroupInjectionKey, null);
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const {
            size: size2
          } = props;
          if (size2 !== void 0) return size2;
          if (NRadioGroup2) {
            const {
              mergedSizeRef: {
                value: mergedSize
              }
            } = NRadioGroup2;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            return NFormItem2.mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          if (props.disabled) return true;
          if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value) return true;
          if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value) return true;
          return false;
        }
      });
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup2) return NRadioGroup2.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const {
          name
        } = props;
        if (name !== void 0) return name;
        if (NRadioGroup2) return NRadioGroup2.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
        if (NRadioGroup2) {
          const {
            doUpdateValue
          } = NRadioGroup2;
          const {
            value
          } = props;
          call(doUpdateValue, value);
        } else {
          const {
            onUpdateChecked,
            "onUpdate:checked": _onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (onUpdateChecked) call(onUpdateChecked, true);
          if (_onUpdateChecked) call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }
      function toggle() {
        if (mergedDisabledRef.value) return;
        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }
      function handleRadioInputChange() {
        toggle();
        if (inputRef.value) {
          inputRef.value.checked = renderSafeCheckedRef.value;
        }
      }
      function handleRadioInputBlur() {
        focusRef.value = false;
      }
      function handleRadioInputFocus() {
        focusRef.value = true;
      }
      return {
        mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }
    const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
    const NRadio = /* @__PURE__ */ defineComponent({
      name: "Radio",
      props: radioProps,
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme("Radio", "-radio", style$5, radioLight, props, radio.mergedClsPrefix);
        const cssVarsRef = computed(() => {
          const {
            mergedSize: {
              value: size2
            }
          } = radio;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              boxShadow,
              boxShadowActive,
              boxShadowDisabled,
              boxShadowFocus,
              boxShadowHover,
              color,
              colorDisabled,
              colorActive,
              textColor,
              textColorDisabled,
              dotColorActive,
              dotColorDisabled,
              labelPadding,
              labelLineHeight,
              labelFontWeight,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("radioSize", size2)]: radioSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize2,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          onRender,
          label
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h("label", {
          class: [`${mergedClsPrefix}-radio`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-radio--rtl`, this.mergedDisabled && `${mergedClsPrefix}-radio--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio--checked`, this.focus && `${mergedClsPrefix}-radio--focus`],
          style: this.cssVars
        }, h("input", {
          ref: "inputRef",
          type: "radio",
          class: `${mergedClsPrefix}-radio-input`,
          value: this.value,
          name: this.mergedName,
          checked: this.renderSafeChecked,
          disabled: this.mergedDisabled,
          onChange: this.handleRadioInputChange,
          onFocus: this.handleRadioInputFocus,
          onBlur: this.handleRadioInputBlur
        }), h("div", {
          class: `${mergedClsPrefix}-radio__dot-wrapper`
        }, " ", h("div", {
          class: [`${mergedClsPrefix}-radio__dot`, this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`]
        })), resolveWrappedSlot($slots.default, (children) => {
          if (!children && !label) return null;
          return h("div", {
            ref: "labelRef",
            class: `${mergedClsPrefix}-radio__label`
          }, children || label);
        }));
      }
    });
    const style$4 = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE$1("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM$1("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM$1("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM$1("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE$1("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE$1("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM$1("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM$1("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
    function mapSlot(defaultSlot, value, clsPrefix) {
      var _a2;
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = (_a2 = wrappedInstance.type) === null || _a2 === void 0 ? void 0 : _a2.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(h("div", {
            class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
          }), wrappedInstance);
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), {
      name: String,
      value: [String, Number, Boolean],
      defaultValue: {
        type: [String, Number, Boolean],
        default: null
      },
      size: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    });
    const NRadioGroup = /* @__PURE__ */ defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = ref(null);
        const {
          mergedSizeRef,
          mergedDisabledRef,
          nTriggerFormChange,
          nTriggerFormInput,
          nTriggerFormBlur,
          nTriggerFormFocus
        } = useFormItem(props);
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Radio", "-radio-group", style$4, radioLight, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue
          } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormBlur();
        }
        provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              buttonBorderColor,
              buttonBorderColorActive,
              buttonBorderRadius,
              buttonBoxShadow,
              buttonBoxShadowFocus,
              buttonBoxShadowHover,
              buttonColor,
              buttonColorActive,
              buttonTextColor,
              buttonTextColorActive,
              buttonTextColorHover,
              opacityDisabled,
              [createKey("buttonHeight", size2)]: height,
              [createKey("fontSize", size2)]: fontSize2
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color": buttonColor,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a2;
        const {
          mergedValue,
          mergedClsPrefix,
          handleFocusin,
          handleFocusout
        } = this;
        const {
          children,
          isButtonGroup
        } = mapSlot(flatten(getSlot(this)), mergedValue, mergedClsPrefix);
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        return h("div", {
          onFocusin: handleFocusin,
          onFocusout: handleFocusout,
          ref: "selfElRef",
          class: [`${mergedClsPrefix}-radio-group`, this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`, this.themeClass, isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`],
          style: this.cssVars
        }, children);
      }
    });
    function self$v(vars) {
      const {
        textColorBase,
        opacity1,
        opacity2,
        opacity3,
        opacity4,
        opacity5
      } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    }
    const iconDark$1 = {
      name: "Icon",
      common: derived$1,
      self: self$v
    };
    const commonVars$8 = {
      itemFontSize: "12px",
      itemHeight: "36px",
      itemWidth: "52px",
      panelActionPadding: "8px 0"
    };
    function self$u(vars) {
      const {
        popoverColor,
        textColor2,
        primaryColor,
        hoverColor,
        dividerColor,
        opacityDisabled,
        boxShadow2,
        borderRadius,
        iconColor,
        iconColorDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVars$8), {
        panelColor: popoverColor,
        panelBoxShadow: boxShadow2,
        panelDividerColor: dividerColor,
        itemTextColor: textColor2,
        itemTextColorActive: primaryColor,
        itemColorHover: hoverColor,
        itemOpacityDisabled: opacityDisabled,
        itemBorderRadius: borderRadius,
        borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const timePickerDark = {
      name: "TimePicker",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Button: buttonDark,
        Input: inputDark
      },
      self: self$u
    };
    const commonVars$7 = {
      itemSize: "24px",
      itemCellWidth: "38px",
      itemCellHeight: "32px",
      scrollItemWidth: "80px",
      scrollItemHeight: "40px",
      panelExtraFooterPadding: "8px 12px",
      panelActionPadding: "8px 12px",
      calendarTitlePadding: "0",
      calendarTitleHeight: "28px",
      arrowSize: "14px",
      panelHeaderPadding: "8px 12px",
      calendarDaysHeight: "32px",
      calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
      // type
      calendarLeftPaddingDate: "6px 12px 4px 12px",
      calendarLeftPaddingDatetime: "4px 12px",
      calendarLeftPaddingDaterange: "6px 12px 4px 12px",
      calendarLeftPaddingDatetimerange: "4px 12px",
      calendarLeftPaddingMonth: "0",
      // TODO: make it actually effective
      calendarLeftPaddingYear: "0",
      calendarLeftPaddingQuarter: "0",
      calendarLeftPaddingMonthrange: "0",
      calendarLeftPaddingQuarterrange: "0",
      calendarLeftPaddingYearrange: "0",
      calendarLeftPaddingWeek: "6px 12px 4px 12px",
      calendarRightPaddingDate: "6px 12px 4px 12px",
      calendarRightPaddingDatetime: "4px 12px",
      calendarRightPaddingDaterange: "6px 12px 4px 12px",
      calendarRightPaddingDatetimerange: "4px 12px",
      calendarRightPaddingMonth: "0",
      calendarRightPaddingYear: "0",
      calendarRightPaddingQuarter: "0",
      calendarRightPaddingMonthrange: "0",
      calendarRightPaddingQuarterrange: "0",
      calendarRightPaddingYearrange: "0",
      calendarRightPaddingWeek: "0"
    };
    function self$t(vars) {
      const {
        hoverColor,
        fontSize: fontSize2,
        textColor2,
        textColorDisabled,
        popoverColor,
        primaryColor,
        borderRadiusSmall,
        iconColor,
        iconColorDisabled,
        textColor1,
        dividerColor,
        boxShadow2,
        borderRadius,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVars$7), {
        itemFontSize: fontSize2,
        calendarDaysFontSize: fontSize2,
        calendarTitleFontSize: fontSize2,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemTextColorActive: popoverColor,
        itemTextColorCurrent: primaryColor,
        itemColorIncluded: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorHover: hoverColor,
        itemColorDisabled: hoverColor,
        itemColorActive: primaryColor,
        itemBorderRadius: borderRadiusSmall,
        panelColor: popoverColor,
        panelTextColor: textColor2,
        arrowColor: iconColor,
        calendarTitleTextColor: textColor1,
        calendarTitleColorHover: hoverColor,
        calendarDaysTextColor: textColor2,
        panelHeaderDividerColor: dividerColor,
        calendarDaysDividerColor: dividerColor,
        calendarDividerColor: dividerColor,
        panelActionDividerColor: dividerColor,
        panelBoxShadow: boxShadow2,
        panelBorderRadius: borderRadius,
        calendarTitleFontWeight: fontWeightStrong,
        scrollItemBorderRadius: borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const datePickerDark = {
      name: "DatePicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        TimePicker: timePickerDark,
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          popoverColor,
          hoverColor,
          primaryColor
        } = vars;
        const commonSelf = self$t(vars);
        commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
        commonSelf.itemColorIncluded = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorHover = composite(popoverColor, hoverColor);
        return commonSelf;
      }
    };
    const commonVariables$7 = {
      thPaddingBorderedSmall: "8px 12px",
      thPaddingBorderedMedium: "12px 16px",
      thPaddingBorderedLarge: "16px 24px",
      thPaddingSmall: "0",
      thPaddingMedium: "0",
      thPaddingLarge: "0",
      tdPaddingBorderedSmall: "8px 12px",
      tdPaddingBorderedMedium: "12px 16px",
      tdPaddingBorderedLarge: "16px 24px",
      tdPaddingSmall: "0 0 8px 0",
      tdPaddingMedium: "0 0 12px 0",
      tdPaddingLarge: "0 0 16px 0"
    };
    function self$s(vars) {
      const {
        tableHeaderColor,
        textColor2,
        textColor1,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), {
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        titleTextColor: textColor1,
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        tdTextColor: textColor2,
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius
      });
    }
    const descriptionsDark = {
      name: "Descriptions",
      common: derived$1,
      self: self$s
    };
    const commonVars$6 = {
      titleFontSize: "18px",
      padding: "16px 28px 20px 28px",
      iconSize: "28px",
      actionSpace: "12px",
      contentMargin: "8px 0 16px 0",
      iconMargin: "0 4px 0 0",
      iconMarginIconTop: "4px 0 8px 0",
      closeSize: "22px",
      closeIconSize: "18px",
      closeMargin: "20px 26px 0 0",
      closeMarginIconTop: "10px 16px 0 0"
    };
    function self$r(vars) {
      const {
        textColor1,
        textColor2,
        modalColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        primaryColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$6), {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        border: `1px solid ${dividerColor}`,
        titleTextColor: textColor1,
        textColor: textColor2,
        color: modalColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        iconColor: primaryColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        borderRadius,
        titleFontWeight: fontWeightStrong
      });
    }
    const dialogDark = {
      name: "Dialog",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$r
    };
    function self$q(vars) {
      const {
        modalColor,
        textColor2,
        boxShadow3
      } = vars;
      return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
      };
    }
    const modalDark = {
      name: "Modal",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Dialog: dialogDark,
        Card: cardDark
      },
      self: self$q
    };
    const loadingBarDark = {
      name: "LoadingBar",
      common: derived$1,
      self(vars) {
        const {
          primaryColor
        } = vars;
        return {
          colorError: "red",
          colorLoading: primaryColor,
          height: "2px"
        };
      }
    };
    const commonVariables$6 = {
      margin: "0 0 8px 0",
      padding: "10px 20px",
      maxWidth: "720px",
      minWidth: "420px",
      iconMargin: "0 10px 0 0",
      closeMargin: "0 0 0 10px",
      closeSize: "20px",
      closeIconSize: "16px",
      iconSize: "20px",
      fontSize: "14px"
    };
    function self$p(vars) {
      const {
        textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        infoColor,
        successColor,
        errorColor,
        warningColor,
        popoverColor,
        boxShadow2,
        primaryColor,
        lineHeight: lineHeight2,
        borderRadius,
        closeColorHover,
        closeColorPressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$6), {
        closeBorderRadius: borderRadius,
        textColor: textColor2,
        textColorInfo: textColor2,
        textColorSuccess: textColor2,
        textColorError: textColor2,
        textColorWarning: textColor2,
        textColorLoading: textColor2,
        color: popoverColor,
        colorInfo: popoverColor,
        colorSuccess: popoverColor,
        colorError: popoverColor,
        colorWarning: popoverColor,
        colorLoading: popoverColor,
        boxShadow: boxShadow2,
        boxShadowInfo: boxShadow2,
        boxShadowSuccess: boxShadow2,
        boxShadowError: boxShadow2,
        boxShadowWarning: boxShadow2,
        boxShadowLoading: boxShadow2,
        iconColor: textColor2,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        iconColorLoading: primaryColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        closeColorHoverLoading: closeColorHover,
        closeColorPressedLoading: closeColorPressed,
        closeIconColorLoading: closeIconColor,
        closeIconColorHoverLoading: closeIconColorHover,
        closeIconColorPressedLoading: closeIconColorPressed,
        loadingColor: primaryColor,
        lineHeight: lineHeight2,
        borderRadius
      });
    }
    const messageDark = {
      name: "Message",
      common: derived$1,
      self: self$p
    };
    const commonVars$5 = {
      closeMargin: "16px 12px",
      closeSize: "20px",
      closeIconSize: "16px",
      width: "365px",
      padding: "16px",
      titleFontSize: "16px",
      metaFontSize: "12px",
      descriptionFontSize: "12px"
    };
    function self$o(vars) {
      const {
        textColor2,
        successColor,
        infoColor,
        warningColor,
        errorColor,
        popoverColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        textColor1,
        textColor3,
        borderRadius,
        fontWeightStrong,
        boxShadow2,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$5), {
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        headerFontWeight: fontWeightStrong,
        iconColor: textColor2,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        color: popoverColor,
        textColor: textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        headerTextColor: textColor1,
        descriptionTextColor: textColor3,
        actionTextColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const notificationDark = {
      name: "Notification",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$o
    };
    function self$n(vars) {
      const {
        textColor1,
        dividerColor,
        fontWeightStrong
      } = vars;
      return {
        textColor: textColor1,
        color: dividerColor,
        fontWeight: fontWeightStrong
      };
    }
    const dividerDark = {
      name: "Divider",
      common: derived$1,
      self: self$n
    };
    function self$m(vars) {
      const {
        modalColor,
        textColor1,
        textColor2,
        boxShadow3,
        lineHeight: lineHeight2,
        fontWeightStrong,
        dividerColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderRadius,
        primaryColorHover
      } = vars;
      return {
        bodyPadding: "16px 24px",
        borderRadius,
        headerPadding: "16px 24px",
        footerPadding: "16px 24px",
        color: modalColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        titleFontSize: "18px",
        titleFontWeight: fontWeightStrong,
        boxShadow: boxShadow3,
        lineHeight: lineHeight2,
        headerBorderBottom: `1px solid ${dividerColor}`,
        footerBorderTop: `1px solid ${dividerColor}`,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeSize: "22px",
        closeIconSize: "18px",
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        resizableTriggerColorHover: primaryColorHover
      };
    }
    const drawerLight = createTheme({
      name: "Drawer",
      common: derived,
      peers: {
        Scrollbar: scrollbarLight
      },
      self: self$m
    });
    const drawerDark = {
      name: "Drawer",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$m
    };
    const NDrawerBodyWrapper = /* @__PURE__ */ defineComponent({
      name: "NDrawerContent",
      inheritAttrs: false,
      props: {
        blockScroll: Boolean,
        show: {
          type: Boolean,
          default: void 0
        },
        displayDirective: {
          type: String,
          required: true
        },
        placement: {
          type: String,
          required: true
        },
        contentClass: String,
        contentStyle: [Object, String],
        nativeScrollbar: {
          type: Boolean,
          required: true
        },
        scrollbarProps: Object,
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          required: true
        },
        maxWidth: Number,
        maxHeight: Number,
        minWidth: Number,
        minHeight: Number,
        resizable: Boolean,
        onClickoutside: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const displayedRef = ref(!!props.show);
        const bodyRef = ref(null);
        const NDrawer2 = inject(drawerInjectionKey);
        let startPosition = 0;
        let memoizedBodyStyleCursor = "";
        let hoverTimerId = null;
        const isHoverOnResizeTriggerRef = ref(false);
        const isDraggingRef = ref(false);
        const isVertical = computed(() => {
          return props.placement === "top" || props.placement === "bottom";
        });
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
        const handleBodyMouseleave = handleBodyMouseup;
        const handleMousedownResizeTrigger = (e) => {
          isDraggingRef.value = true;
          startPosition = isVertical.value ? e.clientY : e.clientX;
          memoizedBodyStyleCursor = document.body.style.cursor;
          document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
          document.body.addEventListener("mousemove", handleBodyMousemove);
          document.body.addEventListener("mouseleave", handleBodyMouseleave);
          document.body.addEventListener("mouseup", handleBodyMouseup);
        };
        const handleMouseenterResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          if (isDraggingRef.value) {
            isHoverOnResizeTriggerRef.value = true;
          } else {
            hoverTimerId = window.setTimeout(() => {
              isHoverOnResizeTriggerRef.value = true;
            }, 300);
          }
        };
        const handleMouseleaveResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          isHoverOnResizeTriggerRef.value = false;
        };
        const {
          doUpdateHeight,
          doUpdateWidth
        } = NDrawer2;
        const regulateWidth = (size2) => {
          const {
            maxWidth
          } = props;
          if (maxWidth && size2 > maxWidth) return maxWidth;
          const {
            minWidth
          } = props;
          if (minWidth && size2 < minWidth) return minWidth;
          return size2;
        };
        const regulateHeight = (size2) => {
          const {
            maxHeight
          } = props;
          if (maxHeight && size2 > maxHeight) return maxHeight;
          const {
            minHeight
          } = props;
          if (minHeight && size2 < minHeight) return minHeight;
          return size2;
        };
        function handleBodyMousemove(e) {
          var _a2, _b2;
          if (isDraggingRef.value) {
            if (isVertical.value) {
              let height = ((_a2 = bodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
              const increment = startPosition - e.clientY;
              height += props.placement === "bottom" ? increment : -increment;
              height = regulateHeight(height);
              doUpdateHeight(height);
              startPosition = e.clientY;
            } else {
              let width = ((_b2 = bodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.offsetWidth) || 0;
              const increment = startPosition - e.clientX;
              width += props.placement === "right" ? increment : -increment;
              width = regulateWidth(width);
              doUpdateWidth(width);
              startPosition = e.clientX;
            }
          }
        }
        function handleBodyMouseup() {
          if (isDraggingRef.value) {
            startPosition = 0;
            isDraggingRef.value = false;
            document.body.style.cursor = memoizedBodyStyleCursor;
            document.body.removeEventListener("mousemove", handleBodyMousemove);
            document.body.removeEventListener("mouseup", handleBodyMouseup);
            document.body.removeEventListener("mouseleave", handleBodyMouseleave);
          }
        }
        watchEffect(() => {
          if (props.show) displayedRef.value = true;
        });
        watch(() => props.show, (value) => {
          if (!value) {
            handleBodyMouseup();
          }
        });
        onBeforeUnmount(() => {
          handleBodyMouseup();
        });
        const bodyDirectivesRef = computed(() => {
          const {
            show
          } = props;
          const directives = [[vShow, show]];
          if (!props.showMask) {
            directives.push([clickoutside, props.onClickoutside, void 0, {
              capture: true
            }]);
          }
          return directives;
        });
        function handleAfterLeave() {
          var _a2;
          displayedRef.value = false;
          (_a2 = props.onAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
        provide(drawerBodyInjectionKey, bodyRef);
        provide(popoverBodyInjectionKey, null);
        provide(modalBodyInjectionKey, null);
        return {
          bodyRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef,
          isMounted: NDrawer2.isMountedRef,
          mergedTheme: NDrawer2.mergedThemeRef,
          displayed: displayedRef,
          transitionName: computed(() => {
            return {
              right: "slide-in-from-right-transition",
              left: "slide-in-from-left-transition",
              top: "slide-in-from-top-transition",
              bottom: "slide-in-from-bottom-transition"
            }[props.placement];
          }),
          handleAfterLeave,
          bodyDirectives: bodyDirectivesRef,
          handleMousedownResizeTrigger,
          handleMouseenterResizeTrigger,
          handleMouseleaveResizeTrigger,
          isDragging: isDraggingRef,
          isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix
        } = this;
        return this.displayDirective === "show" || this.displayed || this.show ? withDirectives(
          /* Keep the wrapper dom. Make sure the drawer has a host.
          Nor the detached content will disappear without transition */
          h("div", {
            role: "none"
          }, h(FocusTrap, {
            disabled: !this.showMask || !this.trapFocus,
            active: this.show,
            autoFocus: this.autoFocus,
            onEsc: this.onEsc
          }, {
            default: () => h(Transition, {
              name: this.transitionName,
              appear: this.isMounted,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.handleAfterLeave
            }, {
              default: () => withDirectives(h("div", mergeProps(this.$attrs, {
                role: "dialog",
                ref: "bodyRef",
                "aria-modal": "true",
                class: [
                  `${mergedClsPrefix}-drawer`,
                  this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                  `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                  /**
                   * When the mouse is pressed to resize the drawer,
                   * disable text selection
                   */
                  this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                  this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                ]
              }), [this.resizable ? h("div", {
                class: [`${mergedClsPrefix}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`],
                onMouseenter: this.handleMouseenterResizeTrigger,
                onMouseleave: this.handleMouseleaveResizeTrigger,
                onMousedown: this.handleMousedownResizeTrigger
              }) : null, this.nativeScrollbar ? h("div", {
                class: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                style: this.contentStyle,
                role: "none"
              }, $slots) : h(Scrollbar, Object.assign({}, this.scrollbarProps, {
                contentStyle: this.contentStyle,
                contentClass: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                theme: this.mergedTheme.peers.Scrollbar,
                themeOverrides: this.mergedTheme.peerOverrides.Scrollbar
              }), $slots)]), this.bodyDirectives)
            })
          })),
          [[vShow, this.displayDirective === "if" || this.displayed || this.show]]
        ) : null;
      }
    });
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$3,
      cubicBezierEaseOut: cubicBezierEaseOut$3
    } = commonVariables$n;
    function slideInFromBottomTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-bottom"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$3}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$2,
      cubicBezierEaseOut: cubicBezierEaseOut$2
    } = commonVariables$n;
    function slideInFromLeftTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-left"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$2}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(-100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$1,
      cubicBezierEaseOut: cubicBezierEaseOut$1
    } = commonVariables$n;
    function slideInFromRightTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-right"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$1}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(100%)"
      })];
    }
    const {
      cubicBezierEaseIn,
      cubicBezierEaseOut
    } = commonVariables$n;
    function slideInFromTopTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-top"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(-100%)"
      })];
    }
    const style$3 = c([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM$1("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM$1("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE$1("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM$1("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM$1("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE$1("main", `
 flex: 1;
 `), cE$1("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM$1("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM$1("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM$1("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM$1("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c("body", [c(">", [cB("drawer-container", `
 position: fixed;
 `)])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c("> *", `
 pointer-events: all;
 `)]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM$1("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
      enterDuration: "0.2s",
      leaveDuration: "0.2s",
      enterCubicBezier: "var(--n-bezier-in)",
      leaveCubicBezier: "var(--n-bezier-out)"
    })])]);
    const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
      show: Boolean,
      width: [Number, String],
      height: [Number, String],
      placement: {
        type: String,
        default: "right"
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        default: true
      },
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      onMaskClick: Function,
      scrollbarProps: Object,
      contentClass: String,
      contentStyle: [Object, String],
      trapFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: {
        type: Boolean,
        default: true
      },
      maxWidth: Number,
      maxHeight: Number,
      minWidth: Number,
      minHeight: Number,
      resizable: Boolean,
      defaultWidth: {
        type: [Number, String],
        default: 251
      },
      defaultHeight: {
        type: [Number, String],
        default: 251
      },
      onUpdateWidth: [Function, Array],
      onUpdateHeight: [Function, Array],
      "onUpdate:width": [Function, Array],
      "onUpdate:height": [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      /** @deprecated */
      drawerStyle: [String, Object],
      drawerClass: String,
      target: null,
      onShow: Function,
      onHide: Function
    });
    const NDrawer = /* @__PURE__ */ defineComponent({
      name: "Drawer",
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const isMountedRef = isMounted();
        const themeRef = useTheme("Drawer", "-drawer", style$3, drawerLight, props, mergedClsPrefixRef);
        const uncontrolledWidthRef = ref(props.defaultWidth);
        const uncontrolledHeightRef = ref(props.defaultHeight);
        const mergedWidthRef = useMergedState(toRef(props, "width"), uncontrolledWidthRef);
        const mergedHeightRef = useMergedState(toRef(props, "height"), uncontrolledHeightRef);
        const styleWidthRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "top" || placement === "bottom") return "";
          return formatLength(mergedWidthRef.value);
        });
        const styleHeightRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "left" || placement === "right") return "";
          return formatLength(mergedHeightRef.value);
        });
        const doUpdateWidth = (value) => {
          const {
            onUpdateWidth,
            "onUpdate:width": _onUpdateWidth
          } = props;
          if (onUpdateWidth) call(onUpdateWidth, value);
          if (_onUpdateWidth) call(_onUpdateWidth, value);
          uncontrolledWidthRef.value = value;
        };
        const doUpdateHeight = (value) => {
          const {
            onUpdateHeight,
            "onUpdate:width": _onUpdateHeight
          } = props;
          if (onUpdateHeight) call(onUpdateHeight, value);
          if (_onUpdateHeight) call(_onUpdateHeight, value);
          uncontrolledHeightRef.value = value;
        };
        const mergedBodyStyleRef = computed(() => {
          return [{
            width: styleWidthRef.value,
            height: styleHeightRef.value
          }, props.drawerStyle || ""];
        });
        function handleMaskClick(e) {
          const {
            onMaskClick,
            maskClosable
          } = props;
          if (maskClosable) {
            doUpdateShow(false);
          }
          if (onMaskClick) onMaskClick(e);
        }
        function handleOutsideClick(e) {
          handleMaskClick(e);
        }
        const isComposingRef2 = useIsComposing();
        function handleEsc(e) {
          var _a2;
          (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props);
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            if (!isComposingRef2.value) {
              doUpdateShow(false);
            }
          }
        }
        function doUpdateShow(show) {
          const {
            onHide,
            onUpdateShow,
            "onUpdate:show": _onUpdateShow
          } = props;
          if (onUpdateShow) call(onUpdateShow, show);
          if (_onUpdateShow) call(_onUpdateShow, show);
          if (onHide && !show) call(onHide, show);
        }
        provide(drawerInjectionKey, {
          isMountedRef,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          doUpdateShow,
          doUpdateHeight,
          doUpdateWidth
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseIn: cubicBezierEaseIn2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: {
              color,
              textColor,
              boxShadow,
              lineHeight: lineHeight2,
              headerPadding,
              footerPadding,
              borderRadius,
              bodyPadding,
              titleFontSize,
              titleTextColor,
              titleFontWeight,
              headerBorderBottom,
              footerBorderTop,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeColorHover,
              closeColorPressed,
              closeIconSize,
              closeSize,
              closeBorderRadius,
              resizableTriggerColorHover
            }
          } = themeRef.value;
          return {
            "--n-line-height": lineHeight2,
            "--n-color": color,
            "--n-border-radius": borderRadius,
            "--n-text-color": textColor,
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-out": cubicBezierEaseOut2,
            "--n-bezier-in": cubicBezierEaseIn2,
            "--n-header-padding": headerPadding,
            "--n-body-padding": bodyPadding,
            "--n-footer-padding": footerPadding,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-header-border-bottom": headerBorderBottom,
            "--n-footer-border-top": footerBorderTop,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-size": closeSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-resize-trigger-color-hover": resizableTriggerColorHover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedBodyStyle: mergedBodyStyleRef,
          handleOutsideClick,
          handleMaskClick,
          handleEsc,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
          isMounted: isMountedRef
        };
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h(LazyTeleport, {
          to: this.to,
          show: this.show
        }, {
          default: () => {
            var _a2;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return withDirectives(h("div", {
              class: [`${mergedClsPrefix}-drawer-container`, this.namespace, this.themeClass],
              style: this.cssVars,
              role: "none"
            }, this.showMask ? h(Transition, {
              name: "fade-in-transition",
              appear: this.isMounted
            }, {
              default: () => this.show ? h("div", {
                "aria-hidden": true,
                class: [`${mergedClsPrefix}-drawer-mask`, this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`],
                onClick: this.handleMaskClick
              }) : null
            }) : null, h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, {
              class: [this.drawerClass, this.$attrs.class],
              style: [this.mergedBodyStyle, this.$attrs.style],
              blockScroll: this.blockScroll,
              contentStyle: this.contentStyle,
              contentClass: this.contentClass,
              placement: this.placement,
              scrollbarProps: this.scrollbarProps,
              show: this.show,
              displayDirective: this.displayDirective,
              nativeScrollbar: this.nativeScrollbar,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.onAfterLeave,
              trapFocus: this.trapFocus,
              autoFocus: this.autoFocus,
              resizable: this.resizable,
              maxHeight: this.maxHeight,
              minHeight: this.minHeight,
              maxWidth: this.maxWidth,
              minWidth: this.minWidth,
              showMask: this.showMask,
              onEsc: this.handleEsc,
              onClickoutside: this.handleOutsideClick
            }), this.$slots)), [[zindexable, {
              zIndex: this.zIndex,
              enabled: this.show
            }]]);
          }
        });
      }
    });
    const drawerContentProps = {
      title: String,
      headerClass: String,
      headerStyle: [Object, String],
      footerClass: String,
      footerStyle: [Object, String],
      bodyClass: String,
      bodyStyle: [Object, String],
      bodyContentClass: String,
      bodyContentStyle: [Object, String],
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      scrollbarProps: Object,
      closable: Boolean
    };
    const NDrawerContent = /* @__PURE__ */ defineComponent({
      name: "DrawerContent",
      props: drawerContentProps,
      slots: Object,
      setup() {
        const NDrawer2 = inject(drawerInjectionKey, null);
        if (!NDrawer2) {
          throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
        }
        const {
          doUpdateShow
        } = NDrawer2;
        function handleCloseClick() {
          doUpdateShow(false);
        }
        return {
          handleCloseClick,
          mergedTheme: NDrawer2.mergedThemeRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef
        };
      },
      render() {
        const {
          title,
          mergedClsPrefix,
          nativeScrollbar,
          mergedTheme,
          bodyClass,
          bodyStyle,
          bodyContentClass,
          bodyContentStyle,
          headerClass,
          headerStyle,
          footerClass,
          footerStyle,
          scrollbarProps: scrollbarProps2,
          closable,
          $slots
        } = this;
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-drawer-content`, nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`]
        }, $slots.header || title || closable ? h("div", {
          class: [`${mergedClsPrefix}-drawer-header`, headerClass],
          style: headerStyle,
          role: "none"
        }, h("div", {
          class: `${mergedClsPrefix}-drawer-header__main`,
          role: "heading",
          "aria-level": "1"
        }, $slots.header !== void 0 ? $slots.header() : title), closable && h(NBaseClose, {
          onClick: this.handleCloseClick,
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-drawer-header__close`,
          absolute: true
        })) : null, nativeScrollbar ? h("div", {
          class: [`${mergedClsPrefix}-drawer-body`, bodyClass],
          style: bodyStyle,
          role: "none"
        }, h("div", {
          class: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          style: bodyContentStyle,
          role: "none"
        }, $slots)) : h(Scrollbar, Object.assign({
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          theme: mergedTheme.peers.Scrollbar
        }, scrollbarProps2, {
          class: `${mergedClsPrefix}-drawer-body`,
          contentClass: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          contentStyle: bodyContentStyle
        }), $slots), $slots.footer ? h("div", {
          class: [`${mergedClsPrefix}-drawer-footer`, footerClass],
          style: footerStyle,
          role: "none"
        }, $slots.footer()) : null);
      }
    });
    const commonVariables$5 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };
    const dynamicInputDark = {
      name: "DynamicInput",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self() {
        return commonVariables$5;
      }
    };
    const commonVars$4 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const spaceDark = {
      name: "Space",
      self() {
        return commonVars$4;
      }
    };
    function self$l() {
      return commonVars$4;
    }
    const spaceLight = {
      self: self$l
    };
    let supportFlexGap;
    function ensureSupportFlexGap() {
      if (!isBrowser$1) return true;
      if (supportFlexGap === void 0) {
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        const isSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return supportFlexGap = isSupported;
      }
      return supportFlexGap;
    }
    const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
      align: String,
      justify: {
        type: String,
        default: "start"
      },
      inline: Boolean,
      vertical: Boolean,
      reverse: Boolean,
      size: {
        type: [String, Number, Array],
        default: "medium"
      },
      wrapItem: {
        type: Boolean,
        default: true
      },
      itemClass: String,
      itemStyle: [String, Object],
      wrap: {
        type: Boolean,
        default: true
      },
      // internal
      internalUseGap: {
        type: Boolean,
        default: void 0
      }
    });
    const NSpace = /* @__PURE__ */ defineComponent({
      name: "Space",
      props: spaceProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Space", "-space", void 0, spaceLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
        return {
          useGap: ensureSupportFlexGap(),
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          margin: computed(() => {
            const {
              size: size2
            } = props;
            if (Array.isArray(size2)) {
              return {
                horizontal: size2[0],
                vertical: size2[1]
              };
            }
            if (typeof size2 === "number") {
              return {
                horizontal: size2,
                vertical: size2
              };
            }
            const {
              self: {
                [createKey("gap", size2)]: gap
              }
            } = themeRef.value;
            const {
              row,
              col
            } = getGap(gap);
            return {
              horizontal: depx(col),
              vertical: depx(row)
            };
          })
        };
      },
      render() {
        const {
          vertical,
          reverse,
          align,
          inline,
          justify,
          itemClass,
          itemStyle,
          margin,
          wrap,
          mergedClsPrefix,
          rtlEnabled,
          useGap,
          wrapItem,
          internalUseGap
        } = this;
        const children = flatten(getSlot(this), false);
        if (!children.length) return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith("space-");
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-space`, rtlEnabled && `${mergedClsPrefix}-space--rtl`],
          style: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: (() => {
              if (vertical && !reverse) return "column";
              if (vertical && reverse) return "column-reverse";
              if (!vertical && reverse) return "row-reverse";
              else return "row";
            })(),
            justifyContent: ["start", "end"].includes(justify) ? `flex-${justify}` : justify,
            flexWrap: !wrap || vertical ? "nowrap" : "wrap",
            marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            alignItems: align,
            gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
          }
        }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => child.type === Comment ? child : h("div", {
          role: "none",
          class: itemClass,
          style: [itemStyle, {
            maxWidth: "100%"
          }, useGap ? "" : vertical ? {
            marginBottom: index !== lastIndex ? verticalMargin : ""
          } : rtlEnabled ? {
            marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          } : {
            marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          }]
        }, child)));
      }
    });
    const dynamicTagsDark = {
      name: "DynamicTags",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        Tag: tagDark,
        Space: spaceDark
      },
      self() {
        return {
          inputWidth: "64px"
        };
      }
    };
    const elementDark = {
      name: "Element",
      common: derived$1
    };
    const commonVars$3 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const flexDark = {
      name: "Flex",
      self() {
        return commonVars$3;
      }
    };
    const buttonGroupDark = {
      name: "ButtonGroup",
      common: derived$1
    };
    const commonVariables$4 = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right",
      labelFontWeight: "400"
    };
    function self$k(vars) {
      const {
        heightSmall,
        heightMedium,
        heightLarge,
        textColor1,
        errorColor,
        warningColor,
        lineHeight: lineHeight2,
        textColor3
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), {
        blankHeightSmall: heightSmall,
        blankHeightMedium: heightMedium,
        blankHeightLarge: heightLarge,
        lineHeight: lineHeight2,
        labelTextColor: textColor1,
        asteriskColor: errorColor,
        feedbackTextColorError: errorColor,
        feedbackTextColorWarning: warningColor,
        feedbackTextColor: textColor3
      });
    }
    const formLight = {
      common: derived,
      self: self$k
    };
    const formItemDark = {
      name: "Form",
      common: derived$1,
      self: self$k
    };
    const gradientTextDark = {
      name: "GradientText",
      common: derived$1,
      self(vars) {
        const {
          primaryColor,
          successColor,
          warningColor,
          errorColor,
          infoColor,
          primaryColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          infoColorSuppl,
          fontWeightStrong
        } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: primaryColor,
          colorEndPrimary: primaryColorSuppl,
          colorStartInfo: infoColor,
          colorEndInfo: infoColorSuppl,
          colorStartWarning: warningColor,
          colorEndWarning: warningColorSuppl,
          colorStartError: errorColor,
          colorEndError: errorColorSuppl,
          colorStartSuccess: successColor,
          colorEndSuccess: successColorSuppl
        };
      }
    };
    const inputNumberDark = {
      name: "InputNumber",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Input: inputDark
      },
      self(vars) {
        const {
          textColorDisabled
        } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      }
    };
    const layoutDark = {
      name: "Layout",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          textColor2,
          bodyColor,
          popoverColor,
          cardColor,
          dividerColor,
          scrollbarColor,
          scrollbarColorHover
        } = vars;
        return {
          textColor: textColor2,
          textColorInverted: textColor2,
          color: bodyColor,
          colorEmbedded: bodyColor,
          headerColor: cardColor,
          headerColorInverted: cardColor,
          footerColor: cardColor,
          footerColorInverted: cardColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: dividerColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: dividerColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: dividerColor,
          siderColor: cardColor,
          siderColorInverted: cardColor,
          siderToggleButtonBorder: "1px solid transparent",
          siderToggleButtonColor: popoverColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          __invertScrollbar: "false"
        };
      }
    };
    const rowDark = {
      name: "Row",
      common: derived$1
    };
    function self$j(vars) {
      const {
        textColor2,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontSize: fontSize2,
        hoverColor
      } = vars;
      return {
        textColor: textColor2,
        color: cardColor,
        colorHover: hoverColor,
        colorModal: modalColor,
        colorHoverModal: composite(modalColor, hoverColor),
        colorPopover: popoverColor,
        colorHoverPopover: composite(popoverColor, hoverColor),
        borderColor: dividerColor,
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius,
        fontSize: fontSize2
      };
    }
    const listDark$1 = {
      name: "List",
      common: derived$1,
      self: self$j
    };
    const logDark = {
      name: "Log",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Code: codeDark
      },
      self(vars) {
        const {
          textColor2,
          inputColor,
          fontSize: fontSize2,
          primaryColor
        } = vars;
        return {
          loaderFontSize: fontSize2,
          loaderTextColor: textColor2,
          loaderColor: inputColor,
          loaderBorder: "1px solid #0000",
          loadingColor: primaryColor
        };
      }
    };
    const listDark = {
      name: "Mention",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
    };
    function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
        itemColorHoverInverted: "#0000",
        itemColorActiveInverted: activeItemColor,
        itemColorActiveHoverInverted: activeItemColor,
        itemColorActiveCollapsedInverted: activeItemColor,
        itemTextColorInverted: color,
        itemTextColorHoverInverted: activeTextColor,
        itemTextColorChildActiveInverted: activeTextColor,
        itemTextColorChildActiveHoverInverted: activeTextColor,
        itemTextColorActiveInverted: activeTextColor,
        itemTextColorActiveHoverInverted: activeTextColor,
        itemTextColorHorizontalInverted: color,
        itemTextColorHoverHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
        itemTextColorActiveHorizontalInverted: activeTextColor,
        itemTextColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorInverted: color,
        itemIconColorHoverInverted: activeTextColor,
        itemIconColorActiveInverted: activeTextColor,
        itemIconColorActiveHoverInverted: activeTextColor,
        itemIconColorChildActiveInverted: activeTextColor,
        itemIconColorChildActiveHoverInverted: activeTextColor,
        itemIconColorCollapsedInverted: color,
        itemIconColorHorizontalInverted: color,
        itemIconColorHoverHorizontalInverted: activeTextColor,
        itemIconColorActiveHorizontalInverted: activeTextColor,
        itemIconColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
        arrowColorInverted: color,
        arrowColorHoverInverted: activeTextColor,
        arrowColorActiveInverted: activeTextColor,
        arrowColorActiveHoverInverted: activeTextColor,
        arrowColorChildActiveInverted: activeTextColor,
        arrowColorChildActiveHoverInverted: activeTextColor,
        groupTextColorInverted: groupTextColor
      };
    }
    function self$i(vars) {
      const {
        borderRadius,
        textColor3,
        primaryColor,
        textColor2,
        textColor1,
        fontSize: fontSize2,
        dividerColor,
        hoverColor,
        primaryColorHover
      } = vars;
      return Object.assign({
        borderRadius,
        color: "#0000",
        groupTextColor: textColor3,
        itemColorHover: hoverColor,
        itemColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveHover: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveCollapsed: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemTextColor: textColor2,
        itemTextColorHover: textColor2,
        itemTextColorActive: primaryColor,
        itemTextColorActiveHover: primaryColor,
        itemTextColorChildActive: primaryColor,
        itemTextColorChildActiveHover: primaryColor,
        itemTextColorHorizontal: textColor2,
        itemTextColorHoverHorizontal: primaryColorHover,
        itemTextColorActiveHorizontal: primaryColor,
        itemTextColorActiveHoverHorizontal: primaryColor,
        itemTextColorChildActiveHorizontal: primaryColor,
        itemTextColorChildActiveHoverHorizontal: primaryColor,
        itemIconColor: textColor1,
        itemIconColorHover: textColor1,
        itemIconColorActive: primaryColor,
        itemIconColorActiveHover: primaryColor,
        itemIconColorChildActive: primaryColor,
        itemIconColorChildActiveHover: primaryColor,
        itemIconColorCollapsed: textColor1,
        itemIconColorHorizontal: textColor1,
        itemIconColorHoverHorizontal: primaryColorHover,
        itemIconColorActiveHorizontal: primaryColor,
        itemIconColorActiveHoverHorizontal: primaryColor,
        itemIconColorChildActiveHorizontal: primaryColor,
        itemIconColorChildActiveHoverHorizontal: primaryColor,
        itemHeight: "42px",
        arrowColor: textColor2,
        arrowColorHover: textColor2,
        arrowColorActive: primaryColor,
        arrowColorActiveHover: primaryColor,
        arrowColorChildActive: primaryColor,
        arrowColorChildActiveHover: primaryColor,
        colorInverted: "#0000",
        borderColorHorizontal: "#0000",
        fontSize: fontSize2,
        dividerColor
      }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
    }
    const menuDark = {
      name: "Menu",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const {
          primaryColor,
          primaryColorSuppl
        } = vars;
        const commonSelf = self$i(vars);
        commonSelf.itemColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveHover = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveInverted = primaryColorSuppl;
        commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
        commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const common = {
      titleFontSize: "18px",
      backSize: "22px"
    };
    function self$h(vars) {
      const {
        textColor1,
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeightStrong,
        primaryColorHover,
        primaryColorPressed
      } = vars;
      return Object.assign(Object.assign({}, common), {
        titleFontWeight: fontWeightStrong,
        fontSize: fontSize2,
        titleTextColor: textColor1,
        backColor: textColor2,
        backColorHover: primaryColorHover,
        backColorPressed: primaryColorPressed,
        subtitleTextColor: textColor3
      });
    }
    const pageHeaderDark = {
      name: "PageHeader",
      common: derived$1,
      self: self$h
    };
    const commonVars$2 = {
      iconSize: "22px"
    };
    function self$g(vars) {
      const {
        fontSize: fontSize2,
        warningColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars$2), {
        fontSize: fontSize2,
        iconColor: warningColor
      });
    }
    const popconfirmDark = {
      name: "Popconfirm",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Popover: popoverDark
      },
      self: self$g
    };
    function self$f(vars) {
      const {
        infoColor,
        successColor,
        warningColor,
        errorColor,
        textColor2,
        progressRailColor,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        fontSize: fontSize2,
        fontSizeCircle: "28px",
        fontWeightCircle: fontWeight,
        railColor: progressRailColor,
        railHeight: "8px",
        iconSizeCircle: "36px",
        iconSizeLine: "18px",
        iconColor: infoColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        textColorCircle: textColor2,
        textColorLineInner: "rgb(255, 255, 255)",
        textColorLineOuter: textColor2,
        fillColor: infoColor,
        fillColorInfo: infoColor,
        fillColorSuccess: successColor,
        fillColorWarning: warningColor,
        fillColorError: errorColor,
        lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
      };
    }
    const progressDark = {
      name: "Progress",
      common: derived$1,
      self(vars) {
        const commonSelf = self$f(vars);
        commonSelf.textColorLineInner = "rgb(0, 0, 0)";
        commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
        return commonSelf;
      }
    };
    const rateDark = {
      name: "Rate",
      common: derived$1,
      self(vars) {
        const {
          railColor
        } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#CCAA33",
          itemSize: "20px",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      }
    };
    const commonVariables$3 = {
      titleFontSizeSmall: "26px",
      titleFontSizeMedium: "32px",
      titleFontSizeLarge: "40px",
      titleFontSizeHuge: "48px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      iconSizeSmall: "64px",
      iconSizeMedium: "80px",
      iconSizeLarge: "100px",
      iconSizeHuge: "125px",
      iconColor418: void 0,
      iconColor404: void 0,
      iconColor403: void 0,
      iconColor500: void 0
    };
    function self$e(vars) {
      const {
        textColor2,
        textColor1,
        errorColor,
        successColor,
        infoColor,
        warningColor,
        lineHeight: lineHeight2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), {
        lineHeight: lineHeight2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        textColor: textColor2,
        iconColorError: errorColor,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor
      });
    }
    const resultDark = {
      name: "Result",
      common: derived$1,
      self: self$e
    };
    const sizeVariables$3 = {
      railHeight: "4px",
      railWidthVertical: "4px",
      handleSize: "18px",
      dotHeight: "8px",
      dotWidth: "8px",
      dotBorderRadius: "4px"
    };
    const sliderDark = {
      name: "Slider",
      common: derived$1,
      self(vars) {
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const {
          railColor,
          modalColor,
          primaryColorSuppl,
          popoverColor,
          textColor2,
          cardColor,
          borderRadius,
          fontSize: fontSize2,
          opacityDisabled
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables$3), {
          fontSize: fontSize2,
          markFontSize: fontSize2,
          railColor,
          railColorHover: railColor,
          fillColor: primaryColorSuppl,
          fillColorHover: primaryColorSuppl,
          opacityDisabled,
          handleColor: "#FFF",
          dotColor: cardColor,
          dotColorModal: modalColor,
          dotColorPopover: popoverColor,
          handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          indicatorColor: popoverColor,
          indicatorBoxShadow: boxShadow,
          indicatorTextColor: textColor2,
          indicatorBorderRadius: borderRadius,
          dotBorder: `2px solid ${railColor}`,
          dotBorderActive: `2px solid ${primaryColorSuppl}`,
          dotBoxShadow: ""
        });
      }
    };
    function self$d(vars) {
      const {
        opacityDisabled,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        primaryColor,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        textColor: primaryColor,
        sizeTiny: heightTiny,
        sizeSmall: heightSmall,
        sizeMedium: heightMedium,
        sizeLarge: heightLarge,
        sizeHuge: heightHuge,
        color: primaryColor,
        opacitySpinning: opacityDisabled
      };
    }
    const spinDark = {
      name: "Spin",
      common: derived$1,
      self: self$d
    };
    function self$c(vars) {
      const {
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        labelFontSize: fontSize2,
        labelFontWeight: fontWeight,
        valueFontWeight: fontWeight,
        valueFontSize: "24px",
        labelTextColor: textColor3,
        valuePrefixTextColor: textColor2,
        valueSuffixTextColor: textColor2,
        valueTextColor: textColor2
      };
    }
    const statisticDark = {
      name: "Statistic",
      common: derived$1,
      self: self$c
    };
    const commonVariables$2 = {
      stepHeaderFontSizeSmall: "14px",
      stepHeaderFontSizeMedium: "16px",
      indicatorIndexFontSizeSmall: "14px",
      indicatorIndexFontSizeMedium: "16px",
      indicatorSizeSmall: "22px",
      indicatorSizeMedium: "28px",
      indicatorIconSizeSmall: "14px",
      indicatorIconSizeMedium: "18px"
    };
    function self$b(vars) {
      const {
        fontWeightStrong,
        baseColor,
        textColorDisabled,
        primaryColor,
        errorColor,
        textColor1,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), {
        stepHeaderFontWeight: fontWeightStrong,
        indicatorTextColorProcess: baseColor,
        indicatorTextColorWait: textColorDisabled,
        indicatorTextColorFinish: primaryColor,
        indicatorTextColorError: errorColor,
        indicatorBorderColorProcess: primaryColor,
        indicatorBorderColorWait: textColorDisabled,
        indicatorBorderColorFinish: primaryColor,
        indicatorBorderColorError: errorColor,
        indicatorColorProcess: primaryColor,
        indicatorColorWait: "#0000",
        indicatorColorFinish: "#0000",
        indicatorColorError: "#0000",
        splitorColorProcess: textColorDisabled,
        splitorColorWait: textColorDisabled,
        splitorColorFinish: primaryColor,
        splitorColorError: textColorDisabled,
        headerTextColorProcess: textColor1,
        headerTextColorWait: textColorDisabled,
        headerTextColorFinish: textColorDisabled,
        headerTextColorError: errorColor,
        descriptionTextColorProcess: textColor2,
        descriptionTextColorWait: textColorDisabled,
        descriptionTextColorFinish: textColorDisabled,
        descriptionTextColorError: errorColor
      });
    }
    const stepsDark = {
      name: "Steps",
      common: derived$1,
      self: self$b
    };
    const commonVars$1 = {
      buttonHeightSmall: "14px",
      buttonHeightMedium: "18px",
      buttonHeightLarge: "22px",
      buttonWidthSmall: "14px",
      buttonWidthMedium: "18px",
      buttonWidthLarge: "22px",
      buttonWidthPressedSmall: "20px",
      buttonWidthPressedMedium: "24px",
      buttonWidthPressedLarge: "28px",
      railHeightSmall: "18px",
      railHeightMedium: "22px",
      railHeightLarge: "26px",
      railWidthSmall: "32px",
      railWidthMedium: "40px",
      railWidthLarge: "48px"
    };
    const switchDark = {
      name: "Switch",
      common: derived$1,
      self(vars) {
        const {
          primaryColorSuppl,
          opacityDisabled,
          borderRadius,
          primaryColor,
          textColor2,
          baseColor
        } = vars;
        const railOverlayColor = "rgba(255, 255, 255, .20)";
        return Object.assign(Object.assign({}, commonVars$1), {
          iconColor: baseColor,
          textColor: textColor2,
          loadingColor: primaryColorSuppl,
          opacityDisabled,
          railColor: railOverlayColor,
          railColorActive: primaryColorSuppl,
          buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          buttonColor: "#FFF",
          railBorderRadiusSmall: borderRadius,
          railBorderRadiusMedium: borderRadius,
          railBorderRadiusLarge: borderRadius,
          buttonBorderRadiusSmall: borderRadius,
          buttonBorderRadiusMedium: borderRadius,
          buttonBorderRadiusLarge: borderRadius,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`
        });
      }
    };
    function self$a(vars) {
      const {
        primaryColor,
        opacityDisabled,
        borderRadius,
        textColor3
      } = vars;
      const railOverlayColor = "rgba(0, 0, 0, .14)";
      return Object.assign(Object.assign({}, commonVars$1), {
        iconColor: textColor3,
        textColor: "white",
        loadingColor: primaryColor,
        opacityDisabled,
        railColor: railOverlayColor,
        railColorActive: primaryColor,
        buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        buttonColor: "#FFF",
        railBorderRadiusSmall: borderRadius,
        railBorderRadiusMedium: borderRadius,
        railBorderRadiusLarge: borderRadius,
        buttonBorderRadiusSmall: borderRadius,
        buttonBorderRadiusMedium: borderRadius,
        buttonBorderRadiusLarge: borderRadius,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`
      });
    }
    const switchLight = {
      common: derived,
      self: self$a
    };
    const sizeVariables$2 = {
      thPaddingSmall: "6px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "6px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px"
    };
    function self$9(vars) {
      const {
        dividerColor,
        cardColor,
        modalColor,
        popoverColor,
        tableHeaderColor,
        tableColorStriped,
        textColor1,
        textColor2,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$2), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight: lineHeight2,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        tdColorStriped: composite(cardColor, tableColorStriped),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        tdTextColor: textColor2,
        thFontWeight: fontWeightStrong
      });
    }
    const tableDark = {
      name: "Table",
      common: derived$1,
      self: self$9
    };
    const sizeVariables$1 = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabGapSmallLineVertical: "8px",
      tabGapMediumLineVertical: "8px",
      tabGapLargeLineVertical: "8px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabPaddingVerticalSmallLine: "6px 12px",
      tabPaddingVerticalMediumLine: "8px 16px",
      tabPaddingVerticalLargeLine: "10px 20px",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabGapSmallBarVertical: "8px",
      tabGapMediumBarVertical: "8px",
      tabGapLargeBarVertical: "8px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabPaddingVerticalSmallBar: "6px 12px",
      tabPaddingVerticalMediumBar: "8px 16px",
      tabPaddingVerticalLargeBar: "10px 20px",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabGapSmallCardVertical: "4px",
      tabGapMediumCardVertical: "4px",
      tabGapLargeCardVertical: "4px",
      tabPaddingSmallCard: "8px 16px",
      tabPaddingMediumCard: "10px 20px",
      tabPaddingLargeCard: "12px 24px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabPaddingVerticalLargeSegment: "0 8px",
      tabPaddingVerticalSmallCard: "8px 12px",
      tabPaddingVerticalMediumCard: "10px 16px",
      tabPaddingVerticalLargeCard: "12px 20px",
      tabPaddingVerticalSmallSegment: "0 4px",
      tabPaddingVerticalMediumSegment: "0 6px",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      tabGapSmallSegmentVertical: "0",
      tabGapMediumSegmentVertical: "0",
      tabGapLargeSegmentVertical: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };
    function self$8(vars) {
      const {
        textColor2,
        primaryColor,
        textColorDisabled,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        tabColor,
        baseColor,
        dividerColor,
        fontWeight,
        textColor1,
        borderRadius,
        fontSize: fontSize2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$1), {
        colorSegment: tabColor,
        tabFontSizeCard: fontSize2,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      });
    }
    const tabsDark = {
      name: "Tabs",
      common: derived$1,
      self(vars) {
        const commonSelf = self$8(vars);
        const {
          inputColor
        } = vars;
        commonSelf.colorSegment = inputColor;
        commonSelf.tabColorSegment = inputColor;
        return commonSelf;
      }
    };
    function self$7(vars) {
      const {
        textColor1,
        textColor2,
        fontWeightStrong,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        titleTextColor: textColor1,
        textColor: textColor2,
        titleFontWeight: fontWeightStrong
      };
    }
    const thingDark = {
      name: "Thing",
      common: derived$1,
      self: self$7
    };
    const sizeVariables = {
      titleMarginMedium: "0 0 6px 0",
      titleMarginLarge: "-2px 0 6px 0",
      titleFontSizeMedium: "14px",
      titleFontSizeLarge: "16px",
      iconSizeMedium: "14px",
      iconSizeLarge: "14px"
    };
    const timelineDark = {
      name: "Timeline",
      common: derived$1,
      self(vars) {
        const {
          textColor3,
          infoColorSuppl,
          errorColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          textColor1,
          textColor2,
          railColor,
          fontWeightStrong,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables), {
          contentFontSize: fontSize2,
          titleFontWeight: fontWeightStrong,
          circleBorder: `2px solid ${textColor3}`,
          circleBorderInfo: `2px solid ${infoColorSuppl}`,
          circleBorderError: `2px solid ${errorColorSuppl}`,
          circleBorderSuccess: `2px solid ${successColorSuppl}`,
          circleBorderWarning: `2px solid ${warningColorSuppl}`,
          iconColor: textColor3,
          iconColorInfo: infoColorSuppl,
          iconColorError: errorColorSuppl,
          iconColorSuccess: successColorSuppl,
          iconColorWarning: warningColorSuppl,
          titleTextColor: textColor1,
          contentTextColor: textColor2,
          metaTextColor: textColor3,
          lineColor: railColor
        });
      }
    };
    const commonVariables$1 = {
      extraFontSizeSmall: "12px",
      extraFontSizeMedium: "12px",
      extraFontSizeLarge: "14px",
      titleFontSizeSmall: "14px",
      titleFontSizeMedium: "16px",
      titleFontSizeLarge: "16px",
      closeSize: "20px",
      closeIconSize: "16px",
      headerHeightSmall: "44px",
      headerHeightMedium: "44px",
      headerHeightLarge: "50px"
    };
    const transferDark$1 = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          textColor3,
          hoverColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          dividerColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        });
      }
    };
    function self$6(vars) {
      const {
        borderRadiusSmall,
        dividerColor,
        hoverColor,
        pressedColor,
        primaryColor,
        textColor3,
        textColor2,
        textColorDisabled,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: "1.5",
        nodeHeight: "30px",
        nodeWrapperPadding: "3px 0",
        nodeBorderRadius: borderRadiusSmall,
        nodeColorHover: hoverColor,
        nodeColorPressed: pressedColor,
        nodeColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        arrowColor: textColor3,
        nodeTextColor: textColor2,
        nodeTextColorDisabled: textColorDisabled,
        loadingColor: primaryColor,
        dropMarkColor: primaryColor,
        lineColor: dividerColor
      };
    }
    const treeDark = {
      name: "Tree",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self(vars) {
        const {
          primaryColor
        } = vars;
        const commonSelf = self$6(vars);
        commonSelf.nodeColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        return commonSelf;
      }
    };
    const treeSelectDark = {
      name: "TreeSelect",
      common: derived$1,
      peers: {
        Tree: treeDark,
        Empty: emptyDark,
        InternalSelection: internalSelectionDark
      }
    };
    const commonVars = {
      headerFontSize1: "30px",
      headerFontSize2: "22px",
      headerFontSize3: "18px",
      headerFontSize4: "16px",
      headerFontSize5: "16px",
      headerFontSize6: "16px",
      headerMargin1: "28px 0 20px 0",
      headerMargin2: "28px 0 20px 0",
      headerMargin3: "28px 0 20px 0",
      headerMargin4: "28px 0 18px 0",
      headerMargin5: "28px 0 18px 0",
      headerMargin6: "28px 0 18px 0",
      headerPrefixWidth1: "16px",
      headerPrefixWidth2: "16px",
      headerPrefixWidth3: "12px",
      headerPrefixWidth4: "12px",
      headerPrefixWidth5: "12px",
      headerPrefixWidth6: "12px",
      headerBarWidth1: "4px",
      headerBarWidth2: "4px",
      headerBarWidth3: "3px",
      headerBarWidth4: "3px",
      headerBarWidth5: "3px",
      headerBarWidth6: "3px",
      pMargin: "16px 0 16px 0",
      liMargin: ".25em 0 0 0",
      olPadding: "0 0 0 2em",
      ulPadding: "0 0 0 2em"
    };
    function self$5(vars) {
      const {
        primaryColor,
        textColor2,
        borderColor,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        borderRadiusSmall,
        dividerColor,
        fontWeightStrong,
        textColor1,
        textColor3,
        infoColor,
        warningColor,
        errorColor,
        successColor,
        codeColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars), {
        aTextColor: primaryColor,
        blockquoteTextColor: textColor2,
        blockquotePrefixColor: borderColor,
        blockquoteLineHeight: lineHeight2,
        blockquoteFontSize: fontSize2,
        codeBorderRadius: borderRadiusSmall,
        liTextColor: textColor2,
        liLineHeight: lineHeight2,
        liFontSize: fontSize2,
        hrColor: dividerColor,
        headerFontWeight: fontWeightStrong,
        headerTextColor: textColor1,
        pTextColor: textColor2,
        pTextColor1Depth: textColor1,
        pTextColor2Depth: textColor2,
        pTextColor3Depth: textColor3,
        pLineHeight: lineHeight2,
        pFontSize: fontSize2,
        headerBarColor: primaryColor,
        headerBarColorPrimary: primaryColor,
        headerBarColorInfo: infoColor,
        headerBarColorError: errorColor,
        headerBarColorWarning: warningColor,
        headerBarColorSuccess: successColor,
        textColor: textColor2,
        textColor1Depth: textColor1,
        textColor2Depth: textColor2,
        textColor3Depth: textColor3,
        textColorPrimary: primaryColor,
        textColorInfo: infoColor,
        textColorSuccess: successColor,
        textColorWarning: warningColor,
        textColorError: errorColor,
        codeTextColor: textColor2,
        codeColor,
        codeBorder: "1px solid #0000"
      });
    }
    const typographyDark = {
      name: "Typography",
      common: derived$1,
      self: self$5
    };
    function self$4(vars) {
      const {
        iconColor,
        primaryColor,
        errorColor,
        textColor2,
        successColor,
        opacityDisabled,
        actionColor,
        borderColor,
        hoverColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        borderRadius,
        draggerColor: actionColor,
        draggerBorder: `1px dashed ${borderColor}`,
        draggerBorderHover: `1px dashed ${primaryColor}`,
        itemColorHover: hoverColor,
        itemColorHoverError: changeColor(errorColor, {
          alpha: 0.06
        }),
        itemTextColor: textColor2,
        itemTextColorError: errorColor,
        itemTextColorSuccess: successColor,
        itemIconColor: iconColor,
        itemDisabledOpacity: opacityDisabled,
        itemBorderImageCardError: `1px solid ${errorColor}`,
        itemBorderImageCard: `1px solid ${borderColor}`
      };
    }
    const uploadDark = {
      name: "Upload",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Progress: progressDark
      },
      self(vars) {
        const {
          errorColor
        } = vars;
        const commonSelf = self$4(vars);
        commonSelf.itemColorHoverError = changeColor(errorColor, {
          alpha: 0.09
        });
        return commonSelf;
      }
    };
    const watermarkDark = {
      name: "Watermark",
      common: derived$1,
      self(vars) {
        const {
          fontFamily: fontFamily2
        } = vars;
        return {
          fontFamily: fontFamily2
        };
      }
    };
    const floatButtonDark = {
      name: "FloatButton",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          buttonColor2Hover,
          buttonColor2Pressed,
          primaryColor,
          primaryColorHover,
          primaryColorPressed,
          baseColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          textColor: textColor2,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          colorHover: buttonColor2Hover,
          colorPressed: buttonColor2Pressed,
          colorPrimary: primaryColor,
          colorPrimaryHover: primaryColorHover,
          colorPrimaryPressed: primaryColorPressed,
          textColorPrimary: baseColor,
          borderRadiusSquare: borderRadius
        };
      }
    };
    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
    const style$2 = cB("form", [cM$1("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c("&:last-child", {
      marginRight: 0
    })])])]);
    var __awaiter$1 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formProps = Object.assign(Object.assign({}, useTheme.props), {
      inline: Boolean,
      labelWidth: [Number, String],
      labelAlign: String,
      labelPlacement: {
        type: String,
        default: "top"
      },
      model: {
        type: Object,
        default: () => {
        }
      },
      rules: Object,
      disabled: Boolean,
      size: String,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: true
      },
      onSubmit: {
        type: Function,
        default: (e) => {
          e.preventDefault();
        }
      },
      showLabel: {
        type: Boolean,
        default: void 0
      },
      validateMessages: Object
    });
    const NForm = /* @__PURE__ */ defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const {
          mergedClsPrefixRef
        } = useConfig(props);
        useTheme("Form", "-form", style$2, formLight, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        function validate(validateCallback_1) {
          return __awaiter$1(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
            return yield new Promise((resolve2, reject) => {
              const formItemValidationPromises = [];
              for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                  if (formItemInstance.path) {
                    formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                  }
                }
              }
              void Promise.all(formItemValidationPromises).then((results) => {
                const formInvalid = results.some((result) => !result.valid);
                const errors = [];
                const warnings = [];
                results.forEach((result) => {
                  var _a2, _b2;
                  if ((_a2 = result.errors) === null || _a2 === void 0 ? void 0 : _a2.length) {
                    errors.push(result.errors);
                  }
                  if ((_b2 = result.warnings) === null || _b2 === void 0 ? void 0 : _b2.length) {
                    warnings.push(result.warnings);
                  }
                });
                if (validateCallback) {
                  validateCallback(errors.length ? errors : void 0, {
                    warnings: warnings.length ? warnings : void 0
                  });
                }
                if (formInvalid) {
                  reject(errors.length ? errors : void 0);
                } else {
                  resolve2({
                    warnings: warnings.length ? warnings : void 0
                  });
                }
              });
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        provide(formItemInstsInjectionKey, {
          formItems
        });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h("form", {
          class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
          onSubmit: this.onSubmit
        }, this.$slots);
      }
    });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
        o2.__proto__ = p22;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i >= len) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip2 = function ip22(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip2.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip2.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip2.v4().source;
      var ipv6 = ip2.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float2(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex2(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc2) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc22() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys = options.keys || Object.keys(this.rules);
        keys.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys = Object.keys(rule);
        var messageIndex = keys.indexOf("message");
        if (messageIndex !== -1) {
          keys.splice(messageIndex, 1);
        }
        if (keys.length === 1 && keys[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    const {
      cubicBezierEaseInOut
    } = commonVariables$n;
    function fadeDownTransition({
      name = "fade-down",
      fromOffset = "-4px",
      enterDuration = ".3s",
      leaveDuration = ".3s",
      enterCubicBezier = cubicBezierEaseInOut,
      leaveCubicBezier = cubicBezierEaseInOut
    } = {}) {
      return [c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }
    const style$1 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE$1("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE$1("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM$1("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM$1("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM$1("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM$1("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM$1("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM$1("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE$1("text", `
 grid-area: text; 
 `), cE$1("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM$1("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM$1("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM$1("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM$1("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);
    function formItemSize(props) {
      const NForm2 = inject(formInjectionKey, null);
      return {
        mergedSize: computed(() => {
          if (props.size !== void 0) return props.size;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0) return NForm2.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm2 = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
        const {
          labelPlacement
        } = props;
        if (labelPlacement !== void 0) return labelPlacement;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement) return NForm2.props.labelPlacement;
        return "top";
      });
      const isAutoLabelWidthRef = computed(() => {
        return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
      });
      const mergedLabelWidthRef = computed(() => {
        if (mergedLabelPlacementRef.value === "top") return;
        const {
          labelWidth
        } = props;
        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }
        if (isAutoLabelWidthRef.value) {
          const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
          return formatLength(NForm2.props.labelWidth);
        }
        return void 0;
      });
      const mergedLabelAlignRef = computed(() => {
        const {
          labelAlign
        } = props;
        if (labelAlign) return labelAlign;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign) return NForm2.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = computed(() => {
        var _a2;
        return [(_a2 = props.labelProps) === null || _a2 === void 0 ? void 0 : _a2.style, props.labelStyle, {
          width: mergedLabelWidthRef.value
        }];
      });
      const mergedShowRequireMarkRef = computed(() => {
        const {
          showRequireMark
        } = props;
        if (showRequireMark !== void 0) return showRequireMark;
        return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
        const {
          requireMarkPlacement
        } = props;
        if (requireMarkPlacement !== void 0) return requireMarkPlacement;
        return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = ref(false);
      const validationWarnedRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
        const {
          validationStatus
        } = props;
        if (validationStatus !== void 0) return validationStatus;
        if (validationErroredRef.value) return "error";
        if (validationWarnedRef.value) return "warning";
        return void 0;
      });
      const mergedShowFeedbackRef = computed(() => {
        const {
          showFeedback
        } = props;
        if (showFeedback !== void 0) return showFeedback;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0) return NForm2.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = computed(() => {
        const {
          showLabel
        } = props;
        if (showLabel !== void 0) return showLabel;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0) return NForm2.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        validationWarned: validationWarnedRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef,
        isAutoLabelWidth: isAutoLabelWidthRef
      };
    }
    function formItemRule(props) {
      const NForm2 = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
        const {
          rulePath
        } = props;
        if (rulePath !== void 0) return rulePath;
        const {
          path
        } = props;
        if (path !== void 0) return path;
        return void 0;
      });
      const mergedRulesRef = computed(() => {
        const rules2 = [];
        const {
          rule
        } = props;
        if (rule !== void 0) {
          if (Array.isArray(rule)) rules2.push(...rule);
          else rules2.push(rule);
        }
        if (NForm2) {
          const {
            rules: formRules
          } = NForm2.props;
          const {
            value: rulePath
          } = compatibleRulePathRef;
          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = get(formRules, rulePath);
            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules2.push(...formRule);
              } else {
                rules2.push(formRule);
              }
            }
          }
        }
        return rules2;
      });
      const hasRequiredRuleRef = computed(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
      });
      const mergedRequiredRef = computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }
    var __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
      label: String,
      labelWidth: [Number, String],
      labelStyle: [String, Object],
      labelAlign: String,
      labelPlacement: String,
      path: String,
      first: Boolean,
      rulePath: String,
      required: Boolean,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: void 0
      },
      rule: [Object, Array],
      size: String,
      ignorePathChange: Boolean,
      validationStatus: String,
      feedback: String,
      feedbackClass: String,
      feedbackStyle: [String, Object],
      showLabel: {
        type: Boolean,
        default: void 0
      },
      labelProps: Object
    });
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
            return true;
          }
        } catch (err) {
          warn("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
          console.error(err);
          return void 0;
        }
      };
    }
    const NFormItem = /* @__PURE__ */ defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const NForm2 = inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const {
          validationErrored: validationErroredRef,
          validationWarned: validationWarnedRef
        } = formItemMiscRefs;
        const {
          mergedRequired: mergedRequiredRef,
          mergedRules: mergedRulesRef
        } = formItemRule(props);
        const {
          mergedSize: mergedSizeRef
        } = formItemSizeRefs;
        const {
          mergedLabelPlacement: labelPlacementRef,
          mergedLabelAlign: labelTextAlignRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
        } = formItemMiscRefs;
        const renderExplainsRef = ref([]);
        const feedbackIdRef = ref(createId());
        const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
        const themeRef = useTheme("Form", "-form-item", style$1, formLight, props, mergedClsPrefixRef);
        watch(toRef(props, "path"), () => {
          if (props.ignorePathChange) return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          validationWarnedRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        const internalValidate = (...args_1) => __awaiter(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) {
          const {
            path
          } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first) options.first = props.first;
          }
          const {
            value: rules2
          } = mergedRulesRef;
          const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          })).filter(shouldRuleBeApplied).map((rule, i) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
          const activeWarningRules = activeRules.filter((r) => r.level === "warning");
          const validationResult = {
            valid: true,
            errors: void 0,
            warnings: void 0
          };
          if (!activeRules.length) return validationResult;
          const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
          const validator = new Schema({
            [mergedPath]: activeErrorRules
          });
          const warningValidator = new Schema({
            [mergedPath]: activeWarningRules
          });
          const {
            validateMessages
          } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
          if (validateMessages) {
            validator.messages(validateMessages);
            warningValidator.messages(validateMessages);
          }
          const renderMessages = (errors) => {
            renderExplainsRef.value = errors.map((error) => {
              const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
              return {
                key: transformedMessage,
                render: () => {
                  if (transformedMessage.startsWith("__renderMessage__")) {
                    return messageRenderers[transformedMessage]();
                  }
                  return transformedMessage;
                }
              };
            });
            errors.forEach((error) => {
              var _a2;
              if ((_a2 = error.message) === null || _a2 === void 0 ? void 0 : _a2.startsWith("__renderMessage__")) {
                error.message = originalMessageRendersMessage[error.message];
              }
            });
          };
          if (activeErrorRules.length) {
            const errors = yield new Promise((resolve2) => {
              void validator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (errors === null || errors === void 0 ? void 0 : errors.length) {
              validationResult.valid = false;
              validationResult.errors = errors;
              renderMessages(errors);
            }
          }
          if (activeWarningRules.length && !validationResult.errors) {
            const warnings = yield new Promise((resolve2) => {
              void warningValidator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
              renderMessages(warnings);
              validationResult.warnings = warnings;
            }
          }
          if (!validationResult.errors && !validationResult.warnings) {
            restoreValidation();
          } else {
            validationErroredRef.value = !!validationResult.errors;
            validationWarnedRef.value = !!validationResult.warnings;
          }
          return validationResult;
        });
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        function validate(options, callback) {
          return __awaiter(this, void 0, void 0, function* () {
            let trigger2;
            let validateCallback;
            let shouldRuleBeApplied;
            let asyncValidatorOptions;
            if (typeof options === "string") {
              trigger2 = options;
              validateCallback = callback;
            } else if (options !== null && typeof options === "object") {
              trigger2 = options.trigger;
              validateCallback = options.callback;
              shouldRuleBeApplied = options.shouldRuleBeApplied;
              asyncValidatorOptions = options.options;
            }
            return yield new Promise((resolve2, reject) => {
              void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
                valid,
                errors,
                warnings
              }) => {
                if (valid) {
                  if (validateCallback) {
                    validateCallback(void 0, {
                      warnings
                    });
                  }
                  resolve2({
                    warnings
                  });
                } else {
                  if (validateCallback) {
                    validateCallback(errors, {
                      warnings
                    });
                  }
                  reject(errors);
                }
              });
            });
          });
        }
        provide(formItemInjectionKey, {
          path: toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = ref(null);
        onMounted(() => {
          if (!formItemMiscRefs.isAutoLabelWidth.value) return;
          const labelElement = labelElementRef.value;
          if (labelElement !== null) {
            const memoizedWhitespace = labelElement.style.whiteSpace;
            labelElement.style.whiteSpace = "nowrap";
            labelElement.style.width = "";
            NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
            labelElement.style.whiteSpace = memoizedWhitespace;
          }
        });
        const cssVarsRef = computed(() => {
          var _a2;
          const {
            value: size2
          } = mergedSizeRef;
          const {
            value: labelPlacement
          } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              labelTextColor,
              asteriskColor,
              lineHeight: lineHeight2,
              feedbackTextColor,
              feedbackTextColorWarning,
              feedbackTextColorError,
              feedbackPadding,
              labelFontWeight,
              [createKey("labelHeight", size2)]: labelHeight,
              [createKey("blankHeight", size2)]: blankHeight,
              [createKey("feedbackFontSize", size2)]: feedbackFontSize,
              [createKey("feedbackHeight", size2)]: feedbackHeight,
              [createKey("labelPadding", direction)]: labelPadding,
              [createKey("labelTextAlign", direction)]: labelTextAlign,
              [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize
            }
          } = themeRef.value;
          let mergedLabelTextAlign = (_a2 = labelTextAlignRef.value) !== null && _a2 !== void 0 ? _a2 : labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-line-height": lineHeight2,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-label-font-weight": labelFontWeight,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
          var _a2;
          return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a2 = labelTextAlignRef.value) === null || _a2 === void 0 ? void 0 : _a2[0]) || ""}`;
        }), cssVarsRef, props) : void 0;
        const reverseColSpaceRef = computed(() => {
          return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
        });
        return Object.assign(Object.assign(Object.assign(Object.assign({
          labelElementRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRequired: mergedRequiredRef,
          feedbackId: feedbackIdRef,
          renderExplains: renderExplainsRef,
          reverseColSpace: reverseColSpaceRef
        }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          mergedShowLabel,
          mergedShowRequireMark,
          mergedRequireMarkPlacement,
          onRender
        } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderLabel = () => {
          const labelText = this.$slots.label ? this.$slots.label() : this.label;
          if (!labelText) return null;
          const textNode = h("span", {
            class: `${mergedClsPrefix}-form-item-label__text`
          }, labelText);
          const markNode = renderedShowRequireMark ? h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk`
          }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
          }, " *");
          const {
            labelProps
          } = this;
          return h("label", Object.assign({}, labelProps, {
            class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
            style: this.mergedLabelStyle,
            ref: "labelElementRef"
          }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
        };
        return h("div", {
          class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
          style: this.cssVars
        }, mergedShowLabel && renderLabel(), h("div", {
          class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]
        }, $slots), this.mergedShowFeedback ? h("div", {
          key: this.feedbackId,
          style: this.feedbackStyle,
          class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
        }, h(Transition, {
          name: "fade-down-transition",
          mode: "out-in"
        }, {
          default: () => {
            const {
              mergedValidationStatus
            } = this;
            return resolveWrappedSlot($slots.feedback, (children) => {
              var _a2;
              const {
                feedback
              } = this;
              const feedbackNodes = children || feedback ? h("div", {
                key: "__feedback__",
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, children || feedback) : this.renderExplains.length ? (_a2 = this.renderExplains) === null || _a2 === void 0 ? void 0 : _a2.map(({
                key,
                render: render2
              }) => h("div", {
                key,
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, render2())) : null;
              return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", {
                key: "controlled-warning",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
              }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", {
                key: "controlled-error",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
              }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", {
                key: "controlled-success",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
              }, feedbackNodes) : h("div", {
                key: "controlled-default",
                class: `${mergedClsPrefix}-form-item-feedback`
              }, feedbackNodes) : null;
            });
          }
        })) : null);
      }
    });
    function self$3(vars) {
      const {
        primaryColor,
        baseColor
      } = vars;
      return {
        color: primaryColor,
        iconColor: baseColor
      };
    }
    const iconDark = {
      name: "IconWrapper",
      common: derived$1,
      self: self$3
    };
    const imageDark = {
      name: "Image",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      },
      self: (vars) => {
        const {
          textColor2
        } = vars;
        return {
          toolbarIconColor: textColor2,
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
    };
    const commonVariables = {
      extraFontSize: "12px",
      width: "440px"
    };
    const transferDark = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          iconColorDisabled,
          iconColor,
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          heightSmall,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          hoverColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: "#0000",
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        });
      }
    };
    function self$2() {
      return {};
    }
    const marqueeDark = {
      name: "Marquee",
      common: derived$1,
      self: self$2
    };
    const qrcodeDark = {
      name: "QrCode",
      common: derived$1,
      self: (vars) => {
        return {
          borderRadius: vars.borderRadius
        };
      }
    };
    const skeletonDark = {
      name: "Skeleton",
      common: derived$1,
      self(vars) {
        const {
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius
        } = vars;
        return {
          color: "rgba(255, 255, 255, 0.12)",
          colorEnd: "rgba(255, 255, 255, 0.18)",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      }
    };
    const splitDark = {
      name: "Split",
      common: derived$1
    };
    const style = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE$1("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE$1("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE$1("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE$1("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE$1("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c("&:focus", [cE$1("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM$1("round", [cE$1("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE$1("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM$1("rubber-band", [cM$1("pressed", [cE$1("rail", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cE$1("rail", [c("&:active", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cM$1("active", [cM$1("pressed", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE$1("rail", [c("&:active", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM$1("active", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE$1("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE$1("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE$1("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM$1("active", [cE$1("rail", "background-color: var(--n-rail-color-active);")]), cM$1("loading", [cE$1("rail", `
 cursor: wait;
 `)]), cM$1("disabled", [cE$1("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
    const switchProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      loading: Boolean,
      defaultValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      round: {
        type: Boolean,
        default: true
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      railStyle: Function,
      rubberBand: {
        type: Boolean,
        default: true
      },
      /** @deprecated */
      onChange: [Function, Array]
    });
    let supportCssMax;
    const NSwitch = /* @__PURE__ */ defineComponent({
      name: "Switch",
      props: switchProps,
      slots: Object,
      setup(props) {
        if (supportCssMax === void 0) {
          if (typeof CSS !== "undefined") {
            if (typeof CSS.supports !== "undefined") {
              supportCssMax = CSS.supports("width", "max(1px)");
            } else {
              supportCssMax = false;
            }
          } else {
            supportCssMax = true;
          }
        }
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Switch", "-switch", style, switchLight, props, mergedClsPrefixRef);
        const formItem = useFormItem(props);
        const {
          mergedSizeRef,
          mergedDisabledRef
        } = formItem;
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedRef = computed(() => {
          return mergedValueRef.value === props.checkedValue;
        });
        const pressedRef = ref(false);
        const focusedRef = ref(false);
        const mergedRailStyleRef = computed(() => {
          const {
            railStyle
          } = props;
          if (!railStyle) return void 0;
          return railStyle({
            focused: focusedRef.value,
            checked: checkedRef.value
          });
        });
        function doUpdateValue(value) {
          const {
            "onUpdate:value": _onUpdateValue,
            onChange,
            onUpdateValue
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (_onUpdateValue) call(_onUpdateValue, value);
          if (onUpdateValue) call(onUpdateValue, value);
          if (onChange) call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doFocus() {
          const {
            nTriggerFormFocus
          } = formItem;
          nTriggerFormFocus();
        }
        function doBlur() {
          const {
            nTriggerFormBlur
          } = formItem;
          nTriggerFormBlur();
        }
        function handleClick() {
          if (props.loading || mergedDisabledRef.value) return;
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
        }
        function handleFocus() {
          focusedRef.value = true;
          doFocus();
        }
        function handleBlur() {
          focusedRef.value = false;
          doBlur();
          pressedRef.value = false;
        }
        function handleKeyup(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
            pressedRef.value = false;
          }
        }
        function handleKeydown(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            e.preventDefault();
            pressedRef.value = true;
          }
        }
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            self: {
              opacityDisabled,
              railColor,
              railColorActive,
              buttonBoxShadow,
              buttonColor,
              boxShadowFocus,
              loadingColor,
              textColor,
              iconColor,
              [createKey("buttonHeight", size2)]: buttonHeight,
              [createKey("buttonWidth", size2)]: buttonWidth,
              [createKey("buttonWidthPressed", size2)]: buttonWidthPressed,
              [createKey("railHeight", size2)]: railHeight,
              [createKey("railWidth", size2)]: railWidth,
              [createKey("railBorderRadius", size2)]: railBorderRadius,
              [createKey("buttonBorderRadius", size2)]: buttonBorderRadius
            },
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            }
          } = themeRef.value;
          let offset;
          let height;
          let width;
          if (supportCssMax) {
            offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
            height = `max(${railHeight}, ${buttonHeight})`;
            width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
          } else {
            offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
            height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
            width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
          }
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-color": buttonColor,
            "--n-button-width": buttonWidth,
            "--n-button-width-pressed": buttonWidthPressed,
            "--n-button-height": buttonHeight,
            "--n-height": height,
            "--n-offset": offset,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-border-radius": railBorderRadius,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-height": railHeight,
            "--n-rail-width": railWidth,
            "--n-width": width,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", computed(() => {
          return mergedSizeRef.value[0];
        }), cssVarsRef, props) : void 0;
        return {
          handleClick,
          handleBlur,
          handleFocus,
          handleKeyup,
          handleKeydown,
          mergedRailStyle: mergedRailStyleRef,
          pressed: pressedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          checked: checkedRef,
          mergedDisabled: mergedDisabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedDisabled,
          checked,
          mergedRailStyle,
          onRender,
          $slots
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const {
          checked: checkedSlot,
          unchecked: uncheckedSlot,
          icon: iconSlot,
          "checked-icon": checkedIconSlot,
          "unchecked-icon": uncheckedIconSlot
        } = $slots;
        const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
        return h("div", {
          role: "switch",
          "aria-checked": checked,
          class: [`${mergedClsPrefix}-switch`, this.themeClass, hasIcon && `${mergedClsPrefix}-switch--icon`, checked && `${mergedClsPrefix}-switch--active`, mergedDisabled && `${mergedClsPrefix}-switch--disabled`, this.round && `${mergedClsPrefix}-switch--round`, this.loading && `${mergedClsPrefix}-switch--loading`, this.pressed && `${mergedClsPrefix}-switch--pressed`, this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`],
          tabindex: !this.mergedDisabled ? 0 : void 0,
          style: this.cssVars,
          onClick: this.handleClick,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, h("div", {
          class: `${mergedClsPrefix}-switch__rail`,
          "aria-hidden": "true",
          style: mergedRailStyle
        }, resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
          if (checkedSlotChildren || uncheckedSlotChildren) {
            return h("div", {
              "aria-hidden": true,
              class: `${mergedClsPrefix}-switch__children-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), checkedSlotChildren), h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), uncheckedSlotChildren));
          }
          return null;
        })), h("div", {
          class: `${mergedClsPrefix}-switch__button`
        }, resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
          return h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              key: "loading",
              clsPrefix: mergedClsPrefix,
              strokeWidth: 20
            }) : this.checked && (checkedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: checkedIcon ? "checked-icon" : "icon"
            }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: uncheckedIcon ? "unchecked-icon" : "icon"
            }, uncheckedIcon || icon) : null
          });
        }))), resolveWrappedSlot(checkedSlot, (children) => children && h("div", {
          key: "checked",
          class: `${mergedClsPrefix}-switch__checked`
        }, children)), resolveWrappedSlot(uncheckedSlot, (children) => children && h("div", {
          key: "unchecked",
          class: `${mergedClsPrefix}-switch__unchecked`
        }, children)))));
      }
    });
    const self$1 = () => ({});
    const equationDark = {
      name: "Equation",
      common: derived$1,
      self: self$1
    };
    const floatButtonGroupDark = {
      name: "FloatButtonGroup",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          dividerColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          buttonBorderColor: dividerColor,
          borderRadiusSquare: borderRadius,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)"
        };
      }
    };
    const darkTheme = {
      name: "dark",
      common: derived$1,
      Alert: alertDark,
      Anchor: anchorDark,
      AutoComplete: autoCompleteDark,
      Avatar: avatarDark,
      AvatarGroup: avatarGroupDark,
      BackTop: backTopDark,
      Badge: badgeDark,
      Breadcrumb: breadcrumbDark,
      Button: buttonDark,
      ButtonGroup: buttonGroupDark,
      Calendar: calendarDark,
      Card: cardDark,
      Carousel: carouselDark,
      Cascader: cascaderDark,
      Checkbox: checkboxDark,
      Code: codeDark,
      Collapse: collapseDark,
      CollapseTransition: collapseTransitionDark,
      ColorPicker: colorPickerDark,
      DataTable: dataTableDark,
      DatePicker: datePickerDark,
      Descriptions: descriptionsDark,
      Dialog: dialogDark,
      Divider: dividerDark,
      Drawer: drawerDark,
      Dropdown: dropdownDark,
      DynamicInput: dynamicInputDark,
      DynamicTags: dynamicTagsDark,
      Element: elementDark,
      Empty: emptyDark,
      Ellipsis: ellipsisDark,
      Equation: equationDark,
      Flex: flexDark,
      Form: formItemDark,
      GradientText: gradientTextDark,
      Icon: iconDark$1,
      IconWrapper: iconDark,
      Image: imageDark,
      Input: inputDark,
      InputNumber: inputNumberDark,
      LegacyTransfer: transferDark,
      Layout: layoutDark,
      List: listDark$1,
      LoadingBar: loadingBarDark,
      Log: logDark,
      Menu: menuDark,
      Mention: listDark,
      Message: messageDark,
      Modal: modalDark,
      Notification: notificationDark,
      PageHeader: pageHeaderDark,
      Pagination: paginationDark,
      Popconfirm: popconfirmDark,
      Popover: popoverDark,
      Popselect: popselect,
      Progress: progressDark,
      QrCode: qrcodeDark,
      Radio: radioDark,
      Rate: rateDark,
      Result: resultDark,
      Row: rowDark,
      Scrollbar: scrollbarDark,
      Select: selectDark,
      Skeleton: skeletonDark,
      Slider: sliderDark,
      Space: spaceDark,
      Spin: spinDark,
      Statistic: statisticDark,
      Steps: stepsDark,
      Switch: switchDark,
      Table: tableDark,
      Tabs: tabsDark,
      Tag: tagDark,
      Thing: thingDark,
      TimePicker: timePickerDark,
      Timeline: timelineDark,
      Tooltip: tooltipDark,
      Transfer: transferDark$1,
      Tree: treeDark,
      TreeSelect: treeSelectDark,
      Typography: typographyDark,
      Upload: uploadDark,
      Watermark: watermarkDark,
      Split: splitDark,
      FloatButton: floatButtonDark,
      FloatButtonGroup: floatButtonGroupDark,
      Marquee: marqueeDark
    };
    const _imports_0 = "/yiitap/logo.png";
    var rb = Object.defineProperty;
    var ob = (t2, e, n) => e in t2 ? rb(t2, e, { enumerable: true, configurable: true, writable: true, value: n }) : t2[e] = n;
    var ft = (t2, e, n) => ob(t2, typeof e != "symbol" ? e + "" : e, n);
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function It(t2) {
      this.content = t2;
    }
    It.prototype = {
      constructor: It,
      find: function(t2) {
        for (var e = 0; e < this.content.length; e += 2)
          if (this.content[e] === t2) return e;
        return -1;
      },
      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(t2) {
        var e = this.find(t2);
        return e == -1 ? void 0 : this.content[e + 1];
      },
      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(t2, e, n) {
        var r = n && n != t2 ? this.remove(n) : this, o = r.find(t2), i = r.content.slice();
        return o == -1 ? i.push(n || t2, e) : (i[o + 1] = e, n && (i[o] = n)), new It(i);
      },
      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(t2) {
        var e = this.find(t2);
        if (e == -1) return this;
        var n = this.content.slice();
        return n.splice(e, 2), new It(n);
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(t2, e) {
        return new It([t2, e].concat(this.remove(t2).content));
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(t2, e) {
        var n = this.remove(t2).content.slice();
        return n.push(t2, e), new It(n);
      },
      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(t2, e, n) {
        var r = this.remove(e), o = r.content.slice(), i = r.find(t2);
        return o.splice(i == -1 ? o.length : i, 0, e, n), new It(o);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(t2) {
        for (var e = 0; e < this.content.length; e += 2)
          t2(this.content[e], this.content[e + 1]);
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(t2) {
        return t2 = It.from(t2), t2.size ? new It(t2.content.concat(this.subtract(t2).content)) : this;
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(t2) {
        return t2 = It.from(t2), t2.size ? new It(this.subtract(t2).content.concat(t2.content)) : this;
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(t2) {
        var e = this;
        t2 = It.from(t2);
        for (var n = 0; n < t2.content.length; n += 2)
          e = e.remove(t2.content[n]);
        return e;
      },
      // :: () → Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var t2 = {};
        return this.forEach(function(e, n) {
          t2[e] = n;
        }), t2;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    It.from = function(t2) {
      if (t2 instanceof It) return t2;
      var e = [];
      if (t2) for (var n in t2) e.push(n, t2[n]);
      return new It(e);
    };
    function lf(t2, e, n) {
      for (let r = 0; ; r++) {
        if (r == t2.childCount || r == e.childCount)
          return t2.childCount == e.childCount ? null : n;
        let o = t2.child(r), i = e.child(r);
        if (o == i) {
          n += o.nodeSize;
          continue;
        }
        if (!o.sameMarkup(i))
          return n;
        if (o.isText && o.text != i.text) {
          for (let s = 0; o.text[s] == i.text[s]; s++)
            n++;
          return n;
        }
        if (o.content.size || i.content.size) {
          let s = lf(o.content, i.content, n + 1);
          if (s != null)
            return s;
        }
        n += o.nodeSize;
      }
    }
    function cf(t2, e, n, r) {
      for (let o = t2.childCount, i = e.childCount; ; ) {
        if (o == 0 || i == 0)
          return o == i ? null : { a: n, b: r };
        let s = t2.child(--o), a = e.child(--i), l = s.nodeSize;
        if (s == a) {
          n -= l, r -= l;
          continue;
        }
        if (!s.sameMarkup(a))
          return { a: n, b: r };
        if (s.isText && s.text != a.text) {
          let c2 = 0, u = Math.min(s.text.length, a.text.length);
          for (; c2 < u && s.text[s.text.length - c2 - 1] == a.text[a.text.length - c2 - 1]; )
            c2++, n--, r--;
          return { a: n, b: r };
        }
        if (s.content.size || a.content.size) {
          let c2 = cf(s.content, a.content, n - 1, r - 1);
          if (c2)
            return c2;
        }
        n -= l, r -= l;
      }
    }
    class R {
      /**
      @internal
      */
      constructor(e, n) {
        if (this.content = e, this.size = n || 0, n == null)
          for (let r = 0; r < e.length; r++)
            this.size += e[r].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(e, n, r, o = 0, i) {
        for (let s = 0, a = 0; a < n; s++) {
          let l = this.content[s], c2 = a + l.nodeSize;
          if (c2 > e && r(l, o + a, i || null, s) !== false && l.content.size) {
            let u = a + 1;
            l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, o + u);
          }
          a = c2;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(e) {
        this.nodesBetween(0, this.size, e);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(e, n, r, o) {
        let i = "", s = true;
        return this.nodesBetween(e, n, (a, l) => {
          let c2 = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? o ? typeof o == "function" ? o(a) : o : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
          a.isBlock && (a.isLeaf && c2 || a.isTextblock) && r && (s ? s = false : i += r), i += c2;
        }, 0), i;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(e) {
        if (!e.size)
          return this;
        if (!this.size)
          return e;
        let n = this.lastChild, r = e.firstChild, o = this.content.slice(), i = 0;
        for (n.isText && n.sameMarkup(r) && (o[o.length - 1] = n.withText(n.text + r.text), i = 1); i < e.content.length; i++)
          o.push(e.content[i]);
        return new R(o, this.size + e.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(e, n = this.size) {
        if (e == 0 && n == this.size)
          return this;
        let r = [], o = 0;
        if (n > e)
          for (let i = 0, s = 0; s < n; i++) {
            let a = this.content[i], l = s + a.nodeSize;
            l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), o += a.nodeSize), s = l;
          }
        return new R(r, o);
      }
      /**
      @internal
      */
      cutByIndex(e, n) {
        return e == n ? R.empty : e == 0 && n == this.content.length ? this : new R(this.content.slice(e, n));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(e, n) {
        let r = this.content[e];
        if (r == n)
          return this;
        let o = this.content.slice(), i = this.size + n.nodeSize - r.nodeSize;
        return o[e] = n, new R(o, i);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(e) {
        return new R([e].concat(this.content), this.size + e.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(e) {
        return new R(this.content.concat(e), this.size + e.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(e) {
        if (this.content.length != e.content.length)
          return false;
        for (let n = 0; n < this.content.length; n++)
          if (!this.content[n].eq(e.content[n]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(e) {
        let n = this.content[e];
        if (!n)
          throw new RangeError("Index " + e + " out of range for " + this);
        return n;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content[e] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
          let o = this.content[n];
          e(o, r, n), r += o.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(e, n = 0) {
        return lf(this, e, n);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(e, n = this.size, r = e.size) {
        return cf(this, e, n, r);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(e, n = -1) {
        if (e == 0)
          return Xi(0, e);
        if (e == this.size)
          return Xi(this.content.length, e);
        if (e > this.size || e < 0)
          throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let r = 0, o = 0; ; r++) {
          let i = this.child(r), s = o + i.nodeSize;
          if (s >= e)
            return s == e || n > 0 ? Xi(r + 1, s) : Xi(r, o);
          o = s;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((e) => e.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          return R.empty;
        if (!Array.isArray(n))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new R(n.map(e.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(e) {
        if (!e.length)
          return R.empty;
        let n, r = 0;
        for (let o = 0; o < e.length; o++) {
          let i = e[o];
          r += i.nodeSize, o && i.isText && e[o - 1].sameMarkup(i) ? (n || (n = e.slice(0, o)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i);
        }
        return new R(n || e, r);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(e) {
        if (!e)
          return R.empty;
        if (e instanceof R)
          return e;
        if (Array.isArray(e))
          return this.fromArray(e);
        if (e.attrs)
          return new R([e], e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }
    R.empty = new R([], 0);
    const el = { index: 0, offset: 0 };
    function Xi(t2, e) {
      return el.index = t2, el.offset = e, el;
    }
    function Rs(t2, e) {
      if (t2 === e)
        return true;
      if (!(t2 && typeof t2 == "object") || !(e && typeof e == "object"))
        return false;
      let n = Array.isArray(t2);
      if (Array.isArray(e) != n)
        return false;
      if (n) {
        if (t2.length != e.length)
          return false;
        for (let r = 0; r < t2.length; r++)
          if (!Rs(t2[r], e[r]))
            return false;
      } else {
        for (let r in t2)
          if (!(r in e) || !Rs(t2[r], e[r]))
            return false;
        for (let r in e)
          if (!(r in t2))
            return false;
      }
      return true;
    }
    let Xe = class Bl {
      /**
      @internal
      */
      constructor(e, n) {
        this.type = e, this.attrs = n;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(e) {
        let n, r = false;
        for (let o = 0; o < e.length; o++) {
          let i = e[o];
          if (this.eq(i))
            return e;
          if (this.type.excludes(i.type))
            n || (n = e.slice(0, o));
          else {
            if (i.type.excludes(this.type))
              return e;
            !r && i.type.rank > this.type.rank && (n || (n = e.slice(0, o)), n.push(this), r = true), n && n.push(i);
          }
        }
        return n || (n = e.slice()), r || n.push(this), n;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(e) {
        for (let n = 0; n < e.length; n++)
          if (this.eq(e[n]))
            return e.slice(0, n).concat(e.slice(n + 1));
        return e;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(e) {
        for (let n = 0; n < e.length; n++)
          if (this.eq(e[n]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(e) {
        return this == e || this.type == e.type && Rs(this.attrs, e.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let n in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return e;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(e, n) {
        if (!n)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let r = e.marks[n.type];
        if (!r)
          throw new RangeError(`There is no mark type ${n.type} in this schema`);
        let o = r.create(n.attrs);
        return r.checkAttrs(o.attrs), o;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(e, n) {
        if (e == n)
          return true;
        if (e.length != n.length)
          return false;
        for (let r = 0; r < e.length; r++)
          if (!e[r].eq(n[r]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
          return Bl.none;
        if (e instanceof Bl)
          return [e];
        let n = e.slice();
        return n.sort((r, o) => r.type.rank - o.type.rank), n;
      }
    };
    Xe.none = [];
    class Is extends Error {
    }
    class K {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragment—i.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(e, n, r) {
        this.content = e, this.openStart = n, this.openEnd = r;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(e, n) {
        let r = df(this.content, e + this.openStart, n);
        return r && new K(r, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(e, n) {
        return new K(uf(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let e = { content: this.content.toJSON() };
        return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          return K.empty;
        let r = n.openStart || 0, o = n.openEnd || 0;
        if (typeof r != "number" || typeof o != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new K(R.fromJSON(e, n.content), r, o);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(e, n = true) {
        let r = 0, o = 0;
        for (let i = e.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
          r++;
        for (let i = e.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
          o++;
        return new K(e, r, o);
      }
    }
    K.empty = new K(R.empty, 0, 0);
    function uf(t2, e, n) {
      let { index: r, offset: o } = t2.findIndex(e), i = t2.maybeChild(r), { index: s, offset: a } = t2.findIndex(n);
      if (o == e || i.isText) {
        if (a != n && !t2.child(s).isText)
          throw new RangeError("Removing non-flat range");
        return t2.cut(0, e).append(t2.cut(n));
      }
      if (r != s)
        throw new RangeError("Removing non-flat range");
      return t2.replaceChild(r, i.copy(uf(i.content, e - o - 1, n - o - 1)));
    }
    function df(t2, e, n, r) {
      let { index: o, offset: i } = t2.findIndex(e), s = t2.maybeChild(o);
      if (i == e || s.isText)
        return t2.cut(0, e).append(n).append(t2.cut(e));
      let a = df(s.content, e - i - 1, n);
      return a && t2.replaceChild(o, s.copy(a));
    }
    function hb(t2, e, n) {
      if (n.openStart > t2.depth)
        throw new Is("Inserted content deeper than insertion position");
      if (t2.depth - n.openStart != e.depth - n.openEnd)
        throw new Is("Inconsistent open depths");
      return pf(t2, e, n, 0);
    }
    function pf(t2, e, n, r) {
      let o = t2.index(r), i = t2.node(r);
      if (o == e.index(r) && r < t2.depth - n.openStart) {
        let s = pf(t2, e, n, r + 1);
        return i.copy(i.content.replaceChild(o, s));
      } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t2.depth == r && e.depth == r) {
          let s = t2.parent, a = s.content;
          return Zr(s, a.cut(0, t2.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
        } else {
          let { start: s, end: a } = mb(n, t2);
          return Zr(i, hf(t2, s, a, e, r));
        }
      else return Zr(i, Ds(t2, e, r));
    }
    function ff(t2, e) {
      if (!e.type.compatibleContent(t2.type))
        throw new Is("Cannot join " + e.type.name + " onto " + t2.type.name);
    }
    function $l(t2, e, n) {
      let r = t2.node(n);
      return ff(r, e.node(n)), r;
    }
    function Xr(t2, e) {
      let n = e.length - 1;
      n >= 0 && t2.isText && t2.sameMarkup(e[n]) ? e[n] = t2.withText(e[n].text + t2.text) : e.push(t2);
    }
    function oi(t2, e, n, r) {
      let o = (e || t2).node(n), i = 0, s = e ? e.index(n) : o.childCount;
      t2 && (i = t2.index(n), t2.depth > n ? i++ : t2.textOffset && (Xr(t2.nodeAfter, r), i++));
      for (let a = i; a < s; a++)
        Xr(o.child(a), r);
      e && e.depth == n && e.textOffset && Xr(e.nodeBefore, r);
    }
    function Zr(t2, e) {
      return t2.type.checkContent(e), t2.copy(e);
    }
    function hf(t2, e, n, r, o) {
      let i = t2.depth > o && $l(t2, e, o + 1), s = r.depth > o && $l(n, r, o + 1), a = [];
      return oi(null, t2, o, a), i && s && e.index(o) == n.index(o) ? (ff(i, s), Xr(Zr(i, hf(t2, e, n, r, o + 1)), a)) : (i && Xr(Zr(i, Ds(t2, e, o + 1)), a), oi(e, n, o, a), s && Xr(Zr(s, Ds(n, r, o + 1)), a)), oi(r, null, o, a), new R(a);
    }
    function Ds(t2, e, n) {
      let r = [];
      if (oi(null, t2, n, r), t2.depth > n) {
        let o = $l(t2, e, n + 1);
        Xr(Zr(o, Ds(t2, e, n + 1)), r);
      }
      return oi(e, null, n, r), new R(r);
    }
    function mb(t2, e) {
      let n = e.depth - t2.openStart, o = e.node(n).copy(t2.content);
      for (let i = n - 1; i >= 0; i--)
        o = e.node(i).copy(R.from(o));
      return {
        start: o.resolveNoCache(t2.openStart + n),
        end: o.resolveNoCache(o.content.size - t2.openEnd - n)
      };
    }
    class gi {
      /**
      @internal
      */
      constructor(e, n, r) {
        this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parent—text nodes are ‘flat’ in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(e) {
        return this.path[this.resolveDepth(e) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(e) {
        return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(e) {
        return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(e) {
        return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let e = this.parent, n = this.index(this.depth);
        if (n == e.childCount)
          return null;
        let r = this.pos - this.path[this.path.length - 1], o = e.child(n);
        return r ? e.child(n).cut(r) : o;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(e, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3], o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let i = 0; i < e; i++)
          o += r.child(i).nodeSize;
        return o;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let e = this.parent, n = this.index();
        if (e.content.size == 0)
          return Xe.none;
        if (this.textOffset)
          return e.child(n).marks;
        let r = e.maybeChild(n - 1), o = e.maybeChild(n);
        if (!r) {
          let a = r;
          r = o, o = a;
        }
        let i = r.marks;
        for (var s = 0; s < i.length; s++)
          i[s].type.spec.inclusive === false && (!o || !i[s].isInSet(o.marks)) && (i = i[s--].removeFromSet(i));
        return i;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross(e) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
          return null;
        let r = n.marks, o = e.parent.maybeChild(e.index());
        for (var i = 0; i < r.length; i++)
          r[i].type.spec.inclusive === false && (!o || !r[i].isInSet(o.marks)) && (r = r[i--].removeFromSet(r));
        return r;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(e) {
        for (let n = this.depth; n > 0; n--)
          if (this.start(n) <= e && this.end(n) >= e)
            return n;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(e = this, n) {
        if (e.pos < this.pos)
          return e.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
          if (e.pos <= this.end(r) && (!n || n(this.node(r))))
            return new Ls(this, e, r);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(e) {
        return e.pos > this.pos ? e : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(e) {
        return e.pos < this.pos ? e : this;
      }
      /**
      @internal
      */
      toString() {
        let e = "";
        for (let n = 1; n <= this.depth; n++)
          e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return e + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(e, n) {
        if (!(n >= 0 && n <= e.content.size))
          throw new RangeError("Position " + n + " out of range");
        let r = [], o = 0, i = n;
        for (let s = e; ; ) {
          let { index: a, offset: l } = s.content.findIndex(i), c2 = i - l;
          if (r.push(s, a, o + l), !c2 || (s = s.child(a), s.isText))
            break;
          i = c2 - 1, o += l + 1;
        }
        return new gi(n, r, i);
      }
      /**
      @internal
      */
      static resolveCached(e, n) {
        let r = Lu.get(e);
        if (r)
          for (let i = 0; i < r.elts.length; i++) {
            let s = r.elts[i];
            if (s.pos == n)
              return s;
          }
        else
          Lu.set(e, r = new gb());
        let o = r.elts[r.i] = gi.resolve(e, n);
        return r.i = (r.i + 1) % bb, o;
      }
    }
    class gb {
      constructor() {
        this.elts = [], this.i = 0;
      }
    }
    const bb = 12, Lu = /* @__PURE__ */ new WeakMap();
    class Ls {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor(e, n, r) {
        this.$from = e, this.$to = n, this.depth = r;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    }
    const yb = /* @__PURE__ */ Object.create(null);
    let Mr = class Fl {
      /**
      @internal
      */
      constructor(e, n, r, o = Xe.none) {
        this.type = e, this.attrs = n, this.marks = o, this.content = r || R.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(e) {
        return this.content.child(e);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content.maybeChild(e);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        this.content.forEach(e);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(e, n, r, o = 0) {
        this.content.nodesBetween(e, n, r, o, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(e) {
        this.nodesBetween(0, this.content.size, e);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(e, n, r, o) {
        return this.content.textBetween(e, n, r, o);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(e, n, r) {
        return this.type == e && Rs(this.attrs, n || e.defaultAttrs || yb) && Xe.sameSet(this.marks, r || Xe.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(e = null) {
        return e == this.content ? this : new Fl(this.type, this.attrs, e, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(e) {
        return e == this.marks ? this : new Fl(this.type, this.attrs, this.content, e);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(e, n = this.content.size) {
        return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(e, n = this.content.size, r = false) {
        if (e == n)
          return K.empty;
        let o = this.resolve(e), i = this.resolve(n), s = r ? 0 : o.sharedDepth(n), a = o.start(s), c2 = o.node(s).content.cut(o.pos - a, i.pos - a);
        return new K(c2, o.depth - s, i.depth - s);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(e, n, r) {
        return hb(this.resolve(e), this.resolve(n), r);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(e) {
        for (let n = this; ; ) {
          let { index: r, offset: o } = n.content.findIndex(e);
          if (n = n.maybeChild(r), !n)
            return null;
          if (o == e || n.isText)
            return n;
          e -= o + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(e) {
        let { index: n, offset: r } = this.content.findIndex(e);
        return { node: this.content.maybeChild(n), index: n, offset: r };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(e) {
        if (e == 0)
          return { node: null, index: 0, offset: 0 };
        let { index: n, offset: r } = this.content.findIndex(e);
        if (r < e)
          return { node: this.content.child(n), index: n, offset: r };
        let o = this.content.child(n - 1);
        return { node: o, index: n - 1, offset: r - o.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(e) {
        return gi.resolveCached(this, e);
      }
      /**
      @internal
      */
      resolveNoCache(e) {
        return gi.resolve(this, e);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(e, n, r) {
        let o = false;
        return n > e && this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = true), !o)), o;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"), mf(this.marks, e);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(e) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!n)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return n;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(e, n, r = R.empty, o = 0, i = r.childCount) {
        let s = this.contentMatchAt(e).matchFragment(r, o, i), a = s && s.matchFragment(this.content, n);
        if (!a || !a.validEnd)
          return false;
        for (let l = o; l < i; l++)
          if (!this.type.allowsMarks(r.child(l).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(e, n, r, o) {
        if (o && !this.type.allowsMarks(o))
          return false;
        let i = this.contentMatchAt(e).matchType(r), s = i && i.matchFragment(this.content, n);
        return s ? s.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
        let e = Xe.none;
        for (let n = 0; n < this.marks.length; n++) {
          let r = this.marks[n];
          r.type.checkAttrs(r.attrs), e = r.addToSet(e);
        }
        if (!Xe.sameSet(e, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
        this.content.forEach((n) => n.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let n in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          throw new RangeError("Invalid input for Node.fromJSON");
        let r;
        if (n.marks) {
          if (!Array.isArray(n.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          r = n.marks.map(e.markFromJSON);
        }
        if (n.type == "text") {
          if (typeof n.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return e.text(n.text, r);
        }
        let o = R.fromJSON(e, n.content), i = e.nodeType(n.type).create(n.attrs, o, r);
        return i.type.checkAttrs(i.attrs), i;
      }
    };
    Mr.prototype.text = void 0;
    class Ps extends Mr {
      /**
      @internal
      */
      constructor(e, n, r, o) {
        if (super(e, n, null, o), !r)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = r;
      }
      toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : mf(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(e, n) {
        return this.text.slice(e, n);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(e) {
        return e == this.marks ? this : new Ps(this.type, this.attrs, this.text, e);
      }
      withText(e) {
        return e == this.text ? this : new Ps(this.type, this.attrs, e, this.marks);
      }
      cut(e = 0, n = this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
      }
      eq(e) {
        return this.sameMarkup(e) && this.text == e.text;
      }
      toJSON() {
        let e = super.toJSON();
        return e.text = this.text, e;
      }
    }
    function mf(t2, e) {
      for (let n = t2.length - 1; n >= 0; n--)
        e = t2[n].type.name + "(" + e + ")";
      return e;
    }
    class io {
      /**
      @internal
      */
      constructor(e) {
        this.validEnd = e, this.next = [], this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(e, n) {
        let r = new vb(e, n);
        if (r.next == null)
          return io.empty;
        let o = gf(r);
        r.next && r.err("Unexpected trailing text");
        let i = xb(Cb(o));
        return Tb(i, r), i;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(e) {
        for (let n = 0; n < this.next.length; n++)
          if (this.next[n].type == e)
            return this.next[n].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(e, n = 0, r = e.childCount) {
        let o = this;
        for (let i = n; o && i < r; i++)
          o = o.matchType(e.child(i).type);
        return o;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
          let { type: n } = this.next[e];
          if (!(n.isText || n.hasRequiredAttrs()))
            return n;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(e) {
        for (let n = 0; n < this.next.length; n++)
          for (let r = 0; r < e.next.length; r++)
            if (this.next[n].type == e.next[r].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(e, n = false, r = 0) {
        let o = [this];
        function i(s, a) {
          let l = s.matchFragment(e, r);
          if (l && (!n || l.validEnd))
            return R.from(a.map((c2) => c2.createAndFill()));
          for (let c2 = 0; c2 < s.next.length; c2++) {
            let { type: u, next: d } = s.next[c2];
            if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(d) == -1) {
              o.push(d);
              let p2 = i(d, a.concat(u));
              if (p2)
                return p2;
            }
          }
          return null;
        }
        return i(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
          if (this.wrapCache[r] == e)
            return this.wrapCache[r + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n), n;
      }
      /**
      @internal
      */
      computeWrapping(e) {
        let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
        for (; r.length; ) {
          let o = r.shift(), i = o.match;
          if (i.matchType(e)) {
            let s = [];
            for (let a = o; a.type; a = a.via)
              s.push(a.type);
            return s.reverse();
          }
          for (let s = 0; s < i.next.length; s++) {
            let { type: a, next: l } = i.next[s];
            !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!o.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: o }), n[a.name] = true);
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_​th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(e) {
        if (e >= this.next.length)
          throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e];
      }
      /**
      @internal
      */
      toString() {
        let e = [];
        function n(r) {
          e.push(r);
          for (let o = 0; o < r.next.length; o++)
            e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
        }
        return n(this), e.map((r, o) => {
          let i = o + (r.validEnd ? "*" : " ") + " ";
          for (let s = 0; s < r.next.length; s++)
            i += (s ? ", " : "") + r.next[s].type.name + "->" + e.indexOf(r.next[s].next);
          return i;
        }).join(`
`);
      }
    }
    io.empty = new io(true);
    class vb {
      constructor(e, n) {
        this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(e) {
        return this.next == e && (this.pos++ || true);
      }
      err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')");
      }
    }
    function gf(t2) {
      let e = [];
      do
        e.push(Eb(t2));
      while (t2.eat("|"));
      return e.length == 1 ? e[0] : { type: "choice", exprs: e };
    }
    function Eb(t2) {
      let e = [];
      do
        e.push(kb(t2));
      while (t2.next && t2.next != ")" && t2.next != "|");
      return e.length == 1 ? e[0] : { type: "seq", exprs: e };
    }
    function kb(t2) {
      let e = Sb(t2);
      for (; ; )
        if (t2.eat("+"))
          e = { type: "plus", expr: e };
        else if (t2.eat("*"))
          e = { type: "star", expr: e };
        else if (t2.eat("?"))
          e = { type: "opt", expr: e };
        else if (t2.eat("{"))
          e = wb(t2, e);
        else
          break;
      return e;
    }
    function Pu(t2) {
      /\D/.test(t2.next) && t2.err("Expected number, got '" + t2.next + "'");
      let e = Number(t2.next);
      return t2.pos++, e;
    }
    function wb(t2, e) {
      let n = Pu(t2), r = n;
      return t2.eat(",") && (t2.next != "}" ? r = Pu(t2) : r = -1), t2.eat("}") || t2.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
    }
    function _b(t2, e) {
      let n = t2.nodeTypes, r = n[e];
      if (r)
        return [r];
      let o = [];
      for (let i in n) {
        let s = n[i];
        s.isInGroup(e) && o.push(s);
      }
      return o.length == 0 && t2.err("No node type or group '" + e + "' found"), o;
    }
    function Sb(t2) {
      if (t2.eat("(")) {
        let e = gf(t2);
        return t2.eat(")") || t2.err("Missing closing paren"), e;
      } else if (/\W/.test(t2.next))
        t2.err("Unexpected token '" + t2.next + "'");
      else {
        let e = _b(t2, t2.next).map((n) => (t2.inline == null ? t2.inline = n.isInline : t2.inline != n.isInline && t2.err("Mixing inline and block content"), { type: "name", value: n }));
        return t2.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
      }
    }
    function Cb(t2) {
      let e = [[]];
      return o(i(t2, 0), n()), e;
      function n() {
        return e.push([]) - 1;
      }
      function r(s, a, l) {
        let c2 = { term: l, to: a };
        return e[s].push(c2), c2;
      }
      function o(s, a) {
        s.forEach((l) => l.to = a);
      }
      function i(s, a) {
        if (s.type == "choice")
          return s.exprs.reduce((l, c2) => l.concat(i(c2, a)), []);
        if (s.type == "seq")
          for (let l = 0; ; l++) {
            let c2 = i(s.exprs[l], a);
            if (l == s.exprs.length - 1)
              return c2;
            o(c2, a = n());
          }
        else if (s.type == "star") {
          let l = n();
          return r(a, l), o(i(s.expr, l), l), [r(l)];
        } else if (s.type == "plus") {
          let l = n();
          return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)];
        } else {
          if (s.type == "opt")
            return [r(a)].concat(i(s.expr, a));
          if (s.type == "range") {
            let l = a;
            for (let c2 = 0; c2 < s.min; c2++) {
              let u = n();
              o(i(s.expr, l), u), l = u;
            }
            if (s.max == -1)
              o(i(s.expr, l), l);
            else
              for (let c2 = s.min; c2 < s.max; c2++) {
                let u = n();
                r(l, u), o(i(s.expr, l), u), l = u;
              }
            return [r(l)];
          } else {
            if (s.type == "name")
              return [r(a, void 0, s.value)];
            throw new Error("Unknown expr type");
          }
        }
      }
    }
    function bf(t2, e) {
      return e - t2;
    }
    function Bu(t2, e) {
      let n = [];
      return r(e), n.sort(bf);
      function r(o) {
        let i = t2[o];
        if (i.length == 1 && !i[0].term)
          return r(i[0].to);
        n.push(o);
        for (let s = 0; s < i.length; s++) {
          let { term: a, to: l } = i[s];
          !a && n.indexOf(l) == -1 && r(l);
        }
      }
    }
    function xb(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      return n(Bu(t2, 0));
      function n(r) {
        let o = [];
        r.forEach((s) => {
          t2[s].forEach(({ term: a, to: l }) => {
            if (!a)
              return;
            let c2;
            for (let u = 0; u < o.length; u++)
              o[u][0] == a && (c2 = o[u][1]);
            Bu(t2, l).forEach((u) => {
              c2 || o.push([a, c2 = []]), c2.indexOf(u) == -1 && c2.push(u);
            });
          });
        });
        let i = e[r.join(",")] = new io(r.indexOf(t2.length - 1) > -1);
        for (let s = 0; s < o.length; s++) {
          let a = o[s][1].sort(bf);
          i.next.push({ type: o[s][0], next: e[a.join(",")] || n(a) });
        }
        return i;
      }
    }
    function Tb(t2, e) {
      for (let n = 0, r = [t2]; n < r.length; n++) {
        let o = r[n], i = !o.validEnd, s = [];
        for (let a = 0; a < o.next.length; a++) {
          let { type: l, next: c2 } = o.next[a];
          s.push(l.name), i && !(l.isText || l.hasRequiredAttrs()) && (i = false), r.indexOf(c2) == -1 && r.push(c2);
        }
        i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function yf(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let n in t2) {
        let r = t2[n];
        if (!r.hasDefault)
          return null;
        e[n] = r.default;
      }
      return e;
    }
    function vf(t2, e) {
      let n = /* @__PURE__ */ Object.create(null);
      for (let r in t2) {
        let o = e && e[r];
        if (o === void 0) {
          let i = t2[r];
          if (i.hasDefault)
            o = i.default;
          else
            throw new RangeError("No value supplied for attribute " + r);
        }
        n[r] = o;
      }
      return n;
    }
    function Ef(t2, e, n, r) {
      for (let o in e)
        if (!(o in t2))
          throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
      for (let o in t2) {
        let i = t2[o];
        i.validate && i.validate(e[o]);
      }
    }
    function kf(t2, e) {
      let n = /* @__PURE__ */ Object.create(null);
      if (e)
        for (let r in e)
          n[r] = new Nb(t2, r, e[r]);
      return n;
    }
    let $u = class wf {
      /**
      @internal
      */
      constructor(e, n, r) {
        this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = kf(e, r.attrs), this.defaultAttrs = yf(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == io.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(e) {
        return this.groups.indexOf(e) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let e in this.attrs)
          if (this.attrs[e].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : vf(this.attrs, e);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(e = null, n, r) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Mr(this, this.computeAttrs(e), R.from(n), Xe.setFrom(r));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(e = null, n, r) {
        return n = R.from(n), this.checkContent(n), new Mr(this, this.computeAttrs(e), n, Xe.setFrom(r));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(e = null, n, r) {
        if (e = this.computeAttrs(e), n = R.from(n), n.size) {
          let s = this.contentMatch.fillBefore(n);
          if (!s)
            return null;
          n = s.append(n);
        }
        let o = this.contentMatch.matchFragment(n), i = o && o.fillBefore(R.empty, true);
        return i ? new Mr(this, e, n.append(i), Xe.setFrom(r)) : null;
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(e) {
        let n = this.contentMatch.matchFragment(e);
        if (!n || !n.validEnd)
          return false;
        for (let r = 0; r < e.childCount; r++)
          if (!this.allowsMarks(e.child(r).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(e) {
        if (!this.validContent(e))
          throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Ef(this.attrs, e, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(e) {
        if (this.markSet == null)
          return true;
        for (let n = 0; n < e.length; n++)
          if (!this.allowsMarkType(e[n].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(e) {
        if (this.markSet == null)
          return e;
        let n;
        for (let r = 0; r < e.length; r++)
          this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
        return n ? n.length ? n : Xe.none : e;
      }
      /**
      @internal
      */
      static compile(e, n) {
        let r = /* @__PURE__ */ Object.create(null);
        e.forEach((i, s) => r[i] = new wf(i, n, s));
        let o = n.spec.topNode || "doc";
        if (!r[o])
          throw new RangeError("Schema is missing its top node type ('" + o + "')");
        if (!r.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let i in r.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return r;
      }
    };
    function Ob(t2, e, n) {
      let r = n.split("|");
      return (o) => {
        let i = o === null ? "null" : typeof o;
        if (r.indexOf(i) < 0)
          throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t2}, got ${i}`);
      };
    }
    class Nb {
      constructor(e, n, r) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? Ob(e, n, r.validate) : r.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    }
    class Ta {
      /**
      @internal
      */
      constructor(e, n, r, o) {
        this.name = e, this.rank = n, this.schema = r, this.spec = o, this.attrs = kf(e, o.attrs), this.excluded = null;
        let i = yf(this.attrs);
        this.instance = i ? new Xe(this, i) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(e = null) {
        return !e && this.instance ? this.instance : new Xe(this, vf(this.attrs, e));
      }
      /**
      @internal
      */
      static compile(e, n) {
        let r = /* @__PURE__ */ Object.create(null), o = 0;
        return e.forEach((i, s) => r[i] = new Ta(i, o++, n, s)), r;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(e) {
        for (var n = 0; n < e.length; n++)
          e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
        return e;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(e) {
        for (let n = 0; n < e.length; n++)
          if (e[n].type == this)
            return e[n];
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Ef(this.attrs, e, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(e) {
        return this.excluded.indexOf(e) > -1;
      }
    }
    class _f {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(e) {
        this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
        let n = this.spec = {};
        for (let o in e)
          n[o] = e[o];
        n.nodes = It.from(e.nodes), n.marks = It.from(e.marks || {}), this.nodes = $u.compile(this.spec.nodes, this), this.marks = Ta.compile(this.spec.marks, this);
        let r = /* @__PURE__ */ Object.create(null);
        for (let o in this.nodes) {
          if (o in this.marks)
            throw new RangeError(o + " can not be both a node and a mark");
          let i = this.nodes[o], s = i.spec.content || "", a = i.spec.marks;
          if (i.contentMatch = r[s] || (r[s] = io.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!i.isInline || !i.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = i;
          }
          i.markSet = a == "_" ? null : a ? Fu(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null;
        }
        for (let o in this.marks) {
          let i = this.marks[o], s = i.spec.excludes;
          i.excluded = s == null ? [i] : s == "" ? [] : Fu(this, s.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(e, n = null, r, o) {
        if (typeof e == "string")
          e = this.nodeType(e);
        else if (e instanceof $u) {
          if (e.schema != this)
            throw new RangeError("Node type from different schema used (" + e.name + ")");
        } else throw new RangeError("Invalid node type: " + e);
        return e.createChecked(n, r, o);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(e, n) {
        let r = this.nodes.text;
        return new Ps(r, r.defaultAttrs, e, Xe.setFrom(n));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(e, n) {
        return typeof e == "string" && (e = this.marks[e]), e.create(n);
      }
      /**
      Deserialize a node from its JSON representation. This method is
      bound.
      */
      nodeFromJSON(e) {
        return Mr.fromJSON(this, e);
      }
      /**
      Deserialize a mark from its JSON representation. This method is
      bound.
      */
      markFromJSON(e) {
        return Xe.fromJSON(this, e);
      }
      /**
      @internal
      */
      nodeType(e) {
        let n = this.nodes[e];
        if (!n)
          throw new RangeError("Unknown node type: " + e);
        return n;
      }
    }
    function Fu(t2, e) {
      let n = [];
      for (let r = 0; r < e.length; r++) {
        let o = e[r], i = t2.marks[o], s = i;
        if (i)
          n.push(i);
        else
          for (let a in t2.marks) {
            let l = t2.marks[a];
            (o == "_" || l.spec.group && l.spec.group.split(" ").indexOf(o) > -1) && n.push(s = l);
          }
        if (!s)
          throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
      }
      return n;
    }
    function Ab(t2) {
      return t2.tag != null;
    }
    function Mb(t2) {
      return t2.style != null;
    }
    class Rr {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(e, n) {
        this.schema = e, this.rules = n, this.tags = [], this.styles = [];
        let r = this.matchedStyles = [];
        n.forEach((o) => {
          if (Ab(o))
            this.tags.push(o);
          else if (Mb(o)) {
            let i = /[^=]*/.exec(o.style)[0];
            r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
          }
        }), this.normalizeLists = !this.tags.some((o) => {
          if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
            return false;
          let i = e.nodes[o.node];
          return i.contentMatch.matchType(i);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(e, n = {}) {
        let r = new Hu(this, n, false);
        return r.addAll(e, Xe.none, n.from, n.to), r.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(e, n = {}) {
        let r = new Hu(this, n, true);
        return r.addAll(e, Xe.none, n.from, n.to), K.maxOpen(r.finish());
      }
      /**
      @internal
      */
      matchTag(e, n, r) {
        for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
          let i = this.tags[o];
          if (Db(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
            if (i.getAttrs) {
              let s = i.getAttrs(e);
              if (s === false)
                continue;
              i.attrs = s || void 0;
            }
            return i;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(e, n, r, o) {
        for (let i = o ? this.styles.indexOf(o) + 1 : 0; i < this.styles.length; i++) {
          let s = this.styles[i], a = s.style;
          if (!(a.indexOf(e) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
            if (s.getAttrs) {
              let l = s.getAttrs(n);
              if (l === false)
                continue;
              s.attrs = l || void 0;
            }
            return s;
          }
        }
      }
      /**
      @internal
      */
      static schemaRules(e) {
        let n = [];
        function r(o) {
          let i = o.priority == null ? 50 : o.priority, s = 0;
          for (; s < n.length; s++) {
            let a = n[s];
            if ((a.priority == null ? 50 : a.priority) < i)
              break;
          }
          n.splice(s, 0, o);
        }
        for (let o in e.marks) {
          let i = e.marks[o].spec.parseDOM;
          i && i.forEach((s) => {
            r(s = Uu(s)), s.mark || s.ignore || s.clearMark || (s.mark = o);
          });
        }
        for (let o in e.nodes) {
          let i = e.nodes[o].spec.parseDOM;
          i && i.forEach((s) => {
            r(s = Uu(s)), s.node || s.ignore || s.mark || (s.node = o);
          });
        }
        return n;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new Rr(e, Rr.schemaRules(e)));
      }
    }
    const Sf = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    }, Rb = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    }, Cf = { ol: true, ul: true }, bi = 1, zl = 2, ws = 4;
    function zu(t2, e, n) {
      return e != null ? (e ? bi : 0) | (e === "full" ? zl : 0) : t2 && t2.whitespace == "pre" ? bi | zl : n & -5;
    }
    class Zi {
      constructor(e, n, r, o, i, s) {
        this.type = e, this.attrs = n, this.marks = r, this.solid = o, this.options = s, this.content = [], this.activeMarks = Xe.none, this.match = i || (s & ws ? null : e.contentMatch);
      }
      findWrapping(e) {
        if (!this.match) {
          if (!this.type)
            return [];
          let n = this.type.contentMatch.fillBefore(R.from(e));
          if (n)
            this.match = this.type.contentMatch.matchFragment(n);
          else {
            let r = this.type.contentMatch, o;
            return (o = r.findWrapping(e.type)) ? (this.match = r, o) : null;
          }
        }
        return this.match.findWrapping(e.type);
      }
      finish(e) {
        if (!(this.options & bi)) {
          let r = this.content[this.content.length - 1], o;
          if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
            let i = r;
            r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - o[0].length));
          }
        }
        let n = R.from(this.content);
        return !e && this.match && (n = n.append(this.match.fillBefore(R.empty, true))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
      }
      inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Sf.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
      }
    }
    class Hu {
      constructor(e, n, r) {
        this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = false;
        let o = n.topNode, i, s = zu(null, n.preserveWhitespace, 0) | (r ? ws : 0);
        o ? i = new Zi(o.type, o.attrs, Xe.none, true, n.topMatch || o.type.contentMatch, s) : r ? i = new Zi(null, null, Xe.none, true, null, s) : i = new Zi(e.schema.topNodeType, null, Xe.none, true, null, s), this.nodes = [i], this.find = n.findPositions, this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(e, n) {
        e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
      }
      addTextNode(e, n) {
        let r = e.nodeValue, o = this.top, i = o.options & zl ? "full" : this.localPreserveWS || (o.options & bi) > 0;
        if (i === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
          if (i)
            i !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
          else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
            let s = o.content[o.content.length - 1], a = e.previousSibling;
            (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1));
          }
          r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
        } else
          this.findInside(e);
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(e, n, r) {
        let o = this.localPreserveWS, i = this.top;
        (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
        let s = e.nodeName.toLowerCase(), a;
        Cf.hasOwnProperty(s) && this.parser.normalizeLists && Ib(e);
        let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
        e: if (l ? l.ignore : Rb.hasOwnProperty(s))
          this.findInside(e), this.ignoreFallback(e, n);
        else if (!l || l.skip || l.closeParent) {
          l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
          let c2, u = this.needsBlock;
          if (Sf.hasOwnProperty(s))
            i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c2 = true, i.type || (this.needsBlock = true);
          else if (!e.firstChild) {
            this.leafFallback(e, n);
            break e;
          }
          let d = l && l.skip ? n : this.readStyles(e, n);
          d && this.addAll(e, d), c2 && this.sync(i), this.needsBlock = u;
        } else {
          let c2 = this.readStyles(e, n);
          c2 && this.addElementByRule(e, l, c2, l.consuming === false ? a : void 0);
        }
        this.localPreserveWS = o;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(e, n) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
      }
      // Called for ignored nodes
      ignoreFallback(e, n) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(e, n) {
        let r = e.style;
        if (r && r.length)
          for (let o = 0; o < this.parser.matchedStyles.length; o++) {
            let i = this.parser.matchedStyles[o], s = r.getPropertyValue(i);
            if (s)
              for (let a = void 0; ; ) {
                let l = this.parser.matchStyle(i, s, this, a);
                if (!l)
                  break;
                if (l.ignore)
                  return null;
                if (l.clearMark ? n = n.filter((c2) => !l.clearMark(c2)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === false)
                  a = l;
                else
                  break;
              }
          }
        return n;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(e, n, r, o) {
        let i, s;
        if (n.node)
          if (s = this.parser.schema.nodes[n.node], s.isLeaf)
            this.insertNode(s.create(n.attrs), r) || this.leafFallback(e, r);
          else {
            let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
            l && (i = true, r = l);
          }
        else {
          let l = this.parser.schema.marks[n.mark];
          r = r.concat(l.create(n.attrs));
        }
        let a = this.top;
        if (s && s.isLeaf)
          this.findInside(e);
        else if (o)
          this.addElement(e, r, o);
        else if (n.getContent)
          this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r));
        else {
          let l = e;
          typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, true), this.addAll(l, r), this.findAround(e, l, false);
        }
        i && this.sync(a) && this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(e, n, r, o) {
        let i = r || 0;
        for (let s = r ? e.childNodes[r] : e.firstChild, a = o == null ? null : e.childNodes[o]; s != a; s = s.nextSibling, ++i)
          this.findAtPoint(e, i), this.addDOM(s, n);
        this.findAtPoint(e, i);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(e, n) {
        let r, o;
        for (let i = this.open; i >= 0; i--) {
          let s = this.nodes[i], a = s.findWrapping(e);
          if (a && (!r || r.length > a.length) && (r = a, o = s, !a.length) || s.solid)
            break;
        }
        if (!r)
          return null;
        this.sync(o);
        for (let i = 0; i < r.length; i++)
          n = this.enterInner(r[i], null, n, false);
        return n;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(e, n) {
        if (e.isInline && this.needsBlock && !this.top.type) {
          let o = this.textblockFromContext();
          o && (n = this.enterInner(o, null, n));
        }
        let r = this.findPlace(e, n);
        if (r) {
          this.closeExtra();
          let o = this.top;
          o.match && (o.match = o.match.matchType(e.type));
          let i = Xe.none;
          for (let s of r.concat(e.marks))
            (o.type ? o.type.allowsMarkType(s.type) : Vu(s.type, e.type)) && (i = s.addToSet(i));
          return o.content.push(e.mark(i)), true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(e, n, r, o) {
        let i = this.findPlace(e.create(n), r);
        return i && (i = this.enterInner(e, n, r, true, o)), i;
      }
      // Open a node of the given type
      enterInner(e, n, r, o = false, i) {
        this.closeExtra();
        let s = this.top;
        s.match = s.match && s.match.matchType(e);
        let a = zu(e, i, s.options);
        s.options & ws && s.content.length == 0 && (a |= ws);
        let l = Xe.none;
        return r = r.filter((c2) => (s.type ? s.type.allowsMarkType(c2.type) : Vu(c2.type, e)) ? (l = c2.addToSet(l), false) : true), this.nodes.push(new Zi(e, n, l, o, null, a)), this.open++, r;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(e = false) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
          for (; n > this.open; n--)
            this.nodes[n - 1].content.push(this.nodes[n].finish(e));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(e) {
        for (let n = this.open; n >= 0; n--) {
          if (this.nodes[n] == e)
            return this.open = n, true;
          this.localPreserveWS && (this.nodes[n].options |= bi);
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let n = this.open; n >= 0; n--) {
          let r = this.nodes[n].content;
          for (let o = r.length - 1; o >= 0; o--)
            e += r[o].nodeSize;
          n && e++;
        }
        return e;
      }
      findAtPoint(e, n) {
        if (this.find)
          for (let r = 0; r < this.find.length; r++)
            this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
      }
      findInside(e) {
        if (this.find)
          for (let n = 0; n < this.find.length; n++)
            this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
      }
      findAround(e, n, r) {
        if (e != n && this.find)
          for (let o = 0; o < this.find.length; o++)
            this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos);
      }
      findInText(e) {
        if (this.find)
          for (let n = 0; n < this.find.length; n++)
            this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
      }
      // Determines whether the given context string matches this context.
      matchesContext(e) {
        if (e.indexOf("|") > -1)
          return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = e.split("/"), r = this.options.context, o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1), s = (a, l) => {
          for (; a >= 0; a--) {
            let c2 = n[a];
            if (c2 == "") {
              if (a == n.length - 1 || a == 0)
                continue;
              for (; l >= i; l--)
                if (s(a - 1, l))
                  return true;
              return false;
            } else {
              let u = l > 0 || l == 0 && o ? this.nodes[l].type : r && l >= i ? r.node(l - i).type : null;
              if (!u || u.name != c2 && !u.isInGroup(c2))
                return false;
              l--;
            }
          }
          return true;
        };
        return s(n.length - 1, this.open);
      }
      textblockFromContext() {
        let e = this.options.context;
        if (e)
          for (let n = e.depth; n >= 0; n--) {
            let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
            if (r && r.isTextblock && r.defaultAttrs)
              return r;
          }
        for (let n in this.parser.schema.nodes) {
          let r = this.parser.schema.nodes[n];
          if (r.isTextblock && r.defaultAttrs)
            return r;
        }
      }
    }
    function Ib(t2) {
      for (let e = t2.firstChild, n = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && Cf.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
      }
    }
    function Db(t2, e) {
      return (t2.matches || t2.msMatchesSelector || t2.webkitMatchesSelector || t2.mozMatchesSelector).call(t2, e);
    }
    function Uu(t2) {
      let e = {};
      for (let n in t2)
        e[n] = t2[n];
      return e;
    }
    function Vu(t2, e) {
      let n = e.schema.nodes;
      for (let r in n) {
        let o = n[r];
        if (!o.allowsMarkType(t2))
          continue;
        let i = [], s = (a) => {
          i.push(a);
          for (let l = 0; l < a.edgeCount; l++) {
            let { type: c2, next: u } = a.edge(l);
            if (c2 == e || i.indexOf(u) < 0 && s(u))
              return true;
          }
        };
        if (s(o.contentMatch))
          return true;
      }
    }
    class fo {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(e, n) {
        this.nodes = e, this.marks = n;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(e, n = {}, r) {
        r || (r = tl(n).createDocumentFragment());
        let o = r, i = [];
        return e.forEach((s) => {
          if (i.length || s.marks.length) {
            let a = 0, l = 0;
            for (; a < i.length && l < s.marks.length; ) {
              let c2 = s.marks[l];
              if (!this.marks[c2.type.name]) {
                l++;
                continue;
              }
              if (!c2.eq(i[a][0]) || c2.type.spec.spanning === false)
                break;
              a++, l++;
            }
            for (; a < i.length; )
              o = i.pop()[1];
            for (; l < s.marks.length; ) {
              let c2 = s.marks[l++], u = this.serializeMark(c2, s.isInline, n);
              u && (i.push([c2, o]), o.appendChild(u.dom), o = u.contentDOM || u.dom);
            }
          }
          o.appendChild(this.serializeNodeInner(s, n));
        }), r;
      }
      /**
      @internal
      */
      serializeNodeInner(e, n) {
        let { dom: r, contentDOM: o } = _s(tl(n), this.nodes[e.type.name](e), null, e.attrs);
        if (o) {
          if (e.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(e.content, n, o);
        }
        return r;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(e, n = {}) {
        let r = this.serializeNodeInner(e, n);
        for (let o = e.marks.length - 1; o >= 0; o--) {
          let i = this.serializeMark(e.marks[o], e.isInline, n);
          i && ((i.contentDOM || i.dom).appendChild(r), r = i.dom);
        }
        return r;
      }
      /**
      @internal
      */
      serializeMark(e, n, r = {}) {
        let o = this.marks[e.type.name];
        return o && _s(tl(r), o(e, n), null, e.attrs);
      }
      static renderSpec(e, n, r = null, o) {
        return _s(e, n, r, o);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new fo(this.nodesFromSchema(e), this.marksFromSchema(e)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(e) {
        let n = Wu(e.nodes);
        return n.text || (n.text = (r) => r.text), n;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(e) {
        return Wu(e.marks);
      }
    }
    function Wu(t2) {
      let e = {};
      for (let n in t2) {
        let r = t2[n].spec.toDOM;
        r && (e[n] = r);
      }
      return e;
    }
    function tl(t2) {
      return t2.document || window.document;
    }
    const Ku = /* @__PURE__ */ new WeakMap();
    function Lb(t2) {
      let e = Ku.get(t2);
      return e === void 0 && Ku.set(t2, e = Pb(t2)), e;
    }
    function Pb(t2) {
      let e = null;
      function n(r) {
        if (r && typeof r == "object")
          if (Array.isArray(r))
            if (typeof r[0] == "string")
              e || (e = []), e.push(r);
            else
              for (let o = 0; o < r.length; o++)
                n(r[o]);
          else
            for (let o in r)
              n(r[o]);
      }
      return n(t2), e;
    }
    function _s(t2, e, n, r) {
      if (typeof e == "string")
        return { dom: t2.createTextNode(e) };
      if (e.nodeType != null)
        return { dom: e };
      if (e.dom && e.dom.nodeType != null)
        return e;
      let o = e[0], i;
      if (typeof o != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (r && (i = Lb(r)) && i.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let s = o.indexOf(" ");
      s > 0 && (n = o.slice(0, s), o = o.slice(s + 1));
      let a, l = n ? t2.createElementNS(n, o) : t2.createElement(o), c2 = e[1], u = 1;
      if (c2 && typeof c2 == "object" && c2.nodeType == null && !Array.isArray(c2)) {
        u = 2;
        for (let d in c2)
          if (c2[d] != null) {
            let p2 = d.indexOf(" ");
            p2 > 0 ? l.setAttributeNS(d.slice(0, p2), d.slice(p2 + 1), c2[d]) : l.setAttribute(d, c2[d]);
          }
      }
      for (let d = u; d < e.length; d++) {
        let p2 = e[d];
        if (p2 === 0) {
          if (d < e.length - 1 || d > u)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom: l, contentDOM: l };
        } else {
          let { dom: f, contentDOM: h2 } = _s(t2, p2, n, r);
          if (l.appendChild(f), h2) {
            if (a)
              throw new RangeError("Multiple content holes");
            a = h2;
          }
        }
      }
      return { dom: l, contentDOM: a };
    }
    const xf = 65535, Tf = Math.pow(2, 16);
    function Bb(t2, e) {
      return t2 + e * Tf;
    }
    function qu(t2) {
      return t2 & xf;
    }
    function $b(t2) {
      return (t2 - (t2 & xf)) / Tf;
    }
    const Of = 1, Nf = 2, Ss = 4, Af = 8;
    class Hl {
      /**
      @internal
      */
      constructor(e, n, r) {
        this.pos = e, this.delInfo = n, this.recover = r;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & Af) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (Of | Ss)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (Nf | Ss)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & Ss) > 0;
      }
    }
    class cn {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(e, n = false) {
        if (this.ranges = e, this.inverted = n, !e.length && cn.empty)
          return cn.empty;
      }
      /**
      @internal
      */
      recover(e) {
        let n = 0, r = qu(e);
        if (!this.inverted)
          for (let o = 0; o < r; o++)
            n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
        return this.ranges[r * 3] + n + $b(e);
      }
      mapResult(e, n = 1) {
        return this._map(e, n, false);
      }
      map(e, n = 1) {
        return this._map(e, n, true);
      }
      /**
      @internal
      */
      _map(e, n, r) {
        let o = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? o : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = this.ranges[a + s], d = l + c2;
          if (e <= d) {
            let p2 = c2 ? e == l ? -1 : e == d ? 1 : n : n, f = l + o + (p2 < 0 ? 0 : u);
            if (r)
              return f;
            let h2 = e == (n < 0 ? l : d) ? null : Bb(a / 3, e - l), m = e == l ? Nf : e == d ? Of : Ss;
            return (n < 0 ? e != l : e != d) && (m |= Af), new Hl(f, m, h2);
          }
          o += u - c2;
        }
        return r ? e + o : new Hl(e + o, 0, null);
      }
      /**
      @internal
      */
      touches(e, n) {
        let r = 0, o = qu(n), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? r : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = l + c2;
          if (e <= u && a == o * 3)
            return true;
          r += this.ranges[a + s] - c2;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(e) {
        let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
          let s = this.ranges[o], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c2 = this.ranges[o + n], u = this.ranges[o + r];
          e(a, a + c2, l, l + u), i += u - c2;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new cn(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(e) {
        return e == 0 ? cn.empty : new cn(e < 0 ? [0, -e, 0] : [0, 0, e]);
      }
    }
    cn.empty = new cn([]);
    class yi {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(e, n, r = 0, o = e ? e.length : 0) {
        this.mirror = n, this.from = r, this.to = o, this._maps = e || [], this.ownData = !(e || n);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(e = 0, n = this.maps.length) {
        return new yi(this._maps, this.mirror, e, n);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(e, n) {
        this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(e) {
        for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
          let o = e.getMirror(n);
          this.appendMap(e._maps[n], o != null && o < n ? r + o : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(e) {
        if (this.mirror) {
          for (let n = 0; n < this.mirror.length; n++)
            if (this.mirror[n] == e)
              return this.mirror[n + (n % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(e, n) {
        this.mirror || (this.mirror = []), this.mirror.push(e, n);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(e) {
        for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
          let o = e.getMirror(n);
          this.appendMap(e._maps[n].invert(), o != null && o > n ? r - o - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let e = new yi();
        return e.appendMappingInverted(this), e;
      }
      /**
      Map a position through this mapping.
      */
      map(e, n = 1) {
        if (this.mirror)
          return this._map(e, n, true);
        for (let r = this.from; r < this.to; r++)
          e = this._maps[r].map(e, n);
        return e;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(e, n = 1) {
        return this._map(e, n, false);
      }
      /**
      @internal
      */
      _map(e, n, r) {
        let o = 0;
        for (let i = this.from; i < this.to; i++) {
          let s = this._maps[i], a = s.mapResult(e, n);
          if (a.recover != null) {
            let l = this.getMirror(i);
            if (l != null && l > i && l < this.to) {
              i = l, e = this._maps[l].recover(a.recover);
              continue;
            }
          }
          o |= a.delInfo, e = a.pos;
        }
        return r ? e : new Hl(e, o, null);
      }
    }
    const nl = /* @__PURE__ */ Object.create(null);
    class Ut {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return cn.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(e) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(e, n) {
        if (!n || !n.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let r = nl[n.stepType];
        if (!r)
          throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(e, n);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(e, n) {
        if (e in nl)
          throw new RangeError("Duplicate use of step JSON ID " + e);
        return nl[e] = n, n.prototype.jsonID = e, n;
      }
    }
    class yt {
      /**
      @internal
      */
      constructor(e, n) {
        this.doc = e, this.failed = n;
      }
      /**
      Create a successful step result.
      */
      static ok(e) {
        return new yt(e, null);
      }
      /**
      Create a failed step result.
      */
      static fail(e) {
        return new yt(null, e);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(e, n, r, o) {
        try {
          return yt.ok(e.replace(n, r, o));
        } catch (i) {
          if (i instanceof Is)
            return yt.fail(i.message);
          throw i;
        }
      }
    }
    function Sc(t2, e, n) {
      let r = [];
      for (let o = 0; o < t2.childCount; o++) {
        let i = t2.child(o);
        i.content.size && (i = i.copy(Sc(i.content, e, i))), i.isInline && (i = e(i, n, o)), r.push(i);
      }
      return R.fromArray(r);
    }
    class Tr extends Ut {
      /**
      Create a mark step.
      */
      constructor(e, n, r) {
        super(), this.from = e, this.to = n, this.mark = r;
      }
      apply(e) {
        let n = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), i = new K(Sc(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), n.openStart, n.openEnd);
        return yt.fromReplace(e, this.from, this.to, i);
      }
      invert() {
        return new qn(this.from, this.to, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new Tr(n.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof Tr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Tr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new Tr(n.from, n.to, e.markFromJSON(n.mark));
      }
    }
    Ut.jsonID("addMark", Tr);
    class qn extends Ut {
      /**
      Create a mark-removing step.
      */
      constructor(e, n, r) {
        super(), this.from = e, this.to = n, this.mark = r;
      }
      apply(e) {
        let n = e.slice(this.from, this.to), r = new K(Sc(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), n.openStart, n.openEnd);
        return yt.fromReplace(e, this.from, this.to, r);
      }
      invert() {
        return new Tr(this.from, this.to, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new qn(n.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof qn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new qn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new qn(n.from, n.to, e.markFromJSON(n.mark));
      }
    }
    Ut.jsonID("removeMark", qn);
    class Or extends Ut {
      /**
      Create a node mark step.
      */
      constructor(e, n) {
        super(), this.pos = e, this.mark = n;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return yt.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return yt.fromReplace(e, this.pos, this.pos + 1, new K(R.from(r), 0, n.isLeaf ? 0 : 1));
      }
      invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
          let r = this.mark.addToSet(n.marks);
          if (r.length == n.marks.length) {
            for (let o = 0; o < n.marks.length; o++)
              if (!n.marks[o].isInSet(r))
                return new Or(this.pos, n.marks[o]);
            return new Or(this.pos, this.mark);
          }
        }
        return new Mo(this.pos, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Or(n.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new Or(n.pos, e.markFromJSON(n.mark));
      }
    }
    Ut.jsonID("addNodeMark", Or);
    class Mo extends Ut {
      /**
      Create a mark-removing step.
      */
      constructor(e, n) {
        super(), this.pos = e, this.mark = n;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return yt.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return yt.fromReplace(e, this.pos, this.pos + 1, new K(R.from(r), 0, n.isLeaf ? 0 : 1));
      }
      invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new Or(this.pos, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Mo(n.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new Mo(n.pos, e.markFromJSON(n.mark));
      }
    }
    Ut.jsonID("removeNodeMark", Mo);
    class St extends Ut {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`—the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(e, n, r, o = false) {
        super(), this.from = e, this.to = n, this.slice = r, this.structure = o;
      }
      apply(e) {
        return this.structure && Ul(e, this.from, this.to) ? yt.fail("Structure replace would overwrite content") : yt.fromReplace(e, this.from, this.to, this.slice);
      }
      getMap() {
        return new cn([this.from, this.to - this.from, this.slice.size]);
      }
      invert(e) {
        return new St(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
      }
      map(e) {
        let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new St(n.pos, Math.max(n.pos, r.pos), this.slice);
      }
      merge(e) {
        if (!(e instanceof St) || e.structure || this.structure)
          return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
          let n = this.slice.size + e.slice.size == 0 ? K.empty : new K(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
          return new St(this.from, this.to + (e.to - e.from), n, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
          let n = this.slice.size + e.slice.size == 0 ? K.empty : new K(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
          return new St(e.from, this.to, n, this.structure);
        } else
          return null;
      }
      toJSON() {
        let e = { stepType: "replace", from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new St(n.from, n.to, K.fromJSON(e, n.slice), !!n.structure);
      }
    }
    Ut.jsonID("replace", St);
    class Ct extends Ut {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(e, n, r, o, i, s, a = false) {
        super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = o, this.slice = i, this.insert = s, this.structure = a;
      }
      apply(e) {
        if (this.structure && (Ul(e, this.from, this.gapFrom) || Ul(e, this.gapTo, this.to)))
          return yt.fail("Structure gap-replace would overwrite content");
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
          return yt.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? yt.fromReplace(e, this.from, this.to, r) : yt.fail("Content does not fit in gap");
      }
      getMap() {
        return new cn([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new Ct(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || o < n.pos || i > r.pos ? null : new Ct(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let e = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new Ct(n.from, n.to, n.gapFrom, n.gapTo, K.fromJSON(e, n.slice), n.insert, !!n.structure);
      }
    }
    Ut.jsonID("replaceAround", Ct);
    function Ul(t2, e, n) {
      let r = t2.resolve(e), o = n - e, i = r.depth;
      for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
        i--, o--;
      if (o > 0) {
        let s = r.node(i).maybeChild(r.indexAfter(i));
        for (; o > 0; ) {
          if (!s || s.isLeaf)
            return true;
          s = s.firstChild, o--;
        }
      }
      return false;
    }
    function Fb(t2, e, n, r) {
      let o = [], i = [], s, a;
      t2.doc.nodesBetween(e, n, (l, c2, u) => {
        if (!l.isInline)
          return;
        let d = l.marks;
        if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
          let p2 = Math.max(c2, e), f = Math.min(c2 + l.nodeSize, n), h2 = r.addToSet(d);
          for (let m = 0; m < d.length; m++)
            d[m].isInSet(h2) || (s && s.to == p2 && s.mark.eq(d[m]) ? s.to = f : o.push(s = new qn(p2, f, d[m])));
          a && a.to == p2 ? a.to = f : i.push(a = new Tr(p2, f, r));
        }
      }), o.forEach((l) => t2.step(l)), i.forEach((l) => t2.step(l));
    }
    function zb(t2, e, n, r) {
      let o = [], i = 0;
      t2.doc.nodesBetween(e, n, (s, a) => {
        if (!s.isInline)
          return;
        i++;
        let l = null;
        if (r instanceof Ta) {
          let c2 = s.marks, u;
          for (; u = r.isInSet(c2); )
            (l || (l = [])).push(u), c2 = u.removeFromSet(c2);
        } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
        if (l && l.length) {
          let c2 = Math.min(a + s.nodeSize, n);
          for (let u = 0; u < l.length; u++) {
            let d = l[u], p2;
            for (let f = 0; f < o.length; f++) {
              let h2 = o[f];
              h2.step == i - 1 && d.eq(o[f].style) && (p2 = h2);
            }
            p2 ? (p2.to = c2, p2.step = i) : o.push({ style: d, from: Math.max(a, e), to: c2, step: i });
          }
        }
      }), o.forEach((s) => t2.step(new qn(s.from, s.to, s.style)));
    }
    function Cc(t2, e, n, r = n.contentMatch, o = true) {
      let i = t2.doc.nodeAt(e), s = [], a = e + 1;
      for (let l = 0; l < i.childCount; l++) {
        let c2 = i.child(l), u = a + c2.nodeSize, d = r.matchType(c2.type);
        if (!d)
          s.push(new St(a, u, K.empty));
        else {
          r = d;
          for (let p2 = 0; p2 < c2.marks.length; p2++)
            n.allowsMarkType(c2.marks[p2].type) || t2.step(new qn(a, u, c2.marks[p2]));
          if (o && c2.isText && n.whitespace != "pre") {
            let p2, f = /\r?\n|\r/g, h2;
            for (; p2 = f.exec(c2.text); )
              h2 || (h2 = new K(R.from(n.schema.text(" ", n.allowedMarks(c2.marks))), 0, 0)), s.push(new St(a + p2.index, a + p2.index + p2[0].length, h2));
          }
        }
        a = u;
      }
      if (!r.validEnd) {
        let l = r.fillBefore(R.empty, true);
        t2.replace(a, a, new K(l, 0, 0));
      }
      for (let l = s.length - 1; l >= 0; l--)
        t2.step(s[l]);
    }
    function Hb(t2, e, n) {
      return (e == 0 || t2.canReplace(e, t2.childCount)) && (n == t2.childCount || t2.canReplace(0, n));
    }
    function Uo(t2) {
      let n = t2.parent.content.cutByIndex(t2.startIndex, t2.endIndex);
      for (let r = t2.depth; ; --r) {
        let o = t2.$from.node(r), i = t2.$from.index(r), s = t2.$to.indexAfter(r);
        if (r < t2.depth && o.canReplace(i, s, n))
          return r;
        if (r == 0 || o.type.spec.isolating || !Hb(o, i, s))
          break;
      }
      return null;
    }
    function Ub(t2, e, n) {
      let { $from: r, $to: o, depth: i } = e, s = r.before(i + 1), a = o.after(i + 1), l = s, c2 = a, u = R.empty, d = 0;
      for (let h2 = i, m = false; h2 > n; h2--)
        m || r.index(h2) > 0 ? (m = true, u = R.from(r.node(h2).copy(u)), d++) : l--;
      let p2 = R.empty, f = 0;
      for (let h2 = i, m = false; h2 > n; h2--)
        m || o.after(h2 + 1) < o.end(h2) ? (m = true, p2 = R.from(o.node(h2).copy(p2)), f++) : c2++;
      t2.step(new Ct(l, c2, s, a, new K(u.append(p2), d, f), u.size - d, true));
    }
    function xc(t2, e, n = null, r = t2) {
      let o = Vb(t2, e), i = o && Wb(r, e);
      return i ? o.map(Gu).concat({ type: e, attrs: n }).concat(i.map(Gu)) : null;
    }
    function Gu(t2) {
      return { type: t2, attrs: null };
    }
    function Vb(t2, e) {
      let { parent: n, startIndex: r, endIndex: o } = t2, i = n.contentMatchAt(r).findWrapping(e);
      if (!i)
        return null;
      let s = i.length ? i[0] : e;
      return n.canReplaceWith(r, o, s) ? i : null;
    }
    function Wb(t2, e) {
      let { parent: n, startIndex: r, endIndex: o } = t2, i = n.child(r), s = e.contentMatch.findWrapping(i.type);
      if (!s)
        return null;
      let l = (s.length ? s[s.length - 1] : e).contentMatch;
      for (let c2 = r; l && c2 < o; c2++)
        l = l.matchType(n.child(c2).type);
      return !l || !l.validEnd ? null : s;
    }
    function Kb(t2, e, n) {
      let r = R.empty;
      for (let s = n.length - 1; s >= 0; s--) {
        if (r.size) {
          let a = n[s].type.contentMatch.matchFragment(r);
          if (!a || !a.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        r = R.from(n[s].type.create(n[s].attrs, r));
      }
      let o = e.start, i = e.end;
      t2.step(new Ct(o, i, o, i, new K(r, 0, 0), n.length, true));
    }
    function qb(t2, e, n, r, o) {
      if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let i = t2.steps.length;
      t2.doc.nodesBetween(e, n, (s, a) => {
        let l = typeof o == "function" ? o(s) : o;
        if (s.isTextblock && !s.hasMarkup(r, l) && Gb(t2.doc, t2.mapping.slice(i).map(a), r)) {
          let c2 = null;
          if (r.schema.linebreakReplacement) {
            let f = r.whitespace == "pre", h2 = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
            f && !h2 ? c2 = false : !f && h2 && (c2 = true);
          }
          c2 === false && Rf(t2, s, a, i), Cc(t2, t2.mapping.slice(i).map(a, 1), r, void 0, c2 === null);
          let u = t2.mapping.slice(i), d = u.map(a, 1), p2 = u.map(a + s.nodeSize, 1);
          return t2.step(new Ct(d, p2, d + 1, p2 - 1, new K(R.from(r.create(l, null, s.marks)), 0, 0), 1, true)), c2 === true && Mf(t2, s, a, i), false;
        }
      });
    }
    function Mf(t2, e, n, r) {
      e.forEach((o, i) => {
        if (o.isText) {
          let s, a = /\r?\n|\r/g;
          for (; s = a.exec(o.text); ) {
            let l = t2.mapping.slice(r).map(n + 1 + i + s.index);
            t2.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function Rf(t2, e, n, r) {
      e.forEach((o, i) => {
        if (o.type == o.type.schema.linebreakReplacement) {
          let s = t2.mapping.slice(r).map(n + 1 + i);
          t2.replaceWith(s, s + 1, e.type.schema.text(`
`));
        }
      });
    }
    function Gb(t2, e, n) {
      let r = t2.resolve(e), o = r.index();
      return r.parent.canReplaceWith(o, o + 1, n);
    }
    function jb(t2, e, n, r, o) {
      let i = t2.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at given position");
      n || (n = i.type);
      let s = n.create(r, null, o || i.marks);
      if (i.isLeaf)
        return t2.replaceWith(e, e + i.nodeSize, s);
      if (!n.validContent(i.content))
        throw new RangeError("Invalid content for node type " + n.name);
      t2.step(new Ct(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new K(R.from(s), 0, 0), 1, true));
    }
    function ur(t2, e, n = 1, r) {
      let o = t2.resolve(e), i = o.depth - n, s = r && r[r.length - 1] || o.parent;
      if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
        return false;
      for (let c2 = o.depth - 1, u = n - 2; c2 > i; c2--, u--) {
        let d = o.node(c2), p2 = o.index(c2);
        if (d.type.spec.isolating)
          return false;
        let f = d.content.cutByIndex(p2, d.childCount), h2 = r && r[u + 1];
        h2 && (f = f.replaceChild(0, h2.type.create(h2.attrs)));
        let m = r && r[u] || d;
        if (!d.canReplace(p2 + 1, d.childCount) || !m.type.validContent(f))
          return false;
      }
      let a = o.indexAfter(i), l = r && r[0];
      return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
    }
    function Yb(t2, e, n = 1, r) {
      let o = t2.doc.resolve(e), i = R.empty, s = R.empty;
      for (let a = o.depth, l = o.depth - n, c2 = n - 1; a > l; a--, c2--) {
        i = R.from(o.node(a).copy(i));
        let u = r && r[c2];
        s = R.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s));
      }
      t2.step(new St(e, e, new K(i.append(s), n, n), true));
    }
    function Fr(t2, e) {
      let n = t2.resolve(e), r = n.index();
      return If(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
    }
    function Jb(t2, e) {
      e.content.size || t2.type.compatibleContent(e.type);
      let n = t2.contentMatchAt(t2.childCount), { linebreakReplacement: r } = t2.type.schema;
      for (let o = 0; o < e.childCount; o++) {
        let i = e.child(o), s = i.type == r ? t2.type.schema.nodes.text : i.type;
        if (n = n.matchType(s), !n || !t2.type.allowsMarks(i.marks))
          return false;
      }
      return n.validEnd;
    }
    function If(t2, e) {
      return !!(t2 && e && !t2.isLeaf && Jb(t2, e));
    }
    function Oa(t2, e, n = -1) {
      let r = t2.resolve(e);
      for (let o = r.depth; ; o--) {
        let i, s, a = r.index(o);
        if (o == r.depth ? (i = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (i = r.node(o + 1), a++, s = r.node(o).maybeChild(a)) : (i = r.node(o).maybeChild(a - 1), s = r.node(o + 1)), i && !i.isTextblock && If(i, s) && r.node(o).canReplace(a, a + 1))
          return e;
        if (o == 0)
          break;
        e = n < 0 ? r.before(o) : r.after(o);
      }
    }
    function Xb(t2, e, n) {
      let r = null, { linebreakReplacement: o } = t2.doc.type.schema, i = t2.doc.resolve(e - n), s = i.node().type;
      if (o && s.inlineContent) {
        let u = s.whitespace == "pre", d = !!s.contentMatch.matchType(o);
        u && !d ? r = false : !u && d && (r = true);
      }
      let a = t2.steps.length;
      if (r === false) {
        let u = t2.doc.resolve(e + n);
        Rf(t2, u.node(), u.before(), a);
      }
      s.inlineContent && Cc(t2, e + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
      let l = t2.mapping.slice(a), c2 = l.map(e - n);
      if (t2.step(new St(c2, l.map(e + n, -1), K.empty, true)), r === true) {
        let u = t2.doc.resolve(c2);
        Mf(t2, u.node(), u.before(), t2.steps.length);
      }
      return t2;
    }
    function Zb(t2, e, n) {
      let r = t2.resolve(e);
      if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return e;
      if (r.parentOffset == 0)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.index(o);
          if (r.node(o).canReplaceWith(i, i, n))
            return r.before(o + 1);
          if (i > 0)
            return null;
        }
      if (r.parentOffset == r.parent.content.size)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.indexAfter(o);
          if (r.node(o).canReplaceWith(i, i, n))
            return r.after(o + 1);
          if (i < r.node(o).childCount)
            return null;
        }
      return null;
    }
    function Df(t2, e, n) {
      let r = t2.resolve(e);
      if (!n.content.size)
        return e;
      let o = n.content;
      for (let i = 0; i < n.openStart; i++)
        o = o.firstChild.content;
      for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
        for (let s = r.depth; s >= 0; s--) {
          let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), c2 = r.node(s), u = false;
          if (i == 1)
            u = c2.canReplace(l, l, o);
          else {
            let d = c2.contentMatchAt(l).findWrapping(o.firstChild.type);
            u = d && c2.canReplaceWith(l, l, d[0]);
          }
          if (u)
            return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
        }
      return null;
    }
    function Na(t2, e, n = e, r = K.empty) {
      if (e == n && !r.size)
        return null;
      let o = t2.resolve(e), i = t2.resolve(n);
      return Lf(o, i, r) ? new St(e, n, r) : new Qb(o, i, r).fit();
    }
    function Lf(t2, e, n) {
      return !n.openStart && !n.openEnd && t2.start() == e.start() && t2.parent.canReplace(t2.index(), e.index(), n.content);
    }
    class Qb {
      constructor(e, n, r) {
        this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = R.empty;
        for (let o = 0; o <= e.depth; o++) {
          let i = e.node(o);
          this.frontier.push({
            type: i.type,
            match: i.contentMatchAt(e.indexAfter(o))
          });
        }
        for (let o = e.depth; o > 0; o--)
          this.placed = R.from(e.node(o).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        for (; this.unplaced.size; ) {
          let c2 = this.findFittable();
          c2 ? this.placeNodes(c2) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!o)
          return null;
        let i = this.placed, s = r.depth, a = o.depth;
        for (; s && a && i.childCount == 1; )
          i = i.firstChild.content, s--, a--;
        let l = new K(i, s, a);
        return e > -1 ? new Ct(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new St(r.pos, o.pos, l) : null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
          let i = n.firstChild;
          if (n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
            e = r;
            break;
          }
          n = i.content;
        }
        for (let n = 1; n <= 2; n++)
          for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
            let o, i = null;
            r ? (i = rl(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
            let s = o.firstChild;
            for (let a = this.depth; a >= 0; a--) {
              let { type: l, match: c2 } = this.frontier[a], u, d = null;
              if (n == 1 && (s ? c2.matchType(s.type) || (d = c2.fillBefore(R.from(s), false)) : i && l.compatibleContent(i.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, inject: d };
              if (n == 2 && s && (u = c2.findWrapping(s.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, wrap: u };
              if (i && c2.matchType(i.type))
                break;
            }
          }
      }
      openMore() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced, o = rl(e, n);
        return !o.childCount || o.firstChild.isLeaf ? false : (this.unplaced = new K(e, n + 1, Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)), true);
      }
      dropNode() {
        let { content: e, openStart: n, openEnd: r } = this.unplaced, o = rl(e, n);
        if (o.childCount <= 1 && n > 0) {
          let i = e.size - n <= n + o.size;
          this.unplaced = new K(Qo(e, n - 1, 1), n - 1, i ? n - 1 : r);
        } else
          this.unplaced = new K(Qo(e, n, 1), n, r);
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: o, wrap: i }) {
        for (; this.depth > n; )
          this.closeFrontierNode();
        if (i)
          for (let m = 0; m < i.length; m++)
            this.openFrontierNode(i[m]);
        let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - e, c2 = 0, u = [], { match: d, type: p2 } = this.frontier[n];
        if (o) {
          for (let m = 0; m < o.childCount; m++)
            u.push(o.child(m));
          d = d.matchFragment(o);
        }
        let f = a.size + e - (s.content.size - s.openEnd);
        for (; c2 < a.childCount; ) {
          let m = a.child(c2), g = d.matchType(m.type);
          if (!g)
            break;
          c2++, (c2 > 1 || l == 0 || m.content.size) && (d = g, u.push(Pf(m.mark(p2.allowedMarks(m.marks)), c2 == 1 ? l : 0, c2 == a.childCount ? f : -1)));
        }
        let h2 = c2 == a.childCount;
        h2 || (f = -1), this.placed = ei(this.placed, n, R.from(u)), this.frontier[n].match = d, h2 && f < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let m = 0, g = a; m < f; m++) {
          let b = g.lastChild;
          this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
        }
        this.unplaced = h2 ? e == 0 ? K.empty : new K(Qo(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1) : new K(Qo(s.content, e, c2), s.openStart, s.openEnd);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let e = this.frontier[this.depth], n;
        if (!e.type.isTextblock || !ol(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
          return -1;
        let { depth: r } = this.$to, o = this.$to.after(r);
        for (; r > 1 && o == this.$to.end(--r); )
          ++o;
        return o;
      }
      findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
          let { match: r, type: o } = this.frontier[n], i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = ol(e, n, o, r, i);
          if (s) {
            for (let a = n - 1; a >= 0; a--) {
              let { match: l, type: c2 } = this.frontier[a], u = ol(e, a, c2, l, true);
              if (!u || u.childCount)
                continue e;
            }
            return { depth: n, fit: s, move: i ? e.doc.resolve(e.after(n + 1)) : e };
          }
        }
      }
      close(e) {
        let n = this.findCloseLevel(e);
        if (!n)
          return null;
        for (; this.depth > n.depth; )
          this.closeFrontierNode();
        n.fit.childCount && (this.placed = ei(this.placed, n.depth, n.fit)), e = n.move;
        for (let r = n.depth + 1; r <= e.depth; r++) {
          let o = e.node(r), i = o.type.contentMatch.fillBefore(o.content, true, e.index(r));
          this.openFrontierNode(o.type, o.attrs, i);
        }
        return e;
      }
      openFrontierNode(e, n = null, r) {
        let o = this.frontier[this.depth];
        o.match = o.match.matchType(e), this.placed = ei(this.placed, this.depth, R.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
      }
      closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(R.empty, true);
        n.childCount && (this.placed = ei(this.placed, this.frontier.length, n));
      }
    }
    function Qo(t2, e, n) {
      return e == 0 ? t2.cutByIndex(n, t2.childCount) : t2.replaceChild(0, t2.firstChild.copy(Qo(t2.firstChild.content, e - 1, n)));
    }
    function ei(t2, e, n) {
      return e == 0 ? t2.append(n) : t2.replaceChild(t2.childCount - 1, t2.lastChild.copy(ei(t2.lastChild.content, e - 1, n)));
    }
    function rl(t2, e) {
      for (let n = 0; n < e; n++)
        t2 = t2.firstChild.content;
      return t2;
    }
    function Pf(t2, e, n) {
      if (e <= 0)
        return t2;
      let r = t2.content;
      return e > 1 && (r = r.replaceChild(0, Pf(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t2.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t2.type.contentMatch.matchFragment(r).fillBefore(R.empty, true)))), t2.copy(r);
    }
    function ol(t2, e, n, r, o) {
      let i = t2.node(e), s = o ? t2.indexAfter(e) : t2.index(e);
      if (s == i.childCount && !n.compatibleContent(i.type))
        return null;
      let a = r.fillBefore(i.content, true, s);
      return a && !ey(n, i.content, s) ? a : null;
    }
    function ey(t2, e, n) {
      for (let r = n; r < e.childCount; r++)
        if (!t2.allowsMarks(e.child(r).marks))
          return true;
      return false;
    }
    function ty(t2) {
      return t2.spec.defining || t2.spec.definingForContent;
    }
    function ny(t2, e, n, r) {
      if (!r.size)
        return t2.deleteRange(e, n);
      let o = t2.doc.resolve(e), i = t2.doc.resolve(n);
      if (Lf(o, i, r))
        return t2.step(new St(e, n, r));
      let s = $f(o, t2.doc.resolve(n));
      s[s.length - 1] == 0 && s.pop();
      let a = -(o.depth + 1);
      s.unshift(a);
      for (let p2 = o.depth, f = o.pos - 1; p2 > 0; p2--, f--) {
        let h2 = o.node(p2).type.spec;
        if (h2.defining || h2.definingAsContext || h2.isolating)
          break;
        s.indexOf(p2) > -1 ? a = p2 : o.before(p2) == f && s.splice(1, 0, -p2);
      }
      let l = s.indexOf(a), c2 = [], u = r.openStart;
      for (let p2 = r.content, f = 0; ; f++) {
        let h2 = p2.firstChild;
        if (c2.push(h2), f == r.openStart)
          break;
        p2 = h2.content;
      }
      for (let p2 = u - 1; p2 >= 0; p2--) {
        let f = c2[p2], h2 = ty(f.type);
        if (h2 && !f.sameMarkup(o.node(Math.abs(a) - 1)))
          u = p2;
        else if (h2 || !f.type.isTextblock)
          break;
      }
      for (let p2 = r.openStart; p2 >= 0; p2--) {
        let f = (p2 + u + 1) % (r.openStart + 1), h2 = c2[f];
        if (h2)
          for (let m = 0; m < s.length; m++) {
            let g = s[(m + l) % s.length], b = true;
            g < 0 && (b = false, g = -g);
            let E = o.node(g - 1), _ = o.index(g - 1);
            if (E.canReplaceWith(_, _, h2.type, h2.marks))
              return t2.replace(o.before(g), b ? i.after(g) : n, new K(Bf(r.content, 0, r.openStart, f), f, r.openEnd));
          }
      }
      let d = t2.steps.length;
      for (let p2 = s.length - 1; p2 >= 0 && (t2.replace(e, n, r), !(t2.steps.length > d)); p2--) {
        let f = s[p2];
        f < 0 || (e = o.before(f), n = i.after(f));
      }
    }
    function Bf(t2, e, n, r, o) {
      if (e < n) {
        let i = t2.firstChild;
        t2 = t2.replaceChild(0, i.copy(Bf(i.content, e + 1, n, r, i)));
      }
      if (e > r) {
        let i = o.contentMatchAt(0), s = i.fillBefore(t2).append(t2);
        t2 = s.append(i.matchFragment(s).fillBefore(R.empty, true));
      }
      return t2;
    }
    function ry(t2, e, n, r) {
      if (!r.isInline && e == n && t2.doc.resolve(e).parent.content.size) {
        let o = Zb(t2.doc, e, r.type);
        o != null && (e = n = o);
      }
      t2.replaceRange(e, n, new K(R.from(r), 0, 0));
    }
    function oy(t2, e, n) {
      let r = t2.doc.resolve(e), o = t2.doc.resolve(n), i = $f(r, o);
      for (let s = 0; s < i.length; s++) {
        let a = i[s], l = s == i.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
          return t2.delete(r.start(a), o.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1))))
          return t2.delete(r.before(a), o.after(a));
      }
      for (let s = 1; s <= r.depth && s <= o.depth; s++)
        if (e - r.start(s) == r.depth - s && n > r.end(s) && o.end(s) - n != o.depth - s && r.start(s - 1) == o.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1)))
          return t2.delete(r.before(s), n);
      t2.delete(e, n);
    }
    function $f(t2, e) {
      let n = [], r = Math.min(t2.depth, e.depth);
      for (let o = r; o >= 0; o--) {
        let i = t2.start(o);
        if (i < t2.pos - (t2.depth - o) || e.end(o) > e.pos + (e.depth - o) || t2.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
          break;
        (i == e.start(o) || o == t2.depth && o == e.depth && t2.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == i - 1) && n.push(o);
      }
      return n;
    }
    class No extends Ut {
      /**
      Construct an attribute step.
      */
      constructor(e, n, r) {
        super(), this.pos = e, this.attr = n, this.value = r;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return yt.fail("No node at attribute step's position");
        let r = /* @__PURE__ */ Object.create(null);
        for (let i in n.attrs)
          r[i] = n.attrs[i];
        r[this.attr] = this.value;
        let o = n.type.create(r, null, n.marks);
        return yt.fromReplace(e, this.pos, this.pos + 1, new K(R.from(o), 0, n.isLeaf ? 0 : 1));
      }
      getMap() {
        return cn.empty;
      }
      invert(e) {
        return new No(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new No(n.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(e, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new No(n.pos, n.attr, n.value);
      }
    }
    Ut.jsonID("attr", No);
    class vi extends Ut {
      /**
      Construct an attribute step.
      */
      constructor(e, n) {
        super(), this.attr = e, this.value = n;
      }
      apply(e) {
        let n = /* @__PURE__ */ Object.create(null);
        for (let o in e.attrs)
          n[o] = e.attrs[o];
        n[this.attr] = this.value;
        let r = e.type.create(n, e.content, e.marks);
        return yt.ok(r);
      }
      getMap() {
        return cn.empty;
      }
      invert(e) {
        return new vi(this.attr, e.attrs[this.attr]);
      }
      map(e) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(e, n) {
        if (typeof n.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new vi(n.attr, n.value);
      }
    }
    Ut.jsonID("docAttr", vi);
    let Ro = class extends Error {
    };
    Ro = function t(e) {
      let n = Error.call(this, e);
      return n.__proto__ = t.prototype, n;
    };
    Ro.prototype = Object.create(Error.prototype);
    Ro.prototype.constructor = Ro;
    Ro.prototype.name = "TransformError";
    class Tc {
      /**
      Create a transform that starts with the given document.
      */
      constructor(e) {
        this.doc = e, this.steps = [], this.docs = [], this.mapping = new yi();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(e) {
        let n = this.maybeStep(e);
        if (n.failed)
          throw new Ro(n.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc), n;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(e, n) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(e, n = e, r = K.empty) {
        let o = Na(this.doc, e, n, r);
        return o && this.step(o), this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(e, n, r) {
        return this.replace(e, n, new K(R.from(r), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(e, n) {
        return this.replace(e, n, K.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(e, n) {
        return this.replaceWith(e, e, n);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(e, n, r) {
        return ny(this, e, n, r), this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(e, n, r) {
        return ry(this, e, n, r), this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(e, n) {
        return oy(this, e, n), this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(e, n) {
        return Ub(this, e, n), this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(e, n = 1) {
        return Xb(this, e, n), this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(e, n) {
        return Kb(this, e, n), this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(e, n = e, r, o = null) {
        return qb(this, e, n, r, o), this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(e, n, r = null, o) {
        return jb(this, e, n, r, o), this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(e, n, r) {
        return this.step(new No(e, n, r)), this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(e, n) {
        return this.step(new vi(e, n)), this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(e, n) {
        return this.step(new Or(e, n)), this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(e, n) {
        if (!(n instanceof Xe)) {
          let r = this.doc.nodeAt(e);
          if (!r)
            throw new RangeError("No node at position " + e);
          if (n = n.isInSet(r.marks), !n)
            return this;
        }
        return this.step(new Mo(e, n)), this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(e, n = 1, r) {
        return Yb(this, e, n, r), this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(e, n, r) {
        return Fb(this, e, n, r), this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(e, n, r) {
        return zb(this, e, n, r), this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(e, n, r) {
        return Cc(this, e, n, r), this;
      }
    }
    const il = /* @__PURE__ */ Object.create(null);
    class ue {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor(e, n, r) {
        this.$anchor = e, this.$head = n, this.ranges = r || [new Ff(e.min(n), e.max(n))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let e = this.ranges;
        for (let n = 0; n < e.length; n++)
          if (e[n].$from.pos != e[n].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(e, n = K.empty) {
        let r = n.content.lastChild, o = null;
        for (let a = 0; a < n.openEnd; a++)
          o = r, r = r.lastChild;
        let i = e.steps.length, s = this.ranges;
        for (let a = 0; a < s.length; a++) {
          let { $from: l, $to: c2 } = s[a], u = e.mapping.slice(i);
          e.replaceRange(u.map(l.pos), u.map(c2.pos), a ? K.empty : n), a == 0 && Ju(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(e, n) {
        let r = e.steps.length, o = this.ranges;
        for (let i = 0; i < o.length; i++) {
          let { $from: s, $to: a } = o[i], l = e.mapping.slice(r), c2 = l.map(s.pos), u = l.map(a.pos);
          i ? e.deleteRange(c2, u) : (e.replaceRangeWith(c2, u, n), Ju(e, r, n.isInline ? -1 : 1));
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom(e, n, r = false) {
        let o = e.parent.inlineContent ? new ie(e) : Eo(e.node(0), e.parent, e.pos, e.index(), n, r);
        if (o)
          return o;
        for (let i = e.depth - 1; i >= 0; i--) {
          let s = n < 0 ? Eo(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r) : Eo(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
          if (s)
            return s;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near(e, n = 1) {
        return this.findFrom(e, n) || this.findFrom(e, -n) || new pn(e.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(e) {
        return Eo(e, e, 0, 0, 1) || new pn(e);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(e) {
        return Eo(e, e, e.content.size, e.childCount, -1) || new pn(e);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(e, n) {
        if (!n || !n.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let r = il[n.type];
        if (!r)
          throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(e, n);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(e, n) {
        if (e in il)
          throw new RangeError("Duplicate use of selection JSON ID " + e);
        return il[e] = n, n.prototype.jsonID = e, n;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return ie.between(this.$anchor, this.$head).getBookmark();
      }
    }
    ue.prototype.visible = true;
    class Ff {
      /**
      Create a range.
      */
      constructor(e, n) {
        this.$from = e, this.$to = n;
      }
    }
    let ju = false;
    function Yu(t2) {
      !ju && !t2.parent.inlineContent && (ju = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t2.parent.type.name + ")"));
    }
    class ie extends ue {
      /**
      Construct a text selection between the given points.
      */
      constructor(e, n = e) {
        Yu(e), Yu(n), super(e, n);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(e, n) {
        let r = e.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
          return ue.near(r);
        let o = e.resolve(n.map(this.anchor));
        return new ie(o.parent.inlineContent ? o : r, r);
      }
      replace(e, n = K.empty) {
        if (super.replace(e, n), n == K.empty) {
          let r = this.$from.marksAcross(this.$to);
          r && e.ensureMarks(r);
        }
      }
      eq(e) {
        return e instanceof ie && e.anchor == this.anchor && e.head == this.head;
      }
      getBookmark() {
        return new Aa(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new ie(e.resolve(n.anchor), e.resolve(n.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(e, n, r = n) {
        let o = e.resolve(n);
        return new this(o, r == n ? o : e.resolve(r));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between(e, n, r) {
        let o = e.pos - n.pos;
        if ((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent) {
          let i = ue.findFrom(n, r, true) || ue.findFrom(n, -r, true);
          if (i)
            n = i.$head;
          else
            return ue.near(n, r);
        }
        return e.parent.inlineContent || (o == 0 ? e = n : (e = (ue.findFrom(e, -r, true) || ue.findFrom(e, r, true)).$anchor, e.pos < n.pos != o < 0 && (e = n))), new ie(e, n);
      }
    }
    ue.jsonID("text", ie);
    class Aa {
      constructor(e, n) {
        this.anchor = e, this.head = n;
      }
      map(e) {
        return new Aa(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        return ie.between(e.resolve(this.anchor), e.resolve(this.head));
      }
    }
    class re extends ue {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor(e) {
        let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
        super(e, r), this.node = n;
      }
      map(e, n) {
        let { deleted: r, pos: o } = n.mapResult(this.anchor), i = e.resolve(o);
        return r ? ue.near(i) : new re(i);
      }
      content() {
        return new K(R.from(this.node), 0, 0);
      }
      eq(e) {
        return e instanceof re && e.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new Oc(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new re(e.resolve(n.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(e, n) {
        return new re(e.resolve(n));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== false;
      }
    }
    re.prototype.visible = false;
    ue.jsonID("node", re);
    class Oc {
      constructor(e) {
        this.anchor = e;
      }
      map(e) {
        let { deleted: n, pos: r } = e.mapResult(this.anchor);
        return n ? new Aa(r, r) : new Oc(r);
      }
      resolve(e) {
        let n = e.resolve(this.anchor), r = n.nodeAfter;
        return r && re.isSelectable(r) ? new re(n) : ue.near(n);
      }
    }
    class pn extends ue {
      /**
      Create an all-selection over the given document.
      */
      constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size));
      }
      replace(e, n = K.empty) {
        if (n == K.empty) {
          e.delete(0, e.doc.content.size);
          let r = ue.atStart(e.doc);
          r.eq(e.selection) || e.setSelection(r);
        } else
          super.replace(e, n);
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(e) {
        return new pn(e);
      }
      map(e) {
        return new pn(e);
      }
      eq(e) {
        return e instanceof pn;
      }
      getBookmark() {
        return iy;
      }
    }
    ue.jsonID("all", pn);
    const iy = {
      map() {
        return this;
      },
      resolve(t2) {
        return new pn(t2);
      }
    };
    function Eo(t2, e, n, r, o, i = false) {
      if (e.inlineContent)
        return ie.create(t2, n);
      for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < e.childCount : s >= 0; s += o) {
        let a = e.child(s);
        if (a.isAtom) {
          if (!i && re.isSelectable(a))
            return re.create(t2, n - (o < 0 ? a.nodeSize : 0));
        } else {
          let l = Eo(t2, a, n + o, o < 0 ? a.childCount : 0, o, i);
          if (l)
            return l;
        }
        n += a.nodeSize * o;
      }
      return null;
    }
    function Ju(t2, e, n) {
      let r = t2.steps.length - 1;
      if (r < e)
        return;
      let o = t2.steps[r];
      if (!(o instanceof St || o instanceof Ct))
        return;
      let i = t2.mapping.maps[r], s;
      i.forEach((a, l, c2, u) => {
        s == null && (s = u);
      }), t2.setSelection(ue.near(t2.doc.resolve(s), n));
    }
    const Xu = 1, Zu = 2, Qu = 4;
    class sy extends Tc {
      /**
      @internal
      */
      constructor(e) {
        super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(e) {
        if (e.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Xu) & -3, this.storedMarks = null, this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & Xu) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(e) {
        return this.storedMarks = e, this.updated |= Zu, this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(e) {
        return Xe.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & Zu) > 0;
      }
      /**
      @internal
      */
      addStep(e, n) {
        super.addStep(e, n), this.updated = this.updated & -3, this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(e) {
        return this.time = e, this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(e) {
        return this.selection.replace(this, e), this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(e, n = true) {
        let r = this.selection;
        return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Xe.none))), r.replaceWith(this, e), this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        return this.selection.replace(this), this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(e, n, r) {
        let o = this.doc.type.schema;
        if (n == null)
          return e ? this.replaceSelectionWith(o.text(e), true) : this.deleteSelection();
        {
          if (r == null && (r = n), r = r ?? n, !e)
            return this.deleteRange(n, r);
          let i = this.storedMarks;
          if (!i) {
            let s = this.doc.resolve(n);
            i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
          }
          return this.replaceRangeWith(n, r, o.text(e, i)), this.selection.empty || this.setSelection(ue.near(this.selection.$to)), this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(e, n) {
        return this.meta[typeof e == "string" ? e : e.key] = n, this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let e in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        return this.updated |= Qu, this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & Qu) > 0;
      }
    }
    function ed(t2, e) {
      return !e || !t2 ? t2 : t2.bind(e);
    }
    class ti {
      constructor(e, n, r) {
        this.name = e, this.init = ed(n.init, r), this.apply = ed(n.apply, r);
      }
    }
    const ay = [
      new ti("doc", {
        init(t2) {
          return t2.doc || t2.schema.topNodeType.createAndFill();
        },
        apply(t2) {
          return t2.doc;
        }
      }),
      new ti("selection", {
        init(t2, e) {
          return t2.selection || ue.atStart(e.doc);
        },
        apply(t2) {
          return t2.selection;
        }
      }),
      new ti("storedMarks", {
        init(t2) {
          return t2.storedMarks || null;
        },
        apply(t2, e, n, r) {
          return r.selection.$cursor ? t2.storedMarks : null;
        }
      }),
      new ti("scrollToSelection", {
        init() {
          return 0;
        },
        apply(t2, e) {
          return t2.scrolledIntoView ? e + 1 : e;
        }
      })
    ];
    class sl {
      constructor(e, n) {
        this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = ay.slice(), n && n.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
          this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new ti(r.key, r.spec.state, r));
        });
      }
    }
    class xo {
      /**
      @internal
      */
      constructor(e) {
        this.config = e;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(e) {
        return this.applyTransaction(e).state;
      }
      /**
      @internal
      */
      filterTransaction(e, n = -1) {
        for (let r = 0; r < this.config.plugins.length; r++)
          if (r != n) {
            let o = this.config.plugins[r];
            if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(e) {
        if (!this.filterTransaction(e))
          return { state: this, transactions: [] };
        let n = [e], r = this.applyInner(e), o = null;
        for (; ; ) {
          let i = false;
          for (let s = 0; s < this.config.plugins.length; s++) {
            let a = this.config.plugins[s];
            if (a.spec.appendTransaction) {
              let l = o ? o[s].n : 0, c2 = o ? o[s].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c2, r);
              if (u && r.filterTransaction(u, s)) {
                if (u.setMeta("appendedTransaction", e), !o) {
                  o = [];
                  for (let d = 0; d < this.config.plugins.length; d++)
                    o.push(d < s ? { state: r, n: n.length } : { state: this, n: 0 });
                }
                n.push(u), r = r.applyInner(u), i = true;
              }
              o && (o[s] = { state: r, n: n.length });
            }
          }
          if (!i)
            return { state: r, transactions: n };
        }
      }
      /**
      @internal
      */
      applyInner(e) {
        if (!e.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let n = new xo(this.config), r = this.config.fields;
        for (let o = 0; o < r.length; o++) {
          let i = r[o];
          n[i.name] = i.apply(e, this[i.name], this, n);
        }
        return n;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new sy(this);
      }
      /**
      Create a new state.
      */
      static create(e) {
        let n = new sl(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new xo(n);
        for (let o = 0; o < n.fields.length; o++)
          r[n.fields[o].name] = n.fields[o].init(e, r);
        return r;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(e) {
        let n = new sl(this.schema, e.plugins), r = n.fields, o = new xo(n);
        for (let i = 0; i < r.length; i++) {
          let s = r[i].name;
          o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
        }
        return o;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(e) {
        let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
          for (let r in e) {
            if (r == "doc" || r == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let o = e[r], i = o.spec.state;
            i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
          }
        return n;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(e, n, r) {
        if (!n)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
          throw new RangeError("Required config field 'schema' missing");
        let o = new sl(e.schema, e.plugins), i = new xo(o);
        return o.fields.forEach((s) => {
          if (s.name == "doc")
            i.doc = Mr.fromJSON(e.schema, n.doc);
          else if (s.name == "selection")
            i.selection = ue.fromJSON(i.doc, n.selection);
          else if (s.name == "storedMarks")
            n.storedMarks && (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
          else {
            if (r)
              for (let a in r) {
                let l = r[a], c2 = l.spec.state;
                if (l.key == s.name && c2 && c2.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
                  i[s.name] = c2.fromJSON.call(l, e, n[a], i);
                  return;
                }
              }
            i[s.name] = s.init(e, i);
          }
        }), i;
      }
    }
    function zf(t2, e, n) {
      for (let r in t2) {
        let o = t2[r];
        o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = zf(o, e, {})), n[r] = o;
      }
      return n;
    }
    class Ue {
      /**
      Create a plugin.
      */
      constructor(e) {
        this.spec = e, this.props = {}, e.props && zf(e.props, this, this.props), this.key = e.key ? e.key.key : Hf("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const al = /* @__PURE__ */ Object.create(null);
    function Hf(t2) {
      return t2 in al ? t2 + "$" + ++al[t2] : (al[t2] = 0, t2 + "$");
    }
    class Je {
      /**
      Create a plugin key.
      */
      constructor(e = "key") {
        this.key = Hf(e);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(e) {
        return e.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const Dt = function(t2) {
      for (var e = 0; ; e++)
        if (t2 = t2.previousSibling, !t2)
          return e;
    }, Ei = function(t2) {
      let e = t2.assignedSlot || t2.parentNode;
      return e && e.nodeType == 11 ? e.host : e;
    };
    let Vl = null;
    const sr = function(t2, e, n) {
      let r = Vl || (Vl = document.createRange());
      return r.setEnd(t2, n ?? t2.nodeValue.length), r.setStart(t2, e || 0), r;
    }, ly = function() {
      Vl = null;
    }, so = function(t2, e, n, r) {
      return n && (td(t2, e, n, r, -1) || td(t2, e, n, r, 1));
    }, cy = /^(img|br|input|textarea|hr)$/i;
    function td(t2, e, n, r, o) {
      for (; ; ) {
        if (t2 == n && e == r)
          return true;
        if (e == (o < 0 ? 0 : vn(t2))) {
          let i = t2.parentNode;
          if (!i || i.nodeType != 1 || Bi(t2) || cy.test(t2.nodeName) || t2.contentEditable == "false")
            return false;
          e = Dt(t2) + (o < 0 ? 0 : 1), t2 = i;
        } else if (t2.nodeType == 1) {
          if (t2 = t2.childNodes[e + (o < 0 ? -1 : 0)], t2.contentEditable == "false")
            return false;
          e = o < 0 ? vn(t2) : 0;
        } else
          return false;
      }
    }
    function vn(t2) {
      return t2.nodeType == 3 ? t2.nodeValue.length : t2.childNodes.length;
    }
    function uy(t2, e) {
      for (; ; ) {
        if (t2.nodeType == 3 && e)
          return t2;
        if (t2.nodeType == 1 && e > 0) {
          if (t2.contentEditable == "false")
            return null;
          t2 = t2.childNodes[e - 1], e = vn(t2);
        } else if (t2.parentNode && !Bi(t2))
          e = Dt(t2), t2 = t2.parentNode;
        else
          return null;
      }
    }
    function dy(t2, e) {
      for (; ; ) {
        if (t2.nodeType == 3 && e < t2.nodeValue.length)
          return t2;
        if (t2.nodeType == 1 && e < t2.childNodes.length) {
          if (t2.contentEditable == "false")
            return null;
          t2 = t2.childNodes[e], e = 0;
        } else if (t2.parentNode && !Bi(t2))
          e = Dt(t2) + 1, t2 = t2.parentNode;
        else
          return null;
      }
    }
    function py(t2, e, n) {
      for (let r = e == 0, o = e == vn(t2); r || o; ) {
        if (t2 == n)
          return true;
        let i = Dt(t2);
        if (t2 = t2.parentNode, !t2)
          return false;
        r = r && i == 0, o = o && i == vn(t2);
      }
    }
    function Bi(t2) {
      let e;
      for (let n = t2; n && !(e = n.pmViewDesc); n = n.parentNode)
        ;
      return e && e.node && e.node.isBlock && (e.dom == t2 || e.contentDOM == t2);
    }
    const Ma = function(t2) {
      return t2.focusNode && so(t2.focusNode, t2.focusOffset, t2.anchorNode, t2.anchorOffset);
    };
    function qr(t2, e) {
      let n = document.createEvent("Event");
      return n.initEvent("keydown", true, true), n.keyCode = t2, n.key = n.code = e, n;
    }
    function fy(t2) {
      let e = t2.activeElement;
      for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
      return e;
    }
    function hy(t2, e, n) {
      if (t2.caretPositionFromPoint)
        try {
          let r = t2.caretPositionFromPoint(e, n);
          if (r)
            return { node: r.offsetNode, offset: Math.min(vn(r.offsetNode), r.offset) };
        } catch {
        }
      if (t2.caretRangeFromPoint) {
        let r = t2.caretRangeFromPoint(e, n);
        if (r)
          return { node: r.startContainer, offset: Math.min(vn(r.startContainer), r.startOffset) };
      }
    }
    const Yn = typeof navigator < "u" ? navigator : null, nd = typeof document < "u" ? document : null, zr = Yn && Yn.userAgent || "", Wl = /Edge\/(\d+)/.exec(zr), Uf = /MSIE \d/.exec(zr), Kl = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(zr), en = !!(Uf || Kl || Wl), Ir = Uf ? document.documentMode : Kl ? +Kl[1] : Wl ? +Wl[1] : 0, In = !en && /gecko\/(\d+)/i.test(zr);
    In && +(/Firefox\/(\d+)/.exec(zr) || [0, 0])[1];
    const ql = !en && /Chrome\/(\d+)/.exec(zr), zt = !!ql, Vf = ql ? +ql[1] : 0, jt = !en && !!Yn && /Apple Computer/.test(Yn.vendor), Io = jt && (/Mobile\/\w+/.test(zr) || !!Yn && Yn.maxTouchPoints > 2), yn = Io || (Yn ? /Mac/.test(Yn.platform) : false), my = Yn ? /Win/.test(Yn.platform) : false, lr = /Android \d/.test(zr), $i = !!nd && "webkitFontSmoothing" in nd.documentElement.style, gy = $i ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function by(t2) {
      let e = t2.defaultView && t2.defaultView.visualViewport;
      return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
      } : {
        left: 0,
        right: t2.documentElement.clientWidth,
        top: 0,
        bottom: t2.documentElement.clientHeight
      };
    }
    function tr(t2, e) {
      return typeof t2 == "number" ? t2 : t2[e];
    }
    function yy(t2) {
      let e = t2.getBoundingClientRect(), n = e.width / t2.offsetWidth || 1, r = e.height / t2.offsetHeight || 1;
      return {
        left: e.left,
        right: e.left + t2.clientWidth * n,
        top: e.top,
        bottom: e.top + t2.clientHeight * r
      };
    }
    function rd(t2, e, n) {
      let r = t2.someProp("scrollThreshold") || 0, o = t2.someProp("scrollMargin") || 5, i = t2.dom.ownerDocument;
      for (let s = n || t2.dom; s; s = Ei(s)) {
        if (s.nodeType != 1)
          continue;
        let a = s, l = a == i.body, c2 = l ? by(i) : yy(a), u = 0, d = 0;
        if (e.top < c2.top + tr(r, "top") ? d = -(c2.top - e.top + tr(o, "top")) : e.bottom > c2.bottom - tr(r, "bottom") && (d = e.bottom - e.top > c2.bottom - c2.top ? e.top + tr(o, "top") - c2.top : e.bottom - c2.bottom + tr(o, "bottom")), e.left < c2.left + tr(r, "left") ? u = -(c2.left - e.left + tr(o, "left")) : e.right > c2.right - tr(r, "right") && (u = e.right - c2.right + tr(o, "right")), u || d)
          if (l)
            i.defaultView.scrollBy(u, d);
          else {
            let p2 = a.scrollLeft, f = a.scrollTop;
            d && (a.scrollTop += d), u && (a.scrollLeft += u);
            let h2 = a.scrollLeft - p2, m = a.scrollTop - f;
            e = { left: e.left - h2, top: e.top - m, right: e.right - h2, bottom: e.bottom - m };
          }
        if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
          break;
      }
    }
    function vy(t2) {
      let e = t2.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, o;
      for (let i = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
        let a = t2.root.elementFromPoint(i, s);
        if (!a || a == t2.dom || !t2.dom.contains(a))
          continue;
        let l = a.getBoundingClientRect();
        if (l.top >= n - 20) {
          r = a, o = l.top;
          break;
        }
      }
      return { refDOM: r, refTop: o, stack: Wf(t2.dom) };
    }
    function Wf(t2) {
      let e = [], n = t2.ownerDocument;
      for (let r = t2; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t2 != n); r = Ei(r))
        ;
      return e;
    }
    function Ey({ refDOM: t2, refTop: e, stack: n }) {
      let r = t2 ? t2.getBoundingClientRect().top : 0;
      Kf(n, r == 0 ? 0 : r - e);
    }
    function Kf(t2, e) {
      for (let n = 0; n < t2.length; n++) {
        let { dom: r, top: o, left: i } = t2[n];
        r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != i && (r.scrollLeft = i);
      }
    }
    let go = null;
    function ky(t2) {
      if (t2.setActive)
        return t2.setActive();
      if (go)
        return t2.focus(go);
      let e = Wf(t2);
      t2.focus(go == null ? {
        get preventScroll() {
          return go = { preventScroll: true }, true;
        }
      } : void 0), go || (go = false, Kf(e, 0));
    }
    function qf(t2, e) {
      let n, r = 2e8, o, i = 0, s = e.top, a = e.top, l, c2;
      for (let u = t2.firstChild, d = 0; u; u = u.nextSibling, d++) {
        let p2;
        if (u.nodeType == 1)
          p2 = u.getClientRects();
        else if (u.nodeType == 3)
          p2 = sr(u).getClientRects();
        else
          continue;
        for (let f = 0; f < p2.length; f++) {
          let h2 = p2[f];
          if (h2.top <= s && h2.bottom >= a) {
            s = Math.max(h2.bottom, s), a = Math.min(h2.top, a);
            let m = h2.left > e.left ? h2.left - e.left : h2.right < e.left ? e.left - h2.right : 0;
            if (m < r) {
              n = u, r = m, o = m && n.nodeType == 3 ? {
                left: h2.right < e.left ? h2.right : h2.left,
                top: e.top
              } : e, u.nodeType == 1 && m && (i = d + (e.left >= (h2.left + h2.right) / 2 ? 1 : 0));
              continue;
            }
          } else h2.top > e.top && !l && h2.left <= e.left && h2.right >= e.left && (l = u, c2 = { left: Math.max(h2.left, Math.min(h2.right, e.left)), top: h2.top });
          !n && (e.left >= h2.right && e.top >= h2.top || e.left >= h2.left && e.top >= h2.bottom) && (i = d + 1);
        }
      }
      return !n && l && (n = l, o = c2, r = 0), n && n.nodeType == 3 ? wy(n, o) : !n || r && n.nodeType == 1 ? { node: t2, offset: i } : qf(n, o);
    }
    function wy(t2, e) {
      let n = t2.nodeValue.length, r = document.createRange();
      for (let o = 0; o < n; o++) {
        r.setEnd(t2, o + 1), r.setStart(t2, o);
        let i = Er(r, 1);
        if (i.top != i.bottom && Nc(e, i))
          return { node: t2, offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
      }
      return { node: t2, offset: 0 };
    }
    function Nc(t2, e) {
      return t2.left >= e.left - 1 && t2.left <= e.right + 1 && t2.top >= e.top - 1 && t2.top <= e.bottom + 1;
    }
    function _y(t2, e) {
      let n = t2.parentNode;
      return n && /^li$/i.test(n.nodeName) && e.left < t2.getBoundingClientRect().left ? n : t2;
    }
    function Sy(t2, e, n) {
      let { node: r, offset: o } = qf(e, n), i = -1;
      if (r.nodeType == 1 && !r.firstChild) {
        let s = r.getBoundingClientRect();
        i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
      }
      return t2.docView.posFromDOM(r, o, i);
    }
    function Cy(t2, e, n, r) {
      let o = -1;
      for (let i = e, s = false; i != t2.dom; ) {
        let a = t2.docView.nearestDesc(i, true), l;
        if (!a)
          return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
        ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > r.left || l.top > r.top ? o = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (o = a.posAfter), s = true), !a.contentDOM && o < 0 && !a.node.isText))
          return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
        i = a.dom.parentNode;
      }
      return o > -1 ? o : t2.docView.posFromDOM(e, n, -1);
    }
    function Gf(t2, e, n) {
      let r = t2.childNodes.length;
      if (r && n.top < n.bottom)
        for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ; ) {
          let s = t2.childNodes[i];
          if (s.nodeType == 1) {
            let a = s.getClientRects();
            for (let l = 0; l < a.length; l++) {
              let c2 = a[l];
              if (Nc(e, c2))
                return Gf(s, e, c2);
            }
          }
          if ((i = (i + 1) % r) == o)
            break;
        }
      return t2;
    }
    function xy(t2, e) {
      let n = t2.dom.ownerDocument, r, o = 0, i = hy(n, e.left, e.top);
      i && ({ node: r, offset: o } = i);
      let s = (t2.root.elementFromPoint ? t2.root : n).elementFromPoint(e.left, e.top), a;
      if (!s || !t2.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
        let c2 = t2.dom.getBoundingClientRect();
        if (!Nc(e, c2) || (s = Gf(t2.dom, e, c2), !s))
          return null;
      }
      if (jt)
        for (let c2 = s; r && c2; c2 = Ei(c2))
          c2.draggable && (r = void 0);
      if (s = _y(s, e), r) {
        if (In && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
          let u = r.childNodes[o], d;
          u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && o++;
        }
        let c2;
        $i && o && r.nodeType == 1 && (c2 = r.childNodes[o - 1]).nodeType == 1 && c2.contentEditable == "false" && c2.getBoundingClientRect().top >= e.top && o--, r == t2.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t2.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (a = Cy(t2, r, o, e));
      }
      a == null && (a = Sy(t2, s, e));
      let l = t2.docView.nearestDesc(s, true);
      return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
    }
    function od(t2) {
      return t2.top < t2.bottom || t2.left < t2.right;
    }
    function Er(t2, e) {
      let n = t2.getClientRects();
      if (n.length) {
        let r = n[e < 0 ? 0 : n.length - 1];
        if (od(r))
          return r;
      }
      return Array.prototype.find.call(n, od) || t2.getBoundingClientRect();
    }
    const Ty = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function jf(t2, e, n) {
      let { node: r, offset: o, atom: i } = t2.docView.domFromPos(e, n < 0 ? -1 : 1), s = $i || In;
      if (r.nodeType == 3)
        if (s && (Ty.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
          let l = Er(sr(r, o, o), n);
          if (In && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
            let c2 = Er(sr(r, o - 1, o - 1), -1);
            if (c2.top == l.top) {
              let u = Er(sr(r, o, o + 1), -1);
              if (u.top != l.top)
                return Yo(u, u.left < c2.left);
            }
          }
          return l;
        } else {
          let l = o, c2 = o, u = n < 0 ? 1 : -1;
          return n < 0 && !o ? (c2++, u = -1) : n >= 0 && o == r.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c2++, Yo(Er(sr(r, l, c2), u), u < 0);
        }
      if (!t2.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
        if (i == null && o && (n < 0 || o == vn(r))) {
          let l = r.childNodes[o - 1];
          if (l.nodeType == 1)
            return ll(l.getBoundingClientRect(), false);
        }
        if (i == null && o < vn(r)) {
          let l = r.childNodes[o];
          if (l.nodeType == 1)
            return ll(l.getBoundingClientRect(), true);
        }
        return ll(r.getBoundingClientRect(), n >= 0);
      }
      if (i == null && o && (n < 0 || o == vn(r))) {
        let l = r.childNodes[o - 1], c2 = l.nodeType == 3 ? sr(l, vn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c2)
          return Yo(Er(c2, 1), false);
      }
      if (i == null && o < vn(r)) {
        let l = r.childNodes[o];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
          l = l.nextSibling;
        let c2 = l ? l.nodeType == 3 ? sr(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c2)
          return Yo(Er(c2, -1), true);
      }
      return Yo(Er(r.nodeType == 3 ? sr(r) : r, -n), n >= 0);
    }
    function Yo(t2, e) {
      if (t2.width == 0)
        return t2;
      let n = e ? t2.left : t2.right;
      return { top: t2.top, bottom: t2.bottom, left: n, right: n };
    }
    function ll(t2, e) {
      if (t2.height == 0)
        return t2;
      let n = e ? t2.top : t2.bottom;
      return { top: n, bottom: n, left: t2.left, right: t2.right };
    }
    function Yf(t2, e, n) {
      let r = t2.state, o = t2.root.activeElement;
      r != e && t2.updateState(e), o != t2.dom && t2.focus();
      try {
        return n();
      } finally {
        r != e && t2.updateState(r), o != t2.dom && o && o.focus();
      }
    }
    function Oy(t2, e, n) {
      let r = e.selection, o = n == "up" ? r.$from : r.$to;
      return Yf(t2, e, () => {
        let { node: i } = t2.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
        for (; ; ) {
          let a = t2.docView.nearestDesc(i, true);
          if (!a)
            break;
          if (a.node.isBlock) {
            i = a.contentDOM || a.dom;
            break;
          }
          i = a.dom.parentNode;
        }
        let s = jf(t2, o.pos, 1);
        for (let a = i.firstChild; a; a = a.nextSibling) {
          let l;
          if (a.nodeType == 1)
            l = a.getClientRects();
          else if (a.nodeType == 3)
            l = sr(a, 0, a.nodeValue.length).getClientRects();
          else
            continue;
          for (let c2 = 0; c2 < l.length; c2++) {
            let u = l[c2];
            if (u.bottom > u.top + 1 && (n == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    const Ny = /[\u0590-\u08ac]/;
    function Ay(t2, e, n) {
      let { $head: r } = e.selection;
      if (!r.parent.isTextblock)
        return false;
      let o = r.parentOffset, i = !o, s = o == r.parent.content.size, a = t2.domSelection();
      return a ? !Ny.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i : s : Yf(t2, e, () => {
        let { focusNode: l, focusOffset: c2, anchorNode: u, anchorOffset: d } = t2.domSelectionRange(), p2 = a.caretBidiLevel;
        a.modify("move", n, "character");
        let f = r.depth ? t2.docView.domAfterPos(r.before()) : t2.dom, { focusNode: h2, focusOffset: m } = t2.domSelectionRange(), g = h2 && !f.contains(h2.nodeType == 1 ? h2 : h2.parentNode) || l == h2 && c2 == m;
        try {
          a.collapse(u, d), l && (l != u || c2 != d) && a.extend && a.extend(l, c2);
        } catch {
        }
        return p2 != null && (a.caretBidiLevel = p2), g;
      }) : r.pos == r.start() || r.pos == r.end();
    }
    let id = null, sd = null, ad = false;
    function My(t2, e, n) {
      return id == e && sd == n ? ad : (id = e, sd = n, ad = n == "up" || n == "down" ? Oy(t2, e, n) : Ay(t2, e, n));
    }
    const kn = 0, ld = 1, jr = 2, Jn = 3;
    class Fi {
      constructor(e, n, r, o) {
        this.parent = e, this.children = n, this.dom = r, this.contentDOM = o, this.dirty = kn, r.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(e) {
        return false;
      }
      matchesMark(e) {
        return false;
      }
      matchesNode(e, n, r) {
        return false;
      }
      matchesHack(e) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(e) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let e = 0;
        for (let n = 0; n < this.children.length; n++)
          e += this.children[n].size;
        return e;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
          this.children[e].destroy();
      }
      posBeforeChild(e) {
        for (let n = 0, r = this.posAtStart; ; n++) {
          let o = this.children[n];
          if (o == e)
            return r;
          r += o.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(e, n, r) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
          if (r < 0) {
            let i, s;
            if (e == this.contentDOM)
              i = e.childNodes[n - 1];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              i = e.previousSibling;
            }
            for (; i && !((s = i.pmViewDesc) && s.parent == this); )
              i = i.previousSibling;
            return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
          } else {
            let i, s;
            if (e == this.contentDOM)
              i = e.childNodes[n];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              i = e.nextSibling;
            }
            for (; i && !((s = i.pmViewDesc) && s.parent == this); )
              i = i.nextSibling;
            return i ? this.posBeforeChild(s) : this.posAtEnd;
          }
        let o;
        if (e == this.dom && this.contentDOM)
          o = n > Dt(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          o = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (n == 0)
            for (let i = e; ; i = i.parentNode) {
              if (i == this.dom) {
                o = false;
                break;
              }
              if (i.previousSibling)
                break;
            }
          if (o == null && n == e.childNodes.length)
            for (let i = e; ; i = i.parentNode) {
              if (i == this.dom) {
                o = true;
                break;
              }
              if (i.nextSibling)
                break;
            }
        }
        return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(e, n = false) {
        for (let r = true, o = e; o; o = o.parentNode) {
          let i = this.getDesc(o), s;
          if (i && (!n || i.node))
            if (r && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
              r = false;
            else
              return i;
        }
      }
      getDesc(e) {
        let n = e.pmViewDesc;
        for (let r = n; r; r = r.parent)
          if (r == this)
            return n;
      }
      posFromDOM(e, n, r) {
        for (let o = e; o; o = o.parentNode) {
          let i = this.getDesc(o);
          if (i)
            return i.localPosFromDOM(e, n, r);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(e) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
          let o = this.children[n], i = r + o.size;
          if (r == e && i != r) {
            for (; !o.border && o.children.length; )
              for (let s = 0; s < o.children.length; s++) {
                let a = o.children[s];
                if (a.size) {
                  o = a;
                  break;
                }
              }
            return o;
          }
          if (e < i)
            return o.descAt(e - r - o.border);
          r = i;
        }
      }
      domFromPos(e, n) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: e + 1 };
        let r = 0, o = 0;
        for (let i = 0; r < this.children.length; r++) {
          let s = this.children[r], a = i + s.size;
          if (a > e || s instanceof Xf) {
            o = e - i;
            break;
          }
          i = a;
        }
        if (o)
          return this.children[r].domFromPos(o - this.children[r].border, n);
        for (let i; r && !(i = this.children[r - 1]).size && i instanceof Jf && i.side >= 0; r--)
          ;
        if (n <= 0) {
          let i, s = true;
          for (; i = r ? this.children[r - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); r--, s = false)
            ;
          return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : { node: this.contentDOM, offset: i ? Dt(i.dom) + 1 : 0 };
        } else {
          let i, s = true;
          for (; i = r < this.children.length ? this.children[r] : null, !(!i || i.dom.parentNode == this.contentDOM); r++, s = false)
            ;
          return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : { node: this.contentDOM, offset: i ? Dt(i.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(e, n, r = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let o = -1, i = -1;
        for (let s = r, a = 0; ; a++) {
          let l = this.children[a], c2 = s + l.size;
          if (o == -1 && e <= c2) {
            let u = s + l.border;
            if (e >= u && n <= c2 - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
              return l.parseRange(e, n, u);
            e = s;
            for (let d = a; d > 0; d--) {
              let p2 = this.children[d - 1];
              if (p2.size && p2.dom.parentNode == this.contentDOM && !p2.emptyChildAt(1)) {
                o = Dt(p2.dom) + 1;
                break;
              }
              e -= p2.size;
            }
            o == -1 && (o = 0);
          }
          if (o > -1 && (c2 > n || a == this.children.length - 1)) {
            n = c2;
            for (let u = a + 1; u < this.children.length; u++) {
              let d = this.children[u];
              if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
                i = Dt(d.dom);
                break;
              }
              n += d.size;
            }
            i == -1 && (i = this.contentDOM.childNodes.length);
            break;
          }
          s = c2;
        }
        return { node: this.contentDOM, from: e, to: n, fromOffset: o, toOffset: i };
      }
      emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let n = this.children[e < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(e);
      }
      domAfterPos(e) {
        let { node: n, offset: r } = this.domFromPos(e, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
          throw new RangeError("No node after pos " + e);
        return n.childNodes[r];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(e, n, r, o = false) {
        let i = Math.min(e, n), s = Math.max(e, n);
        for (let f = 0, h2 = 0; f < this.children.length; f++) {
          let m = this.children[f], g = h2 + m.size;
          if (i > h2 && s < g)
            return m.setSelection(e - h2 - m.border, n - h2 - m.border, r, o);
          h2 = g;
        }
        let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c2 = r.root.getSelection(), u = r.domSelectionRange(), d = false;
        if ((In || jt) && e == n) {
          let { node: f, offset: h2 } = a;
          if (f.nodeType == 3) {
            if (d = !!(h2 && f.nodeValue[h2 - 1] == `
`), d && h2 == f.nodeValue.length)
              for (let m = f, g; m; m = m.parentNode) {
                if (g = m.nextSibling) {
                  g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: Dt(g) + 1 });
                  break;
                }
                let b = m.pmViewDesc;
                if (b && b.node && b.node.isBlock)
                  break;
              }
          } else {
            let m = f.childNodes[h2 - 1];
            d = m && (m.nodeName == "BR" || m.contentEditable == "false");
          }
        }
        if (In && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
          let f = u.focusNode.childNodes[u.focusOffset];
          f && f.contentEditable == "false" && (o = true);
        }
        if (!(o || d && jt) && so(a.node, a.offset, u.anchorNode, u.anchorOffset) && so(l.node, l.offset, u.focusNode, u.focusOffset))
          return;
        let p2 = false;
        if ((c2.extend || e == n) && !d) {
          c2.collapse(a.node, a.offset);
          try {
            e != n && c2.extend(l.node, l.offset), p2 = true;
          } catch {
          }
        }
        if (!p2) {
          if (e > n) {
            let h2 = a;
            a = l, l = h2;
          }
          let f = document.createRange();
          f.setEnd(l.node, l.offset), f.setStart(a.node, a.offset), c2.removeAllRanges(), c2.addRange(f);
        }
      }
      ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(e, n) {
        for (let r = 0, o = 0; o < this.children.length; o++) {
          let i = this.children[o], s = r + i.size;
          if (r == s ? e <= s && n >= r : e < s && n > r) {
            let a = r + i.border, l = s - i.border;
            if (e >= a && n <= l) {
              this.dirty = e == r || n == s ? jr : ld, e == a && n == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = Jn : i.markDirty(e - a, n - a);
              return;
            } else
              i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? jr : Jn;
          }
          r = s;
        }
        this.dirty = jr;
      }
      markParentsDirty() {
        let e = 1;
        for (let n = this.parent; n; n = n.parent, e++) {
          let r = e == 1 ? jr : ld;
          n.dirty < r && (n.dirty = r);
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      isText(e) {
        return false;
      }
    }
    class Jf extends Fi {
      constructor(e, n, r, o) {
        let i, s = n.type.toDOM;
        if (typeof s == "function" && (s = s(r, () => {
          if (!i)
            return o;
          if (i.parent)
            return i.parent.posBeforeChild(i);
        })), !n.type.spec.raw) {
          if (s.nodeType != 1) {
            let a = document.createElement("span");
            a.appendChild(s), s = a;
          }
          s.contentEditable = "false", s.classList.add("ProseMirror-widget");
        }
        super(e, [], s, null), this.widget = n, this.widget = n, i = this;
      }
      matchesWidget(e) {
        return this.dirty == kn && e.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(e) {
        let n = this.widget.spec.stopEvent;
        return n ? n(e) : false;
      }
      ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom), super.destroy();
      }
      get domAtom() {
        return true;
      }
      get side() {
        return this.widget.type.side;
      }
    }
    class Ry extends Fi {
      constructor(e, n, r, o) {
        super(e, [], n, null), this.textDOM = r, this.text = o;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(e, n) {
        return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
      }
      domFromPos(e) {
        return { node: this.textDOM, offset: e };
      }
      ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue;
      }
    }
    class ao extends Fi {
      constructor(e, n, r, o, i) {
        super(e, [], r, o), this.mark = n, this.spec = i;
      }
      static create(e, n, r, o) {
        let i = o.nodeViews[n.type.name], s = i && i(n, o, r);
        return (!s || !s.dom) && (s = fo.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new ao(e, n, s.dom, s.contentDOM || s.dom, s);
      }
      parseRule() {
        return this.dirty & Jn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(e) {
        return this.dirty != Jn && this.mark.eq(e);
      }
      markDirty(e, n) {
        if (super.markDirty(e, n), this.dirty != kn) {
          let r = this.parent;
          for (; !r.node; )
            r = r.parent;
          r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = kn;
        }
      }
      slice(e, n, r) {
        let o = ao.create(this.parent, this.mark, true, r), i = this.children, s = this.size;
        n < s && (i = jl(i, n, s, r)), e > 0 && (i = jl(i, 0, e, r));
        for (let a = 0; a < i.length; a++)
          i[a].parent = o;
        return o.children = i, o;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
    }
    class Dr extends Fi {
      constructor(e, n, r, o, i, s, a, l, c2) {
        super(e, [], i, s), this.node = n, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = a;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(e, n, r, o, i, s) {
        let a = i.nodeViews[n.type.name], l, c2 = a && a(n, i, () => {
          if (!l)
            return s;
          if (l.parent)
            return l.parent.posBeforeChild(l);
        }, r, o), u = c2 && c2.dom, d = c2 && c2.contentDOM;
        if (n.isText) {
          if (!u)
            u = document.createTextNode(n.text);
          else if (u.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else u || ({ dom: u, contentDOM: d } = fo.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
        !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = true));
        let p2 = u;
        return u = eh(u, r, n), c2 ? l = new Iy(e, n, r, o, u, d || null, p2, c2, i, s + 1) : n.isText ? new Ra(e, n, r, o, u, p2, i) : new Dr(e, n, r, o, u, d || null, p2, i, s + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let e = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
          e.getContent = () => this.node.content;
        else if (!this.contentLost)
          e.contentElement = this.contentDOM;
        else {
          for (let n = this.children.length - 1; n >= 0; n--) {
            let r = this.children[n];
            if (this.dom.contains(r.dom.parentNode)) {
              e.contentElement = r.dom.parentNode;
              break;
            }
          }
          e.contentElement || (e.getContent = () => R.empty);
        }
        return e;
      }
      matchesNode(e, n, r) {
        return this.dirty == kn && e.eq(this.node) && Bs(n, this.outerDeco) && r.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(e, n) {
        let r = this.node.inlineContent, o = n, i = e.composing ? this.localCompositionInfo(e, n) : null, s = i && i.pos > -1 ? i : null, a = i && i.pos < 0, l = new Ly(this, s && s.node, e);
        $y(this.node, this.innerDeco, (c2, u, d) => {
          c2.spec.marks ? l.syncToMarks(c2.spec.marks, r, e) : c2.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Xe.none : this.node.child(u).marks, r, e), l.placeWidget(c2, e, o);
        }, (c2, u, d, p2) => {
          l.syncToMarks(c2.marks, r, e);
          let f;
          l.findNodeMatch(c2, u, d, p2) || a && e.state.selection.from > o && e.state.selection.to < o + c2.nodeSize && (f = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c2, u, d, f, e) || l.updateNextNode(c2, u, d, e, p2, o) || l.addNode(c2, u, d, e, o), o += c2.nodeSize;
        }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == jr) && (s && this.protectLocalComposition(e, s), Zf(this.contentDOM, this.children, e), Io && Fy(this.dom));
      }
      localCompositionInfo(e, n) {
        let { from: r, to: o } = e.state.selection;
        if (!(e.state.selection instanceof ie) || r < n || o > n + this.node.content.size)
          return null;
        let i = e.input.compositionNode;
        if (!i || !this.dom.contains(i.parentNode))
          return null;
        if (this.node.inlineContent) {
          let s = i.nodeValue, a = zy(this.node.content, s, r - n, o - n);
          return a < 0 ? null : { node: i, pos: a, text: s };
        } else
          return { node: i, pos: -1, text: "" };
      }
      protectLocalComposition(e, { node: n, pos: r, text: o }) {
        if (this.getDesc(n))
          return;
        let i = n;
        for (; i.parentNode != this.contentDOM; i = i.parentNode) {
          for (; i.previousSibling; )
            i.parentNode.removeChild(i.previousSibling);
          for (; i.nextSibling; )
            i.parentNode.removeChild(i.nextSibling);
          i.pmViewDesc && (i.pmViewDesc = void 0);
        }
        let s = new Ry(this, i, n, o);
        e.input.compositionNodes.push(s), this.children = jl(this.children, r, r + o.length, e, s);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(e, n, r, o) {
        return this.dirty == Jn || !e.sameMarkup(this.node) ? false : (this.updateInner(e, n, r, o), true);
      }
      updateInner(e, n, r, o) {
        this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = kn;
      }
      updateOuterDeco(e) {
        if (Bs(e, this.outerDeco))
          return;
        let n = this.nodeDOM.nodeType != 1, r = this.dom;
        this.dom = Qf(this.dom, this.nodeDOM, Gl(this.outerDeco, this.node, n), Gl(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
      }
      // Mark this node as being the selected node.
      selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
      }
      // Remove selected node marking from this node.
      deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
      }
      get domAtom() {
        return this.node.isAtom;
      }
    }
    function cd(t2, e, n, r, o) {
      eh(r, e, t2);
      let i = new Dr(void 0, t2, e, n, r, r, r, o, 0);
      return i.contentDOM && i.updateChildren(o, 0), i;
    }
    class Ra extends Dr {
      constructor(e, n, r, o, i, s, a) {
        super(e, n, r, o, i, null, s, a, 0);
      }
      parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco; )
          e = e.parentNode;
        return { skip: e || true };
      }
      update(e, n, r, o) {
        return this.dirty == Jn || this.dirty != kn && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(n), (this.dirty != kn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = kn, true);
      }
      inParent() {
        let e = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
          if (n == e)
            return true;
        return false;
      }
      domFromPos(e) {
        return { node: this.nodeDOM, offset: e };
      }
      localPosFromDOM(e, n, r) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
      }
      ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection";
      }
      slice(e, n, r) {
        let o = this.node.cut(e, n), i = document.createTextNode(o.text);
        return new Ra(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
      }
      markDirty(e, n) {
        super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Jn);
      }
      get domAtom() {
        return false;
      }
      isText(e) {
        return this.node.text == e;
      }
    }
    class Xf extends Fi {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(e) {
        return this.dirty == kn && this.dom.nodeName == e;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    }
    class Iy extends Dr {
      constructor(e, n, r, o, i, s, a, l, c2, u) {
        super(e, n, r, o, i, s, a, c2, u), this.spec = l;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(e, n, r, o) {
        if (this.dirty == Jn)
          return false;
        if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
          let i = this.spec.update(e, n, r);
          return i && this.updateInner(e, n, r, o), i;
        } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, n, r, o);
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(e, n, r, o) {
        this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, o);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
      stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
    }
    function Zf(t2, e, n) {
      let r = t2.firstChild, o = false;
      for (let i = 0; i < e.length; i++) {
        let s = e[i], a = s.dom;
        if (a.parentNode == t2) {
          for (; a != r; )
            r = ud(r), o = true;
          r = r.nextSibling;
        } else
          o = true, t2.insertBefore(a, r);
        if (s instanceof ao) {
          let l = r ? r.previousSibling : t2.lastChild;
          Zf(s.contentDOM, s.children, n), r = l ? l.nextSibling : t2.firstChild;
        }
      }
      for (; r; )
        r = ud(r), o = true;
      o && n.trackWrites == t2 && (n.trackWrites = null);
    }
    const ii = function(t2) {
      t2 && (this.nodeName = t2);
    };
    ii.prototype = /* @__PURE__ */ Object.create(null);
    const Yr = [new ii()];
    function Gl(t2, e, n) {
      if (t2.length == 0)
        return Yr;
      let r = n ? Yr[0] : new ii(), o = [r];
      for (let i = 0; i < t2.length; i++) {
        let s = t2[i].type.attrs;
        if (s) {
          s.nodeName && o.push(r = new ii(s.nodeName));
          for (let a in s) {
            let l = s[a];
            l != null && (n && o.length == 1 && o.push(r = new ii(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
          }
        }
      }
      return o;
    }
    function Qf(t2, e, n, r) {
      if (n == Yr && r == Yr)
        return e;
      let o = e;
      for (let i = 0; i < r.length; i++) {
        let s = r[i], a = n[i];
        if (i) {
          let l;
          a && a.nodeName == s.nodeName && o != t2 && (l = o.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = true, l.appendChild(o), a = Yr[0]), o = l;
        }
        Dy(o, a || Yr[0], s);
      }
      return o;
    }
    function Dy(t2, e, n) {
      for (let r in e)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && t2.removeAttribute(r);
      for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t2.setAttribute(r, n[r]);
      if (e.class != n.class) {
        let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let i = 0; i < r.length; i++)
          o.indexOf(r[i]) == -1 && t2.classList.remove(r[i]);
        for (let i = 0; i < o.length; i++)
          r.indexOf(o[i]) == -1 && t2.classList.add(o[i]);
        t2.classList.length == 0 && t2.removeAttribute("class");
      }
      if (e.style != n.style) {
        if (e.style) {
          let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
          for (; o = r.exec(e.style); )
            t2.style.removeProperty(o[1]);
        }
        n.style && (t2.style.cssText += n.style);
      }
    }
    function eh(t2, e, n) {
      return Qf(t2, t2, Yr, Gl(e, n, t2.nodeType != 1));
    }
    function Bs(t2, e) {
      if (t2.length != e.length)
        return false;
      for (let n = 0; n < t2.length; n++)
        if (!t2[n].type.eq(e[n].type))
          return false;
      return true;
    }
    function ud(t2) {
      let e = t2.nextSibling;
      return t2.parentNode.removeChild(t2), e;
    }
    class Ly {
      constructor(e, n, r) {
        this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = Py(e.node.content, e);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(e, n) {
        if (e != n) {
          for (let r = e; r < n; r++)
            this.top.children[r].destroy();
          this.top.children.splice(e, n - e), this.changed = true;
        }
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(e, n, r) {
        let o = 0, i = this.stack.length >> 1, s = Math.min(i, e.length);
        for (; o < s && (o == i - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== false; )
          o++;
        for (; o < i; )
          this.destroyRest(), this.top.dirty = kn, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
        for (; i < e.length; ) {
          this.stack.push(this.top, this.index + 1);
          let a = -1;
          for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
            let c2 = this.top.children[l];
            if (c2.matchesMark(e[i]) && !this.isLocked(c2.dom)) {
              a = l;
              break;
            }
          }
          if (a > -1)
            a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
          else {
            let l = ao.create(this.top, e[i], n, r);
            this.top.children.splice(this.index, 0, l), this.top = l, this.changed = true;
          }
          this.index = 0, i++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(e, n, r, o) {
        let i = -1, s;
        if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, r))
          i = this.top.children.indexOf(s, this.index);
        else
          for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
            let c2 = this.top.children[a];
            if (c2.matchesNode(e, n, r) && !this.preMatch.matched.has(c2)) {
              i = a;
              break;
            }
          }
        return i < 0 ? false : (this.destroyBetween(this.index, i), this.index++, true);
      }
      updateNodeAt(e, n, r, o, i) {
        let s = this.top.children[o];
        return s.dirty == Jn && s.dom == s.contentDOM && (s.dirty = jr), s.update(e, n, r, i) ? (this.destroyBetween(this.index, o), this.index++, true) : false;
      }
      findIndexWithChild(e) {
        for (; ; ) {
          let n = e.parentNode;
          if (!n)
            return -1;
          if (n == this.top.contentDOM) {
            let r = e.pmViewDesc;
            if (r) {
              for (let o = this.index; o < this.top.children.length; o++)
                if (this.top.children[o] == r)
                  return o;
            }
            return -1;
          }
          e = n;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(e, n, r, o, i, s) {
        for (let a = this.index; a < this.top.children.length; a++) {
          let l = this.top.children[a];
          if (l instanceof Dr) {
            let c2 = this.preMatch.matched.get(l);
            if (c2 != null && c2 != i)
              return false;
            let u = l.dom, d, p2 = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Jn && Bs(n, l.outerDeco));
            if (!p2 && l.update(e, n, r, o))
              return this.destroyBetween(this.index, a), l.dom != u && (this.changed = true), this.index++, true;
            if (!p2 && (d = this.recreateWrapper(l, e, n, r, o, s)))
              return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = jr, d.updateChildren(o, s + 1), d.dirty = kn), this.changed = true, this.index++, true;
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(e, n, r, o, i, s) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Bs(r, e.outerDeco) || !o.eq(e.innerDeco))
          return null;
        let a = Dr.create(this.top, n, r, o, i, s);
        if (a.contentDOM) {
          a.children = e.children, e.children = [];
          for (let l of a.children)
            l.parent = a;
        }
        return e.destroy(), a;
      }
      // Insert the node as a newly created node desc.
      addNode(e, n, r, o, i) {
        let s = Dr.create(this.top, e, n, r, o, i);
        s.contentDOM && s.updateChildren(o, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = true;
      }
      placeWidget(e, n, r) {
        let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
          this.index++;
        else {
          let i = new Jf(this.top, e, n, r);
          this.top.children.splice(this.index++, 0, i), this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let e = this.top.children[this.index - 1], n = this.top;
        for (; e instanceof ao; )
          n = e, e = n.children[n.children.length - 1];
        (!e || // Empty textblock
        !(e instanceof Ra) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((jt || zt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
      }
      addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
          this.index++;
        else {
          let r = document.createElement(e);
          e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
          let o = new Xf(this.top, [], r, null);
          n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o), this.changed = true;
        }
      }
      isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
      }
    }
    function Py(t2, e) {
      let n = e, r = n.children.length, o = t2.childCount, i = /* @__PURE__ */ new Map(), s = [];
      e: for (; o > 0; ) {
        let a;
        for (; ; )
          if (r) {
            let c2 = n.children[r - 1];
            if (c2 instanceof ao)
              n = c2, r = c2.children.length;
            else {
              a = c2, r--;
              break;
            }
          } else {
            if (n == e)
              break e;
            r = n.parent.children.indexOf(n), n = n.parent;
          }
        let l = a.node;
        if (l) {
          if (l != t2.child(o - 1))
            break;
          --o, i.set(a, o), s.push(a);
        }
      }
      return { index: o, matched: i, matches: s.reverse() };
    }
    function By(t2, e) {
      return t2.type.side - e.type.side;
    }
    function $y(t2, e, n, r) {
      let o = e.locals(t2), i = 0;
      if (o.length == 0) {
        for (let c2 = 0; c2 < t2.childCount; c2++) {
          let u = t2.child(c2);
          r(u, o, e.forChild(i, u), c2), i += u.nodeSize;
        }
        return;
      }
      let s = 0, a = [], l = null;
      for (let c2 = 0; ; ) {
        let u, d;
        for (; s < o.length && o[s].to == i; ) {
          let g = o[s++];
          g.widget && (u ? (d || (d = [u])).push(g) : u = g);
        }
        if (u)
          if (d) {
            d.sort(By);
            for (let g = 0; g < d.length; g++)
              n(d[g], c2, !!l);
          } else
            n(u, c2, !!l);
        let p2, f;
        if (l)
          f = -1, p2 = l, l = null;
        else if (c2 < t2.childCount)
          f = c2, p2 = t2.child(c2++);
        else
          break;
        for (let g = 0; g < a.length; g++)
          a[g].to <= i && a.splice(g--, 1);
        for (; s < o.length && o[s].from <= i && o[s].to > i; )
          a.push(o[s++]);
        let h2 = i + p2.nodeSize;
        if (p2.isText) {
          let g = h2;
          s < o.length && o[s].from < g && (g = o[s].from);
          for (let b = 0; b < a.length; b++)
            a[b].to < g && (g = a[b].to);
          g < h2 && (l = p2.cut(g - i), p2 = p2.cut(0, g - i), h2 = g, f = -1);
        } else
          for (; s < o.length && o[s].to < h2; )
            s++;
        let m = p2.isInline && !p2.isLeaf ? a.filter((g) => !g.inline) : a.slice();
        r(p2, m, e.forChild(i, p2), f), i = h2;
      }
    }
    function Fy(t2) {
      if (t2.nodeName == "UL" || t2.nodeName == "OL") {
        let e = t2.style.cssText;
        t2.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t2).listStyle, t2.style.cssText = e;
      }
    }
    function zy(t2, e, n, r) {
      for (let o = 0, i = 0; o < t2.childCount && i <= r; ) {
        let s = t2.child(o++), a = i;
        if (i += s.nodeSize, !s.isText)
          continue;
        let l = s.text;
        for (; o < t2.childCount; ) {
          let c2 = t2.child(o++);
          if (i += c2.nodeSize, !c2.isText)
            break;
          l += c2.text;
        }
        if (i >= n) {
          if (i >= r && l.slice(r - e.length - a, r - a) == e)
            return r - e.length;
          let c2 = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
          if (c2 >= 0 && c2 + e.length + a >= n)
            return a + c2;
          if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
            return r;
        }
      }
      return -1;
    }
    function jl(t2, e, n, r, o) {
      let i = [];
      for (let s = 0, a = 0; s < t2.length; s++) {
        let l = t2[s], c2 = a, u = a += l.size;
        c2 >= n || u <= e ? i.push(l) : (c2 < e && i.push(l.slice(0, e - c2, r)), o && (i.push(o), o = void 0), u > n && i.push(l.slice(n - c2, l.size, r)));
      }
      return i;
    }
    function Ac(t2, e = null) {
      let n = t2.domSelectionRange(), r = t2.state.doc;
      if (!n.focusNode)
        return null;
      let o = t2.docView.nearestDesc(n.focusNode), i = o && o.size == 0, s = t2.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
      if (s < 0)
        return null;
      let a = r.resolve(s), l, c2;
      if (Ma(n)) {
        for (l = s; o && !o.node; )
          o = o.parent;
        let d = o.node;
        if (o && d.isAtom && re.isSelectable(d) && o.parent && !(d.isInline && py(n.focusNode, n.focusOffset, o.dom))) {
          let p2 = o.posBefore;
          c2 = new re(s == p2 ? a : r.resolve(p2));
        }
      } else {
        if (n instanceof t2.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
          let d = s, p2 = s;
          for (let f = 0; f < n.rangeCount; f++) {
            let h2 = n.getRangeAt(f);
            d = Math.min(d, t2.docView.posFromDOM(h2.startContainer, h2.startOffset, 1)), p2 = Math.max(p2, t2.docView.posFromDOM(h2.endContainer, h2.endOffset, -1));
          }
          if (d < 0)
            return null;
          [l, s] = p2 == t2.state.selection.anchor ? [p2, d] : [d, p2], a = r.resolve(s);
        } else
          l = t2.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (l < 0)
          return null;
      }
      let u = r.resolve(l);
      if (!c2) {
        let d = e == "pointer" || t2.state.selection.head < a.pos && !i ? 1 : -1;
        c2 = Mc(t2, u, a, d);
      }
      return c2;
    }
    function th(t2) {
      return t2.editable ? t2.hasFocus() : rh(t2) && document.activeElement && document.activeElement.contains(t2.dom);
    }
    function dr(t2, e = false) {
      let n = t2.state.selection;
      if (nh(t2, n), !!th(t2)) {
        if (!e && t2.input.mouseDown && t2.input.mouseDown.allowDefault && zt) {
          let r = t2.domSelectionRange(), o = t2.domObserver.currentSelection;
          if (r.anchorNode && o.anchorNode && so(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
            t2.input.mouseDown.delayedSelectionSync = true, t2.domObserver.setCurSelection();
            return;
          }
        }
        if (t2.domObserver.disconnectSelection(), t2.cursorWrapper)
          Uy(t2);
        else {
          let { anchor: r, head: o } = n, i, s;
          dd && !(n instanceof ie) && (n.$from.parent.inlineContent || (i = pd(t2, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = pd(t2, n.to))), t2.docView.setSelection(r, o, t2, e), dd && (i && fd(i), s && fd(s)), n.visible ? t2.dom.classList.remove("ProseMirror-hideselection") : (t2.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Hy(t2));
        }
        t2.domObserver.setCurSelection(), t2.domObserver.connectSelection();
      }
    }
    const dd = jt || zt && Vf < 63;
    function pd(t2, e) {
      let { node: n, offset: r } = t2.docView.domFromPos(e, 0), o = r < n.childNodes.length ? n.childNodes[r] : null, i = r ? n.childNodes[r - 1] : null;
      if (jt && o && o.contentEditable == "false")
        return cl(o);
      if ((!o || o.contentEditable == "false") && (!i || i.contentEditable == "false")) {
        if (o)
          return cl(o);
        if (i)
          return cl(i);
      }
    }
    function cl(t2) {
      return t2.contentEditable = "true", jt && t2.draggable && (t2.draggable = false, t2.wasDraggable = true), t2;
    }
    function fd(t2) {
      t2.contentEditable = "false", t2.wasDraggable && (t2.draggable = true, t2.wasDraggable = null);
    }
    function Hy(t2) {
      let e = t2.dom.ownerDocument;
      e.removeEventListener("selectionchange", t2.input.hideSelectionGuard);
      let n = t2.domSelectionRange(), r = n.anchorNode, o = n.anchorOffset;
      e.addEventListener("selectionchange", t2.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != o) && (e.removeEventListener("selectionchange", t2.input.hideSelectionGuard), setTimeout(() => {
          (!th(t2) || t2.state.selection.visible) && t2.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
      });
    }
    function Uy(t2) {
      let e = t2.domSelection(), n = document.createRange();
      if (!e)
        return;
      let r = t2.cursorWrapper.dom, o = r.nodeName == "IMG";
      o ? n.setStart(r.parentNode, Dt(r) + 1) : n.setStart(r, 0), n.collapse(true), e.removeAllRanges(), e.addRange(n), !o && !t2.state.selection.visible && en && Ir <= 11 && (r.disabled = true, r.disabled = false);
    }
    function nh(t2, e) {
      if (e instanceof re) {
        let n = t2.docView.descAt(e.from);
        n != t2.lastSelectedViewDesc && (hd(t2), n && n.selectNode(), t2.lastSelectedViewDesc = n);
      } else
        hd(t2);
    }
    function hd(t2) {
      t2.lastSelectedViewDesc && (t2.lastSelectedViewDesc.parent && t2.lastSelectedViewDesc.deselectNode(), t2.lastSelectedViewDesc = void 0);
    }
    function Mc(t2, e, n, r) {
      return t2.someProp("createSelectionBetween", (o) => o(t2, e, n)) || ie.between(e, n, r);
    }
    function md(t2) {
      return t2.editable && !t2.hasFocus() ? false : rh(t2);
    }
    function rh(t2) {
      let e = t2.domSelectionRange();
      if (!e.anchorNode)
        return false;
      try {
        return t2.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t2.editable || t2.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
      } catch {
        return false;
      }
    }
    function Vy(t2) {
      let e = t2.docView.domFromPos(t2.state.selection.anchor, 0), n = t2.domSelectionRange();
      return so(e.node, e.offset, n.anchorNode, n.anchorOffset);
    }
    function Yl(t2, e) {
      let { $anchor: n, $head: r } = t2.selection, o = e > 0 ? n.max(r) : n.min(r), i = o.parent.inlineContent ? o.depth ? t2.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
      return i && ue.findFrom(i, e);
    }
    function kr(t2, e) {
      return t2.dispatch(t2.state.tr.setSelection(e).scrollIntoView()), true;
    }
    function gd(t2, e, n) {
      let r = t2.state.selection;
      if (r instanceof ie)
        if (n.indexOf("s") > -1) {
          let { $head: o } = r, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
          if (!i || i.isText || !i.isLeaf)
            return false;
          let s = t2.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
          return kr(t2, new ie(r.$anchor, s));
        } else if (r.empty) {
          if (t2.endOfTextblock(e > 0 ? "forward" : "backward")) {
            let o = Yl(t2.state, e);
            return o && o instanceof re ? kr(t2, o) : false;
          } else if (!(yn && n.indexOf("m") > -1)) {
            let o = r.$head, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, s;
            if (!i || i.isText)
              return false;
            let a = e < 0 ? o.pos - i.nodeSize : o.pos;
            return i.isAtom || (s = t2.docView.descAt(a)) && !s.contentDOM ? re.isSelectable(i) ? kr(t2, new re(e < 0 ? t2.state.doc.resolve(o.pos - i.nodeSize) : o)) : $i ? kr(t2, new ie(t2.state.doc.resolve(e < 0 ? a : a + i.nodeSize))) : false : false;
          }
        } else return false;
      else {
        if (r instanceof re && r.node.isInline)
          return kr(t2, new ie(e > 0 ? r.$to : r.$from));
        {
          let o = Yl(t2.state, e);
          return o ? kr(t2, o) : false;
        }
      }
    }
    function $s(t2) {
      return t2.nodeType == 3 ? t2.nodeValue.length : t2.childNodes.length;
    }
    function si(t2, e) {
      let n = t2.pmViewDesc;
      return n && n.size == 0 && (e < 0 || t2.nextSibling || t2.nodeName != "BR");
    }
    function bo(t2, e) {
      return e < 0 ? Wy(t2) : Ky(t2);
    }
    function Wy(t2) {
      let e = t2.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
      if (!n)
        return;
      let o, i, s = false;
      for (In && n.nodeType == 1 && r < $s(n) && si(n.childNodes[r], -1) && (s = true); ; )
        if (r > 0) {
          if (n.nodeType != 1)
            break;
          {
            let a = n.childNodes[r - 1];
            if (si(a, -1))
              o = n, i = --r;
            else if (a.nodeType == 3)
              n = a, r = n.nodeValue.length;
            else
              break;
          }
        } else {
          if (oh(n))
            break;
          {
            let a = n.previousSibling;
            for (; a && si(a, -1); )
              o = n.parentNode, i = Dt(a), a = a.previousSibling;
            if (a)
              n = a, r = $s(n);
            else {
              if (n = n.parentNode, n == t2.dom)
                break;
              r = 0;
            }
          }
        }
      s ? Jl(t2, n, r) : o && Jl(t2, o, i);
    }
    function Ky(t2) {
      let e = t2.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
      if (!n)
        return;
      let o = $s(n), i, s;
      for (; ; )
        if (r < o) {
          if (n.nodeType != 1)
            break;
          let a = n.childNodes[r];
          if (si(a, 1))
            i = n, s = ++r;
          else
            break;
        } else {
          if (oh(n))
            break;
          {
            let a = n.nextSibling;
            for (; a && si(a, 1); )
              i = a.parentNode, s = Dt(a) + 1, a = a.nextSibling;
            if (a)
              n = a, r = 0, o = $s(n);
            else {
              if (n = n.parentNode, n == t2.dom)
                break;
              r = o = 0;
            }
          }
        }
      i && Jl(t2, i, s);
    }
    function oh(t2) {
      let e = t2.pmViewDesc;
      return e && e.node && e.node.isBlock;
    }
    function qy(t2, e) {
      for (; t2 && e == t2.childNodes.length && !Bi(t2); )
        e = Dt(t2) + 1, t2 = t2.parentNode;
      for (; t2 && e < t2.childNodes.length; ) {
        let n = t2.childNodes[e];
        if (n.nodeType == 3)
          return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
          break;
        t2 = n, e = 0;
      }
    }
    function Gy(t2, e) {
      for (; t2 && !e && !Bi(t2); )
        e = Dt(t2), t2 = t2.parentNode;
      for (; t2 && e; ) {
        let n = t2.childNodes[e - 1];
        if (n.nodeType == 3)
          return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
          break;
        t2 = n, e = t2.childNodes.length;
      }
    }
    function Jl(t2, e, n) {
      if (e.nodeType != 3) {
        let i, s;
        (s = qy(e, n)) ? (e = s, n = 0) : (i = Gy(e, n)) && (e = i, n = i.nodeValue.length);
      }
      let r = t2.domSelection();
      if (!r)
        return;
      if (Ma(r)) {
        let i = document.createRange();
        i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
      } else r.extend && r.extend(e, n);
      t2.domObserver.setCurSelection();
      let { state: o } = t2;
      setTimeout(() => {
        t2.state == o && dr(t2);
      }, 50);
    }
    function bd(t2, e) {
      let n = t2.state.doc.resolve(e);
      if (!(zt || my) && n.parent.inlineContent) {
        let o = t2.coordsAtPos(e);
        if (e > n.start()) {
          let i = t2.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
          if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
            return i.left < o.left ? "ltr" : "rtl";
        }
        if (e < n.end()) {
          let i = t2.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
          if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
            return i.left > o.left ? "ltr" : "rtl";
        }
      }
      return getComputedStyle(t2.dom).direction == "rtl" ? "rtl" : "ltr";
    }
    function yd(t2, e, n) {
      let r = t2.state.selection;
      if (r instanceof ie && !r.empty || n.indexOf("s") > -1 || yn && n.indexOf("m") > -1)
        return false;
      let { $from: o, $to: i } = r;
      if (!o.parent.inlineContent || t2.endOfTextblock(e < 0 ? "up" : "down")) {
        let s = Yl(t2.state, e);
        if (s && s instanceof re)
          return kr(t2, s);
      }
      if (!o.parent.inlineContent) {
        let s = e < 0 ? o : i, a = r instanceof pn ? ue.near(s, e) : ue.findFrom(s, e);
        return a ? kr(t2, a) : false;
      }
      return false;
    }
    function vd(t2, e) {
      if (!(t2.state.selection instanceof ie))
        return true;
      let { $head: n, $anchor: r, empty: o } = t2.state.selection;
      if (!n.sameParent(r))
        return true;
      if (!o)
        return false;
      if (t2.endOfTextblock(e > 0 ? "forward" : "backward"))
        return true;
      let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
      if (i && !i.isText) {
        let s = t2.state.tr;
        return e < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize), t2.dispatch(s), true;
      }
      return false;
    }
    function Ed(t2, e, n) {
      t2.domObserver.stop(), e.contentEditable = n, t2.domObserver.start();
    }
    function jy(t2) {
      if (!jt || t2.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode: e, focusOffset: n } = t2.domSelectionRange();
      if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let r = e.firstChild;
        Ed(t2, r, "true"), setTimeout(() => Ed(t2, r, "false"), 20);
      }
      return false;
    }
    function Yy(t2) {
      let e = "";
      return t2.ctrlKey && (e += "c"), t2.metaKey && (e += "m"), t2.altKey && (e += "a"), t2.shiftKey && (e += "s"), e;
    }
    function Jy(t2, e) {
      let n = e.keyCode, r = Yy(e);
      if (n == 8 || yn && n == 72 && r == "c")
        return vd(t2, -1) || bo(t2, -1);
      if (n == 46 && !e.shiftKey || yn && n == 68 && r == "c")
        return vd(t2, 1) || bo(t2, 1);
      if (n == 13 || n == 27)
        return true;
      if (n == 37 || yn && n == 66 && r == "c") {
        let o = n == 37 ? bd(t2, t2.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return gd(t2, o, r) || bo(t2, o);
      } else if (n == 39 || yn && n == 70 && r == "c") {
        let o = n == 39 ? bd(t2, t2.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return gd(t2, o, r) || bo(t2, o);
      } else {
        if (n == 38 || yn && n == 80 && r == "c")
          return yd(t2, -1, r) || bo(t2, -1);
        if (n == 40 || yn && n == 78 && r == "c")
          return jy(t2) || yd(t2, 1, r) || bo(t2, 1);
        if (r == (yn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
          return true;
      }
      return false;
    }
    function Rc(t2, e) {
      t2.someProp("transformCopied", (f) => {
        e = f(e, t2);
      });
      let n = [], { content: r, openStart: o, openEnd: i } = e;
      for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        o--, i--;
        let f = r.firstChild;
        n.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), r = f.content;
      }
      let s = t2.someProp("clipboardSerializer") || fo.fromSchema(t2.state.schema), a = uh(), l = a.createElement("div");
      l.appendChild(s.serializeFragment(r, { document: a }));
      let c2 = l.firstChild, u, d = 0;
      for (; c2 && c2.nodeType == 1 && (u = ch[c2.nodeName.toLowerCase()]); ) {
        for (let f = u.length - 1; f >= 0; f--) {
          let h2 = a.createElement(u[f]);
          for (; l.firstChild; )
            h2.appendChild(l.firstChild);
          l.appendChild(h2), d++;
        }
        c2 = l.firstChild;
      }
      c2 && c2.nodeType == 1 && c2.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
      let p2 = t2.someProp("clipboardTextSerializer", (f) => f(e, t2)) || e.content.textBetween(0, e.content.size, `

`);
      return { dom: l, text: p2, slice: e };
    }
    function ih(t2, e, n, r, o) {
      let i = o.parent.type.spec.code, s, a;
      if (!n && !e)
        return null;
      let l = e && (r || i || !n);
      if (l) {
        if (t2.someProp("transformPastedText", (p2) => {
          e = p2(e, i || r, t2);
        }), i)
          return e ? new K(R.from(t2.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : K.empty;
        let d = t2.someProp("clipboardTextParser", (p2) => p2(e, o, r, t2));
        if (d)
          a = d;
        else {
          let p2 = o.marks(), { schema: f } = t2.state, h2 = fo.fromSchema(f);
          s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
            let g = s.appendChild(document.createElement("p"));
            m && g.appendChild(h2.serializeNode(f.text(m, p2)));
          });
        }
      } else
        t2.someProp("transformPastedHTML", (d) => {
          n = d(n, t2);
        }), s = ev(n), $i && tv(s);
      let c2 = s && s.querySelector("[data-pm-slice]"), u = c2 && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c2.getAttribute("data-pm-slice") || "");
      if (u && u[3])
        for (let d = +u[3]; d > 0; d--) {
          let p2 = s.firstChild;
          for (; p2 && p2.nodeType != 1; )
            p2 = p2.nextSibling;
          if (!p2)
            break;
          s = p2;
        }
      if (a || (a = (t2.someProp("clipboardParser") || t2.someProp("domParser") || Rr.fromSchema(t2.state.schema)).parseSlice(s, {
        preserveWhitespace: !!(l || u),
        context: o,
        ruleFromNode(p2) {
          return p2.nodeName == "BR" && !p2.nextSibling && p2.parentNode && !Xy.test(p2.parentNode.nodeName) ? { ignore: true } : null;
        }
      })), u)
        a = nv(kd(a, +u[1], +u[2]), u[4]);
      else if (a = K.maxOpen(Zy(a.content, o), true), a.openStart || a.openEnd) {
        let d = 0, p2 = 0;
        for (let f = a.content.firstChild; d < a.openStart && !f.type.spec.isolating; d++, f = f.firstChild)
          ;
        for (let f = a.content.lastChild; p2 < a.openEnd && !f.type.spec.isolating; p2++, f = f.lastChild)
          ;
        a = kd(a, d, p2);
      }
      return t2.someProp("transformPasted", (d) => {
        a = d(a, t2);
      }), a;
    }
    const Xy = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function Zy(t2, e) {
      if (t2.childCount < 2)
        return t2;
      for (let n = e.depth; n >= 0; n--) {
        let o = e.node(n).contentMatchAt(e.index(n)), i, s = [];
        if (t2.forEach((a) => {
          if (!s)
            return;
          let l = o.findWrapping(a.type), c2;
          if (!l)
            return s = null;
          if (c2 = s.length && i.length && ah(l, i, a, s[s.length - 1], 0))
            s[s.length - 1] = c2;
          else {
            s.length && (s[s.length - 1] = lh(s[s.length - 1], i.length));
            let u = sh(a, l);
            s.push(u), o = o.matchType(u.type), i = l;
          }
        }), s)
          return R.from(s);
      }
      return t2;
    }
    function sh(t2, e, n = 0) {
      for (let r = e.length - 1; r >= n; r--)
        t2 = e[r].create(null, R.from(t2));
      return t2;
    }
    function ah(t2, e, n, r, o) {
      if (o < t2.length && o < e.length && t2[o] == e[o]) {
        let i = ah(t2, e, n, r.lastChild, o + 1);
        if (i)
          return r.copy(r.content.replaceChild(r.childCount - 1, i));
        if (r.contentMatchAt(r.childCount).matchType(o == t2.length - 1 ? n.type : t2[o + 1]))
          return r.copy(r.content.append(R.from(sh(n, t2, o + 1))));
      }
    }
    function lh(t2, e) {
      if (e == 0)
        return t2;
      let n = t2.content.replaceChild(t2.childCount - 1, lh(t2.lastChild, e - 1)), r = t2.contentMatchAt(t2.childCount).fillBefore(R.empty, true);
      return t2.copy(n.append(r));
    }
    function Xl(t2, e, n, r, o, i) {
      let s = e < 0 ? t2.firstChild : t2.lastChild, a = s.content;
      return t2.childCount > 1 && (i = 0), o < r - 1 && (a = Xl(a, e, n, r, o + 1, i)), o >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(R.empty, true))), t2.replaceChild(e < 0 ? 0 : t2.childCount - 1, s.copy(a));
    }
    function kd(t2, e, n) {
      return e < t2.openStart && (t2 = new K(Xl(t2.content, -1, e, t2.openStart, 0, t2.openEnd), e, t2.openEnd)), n < t2.openEnd && (t2 = new K(Xl(t2.content, 1, n, t2.openEnd, 0, 0), t2.openStart, n)), t2;
    }
    const ch = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    let wd = null;
    function uh() {
      return wd || (wd = document.implementation.createHTMLDocument("title"));
    }
    let ul = null;
    function Qy(t2) {
      let e = window.trustedTypes;
      return e ? (ul || (ul = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), ul.createHTML(t2)) : t2;
    }
    function ev(t2) {
      let e = /^(\s*<meta [^>]*>)*/.exec(t2);
      e && (t2 = t2.slice(e[0].length));
      let n = uh().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t2), o;
      if ((o = r && ch[r[1].toLowerCase()]) && (t2 = o.map((i) => "<" + i + ">").join("") + t2 + o.map((i) => "</" + i + ">").reverse().join("")), n.innerHTML = Qy(t2), o)
        for (let i = 0; i < o.length; i++)
          n = n.querySelector(o[i]) || n;
      return n;
    }
    function tv(t2) {
      let e = t2.querySelectorAll(zt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t2.ownerDocument.createTextNode(" "), r);
      }
    }
    function nv(t2, e) {
      if (!t2.size)
        return t2;
      let n = t2.content.firstChild.type.schema, r;
      try {
        r = JSON.parse(e);
      } catch {
        return t2;
      }
      let { content: o, openStart: i, openEnd: s } = t2;
      for (let a = r.length - 2; a >= 0; a -= 2) {
        let l = n.nodes[r[a]];
        if (!l || l.hasRequiredAttrs())
          break;
        o = R.from(l.create(r[a + 1], o)), i++, s++;
      }
      return new K(o, i, s);
    }
    const Yt = {}, Jt = {}, rv = { touchstart: true, touchmove: true };
    class ov {
      constructor() {
        this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
      }
    }
    function iv(t2) {
      for (let e in Yt) {
        let n = Yt[e];
        t2.dom.addEventListener(e, t2.input.eventHandlers[e] = (r) => {
          av(t2, r) && !Ic(t2, r) && (t2.editable || !(r.type in Jt)) && n(t2, r);
        }, rv[e] ? { passive: true } : void 0);
      }
      jt && t2.dom.addEventListener("input", () => null), Zl(t2);
    }
    function Nr(t2, e) {
      t2.input.lastSelectionOrigin = e, t2.input.lastSelectionTime = Date.now();
    }
    function sv(t2) {
      t2.domObserver.stop();
      for (let e in t2.input.eventHandlers)
        t2.dom.removeEventListener(e, t2.input.eventHandlers[e]);
      clearTimeout(t2.input.composingTimeout), clearTimeout(t2.input.lastIOSEnterFallbackTimeout);
    }
    function Zl(t2) {
      t2.someProp("handleDOMEvents", (e) => {
        for (let n in e)
          t2.input.eventHandlers[n] || t2.dom.addEventListener(n, t2.input.eventHandlers[n] = (r) => Ic(t2, r));
      });
    }
    function Ic(t2, e) {
      return t2.someProp("handleDOMEvents", (n) => {
        let r = n[e.type];
        return r ? r(t2, e) || e.defaultPrevented : false;
      });
    }
    function av(t2, e) {
      if (!e.bubbles)
        return true;
      if (e.defaultPrevented)
        return false;
      for (let n = e.target; n != t2.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
          return false;
      return true;
    }
    function lv(t2, e) {
      !Ic(t2, e) && Yt[e.type] && (t2.editable || !(e.type in Jt)) && Yt[e.type](t2, e);
    }
    Jt.keydown = (t2, e) => {
      let n = e;
      if (t2.input.shiftKey = n.keyCode == 16 || n.shiftKey, !ph(t2, n) && (t2.input.lastKeyCode = n.keyCode, t2.input.lastKeyCodeTime = Date.now(), !(lr && zt && n.keyCode == 13)))
        if (n.keyCode != 229 && t2.domObserver.forceFlush(), Io && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
          let r = Date.now();
          t2.input.lastIOSEnter = r, t2.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            t2.input.lastIOSEnter == r && (t2.someProp("handleKeyDown", (o) => o(t2, qr(13, "Enter"))), t2.input.lastIOSEnter = 0);
          }, 200);
        } else t2.someProp("handleKeyDown", (r) => r(t2, n)) || Jy(t2, n) ? n.preventDefault() : Nr(t2, "key");
    };
    Jt.keyup = (t2, e) => {
      e.keyCode == 16 && (t2.input.shiftKey = false);
    };
    Jt.keypress = (t2, e) => {
      let n = e;
      if (ph(t2, n) || !n.charCode || n.ctrlKey && !n.altKey || yn && n.metaKey)
        return;
      if (t2.someProp("handleKeyPress", (o) => o(t2, n))) {
        n.preventDefault();
        return;
      }
      let r = t2.state.selection;
      if (!(r instanceof ie) || !r.$from.sameParent(r.$to)) {
        let o = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(o) && !t2.someProp("handleTextInput", (i) => i(t2, r.$from.pos, r.$to.pos, o)) && t2.dispatch(t2.state.tr.insertText(o).scrollIntoView()), n.preventDefault();
      }
    };
    function Ia(t2) {
      return { left: t2.clientX, top: t2.clientY };
    }
    function cv(t2, e) {
      let n = e.x - t2.clientX, r = e.y - t2.clientY;
      return n * n + r * r < 100;
    }
    function Dc(t2, e, n, r, o) {
      if (r == -1)
        return false;
      let i = t2.state.doc.resolve(r);
      for (let s = i.depth + 1; s > 0; s--)
        if (t2.someProp(e, (a) => s > i.depth ? a(t2, n, i.nodeAfter, i.before(s), o, true) : a(t2, n, i.node(s), i.before(s), o, false)))
          return true;
      return false;
    }
    function Ao(t2, e, n) {
      if (t2.focused || t2.focus(), t2.state.selection.eq(e))
        return;
      let r = t2.state.tr.setSelection(e);
      r.setMeta("pointer", true), t2.dispatch(r);
    }
    function uv(t2, e) {
      if (e == -1)
        return false;
      let n = t2.state.doc.resolve(e), r = n.nodeAfter;
      return r && r.isAtom && re.isSelectable(r) ? (Ao(t2, new re(n)), true) : false;
    }
    function dv(t2, e) {
      if (e == -1)
        return false;
      let n = t2.state.selection, r, o;
      n instanceof re && (r = n.node);
      let i = t2.state.doc.resolve(e);
      for (let s = i.depth + 1; s > 0; s--) {
        let a = s > i.depth ? i.nodeAfter : i.node(s);
        if (re.isSelectable(a)) {
          r && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? o = i.before(n.$from.depth) : o = i.before(s);
          break;
        }
      }
      return o != null ? (Ao(t2, re.create(t2.state.doc, o)), true) : false;
    }
    function pv(t2, e, n, r, o) {
      return Dc(t2, "handleClickOn", e, n, r) || t2.someProp("handleClick", (i) => i(t2, e, r)) || (o ? dv(t2, n) : uv(t2, n));
    }
    function fv(t2, e, n, r) {
      return Dc(t2, "handleDoubleClickOn", e, n, r) || t2.someProp("handleDoubleClick", (o) => o(t2, e, r));
    }
    function hv(t2, e, n, r) {
      return Dc(t2, "handleTripleClickOn", e, n, r) || t2.someProp("handleTripleClick", (o) => o(t2, e, r)) || mv(t2, n, r);
    }
    function mv(t2, e, n) {
      if (n.button != 0)
        return false;
      let r = t2.state.doc;
      if (e == -1)
        return r.inlineContent ? (Ao(t2, ie.create(r, 0, r.content.size)), true) : false;
      let o = r.resolve(e);
      for (let i = o.depth + 1; i > 0; i--) {
        let s = i > o.depth ? o.nodeAfter : o.node(i), a = o.before(i);
        if (s.inlineContent)
          Ao(t2, ie.create(r, a + 1, a + 1 + s.content.size));
        else if (re.isSelectable(s))
          Ao(t2, re.create(r, a));
        else
          continue;
        return true;
      }
    }
    function Lc(t2) {
      return Fs(t2);
    }
    const dh = yn ? "metaKey" : "ctrlKey";
    Yt.mousedown = (t2, e) => {
      let n = e;
      t2.input.shiftKey = n.shiftKey;
      let r = Lc(t2), o = Date.now(), i = "singleClick";
      o - t2.input.lastClick.time < 500 && cv(n, t2.input.lastClick) && !n[dh] && (t2.input.lastClick.type == "singleClick" ? i = "doubleClick" : t2.input.lastClick.type == "doubleClick" && (i = "tripleClick")), t2.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i };
      let s = t2.posAtCoords(Ia(n));
      s && (i == "singleClick" ? (t2.input.mouseDown && t2.input.mouseDown.done(), t2.input.mouseDown = new gv(t2, s, n, !!r)) : (i == "doubleClick" ? fv : hv)(t2, s.pos, s.inside, n) ? n.preventDefault() : Nr(t2, "pointer"));
    };
    class gv {
      constructor(e, n, r, o) {
        this.view = e, this.pos = n, this.event = r, this.flushed = o, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[dh], this.allowDefault = r.shiftKey;
        let i, s;
        if (n.inside > -1)
          i = e.state.doc.nodeAt(n.inside), s = n.inside;
        else {
          let u = e.state.doc.resolve(n.pos);
          i = u.parent, s = u.depth ? u.before() : 0;
        }
        const a = o ? null : r.target, l = a ? e.docView.nearestDesc(a, true) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let { selection: c2 } = e.state;
        (r.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== false || c2 instanceof re && c2.from <= s && c2.to > s) && (this.mightDrag = {
          node: i,
          pos: s,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && In && !this.target.hasAttribute("contentEditable"))
        }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
          this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
        }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Nr(e, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => dr(this.view)), this.view.input.mouseDown = null;
      }
      up(e) {
        if (this.done(), !this.view.dom.contains(e.target))
          return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Ia(e))), this.updateAllowDefault(e), this.allowDefault || !n ? Nr(this.view, "pointer") : pv(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        jt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        zt && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Ao(this.view, ue.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : Nr(this.view, "pointer");
      }
      move(e) {
        this.updateAllowDefault(e), Nr(this.view, "pointer"), e.buttons == 0 && this.done();
      }
      updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
      }
    }
    Yt.touchstart = (t2) => {
      t2.input.lastTouch = Date.now(), Lc(t2), Nr(t2, "pointer");
    };
    Yt.touchmove = (t2) => {
      t2.input.lastTouch = Date.now(), Nr(t2, "pointer");
    };
    Yt.contextmenu = (t2) => Lc(t2);
    function ph(t2, e) {
      return t2.composing ? true : jt && Math.abs(e.timeStamp - t2.input.compositionEndedAt) < 500 ? (t2.input.compositionEndedAt = -2e8, true) : false;
    }
    const bv = lr ? 5e3 : -1;
    Jt.compositionstart = Jt.compositionupdate = (t2) => {
      if (!t2.composing) {
        t2.domObserver.flush();
        let { state: e } = t2, n = e.selection.$to;
        if (e.selection instanceof ie && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === false)))
          t2.markCursor = t2.state.storedMarks || n.marks(), Fs(t2, true), t2.markCursor = null;
        else if (Fs(t2, !e.selection.empty), In && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
          let r = t2.domSelectionRange();
          for (let o = r.focusNode, i = r.focusOffset; o && o.nodeType == 1 && i != 0; ) {
            let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
            if (!s)
              break;
            if (s.nodeType == 3) {
              let a = t2.domSelection();
              a && a.collapse(s, s.nodeValue.length);
              break;
            } else
              o = s, i = -1;
          }
        }
        t2.input.composing = true;
      }
      fh(t2, bv);
    };
    Jt.compositionend = (t2, e) => {
      t2.composing && (t2.input.composing = false, t2.input.compositionEndedAt = e.timeStamp, t2.input.compositionPendingChanges = t2.domObserver.pendingRecords().length ? t2.input.compositionID : 0, t2.input.compositionNode = null, t2.input.compositionPendingChanges && Promise.resolve().then(() => t2.domObserver.flush()), t2.input.compositionID++, fh(t2, 20));
    };
    function fh(t2, e) {
      clearTimeout(t2.input.composingTimeout), e > -1 && (t2.input.composingTimeout = setTimeout(() => Fs(t2), e));
    }
    function hh(t2) {
      for (t2.composing && (t2.input.composing = false, t2.input.compositionEndedAt = vv()); t2.input.compositionNodes.length > 0; )
        t2.input.compositionNodes.pop().markParentsDirty();
    }
    function yv(t2) {
      let e = t2.domSelectionRange();
      if (!e.focusNode)
        return null;
      let n = uy(e.focusNode, e.focusOffset), r = dy(e.focusNode, e.focusOffset);
      if (n && r && n != r) {
        let o = r.pmViewDesc, i = t2.domObserver.lastChangedTextNode;
        if (n == i || r == i)
          return i;
        if (!o || !o.isText(r.nodeValue))
          return r;
        if (t2.input.compositionNode == r) {
          let s = n.pmViewDesc;
          if (!(!s || !s.isText(n.nodeValue)))
            return r;
        }
      }
      return n || r;
    }
    function vv() {
      let t2 = document.createEvent("Event");
      return t2.initEvent("event", true, true), t2.timeStamp;
    }
    function Fs(t2, e = false) {
      if (!(lr && t2.domObserver.flushingSoon >= 0)) {
        if (t2.domObserver.forceFlush(), hh(t2), e || t2.docView && t2.docView.dirty) {
          let n = Ac(t2);
          return n && !n.eq(t2.state.selection) ? t2.dispatch(t2.state.tr.setSelection(n)) : (t2.markCursor || e) && !t2.state.selection.empty ? t2.dispatch(t2.state.tr.deleteSelection()) : t2.updateState(t2.state), true;
        }
        return false;
      }
    }
    function Ev(t2, e) {
      if (!t2.dom.parentNode)
        return;
      let n = t2.dom.parentNode.appendChild(document.createElement("div"));
      n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let r = getSelection(), o = document.createRange();
      o.selectNodeContents(e), t2.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
        n.parentNode && n.parentNode.removeChild(n), t2.focus();
      }, 50);
    }
    const ki = en && Ir < 15 || Io && gy < 604;
    Yt.copy = Jt.cut = (t2, e) => {
      let n = e, r = t2.state.selection, o = n.type == "cut";
      if (r.empty)
        return;
      let i = ki ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = Rc(t2, s);
      i ? (n.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : Ev(t2, a), o && t2.dispatch(t2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function kv(t2) {
      return t2.openStart == 0 && t2.openEnd == 0 && t2.content.childCount == 1 ? t2.content.firstChild : null;
    }
    function wv(t2, e) {
      if (!t2.dom.parentNode)
        return;
      let n = t2.input.shiftKey || t2.state.selection.$from.parent.type.spec.code, r = t2.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
      n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
      let o = t2.input.shiftKey && t2.input.lastKeyCode != 45;
      setTimeout(() => {
        t2.focus(), r.parentNode && r.parentNode.removeChild(r), n ? wi(t2, r.value, null, o, e) : wi(t2, r.textContent, r.innerHTML, o, e);
      }, 50);
    }
    function wi(t2, e, n, r, o) {
      let i = ih(t2, e, n, r, t2.state.selection.$from);
      if (t2.someProp("handlePaste", (l) => l(t2, o, i || K.empty)))
        return true;
      if (!i)
        return false;
      let s = kv(i), a = s ? t2.state.tr.replaceSelectionWith(s, r) : t2.state.tr.replaceSelection(i);
      return t2.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
    }
    function mh(t2) {
      let e = t2.getData("text/plain") || t2.getData("Text");
      if (e)
        return e;
      let n = t2.getData("text/uri-list");
      return n ? n.replace(/\r?\n/g, " ") : "";
    }
    Jt.paste = (t2, e) => {
      let n = e;
      if (t2.composing && !lr)
        return;
      let r = ki ? null : n.clipboardData, o = t2.input.shiftKey && t2.input.lastKeyCode != 45;
      r && wi(t2, mh(r), r.getData("text/html"), o, n) ? n.preventDefault() : wv(t2, n);
    };
    class gh {
      constructor(e, n, r) {
        this.slice = e, this.move = n, this.node = r;
      }
    }
    const bh = yn ? "altKey" : "ctrlKey";
    Yt.dragstart = (t2, e) => {
      let n = e, r = t2.input.mouseDown;
      if (r && r.done(), !n.dataTransfer)
        return;
      let o = t2.state.selection, i = o.empty ? null : t2.posAtCoords(Ia(n)), s;
      if (!(i && i.pos >= o.from && i.pos <= (o instanceof re ? o.to - 1 : o.to))) {
        if (r && r.mightDrag)
          s = re.create(t2.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
          let d = t2.docView.nearestDesc(n.target, true);
          d && d.node.type.spec.draggable && d != t2.docView && (s = re.create(t2.state.doc, d.posBefore));
        }
      }
      let a = (s || t2.state.selection).content(), { dom: l, text: c2, slice: u } = Rc(t2, a);
      (!n.dataTransfer.files.length || !zt || Vf > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(ki ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", ki || n.dataTransfer.setData("text/plain", c2), t2.dragging = new gh(u, !n[bh], s);
    };
    Yt.dragend = (t2) => {
      let e = t2.dragging;
      window.setTimeout(() => {
        t2.dragging == e && (t2.dragging = null);
      }, 50);
    };
    Jt.dragover = Jt.dragenter = (t2, e) => e.preventDefault();
    Jt.drop = (t2, e) => {
      let n = e, r = t2.dragging;
      if (t2.dragging = null, !n.dataTransfer)
        return;
      let o = t2.posAtCoords(Ia(n));
      if (!o)
        return;
      let i = t2.state.doc.resolve(o.pos), s = r && r.slice;
      s ? t2.someProp("transformPasted", (h2) => {
        s = h2(s, t2);
      }) : s = ih(t2, mh(n.dataTransfer), ki ? null : n.dataTransfer.getData("text/html"), false, i);
      let a = !!(r && !n[bh]);
      if (t2.someProp("handleDrop", (h2) => h2(t2, n, s || K.empty, a))) {
        n.preventDefault();
        return;
      }
      if (!s)
        return;
      n.preventDefault();
      let l = s ? Df(t2.state.doc, i.pos, s) : i.pos;
      l == null && (l = i.pos);
      let c2 = t2.state.tr;
      if (a) {
        let { node: h2 } = r;
        h2 ? h2.replace(c2) : c2.deleteSelection();
      }
      let u = c2.mapping.map(l), d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, p2 = c2.doc;
      if (d ? c2.replaceRangeWith(u, u, s.content.firstChild) : c2.replaceRange(u, u, s), c2.doc.eq(p2))
        return;
      let f = c2.doc.resolve(u);
      if (d && re.isSelectable(s.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(s.content.firstChild))
        c2.setSelection(new re(f));
      else {
        let h2 = c2.mapping.map(l);
        c2.mapping.maps[c2.mapping.maps.length - 1].forEach((m, g, b, E) => h2 = E), c2.setSelection(Mc(t2, f, c2.doc.resolve(h2)));
      }
      t2.focus(), t2.dispatch(c2.setMeta("uiEvent", "drop"));
    };
    Yt.focus = (t2) => {
      t2.input.lastFocus = Date.now(), t2.focused || (t2.domObserver.stop(), t2.dom.classList.add("ProseMirror-focused"), t2.domObserver.start(), t2.focused = true, setTimeout(() => {
        t2.docView && t2.hasFocus() && !t2.domObserver.currentSelection.eq(t2.domSelectionRange()) && dr(t2);
      }, 20));
    };
    Yt.blur = (t2, e) => {
      let n = e;
      t2.focused && (t2.domObserver.stop(), t2.dom.classList.remove("ProseMirror-focused"), t2.domObserver.start(), n.relatedTarget && t2.dom.contains(n.relatedTarget) && t2.domObserver.currentSelection.clear(), t2.focused = false);
    };
    Yt.beforeinput = (t2, e) => {
      if (zt && lr && e.inputType == "deleteContentBackward") {
        t2.domObserver.flushSoon();
        let { domChangeCount: r } = t2.input;
        setTimeout(() => {
          if (t2.input.domChangeCount != r || (t2.dom.blur(), t2.focus(), t2.someProp("handleKeyDown", (i) => i(t2, qr(8, "Backspace")))))
            return;
          let { $cursor: o } = t2.state.selection;
          o && o.pos > 0 && t2.dispatch(t2.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let t2 in Jt)
      Yt[t2] = Jt[t2];
    function _i(t2, e) {
      if (t2 == e)
        return true;
      for (let n in t2)
        if (t2[n] !== e[n])
          return false;
      for (let n in e)
        if (!(n in t2))
          return false;
      return true;
    }
    class zs {
      constructor(e, n) {
        this.toDOM = e, this.spec = n || Qr, this.side = this.spec.side || 0;
      }
      map(e, n, r, o) {
        let { pos: i, deleted: s } = e.mapResult(n.from + o, this.side < 0 ? -1 : 1);
        return s ? null : new ht(i - r, i - r, this);
      }
      valid() {
        return true;
      }
      eq(e) {
        return this == e || e instanceof zs && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && _i(this.spec, e.spec));
      }
      destroy(e) {
        this.spec.destroy && this.spec.destroy(e);
      }
    }
    class Lr {
      constructor(e, n) {
        this.attrs = e, this.spec = n || Qr;
      }
      map(e, n, r, o) {
        let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
        return i >= s ? null : new ht(i, s, this);
      }
      valid(e, n) {
        return n.from < n.to;
      }
      eq(e) {
        return this == e || e instanceof Lr && _i(this.attrs, e.attrs) && _i(this.spec, e.spec);
      }
      static is(e) {
        return e.type instanceof Lr;
      }
      destroy() {
      }
    }
    class Pc {
      constructor(e, n) {
        this.attrs = e, this.spec = n || Qr;
      }
      map(e, n, r, o) {
        let i = e.mapResult(n.from + o, 1);
        if (i.deleted)
          return null;
        let s = e.mapResult(n.to + o, -1);
        return s.deleted || s.pos <= i.pos ? null : new ht(i.pos - r, s.pos - r, this);
      }
      valid(e, n) {
        let { index: r, offset: o } = e.content.findIndex(n.from), i;
        return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
      }
      eq(e) {
        return this == e || e instanceof Pc && _i(this.attrs, e.attrs) && _i(this.spec, e.spec);
      }
      destroy() {
      }
    }
    class ht {
      /**
      @internal
      */
      constructor(e, n, r) {
        this.from = e, this.to = n, this.type = r;
      }
      /**
      @internal
      */
      copy(e, n) {
        return new ht(e, n, this.type);
      }
      /**
      @internal
      */
      eq(e, n = 0) {
        return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
      }
      /**
      @internal
      */
      map(e, n, r) {
        return this.type.map(e, this, n, r);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(e, n, r) {
        return new ht(e, e, new zs(n, r));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(e, n, r, o) {
        return new ht(e, n, new Lr(r, o));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(e, n, r, o) {
        return new ht(e, n, new Pc(r, o));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof Lr;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof zs;
      }
    }
    const ko = [], Qr = {};
    class He {
      /**
      @internal
      */
      constructor(e, n) {
        this.local = e.length ? e : ko, this.children = n.length ? n : ko;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(e, n) {
        return n.length ? Hs(n, e, 0, Qr) : Ft;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(e, n, r) {
        let o = [];
        return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
      }
      findInner(e, n, r, o, i) {
        for (let s = 0; s < this.local.length; s++) {
          let a = this.local[s];
          a.from <= n && a.to >= e && (!i || i(a.spec)) && r.push(a.copy(a.from + o, a.to + o));
        }
        for (let s = 0; s < this.children.length; s += 3)
          if (this.children[s] < n && this.children[s + 1] > e) {
            let a = this.children[s] + 1;
            this.children[s + 2].findInner(e - a, n - a, r, o + a, i);
          }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(e, n, r) {
        return this == Ft || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Qr);
      }
      /**
      @internal
      */
      mapInner(e, n, r, o, i) {
        let s;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a].map(e, r, o);
          l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec);
        }
        return this.children.length ? _v(this.children, s || [], e, n, r, o, i) : s ? new He(s.sort(eo), ko) : Ft;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(e, n) {
        return n.length ? this == Ft ? He.create(e, n) : this.addInner(e, n, 0) : this;
      }
      addInner(e, n, r) {
        let o, i = 0;
        e.forEach((a, l) => {
          let c2 = l + r, u;
          if (u = vh(n, a, c2)) {
            for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
              i += 3;
            o[i] == l ? o[i + 2] = o[i + 2].addInner(a, u, c2 + 1) : o.splice(i, 0, l, l + a.nodeSize, Hs(u, a, c2 + 1, Qr)), i += 3;
          }
        });
        let s = yh(i ? Eh(n) : n, -r);
        for (let a = 0; a < s.length; a++)
          s[a].type.valid(e, s[a]) || s.splice(a--, 1);
        return new He(s.length ? this.local.concat(s).sort(eo) : this.local, o || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(e) {
        return e.length == 0 || this == Ft ? this : this.removeInner(e, 0);
      }
      removeInner(e, n) {
        let r = this.children, o = this.local;
        for (let i = 0; i < r.length; i += 3) {
          let s, a = r[i] + n, l = r[i + 1] + n;
          for (let u = 0, d; u < e.length; u++)
            (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (s || (s = [])).push(d));
          if (!s)
            continue;
          r == this.children && (r = this.children.slice());
          let c2 = r[i + 2].removeInner(s, a + 1);
          c2 != Ft ? r[i + 2] = c2 : (r.splice(i, 3), i -= 3);
        }
        if (o.length) {
          for (let i = 0, s; i < e.length; i++)
            if (s = e[i])
              for (let a = 0; a < o.length; a++)
                o[a].eq(s, n) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
        }
        return r == this.children && o == this.local ? this : o.length || r.length ? new He(o, r) : Ft;
      }
      forChild(e, n) {
        if (this == Ft)
          return this;
        if (n.isLeaf)
          return He.empty;
        let r, o;
        for (let a = 0; a < this.children.length; a += 3)
          if (this.children[a] >= e) {
            this.children[a] == e && (r = this.children[a + 2]);
            break;
          }
        let i = e + 1, s = i + n.content.size;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a];
          if (l.from < s && l.to > i && l.type instanceof Lr) {
            let c2 = Math.max(i, l.from) - i, u = Math.min(s, l.to) - i;
            c2 < u && (o || (o = [])).push(l.copy(c2, u));
          }
        }
        if (o) {
          let a = new He(o.sort(eo), ko);
          return r ? new Sr([a, r]) : a;
        }
        return r || Ft;
      }
      /**
      @internal
      */
      eq(e) {
        if (this == e)
          return true;
        if (!(e instanceof He) || this.local.length != e.local.length || this.children.length != e.children.length)
          return false;
        for (let n = 0; n < this.local.length; n++)
          if (!this.local[n].eq(e.local[n]))
            return false;
        for (let n = 0; n < this.children.length; n += 3)
          if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(e) {
        return Bc(this.localsInner(e));
      }
      /**
      @internal
      */
      localsInner(e) {
        if (this == Ft)
          return ko;
        if (e.inlineContent || !this.local.some(Lr.is))
          return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
          this.local[r].type instanceof Lr || n.push(this.local[r]);
        return n;
      }
      forEachSet(e) {
        e(this);
      }
    }
    He.empty = new He([], []);
    He.removeOverlap = Bc;
    const Ft = He.empty;
    class Sr {
      constructor(e) {
        this.members = e;
      }
      map(e, n) {
        const r = this.members.map((o) => o.map(e, n, Qr));
        return Sr.from(r);
      }
      forChild(e, n) {
        if (n.isLeaf)
          return He.empty;
        let r = [];
        for (let o = 0; o < this.members.length; o++) {
          let i = this.members[o].forChild(e, n);
          i != Ft && (i instanceof Sr ? r = r.concat(i.members) : r.push(i));
        }
        return Sr.from(r);
      }
      eq(e) {
        if (!(e instanceof Sr) || e.members.length != this.members.length)
          return false;
        for (let n = 0; n < this.members.length; n++)
          if (!this.members[n].eq(e.members[n]))
            return false;
        return true;
      }
      locals(e) {
        let n, r = true;
        for (let o = 0; o < this.members.length; o++) {
          let i = this.members[o].localsInner(e);
          if (i.length)
            if (!n)
              n = i;
            else {
              r && (n = n.slice(), r = false);
              for (let s = 0; s < i.length; s++)
                n.push(i[s]);
            }
        }
        return n ? Bc(r ? n : n.sort(eo)) : ko;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(e) {
        switch (e.length) {
          case 0:
            return Ft;
          case 1:
            return e[0];
          default:
            return new Sr(e.every((n) => n instanceof He) ? e : e.reduce((n, r) => n.concat(r instanceof He ? r : r.members), []));
        }
      }
      forEachSet(e) {
        for (let n = 0; n < this.members.length; n++)
          this.members[n].forEachSet(e);
      }
    }
    function _v(t2, e, n, r, o, i, s) {
      let a = t2.slice();
      for (let c2 = 0, u = i; c2 < n.maps.length; c2++) {
        let d = 0;
        n.maps[c2].forEach((p2, f, h2, m) => {
          let g = m - h2 - (f - p2);
          for (let b = 0; b < a.length; b += 3) {
            let E = a[b + 1];
            if (E < 0 || p2 > E + u - d)
              continue;
            let _ = a[b] + u - d;
            f >= _ ? a[b + 1] = p2 <= _ ? -2 : -1 : p2 >= u && g && (a[b] += g, a[b + 1] += g);
          }
          d += g;
        }), u = n.maps[c2].map(u, -1);
      }
      let l = false;
      for (let c2 = 0; c2 < a.length; c2 += 3)
        if (a[c2 + 1] < 0) {
          if (a[c2 + 1] == -2) {
            l = true, a[c2 + 1] = -1;
            continue;
          }
          let u = n.map(t2[c2] + i), d = u - o;
          if (d < 0 || d >= r.content.size) {
            l = true;
            continue;
          }
          let p2 = n.map(t2[c2 + 1] + i, -1), f = p2 - o, { index: h2, offset: m } = r.content.findIndex(d), g = r.maybeChild(h2);
          if (g && m == d && m + g.nodeSize == f) {
            let b = a[c2 + 2].mapInner(n, g, u + 1, t2[c2] + i + 1, s);
            b != Ft ? (a[c2] = d, a[c2 + 1] = f, a[c2 + 2] = b) : (a[c2 + 1] = -2, l = true);
          } else
            l = true;
        }
      if (l) {
        let c2 = Sv(a, t2, e, n, o, i, s), u = Hs(c2, r, 0, s);
        e = u.local;
        for (let d = 0; d < a.length; d += 3)
          a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
        for (let d = 0, p2 = 0; d < u.children.length; d += 3) {
          let f = u.children[d];
          for (; p2 < a.length && a[p2] < f; )
            p2 += 3;
          a.splice(p2, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
        }
      }
      return new He(e.sort(eo), a);
    }
    function yh(t2, e) {
      if (!e || !t2.length)
        return t2;
      let n = [];
      for (let r = 0; r < t2.length; r++) {
        let o = t2[r];
        n.push(new ht(o.from + e, o.to + e, o.type));
      }
      return n;
    }
    function Sv(t2, e, n, r, o, i, s) {
      function a(l, c2) {
        for (let u = 0; u < l.local.length; u++) {
          let d = l.local[u].map(r, o, c2);
          d ? n.push(d) : s.onRemove && s.onRemove(l.local[u].spec);
        }
        for (let u = 0; u < l.children.length; u += 3)
          a(l.children[u + 2], l.children[u] + c2 + 1);
      }
      for (let l = 0; l < t2.length; l += 3)
        t2[l + 1] == -1 && a(t2[l + 2], e[l] + i + 1);
      return n;
    }
    function vh(t2, e, n) {
      if (e.isLeaf)
        return null;
      let r = n + e.nodeSize, o = null;
      for (let i = 0, s; i < t2.length; i++)
        (s = t2[i]) && s.from > n && s.to < r && ((o || (o = [])).push(s), t2[i] = null);
      return o;
    }
    function Eh(t2) {
      let e = [];
      for (let n = 0; n < t2.length; n++)
        t2[n] != null && e.push(t2[n]);
      return e;
    }
    function Hs(t2, e, n, r) {
      let o = [], i = false;
      e.forEach((a, l) => {
        let c2 = vh(t2, a, l + n);
        if (c2) {
          i = true;
          let u = Hs(c2, a, n + l + 1, r);
          u != Ft && o.push(l, l + a.nodeSize, u);
        }
      });
      let s = yh(i ? Eh(t2) : t2, -n).sort(eo);
      for (let a = 0; a < s.length; a++)
        s[a].type.valid(e, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
      return s.length || o.length ? new He(s, o) : Ft;
    }
    function eo(t2, e) {
      return t2.from - e.from || t2.to - e.to;
    }
    function Bc(t2) {
      let e = t2;
      for (let n = 0; n < e.length - 1; n++) {
        let r = e[n];
        if (r.from != r.to)
          for (let o = n + 1; o < e.length; o++) {
            let i = e[o];
            if (i.from == r.from) {
              i.to != r.to && (e == t2 && (e = t2.slice()), e[o] = i.copy(i.from, r.to), _d(e, o + 1, i.copy(r.to, i.to)));
              continue;
            } else {
              i.from < r.to && (e == t2 && (e = t2.slice()), e[n] = r.copy(r.from, i.from), _d(e, o, r.copy(i.from, r.to)));
              break;
            }
          }
      }
      return e;
    }
    function _d(t2, e, n) {
      for (; e < t2.length && eo(n, t2[e]) > 0; )
        e++;
      t2.splice(e, 0, n);
    }
    function dl(t2) {
      let e = [];
      return t2.someProp("decorations", (n) => {
        let r = n(t2.state);
        r && r != Ft && e.push(r);
      }), t2.cursorWrapper && e.push(He.create(t2.state.doc, [t2.cursorWrapper.deco])), Sr.from(e);
    }
    const Cv = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    }, xv = en && Ir <= 11;
    class Tv {
      constructor() {
        this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
      }
      set(e) {
        this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
      }
    }
    class Ov {
      constructor(e, n) {
        this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Tv(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
          for (let o = 0; o < r.length; o++)
            this.queue.push(r[o]);
          en && Ir <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush();
        }), xv && (this.onCharData = (r) => {
          this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
        }), this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1, this.flush();
        }, 20));
      }
      forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
      start() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Cv)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let e = this.observer.takeRecords();
          if (e.length) {
            for (let n = 0; n < e.length; n++)
              this.queue.push(e[n]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (md(this.view)) {
          if (this.suppressingSelectionUpdates)
            return dr(this.view);
          if (en && Ir <= 11 && !this.view.state.selection.empty) {
            let e = this.view.domSelectionRange();
            if (e.focusNode && so(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(e) {
        if (!e.focusNode)
          return true;
        let n = /* @__PURE__ */ new Set(), r;
        for (let i = e.focusNode; i; i = Ei(i))
          n.add(i);
        for (let i = e.anchorNode; i; i = Ei(i))
          if (n.has(i)) {
            r = i;
            break;
          }
        let o = r && this.view.docView.nearestDesc(r);
        if (o && o.ignoreMutation({
          type: "selection",
          target: r.nodeType == 3 ? r.parentNode : r
        }))
          return this.setCurSelection(), true;
      }
      pendingRecords() {
        if (this.observer)
          for (let e of this.observer.takeRecords())
            this.queue.push(e);
        return this.queue;
      }
      flush() {
        let { view: e } = this;
        if (!e.docView || this.flushingSoon > -1)
          return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && md(e) && !this.ignoreSelectionChange(r), i = -1, s = -1, a = false, l = [];
        if (e.editable)
          for (let u = 0; u < n.length; u++) {
            let d = this.registerMutation(n[u], l);
            d && (i = i < 0 ? d.from : Math.min(d.from, i), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (a = true));
          }
        if (In && l.length) {
          let u = l.filter((d) => d.nodeName == "BR");
          if (u.length == 2) {
            let [d, p2] = u;
            d.parentNode && d.parentNode.parentNode == p2.parentNode ? p2.remove() : d.remove();
          } else {
            let { focusNode: d } = this.currentSelection;
            for (let p2 of u) {
              let f = p2.parentNode;
              f && f.nodeName == "LI" && (!d || Mv(e, d) != f) && p2.remove();
            }
          }
        }
        let c2 = null;
        i < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ma(r) && (c2 = Ac(e)) && c2.eq(ue.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, dr(e), this.currentSelection.set(r)) : (i > -1 || o) && (i > -1 && (e.docView.markDirty(i, s), Nv(e)), this.handleDOMChange(i, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || dr(e), this.currentSelection.set(r));
      }
      registerMutation(e, n) {
        if (n.indexOf(e.target) > -1)
          return null;
        let r = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
          return null;
        if (e.type == "childList") {
          for (let u = 0; u < e.addedNodes.length; u++) {
            let d = e.addedNodes[u];
            n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
          }
          if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
            return { from: r.posBefore, to: r.posAfter };
          let o = e.previousSibling, i = e.nextSibling;
          if (en && Ir <= 11 && e.addedNodes.length)
            for (let u = 0; u < e.addedNodes.length; u++) {
              let { previousSibling: d, nextSibling: p2 } = e.addedNodes[u];
              (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (o = d), (!p2 || Array.prototype.indexOf.call(e.addedNodes, p2) < 0) && (i = p2);
            }
          let s = o && o.parentNode == e.target ? Dt(o) + 1 : 0, a = r.localPosFromDOM(e.target, s, -1), l = i && i.parentNode == e.target ? Dt(i) : e.target.childNodes.length, c2 = r.localPosFromDOM(e.target, l, 1);
          return { from: a, to: c2 };
        } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
          from: r.posAtStart,
          to: r.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: e.target.nodeValue == e.oldValue
        });
      }
    }
    let Sd = /* @__PURE__ */ new WeakMap(), Cd = false;
    function Nv(t2) {
      if (!Sd.has(t2) && (Sd.set(t2, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t2.dom).whiteSpace) !== -1)) {
        if (t2.requiresGeckoHackNode = In, Cd)
          return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Cd = true;
      }
    }
    function xd(t2, e) {
      let n = e.startContainer, r = e.startOffset, o = e.endContainer, i = e.endOffset, s = t2.domAtPos(t2.state.selection.anchor);
      return so(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]), { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i };
    }
    function Av(t2, e) {
      if (e.getComposedRanges) {
        let o = e.getComposedRanges(t2.root)[0];
        if (o)
          return xd(t2, o);
      }
      let n;
      function r(o) {
        o.preventDefault(), o.stopImmediatePropagation(), n = o.getTargetRanges()[0];
      }
      return t2.dom.addEventListener("beforeinput", r, true), document.execCommand("indent"), t2.dom.removeEventListener("beforeinput", r, true), n ? xd(t2, n) : null;
    }
    function Mv(t2, e) {
      for (let n = e.parentNode; n && n != t2.dom; n = n.parentNode) {
        let r = t2.docView.nearestDesc(n, true);
        if (r && r.node.isBlock)
          return n;
      }
      return null;
    }
    function Rv(t2, e, n) {
      let { node: r, fromOffset: o, toOffset: i, from: s, to: a } = t2.docView.parseRange(e, n), l = t2.domSelectionRange(), c2, u = l.anchorNode;
      if (u && t2.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c2 = [{ node: u, offset: l.anchorOffset }], Ma(l) || c2.push({ node: l.focusNode, offset: l.focusOffset })), zt && t2.input.lastKeyCode === 8)
        for (let g = i; g > o; g--) {
          let b = r.childNodes[g - 1], E = b.pmViewDesc;
          if (b.nodeName == "BR" && !E) {
            i = g;
            break;
          }
          if (!E || E.size)
            break;
        }
      let d = t2.state.doc, p2 = t2.someProp("domParser") || Rr.fromSchema(t2.state.schema), f = d.resolve(s), h2 = null, m = p2.parse(r, {
        topNode: f.parent,
        topMatch: f.parent.contentMatchAt(f.index()),
        topOpen: true,
        from: o,
        to: i,
        preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: c2,
        ruleFromNode: Iv,
        context: f
      });
      if (c2 && c2[0].pos != null) {
        let g = c2[0].pos, b = c2[1] && c2[1].pos;
        b == null && (b = g), h2 = { anchor: g + s, head: b + s };
      }
      return { doc: m, sel: h2, from: s, to: a };
    }
    function Iv(t2) {
      let e = t2.pmViewDesc;
      if (e)
        return e.parseRule();
      if (t2.nodeName == "BR" && t2.parentNode) {
        if (jt && /^(ul|ol)$/i.test(t2.parentNode.nodeName)) {
          let n = document.createElement("div");
          return n.appendChild(document.createElement("li")), { skip: n };
        } else if (t2.parentNode.lastChild == t2 || jt && /^(tr|table)$/i.test(t2.parentNode.nodeName))
          return { ignore: true };
      } else if (t2.nodeName == "IMG" && t2.getAttribute("mark-placeholder"))
        return { ignore: true };
      return null;
    }
    const Dv = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function Lv(t2, e, n, r, o) {
      let i = t2.input.compositionPendingChanges || (t2.composing ? t2.input.compositionID : 0);
      if (t2.input.compositionPendingChanges = 0, e < 0) {
        let L = t2.input.lastSelectionTime > Date.now() - 50 ? t2.input.lastSelectionOrigin : null, W = Ac(t2, L);
        if (W && !t2.state.selection.eq(W)) {
          if (zt && lr && t2.input.lastKeyCode === 13 && Date.now() - 100 < t2.input.lastKeyCodeTime && t2.someProp("handleKeyDown", (de) => de(t2, qr(13, "Enter"))))
            return;
          let te = t2.state.tr.setSelection(W);
          L == "pointer" ? te.setMeta("pointer", true) : L == "key" && te.scrollIntoView(), i && te.setMeta("composition", i), t2.dispatch(te);
        }
        return;
      }
      let s = t2.state.doc.resolve(e), a = s.sharedDepth(n);
      e = s.before(a + 1), n = t2.state.doc.resolve(n).after(a + 1);
      let l = t2.state.selection, c2 = Rv(t2, e, n), u = t2.state.doc, d = u.slice(c2.from, c2.to), p2, f;
      t2.input.lastKeyCode === 8 && Date.now() - 100 < t2.input.lastKeyCodeTime ? (p2 = t2.state.selection.to, f = "end") : (p2 = t2.state.selection.from, f = "start"), t2.input.lastKeyCode = null;
      let h2 = $v(d.content, c2.doc.content, c2.from, p2, f);
      if (h2 && t2.input.domChangeCount++, (Io && t2.input.lastIOSEnter > Date.now() - 225 || lr) && o.some((L) => L.nodeType == 1 && !Dv.test(L.nodeName)) && (!h2 || h2.endA >= h2.endB) && t2.someProp("handleKeyDown", (L) => L(t2, qr(13, "Enter")))) {
        t2.input.lastIOSEnter = 0;
        return;
      }
      if (!h2)
        if (r && l instanceof ie && !l.empty && l.$head.sameParent(l.$anchor) && !t2.composing && !(c2.sel && c2.sel.anchor != c2.sel.head))
          h2 = { start: l.from, endA: l.to, endB: l.to };
        else {
          if (c2.sel) {
            let L = Td(t2, t2.state.doc, c2.sel);
            if (L && !L.eq(t2.state.selection)) {
              let W = t2.state.tr.setSelection(L);
              i && W.setMeta("composition", i), t2.dispatch(W);
            }
          }
          return;
        }
      t2.state.selection.from < t2.state.selection.to && h2.start == h2.endB && t2.state.selection instanceof ie && (h2.start > t2.state.selection.from && h2.start <= t2.state.selection.from + 2 && t2.state.selection.from >= c2.from ? h2.start = t2.state.selection.from : h2.endA < t2.state.selection.to && h2.endA >= t2.state.selection.to - 2 && t2.state.selection.to <= c2.to && (h2.endB += t2.state.selection.to - h2.endA, h2.endA = t2.state.selection.to)), en && Ir <= 11 && h2.endB == h2.start + 1 && h2.endA == h2.start && h2.start > c2.from && c2.doc.textBetween(h2.start - c2.from - 1, h2.start - c2.from + 1) == "  " && (h2.start--, h2.endA--, h2.endB--);
      let m = c2.doc.resolveNoCache(h2.start - c2.from), g = c2.doc.resolveNoCache(h2.endB - c2.from), b = u.resolve(h2.start), E = m.sameParent(g) && m.parent.inlineContent && b.end() >= h2.endA, _;
      if ((Io && t2.input.lastIOSEnter > Date.now() - 225 && (!E || o.some((L) => L.nodeName == "DIV" || L.nodeName == "P")) || !E && m.pos < c2.doc.content.size && !m.sameParent(g) && (_ = ue.findFrom(c2.doc.resolve(m.pos + 1), 1, true)) && _.head == g.pos) && t2.someProp("handleKeyDown", (L) => L(t2, qr(13, "Enter")))) {
        t2.input.lastIOSEnter = 0;
        return;
      }
      if (t2.state.selection.anchor > h2.start && Bv(u, h2.start, h2.endA, m, g) && t2.someProp("handleKeyDown", (L) => L(t2, qr(8, "Backspace")))) {
        lr && zt && t2.domObserver.suppressSelectionUpdates();
        return;
      }
      zt && h2.endB == h2.start && (t2.input.lastChromeDelete = Date.now()), lr && !E && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c2.sel && c2.sel.anchor == c2.sel.head && c2.sel.head == h2.endA && (h2.endB -= 2, g = c2.doc.resolveNoCache(h2.endB - c2.from), setTimeout(() => {
        t2.someProp("handleKeyDown", function(L) {
          return L(t2, qr(13, "Enter"));
        });
      }, 20));
      let v = h2.start, T = h2.endA, S, F, V;
      if (E) {
        if (m.pos == g.pos)
          en && Ir <= 11 && m.parentOffset == 0 && (t2.domObserver.suppressSelectionUpdates(), setTimeout(() => dr(t2), 20)), S = t2.state.tr.delete(v, T), F = u.resolve(h2.start).marksAcross(u.resolve(h2.endA));
        else if (
          // Adding or removing a mark
          h2.endA == h2.endB && (V = Pv(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, h2.endA - b.start())))
        )
          S = t2.state.tr, V.type == "add" ? S.addMark(v, T, V.mark) : S.removeMark(v, T, V.mark);
        else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
          let L = m.parent.textBetween(m.parentOffset, g.parentOffset);
          if (t2.someProp("handleTextInput", (W) => W(t2, v, T, L)))
            return;
          S = t2.state.tr.insertText(L, v, T);
        }
      }
      if (S || (S = t2.state.tr.replace(v, T, c2.doc.slice(h2.start - c2.from, h2.endB - c2.from))), c2.sel) {
        let L = Td(t2, S.doc, c2.sel);
        L && !(zt && t2.composing && L.empty && (h2.start != h2.endB || t2.input.lastChromeDelete < Date.now() - 100) && (L.head == v || L.head == S.mapping.map(T) - 1) || en && L.empty && L.head == v) && S.setSelection(L);
      }
      F && S.ensureMarks(F), i && S.setMeta("composition", i), t2.dispatch(S.scrollIntoView());
    }
    function Td(t2, e, n) {
      return Math.max(n.anchor, n.head) > e.content.size ? null : Mc(t2, e.resolve(n.anchor), e.resolve(n.head));
    }
    function Pv(t2, e) {
      let n = t2.firstChild.marks, r = e.firstChild.marks, o = n, i = r, s, a, l;
      for (let u = 0; u < r.length; u++)
        o = r[u].removeFromSet(o);
      for (let u = 0; u < n.length; u++)
        i = n[u].removeFromSet(i);
      if (o.length == 1 && i.length == 0)
        a = o[0], s = "add", l = (u) => u.mark(a.addToSet(u.marks));
      else if (o.length == 0 && i.length == 1)
        a = i[0], s = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
      else
        return null;
      let c2 = [];
      for (let u = 0; u < e.childCount; u++)
        c2.push(l(e.child(u)));
      if (R.from(c2).eq(t2))
        return { mark: a, type: s };
    }
    function Bv(t2, e, n, r, o) {
      if (
        // The content must have shrunk
        n - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
        pl(r, true, false) < o.pos
      )
        return false;
      let i = t2.resolve(e);
      if (!r.parent.isTextblock) {
        let a = i.nodeAfter;
        return a != null && n == e + a.nodeSize;
      }
      if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
        return false;
      let s = t2.resolve(pl(i, true, true));
      return !s.parent.isTextblock || s.pos > n || pl(s, true, false) < n ? false : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
    }
    function pl(t2, e, n) {
      let r = t2.depth, o = e ? t2.end() : t2.pos;
      for (; r > 0 && (e || t2.indexAfter(r) == t2.node(r).childCount); )
        r--, o++, e = false;
      if (n) {
        let i = t2.node(r).maybeChild(t2.indexAfter(r));
        for (; i && !i.isLeaf; )
          i = i.firstChild, o++;
      }
      return o;
    }
    function $v(t2, e, n, r, o) {
      let i = t2.findDiffStart(e, n);
      if (i == null)
        return null;
      let { a: s, b: a } = t2.findDiffEnd(e, n + t2.size, n + e.size);
      if (o == "end") {
        let l = Math.max(0, i - Math.min(s, a));
        r -= s + l - i;
      }
      if (s < i && t2.size < e.size) {
        let l = r <= i && r >= s ? i - r : 0;
        i -= l, i && i < e.size && Od(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), a = i + (a - s), s = i;
      } else if (a < i) {
        let l = r <= i && r >= a ? i - r : 0;
        i -= l, i && i < t2.size && Od(t2.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), s = i + (s - a), a = i;
      }
      return { start: i, endA: s, endB: a };
    }
    function Od(t2) {
      if (t2.length != 2)
        return false;
      let e = t2.charCodeAt(0), n = t2.charCodeAt(1);
      return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
    }
    class Fv {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(e, n) {
        this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ov(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Id), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = Md(this), Ad(this), this.nodeViews = Rd(this), this.docView = cd(this.state.doc, Nd(this), dl(this), this.dom, this), this.domObserver = new Ov(this, (r, o, i, s) => Lv(this, r, o, i, s)), this.domObserver.start(), iv(this), this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let e = this._props;
          this._props = {};
          for (let n in e)
            this._props[n] = e[n];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && Zl(this);
        let n = this._props;
        this._props = e, e.plugins && (e.plugins.forEach(Id), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(e) {
        let n = {};
        for (let r in this._props)
          n[r] = this._props[r];
        n.state = this.state;
        for (let r in e)
          n[r] = e[r];
        this.update(n);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(e) {
        this.updateStateInner(e, this._props);
      }
      updateStateInner(e, n) {
        var r;
        let o = this.state, i = false, s = false;
        e.storedMarks && this.composing && (hh(this), s = true), this.state = e;
        let a = o.plugins != e.plugins || this._props.plugins != n.plugins;
        if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
          let f = Rd(this);
          Hv(f, this.nodeViews) && (this.nodeViews = f, i = true);
        }
        (a || n.handleDOMEvents != this._props.handleDOMEvents) && Zl(this), this.editable = Md(this), Ad(this);
        let l = dl(this), c2 = Nd(this), u = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", d = i || !this.docView.matchesNode(e.doc, c2, l);
        (d || !e.selection.eq(o.selection)) && (s = true);
        let p2 = u == "preserve" && s && this.dom.style.overflowAnchor == null && vy(this);
        if (s) {
          this.domObserver.stop();
          let f = d && (en || zt) && !this.composing && !o.selection.empty && !e.selection.empty && zv(o.selection, e.selection);
          if (d) {
            let h2 = zt ? this.trackWrites = this.domSelectionRange().focusNode : null;
            this.composing && (this.input.compositionNode = yv(this)), (i || !this.docView.update(e.doc, c2, l, this)) && (this.docView.updateOuterDeco(c2), this.docView.destroy(), this.docView = cd(e.doc, c2, l, this.dom, this)), h2 && !this.trackWrites && (f = true);
          }
          f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Vy(this)) ? dr(this, f) : (nh(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : p2 && Ey(p2);
      }
      /**
      @internal
      */
      scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
          if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof re) {
            let n = this.docView.domAfterPos(this.state.selection.from);
            n.nodeType == 1 && rd(this, n.getBoundingClientRect(), e);
          } else
            rd(this, this.coordsAtPos(this.state.selection.head, 1), e);
        }
      }
      destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop(); )
          e.destroy && e.destroy();
      }
      updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (let n = 0; n < this.directPlugins.length; n++) {
            let r = this.directPlugins[n];
            r.spec.view && this.pluginViews.push(r.spec.view(this));
          }
          for (let n = 0; n < this.state.plugins.length; n++) {
            let r = this.state.plugins[n];
            r.spec.view && this.pluginViews.push(r.spec.view(this));
          }
        } else
          for (let n = 0; n < this.pluginViews.length; n++) {
            let r = this.pluginViews[n];
            r.update && r.update(this, e);
          }
      }
      updateDraggedNode(e, n) {
        let r = e.node, o = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
          o = r.from;
        else {
          let i = r.from + (this.state.doc.content.size - n.doc.content.size);
          (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
        }
        this.dragging = new gh(e.slice, e.move, o < 0 ? void 0 : re.create(this.state.doc, o));
      }
      someProp(e, n) {
        let r = this._props && this._props[e], o;
        if (r != null && (o = n ? n(r) : r))
          return o;
        for (let s = 0; s < this.directPlugins.length; s++) {
          let a = this.directPlugins[s].props[e];
          if (a != null && (o = n ? n(a) : a))
            return o;
        }
        let i = this.state.plugins;
        if (i)
          for (let s = 0; s < i.length; s++) {
            let a = i[s].props[e];
            if (a != null && (o = n ? n(a) : a))
              return o;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (en) {
          let e = this.root.activeElement;
          if (e == this.dom)
            return true;
          if (!e || !this.dom.contains(e))
            return false;
          for (; e && this.dom != e && this.dom.contains(e); ) {
            if (e.contentEditable == "false")
              return false;
            e = e.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop(), this.editable && ky(this.dom), dr(this), this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let e = this._root;
        if (e == null) {
          for (let n = this.dom.parentNode; n; n = n.parentNode)
            if (n.nodeType == 9 || n.nodeType == 11 && n.host)
              return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
        }
        return e || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(e) {
        return xy(this, e);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(e, n = 1) {
        return jf(this, e, n);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(e, n = 0) {
        return this.docView.domFromPos(e, n);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimes—for example when interpreting an event
      target—you don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(e, n, r = -1) {
        let o = this.docView.posFromDOM(e, n, r);
        if (o == null)
          throw new RangeError("DOM position not inside the editor");
        return o;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(e, n) {
        return My(this, n || this.state, e);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(e, n) {
        return wi(this, "", e, false, n || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(e, n) {
        return wi(this, e, null, true, n || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(e) {
        return Rc(this, e);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        this.docView && (sv(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], dl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, ly());
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(e) {
        return lv(this, e);
      }
      /**
      Dispatch a transaction. Will call
      [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
      when given, and otherwise defaults to applying the transaction to
      the current state and calling
      [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
      This method is bound to the view instance, so that it can be
      easily passed around.
      */
      dispatch(e) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, e) : this.updateState(this.state.apply(e));
      }
      /**
      @internal
      */
      domSelectionRange() {
        let e = this.domSelection();
        return e ? jt && this.root.nodeType === 11 && fy(this.dom.ownerDocument) == this.dom && Av(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    }
    function Nd(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      return e.class = "ProseMirror", e.contenteditable = String(t2.editable), t2.someProp("attributes", (n) => {
        if (typeof n == "function" && (n = n(t2.state)), n)
          for (let r in n)
            r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
      }), e.translate || (e.translate = "no"), [ht.node(0, t2.state.doc.content.size, e)];
    }
    function Ad(t2) {
      if (t2.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t2.cursorWrapper = { dom: e, deco: ht.widget(t2.state.selection.from, e, { raw: true, marks: t2.markCursor }) };
      } else
        t2.cursorWrapper = null;
    }
    function Md(t2) {
      return !t2.someProp("editable", (e) => e(t2.state) === false);
    }
    function zv(t2, e) {
      let n = Math.min(t2.$anchor.sharedDepth(t2.head), e.$anchor.sharedDepth(e.head));
      return t2.$anchor.start(n) != e.$anchor.start(n);
    }
    function Rd(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      function n(r) {
        for (let o in r)
          Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
      }
      return t2.someProp("nodeViews", n), t2.someProp("markViews", n), e;
    }
    function Hv(t2, e) {
      let n = 0, r = 0;
      for (let o in t2) {
        if (t2[o] != e[o])
          return true;
        n++;
      }
      for (let o in e)
        r++;
      return n != r;
    }
    function Id(t2) {
      if (t2.spec.state || t2.spec.filterTransaction || t2.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    var Br = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    }, Us = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    }, Uv = typeof navigator < "u" && /Mac/.test(navigator.platform), Vv = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var Lt = 0; Lt < 10; Lt++) Br[48 + Lt] = Br[96 + Lt] = String(Lt);
    for (var Lt = 1; Lt <= 24; Lt++) Br[Lt + 111] = "F" + Lt;
    for (var Lt = 65; Lt <= 90; Lt++)
      Br[Lt] = String.fromCharCode(Lt + 32), Us[Lt] = String.fromCharCode(Lt);
    for (var fl in Br) Us.hasOwnProperty(fl) || (Us[fl] = Br[fl]);
    function Wv(t2) {
      var e = Uv && t2.metaKey && t2.shiftKey && !t2.ctrlKey && !t2.altKey || Vv && t2.shiftKey && t2.key && t2.key.length == 1 || t2.key == "Unidentified", n = !e && t2.key || (t2.shiftKey ? Us : Br)[t2.keyCode] || t2.key || "Unidentified";
      return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
    }
    const Kv = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function qv(t2) {
      let e = t2.split(/-(?!$)/), n = e[e.length - 1];
      n == "Space" && (n = " ");
      let r, o, i, s;
      for (let a = 0; a < e.length - 1; a++) {
        let l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          s = true;
        else if (/^a(lt)?$/i.test(l))
          r = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          o = true;
        else if (/^s(hift)?$/i.test(l))
          i = true;
        else if (/^mod$/i.test(l))
          Kv ? s = true : o = true;
        else
          throw new Error("Unrecognized modifier name: " + l);
      }
      return r && (n = "Alt-" + n), o && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i && (n = "Shift-" + n), n;
    }
    function Gv(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let n in t2)
        e[qv(n)] = t2[n];
      return e;
    }
    function hl(t2, e, n = true) {
      return e.altKey && (t2 = "Alt-" + t2), e.ctrlKey && (t2 = "Ctrl-" + t2), e.metaKey && (t2 = "Meta-" + t2), n && e.shiftKey && (t2 = "Shift-" + t2), t2;
    }
    function jv(t2) {
      return new Ue({ props: { handleKeyDown: $c(t2) } });
    }
    function $c(t2) {
      let e = Gv(t2);
      return function(n, r) {
        let o = Wv(r), i, s = e[hl(o, r)];
        if (s && s(n.state, n.dispatch, n))
          return true;
        if (o.length == 1 && o != " ") {
          if (r.shiftKey) {
            let a = e[hl(o, r, false)];
            if (a && a(n.state, n.dispatch, n))
              return true;
          }
          if ((r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) && (i = Br[r.keyCode]) && i != o) {
            let a = e[hl(i, r)];
            if (a && a(n.state, n.dispatch, n))
              return true;
          }
        }
        return false;
      };
    }
    const Fc = (t2, e) => t2.selection.empty ? false : (e && e(t2.tr.deleteSelection().scrollIntoView()), true);
    function kh(t2, e) {
      let { $cursor: n } = t2.selection;
      return !n || (e ? !e.endOfTextblock("backward", t2) : n.parentOffset > 0) ? null : n;
    }
    const wh = (t2, e, n) => {
      let r = kh(t2, n);
      if (!r)
        return false;
      let o = zc(r);
      if (!o) {
        let s = r.blockRange(), a = s && Uo(s);
        return a == null ? false : (e && e(t2.tr.lift(s, a).scrollIntoView()), true);
      }
      let i = o.nodeBefore;
      if (Mh(t2, o, e, -1))
        return true;
      if (r.parent.content.size == 0 && (Do(i, "end") || re.isSelectable(i)))
        for (let s = r.depth; ; s--) {
          let a = Na(t2.doc, r.before(s), r.after(s), K.empty);
          if (a && a.slice.size < a.to - a.from) {
            if (e) {
              let l = t2.tr.step(a);
              l.setSelection(Do(i, "end") ? ue.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1) : re.create(l.doc, o.pos - i.nodeSize)), e(l.scrollIntoView());
            }
            return true;
          }
          if (s == 1 || r.node(s - 1).childCount > 1)
            break;
        }
      return i.isAtom && o.depth == r.depth - 1 ? (e && e(t2.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), true) : false;
    }, Yv = (t2, e, n) => {
      let r = kh(t2, n);
      if (!r)
        return false;
      let o = zc(r);
      return o ? _h(t2, o, e) : false;
    }, Jv = (t2, e, n) => {
      let r = Ch(t2, n);
      if (!r)
        return false;
      let o = Hc(r);
      return o ? _h(t2, o, e) : false;
    };
    function _h(t2, e, n) {
      let r = e.nodeBefore, o = r, i = e.pos - 1;
      for (; !o.isTextblock; i--) {
        if (o.type.spec.isolating)
          return false;
        let u = o.lastChild;
        if (!u)
          return false;
        o = u;
      }
      let s = e.nodeAfter, a = s, l = e.pos + 1;
      for (; !a.isTextblock; l++) {
        if (a.type.spec.isolating)
          return false;
        let u = a.firstChild;
        if (!u)
          return false;
        a = u;
      }
      let c2 = Na(t2.doc, i, l, K.empty);
      if (!c2 || c2.from != i || c2 instanceof St && c2.slice.size >= l - i)
        return false;
      if (n) {
        let u = t2.tr.step(c2);
        u.setSelection(ie.create(u.doc, i)), n(u.scrollIntoView());
      }
      return true;
    }
    function Do(t2, e, n = false) {
      for (let r = t2; r; r = e == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
          return true;
        if (n && r.childCount != 1)
          return false;
      }
      return false;
    }
    const Sh = (t2, e, n) => {
      let { $head: r, empty: o } = t2.selection, i = r;
      if (!o)
        return false;
      if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", t2) : r.parentOffset > 0)
          return false;
        i = zc(r);
      }
      let s = i && i.nodeBefore;
      return !s || !re.isSelectable(s) ? false : (e && e(t2.tr.setSelection(re.create(t2.doc, i.pos - s.nodeSize)).scrollIntoView()), true);
    };
    function zc(t2) {
      if (!t2.parent.type.spec.isolating)
        for (let e = t2.depth - 1; e >= 0; e--) {
          if (t2.index(e) > 0)
            return t2.doc.resolve(t2.before(e + 1));
          if (t2.node(e).type.spec.isolating)
            break;
        }
      return null;
    }
    function Ch(t2, e) {
      let { $cursor: n } = t2.selection;
      return !n || (e ? !e.endOfTextblock("forward", t2) : n.parentOffset < n.parent.content.size) ? null : n;
    }
    const xh = (t2, e, n) => {
      let r = Ch(t2, n);
      if (!r)
        return false;
      let o = Hc(r);
      if (!o)
        return false;
      let i = o.nodeAfter;
      if (Mh(t2, o, e, 1))
        return true;
      if (r.parent.content.size == 0 && (Do(i, "start") || re.isSelectable(i))) {
        let s = Na(t2.doc, r.before(), r.after(), K.empty);
        if (s && s.slice.size < s.to - s.from) {
          if (e) {
            let a = t2.tr.step(s);
            a.setSelection(Do(i, "start") ? ue.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : re.create(a.doc, a.mapping.map(o.pos))), e(a.scrollIntoView());
          }
          return true;
        }
      }
      return i.isAtom && o.depth == r.depth - 1 ? (e && e(t2.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), true) : false;
    }, Th = (t2, e, n) => {
      let { $head: r, empty: o } = t2.selection, i = r;
      if (!o)
        return false;
      if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", t2) : r.parentOffset < r.parent.content.size)
          return false;
        i = Hc(r);
      }
      let s = i && i.nodeAfter;
      return !s || !re.isSelectable(s) ? false : (e && e(t2.tr.setSelection(re.create(t2.doc, i.pos)).scrollIntoView()), true);
    };
    function Hc(t2) {
      if (!t2.parent.type.spec.isolating)
        for (let e = t2.depth - 1; e >= 0; e--) {
          let n = t2.node(e);
          if (t2.index(e) + 1 < n.childCount)
            return t2.doc.resolve(t2.after(e + 1));
          if (n.type.spec.isolating)
            break;
        }
      return null;
    }
    const Xv = (t2, e) => {
      let n = t2.selection, r = n instanceof re, o;
      if (r) {
        if (n.node.isTextblock || !Fr(t2.doc, n.from))
          return false;
        o = n.from;
      } else if (o = Oa(t2.doc, n.from, -1), o == null)
        return false;
      if (e) {
        let i = t2.tr.join(o);
        r && i.setSelection(re.create(i.doc, o - t2.doc.resolve(o).nodeBefore.nodeSize)), e(i.scrollIntoView());
      }
      return true;
    }, Zv = (t2, e) => {
      let n = t2.selection, r;
      if (n instanceof re) {
        if (n.node.isTextblock || !Fr(t2.doc, n.to))
          return false;
        r = n.to;
      } else if (r = Oa(t2.doc, n.to, 1), r == null)
        return false;
      return e && e(t2.tr.join(r).scrollIntoView()), true;
    }, Qv = (t2, e) => {
      let { $from: n, $to: r } = t2.selection, o = n.blockRange(r), i = o && Uo(o);
      return i == null ? false : (e && e(t2.tr.lift(o, i).scrollIntoView()), true);
    }, Oh = (t2, e) => {
      let { $head: n, $anchor: r } = t2.selection;
      return !n.parent.type.spec.code || !n.sameParent(r) ? false : (e && e(t2.tr.insertText(`
`).scrollIntoView()), true);
    };
    function Uc(t2) {
      for (let e = 0; e < t2.edgeCount; e++) {
        let { type: n } = t2.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
          return n;
      }
      return null;
    }
    const e0 = (t2, e) => {
      let { $head: n, $anchor: r } = t2.selection;
      if (!n.parent.type.spec.code || !n.sameParent(r))
        return false;
      let o = n.node(-1), i = n.indexAfter(-1), s = Uc(o.contentMatchAt(i));
      if (!s || !o.canReplaceWith(i, i, s))
        return false;
      if (e) {
        let a = n.after(), l = t2.tr.replaceWith(a, a, s.createAndFill());
        l.setSelection(ue.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
      }
      return true;
    }, Nh = (t2, e) => {
      let n = t2.selection, { $from: r, $to: o } = n;
      if (n instanceof pn || r.parent.inlineContent || o.parent.inlineContent)
        return false;
      let i = Uc(o.parent.contentMatchAt(o.indexAfter()));
      if (!i || !i.isTextblock)
        return false;
      if (e) {
        let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, a = t2.tr.insert(s, i.createAndFill());
        a.setSelection(ie.create(a.doc, s + 1)), e(a.scrollIntoView());
      }
      return true;
    }, Ah = (t2, e) => {
      let { $cursor: n } = t2.selection;
      if (!n || n.parent.content.size)
        return false;
      if (n.depth > 1 && n.after() != n.end(-1)) {
        let i = n.before();
        if (ur(t2.doc, i))
          return e && e(t2.tr.split(i).scrollIntoView()), true;
      }
      let r = n.blockRange(), o = r && Uo(r);
      return o == null ? false : (e && e(t2.tr.lift(r, o).scrollIntoView()), true);
    };
    function t0(t2) {
      return (e, n) => {
        let { $from: r, $to: o } = e.selection;
        if (e.selection instanceof re && e.selection.node.isBlock)
          return !r.parentOffset || !ur(e.doc, r.pos) ? false : (n && n(e.tr.split(r.pos).scrollIntoView()), true);
        if (!r.depth)
          return false;
        let i = [], s, a, l = false, c2 = false;
        for (let f = r.depth; ; f--)
          if (r.node(f).isBlock) {
            l = r.end(f) == r.pos + (r.depth - f), c2 = r.start(f) == r.pos - (r.depth - f), a = Uc(r.node(f - 1).contentMatchAt(r.indexAfter(f - 1))), i.unshift(l && a ? { type: a } : null), s = f;
            break;
          } else {
            if (f == 1)
              return false;
            i.unshift(null);
          }
        let u = e.tr;
        (e.selection instanceof ie || e.selection instanceof pn) && u.deleteSelection();
        let d = u.mapping.map(r.pos), p2 = ur(u.doc, d, i.length, i);
        if (p2 || (i[0] = a ? { type: a } : null, p2 = ur(u.doc, d, i.length, i)), u.split(d, i.length, i), !l && c2 && r.node(s).type != a) {
          let f = u.mapping.map(r.before(s)), h2 = u.doc.resolve(f);
          a && r.node(s - 1).canReplaceWith(h2.index(), h2.index() + 1, a) && u.setNodeMarkup(u.mapping.map(r.before(s)), a);
        }
        return n && n(u.scrollIntoView()), true;
      };
    }
    const n0 = t0(), r0 = (t2, e) => {
      let { $from: n, to: r } = t2.selection, o, i = n.sharedDepth(r);
      return i == 0 ? false : (o = n.before(i), e && e(t2.tr.setSelection(re.create(t2.doc, o))), true);
    };
    function o0(t2, e, n) {
      let r = e.nodeBefore, o = e.nodeAfter, i = e.index();
      return !r || !o || !r.type.compatibleContent(o.type) ? false : !r.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t2.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || Fr(t2.doc, e.pos)) ? false : (n && n(t2.tr.join(e.pos).scrollIntoView()), true);
    }
    function Mh(t2, e, n, r) {
      let o = e.nodeBefore, i = e.nodeAfter, s, a, l = o.type.spec.isolating || i.type.spec.isolating;
      if (!l && o0(t2, e, n))
        return true;
      let c2 = !l && e.parent.canReplace(e.index(), e.index() + 1);
      if (c2 && (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) && a.matchType(s[0] || i.type).validEnd) {
        if (n) {
          let f = e.pos + i.nodeSize, h2 = R.empty;
          for (let b = s.length - 1; b >= 0; b--)
            h2 = R.from(s[b].create(null, h2));
          h2 = R.from(o.copy(h2));
          let m = t2.tr.step(new Ct(e.pos - 1, f, e.pos, f, new K(h2, 1, 0), s.length, true)), g = m.doc.resolve(f + 2 * s.length);
          g.nodeAfter && g.nodeAfter.type == o.type && Fr(m.doc, g.pos) && m.join(g.pos), n(m.scrollIntoView());
        }
        return true;
      }
      let u = i.type.spec.isolating || r > 0 && l ? null : ue.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), p2 = d && Uo(d);
      if (p2 != null && p2 >= e.depth)
        return n && n(t2.tr.lift(d, p2).scrollIntoView()), true;
      if (c2 && Do(i, "start", true) && Do(o, "end")) {
        let f = o, h2 = [];
        for (; h2.push(f), !f.isTextblock; )
          f = f.lastChild;
        let m = i, g = 1;
        for (; !m.isTextblock; m = m.firstChild)
          g++;
        if (f.canReplace(f.childCount, f.childCount, m.content)) {
          if (n) {
            let b = R.empty;
            for (let _ = h2.length - 1; _ >= 0; _--)
              b = R.from(h2[_].copy(b));
            let E = t2.tr.step(new Ct(e.pos - h2.length, e.pos + i.nodeSize, e.pos + g, e.pos + i.nodeSize - g, new K(b, h2.length, 0), 0, true));
            n(E.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function Rh(t2) {
      return function(e, n) {
        let r = e.selection, o = t2 < 0 ? r.$from : r.$to, i = o.depth;
        for (; o.node(i).isInline; ) {
          if (!i)
            return false;
          i--;
        }
        return o.node(i).isTextblock ? (n && n(e.tr.setSelection(ie.create(e.doc, t2 < 0 ? o.start(i) : o.end(i)))), true) : false;
      };
    }
    const i0 = Rh(-1), s0 = Rh(1);
    function a0(t2, e = null) {
      return function(n, r) {
        let { $from: o, $to: i } = n.selection, s = o.blockRange(i), a = s && xc(s, t2, e);
        return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), true) : false;
      };
    }
    function Dd(t2, e = null) {
      return function(n, r) {
        let o = false;
        for (let i = 0; i < n.selection.ranges.length && !o; i++) {
          let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[i];
          n.doc.nodesBetween(s, a, (l, c2) => {
            if (o)
              return false;
            if (!(!l.isTextblock || l.hasMarkup(t2, e)))
              if (l.type == t2)
                o = true;
              else {
                let u = n.doc.resolve(c2), d = u.index();
                o = u.parent.canReplaceWith(d, d + 1, t2);
              }
          });
        }
        if (!o)
          return false;
        if (r) {
          let i = n.tr;
          for (let s = 0; s < n.selection.ranges.length; s++) {
            let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
            i.setBlockType(a, l, t2, e);
          }
          r(i.scrollIntoView());
        }
        return true;
      };
    }
    function Vc(...t2) {
      return function(e, n, r) {
        for (let o = 0; o < t2.length; o++)
          if (t2[o](e, n, r))
            return true;
        return false;
      };
    }
    Vc(Fc, wh, Sh);
    Vc(Fc, xh, Th);
    Vc(Oh, Nh, Ah, n0);
    typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
    function l0(t2, e = null) {
      return function(n, r) {
        let { $from: o, $to: i } = n.selection, s = o.blockRange(i);
        if (!s)
          return false;
        let a = r ? n.tr : null;
        return c0(a, s, t2, e) ? (r && r(a.scrollIntoView()), true) : false;
      };
    }
    function c0(t2, e, n, r = null) {
      let o = false, i = e, s = e.$from.doc;
      if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
        if (e.$from.index(e.depth - 1) == 0)
          return false;
        let l = s.resolve(e.start - 2);
        i = new Ls(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Ls(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), o = true;
      }
      let a = xc(i, n, r, e);
      return a ? (t2 && u0(t2, e, a, o, n), true) : false;
    }
    function u0(t2, e, n, r, o) {
      let i = R.empty;
      for (let u = n.length - 1; u >= 0; u--)
        i = R.from(n[u].type.create(n[u].attrs, i));
      t2.step(new Ct(e.start - (r ? 2 : 0), e.end, e.start, e.end, new K(i, 0, 0), n.length, true));
      let s = 0;
      for (let u = 0; u < n.length; u++)
        n[u].type == o && (s = u + 1);
      let a = n.length - s, l = e.start + n.length - (r ? 2 : 0), c2 = e.parent;
      for (let u = e.startIndex, d = e.endIndex, p2 = true; u < d; u++, p2 = false)
        !p2 && ur(t2.doc, l, a) && (t2.split(l, a), l += 2 * a), l += c2.child(u).nodeSize;
      return t2;
    }
    function d0(t2) {
      return function(e, n) {
        let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t2);
        return i ? n ? r.node(i.depth - 1).type == t2 ? p0(e, n, t2, i) : f0(e, n, i) : true : false;
      };
    }
    function p0(t2, e, n, r) {
      let o = t2.tr, i = r.end, s = r.$to.end(r.depth);
      i < s && (o.step(new Ct(i - 1, s, i, s, new K(R.from(n.create(null, r.parent.copy())), 1, 0), 1, true)), r = new Ls(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
      const a = Uo(r);
      if (a == null)
        return false;
      o.lift(r, a);
      let l = o.doc.resolve(o.mapping.map(i, -1) - 1);
      return Fr(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && o.join(l.pos), e(o.scrollIntoView()), true;
    }
    function f0(t2, e, n) {
      let r = t2.tr, o = n.parent;
      for (let f = n.end, h2 = n.endIndex - 1, m = n.startIndex; h2 > m; h2--)
        f -= o.child(h2).nodeSize, r.delete(f - 1, f + 1);
      let i = r.doc.resolve(n.start), s = i.nodeAfter;
      if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
        return false;
      let a = n.startIndex == 0, l = n.endIndex == o.childCount, c2 = i.node(-1), u = i.index(-1);
      if (!c2.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? R.empty : R.from(o))))
        return false;
      let d = i.pos, p2 = d + s.nodeSize;
      return r.step(new Ct(d - (a ? 1 : 0), p2 + (l ? 1 : 0), d + 1, p2 - 1, new K((a ? R.empty : R.from(o.copy(R.empty))).append(l ? R.empty : R.from(o.copy(R.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), true;
    }
    function h0(t2) {
      return function(e, n) {
        let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (c2) => c2.childCount > 0 && c2.firstChild.type == t2);
        if (!i)
          return false;
        let s = i.startIndex;
        if (s == 0)
          return false;
        let a = i.parent, l = a.child(s - 1);
        if (l.type != t2)
          return false;
        if (n) {
          let c2 = l.lastChild && l.lastChild.type == a.type, u = R.from(c2 ? t2.create() : null), d = new K(R.from(t2.create(null, R.from(a.type.create(null, u)))), c2 ? 3 : 1, 0), p2 = i.start, f = i.end;
          n(e.tr.step(new Ct(p2 - (c2 ? 3 : 1), f, p2, f, d, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    function Da(t2) {
      const { state: e, transaction: n } = t2;
      let { selection: r } = n, { doc: o } = n, { storedMarks: i } = n;
      return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
          return i;
        },
        get selection() {
          return r;
        },
        get doc() {
          return o;
        },
        get tr() {
          return r = n.selection, o = n.doc, i = n.storedMarks, n;
        }
      };
    }
    class La {
      constructor(e) {
        this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands: e, editor: n, state: r } = this, { view: o } = n, { tr: i } = r, s = this.buildProps(i);
        return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
          const d = l(...u)(s);
          return !i.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(i), d;
        }]));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(e, n = true) {
        const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = [], l = !!e, c2 = e || i.tr, u = () => (!l && n && !c2.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c2), a.every((p2) => p2 === true)), d = {
          ...Object.fromEntries(Object.entries(r).map(([p2, f]) => [p2, (...m) => {
            const g = this.buildProps(c2, n), b = f(...m)(g);
            return a.push(b), d;
          }])),
          run: u
        };
        return d;
      }
      createCan(e) {
        const { rawCommands: n, state: r } = this, o = false, i = e || r.tr, s = this.buildProps(i, o);
        return {
          ...Object.fromEntries(Object.entries(n).map(([l, c2]) => [l, (...u) => c2(...u)({ ...s, dispatch: void 0 })])),
          chain: () => this.createChain(i, o)
        };
      }
      buildProps(e, n = true) {
        const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = {
          tr: e,
          editor: o,
          view: s,
          state: Da({
            state: i,
            transaction: e
          }),
          dispatch: n ? () => {
          } : void 0,
          chain: () => this.createChain(e, n),
          can: () => this.createCan(e),
          get commands() {
            return Object.fromEntries(Object.entries(r).map(([l, c2]) => [l, (...u) => c2(...u)(a)]));
          }
        };
        return a;
      }
    }
    class m0 {
      constructor() {
        this.callbacks = {};
      }
      on(e, n) {
        return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
      }
      emit(e, ...n) {
        const r = this.callbacks[e];
        return r && r.forEach((o) => o.apply(this, n)), this;
      }
      off(e, n) {
        const r = this.callbacks[e];
        return r && (n ? this.callbacks[e] = r.filter((o) => o !== n) : delete this.callbacks[e]), this;
      }
      once(e, n) {
        const r = (...o) => {
          this.off(e, r), n.apply(this, o);
        };
        return this.on(e, r);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    }
    function Z(t2, e, n) {
      return t2.config[e] === void 0 && t2.parent ? Z(t2.parent, e, n) : typeof t2.config[e] == "function" ? t2.config[e].bind({
        ...n,
        parent: t2.parent ? Z(t2.parent, e, n) : null
      }) : t2.config[e];
    }
    function Pa(t2) {
      const e = t2.filter((o) => o.type === "extension"), n = t2.filter((o) => o.type === "node"), r = t2.filter((o) => o.type === "mark");
      return {
        baseExtensions: e,
        nodeExtensions: n,
        markExtensions: r
      };
    }
    function Ih(t2) {
      const e = [], { nodeExtensions: n, markExtensions: r } = Pa(t2), o = [...n, ...r], i = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      return t2.forEach((s) => {
        const a = {
          name: s.name,
          options: s.options,
          storage: s.storage,
          extensions: o
        }, l = Z(s, "addGlobalAttributes", a);
        if (!l)
          return;
        l().forEach((u) => {
          u.types.forEach((d) => {
            Object.entries(u.attributes).forEach(([p2, f]) => {
              e.push({
                type: d,
                name: p2,
                attribute: {
                  ...i,
                  ...f
                }
              });
            });
          });
        });
      }), o.forEach((s) => {
        const a = {
          name: s.name,
          options: s.options,
          storage: s.storage
        }, l = Z(s, "addAttributes", a);
        if (!l)
          return;
        const c2 = l();
        Object.entries(c2).forEach(([u, d]) => {
          const p2 = {
            ...i,
            ...d
          };
          typeof (p2 == null ? void 0 : p2.default) == "function" && (p2.default = p2.default()), p2 != null && p2.isRequired && (p2 == null ? void 0 : p2.default) === void 0 && delete p2.default, e.push({
            type: s.name,
            name: u,
            attribute: p2
          });
        });
      }), e;
    }
    function Tt(t2, e) {
      if (typeof t2 == "string") {
        if (!e.nodes[t2])
          throw Error(`There is no node type named '${t2}'. Maybe you forgot to add the extension?`);
        return e.nodes[t2];
      }
      return t2;
    }
    function Be(...t2) {
      return t2.filter((e) => !!e).reduce((e, n) => {
        const r = { ...e };
        return Object.entries(n).forEach(([o, i]) => {
          if (!r[o]) {
            r[o] = i;
            return;
          }
          if (o === "class") {
            const a = i ? String(i).split(" ") : [], l = r[o] ? r[o].split(" ") : [], c2 = a.filter((u) => !l.includes(u));
            r[o] = [...l, ...c2].join(" ");
          } else if (o === "style") {
            const a = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[o] ? r[o].split(";").map((u) => u.trim()).filter(Boolean) : [], c2 = /* @__PURE__ */ new Map();
            l.forEach((u) => {
              const [d, p2] = u.split(":").map((f) => f.trim());
              c2.set(d, p2);
            }), a.forEach((u) => {
              const [d, p2] = u.split(":").map((f) => f.trim());
              c2.set(d, p2);
            }), r[o] = Array.from(c2.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
          } else
            r[o] = i;
        }), r;
      }, {});
    }
    function Ql(t2, e) {
      return e.filter((n) => n.type === t2.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t2.attrs) || {} : {
        [n.name]: t2.attrs[n.name]
      }).reduce((n, r) => Be(n, r), {});
    }
    function Dh(t2) {
      return typeof t2 == "function";
    }
    function Te(t2, e = void 0, ...n) {
      return Dh(t2) ? e ? t2.bind(e)(...n) : t2(...n) : t2;
    }
    function g0(t2 = {}) {
      return Object.keys(t2).length === 0 && t2.constructor === Object;
    }
    function b0(t2) {
      return typeof t2 != "string" ? t2 : t2.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t2) : t2 === "true" ? true : t2 === "false" ? false : t2;
    }
    function Ld(t2, e) {
      return "style" in t2 ? t2 : {
        ...t2,
        getAttrs: (n) => {
          const r = t2.getAttrs ? t2.getAttrs(n) : t2.attrs;
          if (r === false)
            return false;
          const o = e.reduce((i, s) => {
            const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : b0(n.getAttribute(s.name));
            return a == null ? i : {
              ...i,
              [s.name]: a
            };
          }, {});
          return { ...r, ...o };
        }
      };
    }
    function Pd(t2) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(t2).filter(([e, n]) => e === "attrs" && g0(n) ? false : n != null)
      );
    }
    function y0(t2, e) {
      var n;
      const r = Ih(t2), { nodeExtensions: o, markExtensions: i } = Pa(t2), s = (n = o.find((c2) => Z(c2, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(o.map((c2) => {
        const u = r.filter((b) => b.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = t2.reduce((b, E) => {
          const _ = Z(E, "extendNodeSchema", d);
          return {
            ...b,
            ..._ ? _(c2) : {}
          };
        }, {}), f = Pd({
          ...p2,
          content: Te(Z(c2, "content", d)),
          marks: Te(Z(c2, "marks", d)),
          group: Te(Z(c2, "group", d)),
          inline: Te(Z(c2, "inline", d)),
          atom: Te(Z(c2, "atom", d)),
          selectable: Te(Z(c2, "selectable", d)),
          draggable: Te(Z(c2, "draggable", d)),
          code: Te(Z(c2, "code", d)),
          whitespace: Te(Z(c2, "whitespace", d)),
          linebreakReplacement: Te(Z(c2, "linebreakReplacement", d)),
          defining: Te(Z(c2, "defining", d)),
          isolating: Te(Z(c2, "isolating", d)),
          attrs: Object.fromEntries(u.map((b) => {
            var E;
            return [b.name, { default: (E = b == null ? void 0 : b.attribute) === null || E === void 0 ? void 0 : E.default }];
          }))
        }), h2 = Te(Z(c2, "parseHTML", d));
        h2 && (f.parseDOM = h2.map((b) => Ld(b, u)));
        const m = Z(c2, "renderHTML", d);
        m && (f.toDOM = (b) => m({
          node: b,
          HTMLAttributes: Ql(b, u)
        }));
        const g = Z(c2, "renderText", d);
        return g && (f.toText = g), [c2.name, f];
      })), l = Object.fromEntries(i.map((c2) => {
        const u = r.filter((g) => g.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = t2.reduce((g, b) => {
          const E = Z(b, "extendMarkSchema", d);
          return {
            ...g,
            ...E ? E(c2) : {}
          };
        }, {}), f = Pd({
          ...p2,
          inclusive: Te(Z(c2, "inclusive", d)),
          excludes: Te(Z(c2, "excludes", d)),
          group: Te(Z(c2, "group", d)),
          spanning: Te(Z(c2, "spanning", d)),
          code: Te(Z(c2, "code", d)),
          attrs: Object.fromEntries(u.map((g) => {
            var b;
            return [g.name, { default: (b = g == null ? void 0 : g.attribute) === null || b === void 0 ? void 0 : b.default }];
          }))
        }), h2 = Te(Z(c2, "parseHTML", d));
        h2 && (f.parseDOM = h2.map((g) => Ld(g, u)));
        const m = Z(c2, "renderHTML", d);
        return m && (f.toDOM = (g) => m({
          mark: g,
          HTMLAttributes: Ql(g, u)
        })), [c2.name, f];
      }));
      return new _f({
        topNode: s,
        nodes: a,
        marks: l
      });
    }
    function ml(t2, e) {
      return e.nodes[t2] || e.marks[t2] || null;
    }
    function Bd(t2, e) {
      return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t2.name) : e;
    }
    function Wc(t2, e) {
      const n = fo.fromSchema(e).serializeFragment(t2), o = document.implementation.createHTMLDocument().createElement("div");
      return o.appendChild(n), o.innerHTML;
    }
    const v0 = (t2, e = 500) => {
      let n = "";
      const r = t2.parentOffset;
      return t2.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, a) => {
        var l, c2;
        const u = ((c2 = (l = o.type.spec).toText) === null || c2 === void 0 ? void 0 : c2.call(l, {
          node: o,
          pos: i,
          parent: s,
          index: a
        })) || o.textContent || "%leaf%";
        n += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i));
      }), n;
    };
    function Kc(t2) {
      return Object.prototype.toString.call(t2) === "[object RegExp]";
    }
    class zi {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const E0 = (t2, e) => {
      if (Kc(e))
        return e.exec(t2);
      const n = e(t2);
      if (!n)
        return null;
      const r = [n.text];
      return r.index = n.index, r.input = t2, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
    };
    function Qi(t2) {
      var e;
      const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = t2, { view: l } = n;
      if (l.composing)
        return false;
      const c2 = l.state.doc.resolve(r);
      if (
        // check for code node
        c2.parent.type.spec.code || !((e = c2.nodeBefore || c2.nodeAfter) === null || e === void 0) && e.marks.find((p2) => p2.type.spec.code)
      )
        return false;
      let u = false;
      const d = v0(c2) + i;
      return s.forEach((p2) => {
        if (u)
          return;
        const f = E0(d, p2.find);
        if (!f)
          return;
        const h2 = l.state.tr, m = Da({
          state: l.state,
          transaction: h2
        }), g = {
          from: r - (f[0].length - i.length),
          to: o
        }, { commands: b, chain: E, can: _ } = new La({
          editor: n,
          state: m
        });
        p2.handler({
          state: m,
          range: g,
          match: f,
          commands: b,
          chain: E,
          can: _
        }) === null || !h2.steps.length || (h2.setMeta(a, {
          transform: h2,
          from: r,
          to: o,
          text: i
        }), l.dispatch(h2), u = true);
      }), u;
    }
    function k0(t2) {
      const { editor: e, rules: n } = t2, r = new Ue({
        state: {
          init() {
            return null;
          },
          apply(o, i, s) {
            const a = o.getMeta(r);
            if (a)
              return a;
            const l = o.getMeta("applyInputRules");
            return !!l && setTimeout(() => {
              let { text: u } = l;
              typeof u == "string" ? u = u : u = Wc(R.from(u), s.schema);
              const { from: d } = l, p2 = d + u.length;
              Qi({
                editor: e,
                from: d,
                to: p2,
                text: u,
                rules: n,
                plugin: r
              });
            }), o.selectionSet || o.docChanged ? null : i;
          }
        },
        props: {
          handleTextInput(o, i, s, a) {
            return Qi({
              editor: e,
              from: i,
              to: s,
              text: a,
              rules: n,
              plugin: r
            });
          },
          handleDOMEvents: {
            compositionend: (o) => (setTimeout(() => {
              const { $cursor: i } = o.state.selection;
              i && Qi({
                editor: e,
                from: i.pos,
                to: i.pos,
                text: "",
                rules: n,
                plugin: r
              });
            }), false)
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(o, i) {
            if (i.key !== "Enter")
              return false;
            const { $cursor: s } = o.state.selection;
            return s ? Qi({
              editor: e,
              from: s.pos,
              to: s.pos,
              text: `
`,
              rules: n,
              plugin: r
            }) : false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return r;
    }
    function w0(t2) {
      return Object.prototype.toString.call(t2).slice(8, -1);
    }
    function es(t2) {
      return w0(t2) !== "Object" ? false : t2.constructor === Object && Object.getPrototypeOf(t2) === Object.prototype;
    }
    function Ba(t2, e) {
      const n = { ...t2 };
      return es(t2) && es(e) && Object.keys(e).forEach((r) => {
        es(e[r]) && es(t2[r]) ? n[r] = Ba(t2[r], e[r]) : n[r] = e[r];
      }), n;
    }
    class _n {
      constructor(e = {}) {
        this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new _n(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new _n(e);
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
      static handleExit({ editor: e, mark: n }) {
        const { tr: r } = e.state, o = e.state.selection.$from;
        if (o.pos === o.end()) {
          const s = o.marks();
          if (!!!s.find((c2) => (c2 == null ? void 0 : c2.type.name) === n.name))
            return false;
          const l = s.find((c2) => (c2 == null ? void 0 : c2.type.name) === n.name);
          return l && r.removeStoredMark(l), r.insertText(" ", o.pos), e.view.dispatch(r), true;
        }
        return false;
      }
    }
    function _0(t2) {
      return typeof t2 == "number";
    }
    class S0 {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const C0 = (t2, e, n) => {
      if (Kc(e))
        return [...t2.matchAll(e)];
      const r = e(t2, n);
      return r ? r.map((o) => {
        const i = [o.text];
        return i.index = o.index, i.input = t2, i.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(o.replaceWith)), i;
      }) : [];
    };
    function x0(t2) {
      const { editor: e, state: n, from: r, to: o, rule: i, pasteEvent: s, dropEvent: a } = t2, { commands: l, chain: c2, can: u } = new La({
        editor: e,
        state: n
      }), d = [];
      return n.doc.nodesBetween(r, o, (f, h2) => {
        if (!f.isTextblock || f.type.spec.code)
          return;
        const m = Math.max(r, h2), g = Math.min(o, h2 + f.content.size), b = f.textBetween(m - h2, g - h2, void 0, "￼");
        C0(b, i.find, s).forEach((_) => {
          if (_.index === void 0)
            return;
          const v = m + _.index + 1, T = v + _[0].length, S = {
            from: n.tr.mapping.map(v),
            to: n.tr.mapping.map(T)
          }, F = i.handler({
            state: n,
            range: S,
            match: _,
            commands: l,
            chain: c2,
            can: u,
            pasteEvent: s,
            dropEvent: a
          });
          d.push(F);
        });
      }), d.every((f) => f !== null);
    }
    let ts = null;
    const T0 = (t2) => {
      var e;
      const n = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t2), n;
    };
    function O0(t2) {
      const { editor: e, rules: n } = t2;
      let r = null, o = false, i = false, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      const l = ({ state: u, from: d, to: p2, rule: f, pasteEvt: h2 }) => {
        const m = u.tr, g = Da({
          state: u,
          transaction: m
        });
        if (!(!x0({
          editor: e,
          state: g,
          from: Math.max(d - 1, 0),
          to: p2.b - 1,
          rule: f,
          pasteEvent: h2,
          dropEvent: a
        }) || !m.steps.length)) {
          try {
            a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
          } catch {
            a = null;
          }
          return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
        }
      };
      return n.map((u) => new Ue({
        // we register a global drag handler to track the current drag source element
        view(d) {
          const p2 = (h2) => {
            var m;
            r = !((m = d.dom.parentElement) === null || m === void 0) && m.contains(h2.target) ? d.dom.parentElement : null, r && (ts = e);
          }, f = () => {
            ts && (ts = null);
          };
          return window.addEventListener("dragstart", p2), window.addEventListener("dragend", f), {
            destroy() {
              window.removeEventListener("dragstart", p2), window.removeEventListener("dragend", f);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (d, p2) => {
              if (i = r === d.dom.parentElement, a = p2, !i) {
                const f = ts;
                f && setTimeout(() => {
                  const h2 = f.state.selection;
                  h2 && f.commands.deleteRange({ from: h2.from, to: h2.to });
                }, 10);
              }
              return false;
            },
            paste: (d, p2) => {
              var f;
              const h2 = (f = p2.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
              return s = p2, o = !!(h2 != null && h2.includes("data-pm-slice")), false;
            }
          }
        },
        appendTransaction: (d, p2, f) => {
          const h2 = d[0], m = h2.getMeta("uiEvent") === "paste" && !o, g = h2.getMeta("uiEvent") === "drop" && !i, b = h2.getMeta("applyPasteRules"), E = !!b;
          if (!m && !g && !E)
            return;
          if (E) {
            let { text: T } = b;
            typeof T == "string" ? T = T : T = Wc(R.from(T), f.schema);
            const { from: S } = b, F = S + T.length, V = T0(T);
            return l({
              rule: u,
              state: f,
              from: S,
              to: { b: F },
              pasteEvt: V
            });
          }
          const _ = p2.doc.content.findDiffStart(f.doc.content), v = p2.doc.content.findDiffEnd(f.doc.content);
          if (!(!_0(_) || !v || _ === v.b))
            return l({
              rule: u,
              state: f,
              from: _,
              to: v,
              pasteEvt: s
            });
        }
      }));
    }
    function N0(t2) {
      const e = t2.filter((n, r) => t2.indexOf(n) !== r);
      return Array.from(new Set(e));
    }
    class To {
      constructor(e, n) {
        this.splittableMarks = [], this.editor = n, this.extensions = To.resolve(e), this.schema = y0(this.extensions, n), this.setupExtensions();
      }
      /**
       * Returns a flattened and sorted extension list while
       * also checking for duplicated extensions and warns the user.
       * @param extensions An array of Tiptap extensions
       * @returns An flattened and sorted array of Tiptap extensions
       */
      static resolve(e) {
        const n = To.sort(To.flatten(e)), r = N0(n.map((o) => o.name));
        return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((o) => `'${o}'`).join(", ")}]. This can lead to issues.`), n;
      }
      /**
       * Create a flattened array of extensions by traversing the `addExtensions` field.
       * @param extensions An array of Tiptap extensions
       * @returns A flattened array of Tiptap extensions
       */
      static flatten(e) {
        return e.map((n) => {
          const r = {
            name: n.name,
            options: n.options,
            storage: n.storage
          }, o = Z(n, "addExtensions", r);
          return o ? [n, ...this.flatten(o())] : n;
        }).flat(10);
      }
      /**
       * Sort extensions by priority.
       * @param extensions An array of Tiptap extensions
       * @returns A sorted array of Tiptap extensions by priority
       */
      static sort(e) {
        return e.sort((r, o) => {
          const i = Z(r, "priority") || 100, s = Z(o, "priority") || 100;
          return i > s ? -1 : i < s ? 1 : 0;
        });
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((e, n) => {
          const r = {
            name: n.name,
            options: n.options,
            storage: n.storage,
            editor: this.editor,
            type: ml(n.name, this.schema)
          }, o = Z(n, "addCommands", r);
          return o ? {
            ...e,
            ...o()
          } : e;
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor: e } = this, n = To.sort([...this.extensions].reverse()), r = [], o = [], i = n.map((s) => {
          const a = {
            name: s.name,
            options: s.options,
            storage: s.storage,
            editor: e,
            type: ml(s.name, this.schema)
          }, l = [], c2 = Z(s, "addKeyboardShortcuts", a);
          let u = {};
          if (s.type === "mark" && Z(s, "exitable", a) && (u.ArrowRight = () => _n.handleExit({ editor: e, mark: s })), c2) {
            const m = Object.fromEntries(Object.entries(c2()).map(([g, b]) => [g, () => b({ editor: e })]));
            u = { ...u, ...m };
          }
          const d = jv(u);
          l.push(d);
          const p2 = Z(s, "addInputRules", a);
          Bd(s, e.options.enableInputRules) && p2 && r.push(...p2());
          const f = Z(s, "addPasteRules", a);
          Bd(s, e.options.enablePasteRules) && f && o.push(...f());
          const h2 = Z(s, "addProseMirrorPlugins", a);
          if (h2) {
            const m = h2();
            l.push(...m);
          }
          return l;
        }).flat();
        return [
          k0({
            editor: e,
            rules: r
          }),
          ...O0({
            editor: e,
            rules: o
          }),
          ...i
        ];
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return Ih(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor: e } = this, { nodeExtensions: n } = Pa(this.extensions);
        return Object.fromEntries(n.filter((r) => !!Z(r, "addNodeView")).map((r) => {
          const o = this.attributes.filter((l) => l.type === r.name), i = {
            name: r.name,
            options: r.options,
            storage: r.storage,
            editor: e,
            type: Tt(r.name, this.schema)
          }, s = Z(r, "addNodeView", i);
          if (!s)
            return [];
          const a = (l, c2, u, d, p2) => {
            const f = Ql(l, o);
            return s()({
              // pass-through
              node: l,
              view: c2,
              getPos: u,
              decorations: d,
              innerDecorations: p2,
              // tiptap-specific
              editor: e,
              extension: r,
              HTMLAttributes: f
            });
          };
          return [r.name, a];
        }));
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        this.extensions.forEach((e) => {
          var n;
          this.editor.extensionStorage[e.name] = e.storage;
          const r = {
            name: e.name,
            options: e.options,
            storage: e.storage,
            editor: this.editor,
            type: ml(e.name, this.schema)
          };
          e.type === "mark" && (!((n = Te(Z(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
          const o = Z(e, "onBeforeCreate", r), i = Z(e, "onCreate", r), s = Z(e, "onUpdate", r), a = Z(e, "onSelectionUpdate", r), l = Z(e, "onTransaction", r), c2 = Z(e, "onFocus", r), u = Z(e, "onBlur", r), d = Z(e, "onDestroy", r);
          o && this.editor.on("beforeCreate", o), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c2 && this.editor.on("focus", c2), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
        });
      }
    }
    class Ke {
      constructor(e = {}) {
        this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new Ke(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new Ke({ ...this.config, ...e });
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
    }
    function Lh(t2, e, n) {
      const { from: r, to: o } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
      let a = "";
      return t2.nodesBetween(r, o, (l, c2, u, d) => {
        var p2;
        l.isBlock && c2 > r && (a += i);
        const f = s == null ? void 0 : s[l.type.name];
        if (f)
          return u && (a += f({
            node: l,
            pos: c2,
            parent: u,
            index: d,
            range: e
          })), false;
        l.isText && (a += (p2 = l == null ? void 0 : l.text) === null || p2 === void 0 ? void 0 : p2.slice(Math.max(r, c2) - c2, o - c2));
      }), a;
    }
    function qc(t2) {
      return Object.fromEntries(Object.entries(t2.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
    }
    const A0 = Ke.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor: t2 } = this, { state: e, schema: n } = t2, { doc: r, selection: o } = e, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = qc(n);
                return Lh(r, { from: s, to: a }, {
                  ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                  textSerializers: l
                });
              }
            }
          })
        ];
      }
    }), M0 = () => ({ editor: t2, view: e }) => (requestAnimationFrame(() => {
      var n;
      t2.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
    }), true), R0 = (t2 = false) => ({ commands: e }) => e.setContent("", t2), I0 = () => ({ state: t2, tr: e, dispatch: n }) => {
      const { selection: r } = e, { ranges: o } = r;
      return n && o.forEach(({ $from: i, $to: s }) => {
        t2.doc.nodesBetween(i.pos, s.pos, (a, l) => {
          if (a.type.isText)
            return;
          const { doc: c2, mapping: u } = e, d = c2.resolve(u.map(l)), p2 = c2.resolve(u.map(l + a.nodeSize)), f = d.blockRange(p2);
          if (!f)
            return;
          const h2 = Uo(f);
          if (a.type.isTextblock) {
            const { defaultType: m } = d.parent.contentMatchAt(d.index());
            e.setNodeMarkup(f.start, m);
          }
          (h2 || h2 === 0) && e.lift(f, h2);
        });
      }), true;
    }, D0 = (t2) => (e) => t2(e), L0 = () => ({ state: t2, dispatch: e }) => Nh(t2, e), P0 = (t2, e) => ({ editor: n, tr: r }) => {
      const { state: o } = n, i = o.doc.slice(t2.from, t2.to);
      r.deleteRange(t2.from, t2.to);
      const s = r.mapping.map(e);
      return r.insert(s, i.content), r.setSelection(new ie(r.doc.resolve(s - 1))), true;
    }, B0 = () => ({ tr: t2, dispatch: e }) => {
      const { selection: n } = t2, r = n.$anchor.node();
      if (r.content.size > 0)
        return false;
      const o = t2.selection.$anchor;
      for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
          if (e) {
            const a = o.before(i), l = o.after(i);
            t2.delete(a, l).scrollIntoView();
          }
          return true;
        }
      return false;
    }, $0 = (t2) => ({ tr: e, state: n, dispatch: r }) => {
      const o = Tt(t2, n.schema), i = e.selection.$anchor;
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o) {
          if (r) {
            const l = i.before(s), c2 = i.after(s);
            e.delete(l, c2).scrollIntoView();
          }
          return true;
        }
      return false;
    }, F0 = (t2) => ({ tr: e, dispatch: n }) => {
      const { from: r, to: o } = t2;
      return n && e.delete(r, o), true;
    }, z0 = () => ({ state: t2, dispatch: e }) => Fc(t2, e), H0 = () => ({ commands: t2 }) => t2.keyboardShortcut("Enter"), U0 = () => ({ state: t2, dispatch: e }) => e0(t2, e);
    function Vs(t2, e, n = { strict: true }) {
      const r = Object.keys(e);
      return r.length ? r.every((o) => n.strict ? e[o] === t2[o] : Kc(e[o]) ? e[o].test(t2[o]) : e[o] === t2[o]) : true;
    }
    function Ph(t2, e, n = {}) {
      return t2.find((r) => r.type === e && Vs(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
        n
      ));
    }
    function $d(t2, e, n = {}) {
      return !!Ph(t2, e, n);
    }
    function Vo(t2, e, n) {
      var r;
      if (!t2 || !e)
        return;
      let o = t2.parent.childAfter(t2.parentOffset);
      if ((!o.node || !o.node.marks.some((u) => u.type === e)) && (o = t2.parent.childBefore(t2.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === e) || (n = n || ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !Ph([...o.node.marks], e, n)))
        return;
      let s = o.index, a = t2.start() + o.offset, l = s + 1, c2 = a + o.node.nodeSize;
      for (; s > 0 && $d([...t2.parent.child(s - 1).marks], e, n); )
        s -= 1, a -= t2.parent.child(s).nodeSize;
      for (; l < t2.parent.childCount && $d([...t2.parent.child(l).marks], e, n); )
        c2 += t2.parent.child(l).nodeSize, l += 1;
      return {
        from: a,
        to: c2
      };
    }
    function Hr(t2, e) {
      if (typeof t2 == "string") {
        if (!e.marks[t2])
          throw Error(`There is no mark type named '${t2}'. Maybe you forgot to add the extension?`);
        return e.marks[t2];
      }
      return t2;
    }
    const V0 = (t2, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
      const i = Hr(t2, r.schema), { doc: s, selection: a } = n, { $from: l, from: c2, to: u } = a;
      if (o) {
        const d = Vo(l, i, e);
        if (d && d.from <= c2 && d.to >= u) {
          const p2 = ie.create(s, d.from, d.to);
          n.setSelection(p2);
        }
      }
      return true;
    }, W0 = (t2) => (e) => {
      const n = typeof t2 == "function" ? t2(e) : t2;
      for (let r = 0; r < n.length; r += 1)
        if (n[r](e))
          return true;
      return false;
    };
    function $a(t2) {
      return t2 instanceof ie;
    }
    function cr(t2 = 0, e = 0, n = 0) {
      return Math.min(Math.max(t2, e), n);
    }
    function Bh(t2, e = null) {
      if (!e)
        return null;
      const n = ue.atStart(t2), r = ue.atEnd(t2);
      if (e === "start" || e === true)
        return n;
      if (e === "end")
        return r;
      const o = n.from, i = r.to;
      return e === "all" ? ie.create(t2, cr(0, o, i), cr(t2.content.size, o, i)) : ie.create(t2, cr(e, o, i), cr(e, o, i));
    }
    function $h() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function Fa() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    const K0 = (t2 = null, e = {}) => ({ editor: n, view: r, tr: o, dispatch: i }) => {
      e = {
        scrollIntoView: true,
        ...e
      };
      const s = () => {
        (Fa() || $h()) && r.dom.focus(), requestAnimationFrame(() => {
          n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
        });
      };
      if (r.hasFocus() && t2 === null || t2 === false)
        return true;
      if (i && t2 === null && !$a(n.state.selection))
        return s(), true;
      const a = Bh(o.doc, t2) || n.state.selection, l = n.state.selection.eq(a);
      return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), true;
    }, q0 = (t2, e) => (n) => t2.every((r, o) => e(r, { ...n, index: o })), G0 = (t2, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t2, e), Fh = (t2) => {
      const e = t2.childNodes;
      for (let n = e.length - 1; n >= 0; n -= 1) {
        const r = e[n];
        r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t2.removeChild(r) : r.nodeType === 1 && Fh(r);
      }
      return t2;
    };
    function ns(t2) {
      const e = `<body>${t2}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
      return Fh(n);
    }
    function Ws(t2, e, n) {
      if (t2 instanceof Mr || t2 instanceof R)
        return t2;
      n = {
        slice: true,
        parseOptions: {},
        ...n
      };
      const r = typeof t2 == "object" && t2 !== null, o = typeof t2 == "string";
      if (r)
        try {
          if (Array.isArray(t2) && t2.length > 0)
            return R.fromArray(t2.map((a) => e.nodeFromJSON(a)));
          const s = e.nodeFromJSON(t2);
          return n.errorOnInvalidContent && s.check(), s;
        } catch (i) {
          if (n.errorOnInvalidContent)
            throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
          return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t2, "Error:", i), Ws("", e, n);
        }
      if (o) {
        if (n.errorOnInvalidContent) {
          let s = false, a = "";
          const l = new _f({
            topNode: e.spec.topNode,
            marks: e.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: e.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (c2) => (s = true, a = typeof c2 == "string" ? c2 : c2.outerHTML, null)
                  }
                ]
              }
            })
          });
          if (n.slice ? Rr.fromSchema(l).parseSlice(ns(t2), n.parseOptions) : Rr.fromSchema(l).parse(ns(t2), n.parseOptions), n.errorOnInvalidContent && s)
            throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
        }
        const i = Rr.fromSchema(e);
        return n.slice ? i.parseSlice(ns(t2), n.parseOptions).content : i.parse(ns(t2), n.parseOptions);
      }
      return Ws("", e, n);
    }
    function j0(t2, e, n) {
      const r = t2.steps.length - 1;
      if (r < e)
        return;
      const o = t2.steps[r];
      if (!(o instanceof St || o instanceof Ct))
        return;
      const i = t2.mapping.maps[r];
      let s = 0;
      i.forEach((a, l, c2, u) => {
        s === 0 && (s = u);
      }), t2.setSelection(ue.near(t2.doc.resolve(s), n));
    }
    const Y0 = (t2) => !("type" in t2), J0 = (t2, e, n) => ({ tr: r, dispatch: o, editor: i }) => {
      var s;
      if (o) {
        n = {
          parseOptions: i.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false,
          ...n
        };
        let a;
        try {
          a = Ws(e, i.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...n.parseOptions
            },
            errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : i.options.enableContentCheck
          });
        } catch (h2) {
          return i.emit("contentError", {
            editor: i,
            error: h2,
            disableCollaboration: () => {
              i.storage.collaboration && (i.storage.collaboration.isDisabled = true);
            }
          }), false;
        }
        let { from: l, to: c2 } = typeof t2 == "number" ? { from: t2, to: t2 } : { from: t2.from, to: t2.to }, u = true, d = true;
        if ((Y0(a) ? a : [a]).forEach((h2) => {
          h2.check(), u = u ? h2.isText && h2.marks.length === 0 : false, d = d ? h2.isBlock : false;
        }), l === c2 && d) {
          const { parent: h2 } = r.doc.resolve(l);
          h2.isTextblock && !h2.type.spec.code && !h2.childCount && (l -= 1, c2 += 1);
        }
        let f;
        if (u) {
          if (Array.isArray(e))
            f = e.map((h2) => h2.text || "").join("");
          else if (e instanceof R) {
            let h2 = "";
            e.forEach((m) => {
              m.text && (h2 += m.text);
            }), f = h2;
          } else typeof e == "object" && e && e.text ? f = e.text : f = e;
          r.insertText(f, l, c2);
        } else
          f = a, r.replaceWith(l, c2, f);
        n.updateSelection && j0(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: l, text: f }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: f });
      }
      return true;
    }, X0 = () => ({ state: t2, dispatch: e }) => Xv(t2, e), Z0 = () => ({ state: t2, dispatch: e }) => Zv(t2, e), Q0 = () => ({ state: t2, dispatch: e }) => wh(t2, e), eE = () => ({ state: t2, dispatch: e }) => xh(t2, e), tE = () => ({ state: t2, dispatch: e, tr: n }) => {
      try {
        const r = Oa(t2.doc, t2.selection.$from.pos, -1);
        return r == null ? false : (n.join(r, 2), e && e(n), true);
      } catch {
        return false;
      }
    }, nE = () => ({ state: t2, dispatch: e, tr: n }) => {
      try {
        const r = Oa(t2.doc, t2.selection.$from.pos, 1);
        return r == null ? false : (n.join(r, 2), e && e(n), true);
      } catch {
        return false;
      }
    }, rE = () => ({ state: t2, dispatch: e }) => Yv(t2, e), oE = () => ({ state: t2, dispatch: e }) => Jv(t2, e);
    function zh() {
      return typeof navigator < "u" ? /Mac/.test(navigator.platform) : false;
    }
    function iE(t2) {
      const e = t2.split(/-(?!$)/);
      let n = e[e.length - 1];
      n === "Space" && (n = " ");
      let r, o, i, s;
      for (let a = 0; a < e.length - 1; a += 1) {
        const l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          s = true;
        else if (/^a(lt)?$/i.test(l))
          r = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          o = true;
        else if (/^s(hift)?$/i.test(l))
          i = true;
        else if (/^mod$/i.test(l))
          Fa() || zh() ? s = true : o = true;
        else
          throw new Error(`Unrecognized modifier name: ${l}`);
      }
      return r && (n = `Alt-${n}`), o && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
    }
    const sE = (t2) => ({ editor: e, view: n, tr: r, dispatch: o }) => {
      const i = iE(t2).split(/-(?!$)/), s = i.find((c2) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c2)), a = new KeyboardEvent("keydown", {
        key: s === "Space" ? " " : s,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: true,
        cancelable: true
      }), l = e.captureTransaction(() => {
        n.someProp("handleKeyDown", (c2) => c2(n, a));
      });
      return l == null || l.steps.forEach((c2) => {
        const u = c2.map(r.mapping);
        u && o && r.maybeStep(u);
      }), true;
    };
    function Si(t2, e, n = {}) {
      const { from: r, to: o, empty: i } = t2.selection, s = e ? Tt(e, t2.schema) : null, a = [];
      t2.doc.nodesBetween(r, o, (d, p2) => {
        if (d.isText)
          return;
        const f = Math.max(r, p2), h2 = Math.min(o, p2 + d.nodeSize);
        a.push({
          node: d,
          from: f,
          to: h2
        });
      });
      const l = o - r, c2 = a.filter((d) => s ? s.name === d.node.type.name : true).filter((d) => Vs(d.node.attrs, n, { strict: false }));
      return i ? !!c2.length : c2.reduce((d, p2) => d + p2.to - p2.from, 0) >= l;
    }
    const aE = (t2, e = {}) => ({ state: n, dispatch: r }) => {
      const o = Tt(t2, n.schema);
      return Si(n, o, e) ? Qv(n, r) : false;
    }, lE = () => ({ state: t2, dispatch: e }) => Ah(t2, e), cE = (t2) => ({ state: e, dispatch: n }) => {
      const r = Tt(t2, e.schema);
      return d0(r)(e, n);
    }, uE = () => ({ state: t2, dispatch: e }) => Oh(t2, e);
    function za(t2, e) {
      return e.nodes[t2] ? "node" : e.marks[t2] ? "mark" : null;
    }
    function Fd(t2, e) {
      const n = typeof e == "string" ? [e] : e;
      return Object.keys(t2).reduce((r, o) => (n.includes(o) || (r[o] = t2[o]), r), {});
    }
    const dE = (t2, e) => ({ tr: n, state: r, dispatch: o }) => {
      let i = null, s = null;
      const a = za(typeof t2 == "string" ? t2 : t2.name, r.schema);
      return a ? (a === "node" && (i = Tt(t2, r.schema)), a === "mark" && (s = Hr(t2, r.schema)), o && n.selection.ranges.forEach((l) => {
        r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c2, u) => {
          i && i === c2.type && n.setNodeMarkup(u, void 0, Fd(c2.attrs, e)), s && c2.marks.length && c2.marks.forEach((d) => {
            s === d.type && n.addMark(u, u + c2.nodeSize, s.create(Fd(d.attrs, e)));
          });
        });
      }), true) : false;
    }, pE = () => ({ tr: t2, dispatch: e }) => (e && t2.scrollIntoView(), true), fE = () => ({ tr: t2, dispatch: e }) => {
      if (e) {
        const n = new pn(t2.doc);
        t2.setSelection(n);
      }
      return true;
    }, hE = () => ({ state: t2, dispatch: e }) => Sh(t2, e), mE = () => ({ state: t2, dispatch: e }) => Th(t2, e), gE = () => ({ state: t2, dispatch: e }) => r0(t2, e), bE = () => ({ state: t2, dispatch: e }) => s0(t2, e), yE = () => ({ state: t2, dispatch: e }) => i0(t2, e);
    function ec(t2, e, n = {}, r = {}) {
      return Ws(t2, e, {
        slice: false,
        parseOptions: n,
        errorOnInvalidContent: r.errorOnInvalidContent
      });
    }
    const vE = (t2, e = false, n = {}, r = {}) => ({ editor: o, tr: i, dispatch: s, commands: a }) => {
      var l, c2;
      const { doc: u } = i;
      if (n.preserveWhitespace !== "full") {
        const d = ec(t2, o.schema, n, {
          errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : o.options.enableContentCheck
        });
        return s && i.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), true;
      }
      return s && i.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t2, {
        parseOptions: n,
        errorOnInvalidContent: (c2 = r.errorOnInvalidContent) !== null && c2 !== void 0 ? c2 : o.options.enableContentCheck
      });
    };
    function Hh(t2, e) {
      const n = Hr(e, t2.schema), { from: r, to: o, empty: i } = t2.selection, s = [];
      i ? (t2.storedMarks && s.push(...t2.storedMarks), s.push(...t2.selection.$head.marks())) : t2.doc.nodesBetween(r, o, (l) => {
        s.push(...l.marks);
      });
      const a = s.find((l) => l.type.name === n.name);
      return a ? { ...a.attrs } : {};
    }
    function EE(t2, e) {
      const n = new Tc(t2);
      return e.forEach((r) => {
        r.steps.forEach((o) => {
          n.step(o);
        });
      }), n;
    }
    function kE(t2) {
      for (let e = 0; e < t2.edgeCount; e += 1) {
        const { type: n } = t2.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
          return n;
      }
      return null;
    }
    function tc(t2, e) {
      const n = [];
      return t2.descendants((r, o) => {
        e(r) && n.push({
          node: r,
          pos: o
        });
      }), n;
    }
    function wE(t2, e, n) {
      const r = [];
      return t2.nodesBetween(e.from, e.to, (o, i) => {
        n(o) && r.push({
          node: o,
          pos: i
        });
      }), r;
    }
    function Uh(t2, e) {
      for (let n = t2.depth; n > 0; n -= 1) {
        const r = t2.node(n);
        if (e(r))
          return {
            pos: n > 0 ? t2.before(n) : 0,
            start: t2.start(n),
            depth: n,
            node: r
          };
      }
    }
    function Gc(t2) {
      return (e) => Uh(e.$from, t2);
    }
    function Vh(t2, e) {
      const n = {
        from: 0,
        to: t2.content.size
      };
      return Lh(t2, n, e);
    }
    function _E(t2, e) {
      const n = Tt(e, t2.schema), { from: r, to: o } = t2.selection, i = [];
      t2.doc.nodesBetween(r, o, (a) => {
        i.push(a);
      });
      const s = i.reverse().find((a) => a.type.name === n.name);
      return s ? { ...s.attrs } : {};
    }
    function Wh(t2, e) {
      const n = za(typeof e == "string" ? e : e.name, t2.schema);
      return n === "node" ? _E(t2, e) : n === "mark" ? Hh(t2, e) : {};
    }
    function SE(t2, e = JSON.stringify) {
      const n = {};
      return t2.filter((r) => {
        const o = e(r);
        return Object.prototype.hasOwnProperty.call(n, o) ? false : n[o] = true;
      });
    }
    function CE(t2) {
      const e = SE(t2);
      return e.length === 1 ? e : e.filter((n, r) => !e.filter((i, s) => s !== r).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
    }
    function xE(t2) {
      const { mapping: e, steps: n } = t2, r = [];
      return e.maps.forEach((o, i) => {
        const s = [];
        if (o.ranges.length)
          o.forEach((a, l) => {
            s.push({ from: a, to: l });
          });
        else {
          const { from: a, to: l } = n[i];
          if (a === void 0 || l === void 0)
            return;
          s.push({ from: a, to: l });
        }
        s.forEach(({ from: a, to: l }) => {
          const c2 = e.slice(i).map(a, -1), u = e.slice(i).map(l), d = e.invert().map(c2, -1), p2 = e.invert().map(u);
          r.push({
            oldRange: {
              from: d,
              to: p2
            },
            newRange: {
              from: c2,
              to: u
            }
          });
        });
      }), CE(r);
    }
    function jc(t2, e, n) {
      const r = [];
      return t2 === e ? n.resolve(t2).marks().forEach((o) => {
        const i = n.resolve(t2), s = Vo(i, o.type);
        s && r.push({
          mark: o,
          ...s
        });
      }) : n.nodesBetween(t2, e, (o, i) => {
        !o || (o == null ? void 0 : o.nodeSize) === void 0 || r.push(...o.marks.map((s) => ({
          from: i,
          to: i + o.nodeSize,
          mark: s
        })));
      }), r;
    }
    function Cs(t2, e, n) {
      return Object.fromEntries(Object.entries(n).filter(([r]) => {
        const o = t2.find((i) => i.type === e && i.name === r);
        return o ? o.attribute.keepOnSplit : false;
      }));
    }
    function nc(t2, e, n = {}) {
      const { empty: r, ranges: o } = t2.selection, i = e ? Hr(e, t2.schema) : null;
      if (r)
        return !!(t2.storedMarks || t2.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : true).find((d) => Vs(d.attrs, n, { strict: false }));
      let s = 0;
      const a = [];
      if (o.forEach(({ $from: d, $to: p2 }) => {
        const f = d.pos, h2 = p2.pos;
        t2.doc.nodesBetween(f, h2, (m, g) => {
          if (!m.isText && !m.marks.length)
            return;
          const b = Math.max(f, g), E = Math.min(h2, g + m.nodeSize), _ = E - b;
          s += _, a.push(...m.marks.map((v) => ({
            mark: v,
            from: b,
            to: E
          })));
        });
      }), s === 0)
        return false;
      const l = a.filter((d) => i ? i.name === d.mark.type.name : true).filter((d) => Vs(d.mark.attrs, n, { strict: false })).reduce((d, p2) => d + p2.to - p2.from, 0), c2 = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : true).reduce((d, p2) => d + p2.to - p2.from, 0);
      return (l > 0 ? l + c2 : l) >= s;
    }
    function TE(t2, e, n = {}) {
      if (!e)
        return Si(t2, null, n) || nc(t2, null, n);
      const r = za(e, t2.schema);
      return r === "node" ? Si(t2, e, n) : r === "mark" ? nc(t2, e, n) : false;
    }
    function zd(t2, e) {
      const { nodeExtensions: n } = Pa(e), r = n.find((s) => s.name === t2);
      if (!r)
        return false;
      const o = {
        name: r.name,
        options: r.options,
        storage: r.storage
      }, i = Te(Z(r, "group", o));
      return typeof i != "string" ? false : i.split(" ").includes("list");
    }
    function Yc(t2, { checkChildren: e = true, ignoreWhitespace: n = false } = {}) {
      var r;
      if (n) {
        if (t2.type.name === "hardBreak")
          return true;
        if (t2.isText)
          return /^\s*$/m.test((r = t2.text) !== null && r !== void 0 ? r : "");
      }
      if (t2.isText)
        return !t2.text;
      if (t2.isAtom || t2.isLeaf)
        return false;
      if (t2.content.childCount === 0)
        return true;
      if (e) {
        let o = true;
        return t2.content.forEach((i) => {
          o !== false && (Yc(i, { ignoreWhitespace: n, checkChildren: e }) || (o = false));
        }), o;
      }
      return false;
    }
    function Kh(t2) {
      return t2 instanceof re;
    }
    function qh(t2, e, n) {
      const o = t2.state.doc.content.size, i = cr(e, 0, o), s = cr(n, 0, o), a = t2.coordsAtPos(i), l = t2.coordsAtPos(s, -1), c2 = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), p2 = Math.max(a.right, l.right), f = p2 - d, h2 = u - c2, b = {
        top: c2,
        bottom: u,
        left: d,
        right: p2,
        width: f,
        height: h2,
        x: d,
        y: c2
      };
      return {
        ...b,
        toJSON: () => b
      };
    }
    function OE(t2, e, n) {
      var r;
      const { selection: o } = e;
      let i = null;
      if ($a(o) && (i = o.$cursor), i) {
        const a = (r = t2.storedMarks) !== null && r !== void 0 ? r : i.marks();
        return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
      }
      const { ranges: s } = o;
      return s.some(({ $from: a, $to: l }) => {
        let c2 = a.depth === 0 ? t2.doc.inlineContent && t2.doc.type.allowsMarkType(n) : false;
        return t2.doc.nodesBetween(a.pos, l.pos, (u, d, p2) => {
          if (c2)
            return false;
          if (u.isInline) {
            const f = !p2 || p2.type.allowsMarkType(n), h2 = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n));
            c2 = f && h2;
          }
          return !c2;
        }), c2;
      });
    }
    const NE = (t2, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
      const { selection: i } = n, { empty: s, ranges: a } = i, l = Hr(t2, r.schema);
      if (o)
        if (s) {
          const c2 = Hh(r, l);
          n.addStoredMark(l.create({
            ...c2,
            ...e
          }));
        } else
          a.forEach((c2) => {
            const u = c2.$from.pos, d = c2.$to.pos;
            r.doc.nodesBetween(u, d, (p2, f) => {
              const h2 = Math.max(f, u), m = Math.min(f + p2.nodeSize, d);
              p2.marks.find((b) => b.type === l) ? p2.marks.forEach((b) => {
                l === b.type && n.addMark(h2, m, l.create({
                  ...b.attrs,
                  ...e
                }));
              }) : n.addMark(h2, m, l.create(e));
            });
          });
      return OE(r, n, l);
    }, AE = (t2, e) => ({ tr: n }) => (n.setMeta(t2, e), true), ME = (t2, e = {}) => ({ state: n, dispatch: r, chain: o }) => {
      const i = Tt(t2, n.schema);
      let s;
      return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: a }) => Dd(i, { ...s, ...e })(n) ? true : a.clearNodes()).command(({ state: a }) => Dd(i, { ...s, ...e })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), false);
    }, RE = (t2) => ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e, o = cr(t2, 0, r.content.size), i = re.create(r, o);
        e.setSelection(i);
      }
      return true;
    }, IE = (t2) => ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: r } = e, { from: o, to: i } = typeof t2 == "number" ? { from: t2, to: t2 } : t2, s = ie.atStart(r).from, a = ie.atEnd(r).to, l = cr(o, s, a), c2 = cr(i, s, a), u = ie.create(r, l, c2);
        e.setSelection(u);
      }
      return true;
    }, DE = (t2) => ({ state: e, dispatch: n }) => {
      const r = Tt(t2, e.schema);
      return h0(r)(e, n);
    };
    function Hd(t2, e) {
      const n = t2.storedMarks || t2.selection.$to.parentOffset && t2.selection.$from.marks();
      if (n) {
        const r = n.filter((o) => e == null ? void 0 : e.includes(o.type.name));
        t2.tr.ensureMarks(r);
      }
    }
    const LE = ({ keepMarks: t2 = true } = {}) => ({ tr: e, state: n, dispatch: r, editor: o }) => {
      const { selection: i, doc: s } = e, { $from: a, $to: l } = i, c2 = o.extensionManager.attributes, u = Cs(c2, a.node().type.name, a.node().attrs);
      if (i instanceof re && i.node.isBlock)
        return !a.parentOffset || !ur(s, a.pos) ? false : (r && (t2 && Hd(n, o.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), true);
      if (!a.parent.isBlock)
        return false;
      const d = l.parentOffset === l.parent.content.size, p2 = a.depth === 0 ? void 0 : kE(a.node(-1).contentMatchAt(a.indexAfter(-1)));
      let f = d && p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0, h2 = ur(e.doc, e.mapping.map(a.pos), 1, f);
      if (!f && !h2 && ur(e.doc, e.mapping.map(a.pos), 1, p2 ? [{ type: p2 }] : void 0) && (h2 = true, f = p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0), r) {
        if (h2 && (i instanceof ie && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, f), p2 && !d && !a.parentOffset && a.parent.type !== p2)) {
          const m = e.mapping.map(a.before()), g = e.doc.resolve(m);
          a.node(-1).canReplaceWith(g.index(), g.index() + 1, p2) && e.setNodeMarkup(e.mapping.map(a.before()), p2);
        }
        t2 && Hd(n, o.extensionManager.splittableMarks), e.scrollIntoView();
      }
      return h2;
    }, PE = (t2, e = {}) => ({ tr: n, state: r, dispatch: o, editor: i }) => {
      var s;
      const a = Tt(t2, r.schema), { $from: l, $to: c2 } = r.selection, u = r.selection.node;
      if (u && u.isBlock || l.depth < 2 || !l.sameParent(c2))
        return false;
      const d = l.node(-1);
      if (d.type !== a)
        return false;
      const p2 = i.extensionManager.attributes;
      if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
        if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
          return false;
        if (o) {
          let b = R.empty;
          const E = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
          for (let V = l.depth - E; V >= l.depth - 3; V -= 1)
            b = R.from(l.node(V).copy(b));
          const _ = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
            ...Cs(p2, l.node().type.name, l.node().attrs),
            ...e
          }, T = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(v)) || void 0;
          b = b.append(R.from(a.createAndFill(null, T) || void 0));
          const S = l.before(l.depth - (E - 1));
          n.replace(S, l.after(-_), new K(b, 4 - E, 0));
          let F = -1;
          n.doc.nodesBetween(S, n.doc.content.size, (V, L) => {
            if (F > -1)
              return false;
            V.isTextblock && V.content.size === 0 && (F = L + 1);
          }), F > -1 && n.setSelection(ie.near(n.doc.resolve(F))), n.scrollIntoView();
        }
        return true;
      }
      const f = c2.pos === l.end() ? d.contentMatchAt(0).defaultType : null, h2 = {
        ...Cs(p2, d.type.name, d.attrs),
        ...e
      }, m = {
        ...Cs(p2, l.node().type.name, l.node().attrs),
        ...e
      };
      n.delete(l.pos, c2.pos);
      const g = f ? [
        { type: a, attrs: h2 },
        { type: f, attrs: m }
      ] : [{ type: a, attrs: h2 }];
      if (!ur(n.doc, l.pos, 2))
        return false;
      if (o) {
        const { selection: b, storedMarks: E } = r, { splittableMarks: _ } = i.extensionManager, v = E || b.$to.parentOffset && b.$from.marks();
        if (n.split(l.pos, 2, g).scrollIntoView(), !v || !o)
          return true;
        const T = v.filter((S) => _.includes(S.type.name));
        n.ensureMarks(T);
      }
      return true;
    }, gl = (t2, e) => {
      const n = Gc((s) => s.type === e)(t2.selection);
      if (!n)
        return true;
      const r = t2.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
      if (r === void 0)
        return true;
      const o = t2.doc.nodeAt(r);
      return n.node.type === (o == null ? void 0 : o.type) && Fr(t2.doc, n.pos) && t2.join(n.pos), true;
    }, bl = (t2, e) => {
      const n = Gc((s) => s.type === e)(t2.selection);
      if (!n)
        return true;
      const r = t2.doc.resolve(n.start).after(n.depth);
      if (r === void 0)
        return true;
      const o = t2.doc.nodeAt(r);
      return n.node.type === (o == null ? void 0 : o.type) && Fr(t2.doc, r) && t2.join(r), true;
    }, BE = (t2, e, n, r = {}) => ({ editor: o, tr: i, state: s, dispatch: a, chain: l, commands: c2, can: u }) => {
      const { extensions: d, splittableMarks: p2 } = o.extensionManager, f = Tt(t2, s.schema), h2 = Tt(e, s.schema), { selection: m, storedMarks: g } = s, { $from: b, $to: E } = m, _ = b.blockRange(E), v = g || m.$to.parentOffset && m.$from.marks();
      if (!_)
        return false;
      const T = Gc((S) => zd(S.type.name, d))(m);
      if (_.depth >= 1 && T && _.depth - T.depth <= 1) {
        if (T.node.type === f)
          return c2.liftListItem(h2);
        if (zd(T.node.type.name, d) && f.validContent(T.node.content) && a)
          return l().command(() => (i.setNodeMarkup(T.pos, f), true)).command(() => gl(i, f)).command(() => bl(i, f)).run();
      }
      return !n || !v || !a ? l().command(() => u().wrapInList(f, r) ? true : c2.clearNodes()).wrapInList(f, r).command(() => gl(i, f)).command(() => bl(i, f)).run() : l().command(() => {
        const S = u().wrapInList(f, r), F = v.filter((V) => p2.includes(V.type.name));
        return i.ensureMarks(F), S ? true : c2.clearNodes();
      }).wrapInList(f, r).command(() => gl(i, f)).command(() => bl(i, f)).run();
    }, $E = (t2, e = {}, n = {}) => ({ state: r, commands: o }) => {
      const { extendEmptyMarkRange: i = false } = n, s = Hr(t2, r.schema);
      return nc(r, s, e) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, e);
    }, FE = (t2, e, n = {}) => ({ state: r, commands: o }) => {
      const i = Tt(t2, r.schema), s = Tt(e, r.schema), a = Si(r, i, n);
      let l;
      return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n });
    }, zE = (t2, e = {}) => ({ state: n, commands: r }) => {
      const o = Tt(t2, n.schema);
      return Si(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
    }, HE = () => ({ state: t2, dispatch: e }) => {
      const n = t2.plugins;
      for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        let i;
        if (o.spec.isInputRules && (i = o.getState(t2))) {
          if (e) {
            const s = t2.tr, a = i.transform;
            for (let l = a.steps.length - 1; l >= 0; l -= 1)
              s.step(a.steps[l].invert(a.docs[l]));
            if (i.text) {
              const l = s.doc.resolve(i.from).marks();
              s.replaceWith(i.from, i.to, t2.schema.text(i.text, l));
            } else
              s.delete(i.from, i.to);
          }
          return true;
        }
      }
      return false;
    }, UE = () => ({ tr: t2, dispatch: e }) => {
      const { selection: n } = t2, { empty: r, ranges: o } = n;
      return r || e && o.forEach((i) => {
        t2.removeMark(i.$from.pos, i.$to.pos);
      }), true;
    }, VE = (t2, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
      var i;
      const { extendEmptyMarkRange: s = false } = e, { selection: a } = n, l = Hr(t2, r.schema), { $from: c2, empty: u, ranges: d } = a;
      if (!o)
        return true;
      if (u && s) {
        let { from: p2, to: f } = a;
        const h2 = (i = c2.marks().find((g) => g.type === l)) === null || i === void 0 ? void 0 : i.attrs, m = Vo(c2, l, h2);
        m && (p2 = m.from, f = m.to), n.removeMark(p2, f, l);
      } else
        d.forEach((p2) => {
          n.removeMark(p2.$from.pos, p2.$to.pos, l);
        });
      return n.removeStoredMark(l), true;
    }, WE = (t2, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
      let i = null, s = null;
      const a = za(typeof t2 == "string" ? t2 : t2.name, r.schema);
      return a ? (a === "node" && (i = Tt(t2, r.schema)), a === "mark" && (s = Hr(t2, r.schema)), o && n.selection.ranges.forEach((l) => {
        const c2 = l.$from.pos, u = l.$to.pos;
        let d, p2, f, h2;
        n.selection.empty ? r.doc.nodesBetween(c2, u, (m, g) => {
          i && i === m.type && (f = Math.max(g, c2), h2 = Math.min(g + m.nodeSize, u), d = g, p2 = m);
        }) : r.doc.nodesBetween(c2, u, (m, g) => {
          g < c2 && i && i === m.type && (f = Math.max(g, c2), h2 = Math.min(g + m.nodeSize, u), d = g, p2 = m), g >= c2 && g <= u && (i && i === m.type && n.setNodeMarkup(g, void 0, {
            ...m.attrs,
            ...e
          }), s && m.marks.length && m.marks.forEach((b) => {
            if (s === b.type) {
              const E = Math.max(g, c2), _ = Math.min(g + m.nodeSize, u);
              n.addMark(E, _, s.create({
                ...b.attrs,
                ...e
              }));
            }
          }));
        }), p2 && (d !== void 0 && n.setNodeMarkup(d, void 0, {
          ...p2.attrs,
          ...e
        }), s && p2.marks.length && p2.marks.forEach((m) => {
          s === m.type && n.addMark(f, h2, s.create({
            ...m.attrs,
            ...e
          }));
        }));
      }), true) : false;
    }, KE = (t2, e = {}) => ({ state: n, dispatch: r }) => {
      const o = Tt(t2, n.schema);
      return a0(o, e)(n, r);
    }, qE = (t2, e = {}) => ({ state: n, dispatch: r }) => {
      const o = Tt(t2, n.schema);
      return l0(o, e)(n, r);
    };
    var GE = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur: M0,
      clearContent: R0,
      clearNodes: I0,
      command: D0,
      createParagraphNear: L0,
      cut: P0,
      deleteCurrentNode: B0,
      deleteNode: $0,
      deleteRange: F0,
      deleteSelection: z0,
      enter: H0,
      exitCode: U0,
      extendMarkRange: V0,
      first: W0,
      focus: K0,
      forEach: q0,
      insertContent: G0,
      insertContentAt: J0,
      joinBackward: Q0,
      joinDown: Z0,
      joinForward: eE,
      joinItemBackward: tE,
      joinItemForward: nE,
      joinTextblockBackward: rE,
      joinTextblockForward: oE,
      joinUp: X0,
      keyboardShortcut: sE,
      lift: aE,
      liftEmptyBlock: lE,
      liftListItem: cE,
      newlineInCode: uE,
      resetAttributes: dE,
      scrollIntoView: pE,
      selectAll: fE,
      selectNodeBackward: hE,
      selectNodeForward: mE,
      selectParentNode: gE,
      selectTextblockEnd: bE,
      selectTextblockStart: yE,
      setContent: vE,
      setMark: NE,
      setMeta: AE,
      setNode: ME,
      setNodeSelection: RE,
      setTextSelection: IE,
      sinkListItem: DE,
      splitBlock: LE,
      splitListItem: PE,
      toggleList: BE,
      toggleMark: $E,
      toggleNode: FE,
      toggleWrap: zE,
      undoInputRule: HE,
      unsetAllMarks: UE,
      unsetMark: VE,
      updateAttributes: WE,
      wrapIn: KE,
      wrapInList: qE
    });
    const jE = Ke.create({
      name: "commands",
      addCommands() {
        return {
          ...GE
        };
      }
    }), YE = Ke.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("tiptapDrop"),
            props: {
              handleDrop: (t2, e, n, r) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice: n,
                  moved: r
                });
              }
            }
          })
        ];
      }
    }), JE = Ke.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    }), XE = Ke.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor: t2 } = this;
        return [
          new Ue({
            key: new Je("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (e, n) => {
                  t2.isFocused = true;
                  const r = t2.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", false);
                  return e.dispatch(r), false;
                },
                blur: (e, n) => {
                  t2.isFocused = false;
                  const r = t2.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", false);
                  return e.dispatch(r), false;
                }
              }
            }
          })
        ];
      }
    }), ZE = Ke.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const t2 = () => this.editor.commands.first(({ commands: s }) => [
          () => s.undoInputRule(),
          // maybe convert first text block node to default node
          () => s.command(({ tr: a }) => {
            const { selection: l, doc: c2 } = a, { empty: u, $anchor: d } = l, { pos: p2, parent: f } = d, h2 = d.parent.isTextblock && p2 > 0 ? a.doc.resolve(p2 - 1) : d, m = h2.parent.type.spec.isolating, g = d.pos - d.parentOffset, b = m && h2.parent.childCount === 1 ? g === d.pos : ue.atStart(c2).from === p2;
            return !u || !f.type.isTextblock || f.textContent.length || !b || b && d.parent.type.name === "paragraph" ? false : s.clearNodes();
          }),
          () => s.deleteSelection(),
          () => s.joinBackward(),
          () => s.selectNodeBackward()
        ]), e = () => this.editor.commands.first(({ commands: s }) => [
          () => s.deleteSelection(),
          () => s.deleteCurrentNode(),
          () => s.joinForward(),
          () => s.selectNodeForward()
        ]), r = {
          Enter: () => this.editor.commands.first(({ commands: s }) => [
            () => s.newlineInCode(),
            () => s.createParagraphNear(),
            () => s.liftEmptyBlock(),
            () => s.splitBlock()
          ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: t2,
          "Mod-Backspace": t2,
          "Shift-Backspace": t2,
          Delete: e,
          "Mod-Delete": e,
          "Mod-a": () => this.editor.commands.selectAll()
        }, o = {
          ...r
        }, i = {
          ...r,
          "Ctrl-h": t2,
          "Alt-Backspace": t2,
          "Ctrl-d": e,
          "Ctrl-Alt-Backspace": e,
          "Alt-Delete": e,
          "Alt-d": e,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return Fa() || zh() ? i : o;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
          // with many other commands.
          new Ue({
            key: new Je("clearDocument"),
            appendTransaction: (t2, e, n) => {
              if (t2.some((m) => m.getMeta("composition")))
                return;
              const r = t2.some((m) => m.docChanged) && !e.doc.eq(n.doc), o = t2.some((m) => m.getMeta("preventClearDocument"));
              if (!r || o)
                return;
              const { empty: i, from: s, to: a } = e.selection, l = ue.atStart(e.doc).from, c2 = ue.atEnd(e.doc).to;
              if (i || !(s === l && a === c2) || !Yc(n.doc))
                return;
              const p2 = n.tr, f = Da({
                state: n,
                transaction: p2
              }), { commands: h2 } = new La({
                editor: this.editor,
                state: f
              });
              if (h2.clearNodes(), !!p2.steps.length)
                return p2;
            }
          })
        ];
      }
    }), QE = Ke.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("tiptapPaste"),
            props: {
              handlePaste: (t2, e, n) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice: n
                });
              }
            }
          })
        ];
      }
    }), ek = Ke.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    class Gr {
      get name() {
        return this.node.type.name;
      }
      constructor(e, n, r = false, o = null) {
        this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = o;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var e;
        return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(e) {
        let n = this.from, r = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          n = this.from + 1, r = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from: n, to: r }, e);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0)
          return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
        return new Gr(n, this.editor);
      }
      get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Gr(e, this.editor);
      }
      get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Gr(e, this.editor);
      }
      get children() {
        const e = [];
        return this.node.content.forEach((n, r) => {
          const o = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = this.pos + r + (i ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
          if (!o && a.depth <= this.depth)
            return;
          const l = new Gr(a, this.editor, o, o ? n : null);
          o && (l.actualDepth = this.depth + 1), e.push(new Gr(a, this.editor, o, o ? n : null));
        }), e;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null;
      }
      closest(e, n = {}) {
        let r = null, o = this.parent;
        for (; o && !r; ) {
          if (o.node.type.name === e)
            if (Object.keys(n).length > 0) {
              const i = o.node.attrs, s = Object.keys(n);
              for (let a = 0; a < s.length; a += 1) {
                const l = s[a];
                if (i[l] !== n[l])
                  break;
              }
            } else
              r = o;
          o = o.parent;
        }
        return r;
      }
      querySelector(e, n = {}) {
        return this.querySelectorAll(e, n, true)[0] || null;
      }
      querySelectorAll(e, n = {}, r = false) {
        let o = [];
        if (!this.children || this.children.length === 0)
          return o;
        const i = Object.keys(n);
        return this.children.forEach((s) => {
          r && o.length > 0 || (s.node.type.name === e && i.every((l) => n[l] === s.node.attrs[l]) && o.push(s), !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(e, n, r))));
        }), o;
      }
      setAttribute(e) {
        const { tr: n } = this.editor.state;
        n.setNodeMarkup(this.from, void 0, {
          ...this.node.attrs,
          ...e
        }), this.editor.view.dispatch(n);
      }
    }
    const tk = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    function nk(t2, e, n) {
      const r = document.querySelector("style[data-tiptap-style]");
      if (r !== null)
        return r;
      const o = document.createElement("style");
      return e && o.setAttribute("nonce", e), o.setAttribute("data-tiptap-style", ""), o.innerHTML = t2, document.getElementsByTagName("head")[0].appendChild(o), o;
    }
    let Dn = class extends m0 {
      constructor(e = {}) {
        super(), this.isFocused = false, this.isInitialized = false, this.extensionStorage = {}, this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error: n }) => {
            throw n;
          },
          onPaste: () => null,
          onDrop: () => null
        }, this.isCapturingTransaction = false, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: o }) => this.options.onDrop(n, r, o)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
          this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = true);
        }, 0);
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        this.options.injectCSS && document && (this.css = nk(tk, this.options.injectNonce));
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(e = {}) {
        this.options = {
          ...this.options,
          ...e
        }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(e, n = true) {
        this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
        return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(e, n) {
        const r = Dh(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], o = this.state.reconfigure({ plugins: r });
        return this.view.updateState(o), o;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(e) {
        if (this.isDestroyed)
          return;
        const n = this.state.plugins;
        let r = n;
        if ([].concat(e).forEach((i) => {
          const s = typeof i == "string" ? `${i}$` : i.key;
          r = n.filter((a) => !a.key.startsWith(s));
        }), n.length === r.length)
          return;
        const o = this.state.reconfigure({
          plugins: r
        });
        return this.view.updateState(o), o;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var e, n;
        const o = [...this.options.enableCoreExtensions ? [
          JE,
          A0.configure({
            blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
          }),
          jE,
          XE,
          ZE,
          ek,
          YE,
          QE
        ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== false : true) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i == null ? void 0 : i.type));
        this.extensionManager = new To(o, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new La({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
        var e;
        let n;
        try {
          n = ec(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
        } catch (s) {
          if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
            throw s;
          this.emit("contentError", {
            editor: this,
            error: s,
            disableCollaboration: () => {
              this.storage.collaboration && (this.storage.collaboration.isDisabled = true), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
            }
          }), n = ec(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
        }
        const r = Bh(n, this.options.autofocus);
        this.view = new Fv(this.options.element, {
          ...this.options.editorProps,
          attributes: {
            // add `role="textbox"` to the editor element
            role: "textbox",
            ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
          },
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: xo.create({
            doc: n,
            selection: r || void 0
          })
        });
        const o = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(o), this.createNodeViews(), this.prependClass();
        const i = this.view.dom;
        i.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
        this.view.isDestroyed || this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
      }
      captureTransaction(e) {
        this.isCapturingTransaction = true, e(), this.isCapturingTransaction = false;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null, n;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(e) {
        if (this.view.isDestroyed)
          return;
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = e;
            return;
          }
          e.steps.forEach((s) => {
            var a;
            return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
          });
          return;
        }
        const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
        this.emit("beforeTransaction", {
          editor: this,
          transaction: e,
          nextState: n
        }), this.view.updateState(n), this.emit("transaction", {
          editor: this,
          transaction: e
        }), r && this.emit("selectionUpdate", {
          editor: this,
          transaction: e
        });
        const o = e.getMeta("focus"), i = e.getMeta("blur");
        o && this.emit("focus", {
          editor: this,
          event: o.event,
          transaction: e
        }), i && this.emit("blur", {
          editor: this,
          event: i.event,
          transaction: e
        }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
          editor: this,
          transaction: e
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(e) {
        return Wh(this.state, e);
      }
      isActive(e, n) {
        const r = typeof e == "string" ? e : null, o = typeof e == "string" ? n : e;
        return TE(this.state, r, o);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return Wc(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(e) {
        const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
        return Vh(this.state.doc, {
          blockSeparator: n,
          textSerializers: {
            ...qc(this.schema),
            ...r
          }
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return Yc(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       *
       * @deprecated
       */
      getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        if (this.emit("destroy"), this.view) {
          const e = this.view.dom;
          e && e.editor && delete e.editor, this.view.destroy();
        }
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView);
      }
      $node(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
      }
      $nodes(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
      }
      $pos(e) {
        const n = this.state.doc.resolve(e);
        return new Gr(n, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    };
    function lo(t2) {
      return new zi({
        find: t2.find,
        handler: ({ state: e, range: n, match: r }) => {
          const o = Te(t2.getAttributes, void 0, r);
          if (o === false || o === null)
            return null;
          const { tr: i } = e, s = r[r.length - 1], a = r[0];
          if (s) {
            const l = a.search(/\S/), c2 = n.from + a.indexOf(s), u = c2 + s.length;
            if (jc(n.from, n.to, e.doc).filter((f) => f.mark.type.excluded.find((m) => m === t2.type && m !== f.mark.type)).filter((f) => f.to > c2).length)
              return null;
            u < n.to && i.delete(u, n.to), c2 > n.from && i.delete(n.from + l, c2);
            const p2 = n.from + l + s.length;
            i.addMark(n.from + l, p2, t2.type.create(o || {})), i.removeStoredMark(t2.type);
          }
        }
      });
    }
    function Ha(t2) {
      return new zi({
        find: t2.find,
        handler: ({ state: e, range: n, match: r }) => {
          const o = Te(t2.getAttributes, void 0, r) || {}, { tr: i } = e, s = n.from;
          let a = n.to;
          const l = t2.type.create(o);
          if (r[1]) {
            const c2 = r[0].lastIndexOf(r[1]);
            let u = s + c2;
            u > a ? u = a : a = u + r[1].length;
            const d = r[0][r[0].length - 1];
            i.insertText(d, s + r[0].length - 1), i.replaceWith(u, a, l);
          } else if (r[0]) {
            const c2 = t2.type.isInline ? s : s - 1;
            i.insert(c2, t2.type.create(o)).delete(i.mapping.map(s), i.mapping.map(a));
          }
          i.scrollIntoView();
        }
      });
    }
    function rc(t2) {
      return new zi({
        find: t2.find,
        handler: ({ state: e, range: n, match: r }) => {
          const o = e.doc.resolve(n.from), i = Te(t2.getAttributes, void 0, r) || {};
          if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t2.type))
            return null;
          e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t2.type, i);
        }
      });
    }
    function dt(t2) {
      return new zi({
        find: t2.find,
        handler: ({ state: e, range: n, match: r }) => {
          let o = t2.replace, i = n.from;
          const s = n.to;
          if (r[1]) {
            const a = r[0].lastIndexOf(r[1]);
            o += r[0].slice(a + r[1].length), i += a;
            const l = i - s;
            l > 0 && (o = r[0].slice(a - l, a) + o, i = s);
          }
          e.tr.insertText(o, i, s);
        }
      });
    }
    function Lo(t2) {
      return new zi({
        find: t2.find,
        handler: ({ state: e, range: n, match: r, chain: o }) => {
          const i = Te(t2.getAttributes, void 0, r) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c2 = l && xc(l, t2.type, i);
          if (!c2)
            return null;
          if (s.wrap(l, c2), t2.keepMarks && t2.editor) {
            const { selection: d, storedMarks: p2 } = e, { splittableMarks: f } = t2.editor.extensionManager, h2 = p2 || d.$to.parentOffset && d.$from.marks();
            if (h2) {
              const m = h2.filter((g) => f.includes(g.type.name));
              s.ensureMarks(m);
            }
          }
          if (t2.keepAttributes) {
            const d = t2.type.name === "bulletList" || t2.type.name === "orderedList" ? "listItem" : "taskList";
            o().updateAttributes(d, i).run();
          }
          const u = s.doc.resolve(n.from - 1).nodeBefore;
          u && u.type === t2.type && Fr(s.doc, n.from - 1) && (!t2.joinPredicate || t2.joinPredicate(r, u)) && s.join(n.from - 1);
        }
      });
    }
    class it {
      constructor(e = {}) {
        this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new it(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new it(e);
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
    }
    class rk {
      constructor(e, n, r) {
        this.isDragging = false, this.component = e, this.editor = n.editor, this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...r
        }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
      }
      mount() {
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(e) {
        var n, r, o, i, s, a, l;
        const { view: c2 } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
        if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(u) || !d)
          return;
        let p2 = 0, f = 0;
        if (this.dom !== d) {
          const b = this.dom.getBoundingClientRect(), E = d.getBoundingClientRect(), _ = (o = e.offsetX) !== null && o !== void 0 ? o : (i = e.nativeEvent) === null || i === void 0 ? void 0 : i.offsetX, v = (s = e.offsetY) !== null && s !== void 0 ? s : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
          p2 = E.x - b.x + _, f = E.y - b.y + v;
        }
        (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, p2, f);
        const h2 = this.getPos();
        if (typeof h2 != "number")
          return;
        const m = re.create(c2.state.doc, h2), g = c2.state.tr.setSelection(m);
        c2.dispatch(g);
      }
      stopEvent(e) {
        var n;
        if (!this.dom)
          return false;
        if (typeof this.options.stopEvent == "function")
          return this.options.stopEvent({ event: e });
        const r = e.target;
        if (!(this.dom.contains(r) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))))
          return false;
        const i = e.type.startsWith("drag"), s = e.type === "drop";
        if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !s && !i)
          return true;
        const { isEditable: l } = this.editor, { isDragging: c2 } = this, u = !!this.node.type.spec.draggable, d = re.isSelectable(this.node), p2 = e.type === "copy", f = e.type === "paste", h2 = e.type === "cut", m = e.type === "mousedown";
        if (!u && d && i && e.target === this.dom && e.preventDefault(), u && i && !c2 && e.target === this.dom)
          return e.preventDefault(), false;
        if (u && l && !c2 && m) {
          const g = r.closest("[data-drag-handle]");
          g && (this.dom === g || this.dom.contains(g)) && (this.isDragging = true, document.addEventListener("dragend", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("drop", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("mouseup", () => {
            this.isDragging = false;
          }, { once: true }));
        }
        return !(c2 || s || p2 || f || h2 || m && d);
      }
      /**
       * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
       * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
       * @return `true` if it can safely be ignored.
       */
      ignoreMutation(e) {
        return !this.dom || !this.contentDOM ? true : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? true : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Fa() || $h()) && this.editor.isFocused && [
          ...Array.from(e.addedNodes),
          ...Array.from(e.removedNodes)
        ].every((r) => r.isContentEditable) ? false : this.contentDOM === e.target && e.type === "attributes" ? true : !this.contentDOM.contains(e.target);
      }
      /**
       * Update the attributes of the prosemirror node.
       */
      updateAttributes(e) {
        this.editor.commands.command(({ tr: n }) => {
          const r = this.getPos();
          return typeof r != "number" ? false : (n.setNodeMarkup(r, void 0, {
            ...this.node.attrs,
            ...e
          }), true);
        });
      }
      /**
       * Delete the node.
       */
      deleteNode() {
        const e = this.getPos();
        if (typeof e != "number")
          return;
        const n = e + this.node.nodeSize;
        this.editor.commands.deleteRange({ from: e, to: n });
      }
    }
    function $r(t2) {
      return new S0({
        find: t2.find,
        handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
          const i = Te(t2.getAttributes, void 0, r, o);
          if (i === false || i === null)
            return null;
          const { tr: s } = e, a = r[r.length - 1], l = r[0];
          let c2 = n.to;
          if (a) {
            const u = l.search(/\S/), d = n.from + l.indexOf(a), p2 = d + a.length;
            if (jc(n.from, n.to, e.doc).filter((h2) => h2.mark.type.excluded.find((g) => g === t2.type && g !== h2.mark.type)).filter((h2) => h2.to > d).length)
              return null;
            p2 < n.to && s.delete(p2, n.to), d > n.from && s.delete(n.from + u, d), c2 = n.from + u + a.length, s.addMark(n.from + u, c2, t2.type.create(i || {})), s.removeStoredMark(t2.type);
          }
        }
      });
    }
    function ok(t2) {
      return t2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tn = "top", Sn = "bottom", Cn = "right", nn = "left", Jc = "auto", Hi = [tn, Sn, Cn, nn], Po = "start", Ci = "end", ik = "clippingParents", Gh = "viewport", Jo = "popper", sk = "reference", Ud = /* @__PURE__ */ Hi.reduce(function(t2, e) {
      return t2.concat([e + "-" + Po, e + "-" + Ci]);
    }, []), jh = /* @__PURE__ */ [].concat(Hi, [Jc]).reduce(function(t2, e) {
      return t2.concat([e, e + "-" + Po, e + "-" + Ci]);
    }, []), ak = "beforeRead", lk = "read", ck = "afterRead", uk = "beforeMain", dk = "main", pk = "afterMain", fk = "beforeWrite", hk = "write", mk = "afterWrite", gk = [ak, lk, ck, uk, dk, pk, fk, hk, mk];
    function Xn(t2) {
      return t2 ? (t2.nodeName || "").toLowerCase() : null;
    }
    function fn(t2) {
      if (t2 == null)
        return window;
      if (t2.toString() !== "[object Window]") {
        var e = t2.ownerDocument;
        return e && e.defaultView || window;
      }
      return t2;
    }
    function co(t2) {
      var e = fn(t2).Element;
      return t2 instanceof e || t2 instanceof Element;
    }
    function wn(t2) {
      var e = fn(t2).HTMLElement;
      return t2 instanceof e || t2 instanceof HTMLElement;
    }
    function Xc(t2) {
      if (typeof ShadowRoot > "u")
        return false;
      var e = fn(t2).ShadowRoot;
      return t2 instanceof e || t2 instanceof ShadowRoot;
    }
    function bk(t2) {
      var e = t2.state;
      Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
        !wn(i) || !Xn(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(s) {
          var a = o[s];
          a === false ? i.removeAttribute(s) : i.setAttribute(s, a === true ? "" : a);
        }));
      });
    }
    function yk(t2) {
      var e = t2.state, n = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o = e.elements[r], i = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = s.reduce(function(l, c2) {
            return l[c2] = "", l;
          }, {});
          !wn(o) || !Xn(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function(l) {
            o.removeAttribute(l);
          }));
        });
      };
    }
    const Yh = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: bk,
      effect: yk,
      requires: ["computeStyles"]
    };
    function jn(t2) {
      return t2.split("-")[0];
    }
    var to = Math.max, Ks = Math.min, Bo = Math.round;
    function oc() {
      var t2 = navigator.userAgentData;
      return t2 != null && t2.brands && Array.isArray(t2.brands) ? t2.brands.map(function(e) {
        return e.brand + "/" + e.version;
      }).join(" ") : navigator.userAgent;
    }
    function Jh() {
      return !/^((?!chrome|android).)*safari/i.test(oc());
    }
    function $o(t2, e, n) {
      e === void 0 && (e = false), n === void 0 && (n = false);
      var r = t2.getBoundingClientRect(), o = 1, i = 1;
      e && wn(t2) && (o = t2.offsetWidth > 0 && Bo(r.width) / t2.offsetWidth || 1, i = t2.offsetHeight > 0 && Bo(r.height) / t2.offsetHeight || 1);
      var s = co(t2) ? fn(t2) : window, a = s.visualViewport, l = !Jh() && n, c2 = (r.left + (l && a ? a.offsetLeft : 0)) / o, u = (r.top + (l && a ? a.offsetTop : 0)) / i, d = r.width / o, p2 = r.height / i;
      return {
        width: d,
        height: p2,
        top: u,
        right: c2 + d,
        bottom: u + p2,
        left: c2,
        x: c2,
        y: u
      };
    }
    function Zc(t2) {
      var e = $o(t2), n = t2.offsetWidth, r = t2.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: t2.offsetLeft,
        y: t2.offsetTop,
        width: n,
        height: r
      };
    }
    function Xh(t2, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t2.contains(e))
        return true;
      if (n && Xc(n)) {
        var r = e;
        do {
          if (r && t2.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function fr(t2) {
      return fn(t2).getComputedStyle(t2);
    }
    function vk(t2) {
      return ["table", "td", "th"].indexOf(Xn(t2)) >= 0;
    }
    function Ur(t2) {
      return ((co(t2) ? t2.ownerDocument : (
        // $FlowFixMe[prop-missing]
        t2.document
      )) || window.document).documentElement;
    }
    function Ua(t2) {
      return Xn(t2) === "html" ? t2 : (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        t2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        t2.parentNode || // DOM Element detected
        (Xc(t2) ? t2.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        Ur(t2)
      );
    }
    function Vd(t2) {
      return !wn(t2) || // https://github.com/popperjs/popper-core/issues/837
      fr(t2).position === "fixed" ? null : t2.offsetParent;
    }
    function Ek(t2) {
      var e = /firefox/i.test(oc()), n = /Trident/i.test(oc());
      if (n && wn(t2)) {
        var r = fr(t2);
        if (r.position === "fixed")
          return null;
      }
      var o = Ua(t2);
      for (Xc(o) && (o = o.host); wn(o) && ["html", "body"].indexOf(Xn(o)) < 0; ) {
        var i = fr(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
          return o;
        o = o.parentNode;
      }
      return null;
    }
    function Ui(t2) {
      for (var e = fn(t2), n = Vd(t2); n && vk(n) && fr(n).position === "static"; )
        n = Vd(n);
      return n && (Xn(n) === "html" || Xn(n) === "body" && fr(n).position === "static") ? e : n || Ek(t2) || e;
    }
    function Qc(t2) {
      return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
    }
    function ai(t2, e, n) {
      return to(t2, Ks(e, n));
    }
    function kk(t2, e, n) {
      var r = ai(t2, e, n);
      return r > n ? n : r;
    }
    function Zh() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function Qh(t2) {
      return Object.assign({}, Zh(), t2);
    }
    function em(t2, e) {
      return e.reduce(function(n, r) {
        return n[r] = t2, n;
      }, {});
    }
    var wk = function(e, n) {
      return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
        placement: n.placement
      })) : e, Qh(typeof e != "number" ? e : em(e, Hi));
    };
    function _k(t2) {
      var e, n = t2.state, r = t2.name, o = t2.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, a = jn(n.placement), l = Qc(a), c2 = [nn, Cn].indexOf(a) >= 0, u = c2 ? "height" : "width";
      if (!(!i || !s)) {
        var d = wk(o.padding, n), p2 = Zc(i), f = l === "y" ? tn : nn, h2 = l === "y" ? Sn : Cn, m = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u], g = s[l] - n.rects.reference[l], b = Ui(i), E = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, _ = m / 2 - g / 2, v = d[f], T = E - p2[u] - d[h2], S = E / 2 - p2[u] / 2 + _, F = ai(v, S, T), V = l;
        n.modifiersData[r] = (e = {}, e[V] = F, e.centerOffset = F - S, e);
      }
    }
    function Sk(t2) {
      var e = t2.state, n = t2.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
      o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || Xh(e.elements.popper, o) && (e.elements.arrow = o));
    }
    const Ck = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: _k,
      effect: Sk,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function Fo(t2) {
      return t2.split("-")[1];
    }
    var xk = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function Tk(t2, e) {
      var n = t2.x, r = t2.y, o = e.devicePixelRatio || 1;
      return {
        x: Bo(n * o) / o || 0,
        y: Bo(r * o) / o || 0
      };
    }
    function Wd(t2) {
      var e, n = t2.popper, r = t2.popperRect, o = t2.placement, i = t2.variation, s = t2.offsets, a = t2.position, l = t2.gpuAcceleration, c2 = t2.adaptive, u = t2.roundOffsets, d = t2.isFixed, p2 = s.x, f = p2 === void 0 ? 0 : p2, h2 = s.y, m = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({
        x: f,
        y: m
      }) : {
        x: f,
        y: m
      };
      f = g.x, m = g.y;
      var b = s.hasOwnProperty("x"), E = s.hasOwnProperty("y"), _ = nn, v = tn, T = window;
      if (c2) {
        var S = Ui(n), F = "clientHeight", V = "clientWidth";
        if (S === fn(n) && (S = Ur(n), fr(S).position !== "static" && a === "absolute" && (F = "scrollHeight", V = "scrollWidth")), S = S, o === tn || (o === nn || o === Cn) && i === Ci) {
          v = Sn;
          var L = d && S === T && T.visualViewport ? T.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            S[F]
          );
          m -= L - r.height, m *= l ? 1 : -1;
        }
        if (o === nn || (o === tn || o === Sn) && i === Ci) {
          _ = Cn;
          var W = d && S === T && T.visualViewport ? T.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            S[V]
          );
          f -= W - r.width, f *= l ? 1 : -1;
        }
      }
      var te = Object.assign({
        position: a
      }, c2 && xk), de = u === true ? Tk({
        x: f,
        y: m
      }, fn(n)) : {
        x: f,
        y: m
      };
      if (f = de.x, m = de.y, l) {
        var ke;
        return Object.assign({}, te, (ke = {}, ke[v] = E ? "0" : "", ke[_] = b ? "0" : "", ke.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", ke));
      }
      return Object.assign({}, te, (e = {}, e[v] = E ? m + "px" : "", e[_] = b ? f + "px" : "", e.transform = "", e));
    }
    function Ok(t2) {
      var e = t2.state, n = t2.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, s = i === void 0 ? true : i, a = n.roundOffsets, l = a === void 0 ? true : a, c2 = {
        placement: jn(e.placement),
        variation: Fo(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: o,
        isFixed: e.options.strategy === "fixed"
      };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Wd(Object.assign({}, c2, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: s,
        roundOffsets: l
      })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Wd(Object.assign({}, c2, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    }
    const Nk = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: Ok,
      data: {}
    };
    var rs = {
      passive: true
    };
    function Ak(t2) {
      var e = t2.state, n = t2.instance, r = t2.options, o = r.scroll, i = o === void 0 ? true : o, s = r.resize, a = s === void 0 ? true : s, l = fn(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c2.forEach(function(u) {
        u.addEventListener("scroll", n.update, rs);
      }), a && l.addEventListener("resize", n.update, rs), function() {
        i && c2.forEach(function(u) {
          u.removeEventListener("scroll", n.update, rs);
        }), a && l.removeEventListener("resize", n.update, rs);
      };
    }
    const Mk = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function() {
      },
      effect: Ak,
      data: {}
    };
    var Rk = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function xs(t2) {
      return t2.replace(/left|right|bottom|top/g, function(e) {
        return Rk[e];
      });
    }
    var Ik = {
      start: "end",
      end: "start"
    };
    function Kd(t2) {
      return t2.replace(/start|end/g, function(e) {
        return Ik[e];
      });
    }
    function eu(t2) {
      var e = fn(t2), n = e.pageXOffset, r = e.pageYOffset;
      return {
        scrollLeft: n,
        scrollTop: r
      };
    }
    function tu(t2) {
      return $o(Ur(t2)).left + eu(t2).scrollLeft;
    }
    function Dk(t2, e) {
      var n = fn(t2), r = Ur(t2), o = n.visualViewport, i = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
      if (o) {
        i = o.width, s = o.height;
        var c2 = Jh();
        (c2 || !c2 && e === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
      }
      return {
        width: i,
        height: s,
        x: a + tu(t2),
        y: l
      };
    }
    function Lk(t2) {
      var e, n = Ur(t2), r = eu(t2), o = (e = t2.ownerDocument) == null ? void 0 : e.body, i = to(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = to(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), a = -r.scrollLeft + tu(t2), l = -r.scrollTop;
      return fr(o || n).direction === "rtl" && (a += to(n.clientWidth, o ? o.clientWidth : 0) - i), {
        width: i,
        height: s,
        x: a,
        y: l
      };
    }
    function nu(t2) {
      var e = fr(t2), n = e.overflow, r = e.overflowX, o = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o + r);
    }
    function tm(t2) {
      return ["html", "body", "#document"].indexOf(Xn(t2)) >= 0 ? t2.ownerDocument.body : wn(t2) && nu(t2) ? t2 : tm(Ua(t2));
    }
    function li(t2, e) {
      var n;
      e === void 0 && (e = []);
      var r = tm(t2), o = r === ((n = t2.ownerDocument) == null ? void 0 : n.body), i = fn(r), s = o ? [i].concat(i.visualViewport || [], nu(r) ? r : []) : r, a = e.concat(s);
      return o ? a : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        a.concat(li(Ua(s)))
      );
    }
    function ic(t2) {
      return Object.assign({}, t2, {
        left: t2.x,
        top: t2.y,
        right: t2.x + t2.width,
        bottom: t2.y + t2.height
      });
    }
    function Pk(t2, e) {
      var n = $o(t2, false, e === "fixed");
      return n.top = n.top + t2.clientTop, n.left = n.left + t2.clientLeft, n.bottom = n.top + t2.clientHeight, n.right = n.left + t2.clientWidth, n.width = t2.clientWidth, n.height = t2.clientHeight, n.x = n.left, n.y = n.top, n;
    }
    function qd(t2, e, n) {
      return e === Gh ? ic(Dk(t2, n)) : co(e) ? Pk(e, n) : ic(Lk(Ur(t2)));
    }
    function Bk(t2) {
      var e = li(Ua(t2)), n = ["absolute", "fixed"].indexOf(fr(t2).position) >= 0, r = n && wn(t2) ? Ui(t2) : t2;
      return co(r) ? e.filter(function(o) {
        return co(o) && Xh(o, r) && Xn(o) !== "body";
      }) : [];
    }
    function $k(t2, e, n, r) {
      var o = e === "clippingParents" ? Bk(t2) : [].concat(e), i = [].concat(o, [n]), s = i[0], a = i.reduce(function(l, c2) {
        var u = qd(t2, c2, r);
        return l.top = to(u.top, l.top), l.right = Ks(u.right, l.right), l.bottom = Ks(u.bottom, l.bottom), l.left = to(u.left, l.left), l;
      }, qd(t2, s, r));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function nm(t2) {
      var e = t2.reference, n = t2.element, r = t2.placement, o = r ? jn(r) : null, i = r ? Fo(r) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
      switch (o) {
        case tn:
          l = {
            x: s,
            y: e.y - n.height
          };
          break;
        case Sn:
          l = {
            x: s,
            y: e.y + e.height
          };
          break;
        case Cn:
          l = {
            x: e.x + e.width,
            y: a
          };
          break;
        case nn:
          l = {
            x: e.x - n.width,
            y: a
          };
          break;
        default:
          l = {
            x: e.x,
            y: e.y
          };
      }
      var c2 = o ? Qc(o) : null;
      if (c2 != null) {
        var u = c2 === "y" ? "height" : "width";
        switch (i) {
          case Po:
            l[c2] = l[c2] - (e[u] / 2 - n[u] / 2);
            break;
          case Ci:
            l[c2] = l[c2] + (e[u] / 2 - n[u] / 2);
            break;
        }
      }
      return l;
    }
    function xi(t2, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = r === void 0 ? t2.placement : r, i = n.strategy, s = i === void 0 ? t2.strategy : i, a = n.boundary, l = a === void 0 ? ik : a, c2 = n.rootBoundary, u = c2 === void 0 ? Gh : c2, d = n.elementContext, p2 = d === void 0 ? Jo : d, f = n.altBoundary, h2 = f === void 0 ? false : f, m = n.padding, g = m === void 0 ? 0 : m, b = Qh(typeof g != "number" ? g : em(g, Hi)), E = p2 === Jo ? sk : Jo, _ = t2.rects.popper, v = t2.elements[h2 ? E : p2], T = $k(co(v) ? v : v.contextElement || Ur(t2.elements.popper), l, u, s), S = $o(t2.elements.reference), F = nm({
        reference: S,
        element: _,
        placement: o
      }), V = ic(Object.assign({}, _, F)), L = p2 === Jo ? V : S, W = {
        top: T.top - L.top + b.top,
        bottom: L.bottom - T.bottom + b.bottom,
        left: T.left - L.left + b.left,
        right: L.right - T.right + b.right
      }, te = t2.modifiersData.offset;
      if (p2 === Jo && te) {
        var de = te[o];
        Object.keys(W).forEach(function(ke) {
          var Ee = [Cn, Sn].indexOf(ke) >= 0 ? 1 : -1, fe = [tn, Sn].indexOf(ke) >= 0 ? "y" : "x";
          W[ke] += de[fe] * Ee;
        });
      }
      return W;
    }
    function Fk(t2, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c2 = l === void 0 ? jh : l, u = Fo(r), d = u ? a ? Ud : Ud.filter(function(h2) {
        return Fo(h2) === u;
      }) : Hi, p2 = d.filter(function(h2) {
        return c2.indexOf(h2) >= 0;
      });
      p2.length === 0 && (p2 = d);
      var f = p2.reduce(function(h2, m) {
        return h2[m] = xi(t2, {
          placement: m,
          boundary: o,
          rootBoundary: i,
          padding: s
        })[jn(m)], h2;
      }, {});
      return Object.keys(f).sort(function(h2, m) {
        return f[h2] - f[m];
      });
    }
    function zk(t2) {
      if (jn(t2) === Jc)
        return [];
      var e = xs(t2);
      return [Kd(t2), e, Kd(e)];
    }
    function Hk(t2) {
      var e = t2.state, n = t2.options, r = t2.name;
      if (!e.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? true : o, s = n.altAxis, a = s === void 0 ? true : s, l = n.fallbackPlacements, c2 = n.padding, u = n.boundary, d = n.rootBoundary, p2 = n.altBoundary, f = n.flipVariations, h2 = f === void 0 ? true : f, m = n.allowedAutoPlacements, g = e.options.placement, b = jn(g), E = b === g, _ = l || (E || !h2 ? [xs(g)] : zk(g)), v = [g].concat(_).reduce(function(kt, ze) {
          return kt.concat(jn(ze) === Jc ? Fk(e, {
            placement: ze,
            boundary: u,
            rootBoundary: d,
            padding: c2,
            flipVariations: h2,
            allowedAutoPlacements: m
          }) : ze);
        }, []), T = e.rects.reference, S = e.rects.popper, F = /* @__PURE__ */ new Map(), V = true, L = v[0], W = 0; W < v.length; W++) {
          var te = v[W], de = jn(te), ke = Fo(te) === Po, Ee = [tn, Sn].indexOf(de) >= 0, fe = Ee ? "width" : "height", he = xi(e, {
            placement: te,
            boundary: u,
            rootBoundary: d,
            altBoundary: p2,
            padding: c2
          }), N = Ee ? ke ? Cn : nn : ke ? Sn : tn;
          T[fe] > S[fe] && (N = xs(N));
          var D = xs(N), Y = [];
          if (i && Y.push(he[de] <= 0), a && Y.push(he[N] <= 0, he[D] <= 0), Y.every(function(kt) {
            return kt;
          })) {
            L = te, V = false;
            break;
          }
          F.set(te, Y);
        }
        if (V)
          for (var oe = h2 ? 3 : 1, ce = function(ze) {
            var Qe = v.find(function(on2) {
              var Nt = F.get(on2);
              if (Nt)
                return Nt.slice(0, ze).every(function(hn) {
                  return hn;
                });
            });
            if (Qe)
              return L = Qe, "break";
          }, Se = oe; Se > 0; Se--) {
            var Fe = ce(Se);
            if (Fe === "break") break;
          }
        e.placement !== L && (e.modifiersData[r]._skip = true, e.placement = L, e.reset = true);
      }
    }
    const Uk = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: Hk,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function Gd(t2, e, n) {
      return n === void 0 && (n = {
        x: 0,
        y: 0
      }), {
        top: t2.top - e.height - n.y,
        right: t2.right - e.width + n.x,
        bottom: t2.bottom - e.height + n.y,
        left: t2.left - e.width - n.x
      };
    }
    function jd(t2) {
      return [tn, Cn, Sn, nn].some(function(e) {
        return t2[e] >= 0;
      });
    }
    function Vk(t2) {
      var e = t2.state, n = t2.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, s = xi(e, {
        elementContext: "reference"
      }), a = xi(e, {
        altBoundary: true
      }), l = Gd(s, r), c2 = Gd(a, o, i), u = jd(l), d = jd(c2);
      e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c2,
        isReferenceHidden: u,
        hasPopperEscaped: d
      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d
      });
    }
    const Wk = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: Vk
    };
    function Kk(t2, e, n) {
      var r = jn(t2), o = [nn, tn].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, {
        placement: t2
      })) : n, s = i[0], a = i[1];
      return s = s || 0, a = (a || 0) * o, [nn, Cn].indexOf(r) >= 0 ? {
        x: a,
        y: s
      } : {
        x: s,
        y: a
      };
    }
    function qk(t2) {
      var e = t2.state, n = t2.options, r = t2.name, o = n.offset, i = o === void 0 ? [0, 0] : o, s = jh.reduce(function(u, d) {
        return u[d] = Kk(d, e.rects, i), u;
      }, {}), a = s[e.placement], l = a.x, c2 = a.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = s;
    }
    const Gk = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: qk
    };
    function jk(t2) {
      var e = t2.state, n = t2.name;
      e.modifiersData[n] = nm({
        reference: e.rects.reference,
        element: e.rects.popper,
        placement: e.placement
      });
    }
    const Yk = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: jk,
      data: {}
    };
    function Jk(t2) {
      return t2 === "x" ? "y" : "x";
    }
    function Xk(t2) {
      var e = t2.state, n = t2.options, r = t2.name, o = n.mainAxis, i = o === void 0 ? true : o, s = n.altAxis, a = s === void 0 ? false : s, l = n.boundary, c2 = n.rootBoundary, u = n.altBoundary, d = n.padding, p2 = n.tether, f = p2 === void 0 ? true : p2, h2 = n.tetherOffset, m = h2 === void 0 ? 0 : h2, g = xi(e, {
        boundary: l,
        rootBoundary: c2,
        padding: d,
        altBoundary: u
      }), b = jn(e.placement), E = Fo(e.placement), _ = !E, v = Qc(b), T = Jk(v), S = e.modifiersData.popperOffsets, F = e.rects.reference, V = e.rects.popper, L = typeof m == "function" ? m(Object.assign({}, e.rects, {
        placement: e.placement
      })) : m, W = typeof L == "number" ? {
        mainAxis: L,
        altAxis: L
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, L), te = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, de = {
        x: 0,
        y: 0
      };
      if (S) {
        if (i) {
          var ke, Ee = v === "y" ? tn : nn, fe = v === "y" ? Sn : Cn, he = v === "y" ? "height" : "width", N = S[v], D = N + g[Ee], Y = N - g[fe], oe = f ? -V[he] / 2 : 0, ce = E === Po ? F[he] : V[he], Se = E === Po ? -V[he] : -F[he], Fe = e.elements.arrow, kt = f && Fe ? Zc(Fe) : {
            width: 0,
            height: 0
          }, ze = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Zh(), Qe = ze[Ee], on2 = ze[fe], Nt = ai(0, F[he], kt[he]), hn = _ ? F[he] / 2 - oe - Nt - Qe - W.mainAxis : ce - Nt - Qe - W.mainAxis, At = _ ? -F[he] / 2 + oe + Nt + on2 + W.mainAxis : Se + Nt + on2 + W.mainAxis, mn = e.elements.arrow && Ui(e.elements.arrow), $n = mn ? v === "y" ? mn.clientTop || 0 : mn.clientLeft || 0 : 0, On = (ke = te == null ? void 0 : te[v]) != null ? ke : 0, sn = N + hn - On - $n, Nn = N + At - On, ve = ai(f ? Ks(D, sn) : D, N, f ? to(Y, Nn) : Y);
          S[v] = ve, de[v] = ve - N;
        }
        if (a) {
          var Xt, Bt = v === "x" ? tn : nn, le = v === "x" ? Sn : Cn, Vt = S[T], qe = T === "y" ? "height" : "width", Re = Vt + g[Bt], Wt = Vt - g[le], pt = [tn, nn].indexOf(b) !== -1, An = (Xt = te == null ? void 0 : te[T]) != null ? Xt : 0, Kt = pt ? Re : Vt - F[qe] - V[qe] - An + W.altAxis, H = pt ? Vt + F[qe] + V[qe] - An - W.altAxis : Wt, J = f && pt ? kk(Kt, Vt, H) : ai(f ? Kt : Re, Vt, f ? H : Wt);
          S[T] = J, de[T] = J - Vt;
        }
        e.modifiersData[r] = de;
      }
    }
    const Zk = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: Xk,
      requiresIfExists: ["offset"]
    };
    function Qk(t2) {
      return {
        scrollLeft: t2.scrollLeft,
        scrollTop: t2.scrollTop
      };
    }
    function ew(t2) {
      return t2 === fn(t2) || !wn(t2) ? eu(t2) : Qk(t2);
    }
    function tw(t2) {
      var e = t2.getBoundingClientRect(), n = Bo(e.width) / t2.offsetWidth || 1, r = Bo(e.height) / t2.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function nw(t2, e, n) {
      n === void 0 && (n = false);
      var r = wn(e), o = wn(e) && tw(e), i = Ur(e), s = $o(t2, o, n), a = {
        scrollLeft: 0,
        scrollTop: 0
      }, l = {
        x: 0,
        y: 0
      };
      return (r || !r && !n) && ((Xn(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      nu(i)) && (a = ew(e)), wn(e) ? (l = $o(e, true), l.x += e.clientLeft, l.y += e.clientTop) : i && (l.x = tu(i))), {
        x: s.left + a.scrollLeft - l.x,
        y: s.top + a.scrollTop - l.y,
        width: s.width,
        height: s.height
      };
    }
    function rw(t2) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t2.forEach(function(i) {
        e.set(i.name, i);
      });
      function o(i) {
        n.add(i.name);
        var s = [].concat(i.requires || [], i.requiresIfExists || []);
        s.forEach(function(a) {
          if (!n.has(a)) {
            var l = e.get(a);
            l && o(l);
          }
        }), r.push(i);
      }
      return t2.forEach(function(i) {
        n.has(i.name) || o(i);
      }), r;
    }
    function ow(t2) {
      var e = rw(t2);
      return gk.reduce(function(n, r) {
        return n.concat(e.filter(function(o) {
          return o.phase === r;
        }));
      }, []);
    }
    function iw(t2) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t2());
          });
        })), e;
      };
    }
    function sw(t2) {
      var e = t2.reduce(function(n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, {
          options: Object.assign({}, o.options, r.options),
          data: Object.assign({}, o.data, r.data)
        }) : r, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var Yd = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function Jd() {
      for (var t2 = arguments.length, e = new Array(t2), n = 0; n < t2; n++)
        e[n] = arguments[n];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function aw(t2) {
      t2 === void 0 && (t2 = {});
      var e = t2, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Yd : o;
      return function(a, l, c2) {
        c2 === void 0 && (c2 = i);
        var u = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, Yd, i),
          modifiersData: {},
          elements: {
            reference: a,
            popper: l
          },
          attributes: {},
          styles: {}
        }, d = [], p2 = false, f = {
          state: u,
          setOptions: function(b) {
            var E = typeof b == "function" ? b(u.options) : b;
            m(), u.options = Object.assign({}, i, u.options, E), u.scrollParents = {
              reference: co(a) ? li(a) : a.contextElement ? li(a.contextElement) : [],
              popper: li(l)
            };
            var _ = ow(sw([].concat(r, u.options.modifiers)));
            return u.orderedModifiers = _.filter(function(v) {
              return v.enabled;
            }), h2(), f.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function() {
            if (!p2) {
              var b = u.elements, E = b.reference, _ = b.popper;
              if (Jd(E, _)) {
                u.rects = {
                  reference: nw(E, Ui(_), u.options.strategy === "fixed"),
                  popper: Zc(_)
                }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(W) {
                  return u.modifiersData[W.name] = Object.assign({}, W.data);
                });
                for (var v = 0; v < u.orderedModifiers.length; v++) {
                  if (u.reset === true) {
                    u.reset = false, v = -1;
                    continue;
                  }
                  var T = u.orderedModifiers[v], S = T.fn, F = T.options, V = F === void 0 ? {} : F, L = T.name;
                  typeof S == "function" && (u = S({
                    state: u,
                    options: V,
                    name: L,
                    instance: f
                  }) || u);
                }
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: iw(function() {
            return new Promise(function(g) {
              f.forceUpdate(), g(u);
            });
          }),
          destroy: function() {
            m(), p2 = true;
          }
        };
        if (!Jd(a, l))
          return f;
        f.setOptions(c2).then(function(g) {
          !p2 && c2.onFirstUpdate && c2.onFirstUpdate(g);
        });
        function h2() {
          u.orderedModifiers.forEach(function(g) {
            var b = g.name, E = g.options, _ = E === void 0 ? {} : E, v = g.effect;
            if (typeof v == "function") {
              var T = v({
                state: u,
                name: b,
                instance: f,
                options: _
              }), S = function() {
              };
              d.push(T || S);
            }
          });
        }
        function m() {
          d.forEach(function(g) {
            return g();
          }), d = [];
        }
        return f;
      };
    }
    var lw = [Mk, Yk, Nk, Yh, Gk, Uk, Zk, Ck, Wk], cw = /* @__PURE__ */ aw({
      defaultModifiers: lw
    }), uw = "tippy-box", rm = "tippy-content", dw = "tippy-backdrop", om = "tippy-arrow", im = "tippy-svg-arrow", Kr = {
      passive: true,
      capture: true
    }, sm = function() {
      return document.body;
    };
    function yl(t2, e, n) {
      if (Array.isArray(t2)) {
        var r = t2[e];
        return r ?? (Array.isArray(n) ? n[e] : n);
      }
      return t2;
    }
    function ru(t2, e) {
      var n = {}.toString.call(t2);
      return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
    }
    function am(t2, e) {
      return typeof t2 == "function" ? t2.apply(void 0, e) : t2;
    }
    function Xd(t2, e) {
      if (e === 0)
        return t2;
      var n;
      return function(r) {
        clearTimeout(n), n = setTimeout(function() {
          t2(r);
        }, e);
      };
    }
    function hw(t2) {
      return t2.split(/\s+/).filter(Boolean);
    }
    function wo(t2) {
      return [].concat(t2);
    }
    function Zd(t2, e) {
      t2.indexOf(e) === -1 && t2.push(e);
    }
    function mw(t2) {
      return t2.filter(function(e, n) {
        return t2.indexOf(e) === n;
      });
    }
    function gw(t2) {
      return t2.split("-")[0];
    }
    function qs(t2) {
      return [].slice.call(t2);
    }
    function Qd(t2) {
      return Object.keys(t2).reduce(function(e, n) {
        return t2[n] !== void 0 && (e[n] = t2[n]), e;
      }, {});
    }
    function ci() {
      return document.createElement("div");
    }
    function Ti(t2) {
      return ["Element", "Fragment"].some(function(e) {
        return ru(t2, e);
      });
    }
    function bw(t2) {
      return ru(t2, "NodeList");
    }
    function yw(t2) {
      return ru(t2, "MouseEvent");
    }
    function vw(t2) {
      return !!(t2 && t2._tippy && t2._tippy.reference === t2);
    }
    function Ew(t2) {
      return Ti(t2) ? [t2] : bw(t2) ? qs(t2) : Array.isArray(t2) ? t2 : qs(document.querySelectorAll(t2));
    }
    function vl(t2, e) {
      t2.forEach(function(n) {
        n && (n.style.transitionDuration = e + "ms");
      });
    }
    function ep(t2, e) {
      t2.forEach(function(n) {
        n && n.setAttribute("data-state", e);
      });
    }
    function kw(t2) {
      var e, n = wo(t2), r = n[0];
      return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
    }
    function ww(t2, e) {
      var n = e.clientX, r = e.clientY;
      return t2.every(function(o) {
        var i = o.popperRect, s = o.popperState, a = o.props, l = a.interactiveBorder, c2 = gw(s.placement), u = s.modifiersData.offset;
        if (!u)
          return true;
        var d = c2 === "bottom" ? u.top.y : 0, p2 = c2 === "top" ? u.bottom.y : 0, f = c2 === "right" ? u.left.x : 0, h2 = c2 === "left" ? u.right.x : 0, m = i.top - r + d > l, g = r - i.bottom - p2 > l, b = i.left - n + f > l, E = n - i.right - h2 > l;
        return m || g || b || E;
      });
    }
    function El(t2, e, n) {
      var r = e + "EventListener";
      ["transitionend", "webkitTransitionEnd"].forEach(function(o) {
        t2[r](o, n);
      });
    }
    function tp(t2, e) {
      for (var n = e; n; ) {
        var r;
        if (t2.contains(n))
          return true;
        n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
      }
      return false;
    }
    var Kn = {
      isTouch: false
    }, np = 0;
    function _w() {
      Kn.isTouch || (Kn.isTouch = true, window.performance && document.addEventListener("mousemove", lm));
    }
    function lm() {
      var t2 = performance.now();
      t2 - np < 20 && (Kn.isTouch = false, document.removeEventListener("mousemove", lm)), np = t2;
    }
    function Sw() {
      var t2 = document.activeElement;
      if (vw(t2)) {
        var e = t2._tippy;
        t2.blur && !e.state.isVisible && t2.blur();
      }
    }
    function Cw() {
      document.addEventListener("touchstart", _w, Kr), window.addEventListener("blur", Sw);
    }
    var xw = typeof window < "u" && typeof document < "u", Tw = xw ? (
      // @ts-ignore
      !!window.msCrypto
    ) : false;
    var um = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    }, Mw = {
      allowHTML: false,
      animation: "fade",
      arrow: true,
      content: "",
      inertia: false,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999
    }, un = Object.assign({
      appendTo: sm,
      aria: {
        content: "auto",
        expanded: "auto"
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function() {
      },
      onBeforeUpdate: function() {
      },
      onCreate: function() {
      },
      onDestroy: function() {
      },
      onHidden: function() {
      },
      onHide: function() {
      },
      onMount: function() {
      },
      onShow: function() {
      },
      onShown: function() {
      },
      onTrigger: function() {
      },
      onUntrigger: function() {
      },
      onClickOutside: function() {
      },
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: "mouseenter focus",
      triggerTarget: null
    }, um, Mw), Rw = Object.keys(un), Iw = function(e) {
      var n = Object.keys(e);
      n.forEach(function(r) {
        un[r] = e[r];
      });
    };
    function dm(t2) {
      var e = t2.plugins || [], n = e.reduce(function(r, o) {
        var i = o.name, s = o.defaultValue;
        if (i) {
          var a;
          r[i] = t2[i] !== void 0 ? t2[i] : (a = un[i]) != null ? a : s;
        }
        return r;
      }, {});
      return Object.assign({}, t2, n);
    }
    function Dw(t2, e) {
      var n = e ? Object.keys(dm(Object.assign({}, un, {
        plugins: e
      }))) : Rw, r = n.reduce(function(o, i) {
        var s = (t2.getAttribute("data-tippy-" + i) || "").trim();
        if (!s)
          return o;
        if (i === "content")
          o[i] = s;
        else
          try {
            o[i] = JSON.parse(s);
          } catch {
            o[i] = s;
          }
        return o;
      }, {});
      return r;
    }
    function op(t2, e) {
      var n = Object.assign({}, e, {
        content: am(e.content, [t2])
      }, e.ignoreAttributes ? {} : Dw(t2, e.plugins));
      return n.aria = Object.assign({}, un.aria, n.aria), n.aria = {
        expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
        content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
      }, n;
    }
    var Lw = function() {
      return "innerHTML";
    };
    function ac(t2, e) {
      t2[Lw()] = e;
    }
    function ip(t2) {
      var e = ci();
      return t2 === true ? e.className = om : (e.className = im, Ti(t2) ? e.appendChild(t2) : ac(e, t2)), e;
    }
    function sp(t2, e) {
      Ti(e.content) ? (ac(t2, ""), t2.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? ac(t2, e.content) : t2.textContent = e.content);
    }
    function lc(t2) {
      var e = t2.firstElementChild, n = qs(e.children);
      return {
        box: e,
        content: n.find(function(r) {
          return r.classList.contains(rm);
        }),
        arrow: n.find(function(r) {
          return r.classList.contains(om) || r.classList.contains(im);
        }),
        backdrop: n.find(function(r) {
          return r.classList.contains(dw);
        })
      };
    }
    function fm(t2) {
      var e = ci(), n = ci();
      n.className = uw, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
      var r = ci();
      r.className = rm, r.setAttribute("data-state", "hidden"), sp(r, t2.props), e.appendChild(n), n.appendChild(r), o(t2.props, t2.props);
      function o(i, s) {
        var a = lc(e), l = a.box, c2 = a.content, u = a.arrow;
        s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (i.content !== s.content || i.allowHTML !== s.allowHTML) && sp(c2, t2.props), s.arrow ? u ? i.arrow !== s.arrow && (l.removeChild(u), l.appendChild(ip(s.arrow))) : l.appendChild(ip(s.arrow)) : u && l.removeChild(u);
      }
      return {
        popper: e,
        onUpdate: o
      };
    }
    fm.$$tippy = true;
    var Pw = 1, is = [], kl = [];
    function Bw(t2, e) {
      var n = op(t2, Object.assign({}, un, dm(Qd(e)))), r, o, i, s = false, a = false, l = false, c2 = false, u, d, p2, f = [], h2 = Xd(sn, n.interactiveDebounce), m, g = Pw++, b = null, E = mw(n.plugins), _ = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      }, v = {
        // properties
        id: g,
        reference: t2,
        popper: ci(),
        popperInstance: b,
        props: n,
        state: _,
        plugins: E,
        // methods
        clearDelayTimeouts: Kt,
        setProps: H,
        setContent: J,
        show: we,
        hide: Ie,
        hideWithInteractivity: gt,
        enable: pt,
        disable: An,
        unmount: an,
        destroy: qo
      };
      if (!n.render)
        return v;
      var T = n.render(v), S = T.popper, F = T.onUpdate;
      S.setAttribute("data-tippy-root", ""), S.id = "tippy-" + v.id, v.popper = S, t2._tippy = v, S._tippy = v;
      var V = E.map(function(O) {
        return O.fn(v);
      }), L = t2.hasAttribute("aria-expanded");
      return mn(), oe(), N(), D("onCreate", [v]), n.showOnCreate && Re(), S.addEventListener("mouseenter", function() {
        v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
      }), S.addEventListener("mouseleave", function() {
        v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && Ee().addEventListener("mousemove", h2);
      }), v;
      function W() {
        var O = v.props.touch;
        return Array.isArray(O) ? O : [O, 0];
      }
      function te() {
        return W()[0] === "hold";
      }
      function de() {
        var O;
        return !!((O = v.props.render) != null && O.$$tippy);
      }
      function ke() {
        return m || t2;
      }
      function Ee() {
        var O = ke().parentNode;
        return O ? kw(O) : document;
      }
      function fe() {
        return lc(S);
      }
      function he(O) {
        return v.state.isMounted && !v.state.isVisible || Kn.isTouch || u && u.type === "focus" ? 0 : yl(v.props.delay, O ? 0 : 1, un.delay);
      }
      function N(O) {
        O === void 0 && (O = false), S.style.pointerEvents = v.props.interactive && !O ? "" : "none", S.style.zIndex = "" + v.props.zIndex;
      }
      function D(O, Q, pe) {
        if (pe === void 0 && (pe = true), V.forEach(function(Ae) {
          Ae[O] && Ae[O].apply(Ae, Q);
        }), pe) {
          var $e;
          ($e = v.props)[O].apply($e, Q);
        }
      }
      function Y() {
        var O = v.props.aria;
        if (O.content) {
          var Q = "aria-" + O.content, pe = S.id, $e = wo(v.props.triggerTarget || t2);
          $e.forEach(function(Ae) {
            var wt = Ae.getAttribute(Q);
            if (v.state.isVisible)
              Ae.setAttribute(Q, wt ? wt + " " + pe : pe);
            else {
              var qt = wt && wt.replace(pe, "").trim();
              qt ? Ae.setAttribute(Q, qt) : Ae.removeAttribute(Q);
            }
          });
        }
      }
      function oe() {
        if (!(L || !v.props.aria.expanded)) {
          var O = wo(v.props.triggerTarget || t2);
          O.forEach(function(Q) {
            v.props.interactive ? Q.setAttribute("aria-expanded", v.state.isVisible && Q === ke() ? "true" : "false") : Q.removeAttribute("aria-expanded");
          });
        }
      }
      function ce() {
        Ee().removeEventListener("mousemove", h2), is = is.filter(function(O) {
          return O !== h2;
        });
      }
      function Se(O) {
        if (!(Kn.isTouch && (l || O.type === "mousedown"))) {
          var Q = O.composedPath && O.composedPath()[0] || O.target;
          if (!(v.props.interactive && tp(S, Q))) {
            if (wo(v.props.triggerTarget || t2).some(function(pe) {
              return tp(pe, Q);
            })) {
              if (Kn.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
                return;
            } else
              D("onClickOutside", [v, O]);
            v.props.hideOnClick === true && (v.clearDelayTimeouts(), v.hide(), a = true, setTimeout(function() {
              a = false;
            }), v.state.isMounted || Qe());
          }
        }
      }
      function Fe() {
        l = true;
      }
      function kt() {
        l = false;
      }
      function ze() {
        var O = Ee();
        O.addEventListener("mousedown", Se, true), O.addEventListener("touchend", Se, Kr), O.addEventListener("touchstart", kt, Kr), O.addEventListener("touchmove", Fe, Kr);
      }
      function Qe() {
        var O = Ee();
        O.removeEventListener("mousedown", Se, true), O.removeEventListener("touchend", Se, Kr), O.removeEventListener("touchstart", kt, Kr), O.removeEventListener("touchmove", Fe, Kr);
      }
      function on2(O, Q) {
        hn(O, function() {
          !v.state.isVisible && S.parentNode && S.parentNode.contains(S) && Q();
        });
      }
      function Nt(O, Q) {
        hn(O, Q);
      }
      function hn(O, Q) {
        var pe = fe().box;
        function $e(Ae) {
          Ae.target === pe && (El(pe, "remove", $e), Q());
        }
        if (O === 0)
          return Q();
        El(pe, "remove", d), El(pe, "add", $e), d = $e;
      }
      function At(O, Q, pe) {
        pe === void 0 && (pe = false);
        var $e = wo(v.props.triggerTarget || t2);
        $e.forEach(function(Ae) {
          Ae.addEventListener(O, Q, pe), f.push({
            node: Ae,
            eventType: O,
            handler: Q,
            options: pe
          });
        });
      }
      function mn() {
        te() && (At("touchstart", On, {
          passive: true
        }), At("touchend", Nn, {
          passive: true
        })), hw(v.props.trigger).forEach(function(O) {
          if (O !== "manual")
            switch (At(O, On), O) {
              case "mouseenter":
                At("mouseleave", Nn);
                break;
              case "focus":
                At(Tw ? "focusout" : "blur", ve);
                break;
              case "focusin":
                At("focusout", ve);
                break;
            }
        });
      }
      function $n() {
        f.forEach(function(O) {
          var Q = O.node, pe = O.eventType, $e = O.handler, Ae = O.options;
          Q.removeEventListener(pe, $e, Ae);
        }), f = [];
      }
      function On(O) {
        var Q, pe = false;
        if (!(!v.state.isEnabled || Xt(O) || a)) {
          var $e = ((Q = u) == null ? void 0 : Q.type) === "focus";
          u = O, m = O.currentTarget, oe(), !v.state.isVisible && yw(O) && is.forEach(function(Ae) {
            return Ae(O);
          }), O.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || s) && v.props.hideOnClick !== false && v.state.isVisible ? pe = true : Re(O), O.type === "click" && (s = !pe), pe && !$e && Wt(O);
        }
      }
      function sn(O) {
        var Q = O.target, pe = ke().contains(Q) || S.contains(Q);
        if (!(O.type === "mousemove" && pe)) {
          var $e = qe().concat(S).map(function(Ae) {
            var wt, qt = Ae._tippy, gr = (wt = qt.popperInstance) == null ? void 0 : wt.state;
            return gr ? {
              popperRect: Ae.getBoundingClientRect(),
              popperState: gr,
              props: n
            } : null;
          }).filter(Boolean);
          ww($e, O) && (ce(), Wt(O));
        }
      }
      function Nn(O) {
        var Q = Xt(O) || v.props.trigger.indexOf("click") >= 0 && s;
        if (!Q) {
          if (v.props.interactive) {
            v.hideWithInteractivity(O);
            return;
          }
          Wt(O);
        }
      }
      function ve(O) {
        v.props.trigger.indexOf("focusin") < 0 && O.target !== ke() || v.props.interactive && O.relatedTarget && S.contains(O.relatedTarget) || Wt(O);
      }
      function Xt(O) {
        return Kn.isTouch ? te() !== O.type.indexOf("touch") >= 0 : false;
      }
      function Bt() {
        le();
        var O = v.props, Q = O.popperOptions, pe = O.placement, $e = O.offset, Ae = O.getReferenceClientRect, wt = O.moveTransition, qt = de() ? lc(S).arrow : null, gr = Ae ? {
          getBoundingClientRect: Ae,
          contextElement: Ae.contextElement || ke()
        } : t2, Go = {
          name: "$$tippy",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function(M) {
            var U = M.state;
            if (de()) {
              var me = fe(), rt = me.box;
              ["placement", "reference-hidden", "escaped"].forEach(function(et) {
                et === "placement" ? rt.setAttribute("data-placement", U.placement) : U.attributes.popper["data-popper-" + et] ? rt.setAttribute("data-" + et, "") : rt.removeAttribute("data-" + et);
              }), U.attributes.popper = {};
            }
          }
        }, Zt = [{
          name: "offset",
          options: {
            offset: $e
          }
        }, {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: "flip",
          options: {
            padding: 5
          }
        }, {
          name: "computeStyles",
          options: {
            adaptive: !wt
          }
        }, Go];
        de() && qt && Zt.push({
          name: "arrow",
          options: {
            element: qt,
            padding: 3
          }
        }), Zt.push.apply(Zt, (Q == null ? void 0 : Q.modifiers) || []), v.popperInstance = cw(gr, S, Object.assign({}, Q, {
          placement: pe,
          onFirstUpdate: p2,
          modifiers: Zt
        }));
      }
      function le() {
        v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
      }
      function Vt() {
        var O = v.props.appendTo, Q, pe = ke();
        v.props.interactive && O === sm || O === "parent" ? Q = pe.parentNode : Q = am(O, [pe]), Q.contains(S) || Q.appendChild(S), v.state.isMounted = true, Bt();
      }
      function qe() {
        return qs(S.querySelectorAll("[data-tippy-root]"));
      }
      function Re(O) {
        v.clearDelayTimeouts(), O && D("onTrigger", [v, O]), ze();
        var Q = he(true), pe = W(), $e = pe[0], Ae = pe[1];
        Kn.isTouch && $e === "hold" && Ae && (Q = Ae), Q ? r = setTimeout(function() {
          v.show();
        }, Q) : v.show();
      }
      function Wt(O) {
        if (v.clearDelayTimeouts(), D("onUntrigger", [v, O]), !v.state.isVisible) {
          Qe();
          return;
        }
        if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(O.type) >= 0 && s)) {
          var Q = he(false);
          Q ? o = setTimeout(function() {
            v.state.isVisible && v.hide();
          }, Q) : i = requestAnimationFrame(function() {
            v.hide();
          });
        }
      }
      function pt() {
        v.state.isEnabled = true;
      }
      function An() {
        v.hide(), v.state.isEnabled = false;
      }
      function Kt() {
        clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
      }
      function H(O) {
        if (!v.state.isDestroyed) {
          D("onBeforeUpdate", [v, O]), $n();
          var Q = v.props, pe = op(t2, Object.assign({}, Q, Qd(O), {
            ignoreAttributes: true
          }));
          v.props = pe, mn(), Q.interactiveDebounce !== pe.interactiveDebounce && (ce(), h2 = Xd(sn, pe.interactiveDebounce)), Q.triggerTarget && !pe.triggerTarget ? wo(Q.triggerTarget).forEach(function($e) {
            $e.removeAttribute("aria-expanded");
          }) : pe.triggerTarget && t2.removeAttribute("aria-expanded"), oe(), N(), F && F(Q, pe), v.popperInstance && (Bt(), qe().forEach(function($e) {
            requestAnimationFrame($e._tippy.popperInstance.forceUpdate);
          })), D("onAfterUpdate", [v, O]);
        }
      }
      function J(O) {
        v.setProps({
          content: O
        });
      }
      function we() {
        var O = v.state.isVisible, Q = v.state.isDestroyed, pe = !v.state.isEnabled, $e = Kn.isTouch && !v.props.touch, Ae = yl(v.props.duration, 0, un.duration);
        if (!(O || Q || pe || $e) && !ke().hasAttribute("disabled") && (D("onShow", [v], false), v.props.onShow(v) !== false)) {
          if (v.state.isVisible = true, de() && (S.style.visibility = "visible"), N(), ze(), v.state.isMounted || (S.style.transition = "none"), de()) {
            var wt = fe(), qt = wt.box, gr = wt.content;
            vl([qt, gr], 0);
          }
          p2 = function() {
            var Zt;
            if (!(!v.state.isVisible || c2)) {
              if (c2 = true, S.offsetHeight, S.style.transition = v.props.moveTransition, de() && v.props.animation) {
                var k = fe(), M = k.box, U = k.content;
                vl([M, U], Ae), ep([M, U], "visible");
              }
              Y(), oe(), Zd(kl, v), (Zt = v.popperInstance) == null || Zt.forceUpdate(), D("onMount", [v]), v.props.animation && de() && Nt(Ae, function() {
                v.state.isShown = true, D("onShown", [v]);
              });
            }
          }, Vt();
        }
      }
      function Ie() {
        var O = !v.state.isVisible, Q = v.state.isDestroyed, pe = !v.state.isEnabled, $e = yl(v.props.duration, 1, un.duration);
        if (!(O || Q || pe) && (D("onHide", [v], false), v.props.onHide(v) !== false)) {
          if (v.state.isVisible = false, v.state.isShown = false, c2 = false, s = false, de() && (S.style.visibility = "hidden"), ce(), Qe(), N(true), de()) {
            var Ae = fe(), wt = Ae.box, qt = Ae.content;
            v.props.animation && (vl([wt, qt], $e), ep([wt, qt], "hidden"));
          }
          Y(), oe(), v.props.animation ? de() && on2($e, v.unmount) : v.unmount();
        }
      }
      function gt(O) {
        Ee().addEventListener("mousemove", h2), Zd(is, h2), h2(O);
      }
      function an() {
        v.state.isVisible && v.hide(), v.state.isMounted && (le(), qe().forEach(function(O) {
          O._tippy.unmount();
        }), S.parentNode && S.parentNode.removeChild(S), kl = kl.filter(function(O) {
          return O !== v;
        }), v.state.isMounted = false, D("onHidden", [v]));
      }
      function qo() {
        !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), $n(), delete t2._tippy, v.state.isDestroyed = true, D("onDestroy", [v]));
      }
    }
    function Zn(t2, e) {
      e === void 0 && (e = {});
      var n = un.plugins.concat(e.plugins || []);
      Cw();
      var r = Object.assign({}, e, {
        plugins: n
      }), o = Ew(t2);
      var a = o.reduce(function(l, c2) {
        var u = c2 && Bw(c2, r);
        return u && l.push(u), l;
      }, []);
      return Ti(t2) ? a[0] : a;
    }
    Zn.defaultProps = un;
    Zn.setDefaultProps = Iw;
    Zn.currentInput = Kn;
    Object.assign({}, Yh, {
      effect: function(e) {
        var n = e.state, r = {
          popper: {
            position: n.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
      }
    });
    Zn.setDefaultProps({
      render: fm
    });
    class $w {
      constructor({ editor: e, element: n, view: r, tippyOptions: o = {}, updateDelay: i = 250, shouldShow: s }) {
        this.preventHide = false, this.shouldShow = ({ view: a, state: l, from: c2, to: u }) => {
          const { doc: d, selection: p2 } = l, { empty: f } = p2, h2 = !d.textBetween(c2, u).length && $a(l.selection), m = this.element.contains(document.activeElement);
          return !(!(a.hasFocus() || m) || f || h2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.dragstartHandler = () => {
          this.hide();
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: a }) => {
          var l;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (a) => {
          this.blurHandler({ event: a });
        }, this.handleDebouncedUpdate = (a, l) => {
          const c2 = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
          !c2 && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, c2, u, l);
          }, this.updateDelay));
        }, this.updateHandler = (a, l, c2, u) => {
          var d, p2, f;
          const { state: h2, composing: m } = a, { selection: g } = h2;
          if (m || !l && !c2)
            return;
          this.createTooltip();
          const { ranges: E } = g, _ = Math.min(...E.map((S) => S.$from.pos)), v = Math.max(...E.map((S) => S.$to.pos));
          if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
            editor: this.editor,
            element: this.element,
            view: a,
            state: h2,
            oldState: u,
            from: _,
            to: v
          }))) {
            this.hide();
            return;
          }
          (p2 = this.tippy) === null || p2 === void 0 || p2.setProps({
            getReferenceClientRect: ((f = this.tippyOptions) === null || f === void 0 ? void 0 : f.getReferenceClientRect) || (() => {
              if (Kh(h2.selection)) {
                let S = a.nodeDOM(_);
                if (S) {
                  const F = S.dataset.nodeViewWrapper ? S : S.querySelector("[data-node-view-wrapper]");
                  if (F && (S = F.firstChild), S)
                    return S.getBoundingClientRect();
                }
              }
              return qh(a, _, v);
            })
          }), this.show();
        }, this.editor = e, this.element = n, this.view = r, this.updateDelay = i, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Zn(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "top",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, n) {
        const { state: r } = e, o = r.selection.from !== r.selection.to;
        if (this.updateDelay > 0 && o) {
          this.handleDebouncedUpdate(e, n);
          return;
        }
        const i = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
        this.updateHandler(e, i, s, n);
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, n;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const hm = (t2) => new Ue({
      key: typeof t2.pluginKey == "string" ? new Je(t2.pluginKey) : t2.pluginKey,
      view: (e) => new $w({ view: e, ...t2 })
    });
    Ke.create({
      name: "bubbleMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "bubbleMenu",
          updateDelay: void 0,
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          hm({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    class Fw {
      getTextContent(e) {
        return Vh(e, { textSerializers: qc(this.editor.schema) });
      }
      constructor({ editor: e, element: n, view: r, tippyOptions: o = {}, shouldShow: i }) {
        this.preventHide = false, this.shouldShow = ({ view: s, state: a }) => {
          const { selection: l } = a, { $anchor: c2, empty: u } = l, d = c2.depth === 1, p2 = c2.parent.isTextblock && !c2.parent.type.spec.code && !c2.parent.textContent && c2.parent.childCount === 0 && !this.getTextContent(c2.parent);
          return !(!s.hasFocus() || !u || !d || !p2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: s }) => {
          var a;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (s) => {
          this.blurHandler({ event: s });
        }, this.editor = e, this.element = n, this.view = r, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Zn(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "right",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, n) {
        var r, o, i;
        const { state: s } = e, { doc: a, selection: l } = s, { from: c2, to: u } = l;
        if (n && n.doc.eq(a) && n.selection.eq(l))
          return;
        if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
          editor: this.editor,
          view: e,
          state: s,
          oldState: n
        }))) {
          this.hide();
          return;
        }
        (o = this.tippy) === null || o === void 0 || o.setProps({
          getReferenceClientRect: ((i = this.tippyOptions) === null || i === void 0 ? void 0 : i.getReferenceClientRect) || (() => qh(e, c2, u))
        }), this.show();
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, n;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const mm = (t2) => new Ue({
      key: typeof t2.pluginKey == "string" ? new Je(t2.pluginKey) : t2.pluginKey,
      view: (e) => new Fw({ view: e, ...t2 })
    });
    Ke.create({
      name: "floatingMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "floatingMenu",
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          mm({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    const zw = /* @__PURE__ */ defineComponent({
      name: "BubbleMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "bubbleMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(t2, { slots: e }) {
        const n = ref(null);
        return onMounted(() => {
          const { updateDelay: r, editor: o, pluginKey: i, shouldShow: s, tippyOptions: a } = t2;
          o.registerPlugin(hm({
            updateDelay: r,
            editor: o,
            element: n.value,
            pluginKey: i,
            shouldShow: s,
            tippyOptions: a
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: r, editor: o } = t2;
          o.unregisterPlugin(r);
        }), () => {
          var r;
          return h("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
        };
      }
    });
    function ap(t2) {
      return customRef((e, n) => ({
        get() {
          return e(), t2;
        },
        set(r) {
          t2 = r, requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              n();
            });
          });
        }
      }));
    }
    class gm extends Dn {
      constructor(e = {}) {
        return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = ap(this.view.state), this.reactiveExtensionStorage = ap(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
          this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
        }), markRaw(this);
      }
      get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state;
      }
      get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
      }
      /**
       * Register a ProseMirror plugin.
       */
      registerPlugin(e, n) {
        const r = super.registerPlugin(e, n);
        return this.reactiveState && (this.reactiveState.value = r), r;
      }
      /**
       * Unregister a ProseMirror plugin.
       */
      unregisterPlugin(e) {
        const n = super.unregisterPlugin(e);
        return this.reactiveState && n && (this.reactiveState.value = n), n;
      }
    }
    const Hw = /* @__PURE__ */ defineComponent({
      name: "EditorContent",
      props: {
        editor: {
          default: null,
          type: Object
        }
      },
      setup(t2) {
        const e = ref(), n = getCurrentInstance();
        return watchEffect(() => {
          const r = t2.editor;
          r && r.options.element && e.value && nextTick(() => {
            if (!e.value || !r.options.element.firstChild)
              return;
            const o = unref(e.value);
            e.value.append(...r.options.element.childNodes), r.contentComponent = n.ctx._, n && (r.appContext = {
              ...n.appContext,
              // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
              // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
              // @ts-expect-error forward instance's 'provides' into appContext
              provides: n.provides
            }), r.setOptions({
              element: o
            }), r.createNodeViews();
          });
        }), onBeforeUnmount(() => {
          const r = t2.editor;
          r && (r.contentComponent = null, r.appContext = null);
        }), { rootEl: e };
      },
      render() {
        return h("div", {
          ref: (t2) => {
            this.rootEl = t2;
          }
        });
      }
    }), Uw = /* @__PURE__ */ defineComponent({
      name: "FloatingMenu",
      props: {
        pluginKey: {
          // TODO: TypeScript breaks :(
          // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
          type: null,
          default: "floatingMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(t2, { slots: e }) {
        const n = ref(null);
        return onMounted(() => {
          const { pluginKey: r, editor: o, tippyOptions: i, shouldShow: s } = t2;
          o.registerPlugin(mm({
            pluginKey: r,
            editor: o,
            element: n.value,
            tippyOptions: i,
            shouldShow: s
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: r, editor: o } = t2;
          o.unregisterPlugin(r);
        }), () => {
          var r;
          return h("div", { ref: n }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
        };
      }
    }), hr = /* @__PURE__ */ defineComponent({
      name: "NodeViewContent",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      render() {
        return h(this.as, {
          style: {
            whiteSpace: "pre-wrap"
          },
          "data-node-view-content": ""
        });
      }
    }), ou = /* @__PURE__ */ defineComponent({
      name: "NodeViewWrapper",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      inject: ["onDragStart", "decorationClasses"],
      render() {
        var t2, e;
        return h(this.as, {
          // @ts-ignore
          class: this.decorationClasses,
          style: {
            whiteSpace: "normal"
          },
          "data-node-view-wrapper": "",
          // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
          onDragstart: this.onDragStart
        }, (e = (t2 = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t2));
      }
    }), Vw = (t2 = {}) => {
      const e = shallowRef();
      return onMounted(() => {
        e.value = new gm(t2);
      }), onBeforeUnmount(() => {
        var n, r, o;
        const i = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, s = i == null ? void 0 : i.cloneNode(true);
        (r = i == null ? void 0 : i.parentNode) === null || r === void 0 || r.replaceChild(s, i), (o = e.value) === null || o === void 0 || o.destroy();
      }), e;
    };
    class bm {
      constructor(e, { props: n = {}, editor: r }) {
        this.editor = r, this.component = markRaw(e), this.el = document.createElement("div"), this.props = reactive(n), this.renderedComponent = this.renderComponent();
      }
      get element() {
        return this.renderedComponent.el;
      }
      get ref() {
        var e, n, r, o;
        return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (o = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || o === void 0 ? void 0 : o.proxy;
      }
      renderComponent() {
        let e = h(this.component, this.props);
        return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && render$1(e, this.el), { vNode: e, destroy: () => {
          this.el && render$1(null, this.el), this.el = null, e = null;
        }, el: this.el ? this.el.firstElementChild : null };
      }
      updateProps(e = {}) {
        Object.entries(e).forEach(([n, r]) => {
          this.props[n] = r;
        }), this.renderComponent();
      }
      destroy() {
        this.renderedComponent.destroy();
      }
    }
    const Ot = {
      editor: {
        type: Object,
        required: true
      },
      node: {
        type: Object,
        required: true
      },
      decorations: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        required: true
      },
      extension: {
        type: Object,
        required: true
      },
      getPos: {
        type: Function,
        required: true
      },
      updateAttributes: {
        type: Function,
        required: true
      },
      deleteNode: {
        type: Function,
        required: true
      },
      view: {
        type: Object,
        required: true
      },
      innerDecorations: {
        type: Object,
        required: true
      },
      HTMLAttributes: {
        type: Object,
        required: true
      }
    };
    class Ww extends rk {
      mount() {
        const e = {
          editor: this.editor,
          node: this.node,
          decorations: this.decorations,
          innerDecorations: this.innerDecorations,
          view: this.view,
          selected: false,
          extension: this.extension,
          HTMLAttributes: this.HTMLAttributes,
          getPos: () => this.getPos(),
          updateAttributes: (o = {}) => this.updateAttributes(o),
          deleteNode: () => this.deleteNode()
        }, n = this.onDragStart.bind(this);
        this.decorationClasses = ref(this.getDecorationClasses());
        const r = /* @__PURE__ */ defineComponent({
          extends: { ...this.component },
          props: Object.keys(e),
          template: this.component.template,
          setup: (o) => {
            var i, s;
            return provide("onDragStart", n), provide("decorationClasses", this.decorationClasses), (s = (i = this.component).setup) === null || s === void 0 ? void 0 : s.call(i, o, {
              expose: () => {
              }
            });
          },
          // add support for scoped styles
          // @ts-ignore
          // eslint-disable-next-line
          __scopeId: this.component.__scopeId,
          // add support for CSS Modules
          // @ts-ignore
          // eslint-disable-next-line
          __cssModules: this.component.__cssModules,
          // add support for vue devtools
          // @ts-ignore
          // eslint-disable-next-line
          __name: this.component.__name,
          // @ts-ignore
          // eslint-disable-next-line
          __file: this.component.__file
        });
        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new bm(r, {
          editor: this.editor,
          props: e
        });
      }
      /**
       * Return the DOM element.
       * This is the element that will be used to display the node view.
       */
      get dom() {
        if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
          throw Error("Please use the NodeViewWrapper component for your node view.");
        return this.renderer.element;
      }
      /**
       * Return the content DOM element.
       * This is the element that will be used to display the rich-text content of the node.
       */
      get contentDOM() {
        return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
      }
      /**
       * On editor selection update, check if the node is selected.
       * If it is, call `selectNode`, otherwise call `deselectNode`.
       */
      handleSelectionUpdate() {
        const { from: e, to: n } = this.editor.state.selection, r = this.getPos();
        if (typeof r == "number")
          if (e <= r && n >= r + this.node.nodeSize) {
            if (this.renderer.props.selected)
              return;
            this.selectNode();
          } else {
            if (!this.renderer.props.selected)
              return;
            this.deselectNode();
          }
      }
      /**
       * On update, update the React component.
       * To prevent unnecessary updates, the `update` option can be used.
       */
      update(e, n, r) {
        const o = (i) => {
          this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(i);
        };
        if (typeof this.options.update == "function") {
          const i = this.node, s = this.decorations, a = this.innerDecorations;
          return this.node = e, this.decorations = n, this.innerDecorations = r, this.options.update({
            oldNode: i,
            oldDecorations: s,
            newNode: e,
            newDecorations: n,
            oldInnerDecorations: a,
            innerDecorations: r,
            updateProps: () => o({ node: e, decorations: n, innerDecorations: r })
          });
        }
        return e.type !== this.node.type ? false : (e === this.node && this.decorations === n && this.innerDecorations === r || (this.node = e, this.decorations = n, this.innerDecorations = r, o({ node: e, decorations: n, innerDecorations: r })), true);
      }
      /**
       * Select the node.
       * Add the `selected` prop and the `ProseMirror-selectednode` class.
       */
      selectNode() {
        this.renderer.updateProps({
          selected: true
        }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
      }
      /**
       * Deselect the node.
       * Remove the `selected` prop and the `ProseMirror-selectednode` class.
       */
      deselectNode() {
        this.renderer.updateProps({
          selected: false
        }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
      }
      getDecorationClasses() {
        return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
      }
      destroy() {
        this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
      }
    }
    function Ln(t2, e) {
      return (n) => {
        if (!n.editor.contentComponent)
          return {};
        const r = typeof t2 == "function" && "__vccOpts" in t2 ? t2.__vccOpts : t2;
        return new Ww(r, n, e);
      };
    }
    const Kw = /^\s*>\s$/, ym = it.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["blockquote", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: t2 }) => t2.wrapIn(this.name),
          toggleBlockquote: () => ({ commands: t2 }) => t2.toggleWrap(this.name),
          unsetBlockquote: () => ({ commands: t2 }) => t2.lift(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          Lo({
            find: Kw,
            type: this.type
          })
        ];
      }
    }), qw = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, Gw = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, jw = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Yw = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, Jw = _n.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (t2) => t2.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (t2) => t2.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (t2) => /^(bold(er)?|[5-9]\d{2,})$/.test(t2) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["strong", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleBold: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetBold: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          lo({
            find: qw,
            type: this.type
          }),
          lo({
            find: jw,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          $r({
            find: Gw,
            type: this.type
          }),
          $r({
            find: Yw,
            type: this.type
          })
        ];
      }
    }), Xw = "listItem", lp = "textStyle", cp = /^\s*([-+*])\s$/, Zw = it.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["ul", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: t2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Xw, this.editor.getAttributes(lp)).run() : t2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let t2 = Lo({
          find: cp,
          type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t2 = Lo({
          find: cp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => this.editor.getAttributes(lp),
          editor: this.editor
        })), [
          t2
        ];
      }
    }), Qw = /(^|[^`])`([^`]+)`(?!`)/, e_ = /(^|[^`])`([^`]+)`(?!`)/g, t_ = _n.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["code", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleCode: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetCode: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          lo({
            find: Qw,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          $r({
            find: e_,
            type: this.type
          })
        ];
      }
    }), n_ = /^```([a-z]+)?[\s\n]$/, r_ = /^~~~([a-z]+)?[\s\n]$/, vm = it.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (t2) => {
              var e;
              const { languageClassPrefix: n } = this.options, i = [...((e = t2.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
              return i || null;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "pre",
          Be(this.options.HTMLAttributes, e),
          [
            "code",
            {
              class: t2.attrs.language ? this.options.languageClassPrefix + t2.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (t2) => ({ commands: e }) => e.setNode(this.name, t2),
          toggleCodeBlock: (t2) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t2)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: t2, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
            return !t2 || e.parent.type.name !== this.name ? false : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
          },
          // exit node on triple enter
          Enter: ({ editor: t2 }) => {
            if (!this.options.exitOnTripleEnter)
              return false;
            const { state: e } = t2, { selection: n } = e, { $from: r, empty: o } = n;
            if (!o || r.parent.type !== this.type)
              return false;
            const i = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
            return !i || !s ? false : t2.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), true)).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor: t2 }) => {
            if (!this.options.exitOnArrowDown)
              return false;
            const { state: e } = t2, { selection: n, doc: r } = e, { $from: o, empty: i } = n;
            if (!i || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
              return false;
            const a = o.after();
            return a === void 0 ? false : r.nodeAt(a) ? t2.commands.command(({ tr: c2 }) => (c2.setSelection(ue.near(r.resolve(a))), true)) : t2.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          rc({
            find: n_,
            type: this.type,
            getAttributes: (t2) => ({
              language: t2[1]
            })
          }),
          rc({
            find: r_,
            type: this.type,
            getAttributes: (t2) => ({
              language: t2[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new Ue({
            key: new Je("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (t2, e) => {
                if (!e.clipboardData || this.editor.isActive(this.type.name))
                  return false;
                const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), o = r ? JSON.parse(r) : void 0, i = o == null ? void 0 : o.mode;
                if (!n || !i)
                  return false;
                const { tr: s, schema: a } = t2.state, l = a.text(n.replace(/\r\n?/g, `
`));
                return s.replaceSelectionWith(this.type.create({ language: i }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(ie.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", true), t2.dispatch(s), true;
              }
            }
          })
        ];
      }
    }), Em = it.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    function o_(t2 = {}) {
      return new Ue({
        view(e) {
          return new i_(e, t2);
        }
      });
    }
    class i_ {
      constructor(e, n) {
        var r;
        this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === false ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
          let i = (s) => {
            this[o](s);
          };
          return e.dom.addEventListener(o, i), { name: o, handler: i };
        });
      }
      destroy() {
        this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
      }
      update(e, n) {
        this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
      }
      setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
      }
      updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
        if (n) {
          let a = e.nodeBefore, l = e.nodeAfter;
          if (a || l) {
            let c2 = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
            if (c2) {
              let u = c2.getBoundingClientRect(), d = a ? u.bottom : u.top;
              a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
            }
          }
        }
        if (!r) {
          let a = this.editorView.coordsAtPos(this.cursorPos);
          r = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
        }
        let o = this.editorView.dom.offsetParent;
        this.element || (this.element = o.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let i, s;
        if (!o || o == document.body && getComputedStyle(o).position == "static")
          i = -pageXOffset, s = -pageYOffset;
        else {
          let a = o.getBoundingClientRect();
          i = a.left - o.scrollLeft, s = a.top - o.scrollTop;
        }
        this.element.style.left = r.left - i + "px", this.element.style.top = r.top - s + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
      }
      scheduleRemoval(e) {
        clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
      }
      dragover(e) {
        if (!this.editorView.editable)
          return;
        let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), o = r && r.type.spec.disableDropCursor, i = typeof o == "function" ? o(this.editorView, n, e) : o;
        if (n && !i) {
          let s = n.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let a = Df(this.editorView.state.doc, s, this.editorView.dragging.slice);
            a != null && (s = a);
          }
          this.setCursor(s), this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
      }
    }
    const s_ = Ke.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          o_(this.options)
        ];
      }
    });
    class ct extends ue {
      /**
      Create a gap cursor.
      */
      constructor(e) {
        super(e, e);
      }
      map(e, n) {
        let r = e.resolve(n.map(this.head));
        return ct.valid(r) ? new ct(r) : ue.near(r);
      }
      content() {
        return K.empty;
      }
      eq(e) {
        return e instanceof ct && e.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new ct(e.resolve(n.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new iu(this.anchor);
      }
      /**
      @internal
      */
      static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !a_(e) || !l_(e))
          return false;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
          return r;
        let o = n.contentMatchAt(e.index()).defaultType;
        return o && o.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom(e, n, r = false) {
        e: for (; ; ) {
          if (!r && ct.valid(e))
            return e;
          let o = e.pos, i = null;
          for (let s = e.depth; ; s--) {
            let a = e.node(s);
            if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
              i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
              break;
            } else if (s == 0)
              return null;
            o += n;
            let l = e.doc.resolve(o);
            if (ct.valid(l))
              return l;
          }
          for (; ; ) {
            let s = n > 0 ? i.firstChild : i.lastChild;
            if (!s) {
              if (i.isAtom && !i.isText && !re.isSelectable(i)) {
                e = e.doc.resolve(o + i.nodeSize * n), r = false;
                continue e;
              }
              break;
            }
            i = s, o += n;
            let a = e.doc.resolve(o);
            if (ct.valid(a))
              return a;
          }
          return null;
        }
      }
    }
    ct.prototype.visible = false;
    ct.findFrom = ct.findGapCursorFrom;
    ue.jsonID("gapcursor", ct);
    class iu {
      constructor(e) {
        this.pos = e;
      }
      map(e) {
        return new iu(e.map(this.pos));
      }
      resolve(e) {
        let n = e.resolve(this.pos);
        return ct.valid(n) ? new ct(n) : ue.near(n);
      }
    }
    function a_(t2) {
      for (let e = t2.depth; e >= 0; e--) {
        let n = t2.index(e), r = t2.node(e);
        if (n == 0) {
          if (r.type.spec.isolating)
            return true;
          continue;
        }
        for (let o = r.child(n - 1); ; o = o.lastChild) {
          if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
            return true;
          if (o.inlineContent)
            return false;
        }
      }
      return true;
    }
    function l_(t2) {
      for (let e = t2.depth; e >= 0; e--) {
        let n = t2.indexAfter(e), r = t2.node(e);
        if (n == r.childCount) {
          if (r.type.spec.isolating)
            return true;
          continue;
        }
        for (let o = r.child(n); ; o = o.firstChild) {
          if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
            return true;
          if (o.inlineContent)
            return false;
        }
      }
      return true;
    }
    function c_() {
      return new Ue({
        props: {
          decorations: f_,
          createSelectionBetween(t2, e, n) {
            return e.pos == n.pos && ct.valid(n) ? new ct(n) : null;
          },
          handleClick: d_,
          handleKeyDown: u_,
          handleDOMEvents: { beforeinput: p_ }
        }
      });
    }
    const u_ = $c({
      ArrowLeft: ss("horiz", -1),
      ArrowRight: ss("horiz", 1),
      ArrowUp: ss("vert", -1),
      ArrowDown: ss("vert", 1)
    });
    function ss(t2, e) {
      const n = t2 == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
      return function(r, o, i) {
        let s = r.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
        if (s instanceof ie) {
          if (!i.endOfTextblock(n) || a.depth == 0)
            return false;
          l = false, a = r.doc.resolve(e > 0 ? a.after() : a.before());
        }
        let c2 = ct.findGapCursorFrom(a, e, l);
        return c2 ? (o && o(r.tr.setSelection(new ct(c2))), true) : false;
      };
    }
    function d_(t2, e, n) {
      if (!t2 || !t2.editable)
        return false;
      let r = t2.state.doc.resolve(e);
      if (!ct.valid(r))
        return false;
      let o = t2.posAtCoords({ left: n.clientX, top: n.clientY });
      return o && o.inside > -1 && re.isSelectable(t2.state.doc.nodeAt(o.inside)) ? false : (t2.dispatch(t2.state.tr.setSelection(new ct(r))), true);
    }
    function p_(t2, e) {
      if (e.inputType != "insertCompositionText" || !(t2.state.selection instanceof ct))
        return false;
      let { $from: n } = t2.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t2.state.schema.nodes.text);
      if (!r)
        return false;
      let o = R.empty;
      for (let s = r.length - 1; s >= 0; s--)
        o = R.from(r[s].createAndFill(null, o));
      let i = t2.state.tr.replace(n.pos, n.pos, new K(o, 0, 0));
      return i.setSelection(ie.near(i.doc.resolve(n.pos + 1))), t2.dispatch(i), false;
    }
    function f_(t2) {
      if (!(t2.selection instanceof ct))
        return null;
      let e = document.createElement("div");
      return e.className = "ProseMirror-gapcursor", He.create(t2.doc, [ht.widget(t2.selection.head, e, { key: "gapcursor" })]);
    }
    const h_ = Ke.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          c_()
        ];
      },
      extendNodeSchema(t2) {
        var e;
        const n = {
          name: t2.name,
          options: t2.options,
          storage: t2.storage
        };
        return {
          allowGapCursor: (e = Te(Z(t2, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
        };
      }
    }), m_ = it.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["br", Be(this.options.HTMLAttributes, t2)];
      },
      renderText() {
        return `
`;
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: t2, chain: e, state: n, editor: r }) => t2.first([
            () => t2.exitCode(),
            () => t2.command(() => {
              const { selection: o, storedMarks: i } = n;
              if (o.$from.parent.type.spec.isolating)
                return false;
              const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = i || o.$to.parentOffset && o.$from.marks();
              return e().insertContent({ type: this.name }).command(({ tr: c2, dispatch: u }) => {
                if (u && l && s) {
                  const d = l.filter((p2) => a.includes(p2.type.name));
                  c2.ensureMarks(d);
                }
                return true;
              }).run();
            })
          ])
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    }), km = it.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((t2) => ({
          tag: `h${t2}`,
          attrs: { level: t2 }
        }));
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [`h${this.options.levels.includes(t2.attrs.level) ? t2.attrs.level : this.options.levels[0]}`, Be(this.options.HTMLAttributes, e), 0];
      },
      addCommands() {
        return {
          setHeading: (t2) => ({ commands: e }) => this.options.levels.includes(t2.level) ? e.setNode(this.name, t2) : false,
          toggleHeading: (t2) => ({ commands: e }) => this.options.levels.includes(t2.level) ? e.toggleNode(this.name, "paragraph", t2) : false
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((t2, e) => ({
          ...t2,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((t2) => rc({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t2}})\\s$`),
          type: this.type,
          getAttributes: {
            level: t2
          }
        }));
      }
    });
    var Gs = 200, xt = function() {
    };
    xt.prototype.append = function(e) {
      return e.length ? (e = xt.from(e), !this.length && e || e.length < Gs && this.leafAppend(e) || this.length < Gs && e.leafPrepend(this) || this.appendInner(e)) : this;
    };
    xt.prototype.prepend = function(e) {
      return e.length ? xt.from(e).append(this) : this;
    };
    xt.prototype.appendInner = function(e) {
      return new g_(this, e);
    };
    xt.prototype.slice = function(e, n) {
      return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? xt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
    };
    xt.prototype.get = function(e) {
      if (!(e < 0 || e >= this.length))
        return this.getInner(e);
    };
    xt.prototype.forEach = function(e, n, r) {
      n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
    };
    xt.prototype.map = function(e, n, r) {
      n === void 0 && (n = 0), r === void 0 && (r = this.length);
      var o = [];
      return this.forEach(function(i, s) {
        return o.push(e(i, s));
      }, n, r), o;
    };
    xt.from = function(e) {
      return e instanceof xt ? e : e && e.length ? new wm(e) : xt.empty;
    };
    var wm = /* @__PURE__ */ function(t2) {
      function e(r) {
        t2.call(this), this.values = r;
      }
      t2 && (e.__proto__ = t2), e.prototype = Object.create(t2 && t2.prototype), e.prototype.constructor = e;
      var n = { length: { configurable: true }, depth: { configurable: true } };
      return e.prototype.flatten = function() {
        return this.values;
      }, e.prototype.sliceInner = function(o, i) {
        return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
      }, e.prototype.getInner = function(o) {
        return this.values[o];
      }, e.prototype.forEachInner = function(o, i, s, a) {
        for (var l = i; l < s; l++)
          if (o(this.values[l], a + l) === false)
            return false;
      }, e.prototype.forEachInvertedInner = function(o, i, s, a) {
        for (var l = i - 1; l >= s; l--)
          if (o(this.values[l], a + l) === false)
            return false;
      }, e.prototype.leafAppend = function(o) {
        if (this.length + o.length <= Gs)
          return new e(this.values.concat(o.flatten()));
      }, e.prototype.leafPrepend = function(o) {
        if (this.length + o.length <= Gs)
          return new e(o.flatten().concat(this.values));
      }, n.length.get = function() {
        return this.values.length;
      }, n.depth.get = function() {
        return 0;
      }, Object.defineProperties(e.prototype, n), e;
    }(xt);
    xt.empty = new wm([]);
    var g_ = /* @__PURE__ */ function(t2) {
      function e(n, r) {
        t2.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
      }
      return t2 && (e.__proto__ = t2), e.prototype = Object.create(t2 && t2.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten());
      }, e.prototype.getInner = function(r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
      }, e.prototype.forEachInner = function(r, o, i, s) {
        var a = this.left.length;
        if (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === false || i > a && this.right.forEachInner(r, Math.max(o - a, 0), Math.min(this.length, i) - a, s + a) === false)
          return false;
      }, e.prototype.forEachInvertedInner = function(r, o, i, s) {
        var a = this.left.length;
        if (o > a && this.right.forEachInvertedInner(r, o - a, Math.max(i, a) - a, s + a) === false || i < a && this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === false)
          return false;
      }, e.prototype.sliceInner = function(r, o) {
        if (r == 0 && o == this.length)
          return this;
        var i = this.left.length;
        return o <= i ? this.left.slice(r, o) : r >= i ? this.right.slice(r - i, o - i) : this.left.slice(r, i).append(this.right.slice(0, o - i));
      }, e.prototype.leafAppend = function(r) {
        var o = this.right.leafAppend(r);
        if (o)
          return new e(this.left, o);
      }, e.prototype.leafPrepend = function(r) {
        var o = this.left.leafPrepend(r);
        if (o)
          return new e(o, this.right);
      }, e.prototype.appendInner = function(r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
      }, e;
    }(xt);
    const b_ = 500;
    class Rn {
      constructor(e, n) {
        this.items = e, this.eventCount = n;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(e, n) {
        if (this.eventCount == 0)
          return null;
        let r = this.items.length;
        for (; ; r--)
          if (this.items.get(r - 1).selection) {
            --r;
            break;
          }
        let o, i;
        n && (o = this.remapping(r, this.items.length), i = o.maps.length);
        let s = e.tr, a, l, c2 = [], u = [];
        return this.items.forEach((d, p2) => {
          if (!d.step) {
            o || (o = this.remapping(r, p2 + 1), i = o.maps.length), i--, u.push(d);
            return;
          }
          if (o) {
            u.push(new Un(d.map));
            let f = d.step.map(o.slice(i)), h2;
            f && s.maybeStep(f).doc && (h2 = s.mapping.maps[s.mapping.maps.length - 1], c2.push(new Un(h2, void 0, void 0, c2.length + u.length))), i--, h2 && o.appendMap(h2, i);
          } else
            s.maybeStep(d.step);
          if (d.selection)
            return a = o ? d.selection.map(o.slice(i)) : d.selection, l = new Rn(this.items.slice(0, r).append(u.reverse().concat(c2)), this.eventCount - 1), false;
        }, this.items.length, 0), { remaining: l, transform: s, selection: a };
      }
      // Create a new branch with the given transform added.
      addTransform(e, n, r, o) {
        let i = [], s = this.eventCount, a = this.items, l = !o && a.length ? a.get(a.length - 1) : null;
        for (let u = 0; u < e.steps.length; u++) {
          let d = e.steps[u].invert(e.docs[u]), p2 = new Un(e.mapping.maps[u], d, n), f;
          (f = l && l.merge(p2)) && (p2 = f, u ? i.pop() : a = a.slice(0, a.length - 1)), i.push(p2), n && (s++, n = void 0), o || (l = p2);
        }
        let c2 = s - r.depth;
        return c2 > v_ && (a = y_(a, c2), s -= c2), new Rn(a.append(i), s);
      }
      remapping(e, n) {
        let r = new yi();
        return this.items.forEach((o, i) => {
          let s = o.mirrorOffset != null && i - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
          r.appendMap(o.map, s);
        }, e, n), r;
      }
      addMaps(e) {
        return this.eventCount == 0 ? this : new Rn(this.items.append(e.map((n) => new Un(n))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(e, n) {
        if (!this.eventCount)
          return this;
        let r = [], o = Math.max(0, this.items.length - n), i = e.mapping, s = e.steps.length, a = this.eventCount;
        this.items.forEach((p2) => {
          p2.selection && a--;
        }, o);
        let l = n;
        this.items.forEach((p2) => {
          let f = i.getMirror(--l);
          if (f == null)
            return;
          s = Math.min(s, f);
          let h2 = i.maps[f];
          if (p2.step) {
            let m = e.steps[f].invert(e.docs[f]), g = p2.selection && p2.selection.map(i.slice(l + 1, f));
            g && a++, r.push(new Un(h2, m, g));
          } else
            r.push(new Un(h2));
        }, o);
        let c2 = [];
        for (let p2 = n; p2 < s; p2++)
          c2.push(new Un(i.maps[p2]));
        let u = this.items.slice(0, o).append(c2).append(r), d = new Rn(u, a);
        return d.emptyItemCount() > b_ && (d = d.compress(this.items.length - r.length)), d;
      }
      emptyItemCount() {
        let e = 0;
        return this.items.forEach((n) => {
          n.step || e++;
        }), e;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(e = this.items.length) {
        let n = this.remapping(0, e), r = n.maps.length, o = [], i = 0;
        return this.items.forEach((s, a) => {
          if (a >= e)
            o.push(s), s.selection && i++;
          else if (s.step) {
            let l = s.step.map(n.slice(r)), c2 = l && l.getMap();
            if (r--, c2 && n.appendMap(c2, r), l) {
              let u = s.selection && s.selection.map(n.slice(r));
              u && i++;
              let d = new Un(c2.invert(), l, u), p2, f = o.length - 1;
              (p2 = o.length && o[f].merge(d)) ? o[f] = p2 : o.push(d);
            }
          } else s.map && r--;
        }, this.items.length, 0), new Rn(xt.from(o.reverse()), i);
      }
    }
    Rn.empty = new Rn(xt.empty, 0);
    function y_(t2, e) {
      let n;
      return t2.forEach((r, o) => {
        if (r.selection && e-- == 0)
          return n = o, false;
      }), t2.slice(n);
    }
    class Un {
      constructor(e, n, r, o) {
        this.map = e, this.step = n, this.selection = r, this.mirrorOffset = o;
      }
      merge(e) {
        if (this.step && e.step && !e.selection) {
          let n = e.step.merge(this.step);
          if (n)
            return new Un(n.getMap().invert(), n, this.selection);
        }
      }
    }
    class wr {
      constructor(e, n, r, o, i) {
        this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = o, this.prevComposition = i;
      }
    }
    const v_ = 20;
    function E_(t2, e, n, r) {
      let o = n.getMeta(no), i;
      if (o)
        return o.historyState;
      n.getMeta(__) && (t2 = new wr(t2.done, t2.undone, null, 0, -1));
      let s = n.getMeta("appendedTransaction");
      if (n.steps.length == 0)
        return t2;
      if (s && s.getMeta(no))
        return s.getMeta(no).redo ? new wr(t2.done.addTransform(n, void 0, r, Ts(e)), t2.undone, up(n.mapping.maps), t2.prevTime, t2.prevComposition) : new wr(t2.done, t2.undone.addTransform(n, void 0, r, Ts(e)), null, t2.prevTime, t2.prevComposition);
      if (n.getMeta("addToHistory") !== false && !(s && s.getMeta("addToHistory") === false)) {
        let a = n.getMeta("composition"), l = t2.prevTime == 0 || !s && t2.prevComposition != a && (t2.prevTime < (n.time || 0) - r.newGroupDelay || !k_(n, t2.prevRanges)), c2 = s ? wl(t2.prevRanges, n.mapping) : up(n.mapping.maps);
        return new wr(t2.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, Ts(e)), Rn.empty, c2, n.time, a ?? t2.prevComposition);
      } else return (i = n.getMeta("rebased")) ? new wr(t2.done.rebased(n, i), t2.undone.rebased(n, i), wl(t2.prevRanges, n.mapping), t2.prevTime, t2.prevComposition) : new wr(t2.done.addMaps(n.mapping.maps), t2.undone.addMaps(n.mapping.maps), wl(t2.prevRanges, n.mapping), t2.prevTime, t2.prevComposition);
    }
    function k_(t2, e) {
      if (!e)
        return false;
      if (!t2.docChanged)
        return true;
      let n = false;
      return t2.mapping.maps[0].forEach((r, o) => {
        for (let i = 0; i < e.length; i += 2)
          r <= e[i + 1] && o >= e[i] && (n = true);
      }), n;
    }
    function up(t2) {
      let e = [];
      for (let n = t2.length - 1; n >= 0 && e.length == 0; n--)
        t2[n].forEach((r, o, i, s) => e.push(i, s));
      return e;
    }
    function wl(t2, e) {
      if (!t2)
        return null;
      let n = [];
      for (let r = 0; r < t2.length; r += 2) {
        let o = e.map(t2[r], 1), i = e.map(t2[r + 1], -1);
        o <= i && n.push(o, i);
      }
      return n;
    }
    function w_(t2, e, n) {
      let r = Ts(e), o = no.get(e).spec.config, i = (n ? t2.undone : t2.done).popEvent(e, r);
      if (!i)
        return null;
      let s = i.selection.resolve(i.transform.doc), a = (n ? t2.done : t2.undone).addTransform(i.transform, e.selection.getBookmark(), o, r), l = new wr(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
      return i.transform.setSelection(s).setMeta(no, { redo: n, historyState: l });
    }
    let _l = false, dp = null;
    function Ts(t2) {
      let e = t2.plugins;
      if (dp != e) {
        _l = false, dp = e;
        for (let n = 0; n < e.length; n++)
          if (e[n].spec.historyPreserveItems) {
            _l = true;
            break;
          }
      }
      return _l;
    }
    const no = new Je("history"), __ = new Je("closeHistory");
    function S_(t2 = {}) {
      return t2 = {
        depth: t2.depth || 100,
        newGroupDelay: t2.newGroupDelay || 500
      }, new Ue({
        key: no,
        state: {
          init() {
            return new wr(Rn.empty, Rn.empty, null, 0, -1);
          },
          apply(e, n, r) {
            return E_(n, r, e, t2);
          }
        },
        config: t2,
        props: {
          handleDOMEvents: {
            beforeinput(e, n) {
              let r = n.inputType, o = r == "historyUndo" ? Sm : r == "historyRedo" ? Cm : null;
              return o ? (n.preventDefault(), o(e.state, e.dispatch)) : false;
            }
          }
        }
      });
    }
    function _m(t2, e) {
      return (n, r) => {
        let o = no.getState(n);
        if (!o || (t2 ? o.undone : o.done).eventCount == 0)
          return false;
        if (r) {
          let i = w_(o, n, t2);
          i && r(i.scrollIntoView());
        }
        return true;
      };
    }
    const Sm = _m(false), Cm = _m(true), C_ = Ke.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state: t2, dispatch: e }) => Sm(t2, e),
          redo: () => ({ state: t2, dispatch: e }) => Cm(t2, e)
        };
      },
      addProseMirrorPlugins() {
        return [
          S_(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-я": () => this.editor.commands.undo(),
          "Shift-Mod-я": () => this.editor.commands.redo()
        };
      }
    }), xm = it.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["hr", Be(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain: t2, state: e }) => {
            const { selection: n } = e, { $from: r, $to: o } = n, i = t2();
            return r.parentOffset === 0 ? i.insertContentAt({
              from: Math.max(r.pos - 1, 0),
              to: o.pos
            }, {
              type: this.name
            }) : Kh(n) ? i.insertContentAt(o.pos, {
              type: this.name
            }) : i.insertContent({ type: this.name }), i.command(({ tr: s, dispatch: a }) => {
              var l;
              if (a) {
                const { $to: c2 } = s.selection, u = c2.end();
                if (c2.nodeAfter)
                  c2.nodeAfter.isTextblock ? s.setSelection(ie.create(s.doc, c2.pos + 1)) : c2.nodeAfter.isBlock ? s.setSelection(re.create(s.doc, c2.pos)) : s.setSelection(ie.create(s.doc, c2.pos));
                else {
                  const d = (l = c2.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                  d && (s.insert(u, d), s.setSelection(ie.create(s.doc, u + 1)));
                }
                s.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          Ha({
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    }), x_ = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, T_ = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, O_ = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, N_ = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, A_ = _n.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (t2) => t2.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (t2) => t2.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["em", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleItalic: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetItalic: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          lo({
            find: x_,
            type: this.type
          }),
          lo({
            find: O_,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          $r({
            find: T_,
            type: this.type
          }),
          $r({
            find: N_,
            type: this.type
          })
        ];
      }
    }), M_ = it.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["li", Be(this.options.HTMLAttributes, t2), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    }), R_ = "listItem", pp = "textStyle", fp = /^(\d+)\.\s$/, I_ = it.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (t2) => t2.hasAttribute("start") ? parseInt(t2.getAttribute("start") || "", 10) : 1
          },
          type: {
            default: void 0,
            parseHTML: (t2) => t2.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        const { start: e, ...n } = t2;
        return e === 1 ? ["ol", Be(this.options.HTMLAttributes, n), 0] : ["ol", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: t2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(R_, this.editor.getAttributes(pp)).run() : t2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let t2 = Lo({
          find: fp,
          type: this.type,
          getAttributes: (e) => ({ start: +e[1] }),
          joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t2 = Lo({
          find: fp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(pp) }),
          joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
          editor: this.editor
        })), [
          t2
        ];
      }
    }), Tm = it.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["p", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: t2 }) => t2.setNode(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    }), D_ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, L_ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, P_ = _n.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (t2) => t2.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["s", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleStrike: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetStrike: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          lo({
            find: D_,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          $r({
            find: L_,
            type: this.type
          })
        ];
      }
    }), B_ = it.create({
      name: "text",
      group: "inline"
    }), $_ = Ke.create({
      name: "starterKit",
      addExtensions() {
        var t2, e, n, r, o, i, s, a, l, c2, u, d, p2, f, h2, m, g, b;
        const E = [];
        return this.options.bold !== false && E.push(Jw.configure((t2 = this.options) === null || t2 === void 0 ? void 0 : t2.bold)), this.options.blockquote !== false && E.push(ym.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && E.push(Zw.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)), this.options.code !== false && E.push(t_.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)), this.options.codeBlock !== false && E.push(vm.configure((o = this.options) === null || o === void 0 ? void 0 : o.codeBlock)), this.options.document !== false && E.push(Em.configure((i = this.options) === null || i === void 0 ? void 0 : i.document)), this.options.dropcursor !== false && E.push(s_.configure((s = this.options) === null || s === void 0 ? void 0 : s.dropcursor)), this.options.gapcursor !== false && E.push(h_.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && E.push(m_.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== false && E.push(km.configure((c2 = this.options) === null || c2 === void 0 ? void 0 : c2.heading)), this.options.history !== false && E.push(C_.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== false && E.push(xm.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== false && E.push(A_.configure((p2 = this.options) === null || p2 === void 0 ? void 0 : p2.italic)), this.options.listItem !== false && E.push(M_.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)), this.options.orderedList !== false && E.push(I_.configure((h2 = this.options) === null || h2 === void 0 ? void 0 : h2.orderedList)), this.options.paragraph !== false && E.push(Tm.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== false && E.push(P_.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)), this.options.text !== false && E.push(B_.configure((b = this.options) === null || b === void 0 ? void 0 : b.text)), E;
      }
    }), F_ = (t2) => {
      if (!t2.children.length)
        return;
      const e = t2.querySelectorAll("span");
      e && e.forEach((n) => {
        var r, o;
        const i = n.getAttribute("style"), s = (o = (r = n.parentElement) === null || r === void 0 ? void 0 : r.closest("span")) === null || o === void 0 ? void 0 : o.getAttribute("style");
        n.setAttribute("style", `${s};${i}`);
      });
    }, z_ = _n.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return {
          HTMLAttributes: {},
          mergeNestedSpanStyles: false
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (t2) => t2.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && F_(t2), {}) : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["span", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle: () => ({ tr: t2 }) => {
            const { selection: e } = t2;
            return t2.doc.nodesBetween(e.from, e.to, (n, r) => {
              if (n.isTextblock)
                return true;
              n.marks.filter((o) => o.type === this.type).some((o) => Object.values(o.attrs).some((i) => !!i)) || t2.removeMark(r, r + n.nodeSize, this.type);
            }), true;
          }
        };
      }
    }), ye = /* @__PURE__ */ defineComponent({
      __name: "OIcon",
      props: {
        name: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        small: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("span", {
          class: normalizeClass(["o-icon", { small: t2.small }]),
          style: normalizeStyle({ color: t2.color })
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["yiitip-icon", `icon-${t2.name}`])
          }, null, 2)
        ], 6));
      }
    }), hp = {
      isoName: "en-us",
      nativeName: "English (US)",
      diagram: {
        name: "Text Diagram",
        flow: "Flow Diagram",
        sequence: "Sequence Diagram",
        class: "Class Diagram",
        state: "State Diagram",
        gantt: "Gantt Diagram",
        tips: "Generation of diagram and chart from text in a similar manner as markdown"
      },
      editor: {
        add: "Add",
        addMore: "Add More",
        url: "URL",
        bold: "Bold",
        italic: "Italic",
        strikethrough: "Strikethrough",
        underline: "Underline",
        textFormat: "More text format",
        list: "List",
        unorderedList: "Unordered List",
        orderedList: "Ordered List",
        todoList: "Todo List",
        subscript: "Subscript",
        superscript: "Superscript",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Toggle Fullscreen",
        quote: "Quote",
        left: "Left align",
        center: "Center align",
        right: "Right align",
        justify: "Justify align",
        print: "Print",
        outdent: "Decrease indentation",
        indent: "Increase indentation",
        indentDropdown: "Indent",
        removeFormat: "Remove formatting",
        formatting: "Formatting",
        fontFamily: "Font Family",
        defaultFont: "Default Font",
        fontSize: "Font Size",
        align: "Align",
        hr: "Insert Horizontal Rule",
        undo: "Undo",
        redo: "Redo",
        heading: "Heading & Paragraph",
        heading1: "Heading 1",
        heading2: "Heading 2",
        heading3: "Heading 3",
        heading4: "Heading 4",
        heading5: "Heading 5",
        headings: "Headings",
        paragraph: "Paragraph",
        code: "Code",
        codeBlock: "Code Block",
        size1: "Very small",
        size2: "A bit small",
        size3: "Normal",
        size4: "Medium-large",
        size5: "Big",
        size6: "Very big",
        size7: "Maximum",
        viewSource: "View Source",
        textColor: "Text Color",
        highlightColor: "Highlight Color",
        default: "Default",
        lineHeight: "Line Height",
        blockquote: "Blockquote",
        table: "Table",
        photo: "Insert Photo",
        video: "Insert Video",
        formula: "Formula",
        inlineFormula: "Inline",
        blockFormula: "Block",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancel",
        color: "Color",
        edit: "Edit",
        link: "Link",
        linkAddress: "Link Address",
        ok: "Ok",
        preview: "Preview",
        template: "Template",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        replace: "Replace",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        more: "More",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Image Preferences",
        ratio: "Ratio",
        size: "Size",
        width: "Width",
        height: "Height",
        src: "Image Source",
        caption: "Caption",
        link: "Link",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, H_ = {
      isoName: "pl",
      nativeName: "Polski",
      diagram: {
        name: "Schemat tekstowy",
        flow: "Schemat przepływu",
        sequence: "Schemat sekwencji",
        class: "Schemat klas",
        state: "Diagram stanu",
        gantt: "Diagram Gantta",
        tips: "Generowanie diagramu i wykresu z tekstu w podobny sposób jak markdown"
      },
      editor: {
        add: "Dodaj",
        addMore: "Dodaj więcej",
        url: "URL",
        bold: "Pogrubienie",
        italic: "Kursywa",
        strikethrough: "Przekreślenie",
        underline: "Podkreślenie",
        textFormat: "More text format",
        unorderedList: "Lista wypunktowana",
        orderedList: "Lista numerowana",
        list: "List",
        todoList: "Lista rzeczy do zrobienia",
        subscript: "Indeks dolny",
        superscript: "Indeks górny",
        hyperlink: "Hiperłącze",
        toggleFullscreen: "Przełącz na tryb pełnoekranowy",
        quote: "Zacytuj",
        left: "Wyrównaj do lewej",
        center: "Wyrównaj do środka",
        right: "Wyrównaj do prawej",
        justify: "Wyjustuj",
        print: "Drukuj",
        outdent: "Zmniejsz wcięcie",
        indent: "Zwiększ wcięcie",
        indentDropdown: "Wcięcie",
        removeFormat: "Usuń formatowanie",
        formatting: "Formatowanie",
        fontFamily: "Nazwa czcionki",
        defaultFont: "Domyślna czcionka",
        fontSize: "Rozmiar czcionki",
        align: "Wyrównanie",
        hr: "Wstaw poziomą linię",
        undo: "Cofnij",
        redo: "Przywróć",
        heading: "Heading & Paragraph",
        heading1: "Nagłówek 1",
        heading2: "Nagłówek 2",
        heading3: "Nagłówek 3",
        heading4: "Nagłówek 4",
        heading5: "Nagłówek 5",
        headings: "Nagłówki",
        paragraph: "Paragraf",
        code: "Kod",
        codeBlock: "Blok kodu",
        size1: "Bardzo mała",
        size2: "Mała",
        size3: "Normalna",
        size4: "Średnio-duża",
        size5: "Duża",
        size6: "Bardzo duża",
        size7: "Maksymalna",
        viewSource: "Pokaż źródło",
        textColor: "Kolor czcionki",
        highlightColor: "Kolor wyróżnienia",
        default: "Dymyślny",
        lineHeight: "Wysokość linii",
        blockquote: "Cytat",
        table: "Tabela",
        photo: "Wstaw obraz",
        video: "Insert Video",
        formula: "Formuła",
        inlineFormula: "Formuła w treści",
        blockFormula: "Blokowa formuła",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Anuluj",
        edit: "Edycja",
        link: "Łącze",
        linkAddress: "Adres łącza",
        ok: "Ok",
        preview: "Podgląd",
        template: "Szablon",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferencje obrazu",
        ratio: "Ratio",
        size: "Rozmiar",
        width: "Szerokość",
        height: "Wysokość",
        src: "Źródło obrazu",
        caption: "Nagłówek",
        link: "Łącze",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, U_ = {
      isoName: "pt-br",
      nativeName: "Português (BR)",
      diagram: {
        name: "Diagrama de Texto",
        flow: "Diagrama de Fluxo",
        sequence: "Diagrama de sequência",
        class: "Diagrama de Classe",
        state: "Diagrama de Estado",
        gantt: "Diagrama de Gantt",
        tips: "Geração de diagrama ou gráfico a partir de texto semelhante a markdown"
      },
      editor: {
        add: "Adicionar",
        addMore: "Adicione Mais",
        url: "URL",
        bold: "Negrito",
        italic: "Itálico",
        strikethrough: "Tachar",
        underline: "Sublinhado",
        textFormat: "Mais formatos de textos",
        list: "Lista",
        unorderedList: "Lista com Marcadores",
        orderedList: "Lista Numerada",
        todoList: "Lista de afazer",
        subscript: "Subscrito",
        superscript: "Sobrescrito",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Alternar tela-cheia",
        quote: "Citação",
        left: "Alinhar à esquerda",
        center: "Alinhar ao centro",
        right: "Alinhar à direita",
        justify: "Justificar",
        print: "Imprimir",
        outdent: "Diminuir recuo",
        indent: "Aumentar recuo",
        indentDropdown: "Recuo",
        removeFormat: "Limpar formatação",
        formatting: "Formatação",
        fontFamily: "Fonte",
        defaultFont: "Fonte Padrão",
        fontSize: "Tamanho da fontee",
        align: "Alinhamento",
        hr: "Linha Horizontal",
        undo: "Desfazer",
        redo: "Refazer",
        heading: "Heading & Paragraph",
        heading1: "Título 1",
        heading2: "Título 2",
        heading3: "Título 3",
        heading4: "Título 4",
        heading5: "Título 5",
        headings: "Estilos de Parágrafo",
        paragraph: "Parágrafo",
        code: "Código",
        codeBlock: "Bloco de Código",
        size1: "Muito Pequeno",
        size2: "Pequeno",
        size3: "Normal",
        size4: "Médio",
        size5: "Grande",
        size6: "Enorme",
        size7: "Máximo",
        viewSource: "Código Fonte",
        textColor: "Cor do texto",
        highlightColor: "Cor do fundo",
        default: "Padrão",
        lineHeight: "Espaço entre linhas",
        blockquote: "Bloco de citação",
        table: "Tabela",
        photo: "Inserir Foto",
        video: "Insert Video",
        formula: "Fórmula",
        inlineFormula: "Linha",
        blockFormula: "Bloco",
        thirdPartyService: "Serviços de terceiros",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancelar",
        edit: "Editar",
        link: "Link",
        linkAddress: "Endereço do Link",
        ok: "Ok",
        preview: "Pré Visualização",
        template: "Modelo",
        example: "Exemplo",
        submit: "Enviar",
        settings: "Configurações",
        remove: "Excluir",
        help: "Ajuda",
        back: "Voltar",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferências da Imagem",
        ratio: "Ratio",
        size: "Tamanho",
        width: "Largura",
        height: "Altura",
        src: "Origem da imagem",
        caption: "Legenda",
        link: "Link",
        lockAspectRatio: "Bloquear proporção",
        unlockAspectRatio: "Desbloquear proporção",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Vídeo",
        map: "Mapa",
        design: "Design",
        develop: "Desenvolvimento",
        data: "Dados",
        others: "Outros",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, mp = {
      isoName: "zh-hans",
      nativeName: "简体中文",
      diagram: {
        name: "文本绘图",
        flow: "流程图",
        sequence: "时序图",
        class: "类图",
        state: "状态图",
        gantt: "甘特图",
        tips: "使用Markdown风格文本生成流程图、顺序图、类图、状态图和甘特图"
      },
      editor: {
        add: "添加",
        addMore: "添加更多",
        url: "URL",
        bold: "粗体",
        italic: "斜体",
        strikethrough: "删除线",
        underline: "下划线",
        textFormat: "更多格式",
        list: "列表",
        unorderedList: "无序列表",
        orderedList: "有序列表",
        todoList: "任务列表",
        subscript: "下标",
        superscript: "上标",
        hyperlink: "超链接",
        toggleFullscreen: "全屏切换",
        quote: "引号",
        left: "左对齐",
        center: "居中对齐",
        right: "右对齐",
        justify: "两端对齐",
        print: "打印",
        outdent: "减少缩进",
        indent: "增加缩进",
        indentDropdown: "缩进",
        removeFormat: "清除格式",
        formatting: "格式化",
        fontFamily: "字体",
        defaultFont: "默认字体",
        fontSize: "字体大小",
        align: "对齐方式",
        hr: "插入分割线",
        undo: "撤消",
        redo: "重做",
        heading: "标题与段落",
        heading1: "标题一",
        heading2: "标题二",
        heading3: "标题三",
        heading4: "标题四",
        heading5: "标题五",
        headings: "标题",
        paragraph: "正文",
        code: "代码",
        codeBlock: "代码块",
        size1: "非常小",
        size2: "比较小",
        size3: "正常",
        size4: "中等偏大",
        size5: "大",
        size6: "非常大",
        size7: "超级大",
        viewSource: "查看资料",
        textColor: "文字颜色",
        highlightColor: "背景颜色",
        default: "默认",
        lineHeight: "行高",
        blockquote: "引用",
        table: "表格",
        photo: "图片",
        video: "视频",
        formula: "数学公式",
        inlineFormula: "行内公式",
        blockFormula: "块级公式",
        thirdPartyService: "第三方服务",
        horizontal: "水平线",
        callout: "高亮块",
        emoji: "表情",
        defaultColor: "默认颜色",
        noColor: "无色",
        delete: "删除",
        duplicate: "创建副本"
      },
      label: {
        ai: "AI",
        cancel: "取消",
        color: "颜色",
        edit: "编辑",
        link: "链接",
        linkAddress: "链接地址",
        ok: "确定",
        preview: "预览",
        template: "模板",
        example: "示例",
        submit: "确定",
        settings: "设置",
        remove: "删除",
        replace: "替换",
        help: "帮助",
        back: "返回",
        styles: "样式",
        basic: "基础",
        basicBlocks: "基础块",
        common: "常用",
        media: "多媒体",
        image: "图片",
        video: "视频",
        model: "模型",
        modelViewer: "模型",
        more: "更多",
        toc: "目录",
        untitled: "未命名",
        typeForCommands: "输入 '/' 显示命令",
        empty: "空白页面",
        emptyTips: "按回车开始编辑，或从下方选择",
        copy: "复制",
        cut: "剪切",
        search: "搜索"
      },
      table: {
        cellBackground: "单元格背景色",
        insert: "插入表格",
        remove: "删除表格",
        addColumn: "添加列",
        removeColumn: "删除列",
        addRow: "添加行",
        removeRow: "删除行",
        merge: "合并/拆分 单元格"
      },
      image: {
        preferences: "图片设置",
        ratio: "比例",
        size: "尺寸",
        width: "宽度",
        height: "高度",
        src: "图片地址",
        caption: "图片说明",
        link: "链接",
        lockAspectRatio: "锁定长宽比",
        unlockAspectRatio: "解锁长宽比",
        original: "原始",
        small: "小",
        medium: "中",
        large: "大"
      },
      embed: {
        video: "视频",
        map: "地图",
        design: "设计",
        develop: "开发",
        data: "数据",
        others: "其它",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "优酷",
        iqiyi: "爱奇艺",
        bilibili: "Bilibili",
        qqvideo: "腾讯视频",
        google_map: "谷歌地图",
        amap: "高德地图",
        baidu_map: "百度",
        modao: "墨刀",
        lanhu: "蓝湖",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "金数据",
        iframe: "IFrame",
        linkTips: "链接或代码",
        linkWarning: "无效的链接"
      },
      link: {
        back: "返回主菜单",
        edit: "编辑链接",
        off: "取消链接",
        open: "打开链接",
        open_in_new_tab: "在新标签页打开"
      }
    }, V_ = {
      isoName: "zh-hant",
      nativeName: "繁體中文",
      diagram: {
        name: "文本繪圖",
        flow: "流程圖",
        sequence: "時序圖",
        class: "類圖",
        state: "狀態圖",
        gantt: "甘特圖",
        tips: "使用Markdown風格文本生成流程圖、順序圖、類圖、狀態圖和甘特圖"
      },
      editor: {
        add: "添加",
        addMore: "添加更多",
        url: "URL",
        bold: "粗體",
        italic: "斜體",
        strikethrough: "刪除線",
        underline: "下劃線",
        textFormat: "更多格式",
        list: "列表",
        unorderedList: "無序列表",
        orderedList: "有序列表",
        todoList: "任務列表",
        subscript: "下標",
        superscript: "上標",
        hyperlink: "超鏈接",
        toggleFullscreen: "全屏切換",
        quote: "引號",
        left: "左對齊",
        center: "居中對齊",
        right: "右對齊",
        justify: "兩端對齊",
        print: "打印",
        outdent: "減少縮進",
        indent: "增加縮進",
        indentDropdown: "縮進",
        removeFormat: "清除格式",
        formatting: "格式化",
        fontFamily: "字體",
        defaultFont: "默認字體",
        fontSize: "字體大小",
        align: "對齊方式",
        hr: "插入分割線",
        undo: "撤消",
        redo: "重做",
        heading: "標題與段落",
        heading1: "標題一",
        heading2: "標題二",
        heading3: "標題三",
        heading4: "標題四",
        heading5: "標題五",
        headings: "標題",
        paragraph: "正文",
        code: "代碼",
        codeBlock: "代碼塊",
        size1: "非常小",
        size2: "比較小",
        size3: "正常",
        size4: "中等偏大",
        size5: "大",
        size6: "非常大",
        size7: "超級大",
        viewSource: "查看資料",
        textColor: "文字顏色",
        highlightColor: "背景顏色",
        default: "默認",
        lineHeight: "行高",
        blockquote: "引用",
        table: "表格",
        photo: "圖片",
        video: "視頻",
        formula: "數學公式",
        inlineFormula: "行內公式",
        blockFormula: "塊級公式",
        thirdPartyService: "第三方服務",
        horizontal: "水平線",
        callout: "高亮塊",
        emoji: "表情",
        defaultColor: "默認顏色",
        noColor: "無色",
        delete: "刪除",
        duplicate: "創建副本"
      },
      label: {
        ai: "AI",
        cancel: "取消",
        edit: "編輯",
        link: "鏈接",
        linkAddress: "鏈接地址",
        ok: "確定",
        preview: "預覽",
        template: "模板",
        example: "示例",
        submit: "確定",
        settings: "設置",
        remove: "刪除",
        help: "幫助",
        back: "返回",
        styles: "樣式",
        basic: "基础",
        basicBlocks: "基础块",
        common: "常用",
        media: "多媒體",
        image: "圖片",
        video: "視頻",
        model: "模型",
        modelViewer: "模型",
        toc: "目錄",
        untitled: "未命名",
        typeForCommands: "輸入 '/' 顯示命令",
        empty: "空白页面",
        emptyTips: "按回车开始编辑，或从下方选择",
        copy: "複製",
        cut: "剪切",
        search: "搜索"
      },
      table: {
        cellBackground: "單元格背景色",
        insert: "插入表格",
        remove: "刪除表格",
        addColumn: "添加列",
        removeColumn: "刪除列",
        addRow: "添加行",
        removeRow: "刪除行",
        merge: "合併/拆分 單元格"
      },
      image: {
        preferences: "圖片設置",
        ratio: "比例",
        size: "尺寸",
        width: "寬度",
        height: "高度",
        src: "圖片地址",
        caption: "圖片說明",
        link: "鏈接",
        lockAspectRatio: "鎖定長寬比",
        unlockAspectRatio: "解鎖長寬比",
        original: "原始",
        small: "小",
        medium: "中",
        large: "大"
      },
      embed: {
        video: "視頻",
        map: "地圖",
        design: "設計",
        develop: "開發",
        data: "數據",
        others: "其它",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "優酷",
        iqiyi: "愛奇藝",
        bilibili: "Bilibili",
        qqvideo: "騰訊視頻",
        google_map: "谷歌地圖",
        amap: "高德地圖",
        baidu_map: "百度",
        modao: "墨刀",
        lanhu: "藍湖",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "金數據",
        iframe: "IFrame",
        linkTips: "鏈接或代碼",
        linkWarning: "無效的鏈接"
      },
      link: {
        back: "返回主菜單",
        edit: "編輯鏈接",
        off: "取消鏈接",
        open: "打開鏈接",
        open_in_new_tab: "在新標籤頁打開"
      }
    }, Om = {
      en: hp,
      "en-us": hp,
      pl: H_,
      "pt-br": U_,
      zh: mp,
      "zh-hans": mp,
      "zh-hant": V_
    }, W_ = "en", K_ = Om[W_], q_ = (t2) => Om[t2] || K_;
    function Le() {
      const t2 = inject("locale", { value: "en" }), e = computed(() => q_(t2.value));
      function n(r) {
        return r.split(".").reduce((o, i) => {
          if (o) return o[i];
        }, e.value);
      }
      return {
        locale: t2,
        message: e,
        tr: n
      };
    }
    function Va() {
      const t2 = inject("darkMode", { value: false }), e = computed(() => t2.value ? "dark" : "light");
      return {
        darkMode: t2,
        theme: e
      };
    }
    function Ze() {
      function t2(n, r, o = {}) {
        const i = n == null ? void 0 : n.chain().focus(), s = n == null ? void 0 : n.commands;
        e(s, i, r, o);
      }
      function e(n, r, o, i = {}) {
        switch (console.log("command", o, i), o) {
          // case 'aiViewer':
          // 	focus.setAiViewer({
          // 		content: 'init',
          // 	}).run()
          // 	break
          case "backColor":
            i.color ? n.setHighlight({ color: i.color }) : n.unsetHighlight();
            break;
          case "blockquote":
            r.toggleBlockquote().run();
            break;
          case "bold":
            r.toggleBold().run();
            break;
          case "bulletList":
            r.toggleBulletList().run();
            break;
          case "callout":
            r.toggleCallout().run();
            break;
          case "clearFormat":
            r.unsetAllMarks().run();
            break;
          case "code":
            r.toggleCode().run();
            break;
          case "codeBlock":
            n.toggleCodeBlock({ language: "bash" });
            break;
          // case 'columns':
          // 	commands.setColumns(2)
          // 	break
          case "content":
            n.insertContent(i.content);
            break;
          case "fontFamily":
            n.setFontFamily(i.fontFamily);
            break;
          case "foreColor":
            n.setColor(i.color);
            break;
          case "heading":
            r.toggleHeading(i).run();
            break;
          case "horizontalRule":
            r.setHorizontalRule().run();
            break;
          case "image":
            r.setImage({
              src: "init"
            }).run();
            break;
          case "imageUpdate":
            r.setImage(
              i
            ).run();
            break;
          case "italic":
            r.toggleItalic().run();
            break;
          case "linkSet":
            r.extendMarkRange("link").setLink(
              i
            ).run();
            break;
          case "linkUnset":
            r.extendMarkRange("link").unsetLink().run();
            break;
          // case 'modelViewer':
          // 	focus.setModelViewer({
          // 		src: 'init',
          // 	}).run()
          // 	break
          // case 'modelViewerUpdate':
          // 	focus.setModelViewer(options).run()
          // 	break
          case "orderedList":
            r.toggleOrderedList().run();
            break;
          case "paragraph":
            r.setParagraph().run();
            break;
          case "strike":
            r.toggleStrike().run();
            break;
          case "table":
            r.insertTable({
              rows: 3,
              cols: 3,
              withHeaderRow: true
            }).run();
            break;
          case "tableAddColumn":
            r.addColumnAfter().run();
            break;
          case "tableAddRow":
            r.addRowAfter().run();
            break;
          case "tableCellAttribute":
            r.setCellAttribute(i.name, i.value).run();
            break;
          case "tableDeleteColumn":
            r.deleteColumn().run();
            break;
          case "tableDeleteRow":
            r.deleteRow().run();
            break;
          case "tableDelete":
            r.deleteTable().run();
            break;
          case "tableInsert":
            r.insertTable(i).run();
            break;
          case "tableMergeCells":
            r.mergeCells().run();
            break;
          case "tableSelectColumn":
            r.selectColumn(i.pos).run();
            break;
          case "tableSelectRow":
            r.selectRow(i.pos).run();
            break;
          case "tableSplitCell":
            r.splitCell().run();
            break;
          case "taskList":
            n.toggleTaskList();
            break;
          case "textAlign":
            r.setTextAlign(i.textAlign).run();
            break;
          case "underline":
            r.toggleUnderline().run();
            break;
          case "video":
            r.setVideo({
              src: "init"
            }).run();
        }
      }
      return {
        run: t2,
        onCommand: e
      };
    }
    const ho = /* @__PURE__ */ defineComponent({
      __name: "OTooltip",
      props: {
        placement: {
          type: String,
          default: "top"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
          // default: 'click'
        }
      },
      setup(t2) {
        const e = t2, { theme: n } = Va(), r = ref(), o = ref(), i = ref();
        function s() {
          i.value = Zn(r.value, {
            appendTo: () => document.body,
            animation: "perspective",
            // scale, shift-away
            content: o.value,
            duration: 100,
            interactive: true,
            placement: e.placement,
            trigger: e.trigger
          });
        }
        function a() {
          i.value.setProps({
            theme: n.value
          });
        }
        return watch(n, (l) => {
          a();
        }), onMounted(() => {
          s();
        }), (l, c2) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: r,
          "data-tippy-role": "tooltip"
        }, [
          renderSlot(l.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: o,
            class: "tooltip-content"
          }, [
            renderSlot(l.$slots, "default")
          ], 512)
        ], 512));
      }
    }), je = /* @__PURE__ */ defineComponent({
      __name: "OMenubarBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (r, o) => (openBlock(), createBlock(ho, {
          class: "o-tooltip",
          placement: t2.placement
        }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: o[0] || (o[0] = (i) => n("click", i))
            }, [
              createVNode(ye, {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"])
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 1
        }, 8, ["placement"]));
      }
    }), G_ = /* @__PURE__ */ defineComponent({
      __name: "OSimpleCommandBtn",
      props: {
        name: {
          type: String,
          default: ""
        },
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { run: n } = Ze(), { tr: r } = Le(), o = computed(() => ({
          aiViewer: { icon: "auto_awesome", tooltip: r("label.ai") },
          blockquote: { icon: "format_quote_open", tooltip: r("editor.blockquote") },
          bold: { icon: "format_bold", tooltip: r("editor.bold") },
          callout: { icon: "card_text", tooltip: r("editor.callout") },
          clearFormat: { icon: "format_clear", tooltip: r("editor.removeFormat") },
          code: { icon: "code", tooltip: r("editor.code") },
          codeBlock: { icon: "code_braces", tooltip: r("editor.codeBlock") },
          columns: {
            icon: "splitscreen_vertical_add",
            tooltip: "Column",
            rotate: true
          },
          horizontalRule: { icon: "horizontal_rule", tooltip: r("editor.hr") },
          italic: { icon: "format_italic", tooltip: r("editor.italic") },
          image: { icon: "image", tooltip: r("editor.photo") },
          linkUnset: { icon: "link_off", tooltip: r("link.off") },
          modelViewer: { icon: "3d_rotation", tooltip: r("label.modelViewer") },
          strike: {
            icon: "format_strikethrough",
            tooltip: r("editor.strikethrough")
          },
          underline: { icon: "format_underlined", tooltip: r("editor.underline") },
          video: { icon: "videocam", tooltip: r("editor.video") }
        })), i = computed(() => o.value[e.name] || {
          icon: "",
          isActive: false,
          command: () => {
          }
        });
        function s() {
          n(e.editor, e.name);
        }
        return (a, l) => {
          var c2;
          return openBlock(), createBlock(je, {
            class: "o-simple-command-btn",
            icon: i.value.icon,
            tooltip: i.value.tooltip,
            "content-class": {
              "is-active": (c2 = t2.editor) == null ? void 0 : c2.isActive(t2.name),
              "rotate-90": i.value.rotate
            },
            onClick: s
          }, null, 8, ["icon", "tooltip", "content-class"]);
        };
      }
    }), j_ = { class: "o-block-placeholder" }, Y_ = { class: "icon" }, J_ = { class: "placeholder" }, Nm = /* @__PURE__ */ defineComponent({
      __name: "OBlockPlaceholder",
      props: {
        icon: {
          type: String,
          default: "image"
        },
        placeholder: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("section", j_, [
          createBaseVNode("div", Y_, [
            createVNode(unref(ye), { name: t2.icon }, null, 8, ["name"])
          ]),
          createBaseVNode("div", J_, toDisplayString(t2.placeholder), 1)
        ]));
      }
    }), Pe = {
      amber: "#ffc107",
      blue: "#2172e0",
      brown: "#795548",
      cyan: "#00bcd4",
      deepOrange: "#ff5722",
      deepPurple: "#673ab7",
      green: "#4caf50",
      indigo: "#3f51b5",
      lightBlue: "#03a9f4",
      lightGreen: "#8bc34a",
      lime: "#cddc39",
      orange: "#ff9800",
      purple: "#9c27b0",
      pink: "#e91e63",
      red: "#f44336",
      teal: "#009688",
      yellow: "#ffeb3b"
    }, Vi = [
      {
        label: "editor.paragraph",
        value: "paragraph",
        icon: "title",
        // title, format_paragraph, local_parking
        color: "",
        style: true,
        group: "label.basic"
      },
      {
        label: "editor.heading1",
        value: "heading",
        icon: "format_h1",
        color: Pe.blue,
        style: true,
        options: { level: 1 }
      },
      {
        label: "editor.heading2",
        value: "heading",
        icon: "format_h2",
        color: Pe.blue,
        style: true,
        options: { level: 2 }
      },
      {
        label: "editor.heading3",
        value: "heading",
        icon: "format_h3",
        color: Pe.blue,
        style: true,
        options: { level: 3 }
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        color: Pe.indigo,
        style: true
      },
      {
        label: "editor.unorderedList",
        value: "bulletList",
        icon: "format_list_bulleted",
        color: Pe.indigo,
        style: true
      },
      {
        label: "editor.orderedList",
        value: "orderedList",
        icon: "format_list_numbered",
        color: Pe.indigo,
        style: true
      },
      {
        label: "editor.blockquote",
        value: "blockquote",
        icon: "format_quote_open",
        color: Pe.brown,
        style: true
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        color: Pe.lightBlue,
        style: true
      },
      {
        label: "editor.horizontal",
        value: "horizontalRule",
        icon: "horizontal_rule",
        color: Pe.blue
      },
      {
        label: "editor.callout",
        value: "callout",
        color: Pe.deepOrange,
        icon: "card_text",
        style: false
      },
      {
        label: "editor.emoji",
        value: "emoji",
        icon: "emoji_emotions",
        color: Pe.blue
      }
    ], js = Vi.filter((t2) => t2.style), Ni = [
      {
        label: "label.ai",
        value: "aiViewer",
        icon: "auto_awesome",
        color: Pe.purple,
        tips: "ai",
        group: "label.ai"
      },
      {
        label: "editor.callout",
        value: "callout",
        icon: "card_text",
        color: Pe.deepOrange,
        tips: "callout",
        group: "label.common"
      },
      {
        label: "editor.table",
        value: "table",
        icon: "window",
        tips: "table",
        color: Pe.cyan
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        tips: "code",
        color: Pe.blue
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        tips: "task",
        color: Pe.indigo
      },
      {
        label: "label.image",
        value: "image",
        icon: "image",
        color: Pe.amber,
        tips: "image",
        group: "label.media"
      },
      {
        label: "label.video",
        value: "video",
        icon: "videocam",
        tips: "video",
        color: Pe.purple
      },
      {
        label: "label.model",
        value: "modelViewer",
        icon: "3d_rotation",
        tips: "model",
        color: Pe.purple
      }
    ], su = [...Vi, ...Ni], gp = [
      {
        label: "editor.duplicate",
        value: "duplicate",
        icon: "content_copy",
        color: Pe.blue,
        tips: "Ctrl+D",
        group: "label.common",
        filter: "common"
      },
      {
        label: "editor.delete",
        value: "delete",
        icon: "delete",
        tips: "Ctrl+D",
        color: Pe.deepOrange,
        filter: "common"
      },
      {
        label: "label.replace",
        value: "replace",
        icon: "cached",
        tips: "Ctrl+R",
        color: Pe.blue,
        filter: "image,video,model"
      },
      {
        label: "label.color",
        value: "palette",
        icon: "palette",
        color: Pe.purple,
        filter: "callout",
        component: "OCalloutColorBoard"
      }
    ], X_ = {
      key: 1,
      class: "group o-tips"
    }, Z_ = { class: "suffix o-tips" }, Q_ = {
      key: 1,
      class: "item"
    }, Wo = /* @__PURE__ */ defineComponent({
      __name: "OBlockMenu",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        },
        colorful: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: Boolean,
          default: false
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: o } = Le(), i = ref([]), s = computed(() => {
          var f;
          return (f = n.node) == null ? void 0 : f.type.name;
        }), a = computed(() => {
          const f = gp.filter(
            (m) => {
              var g;
              return ((g = m.filter) == null ? void 0 : g.indexOf("common")) >= 0;
            }
          ), h2 = gp.filter(
            (m) => {
              var g;
              return ((g = m.filter) == null ? void 0 : g.indexOf(s.value)) >= 0;
            }
          );
          if (h2.length > 0) {
            const m = h2[0];
            m.group = `editor.${s.value}`;
          }
          return [...f, ...h2];
        });
        function l(f) {
          switch (f.component) {
            case "OCalloutColorBoard":
              return Mm;
            default:
              return null;
          }
        }
        function c2(f) {
          r("action", f), setTimeout(() => {
            u(f);
          }, 0);
        }
        function u(f) {
          switch (f.value) {
            case "delete":
              n.deleteNode();
              break;
            case "duplicate":
              d();
              break;
          }
        }
        function d() {
          var b, E, _;
          const f = n.node.nodeSize, h2 = n.getPos() + f, m = JSON.parse(JSON.stringify(n.node));
          (b = n.editor) == null || b.commands.insertContentAt(h2, {
            type: "paragraph"
          }), (E = n.editor) == null || E.commands.insertContentAt(h2, m);
          const g = h2 + f + 1;
          (_ = n.editor) == null || _.commands.focus(g);
        }
        function p2(f, h2) {
          switch (console.log("select", f, h2), h2.name) {
            case "backColor":
              n.updateAttributes({ backColor: h2.value });
              break;
            case "foreColor":
              n.updateAttributes({ borderColor: h2.value });
              break;
          }
        }
        return (f, h2) => (openBlock(), createBlock(unref(Pn), {
          class: "o-block-menu",
          hoverable: "",
          clickable: ""
        }, {
          default: withCtx(() => [
            a.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(a.value, (m, g) => (openBlock(), createElementBlock(Fragment, { key: g }, [
              m.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                g > 0 ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                t2.showGroup ? (openBlock(), createElementBlock("div", X_, toDisplayString(unref(o)(m.group)), 1)) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true),
              l(m) ? (openBlock(), createBlock(unref(st), {
                key: 1,
                ref_for: true,
                ref: i.value[m.value],
                offset: [0, 16],
                placement: "right"
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(Tn), {
                    class: "item",
                    clickable: ""
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: m.icon,
                        color: t2.colorful ? m.color : ""
                      }, null, 8, ["name", "color"])
                    ]),
                    suffix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: "navigate_next",
                        class: "o-tips"
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(o)(m.label)), 1)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(l(m)), {
                    onSelect: (b) => p2(m, b)
                  }, null, 40, ["onSelect"]))
                ]),
                _: 2
              }, 1536)) : (openBlock(), createBlock(unref(Tn), {
                key: 2,
                class: "item",
                clickable: "",
                onClick: (b) => c2(m)
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ye), {
                    name: m.icon,
                    color: t2.colorful ? m.color : ""
                  }, null, 8, ["name", "color"])
                ]),
                suffix: withCtx(() => [
                  createBaseVNode("div", Z_, toDisplayString(m.tips), 1)
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString(unref(o)(m.label)), 1)
                ]),
                _: 2
              }, 1032, ["onClick"]))
            ], 64))), 128)) : (openBlock(), createElementBlock("div", Q_, "No result"))
          ]),
          _: 1
        }));
      }
    }), Ai = /* @__PURE__ */ defineComponent({
      __name: "OBlockPopover",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        placement: {
          type: String,
          default: "bottom-center"
        },
        showArrow: {
          type: Boolean,
          default: false
        },
        hideClickOutside: {
          type: Boolean,
          default: false
        },
        tippyClass: {
          type: String,
          default: ""
        },
        offset: {
          type: Array,
          default: function() {
            return [0, 10];
          }
        }
      },
      emits: ["update:modelValue", "show", "hide"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, o = ref();
        function i(a) {
          r("update:modelValue", a);
        }
        function s() {
          n.hideClickOutside && r("update:modelValue", false);
        }
        return watch(
          () => n.modelValue,
          (a) => {
            var l, c2;
            console.log("modelValue", a), a ? (l = o.value) == null || l.setShow(true) : (c2 = o.value) == null || c2.setShow(false);
          }
        ), onMounted(() => {
          var a;
          n.modelValue && ((a = o.value) == null || a.setShow(true));
        }), (a, l) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          placement: t2.placement,
          "tippy-class": t2.tippyClass,
          trigger: "manual",
          arrow: t2.showArrow,
          offset: t2.offset,
          show: t2.modelValue,
          "onUpdate:show": i,
          onClickoutside: s
        }, {
          trigger: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          default: withCtx(() => [
            renderSlot(a.$slots, "popover-content")
          ]),
          _: 3
        }, 8, ["placement", "tippy-class", "arrow", "offset", "show"]));
      }
    }), eS = { class: "o-block-toolbar" }, tS = { class: "button-group" }, Am = /* @__PURE__ */ defineComponent({
      __name: "OBlockToolbar",
      props: {
        ...Ot,
        type: {
          type: String,
          default: "link"
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: i } = Le(), s = ref();
        function a(l) {
          var c2;
          r("action", l), (c2 = s.value) == null || c2.setShow(false);
        }
        return (l, c2) => (openBlock(), createElementBlock("div", eS, [
          createBaseVNode("section", tS, [
            renderSlot(l.$slots, "default"),
            createVNode(unref(st), {
              ref_key: "popover",
              ref: s,
              placement: "bottom-end",
              size: "medium",
              trigger: "click",
              "show-arrow": false
            }, {
              trigger: withCtx(() => [
                createVNode(unref(Pt), {
                  icon: "more_horiz",
                  tooltip: unref(i)("label.more")
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createVNode(unref(Wo), mergeProps(n, { onAction: a }), null, 16)
              ]),
              _: 1
            }, 512)
          ])
        ]));
      }
    }), nS = { class: "o-callout-color-board" }, rS = { class: "fore-colors" }, oS = { class: "color-row" }, iS = { class: "color-row" }, sS = { class: "back-colors" }, aS = { class: "color-row" }, lS = { class: "color-row" }, Mm = /* @__PURE__ */ defineComponent({
      __name: "OCalloutColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e;
        function r(s, a) {
          n("select", {
            name: s,
            value: a.value
          });
        }
        const o = computed(() => [
          { label: "Grey", value: "#e9e9e9" },
          { label: "Brown", value: "#ffd591" },
          { label: "Orange", value: "#ffbb96" },
          { label: "Yellow", value: "#fff08f" },
          { label: "Green", value: "#b7eb8f" },
          { label: "Blue", value: "#91d5ff" },
          { label: "Purple", value: "#d3adf7" },
          { label: "Pink", value: "#ffadd2" },
          { label: "Red", value: "#ffa39e" }
        ]), i = computed(() => [
          { label: "Grey", value: "#F5F5F5" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (s, a) => (openBlock(), createElementBlock("section", nS, [
          createBaseVNode("section", rS, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Border color", -1)),
            createBaseVNode("div", oS, [
              createVNode(unref(je), {
                icon: "slash_forward",
                tooltip: "No color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => r("foreColor", { value: "" }))
              }),
              t2.foreColor ? (openBlock(), createBlock(unref(je), {
                key: 0,
                tooltip: "Last used",
                "content-style": { borderColor: t2.foreColor },
                onClick: a[1] || (a[1] = (l) => r("foreColor", { value: t2.foreColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", iS, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => (openBlock(), createBlock(unref(je), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { borderColor: l.value },
                onClick: (u) => r("foreColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", sS, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", aS, [
              createVNode(unref(je), {
                icon: "slash_forward",
                tooltip: "Default Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => r("backColor", { value: "#F5F5F5" }))
              }),
              t2.backColor ? (openBlock(), createBlock(unref(je), {
                key: 0,
                "content-style": { backgroundColor: t2.backColor },
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[3] || (a[3] = (l) => r("backColor", { value: t2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", lS, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(je), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => r("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), au = /* @__PURE__ */ defineComponent({
      __name: "OContextMenu",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        clientX: {
          type: Number,
          default: 0
        },
        clientY: {
          type: Number,
          default: 0
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:modelValue"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, o = ref();
        computed(() => {
          var a;
          return n.clientX || ((a = n.event) == null ? void 0 : a.clientX) || 0;
        }), computed(() => {
          var a;
          return n.clientY || ((a = n.event) == null ? void 0 : a.clientY) || 0;
        });
        function i(a) {
          r("update:modelValue", a);
        }
        function s() {
          r("update:modelValue", false);
        }
        return watch(
          () => n.modelValue,
          (a) => {
            var l;
            a ? setTimeout(() => {
              var c2;
              (c2 = o.value) == null || c2.setShow(a);
            }, 0) : (l = o.value) == null || l.setShow(a);
          }
        ), (a, l) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          placement: "bottom-start",
          trigger: "manual",
          show: t2.modelValue,
          "show-arrow": false,
          event: t2.event,
          "onUpdate:show": i,
          onClickoutside: s
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["show", "event"]));
      }
    }), cS = { class: "o-color-board" }, uS = { class: "cell-container" }, dS = { class: "label" }, pS = ["onClick"], lu = /* @__PURE__ */ defineComponent({
      __name: "OColorBoard",
      props: {
        defaultColor: {
          type: String,
          default: ""
        },
        defaultLabel: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = t2, r = e;
        function o(l) {
          r("select", l.hex);
        }
        function i(l) {
          return n.activeColor === l;
        }
        function s(l) {
          return "abc";
        }
        const a = computed(() => [
          [
            { label: "color", rgb: "rgb(0, 0, 0)", hex: "#000000" },
            { label: "color", rgb: "rgb(38, 38, 38)", hex: "#262626" },
            { label: "color", rgb: "rgb(89, 89, 89)", hex: "#595959" },
            { label: "color", rgb: "rgb(140, 140, 140)", hex: "#8c8c8c" },
            { label: "color", rgb: "rgb(191, 191, 191)", hex: "#bfbfbf" },
            { label: "color", rgb: "rgb(217, 217, 217)", hex: "#d9d9d9" },
            { label: "color", rgb: "rgb(233, 233, 233)", hex: "#e9e9e9" },
            { label: "color", rgb: "rgb(245, 245, 245)", hex: "#f5f5f5" },
            {
              label: "color",
              rgb: "rgb(250, 250, 250)",
              hex: "#fafafa",
              border: true
            },
            {
              label: "color",
              rgb: "rgb(255, 255, 255)",
              hex: "#ffffff",
              border: true
            }
          ],
          [
            { label: "color", rgb: "rgb(245, 34, 45)", hex: "#f5222d" },
            { label: "color", rgb: "rgb(250, 84, 28)", hex: "#fa541c" },
            { label: "color", rgb: "rgb(250, 140, 22)", hex: "#fa8c16" },
            { label: "color", rgb: "rgb(250, 219, 20)", hex: "#fadb14" },
            { label: "color", rgb: "rgb(82, 196, 26)", hex: "#52c41a" },
            { label: "color", rgb: "rgb(19, 194, 194)", hex: "#13c2c2" },
            { label: "color", rgb: "rgb(24, 144, 255)", hex: "#1890ff" },
            { label: "color", rgb: "rgb(47, 84, 235)", hex: "#2f54eb" },
            { label: "color", rgb: "rgb(114, 46, 209)", hex: "#722ed1" },
            { label: "color", rgb: "rgb(235, 47, 150)", hex: "#eb2f96" }
          ],
          [
            { label: "color", rgb: "rgb(255, 232, 230)", hex: "#ffe8e6" },
            { label: "color", rgb: "rgb(255, 236, 224)", hex: "#ffece0" },
            { label: "color", rgb: "rgb(255, 239, 209)", hex: "#ffefd1" },
            { label: "color", rgb: "rgb(255, 248, 189)", hex: "#fff8bd" },
            { label: "color", rgb: "rgb(228, 247, 210)", hex: "#e4f7d2" },
            { label: "color", rgb: "rgb(211, 245, 240)", hex: "#d3f5f0" },
            { label: "color", rgb: "rgb(212, 238, 252)", hex: "#d4eefc" },
            { label: "color", rgb: "rgb(222, 232, 252)", hex: "#dee8fc" },
            { label: "color", rgb: "rgb(239, 225, 250)", hex: "#efe1fa" },
            { label: "color", rgb: "rgb(250, 225, 235)", hex: "#fae1eb" }
          ],
          [
            { label: "color", rgb: "rgb(255, 163, 158)", hex: "#ffa39e" },
            { label: "color", rgb: "rgb(255, 187, 150)", hex: "#ffbb96" },
            { label: "color", rgb: "rgb(255, 213, 145)", hex: "#ffd591" },
            { label: "color", rgb: "rgb(255, 240, 143)", hex: "#fff08f" },
            { label: "color", rgb: "rgb(183, 235, 143)", hex: "#b7eb8f" },
            { label: "color", rgb: "rgb(135, 232, 222)", hex: "#87e8de" },
            { label: "color", rgb: "rgb(145, 213, 255)", hex: "#91d5ff" },
            { label: "color", rgb: "rgb(173, 198, 255)", hex: "#adc6ff" },
            { label: "color", rgb: "rgb(211, 173, 247)", hex: "#d3adf7" },
            { label: "color", rgb: "rgb(255, 173, 210)", hex: "#ffadd2" }
          ],
          [
            { label: "color", rgb: "rgb(255, 77, 79)", hex: "#ff4d4f" },
            { label: "color", rgb: "rgb(255, 122, 69)", hex: "#ff7a45" },
            { label: "color", rgb: "rgb(255, 169, 64)", hex: "#ffa940" },
            { label: "color", rgb: "rgb(255, 236, 61)", hex: "#ffec3d" },
            { label: "color", rgb: "rgb(115, 209, 61)", hex: "#73d13d" },
            { label: "color", rgb: "rgb(54, 207, 201)", hex: "#36cfc9" },
            { label: "color", rgb: "rgb(64, 169, 255)", hex: "#40a9ff" },
            { label: "color", rgb: "rgb(89, 126, 247)", hex: "#597ef7" },
            { label: "color", rgb: "rgb(146, 84, 222)", hex: "#9254de" },
            { label: "color", rgb: "rgb(247, 89, 171)", hex: "#f759ab" }
          ],
          [
            { label: "color", rgb: "rgb(207, 19, 34)", hex: "#cf1322" },
            { label: "color", rgb: "rgb(212, 56, 13)", hex: "#d4380d" },
            { label: "color", rgb: "rgb(212, 107, 8)", hex: "#d46b08" },
            { label: "color", rgb: "rgb(212, 177, 6)", hex: "#d4b106" },
            { label: "color", rgb: "rgb(56, 158, 13)", hex: "#389e0d" },
            { label: "color", rgb: "rgb(8, 151, 156)", hex: "#08979c" },
            { label: "color", rgb: "rgb(9, 109, 217)", hex: "#096dd9" },
            { label: "color", rgb: "rgb(29, 57, 196)", hex: "#1d39c4" },
            { label: "color", rgb: "rgb(83, 29, 171)", hex: "#531dab" },
            { label: "color", rgb: "rgb(196, 29, 127)", hex: "#c41d7f" }
          ],
          [
            { label: "color", rgb: "rgb(130, 0, 20)", hex: "#820014" },
            { label: "color", rgb: "rgb(135, 20, 0)", hex: "#871400" },
            { label: "color", rgb: "rgb(135, 56, 0)", hex: "#873800" },
            { label: "color", rgb: "rgb(97, 71, 0)", hex: "#614700" },
            { label: "color", rgb: "rgb(19, 82, 0)", hex: "#135200" },
            { label: "color", rgb: "rgb(0, 71, 79)", hex: "#00474f" },
            { label: "color", rgb: "rgb(0, 58, 140)", hex: "#003a8c" },
            { label: "color", rgb: "rgb(6, 17, 120)", hex: "#061178" },
            { label: "color", rgb: "rgb(34, 7, 94)", hex: "#22075e" },
            { label: "color", rgb: "rgb(120, 6, 80)", hex: "#780650" }
          ]
        ]);
        return (l, c2) => (openBlock(), createElementBlock("section", cS, [
          createBaseVNode("div", {
            class: "default-color",
            onClick: c2[0] || (c2[0] = (u) => o({ hex: t2.defaultColor }))
          }, [
            createBaseVNode("div", uS, [
              createBaseVNode("div", {
                class: "cell border",
                style: normalizeStyle({ background: t2.defaultColor })
              }, [
                createVNode(unref(ye), { name: "slash_forward" })
              ], 4)
            ]),
            createBaseVNode("div", dS, toDisplayString(t2.defaultLabel), 1)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (u, d) => (openBlock(), createElementBlock("div", {
            class: "color-row",
            key: `row-${d}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(u, (p2, f) => (openBlock(), createElementBlock("div", {
              class: "",
              key: `col-${f}`
            }, [
              createBaseVNode("div", {
                class: "cell-container",
                onClick: (h2) => o(p2)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["cell", { border: p2.border }]),
                  style: normalizeStyle({ backgroundColor: p2.hex })
                }, [
                  i(p2.hex) ? (openBlock(), createBlock(unref(ye), {
                    key: 0,
                    name: "done",
                    style: normalizeStyle({ color: s(p2.rgb) })
                  }, null, 8, ["style"])) : createCommentVNode("", true)
                ], 6)
              ], 8, pS)
            ]))), 128))
          ]))), 128))
        ]));
      }
    }), Pt = /* @__PURE__ */ defineComponent({
      __name: "OCommandBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (r, o) => (openBlock(), createBlock(unref(ho), { placement: t2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: o[0] || (o[0] = (i) => n("click", i))
            }, [
              createVNode(unref(ye), {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(r.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), cc = /* @__PURE__ */ defineComponent({
      __name: "OCommonBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (r, o) => (openBlock(), createBlock(unref(ho), { placement: t2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: o[0] || (o[0] = (i) => n("click", i))
            }, [
              createVNode(unref(ye), {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(r.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), Sl = [
      {
        label: "Arduino",
        value: "arduino",
        icon: "code_blocks"
      },
      {
        label: "Bash",
        value: "bash",
        icon: "code_blocks"
      },
      {
        label: "C",
        value: "c",
        icon: "code_blocks"
      },
      {
        label: "C++",
        value: "cpp",
        icon: "code_blocks"
      },
      {
        label: "C#",
        value: "csharp",
        icon: "code_blocks"
      },
      {
        label: "CSS",
        value: "css",
        icon: "code_blocks"
      },
      {
        label: "Diff",
        value: "diff",
        icon: "code_blocks"
      },
      {
        label: "Go",
        value: "go",
        icon: "code_blocks"
      },
      {
        label: "GraphQL",
        value: "graphql",
        icon: "code_blocks"
      },
      {
        label: "Ini",
        value: "ini",
        icon: "code_blocks"
      },
      {
        label: "Java",
        value: "java",
        icon: "code_blocks"
      },
      {
        label: "JavaScript",
        value: "javascript",
        icon: "code_blocks"
      },
      {
        label: "JSON",
        value: "json",
        icon: "code_blocks"
      },
      {
        label: "Kotlin",
        value: "kotlin",
        icon: "code_blocks"
      },
      {
        label: "Less",
        value: "less",
        icon: "code_blocks"
      },
      {
        label: "Lua",
        value: "lua",
        icon: "code_blocks"
      },
      {
        label: "Makefile",
        value: "makefile",
        icon: "code_blocks"
      },
      {
        label: "Markdown",
        value: "markdown",
        icon: "code_blocks"
      },
      {
        label: "Objective-C",
        value: "objectivec",
        icon: "code_blocks"
      },
      {
        label: "Perl",
        value: "perl",
        icon: "code_blocks"
      },
      {
        label: "PHP",
        value: "php",
        icon: "code_blocks"
      },
      {
        label: "PHP-Template",
        value: "php-template",
        icon: "code_blocks"
      },
      {
        label: "Plain Text",
        value: "plaintext",
        icon: "code_blocks"
      },
      {
        label: "Python",
        value: "python",
        icon: "code_blocks"
      },
      {
        label: "Python-Repl",
        value: "python-repl",
        icon: "code_blocks"
      },
      {
        label: "R",
        value: "r",
        icon: "code_blocks"
      },
      {
        label: "Ruby",
        value: "ruby",
        icon: "code_blocks"
      },
      {
        label: "Rust",
        value: "rust",
        icon: "code_blocks"
      },
      {
        label: "Scss",
        value: "scss",
        icon: "code_blocks"
      },
      {
        label: "Shell",
        value: "shell",
        icon: "code_blocks"
      },
      {
        label: "SQL",
        value: "sql",
        icon: "code_blocks"
      },
      {
        label: "Swift",
        value: "swift",
        icon: "code_blocks"
      },
      {
        label: "TypeScript",
        value: "typescript",
        icon: "code_blocks"
      },
      {
        label: "VB.Net",
        value: "vbnet",
        icon: "code_blocks"
      },
      {
        label: "WebAssembly",
        value: "wasm",
        icon: "code_blocks"
      },
      {
        label: "XML",
        value: "xml",
        icon: "code_blocks"
      },
      {
        label: "YAML",
        value: "yaml",
        icon: "code_blocks"
      }
    ], fS = { class: "selected-language" }, hS = { class: "header" }, mS = { class: "o-scroll" }, gS = /* @__PURE__ */ defineComponent({
      __name: "OLanguageDropdown",
      props: {
        language: {
          type: String,
          default: "shell"
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = t2, r = e;
        Le();
        const i = ref(), s = ref(), a = ref(""), l = ref(0), c2 = ref(""), u = computed(() => a.value ? Sl.filter(
          (b) => b.value.toLowerCase().indexOf(a.value.toLowerCase()) >= 0
        ) : Sl), d = computed(() => Sl.find((b) => b.value === c2.value));
        function p2(b) {
          b && setTimeout(() => {
            var E;
            (E = s.value) == null || E.focus(), l.value = 0, window.addEventListener("keyup", g);
          }, 0);
        }
        function f() {
          window.removeEventListener("keyup", g);
        }
        function h2(b) {
          f(), c2.value = b.value, r("select", b.value);
        }
        function m() {
          h2(u.value[l.value]);
        }
        function g(b) {
          if (u.value.length > 0) {
            switch (b.code) {
              case "ArrowDown":
                l.value = l.value + 1;
                break;
              case "ArrowUp":
                l.value = l.value - 1;
                break;
              case "Enter":
                m();
                break;
            }
            l.value >= u.value.length && (l.value = 0), l.value < 0 && (l.value = u.value.length - 1);
          } else
            l.value = 0;
        }
        return onMounted(() => {
          c2.value = n.language;
        }), (b, E) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: i,
          placement: "bottom-start",
          trigger: "click",
          "tippy-class": "o-language-popover dropdown",
          "onUpdate:show": p2
        }, {
          trigger: withCtx(() => [
            createVNode(unref(rn), { class: "o-dropdown-btn" }, {
              default: withCtx(() => {
                var _;
                return [
                  createBaseVNode("span", fS, toDisplayString((_ = d.value) == null ? void 0 : _.label), 1),
                  createVNode(unref(ye), {
                    name: "arrow_drop_down",
                    class: "arrow"
                  })
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("header", hS, [
              createVNode(unref(Wi), {
                ref_key: "input",
                ref: s,
                modelValue: a.value,
                "onUpdate:modelValue": E[0] || (E[0] = (_) => a.value = _),
                type: "text",
                placeholder: "Search",
                autofocus: "",
                clearable: ""
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "search",
                    class: "o-tips"
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createBaseVNode("section", mS, [
              createVNode(unref(Pn), {
                hoverable: "",
                clickable: ""
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(u.value, (_, v) => (openBlock(), createBlock(unref(Tn), {
                    key: v,
                    onClick: (T) => h2(_),
                    class: normalizeClass({
                      "is-active": _.value === c2.value,
                      "is-select": v === l.value
                    })
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: _.icon
                      }, null, 8, ["name"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "class"]))), 128))
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 512));
      }
    }), bS = { class: "o-media-input" }, yS = { class: "fields" }, vS = { class: "actions" }, Rm = /* @__PURE__ */ defineComponent({
      __name: "OMediaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["input"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: o } = Le(), i = ref(), s = ref(""), a = ref("");
        function l() {
          return a.value ? (s.value = "null", true) : (s.value = "error", false);
        }
        function c2() {
          l() && r("input", a.value);
        }
        return onMounted(() => {
          a.value = n.val, setTimeout(() => {
            var u;
            (u = i.value) == null || u.focus();
          }, 0);
        }), (u, d) => (openBlock(), createElementBlock("section", bS, [
          createBaseVNode("section", yS, [
            d[1] || (d[1] = createBaseVNode("div", { class: "o-media-title" }, "Link", -1)),
            createVNode(unref(Wi), {
              ref_key: "input",
              ref: i,
              modelValue: a.value,
              "onUpdate:modelValue": d[0] || (d[0] = (p2) => a.value = p2),
              status: s.value,
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ye), {
                  name: "link",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue", "status"])
          ]),
          createBaseVNode("footer", vS, [
            createVNode(unref(rn), {
              type: "info",
              onClick: c2
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), ES = { class: "o-meta-input" }, kS = { class: "header" }, wS = { class: "title" }, _S = { class: "fields" }, SS = { class: "actions" }, Im = /* @__PURE__ */ defineComponent({
      __name: "OMetaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: "Link"
        },
        type: {
          type: String,
          default: "link"
        },
        icon: {
          type: String,
          default: "link"
        },
        secondIcon: {
          type: String,
          default: ""
        },
        secondLabel: {
          type: String,
          default: ""
        }
      },
      emits: ["cancel", "confirm"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: o } = Le(), i = ref(null), s = ref("");
        function a() {
          console.log("confirm", s.value), r("confirm", s.value);
        }
        return onMounted(() => {
          s.value = n.val, setTimeout(() => {
            var l;
            (l = i.value) == null || l.focus();
          }, 0);
        }), (l, c2) => (openBlock(), createElementBlock("section", ES, [
          createBaseVNode("section", kS, [
            createBaseVNode("div", wS, toDisplayString(t2.title), 1),
            createBaseVNode("div", null, [
              renderSlot(l.$slots, "header-right")
            ])
          ]),
          createBaseVNode("section", _S, [
            createVNode(unref(Wi), {
              ref_key: "input",
              ref: i,
              modelValue: s.value,
              "onUpdate:modelValue": c2[0] || (c2[0] = (u) => s.value = u),
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ye), {
                  name: t2.icon,
                  class: "o-tips"
                }, null, 8, ["name"])
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          createBaseVNode("footer", SS, [
            createVNode(unref(rn), {
              type: "tertiary",
              onClick: c2[1] || (c2[1] = (u) => r("cancel"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.cancel")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(rn), {
              type: "info",
              onClick: a
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), CS = { class: "o-table-grid" }, xS = ["onMouseover"], TS = /* @__PURE__ */ defineComponent({
      __name: "OTableGrid",
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e, r = ref(6), o = ref(6), i = ref(2), s = ref(2);
        function a(c2, u) {
          i.value = c2, s.value = u, r.value === c2 && r.value < 10 && (r.value += 1), o.value === u && o.value < 10 && (o.value += 1);
        }
        function l() {
          n("select", {
            rows: i.value,
            cols: s.value,
            withHeaderRow: true
          });
        }
        return (c2, u) => (openBlock(), createElementBlock("section", CS, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (d, p2) => (openBlock(), createElementBlock("div", {
            class: "rows",
            key: `row-${p2}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (f, h2) => (openBlock(), createElementBlock("div", {
              key: `col-${h2}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["cell", { selected: d <= i.value && f <= s.value }]),
                onMouseover: (m) => a(d, f),
                onClick: l
              }, null, 42, xS)
            ]))), 128))
          ]))), 128)),
          createBaseVNode("footer", null, toDisplayString(i.value) + " x " + toDisplayString(s.value), 1)
        ]));
      }
    }), OS = { class: "o-table-cell-background o-button-group" }, NS = { class: "o-command-btn" }, AS = /* @__PURE__ */ defineComponent({
      __name: "OTableCellBackground",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(), i = ref("#ffec3d");
        function s() {
          a(i.value);
        }
        function a(l) {
          o.value.setShow(false), i.value = l, r(e.editor, "tableCellAttribute", {
            name: "background",
            value: i.value
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom-start",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(ho), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", OS, [
                  createBaseVNode("div", {
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, [
                    createVNode(unref(ye), {
                      name: "crop_16_9",
                      class: "arrow"
                    }),
                    createBaseVNode("div", {
                      class: "indicator",
                      style: normalizeStyle(`background: ${i.value}`)
                    }, null, 4)
                  ]),
                  createBaseVNode("div", NS, [
                    createVNode(unref(ye), { name: "arrow_drop_down" })
                  ])
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(lu), {
              "default-color": "",
              "default-label": unref(n)("editor.noColor"),
              onSelect: a
            }, null, 8, ["default-label"])
          ]),
          _: 1
        }, 512));
      }
    }), MS = { class: "o-simple-color-board" }, RS = { class: "fore-colors" }, IS = { class: "color-row" }, DS = { class: "color-row" }, LS = { class: "back-colors" }, PS = { class: "color-row" }, BS = { class: "color-row" }, $S = /* @__PURE__ */ defineComponent({
      __name: "OTextColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e;
        function r(s, a) {
          n("select", s, a.value);
        }
        const o = computed(() => [
          { label: "Grey", value: "#787774" },
          { label: "Brown", value: "#9F6B53" },
          { label: "Orange", value: "#D9730D" },
          { label: "Yellow", value: "#CB912F" },
          { label: "Green", value: "#448361" },
          { label: "Blue", value: "#337EA9" },
          { label: "Purple", value: "#9065B0" },
          { label: "Pink", value: "#C14C8A" },
          { label: "Red", value: "#D44C47" }
        ]), i = computed(() => [
          { label: "Grey", value: "#F1F1EF" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (s, a) => (openBlock(), createElementBlock("section", MS, [
          createBaseVNode("section", RS, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Color", -1)),
            createBaseVNode("div", IS, [
              createVNode(unref(je), {
                icon: "format_text",
                tooltip: "Default color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => r("foreColor", { value: "" }))
              }),
              t2.foreColor ? (openBlock(), createBlock(unref(je), {
                key: 0,
                icon: "format_text",
                color: t2.foreColor,
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[1] || (a[1] = (l) => r("foreColor", { value: t2.foreColor }))
              }, null, 8, ["color"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", DS, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => (openBlock(), createBlock(unref(je), {
                key: `col-${c2}`,
                icon: "format_text",
                color: l.value,
                tooltip: l.label,
                onClick: (u) => r("foreColor", l)
              }, null, 8, ["color", "tooltip", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", LS, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", PS, [
              createVNode(unref(je), {
                icon: "slash_forward",
                tooltip: "No Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => r("backColor", { value: "" }))
              }),
              t2.backColor ? (openBlock(), createBlock(unref(je), {
                key: 0,
                icon: "format_text",
                tooltip: "Last used",
                "content-class": "border",
                "content-style": { backgroundColor: t2.backColor },
                onClick: a[3] || (a[3] = (l) => r("backColor", { value: t2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", BS, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(je), {
                key: `col-${c2}`,
                icon: "format_text",
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => r("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), Ys = [
      {
        type: "paragraph",
        content: []
      }
    ], Dm = [
      {
        type: "listItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], Lm = [
      {
        type: "taskItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], FS = { class: "o-add-node-view" }, zS = {
      key: 0,
      class: "view-main"
    }, HS = { class: "group o-tips" }, US = { class: "panel" }, VS = { class: "group o-tips" }, WS = {
      key: 1,
      class: "item"
    }, KS = {
      key: 1,
      class: "view-emoji"
    }, qS = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: i } = Le(), a = ref("main"), l = ref(0);
        function c2(p2) {
          const f = n.editor.chain();
          let h2 = null;
          switch (p2.value) {
            case "blockquote":
              h2 = {
                content: Ys
              };
              break;
            case "callout":
              h2 = {
                content: Ys,
                attrs: { icon: "💡" }
              };
              break;
            case "codeBlock":
              h2 = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              h2 = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              h2 = {
                attrs: p2.options
              };
              break;
            case "horizontalRule":
              h2 = {};
              break;
            case "paragraph":
              h2 = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              h2 = {
                content: Dm
              };
              break;
            case "taskList":
              h2 = {
                content: Lm
              };
              break;
            case "table":
              setTimeout(() => {
                f.insertContentAt(d.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              h2 = {
                type: "paragraph",
                content: [{ type: p2.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              h2 = { attrs: { src: "init" } };
              break;
          }
          h2 && (h2.type = h2.type || p2.value, setTimeout(() => {
            u.value ? f.insertContent(h2).focus().run() : f.insertContentAt(d.value, h2).focus().run();
          }, 1)), r("action", p2);
        }
        const u = computed(() => n.node.content.size === 0), d = computed(() => u.value ? l.value : l.value + n.node.nodeSize);
        return onMounted(() => {
          l.value = n.getPos();
        }), (p2, f) => (openBlock(), createElementBlock("section", FS, [
          a.value === "main" ? (openBlock(), createElementBlock("section", zS, [
            createBaseVNode("section", null, [
              createBaseVNode("div", HS, toDisplayString(unref(i)("label.basic")), 1),
              createBaseVNode("section", US, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Vi), (h2, m) => (openBlock(), createBlock(unref(je), {
                  key: m,
                  icon: h2.icon,
                  tooltip: unref(i)(h2.label),
                  quaternary: "",
                  onClick: (g) => c2(h2)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Ni).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Ni), (h2, m) => (openBlock(), createElementBlock(Fragment, { key: m }, [
                  h2.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    m > 0 ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", VS, toDisplayString(unref(i)(h2.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(Tn), {
                    class: "item",
                    clickable: "",
                    onClick: (g) => c2(h2)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: h2.icon,
                        color: h2.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i)(h2.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", WS, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", KS)) : createCommentVNode("", true)
        ]));
      }
    }), GS = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref(null), r = ref(false);
        function o(s) {
          r.value = s;
        }
        function i() {
          var s;
          (s = n.value) == null || s.setShow(false), r.value = false;
        }
        return (s, a) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: n,
          placement: "left",
          trigger: "mouseenter",
          arrow: "",
          "onUpdate:show": o
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-node", { "is-selected": r.value }])
            }, [
              createVNode(unref(rn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(qS, mergeProps(e, { onAction: i }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), jS = { class: "o-drag-node-view" }, YS = {
      key: 0,
      class: "view-main"
    }, JS = { key: 0 }, XS = { class: "panel" }, ZS = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: i } = Le(), { onCommand: a } = Ze(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var g, b;
          const m = (g = n.node) == null ? void 0 : g.content.content;
          if (m.length > 0) {
            const E = m[0];
            if (E.type.name === "image")
              return E.type.name;
          }
          return (b = n.node) == null ? void 0 : b.type.name;
        }), d = computed(() => js.find((m) => m.value === u.value));
        function p2(m) {
          var g;
          return m.value === u.value && ((g = n.editor) == null ? void 0 : g.isActive(u.value, m.options));
        }
        function f(m) {
          switch (m.value) {
            default:
              h2(m);
              break;
          }
          r("action", m);
        }
        function h2(m) {
          var _, v, T, S, F;
          const g = n.getPos();
          if (m.value === u.value && c2.value.indexOf(u.value) < 0) {
            const V = (_ = n.editor) == null ? void 0 : _.isActive(u.value), L = (v = n.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, V, L);
            return;
          }
          const b = (T = n.editor) == null ? void 0 : T.commands, E = (S = n.editor) == null ? void 0 : S.chain().focus(g + 1);
          console.log("runCommand", m), a(b, E, m.value, m.options), (F = n.editor) == null || F.commands.setNodeSelection(g);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: Pe.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: Pe.deepOrange
          }
        ]), (m, g) => (openBlock(), createElementBlock("section", jS, [
          l.value === "main" ? (openBlock(), createElementBlock("section", YS, [
            d.value ? (openBlock(), createElementBlock("section", JS, [
              g[0] || (g[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", XS, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(js), (b, E) => (openBlock(), createBlock(unref(je), {
                  key: E,
                  icon: b.icon,
                  tooltip: unref(i)(b.label),
                  "content-class": { "is-active": p2(b) },
                  quaternary: "",
                  onClick: (_) => f(b)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Wo), mergeProps(n, {
              colorful: "",
              "show-group": "",
              onAction: f
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), QS = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, i = ref(null), s = ref(0), a = ref(false), l = ref(["heading", "codeBlock", "paragraph"]), c2 = ref(false), u = computed(() => {
          var E, _;
          const b = (E = n.node) == null ? void 0 : E.content.content;
          if (b.length > 0) {
            const v = b[0];
            if (v.type.name === "image")
              return v.type.name;
          }
          return (_ = n.node) == null ? void 0 : _.type.name;
        }), d = computed(() => {
          var E;
          let b = u.value;
          return b === "heading" ? {
            icon: `format_h${((E = n.node.attrs) == null ? void 0 : E.level) || 1}`,
            color: Pe.blue
          } : (b === "table-wrapper" && (b = "table"), su.find((_) => _.value === b) || { icon: "title" });
        });
        function p2(b) {
          var E;
          (E = i.value) == null || E.setShow(false), r("action", b);
        }
        function f(b) {
          a.value = b, console.log("show", b), b && h2();
        }
        function h2() {
          var E;
          let b = n.getPos();
          l.value.includes(u.value) || (b += 1), (E = n.editor) == null || E.commands.setNodeSelection(b), s.value = b;
        }
        function m(b) {
          c2.value = true, setTimeout(() => {
            c2.value = false;
          }, 10);
        }
        function g(b) {
          c2.value = false;
        }
        return (b, E) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: i,
          placement: "left",
          size: "medium",
          trigger: "click",
          arrow: "",
          "onUpdate:show": f
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-node", { "is-selected": a.value, "is-dragging": c2.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: m,
              onDragend: g
            }, [
              createVNode(unref(rn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: d.value.icon,
                    color: d.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ye), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(ZS, mergeProps(n, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), eC = /* @__PURE__ */ defineComponent({
      __name: "index",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, o = ref(false), i = ref(0);
        ref(0);
        const s = computed(() => a.value === "paragraph" && n.node.content.size === 0), a = computed(() => {
          var p2, f;
          const d = (p2 = n.node) == null ? void 0 : p2.content.content;
          if (d.length > 0) {
            const h2 = d[0];
            if (h2.type.name === "image")
              return h2.type.name;
          }
          return (f = n.node) == null ? void 0 : f.type.name;
        }), l = computed(() => {
          var d;
          return i.value || ((d = n.node.attrs) == null ? void 0 : d.level);
        }), c2 = computed(() => a.value === "heading" ? `type-heading-${l.value}` : `type-${a.value}`);
        function u(d) {
          r("action", d);
        }
        return onMounted(() => {
          i.value = 0;
        }), (d, p2) => {
          var f;
          return (f = d.editor) != null && f.isEditable ? (openBlock(), createElementBlock("section", {
            key: 0,
            class: normalizeClass(["o-side-node", { "is-active": o.value, "is-empty": s.value }])
          }, [
            createBaseVNode("section", {
              class: normalizeClass(["action-container", c2.value])
            }, [
              createVNode(GS, normalizeProps(guardReactiveProps(n)), null, 16),
              s.value ? createCommentVNode("", true) : (openBlock(), createBlock(QS, mergeProps({ key: 0 }, n, { onAction: u }), null, 16))
            ], 2)
          ], 2)) : createCommentVNode("", true);
        };
      }
    }), mr = /* @__PURE__ */ defineComponent({
      __name: "ONodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, o = inject("sideNode", { value: false });
        return computed(() => {
          const i = {};
          return n.node.attrs["data-id"] && (i["data-id"] = n.node.attrs["data-id"]), i;
        }), (i, s) => (openBlock(), createBlock(unref(ou), { class: "o-node-view" }, {
          default: withCtx(() => {
            var a;
            return [
              unref(o) && ((a = i.editor) != null && a.isEditable) ? (openBlock(), createBlock(eC, mergeProps({ key: 0 }, n, {
                onAction: s[0] || (s[0] = (l) => r("action"))
              }), null, 16)) : createCommentVNode("", true),
              renderSlot(i.$slots, "default")
            ];
          }),
          _: 3
        }));
      }
    }), tC = { class: "o-add-node-view" }, nC = {
      key: 0,
      class: "view-main"
    }, rC = { class: "group o-tips" }, oC = { class: "panel" }, iC = { class: "group o-tips" }, sC = {
      key: 1,
      class: "item"
    }, aC = {
      key: 1,
      class: "view-emoji"
    }, lC = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: i } = Le(), a = ref("main");
        function l(d) {
          const p2 = n.editor.chain();
          let f = null;
          switch (d.value) {
            case "blockquote":
              f = {
                content: Ys
              };
              break;
            case "callout":
              f = {
                content: Ys,
                attrs: { icon: "💡" }
              };
              break;
            case "codeBlock":
              f = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              f = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              f = {
                attrs: d.options
              };
              break;
            case "horizontalRule":
              f = {};
              break;
            case "paragraph":
              f = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              f = {
                content: Dm
              };
              break;
            case "taskList":
              f = {
                content: Lm
              };
              break;
            case "table":
              setTimeout(() => {
                p2.insertContentAt(u.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              f = {
                type: "paragraph",
                content: [{ type: d.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              f = { attrs: { src: "init" } };
              break;
          }
          f && (console.log("add", n.getPos(), u.value), f.type = f.type || d.value, setTimeout(() => {
            c2.value ? p2.insertContent(f).focus().run() : p2.insertContentAt(u.value, f).focus().run();
          }, 1)), r("action", d);
        }
        const c2 = computed(() => {
          var d;
          return ((d = n.node) == null ? void 0 : d.content.size) === 0;
        }), u = computed(() => c2.value ? n.getPos() : n.getPos() + n.node.nodeSize);
        return (d, p2) => (openBlock(), createElementBlock("section", tC, [
          a.value === "main" ? (openBlock(), createElementBlock("section", nC, [
            createBaseVNode("section", null, [
              createBaseVNode("div", rC, toDisplayString(unref(i)("label.basic")), 1),
              createBaseVNode("section", oC, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Vi), (f, h2) => (openBlock(), createBlock(unref(je), {
                  key: h2,
                  icon: f.icon,
                  tooltip: unref(i)(f.label),
                  quaternary: "",
                  onClick: (m) => l(f)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Ni).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Ni), (f, h2) => (openBlock(), createElementBlock(Fragment, { key: h2 }, [
                  f.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    h2 > 0 ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", iC, toDisplayString(unref(i)(f.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(Tn), {
                    class: "item",
                    clickable: "",
                    onClick: (m) => l(f)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: f.icon,
                        color: f.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i)(f.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", sC, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", aC)) : createCommentVNode("", true)
        ]));
      }
    }), cC = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      setup(t2) {
        const e = t2, n = ref(), r = ref(false), o = computed(() => {
          var l;
          return ((l = e.node) == null ? void 0 : l.content.size) === 0;
        });
        computed(() => o.value ? e.getPos() : e.getPos() + e.node.nodeSize);
        function i(l) {
          r.value = l;
        }
        function s() {
          var l;
          (l = n.value) == null || l.setShow(true);
        }
        function a() {
          var l;
          (l = n.value) == null || l.setShow(false), r.value = false;
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: n,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "manual",
          offset: [0, 4],
          "onUpdate:show": i
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-btn", { "is-selected": r.value }])
            }, [
              createVNode(unref(rn), {
                type: "tertiary",
                class: "o-node-btn",
                onClick: s
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(lC, mergeProps(e, { onAction: a }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), uC = { class: "o-drag-node-view" }, dC = {
      key: 0,
      class: "view-main"
    }, pC = { key: 0 }, fC = { class: "panel" }, hC = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, { tr: i } = Le(), { onCommand: a } = Ze(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var g, b;
          const m = (g = n.node) == null ? void 0 : g.content.content;
          if (m.length > 0) {
            const E = m[0];
            if (E.type.name === "image")
              return E.type.name;
          }
          return (b = n.node) == null ? void 0 : b.type.name;
        }), d = computed(() => js.find((m) => m.value === u.value));
        function p2(m) {
          var g;
          return m.value === u.value && ((g = n.editor) == null ? void 0 : g.isActive(u.value, m.options));
        }
        function f(m) {
          switch (m.value) {
            case "delete":
              break;
            case "duplicate":
              break;
            default:
              h2(m);
              break;
          }
          r("action", m);
        }
        function h2(m) {
          var _, v, T, S, F;
          const g = n.getPos();
          if (m.value === u.value && c2.value.indexOf(u.value) < 0) {
            const V = (_ = n.editor) == null ? void 0 : _.isActive(u.value), L = (v = n.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, V, L);
            return;
          }
          const b = (T = n.editor) == null ? void 0 : T.commands, E = (S = n.editor) == null ? void 0 : S.chain().focus(g + 1);
          console.log("runCommand", m), a(b, E, m.value, m.options), (F = n.editor) == null || F.commands.setNodeSelection(g);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: Pe.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: Pe.deepOrange
          }
        ]), (m, g) => (openBlock(), createElementBlock("section", uC, [
          l.value === "main" ? (openBlock(), createElementBlock("section", dC, [
            d.value ? (openBlock(), createElementBlock("section", pC, [
              g[0] || (g[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", fC, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(js), (b, E) => (openBlock(), createBlock(unref(je), {
                  key: E,
                  icon: b.icon,
                  tooltip: unref(i)(b.label),
                  "content-class": { "is-active": p2(b) },
                  quaternary: "",
                  onClick: (_) => f(b)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Wo), mergeProps(n, {
              colorful: "",
              "show-group": "",
              onAction: f
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), mC = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action", "dragstart", "dragend"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, i = ref(null), s = ref(false), a = ref(["heading", "codeBlock", "paragraph"]), l = computed(() => {
          var g, b, E;
          const m = (b = (g = n.node) == null ? void 0 : g.content) == null ? void 0 : b.content;
          if ((m == null ? void 0 : m.length) > 0) {
            const _ = m[0];
            if (_.type.name === "image")
              return _.type.name;
          }
          return (E = n.node) == null ? void 0 : E.type.name;
        }), c2 = computed(() => {
          var g;
          let m = l.value;
          return m === "heading" ? {
            icon: `format_h${((g = n.node.attrs) == null ? void 0 : g.level) || 1}`,
            color: Pe.blue
          } : (m === "table-wrapper" && (m = "table"), su.find((b) => b.value === m) || { icon: "title" });
        });
        function u(m) {
          r("dragstart", m);
        }
        function d(m) {
          r("dragend", m);
        }
        function p2(m) {
          var g;
          (g = i.value) == null || g.setShow(false), r("action", m);
        }
        function f(m) {
          s.value = m, console.log("show", m), m && h2();
        }
        function h2() {
          var g;
          let m = n.getPos();
          a.value.includes(l.value) || (m += 1), (g = n.editor) == null || g.commands.setNodeSelection(m);
        }
        return watch(
          () => n.getPos(),
          (m) => {
            var g;
            (g = i.value) == null || g.setShow(false);
          }
        ), (m, g) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: i,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "click",
          offset: [0, 2],
          "onUpdate:show": f
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-btn", { selected: s.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: u,
              onDragend: d
            }, [
              createVNode(unref(rn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: c2.value.icon,
                    color: c2.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ye), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(hC, mergeProps(n, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), rn = /* @__PURE__ */ defineComponent({
      __name: "OBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (r, o) => (openBlock(), createElementBlock("button", {
          class: normalizeClass(["o-btn", t2.type ? `type-${t2.type}` : ""]),
          onClick: o[0] || (o[0] = (i) => n("click", i))
        }, [
          t2.icon ? (openBlock(), createBlock(unref(ye), {
            key: 0,
            name: t2.icon,
            class: normalizeClass(t2.iconClass)
          }, null, 8, ["name", "class"])) : createCommentVNode("", true),
          renderSlot(r.$slots, "default")
        ], 2));
      }
    }), gC = { class: "o-checkbox" }, bC = { class: "o-checkbox__main" }, yC = { class: "o-checkbox__suffix" }, Pm = /* @__PURE__ */ defineComponent({
      __name: "OCheckbox",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        label: {
          type: String,
          default: ""
        }
      },
      emits: ["update:modelValue"],
      setup(t2, { emit: e }) {
        const n = t2, r = e, o = computed({
          get() {
            return n.modelValue;
          },
          set(i) {
            r("update:modelValue", i);
          }
        });
        return (i, s) => (openBlock(), createElementBlock("div", gC, [
          createBaseVNode("div", bC, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": s[0] || (s[0] = (a) => o.value = a),
              type: "checkbox"
            }, null, 512), [
              [vModelCheckbox, o.value]
            ])
          ]),
          createBaseVNode("div", yC, toDisplayString(t2.label), 1)
        ]));
      }
    }), xn = /* @__PURE__ */ defineComponent({
      __name: "ODivider",
      props: {
        vertical: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-divider", { "o-divider-vertical": t2.vertical }])
        }, null, 2));
      }
    }), vC = { class: "o-input__prefix" }, EC = { class: "o-input__main" }, kC = { class: "o-input__suffix" }, Wi = /* @__PURE__ */ defineComponent({
      __name: "OInput",
      props: {
        modelValue: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["blur", "update:modelValue"],
      setup(t2, { expose: e, emit: n }) {
        const r = t2, o = n, i = ref(null), s = computed({
          get() {
            return r.modelValue;
          },
          set(c2) {
            o("update:modelValue", c2);
          }
        });
        function a() {
          var c2;
          (c2 = i.value) == null || c2.focus();
        }
        function l() {
          s.value = "", a();
        }
        return e({
          clear: l,
          focus: a
        }), (c2, u) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-input", `type-${t2.type}`])
        }, [
          createBaseVNode("div", vC, [
            renderSlot(c2.$slots, "prefix")
          ]),
          createBaseVNode("div", EC, [
            withDirectives(createBaseVNode("input", {
              ref_key: "input",
              ref: i,
              "onUpdate:modelValue": u[0] || (u[0] = (d) => s.value = d),
              onBlur: u[1] || (u[1] = (d) => o("blur"))
            }, null, 544), [
              [vModelText, s.value]
            ])
          ]),
          createBaseVNode("div", kC, [
            renderSlot(c2.$slots, "suffix"),
            t2.clearable && s.value ? (openBlock(), createBlock(ye, {
              key: 0,
              name: "close",
              class: "clear o-tips",
              onClick: l
            })) : createCommentVNode("", true)
          ])
        ], 2));
      }
    }), Pn = /* @__PURE__ */ defineComponent({
      __name: "OList",
      props: {
        clickable: {
          type: Boolean,
          default: false
        },
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("ul", {
          class: normalizeClass(["o-list", { clickable: t2.clickable, hoverable: t2.hoverable }])
        }, [
          renderSlot(e.$slots, "default")
        ], 2));
      }
    }), wC = { class: "o-list-item" }, _C = { class: "o-list-item__prefix" }, SC = { class: "o-list-item__main" }, CC = { class: "o-list-item__suffix" }, Tn = /* @__PURE__ */ defineComponent({
      __name: "OListItem",
      props: {
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("li", wC, [
          createBaseVNode("div", _C, [
            renderSlot(e.$slots, "prefix")
          ]),
          createBaseVNode("div", SC, [
            renderSlot(e.$slots, "default")
          ]),
          createBaseVNode("div", CC, [
            renderSlot(e.$slots, "suffix")
          ])
        ]));
      }
    }), st = /* @__PURE__ */ defineComponent({
      __name: "OPopover",
      props: {
        show: {
          type: Boolean,
          default: false
        },
        arrow: {
          type: Boolean,
          default: false
        },
        offset: {
          type: Array,
          default: function() {
            return [0, 10];
          }
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
        },
        tippyClass: {
          type: String,
          default: ""
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:show"],
      setup(t2, { expose: e, emit: n }) {
        const r = t2, o = n, { theme: i } = Va(), s = ref(null), a = ref(), l = ref();
        function c2(f) {
          var h2, m, g, b;
          f ? ((m = l.value) == null || m.setProps({
            getReferenceClientRect: (h2 = r.event) != null && h2.clientX ? u : null
          }), (g = l.value) == null || g.show()) : (b = l.value) == null || b.hide();
        }
        function u() {
          var f, h2;
          return {
            width: 0,
            height: 0,
            left: r.event.clientX,
            right: r.event.clientX,
            top: r.event.clientY,
            bottom: r.event.clientY,
            x: ((f = r.event) == null ? void 0 : f.clientX) || 0,
            // add missing x
            y: ((h2 = r.event) == null ? void 0 : h2.clientY) || 0,
            toJSON: () => {
              var m, g;
              return {
                // add toJSON method to satisfy DOMRect
                width: 100,
                height: 100,
                left: ((m = r.event) == null ? void 0 : m.clientX) || 0,
                top: ((g = r.event) == null ? void 0 : g.clientY) || 0
              };
            }
          };
        }
        function d() {
          l.value = Zn(s.value, {
            appendTo: () => document.body,
            animation: "shift-away",
            // perspective, scale, shift-away
            arrow: r.arrow,
            content: a.value,
            delay: 100,
            duration: 200,
            interactive: true,
            // offset: props.offset, // todo
            placement: r.placement,
            trigger: r.trigger,
            theme: i.value,
            onShow: (f) => {
              o("update:show", true);
            },
            onHide: (f) => {
              o("update:show", false);
            }
          });
        }
        function p2() {
          l.value.setProps({
            theme: i.value
          });
        }
        return watch(i, (f) => {
          p2();
        }), onMounted(() => {
          d();
        }), e({
          setShow: c2
        }), (f, h2) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: s,
          "data-tippy-role": "popover",
          class: "o-popover"
        }, [
          renderSlot(f.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: a,
            class: normalizeClass(["popover-content", t2.tippyClass])
          }, [
            renderSlot(f.$slots, "default")
          ], 2)
        ], 512));
      }
    }), xC = /* @__PURE__ */ defineComponent({
      __name: "OAlignDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = computed(() => [
          { label: n("editor.left"), value: "left", icon: "format_align_center" },
          {
            label: n("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: n("editor.right"), value: "right", icon: "format_align_right" },
          {
            label: n("editor.justify"),
            value: "justify",
            icon: "format_align_justify"
          }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, "textAlign", {
            textAlign: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "format_align_center",
              "content-class": "o-align-dropdown dropdown",
              tooltip: unref(n)("editor.align")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(Tn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = t2.editor) == null ? void 0 : d.isActive({ textAlign: c2.value }) }),
                    onClick: (p2) => s(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = t2.editor) != null && p2.isActive({ textAlign: c2.value }) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), TC = { class: "o-align-group" }, OC = /* @__PURE__ */ defineComponent({
      __name: "OAlignGroup",
      props: {
        editor: {
          type: Dn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = computed(() => [
          { label: n("editor.left"), value: "left", icon: "format_align_left" },
          {
            label: n("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: n("editor.right"), value: "right", icon: "format_align_right" }
        ]);
        function i(s) {
          r(e.editor, "textAlign", {
            textAlign: s.value
          });
        }
        return (s, a) => (openBlock(), createElementBlock("div", TC, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(je, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": {
                "is-active": (u = t2.editor) == null ? void 0 : u.isActive({ textAlign: l.value })
              },
              onClick: (d) => i(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), NC = { class: "o-back-color-dropdown o-button-group" }, AC = /* @__PURE__ */ defineComponent({
      __name: "OBackColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = ref("#ffec3d");
        function s() {
          a(i.value);
        }
        function a(l) {
          o.value.setShow(false), i.value = l, r(e.editor, "backColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(ho), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", NC, [
                  createVNode(unref(rn), {
                    icon: "ink_highlighter",
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${i.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(rn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(lu), {
                "default-color": "",
                "default-label": unref(n)("editor.noColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("highlight").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), MC = /* @__PURE__ */ defineComponent({
      __name: "OFontFamilyDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = computed(() => [
          { label: n("editor.default"), value: "system-ui" },
          // todo
          { label: "Arial", value: "Arial", separator: true },
          { label: "Arial Black", value: "Arial Black" },
          { label: "Georgia", value: "Georgia" },
          { label: "Impact", value: "Impact" },
          { label: "Helvetica", value: "Helvetica" },
          { label: "Roboto", value: "Roboto" },
          { label: "Tahoma", value: "Tahoma" },
          { label: "Times New Roman", value: "Times New Roman" },
          { label: "Verdana", value: "Verdana" },
          { label: "Courier New", value: "Courier New", separator: true },
          { label: "Monaco", value: "Monaco" },
          { label: "Monospace", value: "monospace" }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, "fontFamily", {
            fontFamily: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "format_font",
              "content-class": "o-font-family-dropdown dropdown",
              tooltip: unref(n)("editor.fontFamily")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createElementBlock(Fragment, { key: u }, [
                    c2.separator ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                    createVNode(unref(Tn), {
                      class: normalizeClass({
                        "is-active": (d = t2.editor) == null ? void 0 : d.isActive("textStyle", {
                          fontFamily: c2.value
                        })
                      }),
                      onClick: (p2) => s(c2.value)
                    }, {
                      suffix: withCtx(() => {
                        var p2;
                        return [
                          (p2 = t2.editor) != null && p2.isActive("textStyle", { fontFamily: c2.value }) ? (openBlock(), createBlock(unref(ye), {
                            key: 0,
                            name: "done",
                            small: ""
                          })) : createCommentVNode("", true)
                        ];
                      }),
                      default: withCtx(() => [
                        createBaseVNode("span", {
                          style: normalizeStyle(`font-family: ${c2.value}`)
                        }, toDisplayString(c2.label), 5)
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])
                  ], 64);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), RC = { class: "o-fore-color-dropdown o-button-group" }, IC = /* @__PURE__ */ defineComponent({
      __name: "OForeColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = ref("#ff4d4f");
        function s() {
          a(i.value);
        }
        function a(l) {
          var c2;
          (c2 = o.value) == null || c2.setShow(false), i.value = l, r(e.editor, "foreColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(ho), null, {
              trigger: withCtx(() => [
                createBaseVNode("div", RC, [
                  createVNode(unref(rn), {
                    icon: "format_color_text",
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${i.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(rn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.textColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(lu), {
                "default-color": "",
                "default-label": unref(n)("editor.defaultColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), DC = /* @__PURE__ */ defineComponent({
      __name: "OHeadingDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = computed(() => [
          {
            label: n("editor.paragraph"),
            value: "paragraph",
            valueAlt: "",
            icon: "title"
          },
          {
            label: n("editor.heading1"),
            value: "heading",
            valueAlt: 1,
            icon: "format_h1",
            separator: true
          },
          {
            label: n("editor.heading2"),
            value: "heading",
            valueAlt: 2,
            icon: "format_h2"
          },
          {
            label: n("editor.heading3"),
            value: "heading",
            valueAlt: 3,
            icon: "format_h3"
          },
          {
            label: n("editor.heading4"),
            value: "heading",
            valueAlt: 4,
            icon: "format_h4"
          },
          {
            label: n("editor.heading5"),
            value: "heading",
            valueAlt: 5,
            icon: "format_h5"
          }
        ]);
        function s(l) {
          var c2, u;
          return l.value === "heading" ? (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, { level: l.valueAlt }) : (u = e.editor) == null ? void 0 : u.isActive(l.value);
        }
        function a(l) {
          var c2;
          (c2 = o.value) == null || c2.setShow(false), r(e.editor, l.value, {
            level: l.valueAlt
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "format_header_pound",
              "content-class": "o-heading-dropdown dropdown",
              tooltip: unref(n)("editor.heading")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(Tn), {
                    class: normalizeClass({ "is-active": s(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      s(u) ? (openBlock(), createBlock(unref(ye), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), LC = { class: "o-list-dropdown o-button-group" }, PC = /* @__PURE__ */ defineComponent({
      __name: "OListDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = ref();
        function s() {
          r(e.editor, i.value.value);
        }
        function a(c2) {
          o.value.setShow(false), i.value = c2, r(e.editor, c2.value);
        }
        const l = computed(() => [
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        return onMounted(() => {
          i.value = l.value[0];
        }), (c2, u) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(ho), { trigger: "hover" }, {
              trigger: withCtx(() => {
                var d;
                return [
                  createBaseVNode("div", LC, [
                    createVNode(unref(rn), {
                      icon: (d = i.value) == null ? void 0 : d.icon,
                      class: "o-command-btn",
                      onClick: withModifiers(s, ["stop"])
                    }, null, 8, ["icon"]),
                    createVNode(unref(rn), {
                      icon: "arrow_drop_down",
                      class: "o-command-btn"
                    })
                  ])
                ];
              }),
              default: withCtx(() => {
                var d;
                return [
                  createTextVNode(" " + toDisplayString((d = i.value) == null ? void 0 : d.label), 1)
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => {
                  var f;
                  return openBlock(), createBlock(unref(Tn), {
                    key: p2,
                    class: normalizeClass({ "is-active": (f = t2.editor) == null ? void 0 : f.isActive(d.value) }),
                    onClick: (h2) => a(d)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: d.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var h2;
                      return [
                        (h2 = t2.editor) != null && h2.isActive(d.value) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(d.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), BC = { class: "o-list-group" }, $C = /* @__PURE__ */ defineComponent({
      __name: "OListGroup",
      props: {
        editor: {
          type: Dn,
          required: true
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = computed(() => [
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        function i(s) {
          r(e.editor, s.value);
        }
        return (s, a) => (openBlock(), createElementBlock("div", BC, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(je, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": { "is-active": (u = t2.editor) == null ? void 0 : u.isActive(l.value) },
              onClick: (d) => i(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), FC = /* @__PURE__ */ defineComponent({
      __name: "OLinkBtn",
      props: {
        editor: {
          type: Dn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(), i = ref(false), s = ref(""), a = ref(true);
        function l() {
          var p2;
          s.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (s.value = d.href, a.value = d.target === "_blank", console.log("show", i.value, d, a.value));
        }
        function c2() {
          var d;
          (d = o.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? r(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : r(e.editor, "linkUnset"), (p2 = o.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: i.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (f) => i.value = f),
            l
          ]
        }, {
          trigger: withCtx(() => {
            var f;
            return [
              createVNode(unref(Pt), {
                icon: "link",
                "content-class": { "is-active": (f = t2.editor) == null ? void 0 : f.isActive("link") },
                tooltip: unref(n)("editor.hyperlink")
              }, null, 8, ["content-class", "tooltip"])
            ];
          }),
          default: withCtx(() => [
            i.value ? (openBlock(), createBlock(unref(Im), {
              key: 0,
              title: unref(n)("editor.hyperlink"),
              val: s.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(Pm), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (f) => a.value = f),
                  label: unref(n)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), zC = /* @__PURE__ */ defineComponent({
      __name: "OLinkEditBtn",
      props: {
        editor: {
          type: Dn,
          required: true
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(), i = ref(false), s = ref(""), a = ref(true);
        function l() {
          var p2;
          s.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (s.value = d.href, a.value = d.target === "_blank");
        }
        function c2() {
          var d;
          (d = o.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? r(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : r(e.editor, "linkUnset"), (p2 = o.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: i.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (f) => i.value = f),
            l
          ]
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "edit",
              tooltip: unref(n)("link.edit")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            i.value ? (openBlock(), createBlock(unref(Im), {
              key: 0,
              title: unref(n)("link.edit"),
              val: s.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(Pm), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (f) => a.value = f),
                  label: unref(n)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), HC = /* @__PURE__ */ defineComponent({
      __name: "OLinkOpenBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le();
        function r() {
          var i;
          const o = (i = e.editor) == null ? void 0 : i.getAttributes("link");
          o != null && o.href && window.open(o.href, "target");
        }
        return (o, i) => (openBlock(), createBlock(je, {
          icon: "open_in_new",
          tooltip: unref(n)("link.open"),
          "content-class": "o-link-open-btn",
          onClick: r
        }, null, 8, ["tooltip"]));
      }
    }), UC = [
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "fore-color",
      "back-color",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "codeBlock",
      "link",
      "image",
      "video",
      "modelViewer",
      "table",
      "callout",
      // 'emoji',
      "columns",
      "aiViewer"
    ], VC = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "link",
      "image"
    ], WC = [
      "bold",
      "strike",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "list-group",
      "link",
      "callout",
      "separator",
      "align-dropdown",
      "more"
    ], KC = ["link-open", "link-edit", "linkUnset"], qC = ["align-group", "separator", "link"], GC = [
      "align-group",
      "separator",
      "link-open",
      "link-edit",
      "linkUnset"
    ], jC = [
      "heading",
      "separator",
      "italic",
      "underline",
      "font-family",
      "separator",
      "code",
      "blockquote"
    ], YC = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "font-family",
      "text-color-dropdown",
      "separator",
      "align-group"
    ], JC = [
      "style-dropdown",
      "separator",
      "bold",
      "italic",
      "text-color-dropdown",
      "separator",
      "align-dropdown"
    ], XC = { class: "o-command-btn" }, ZC = { class: "o-more-bubble" }, QC = /* @__PURE__ */ defineComponent({
      __name: "OMoreBubble",
      props: {
        editor: {
          type: Dn,
          required: true
        }
      },
      setup(t2) {
        const e = ref();
        return (n, r) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: e,
          offset: [4, 10],
          class: "o-simple-command-btn",
          "tippy-class": "o-more-bubble-popover",
          placement: "top-end",
          size: "medium",
          trigger: "mouseenter"
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", XC, [
              createVNode(unref(ye), { name: "more_horiz" })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("section", ZC, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(jC), (o, i) => (openBlock(), createElementBlock(Fragment, { key: i }, [
                o === "separator" ? (openBlock(), createBlock(unref(xn), {
                  key: 0,
                  vertical: ""
                })) : typeof o == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Wa)(o)), {
                  key: 1,
                  name: o,
                  editor: t2.editor
                }, null, 8, ["name", "editor"])) : createCommentVNode("", true)
              ], 64))), 128))
            ])
          ]),
          _: 1
        }, 512));
      }
    }), ex = /* @__PURE__ */ defineComponent({
      __name: "OStyleDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = computed(() => [
          { label: n("editor.paragraph"), value: "paragraph", icon: "title" },
          {
            label: n("editor.heading1"),
            value: "heading",
            icon: "format_h1",
            options: { level: 1 }
          },
          {
            label: n("editor.heading2"),
            value: "heading",
            icon: "format_h2",
            options: { level: 2 }
          },
          {
            label: n("editor.heading3"),
            value: "heading",
            icon: "format_h3",
            options: { level: 3 }
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" },
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          {
            label: n("editor.blockquote"),
            value: "blockquote",
            icon: "format_quote_open"
          },
          {
            label: n("editor.removeFormat"),
            value: "clearFormat",
            icon: "format_clear",
            separator: true
          }
        ]);
        function s(l) {
          var c2;
          return (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, l.options);
        }
        function a(l) {
          o.value.setShow(false), r(e.editor, l.value, l.options);
        }
        return (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "format_paint",
              "content-class": "o-style-dropdown o-command-btn dropdown",
              tooltip: unref(n)("label.styles")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(xn), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(Tn), {
                    class: normalizeClass({ "is-active": s(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      s(u) ? (openBlock(), createBlock(unref(ye), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), tx = /* @__PURE__ */ defineComponent({
      __name: "OTableBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null);
        function i(s) {
          var a;
          (a = o.value) == null || a.setShow(false), r(e.editor, "tableInsert", s);
        }
        return (s, a) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "window",
              "content-class": "o-table-btn",
              tooltip: unref(n)("table.insert")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(TS), { onSelect: i })
          ]),
          _: 1
        }, 512));
      }
    }), nx = { class: "o-table-group" }, rx = /* @__PURE__ */ defineComponent({
      __name: "OTableGroup",
      props: {
        editor: {
          type: Dn,
          required: true
        }
      },
      setup(t2) {
        const { tr: e } = Le(), { run: n } = Ze();
        return (r, o) => {
          var i, s;
          return openBlock(), createElementBlock("section", nx, [
            (i = t2.editor) != null && i.can().mergeCells() ? (openBlock(), createBlock(unref(je), {
              key: 0,
              icon: "cell_merge",
              tooltip: unref(e)("table.merge"),
              onClick: o[0] || (o[0] = (a) => unref(n)(t2.editor, "tableMergeCells"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            (s = t2.editor) != null && s.can().splitCell() ? (openBlock(), createBlock(unref(je), {
              key: 1,
              icon: "splitscreen_left",
              tooltip: unref(e)("table.split"),
              onClick: o[1] || (o[1] = (a) => unref(n)(t2.editor, "tableSplitCell"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            createVNode(unref(AS), { editor: t2.editor }, null, 8, ["editor"])
          ]);
        };
      }
    }), ox = /* @__PURE__ */ defineComponent({
      __name: "OTextColorDropdown",
      props: {
        editor: {
          type: Dn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(null), i = ref(""), s = ref("");
        function a(l, c2) {
          l === "foreColor" ? (i.value = c2, localStorage.setItem("yiitap.text-color.fore", c2)) : l === "backColor" && (s.value = c2, localStorage.setItem("yiitap.text-color.back", c2)), o.value.setShow(false), r(e.editor, l, {
            color: c2
          });
        }
        return onMounted(() => {
          i.value = localStorage.getItem("yiitap.text-color.fore") || "", s.value = localStorage.getItem("yiitap.text-color.back") || "";
        }), (l, c2) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "format_text",
              "content-class": "o-text-color-dropdown dropdown",
              tooltip: unref(n)("editor.textColor")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref($S), {
                "fore-color": i.value,
                "back-color": s.value,
                "default-label": unref(n)("editor.defaultColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["fore-color", "back-color", "default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), ix = /* @__PURE__ */ defineComponent({
      __name: "OTextFormatDropdown",
      props: {
        editor: {
          type: Dn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(), i = computed(() => [
          {
            label: n("editor.strikethrough"),
            value: "strike",
            icon: "format_strikethrough"
          },
          {
            label: n("editor.underline"),
            value: "underline",
            icon: "format_underlined"
          },
          { label: n("editor.code"), value: "code", icon: "code" }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, a);
        }
        return (a, l) => (openBlock(), createBlock(unref(st), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Pt), {
              icon: "title",
              "content-class": "o-text-format-dropdown dropdown",
              tooltip: unref(n)("editor.textFormat")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(Tn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = t2.editor) == null ? void 0 : d.isActive(c2.value) }),
                    onClick: (p2) => s(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = t2.editor) != null && p2.isActive(c2.value) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), sx = {
      // 'add-more': 'o-add-more-btn',
      "align-dropdown": xC,
      "align-group": OC,
      "back-color": AC,
      "font-family": MC,
      "fore-color": IC,
      heading: DC,
      // 'indent-dropdown': 'o-indent-dropdown',
      // 'line-height': 'o-line-height-dropdown',
      "list-dropdown": PC,
      "list-group": $C,
      link: FC,
      "link-edit": zC,
      "link-open": HC,
      // 'image-settings': 'o-image-settings-btn',
      // 'emoji': 'o-emoji-btn',
      more: QC,
      // 'node': 'o-node-btn',
      // 'node-dropdown': 'o-node-dropdown',
      "style-dropdown": ex,
      table: tx,
      "table-group": rx,
      "text-color-dropdown": ox,
      "text-format-dropdown": ix
    }, Wa = (t2) => sx[t2] || G_, ax = { class: "o-main-menu" }, lx = { class: "left" }, cx = { class: "right" }, ux = /* @__PURE__ */ defineComponent({
      __name: "OMainMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        }
      },
      setup(t2) {
        const e = t2, n = computed(() => {
          var o;
          let r = e.menu;
          return (o = e.editor) != null && o.isActive("table") && (r = VC), r.length > 0 ? r : UC;
        });
        return (r, o) => (openBlock(), createElementBlock("section", ax, [
          createBaseVNode("section", lx, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(n.value, (i, s) => (openBlock(), createElementBlock(Fragment, { key: s }, [
              i === "separator" ? (openBlock(), createBlock(unref(xn), {
                key: 0,
                vertical: ""
              })) : typeof i == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Wa)(i)), {
                key: 1,
                name: i,
                editor: t2.editor
              }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(i), {
                key: 2,
                editor: t2.editor
              }, null, 8, ["editor"]))
            ], 64))), 128)),
            renderSlot(r.$slots, "left")
          ]),
          createBaseVNode("section", cx, [
            renderSlot(r.$slots, "right")
          ])
        ]));
      }
    }), dx = {
      key: 0,
      class: "o-bubble-menu"
    }, px = { class: "container" }, fx = /* @__PURE__ */ defineComponent({
      __name: "OBubbleMenu",
      props: {
        editor: {
          type: Dn
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Le();
        Va();
        const o = ref(false), i = ref({
          duration: 100,
          placement: "top",
          role: "popover",
          arrow: false,
          // offset: [0, 0]
          onShow: () => {
            o.value = false;
          }
        });
        function s() {
          o.value = true;
        }
        function a(p2) {
          const { schema: f } = e.editor, h2 = f.marks.link;
          if (!h2 || !p2) return false;
          const { $from: m, $to: g } = p2;
          return !!Vo(m, h2);
        }
        function l({ editor: p2, element: f, view: h2, state: m, oldState: g, from: b, to: E }) {
          var te;
          const { doc: _, selection: v } = m, { empty: T } = v, S = !_.textBetween(b, E).length && $a(m.selection);
          if (!h2.hasFocus() || T || S && p2.isActive("link") && !p2.isActive("image"))
            return false;
          const F = ["image"], V = ["toc", "video", "model-viewer"], L = v.node, W = (te = L == null ? void 0 : L.type) == null ? void 0 : te.name;
          return !(p2.isActive("codeBlock") || V.indexOf(W) >= 0 || W && !F.includes(W));
        }
        const c2 = computed(() => {
          if (e.editor) {
            const { state: p2 } = e.editor, { tr: f } = p2, { selection: h2 } = f;
            return a(h2);
          } else
            return false;
        }), u = computed(() => {
          var p2;
          return !o.value && c2.value && !((p2 = e.editor) != null && p2.isActive("image"));
        }), d = computed(() => {
          var f, h2;
          let p2 = e.menu;
          return o.value || ((f = e.editor) != null && f.isActive("image") ? p2 = c2.value ? GC : qC : (h2 = e.editor) != null && h2.isActive("table") ? p2 = YC : c2.value && (p2 = KC)), p2.length > 0 ? p2 : WC;
        });
        return onMounted(() => {
          o.value = false;
        }), (p2, f) => t2.editor ? (openBlock(), createElementBlock("section", dx, [
          createVNode(unref(zw), {
            class: normalizeClass(["bubble-menu", t2.menuClass]),
            editor: t2.editor,
            "should-show": l,
            "tippy-options": i.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", px, [
                u.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(unref(je), {
                    icon: "arrow_back",
                    tooltip: unref(n)("link.back"),
                    onClick: s
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(xn), { vertical: "" })
                ], 64)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (h2, m) => (openBlock(), createElementBlock(Fragment, { key: m }, [
                  h2 === "separator" ? (openBlock(), createBlock(unref(xn), {
                    key: 0,
                    vertical: ""
                  })) : typeof h2 == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Wa)(h2)), {
                    key: 1,
                    name: h2,
                    editor: t2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(h2), {
                    key: 2,
                    editor: t2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    }), hx = {
      key: 0,
      class: "o-floating-menu"
    }, mx = { class: "container" }, gx = /* @__PURE__ */ defineComponent({
      __name: "OFloatingMenu",
      props: {
        editor: {
          type: gm
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, n = ref(false), r = ref({
          arrow: false,
          duration: 100,
          role: "popover",
          placement: "right",
          offset: [0, 168]
        });
        function o() {
          n.value = true;
        }
        function i(c2) {
          const { schema: u } = e.editor, d = u.marks.link;
          if (!d || !c2) return false;
          const { $from: p2, $to: f } = c2;
          return !!Vo(p2, d);
        }
        const s = computed(() => {
          if (e.editor) {
            const { state: c2 } = e.editor, { tr: u } = c2, { selection: d } = u;
            return i(d);
          } else
            return false;
        }), a = computed(() => !n.value && s.value), l = computed(() => {
          let c2 = e.menu;
          return c2.length > 0 ? c2 : JC;
        });
        return (c2, u) => t2.editor ? (openBlock(), createElementBlock("section", hx, [
          createVNode(unref(Uw), {
            class: normalizeClass(["floating-menu", t2.menuClass]),
            editor: t2.editor,
            "tippy-options": r.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", mx, [
                a.value ? (openBlock(), createBlock(unref(je), {
                  key: 0,
                  icon: "arrow_back",
                  onClick: o
                })) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => (openBlock(), createElementBlock(Fragment, { key: p2 }, [
                  d === "separator" ? (openBlock(), createBlock(unref(xn), {
                    key: 0,
                    vertical: ""
                  })) : typeof d == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Wa)(d)), {
                    key: 1,
                    name: d,
                    editor: t2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(d), {
                    key: 2,
                    editor: t2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    function cu(t2, e) {
      const n = e == null ? void 0 : e.posAtCoords(t2);
      if (!n)
        return;
      let r = Os(n.pos, e);
      if (r !== e.dom) {
        for (; r && r.parentNode && r.parentNode !== e.dom; )
          r = r.parentNode;
        if (r)
          return r;
      }
    }
    function Os(t2, e) {
      return e.nodeDOM(t2) || e.domAtPos(t2).node;
    }
    function uu(t2, e) {
      const n = cu(t2, e);
      if (n && n.nodeType === 1) {
        const r = e.docView, o = r.nearestDesc(n, true);
        return !o || o === r ? null : o.posBefore;
      }
      return null;
    }
    function bx(t2, e) {
      let n, r;
      const o = e.resolve(t2.from).node().type.spec.group === "blockContent", i = e.resolve(t2.to).node().type.spec.group === "blockContent", s = Math.min(t2.$anchor.depth, t2.$head.depth);
      if (o && i) {
        const a = t2.$from.start(s - 1), l = t2.$to.end(s - 1);
        n = e.resolve(a - 1).pos, r = e.resolve(l + 1).pos;
      } else
        n = t2.from, r = t2.to;
      return { from: n, to: r };
    }
    function yx(t2, e) {
      const n = uu(t2, e.view);
      return n && n >= 0 ? {
        node: e.state.doc.nodeAt(n),
        pos: n
      } : {
        node: null,
        pos: n
      };
    }
    const Js = new Je("sideMenu");
    class vx {
      constructor() {
        ft(this, "hovered", false);
        ft(this, "coords", { left: 0, top: 0 });
        ft(this, "className", "");
      }
      init(e) {
        return this;
      }
      apply({ tr: e, oldState: n, newState: r }) {
        return e.docChanged ? this : this;
      }
      setHover(e, n, r = "") {
        this.hovered = e, this.coords = n, this.className = r;
      }
    }
    class Ex {
      constructor({
        editor: e,
        element: n,
        view: r,
        tippyOptions: o = {},
        updateDelay: i = 250
      }) {
        ft(this, "editor");
        ft(this, "element");
        ft(this, "view");
        ft(this, "preventHide", false);
        ft(this, "tippy");
        ft(this, "tippyOptions");
        ft(this, "updateDelay");
        ft(this, "updateDebounceTimer");
        ft(this, "mousedownHandler", () => {
          this.preventHide = true;
        });
        ft(this, "onDragStart", (e2) => {
          this.hide();
        });
        ft(this, "blurHandler", ({ event: e2 }) => {
          var n2;
          e2 != null && e2.relatedTarget && ((n2 = this.element.parentNode) != null && n2.contains(e2.relatedTarget)) || this.hide();
        });
        ft(this, "tippyBlurHandler", (e2) => {
          this.blurHandler({ event: e2 });
        });
        ft(this, "handleDebouncedUpdate", (e2, n2) => {
          const r2 = !(n2 != null && n2.selection.eq(e2.state.selection)), o2 = !(n2 != null && n2.doc.eq(e2.state.doc));
          !r2 && !o2 || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(e2, r2, o2, n2);
          }, this.updateDelay));
        });
        ft(this, "updateHandler", (e2, n2, r2, o2) => {
          var u, d;
          const { state: i2, composing: s } = e2, { coords: a } = Js.getState(i2), l = cu(a, e2), c2 = uu(a, e2);
          !l || c2 <= 0 || (this.createTooltip(), (d = this.tippy) == null || d.setProps({
            getReferenceClientRect: ((u = this.tippyOptions) == null ? void 0 : u.getReferenceClientRect) || (() => l.getBoundingClientRect())
          }), this.show());
        });
        this.editor = e, this.element = n, this.view = r, this.updateDelay = i, this.view.dom.addEventListener("dragstart", this.onDragStart), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Zn(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "left",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
      }
      update(e, n) {
        const { state: r } = e, o = !(n != null && n.selection.eq(e.state.selection)), i = !(n != null && n.doc.eq(e.state.doc));
        this.updateHandler(e, o, i, n);
      }
      show() {
        var e;
        (e = this.tippy) == null || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) == null || e.hide();
      }
      destroy() {
        var e, n;
        (e = this.tippy) != null && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ), (n = this.tippy) == null || n.destroy(), this.view.dom.removeEventListener("dragstart", this.onDragStart);
      }
    }
    const kx = (t2, e) => {
      if (!t2.dataTransfer) return;
      const n = e.view, r = n.dom.getBoundingClientRect(), o = {
        left: r.left + r.width / 2,
        // take middle of editor
        top: t2.clientY
      }, i = uu(o, n);
      if (i === null) return;
      const s = n.state.selection, a = n.state.doc;
      bx(s, a), n.dispatch(
        n.state.tr.setSelection(re.create(n.state.doc, i))
      ), _x(n, i);
      const l = n.state.selection.content(), { dom: c2, text: u } = n.serializeForClipboard(l);
      t2.dataTransfer.clearData(), t2.dataTransfer.setData("text/html", c2.innerHTML), t2.dataTransfer.setData("text/plain", u), t2.dataTransfer.effectAllowed = "move", t2.dataTransfer.setDragImage(ro, 0, 0), n.dragging = { slice: l, move: true };
    }, wx = (t2, e) => {
      Bm();
    };
    let ro;
    function _x(t2, e, n = e) {
      const r = t2.domAtPos(e).node.cloneNode(true), o = t2.domAtPos(e).node, i = (d, p2) => Array.prototype.indexOf.call(d.children, p2), s = (d) => {
        let p2 = d, f = p2.parentElement;
        for (; f; ) {
          if (f === t2.dom)
            return p2;
          p2 = f, f = p2.parentElement;
        }
        return p2;
      };
      let a = -1, l = -1;
      e === n ? (a = i(
        o,
        s(Os(e, t2))
      ), l = a) : (a = i(
        o,
        // Expects from position to be just before the first selected block.
        s(Os(e + 1, t2))
      ), l = i(
        o,
        // Expects to position to be just after the last selected block.
        s(Os(n - 1, t2))
      ));
      for (let d = o.childElementCount - 1; d >= 0; d--)
        (d > a || d < l) && r.removeChild(r.children[d]);
      Bm(), ro = r;
      const u = t2.dom.className.split(" ").filter(
        (d) => d !== "ProseMirror" && d !== "yiitap-root" && d !== "yiitap-editor"
      ).join(" ");
      ro.className += " yiitap-dragging-preview " + u, document.body.appendChild(ro);
    }
    function Bm() {
      ro !== void 0 && (document.body.removeChild(ro), ro = void 0);
    }
    class Sx {
      constructor(e) {
        ft(this, "options");
        ft(this, "plugin");
        ft(this, "sideMenuView");
        const n = new vx();
        this.options = e, this.plugin = new Ue({
          key: Js,
          props: {
            handleDOMEvents: {
              mouseover(r, o) {
                const i = {
                  left: o.clientX,
                  top: o.clientY
                }, s = cu(i, r), a = (s == null ? void 0 : s.className) || "", l = n.className;
                a.indexOf("o-table-wrapper-view") >= 0 && l.indexOf("o-table-wrapper-view") >= 0 || (n.setHover(true, i, a), r.dispatch(r.state.tr.setMeta(Js, n)));
              }
            }
          },
          state: {
            init(r, o) {
              return n.init(o);
            },
            apply(r, o, i, s) {
              return n.apply({ tr: r, oldState: i, newState: s });
            }
          },
          view: (r) => (this.sideMenuView = new Ex({ view: r, ...e }), this.sideMenuView)
        });
      }
      dragstart(e) {
        kx(e, this.options.editor);
      }
      dragend(e) {
        wx(e, this.options.editor);
      }
    }
    const Cx = /* @__PURE__ */ defineComponent({
      name: "SideMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "sideMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        }
      },
      setup(t2, { expose: e, slots: n }) {
        const r = ref(null), o = ref(), i = (a) => {
          var l;
          (l = o.value) == null || l.dragstart(a);
        }, s = (a) => {
          var l;
          (l = o.value) == null || l.dragend(a);
        };
        return onMounted(() => {
          const { pluginKey: a, editor: l, updateDelay: c2, tippyOptions: u } = t2;
          o.value = new Sx({
            updateDelay: c2,
            editor: l,
            element: r.value,
            pluginKey: a,
            tippyOptions: u
          }), l.registerPlugin(o.value.plugin);
        }), onBeforeUnmount(() => {
          const { pluginKey: a, editor: l } = t2;
          l.unregisterPlugin(a);
        }), e({
          ...t2,
          dragstart: i,
          dragend: s
        }), () => {
          var a;
          return h("div", { ref: r }, (a = n.default) == null ? void 0 : a.call(n));
        };
      }
    }), xx = {
      key: 0,
      class: "o-side-menu"
    }, Tx = { class: "container" }, Ox = /* @__PURE__ */ defineComponent({
      __name: "OSideMenu",
      props: {
        editor: {
          type: Dn,
          required: true
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, n = ref(null), r = ref(null), o = ref(0), i = computed(() => ({
          arrow: false,
          duration: 100,
          placement: "left"
          // offset: [0, 0]
        })), s = computed(() => ({
          editor: e.editor,
          node: r.value,
          decorations: [],
          selected: false,
          extension: {},
          getPos: () => o.value,
          pos: o.value,
          updateAttributes: l,
          deleteNode: a,
          view: void 0,
          innerDecorations: [],
          HTMLAttributes: void 0
        }));
        function a() {
          var h2, m;
          const p2 = o.value, f = p2 + ((h2 = r.value) == null ? void 0 : h2.nodeSize);
          (m = e.editor) == null || m.commands.deleteRange({ from: p2, to: f });
        }
        function l(p2) {
          var f;
          (f = e.editor) == null || f.commands.command(({ tr: h2 }) => {
            var m;
            return h2.setNodeMarkup(o.value, void 0, {
              ...(m = r.value) == null ? void 0 : m.attrs,
              ...p2
            }), true;
          });
        }
        function c2({ editor: p2, transaction: f }) {
          let h2 = { left: 0, top: 0 };
          const m = Js.getState(e.editor.view.state);
          if (m) {
            h2 = m.coords;
            const g = yx(h2, p2);
            g.node && g.pos > 0 && (r.value = g.node, o.value = g.pos);
          }
        }
        function u(p2) {
          var f;
          (f = n.value) == null || f.dragstart(p2);
        }
        function d(p2) {
          var f;
          (f = n.value) == null || f.dragend(p2);
        }
        return onMounted(() => {
          var p2;
          (p2 = e.editor) == null || p2.on("transaction", c2);
        }), (p2, f) => t2.editor ? (openBlock(), createElementBlock("section", xx, [
          createVNode(unref(Cx), {
            ref_key: "menu",
            ref: n,
            class: normalizeClass(["side-menu", t2.menuClass]),
            editor: t2.editor,
            "tippy-options": i.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", Tx, [
                r.value ? (openBlock(), createBlock(unref(cC), normalizeProps(mergeProps({ key: 0 }, s.value)), null, 16)) : createCommentVNode("", true),
                r.value ? (openBlock(), createBlock(unref(mC), mergeProps({ key: 1 }, s.value, {
                  onDragstart: u,
                  onDragend: d
                }), null, 16)) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const bp = (t2) => {
      const e = /(#[0-9a-f]{3,6})\b/gi, n = [];
      return t2.descendants((r, o) => {
        r.text && Array.from(r.text.matchAll(e)).forEach((i) => {
          const s = i[0], a = i.index || 0, l = o + a, c2 = l + s.length, u = ht.inline(l, c2, {
            class: "color",
            style: `--color: ${s}`
          });
          n.push(u);
        });
      }), He.create(t2, n);
    }, Nx = Ke.create({
      name: "colorHighlighter",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("colorHighlighter"),
            state: {
              init(t2, { doc: e }) {
                return bp(e);
              },
              apply(t2, e) {
                return t2.docChanged ? bp(t2.doc) : e;
              }
            },
            props: {
              decorations(t2) {
                return this.getState(t2);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    Ke.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("focus"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const { isEditable: n, isFocused: r } = this.editor, { anchor: o } = e, i = [];
                if (!n || !r)
                  return He.create(t2, []);
                let s = 0;
                this.options.mode === "deepest" && t2.descendants((l, c2) => {
                  if (!l.isText) {
                    if (!(o >= c2 && o <= c2 + l.nodeSize - 1))
                      return false;
                    s += 1;
                  }
                });
                let a = 0;
                return t2.descendants((l, c2) => {
                  if (l.isText || !(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  i.push(
                    ht.node(c2, c2 + l.nodeSize, {
                      class: this.options.className
                    })
                  );
                }), He.create(t2, i);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Ax = Ke.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something …",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("placeholder"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, o = [];
                return n ? (t2.descendants((i, s) => {
                  const a = r >= s && r <= s + i.nodeSize, l = !i.isLeaf && !i.childCount, c2 = this.options.showOnlyCurrent;
                  if ((a || !c2) && l) {
                    const u = [this.options.emptyNodeClass];
                    this.editor.isEmpty && u.push(this.options.emptyEditorClass);
                    const d = ht.node(s, s + i.nodeSize, {
                      class: u.join(" "),
                      "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                        editor: this.editor,
                        node: i,
                        pos: s,
                        hasAnchor: a
                      }) : this.options.placeholder
                    });
                    o.push(d);
                  }
                  return this.options.includeChildren;
                }), He.create(t2, o)) : null;
              }
            }
          })
        ];
      }
    });
    var uc, dc;
    if (typeof WeakMap < "u") {
      let t2 = /* @__PURE__ */ new WeakMap();
      uc = (e) => t2.get(e), dc = (e, n) => (t2.set(e, n), n);
    } else {
      const t2 = [];
      let n = 0;
      uc = (r) => {
        for (let o = 0; o < t2.length; o += 2)
          if (t2[o] == r) return t2[o + 1];
      }, dc = (r, o) => (n == 10 && (n = 0), t2[n++] = r, t2[n++] = o);
    }
    var ut = class {
      constructor(t2, e, n, r) {
        this.width = t2, this.height = e, this.map = n, this.problems = r;
      }
      // Find the dimensions of the cell at the given position.
      findCell(t2) {
        for (let e = 0; e < this.map.length; e++) {
          const n = this.map[e];
          if (n != t2) continue;
          const r = e % this.width, o = e / this.width | 0;
          let i = r + 1, s = o + 1;
          for (let a = 1; i < this.width && this.map[e + a] == n; a++)
            i++;
          for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
            s++;
          return { left: r, top: o, right: i, bottom: s };
        }
        throw new RangeError(`No cell with offset ${t2} found`);
      }
      // Find the left side of the cell at the given position.
      colCount(t2) {
        for (let e = 0; e < this.map.length; e++)
          if (this.map[e] == t2)
            return e % this.width;
        throw new RangeError(`No cell with offset ${t2} found`);
      }
      // Find the next cell in the given direction, starting from the cell
      // at `pos`, if any.
      nextCell(t2, e, n) {
        const { left: r, right: o, top: i, bottom: s } = this.findCell(t2);
        return e == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[i * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i - 1 : s)];
      }
      // Get the rectangle spanning the two given cells.
      rectBetween(t2, e) {
        const {
          left: n,
          right: r,
          top: o,
          bottom: i
        } = this.findCell(t2), {
          left: s,
          right: a,
          top: l,
          bottom: c2
        } = this.findCell(e);
        return {
          left: Math.min(n, s),
          top: Math.min(o, l),
          right: Math.max(r, a),
          bottom: Math.max(i, c2)
        };
      }
      // Return the position of all cells that have the top left corner in
      // the given rectangle.
      cellsInRect(t2) {
        const e = [], n = {};
        for (let r = t2.top; r < t2.bottom; r++)
          for (let o = t2.left; o < t2.right; o++) {
            const i = r * this.width + o, s = this.map[i];
            n[s] || (n[s] = true, !(o == t2.left && o && this.map[i - 1] == s || r == t2.top && r && this.map[i - this.width] == s) && e.push(s));
          }
        return e;
      }
      // Return the position at which the cell at the given row and column
      // starts, or would start, if a cell started there.
      positionAt(t2, e, n) {
        for (let r = 0, o = 0; ; r++) {
          const i = o + n.child(r).nodeSize;
          if (r == t2) {
            let s = e + t2 * this.width;
            const a = (t2 + 1) * this.width;
            for (; s < a && this.map[s] < o; ) s++;
            return s == a ? i - 1 : this.map[s];
          }
          o = i;
        }
      }
      // Find the table map for the given table node.
      static get(t2) {
        return uc(t2) || dc(t2, Mx(t2));
      }
    };
    function Mx(t2) {
      if (t2.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + t2.type.name);
      const e = Rx(t2), n = t2.childCount, r = [];
      let o = 0, i = null;
      const s = [];
      for (let c2 = 0, u = e * n; c2 < u; c2++) r[c2] = 0;
      for (let c2 = 0, u = 0; c2 < n; c2++) {
        const d = t2.child(c2);
        u++;
        for (let h2 = 0; ; h2++) {
          for (; o < r.length && r[o] != 0; ) o++;
          if (h2 == d.childCount) break;
          const m = d.child(h2), { colspan: g, rowspan: b, colwidth: E } = m.attrs;
          for (let _ = 0; _ < b; _++) {
            if (_ + c2 >= n) {
              (i || (i = [])).push({
                type: "overlong_rowspan",
                pos: u,
                n: b - _
              });
              break;
            }
            const v = o + _ * e;
            for (let T = 0; T < g; T++) {
              r[v + T] == 0 ? r[v + T] = u : (i || (i = [])).push({
                type: "collision",
                row: c2,
                pos: u,
                n: g - T
              });
              const S = E && E[T];
              if (S) {
                const F = (v + T) % e * 2, V = s[F];
                V == null || V != S && s[F + 1] == 1 ? (s[F] = S, s[F + 1] = 1) : V == S && s[F + 1]++;
              }
            }
          }
          o += g, u += m.nodeSize;
        }
        const p2 = (c2 + 1) * e;
        let f = 0;
        for (; o < p2; ) r[o++] == 0 && f++;
        f && (i || (i = [])).push({ type: "missing", row: c2, n: f }), u++;
      }
      (e === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
      const a = new ut(e, n, r, i);
      let l = false;
      for (let c2 = 0; !l && c2 < s.length; c2 += 2)
        s[c2] != null && s[c2 + 1] < n && (l = true);
      return l && Ix(a, s, t2), a;
    }
    function Rx(t2) {
      let e = -1, n = false;
      for (let r = 0; r < t2.childCount; r++) {
        const o = t2.child(r);
        let i = 0;
        if (n)
          for (let s = 0; s < r; s++) {
            const a = t2.child(s);
            for (let l = 0; l < a.childCount; l++) {
              const c2 = a.child(l);
              s + c2.attrs.rowspan > r && (i += c2.attrs.colspan);
            }
          }
        for (let s = 0; s < o.childCount; s++) {
          const a = o.child(s);
          i += a.attrs.colspan, a.attrs.rowspan > 1 && (n = true);
        }
        e == -1 ? e = i : e != i && (e = Math.max(e, i));
      }
      return e;
    }
    function Ix(t2, e, n) {
      t2.problems || (t2.problems = []);
      const r = {};
      for (let o = 0; o < t2.map.length; o++) {
        const i = t2.map[o];
        if (r[i]) continue;
        r[i] = true;
        const s = n.nodeAt(i);
        if (!s)
          throw new RangeError(`No cell with offset ${i} found`);
        let a = null;
        const l = s.attrs;
        for (let c2 = 0; c2 < l.colspan; c2++) {
          const u = (o + c2) % t2.width, d = e[u * 2];
          d != null && (!l.colwidth || l.colwidth[c2] != d) && ((a || (a = Dx(l)))[c2] = d);
        }
        a && t2.problems.unshift({
          type: "colwidth mismatch",
          pos: i,
          colwidth: a
        });
      }
    }
    function Dx(t2) {
      if (t2.colwidth) return t2.colwidth.slice();
      const e = [];
      for (let n = 0; n < t2.colspan; n++) e.push(0);
      return e;
    }
    function Ht(t2) {
      let e = t2.cached.tableNodeTypes;
      if (!e) {
        e = t2.cached.tableNodeTypes = {};
        for (const n in t2.nodes) {
          const r = t2.nodes[n], o = r.spec.tableRole;
          o && (e[o] = r);
        }
      }
      return e;
    }
    var Cr = new Je("selectingCells");
    function Ko(t2) {
      for (let e = t2.depth - 1; e > 0; e--)
        if (t2.node(e).type.spec.tableRole == "row")
          return t2.node(0).resolve(t2.before(e + 1));
      return null;
    }
    function Lx(t2) {
      for (let e = t2.depth; e > 0; e--) {
        const n = t2.node(e).type.spec.tableRole;
        if (n === "cell" || n === "header_cell") return t2.node(e);
      }
      return null;
    }
    function Bn(t2) {
      const e = t2.selection.$head;
      for (let n = e.depth; n > 0; n--)
        if (e.node(n).type.spec.tableRole == "row") return true;
      return false;
    }
    function Ka(t2) {
      const e = t2.selection;
      if ("$anchorCell" in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
      if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
      const n = Ko(e.$head) || Px(e.$head);
      if (n)
        return n;
      throw new RangeError(`No cell found around position ${e.head}`);
    }
    function Px(t2) {
      for (let e = t2.nodeAfter, n = t2.pos; e; e = e.firstChild, n++) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell") return t2.doc.resolve(n);
      }
      for (let e = t2.nodeBefore, n = t2.pos; e; e = e.lastChild, n--) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
          return t2.doc.resolve(n - e.nodeSize);
      }
    }
    function pc(t2) {
      return t2.parent.type.spec.tableRole == "row" && !!t2.nodeAfter;
    }
    function Bx(t2) {
      return t2.node(0).resolve(t2.pos + t2.nodeAfter.nodeSize);
    }
    function du(t2, e) {
      return t2.depth == e.depth && t2.pos >= e.start(-1) && t2.pos <= e.end(-1);
    }
    function $m(t2, e, n) {
      const r = t2.node(-1), o = ut.get(r), i = t2.start(-1), s = o.nextCell(t2.pos - i, e, n);
      return s == null ? null : t2.node(0).resolve(i + s);
    }
    function uo(t2, e, n = 1) {
      const r = { ...t2, colspan: t2.colspan - n };
      return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
    }
    function Fm(t2, e, n = 1) {
      const r = { ...t2, colspan: t2.colspan + n };
      if (r.colwidth) {
        r.colwidth = r.colwidth.slice();
        for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
      }
      return r;
    }
    function $x(t2, e, n) {
      const r = Ht(e.type.schema).header_cell;
      for (let o = 0; o < t2.height; o++)
        if (e.nodeAt(t2.map[n + o * t2.width]).type != r)
          return false;
      return true;
    }
    var Ye = class or extends ue {
      // A table selection is identified by its anchor and head cells. The
      // positions given to this constructor should point _before_ two
      // cells in the same table. They may be the same, to select a single
      // cell.
      constructor(e, n = e) {
        const r = e.node(-1), o = ut.get(r), i = e.start(-1), s = o.rectBetween(
          e.pos - i,
          n.pos - i
        ), a = e.node(0), l = o.cellsInRect(s).filter((u) => u != n.pos - i);
        l.unshift(n.pos - i);
        const c2 = l.map((u) => {
          const d = r.nodeAt(u);
          if (!d)
            throw RangeError(`No cell with offset ${u} found`);
          const p2 = i + u + 1;
          return new Ff(
            a.resolve(p2),
            a.resolve(p2 + d.content.size)
          );
        });
        super(c2[0].$from, c2[0].$to, c2), this.$anchorCell = e, this.$headCell = n;
      }
      map(e, n) {
        const r = e.resolve(n.map(this.$anchorCell.pos)), o = e.resolve(n.map(this.$headCell.pos));
        if (pc(r) && pc(o) && du(r, o)) {
          const i = this.$anchorCell.node(-1) != r.node(-1);
          return i && this.isRowSelection() ? or.rowSelection(r, o) : i && this.isColSelection() ? or.colSelection(r, o) : new or(r, o);
        }
        return ie.between(r, o);
      }
      // Returns a rectangular slice of table rows containing the selected
      // cells.
      content() {
        const e = this.$anchorCell.node(-1), n = ut.get(e), r = this.$anchorCell.start(-1), o = n.rectBetween(
          this.$anchorCell.pos - r,
          this.$headCell.pos - r
        ), i = {}, s = [];
        for (let l = o.top; l < o.bottom; l++) {
          const c2 = [];
          for (let u = l * n.width + o.left, d = o.left; d < o.right; d++, u++) {
            const p2 = n.map[u];
            if (i[p2]) continue;
            i[p2] = true;
            const f = n.findCell(p2);
            let h2 = e.nodeAt(p2);
            if (!h2)
              throw RangeError(`No cell with offset ${p2} found`);
            const m = o.left - f.left, g = f.right - o.right;
            if (m > 0 || g > 0) {
              let b = h2.attrs;
              if (m > 0 && (b = uo(b, 0, m)), g > 0 && (b = uo(
                b,
                b.colspan - g,
                g
              )), f.left < o.left) {
                if (h2 = h2.type.createAndFill(b), !h2)
                  throw RangeError(
                    `Could not create cell with attrs ${JSON.stringify(b)}`
                  );
              } else
                h2 = h2.type.create(b, h2.content);
            }
            if (f.top < o.top || f.bottom > o.bottom) {
              const b = {
                ...h2.attrs,
                rowspan: Math.min(f.bottom, o.bottom) - Math.max(f.top, o.top)
              };
              f.top < o.top ? h2 = h2.type.createAndFill(b) : h2 = h2.type.create(b, h2.content);
            }
            c2.push(h2);
          }
          s.push(e.child(l).copy(R.from(c2)));
        }
        const a = this.isColSelection() && this.isRowSelection() ? e : s;
        return new K(R.from(a), 1, 1);
      }
      replace(e, n = K.empty) {
        const r = e.steps.length, o = this.ranges;
        for (let s = 0; s < o.length; s++) {
          const { $from: a, $to: l } = o[s], c2 = e.mapping.slice(r);
          e.replace(
            c2.map(a.pos),
            c2.map(l.pos),
            s ? K.empty : n
          );
        }
        const i = ue.findFrom(
          e.doc.resolve(e.mapping.slice(r).map(this.to)),
          -1
        );
        i && e.setSelection(i);
      }
      replaceWith(e, n) {
        this.replace(e, new K(R.from(n), 0, 0));
      }
      forEachCell(e) {
        const n = this.$anchorCell.node(-1), r = ut.get(n), o = this.$anchorCell.start(-1), i = r.cellsInRect(
          r.rectBetween(
            this.$anchorCell.pos - o,
            this.$headCell.pos - o
          )
        );
        for (let s = 0; s < i.length; s++)
          e(n.nodeAt(i[s]), o + i[s]);
      }
      // True if this selection goes all the way from the top to the
      // bottom of the table.
      isColSelection() {
        const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
        if (Math.min(e, n) > 0) return false;
        const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = n + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(r, o) == this.$headCell.node(-1).childCount;
      }
      // Returns the smallest column selection that covers the given anchor
      // and head cell.
      static colSelection(e, n = e) {
        const r = e.node(-1), o = ut.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(n.pos - i), l = e.node(0);
        return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i + o.map[s.left])), a.bottom < o.height && (n = l.resolve(
          i + o.map[o.width * (o.height - 1) + a.right - 1]
        ))) : (a.top > 0 && (n = l.resolve(i + o.map[a.left])), s.bottom < o.height && (e = l.resolve(
          i + o.map[o.width * (o.height - 1) + s.right - 1]
        ))), new or(e, n);
      }
      // True if this selection goes all the way from the left to the
      // right of the table.
      isRowSelection() {
        const e = this.$anchorCell.node(-1), n = ut.get(e), r = this.$anchorCell.start(-1), o = n.colCount(this.$anchorCell.pos - r), i = n.colCount(this.$headCell.pos - r);
        if (Math.min(o, i) > 0) return false;
        const s = o + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(s, a) == n.width;
      }
      eq(e) {
        return e instanceof or && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
      }
      // Returns the smallest row selection that covers the given anchor
      // and head cell.
      static rowSelection(e, n = e) {
        const r = e.node(-1), o = ut.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(n.pos - i), l = e.node(0);
        return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
          i + o.map[s.top * o.width]
        )), a.right < o.width && (n = l.resolve(
          i + o.map[o.width * (a.top + 1) - 1]
        ))) : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])), s.right < o.width && (e = l.resolve(
          i + o.map[o.width * (s.top + 1) - 1]
        ))), new or(e, n);
      }
      toJSON() {
        return {
          type: "cell",
          anchor: this.$anchorCell.pos,
          head: this.$headCell.pos
        };
      }
      static fromJSON(e, n) {
        return new or(e.resolve(n.anchor), e.resolve(n.head));
      }
      static create(e, n, r = n) {
        return new or(e.resolve(n), e.resolve(r));
      }
      getBookmark() {
        return new Fx(this.$anchorCell.pos, this.$headCell.pos);
      }
    };
    Ye.prototype.visible = false;
    ue.jsonID("cell", Ye);
    var Fx = class zm {
      constructor(e, n) {
        this.anchor = e, this.head = n;
      }
      map(e) {
        return new zm(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        const n = e.resolve(this.anchor), r = e.resolve(this.head);
        return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && du(n, r) ? new Ye(n, r) : ue.near(r, 1);
      }
    };
    function zx(t2) {
      if (!(t2.selection instanceof Ye)) return null;
      const e = [];
      return t2.selection.forEachCell((n, r) => {
        e.push(
          ht.node(r, r + n.nodeSize, { class: "selectedCell" })
        );
      }), He.create(t2.doc, e);
    }
    function Hx({ $from: t2, $to: e }) {
      if (t2.pos == e.pos || t2.pos < e.pos - 6) return false;
      let n = t2.pos, r = e.pos, o = t2.depth;
      for (; o >= 0 && !(t2.after(o + 1) < t2.end(o)); o--, n++)
        ;
      for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--)
        ;
      return n == r && /row|table/.test(t2.node(o).type.spec.tableRole);
    }
    function Ux({ $from: t2, $to: e }) {
      let n, r;
      for (let o = t2.depth; o > 0; o--) {
        const i = t2.node(o);
        if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
          n = i;
          break;
        }
      }
      for (let o = e.depth; o > 0; o--) {
        const i = e.node(o);
        if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
          r = i;
          break;
        }
      }
      return n !== r && e.parentOffset === 0;
    }
    function Vx(t2, e, n) {
      const r = (e || t2).selection, o = (e || t2).doc;
      let i, s;
      if (r instanceof re && (s = r.node.type.spec.tableRole)) {
        if (s == "cell" || s == "header_cell")
          i = Ye.create(o, r.from);
        else if (s == "row") {
          const a = o.resolve(r.from + 1);
          i = Ye.rowSelection(a, a);
        } else if (!n) {
          const a = ut.get(r.node), l = r.from + 1, c2 = l + a.map[a.width * a.height - 1];
          i = Ye.create(o, l + 1, c2);
        }
      } else r instanceof ie && Hx(r) ? i = ie.create(o, r.from) : r instanceof ie && Ux(r) && (i = ie.create(o, r.$from.start(), r.$from.end()));
      return i && (e || (e = t2.tr)).setSelection(i), e;
    }
    var Wx = new Je("fix-tables");
    function Hm(t2, e, n, r) {
      const o = t2.childCount, i = e.childCount;
      e: for (let s = 0, a = 0; s < i; s++) {
        const l = e.child(s);
        for (let c2 = a, u = Math.min(o, s + 3); c2 < u; c2++)
          if (t2.child(c2) == l) {
            a = c2 + 1, n += l.nodeSize;
            continue e;
          }
        r(l, n), a < o && t2.child(a).sameMarkup(l) ? Hm(t2.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
      }
    }
    function Um(t2, e) {
      let n;
      const r = (o, i) => {
        o.type.spec.tableRole == "table" && (n = Kx(t2, o, i, n));
      };
      return e ? e.doc != t2.doc && Hm(e.doc, t2.doc, 0, r) : t2.doc.descendants(r), n;
    }
    function Kx(t2, e, n, r) {
      const o = ut.get(e);
      if (!o.problems) return r;
      r || (r = t2.tr);
      const i = [];
      for (let l = 0; l < o.height; l++) i.push(0);
      for (let l = 0; l < o.problems.length; l++) {
        const c2 = o.problems[l];
        if (c2.type == "collision") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          const d = u.attrs;
          for (let p2 = 0; p2 < d.rowspan; p2++) i[c2.row + p2] += c2.n;
          r.setNodeMarkup(
            r.mapping.map(n + 1 + c2.pos),
            null,
            uo(d, d.colspan - c2.n, c2.n)
          );
        } else if (c2.type == "missing")
          i[c2.row] += c2.n;
        else if (c2.type == "overlong_rowspan") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          r.setNodeMarkup(r.mapping.map(n + 1 + c2.pos), null, {
            ...u.attrs,
            rowspan: u.attrs.rowspan - c2.n
          });
        } else if (c2.type == "colwidth mismatch") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          r.setNodeMarkup(r.mapping.map(n + 1 + c2.pos), null, {
            ...u.attrs,
            colwidth: c2.colwidth
          });
        } else if (c2.type == "zero_sized") {
          const u = r.mapping.map(n);
          r.delete(u, u + e.nodeSize);
        }
      }
      let s, a;
      for (let l = 0; l < i.length; l++)
        i[l] && (s == null && (s = l), a = l);
      for (let l = 0, c2 = n + 1; l < o.height; l++) {
        const u = e.child(l), d = c2 + u.nodeSize, p2 = i[l];
        if (p2 > 0) {
          let f = "cell";
          u.firstChild && (f = u.firstChild.type.spec.tableRole);
          const h2 = [];
          for (let g = 0; g < p2; g++) {
            const b = Ht(t2.schema)[f].createAndFill();
            b && h2.push(b);
          }
          const m = (l == 0 || s == l - 1) && a == l ? c2 + 1 : d - 1;
          r.insert(r.mapping.map(m), h2);
        }
        c2 = d;
      }
      return r.setMeta(Wx, { fixTables: true });
    }
    function Qn(t2) {
      const e = t2.selection, n = Ka(t2), r = n.node(-1), o = n.start(-1), i = ut.get(r);
      return { ...e instanceof Ye ? i.rectBetween(
        e.$anchorCell.pos - o,
        e.$headCell.pos - o
      ) : i.findCell(n.pos - o), tableStart: o, map: i, table: r };
    }
    function Vm(t2, { map: e, tableStart: n, table: r }, o) {
      let i = o > 0 ? -1 : 0;
      $x(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
      for (let s = 0; s < e.height; s++) {
        const a = s * e.width + o;
        if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
          const l = e.map[a], c2 = r.nodeAt(l);
          t2.setNodeMarkup(
            t2.mapping.map(n + l),
            null,
            Fm(c2.attrs, o - e.colCount(l))
          ), s += c2.attrs.rowspan - 1;
        } else {
          const l = i == null ? Ht(r.type.schema).cell : r.nodeAt(e.map[a + i]).type, c2 = e.positionAt(s, o, r);
          t2.insert(t2.mapping.map(n + c2), l.createAndFill());
        }
      }
      return t2;
    }
    function qx(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Vm(t2.tr, n, n.left));
      }
      return true;
    }
    function Gx(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Vm(t2.tr, n, n.right));
      }
      return true;
    }
    function jx(t2, { map: e, table: n, tableStart: r }, o) {
      const i = t2.mapping.maps.length;
      for (let s = 0; s < e.height; ) {
        const a = s * e.width + o, l = e.map[a], c2 = n.nodeAt(l), u = c2.attrs;
        if (o > 0 && e.map[a - 1] == l || o < e.width - 1 && e.map[a + 1] == l)
          t2.setNodeMarkup(
            t2.mapping.slice(i).map(r + l),
            null,
            uo(u, o - e.colCount(l))
          );
        else {
          const d = t2.mapping.slice(i).map(r + l);
          t2.delete(d, d + c2.nodeSize);
        }
        s += u.rowspan;
      }
    }
    function Yx(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2), r = t2.tr;
        if (n.left == 0 && n.right == n.map.width) return false;
        for (let o = n.right - 1; jx(r, n, o), o != n.left; o--) {
          const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
          if (!i)
            throw RangeError("No table found");
          n.table = i, n.map = ut.get(i);
        }
        e(r);
      }
      return true;
    }
    function Jx(t2, e, n) {
      var r;
      const o = Ht(e.type.schema).header_cell;
      for (let i = 0; i < t2.width; i++)
        if (((r = e.nodeAt(t2.map[i + n * t2.width])) == null ? void 0 : r.type) != o)
          return false;
      return true;
    }
    function Wm(t2, { map: e, tableStart: n, table: r }, o) {
      var i;
      let s = n;
      for (let c2 = 0; c2 < o; c2++) s += r.child(c2).nodeSize;
      const a = [];
      let l = o > 0 ? -1 : 0;
      Jx(e, r, o + l) && (l = o == 0 || o == e.height ? null : 0);
      for (let c2 = 0, u = e.width * o; c2 < e.width; c2++, u++)
        if (o > 0 && o < e.height && e.map[u] == e.map[u - e.width]) {
          const d = e.map[u], p2 = r.nodeAt(d).attrs;
          t2.setNodeMarkup(n + d, null, {
            ...p2,
            rowspan: p2.rowspan + 1
          }), c2 += p2.colspan - 1;
        } else {
          const d = l == null ? Ht(r.type.schema).cell : (i = r.nodeAt(e.map[u + l * e.width])) == null ? void 0 : i.type, p2 = d == null ? void 0 : d.createAndFill();
          p2 && a.push(p2);
        }
      return t2.insert(s, Ht(r.type.schema).row.create(null, a)), t2;
    }
    function Xx(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Wm(t2.tr, n, n.top));
      }
      return true;
    }
    function Zx(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Wm(t2.tr, n, n.bottom));
      }
      return true;
    }
    function Qx(t2, { map: e, table: n, tableStart: r }, o) {
      let i = 0;
      for (let c2 = 0; c2 < o; c2++) i += n.child(c2).nodeSize;
      const s = i + n.child(o).nodeSize, a = t2.mapping.maps.length;
      t2.delete(i + r, s + r);
      const l = /* @__PURE__ */ new Set();
      for (let c2 = 0, u = o * e.width; c2 < e.width; c2++, u++) {
        const d = e.map[u];
        if (!l.has(d)) {
          if (l.add(d), o > 0 && d == e.map[u - e.width]) {
            const p2 = n.nodeAt(d).attrs;
            t2.setNodeMarkup(t2.mapping.slice(a).map(d + r), null, {
              ...p2,
              rowspan: p2.rowspan - 1
            }), c2 += p2.colspan - 1;
          } else if (o < e.height && d == e.map[u + e.width]) {
            const p2 = n.nodeAt(d), f = p2.attrs, h2 = p2.type.create(
              { ...f, rowspan: p2.attrs.rowspan - 1 },
              p2.content
            ), m = e.positionAt(o + 1, c2, n);
            t2.insert(t2.mapping.slice(a).map(r + m), h2), c2 += f.colspan - 1;
          }
        }
      }
    }
    function eT(t2, e) {
      if (!Bn(t2)) return false;
      if (e) {
        const n = Qn(t2), r = t2.tr;
        if (n.top == 0 && n.bottom == n.map.height) return false;
        for (let o = n.bottom - 1; Qx(r, n, o), o != n.top; o--) {
          const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
          if (!i)
            throw RangeError("No table found");
          n.table = i, n.map = ut.get(n.table);
        }
        e(r);
      }
      return true;
    }
    function yp(t2) {
      const e = t2.content;
      return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
    }
    function tT({ width: t2, height: e, map: n }, r) {
      let o = r.top * t2 + r.left, i = o, s = (r.bottom - 1) * t2 + r.left, a = o + (r.right - r.left - 1);
      for (let l = r.top; l < r.bottom; l++) {
        if (r.left > 0 && n[i] == n[i - 1] || r.right < t2 && n[a] == n[a + 1])
          return true;
        i += t2, a += t2;
      }
      for (let l = r.left; l < r.right; l++) {
        if (r.top > 0 && n[o] == n[o - t2] || r.bottom < e && n[s] == n[s + t2])
          return true;
        o++, s++;
      }
      return false;
    }
    function vp(t2, e) {
      const n = t2.selection;
      if (!(n instanceof Ye) || n.$anchorCell.pos == n.$headCell.pos)
        return false;
      const r = Qn(t2), { map: o } = r;
      if (tT(o, r)) return false;
      if (e) {
        const i = t2.tr, s = {};
        let a = R.empty, l, c2;
        for (let u = r.top; u < r.bottom; u++)
          for (let d = r.left; d < r.right; d++) {
            const p2 = o.map[u * o.width + d], f = r.table.nodeAt(p2);
            if (!(s[p2] || !f))
              if (s[p2] = true, l == null)
                l = p2, c2 = f;
              else {
                yp(f) || (a = a.append(f.content));
                const h2 = i.mapping.map(p2 + r.tableStart);
                i.delete(h2, h2 + f.nodeSize);
              }
          }
        if (l == null || c2 == null)
          return true;
        if (i.setNodeMarkup(l + r.tableStart, null, {
          ...Fm(
            c2.attrs,
            c2.attrs.colspan,
            r.right - r.left - c2.attrs.colspan
          ),
          rowspan: r.bottom - r.top
        }), a.size) {
          const u = l + 1 + c2.content.size, d = yp(c2) ? l + 1 : u;
          i.replaceWith(d + r.tableStart, u + r.tableStart, a);
        }
        i.setSelection(
          new Ye(i.doc.resolve(l + r.tableStart))
        ), e(i);
      }
      return true;
    }
    function Ep(t2, e) {
      const n = Ht(t2.schema);
      return nT(({ node: r }) => n[r.type.spec.tableRole])(t2, e);
    }
    function nT(t2) {
      return (e, n) => {
        var r;
        const o = e.selection;
        let i, s;
        if (o instanceof Ye) {
          if (o.$anchorCell.pos != o.$headCell.pos) return false;
          i = o.$anchorCell.nodeAfter, s = o.$anchorCell.pos;
        } else {
          if (i = Lx(o.$from), !i) return false;
          s = (r = Ko(o.$from)) == null ? void 0 : r.pos;
        }
        if (i == null || s == null || i.attrs.colspan == 1 && i.attrs.rowspan == 1)
          return false;
        if (n) {
          let a = i.attrs;
          const l = [], c2 = a.colwidth;
          a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
          const u = Qn(e), d = e.tr;
          for (let f = 0; f < u.right - u.left; f++)
            l.push(
              c2 ? {
                ...a,
                colwidth: c2 && c2[f] ? [c2[f]] : null
              } : a
            );
          let p2;
          for (let f = u.top; f < u.bottom; f++) {
            let h2 = u.map.positionAt(f, u.left, u.table);
            f == u.top && (h2 += i.nodeSize);
            for (let m = u.left, g = 0; m < u.right; m++, g++)
              m == u.left && f == u.top || d.insert(
                p2 = d.mapping.map(h2 + u.tableStart, 1),
                t2({ node: i, row: f, col: m }).createAndFill(l[g])
              );
          }
          d.setNodeMarkup(
            s,
            t2({ node: i, row: u.top, col: u.left }),
            l[0]
          ), o instanceof Ye && d.setSelection(
            new Ye(
              d.doc.resolve(o.$anchorCell.pos),
              p2 ? d.doc.resolve(p2) : void 0
            )
          ), n(d);
        }
        return true;
      };
    }
    function rT(t2, e) {
      return function(n, r) {
        if (!Bn(n)) return false;
        const o = Ka(n);
        if (o.nodeAfter.attrs[t2] === e) return false;
        if (r) {
          const i = n.tr;
          n.selection instanceof Ye ? n.selection.forEachCell((s, a) => {
            s.attrs[t2] !== e && i.setNodeMarkup(a, null, {
              ...s.attrs,
              [t2]: e
            });
          }) : i.setNodeMarkup(o.pos, null, {
            ...o.nodeAfter.attrs,
            [t2]: e
          }), r(i);
        }
        return true;
      };
    }
    function oT(t2) {
      return function(e, n) {
        if (!Bn(e)) return false;
        if (n) {
          const r = Ht(e.schema), o = Qn(e), i = e.tr, s = o.map.cellsInRect(
            t2 == "column" ? {
              left: o.left,
              top: 0,
              right: o.right,
              bottom: o.map.height
            } : t2 == "row" ? {
              left: 0,
              top: o.top,
              right: o.map.width,
              bottom: o.bottom
            } : o
          ), a = s.map((l) => o.table.nodeAt(l));
          for (let l = 0; l < s.length; l++)
            a[l].type == r.header_cell && i.setNodeMarkup(
              o.tableStart + s[l],
              r.cell,
              a[l].attrs
            );
          if (i.steps.length == 0)
            for (let l = 0; l < s.length; l++)
              i.setNodeMarkup(
                o.tableStart + s[l],
                r.header_cell,
                a[l].attrs
              );
          n(i);
        }
        return true;
      };
    }
    function kp(t2, e, n) {
      const r = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: t2 == "row" ? e.map.width : 1,
        bottom: t2 == "column" ? e.map.height : 1
      });
      for (let o = 0; o < r.length; o++) {
        const i = e.table.nodeAt(r[o]);
        if (i && i.type !== n.header_cell)
          return false;
      }
      return true;
    }
    function Mi(t2, e) {
      return e = e || { useDeprecatedLogic: false }, e.useDeprecatedLogic ? oT(t2) : function(n, r) {
        if (!Bn(n)) return false;
        if (r) {
          const o = Ht(n.schema), i = Qn(n), s = n.tr, a = kp("row", i, o), l = kp(
            "column",
            i,
            o
          ), u = (t2 === "column" ? a : t2 === "row" ? l : false) ? 1 : 0, d = t2 == "column" ? {
            left: 0,
            top: u,
            right: 1,
            bottom: i.map.height
          } : t2 == "row" ? {
            left: u,
            top: 0,
            right: i.map.width,
            bottom: 1
          } : i, p2 = t2 == "column" ? l ? o.cell : o.header_cell : t2 == "row" ? a ? o.cell : o.header_cell : o.cell;
          i.map.cellsInRect(d).forEach((f) => {
            const h2 = f + i.tableStart, m = s.doc.nodeAt(h2);
            m && s.setNodeMarkup(h2, p2, m.attrs);
          }), r(s);
        }
        return true;
      };
    }
    Mi("row", {
      useDeprecatedLogic: true
    });
    Mi("column", {
      useDeprecatedLogic: true
    });
    var iT = Mi("cell", {
      useDeprecatedLogic: true
    });
    function sT(t2, e) {
      if (e < 0) {
        const n = t2.nodeBefore;
        if (n) return t2.pos - n.nodeSize;
        for (let r = t2.index(-1) - 1, o = t2.before(); r >= 0; r--) {
          const i = t2.node(-1).child(r), s = i.lastChild;
          if (s)
            return o - 1 - s.nodeSize;
          o -= i.nodeSize;
        }
      } else {
        if (t2.index() < t2.parent.childCount - 1)
          return t2.pos + t2.nodeAfter.nodeSize;
        const n = t2.node(-1);
        for (let r = t2.indexAfter(-1), o = t2.after(); r < n.childCount; r++) {
          const i = n.child(r);
          if (i.childCount) return o + 1;
          o += i.nodeSize;
        }
      }
      return null;
    }
    function wp(t2) {
      return function(e, n) {
        if (!Bn(e)) return false;
        const r = sT(Ka(e), t2);
        if (r == null) return false;
        if (n) {
          const o = e.doc.resolve(r);
          n(
            e.tr.setSelection(ie.between(o, Bx(o))).scrollIntoView()
          );
        }
        return true;
      };
    }
    function aT(t2, e) {
      const n = t2.selection.$anchor;
      for (let r = n.depth; r > 0; r--)
        if (n.node(r).type.spec.tableRole == "table")
          return e && e(
            t2.tr.delete(n.before(r), n.after(r)).scrollIntoView()
          ), true;
      return false;
    }
    function as(t2, e) {
      const n = t2.selection;
      if (!(n instanceof Ye)) return false;
      if (e) {
        const r = t2.tr, o = Ht(t2.schema).cell.createAndFill().content;
        n.forEachCell((i, s) => {
          i.content.eq(o) || r.replace(
            r.mapping.map(s + 1),
            r.mapping.map(s + i.nodeSize - 1),
            new K(o, 0, 0)
          );
        }), r.docChanged && e(r);
      }
      return true;
    }
    function lT(t2) {
      if (!t2.size) return null;
      let { content: e, openStart: n, openEnd: r } = t2;
      for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
        n--, r--, e = e.child(0).content;
      const o = e.child(0), i = o.type.spec.tableRole, s = o.type.schema, a = [];
      if (i == "row")
        for (let l = 0; l < e.childCount; l++) {
          let c2 = e.child(l).content;
          const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
          (u || d) && (c2 = fc(
            Ht(s).row,
            new K(c2, u, d)
          ).content), a.push(c2);
        }
      else if (i == "cell" || i == "header_cell")
        a.push(
          n || r ? fc(
            Ht(s).row,
            new K(e, n, r)
          ).content : e
        );
      else
        return null;
      return cT(s, a);
    }
    function cT(t2, e) {
      const n = [];
      for (let o = 0; o < e.length; o++) {
        const i = e[o];
        for (let s = i.childCount - 1; s >= 0; s--) {
          const { rowspan: a, colspan: l } = i.child(s).attrs;
          for (let c2 = o; c2 < o + a; c2++)
            n[c2] = (n[c2] || 0) + l;
        }
      }
      let r = 0;
      for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
      for (let o = 0; o < n.length; o++)
        if (o >= e.length && e.push(R.empty), n[o] < r) {
          const i = Ht(t2).cell.createAndFill(), s = [];
          for (let a = n[o]; a < r; a++)
            s.push(i);
          e[o] = e[o].append(R.from(s));
        }
      return { height: e.length, width: r, rows: e };
    }
    function fc(t2, e) {
      const n = t2.createAndFill();
      return new Tc(n).replace(0, n.content.size, e).doc;
    }
    function uT({ width: t2, height: e, rows: n }, r, o) {
      if (t2 != r) {
        const i = [], s = [];
        for (let a = 0; a < n.length; a++) {
          const l = n[a], c2 = [];
          for (let u = i[a] || 0, d = 0; u < r; d++) {
            let p2 = l.child(d % l.childCount);
            u + p2.attrs.colspan > r && (p2 = p2.type.createChecked(
              uo(
                p2.attrs,
                p2.attrs.colspan,
                u + p2.attrs.colspan - r
              ),
              p2.content
            )), c2.push(p2), u += p2.attrs.colspan;
            for (let f = 1; f < p2.attrs.rowspan; f++)
              i[a + f] = (i[a + f] || 0) + p2.attrs.colspan;
          }
          s.push(R.from(c2));
        }
        n = s, t2 = r;
      }
      if (e != o) {
        const i = [];
        for (let s = 0, a = 0; s < o; s++, a++) {
          const l = [], c2 = n[a % e];
          for (let u = 0; u < c2.childCount; u++) {
            let d = c2.child(u);
            s + d.attrs.rowspan > o && (d = d.type.create(
              {
                ...d.attrs,
                rowspan: Math.max(1, o - d.attrs.rowspan)
              },
              d.content
            )), l.push(d);
          }
          i.push(R.from(l));
        }
        n = i, e = o;
      }
      return { width: t2, height: e, rows: n };
    }
    function dT(t2, e, n, r, o, i, s) {
      const a = t2.doc.type.schema, l = Ht(a);
      let c2, u;
      if (o > e.width)
        for (let d = 0, p2 = 0; d < e.height; d++) {
          const f = n.child(d);
          p2 += f.nodeSize;
          const h2 = [];
          let m;
          f.lastChild == null || f.lastChild.type == l.cell ? m = c2 || (c2 = l.cell.createAndFill()) : m = u || (u = l.header_cell.createAndFill());
          for (let g = e.width; g < o; g++) h2.push(m);
          t2.insert(t2.mapping.slice(s).map(p2 - 1 + r), h2);
        }
      if (i > e.height) {
        const d = [];
        for (let h2 = 0, m = (e.height - 1) * e.width; h2 < Math.max(e.width, o); h2++) {
          const g = h2 >= e.width ? false : n.nodeAt(e.map[m + h2]).type == l.header_cell;
          d.push(
            g ? u || (u = l.header_cell.createAndFill()) : c2 || (c2 = l.cell.createAndFill())
          );
        }
        const p2 = l.row.create(null, R.from(d)), f = [];
        for (let h2 = e.height; h2 < i; h2++) f.push(p2);
        t2.insert(t2.mapping.slice(s).map(r + n.nodeSize - 2), f);
      }
      return !!(c2 || u);
    }
    function _p(t2, e, n, r, o, i, s, a) {
      if (s == 0 || s == e.height) return false;
      let l = false;
      for (let c2 = o; c2 < i; c2++) {
        const u = s * e.width + c2, d = e.map[u];
        if (e.map[u - e.width] == d) {
          l = true;
          const p2 = n.nodeAt(d), { top: f, left: h2 } = e.findCell(d);
          t2.setNodeMarkup(t2.mapping.slice(a).map(d + r), null, {
            ...p2.attrs,
            rowspan: s - f
          }), t2.insert(
            t2.mapping.slice(a).map(e.positionAt(s, h2, n)),
            p2.type.createAndFill({
              ...p2.attrs,
              rowspan: f + p2.attrs.rowspan - s
            })
          ), c2 += p2.attrs.colspan - 1;
        }
      }
      return l;
    }
    function Sp(t2, e, n, r, o, i, s, a) {
      if (s == 0 || s == e.width) return false;
      let l = false;
      for (let c2 = o; c2 < i; c2++) {
        const u = c2 * e.width + s, d = e.map[u];
        if (e.map[u - 1] == d) {
          l = true;
          const p2 = n.nodeAt(d), f = e.colCount(d), h2 = t2.mapping.slice(a).map(d + r);
          t2.setNodeMarkup(
            h2,
            null,
            uo(
              p2.attrs,
              s - f,
              p2.attrs.colspan - (s - f)
            )
          ), t2.insert(
            h2 + p2.nodeSize,
            p2.type.createAndFill(
              uo(p2.attrs, 0, s - f)
            )
          ), c2 += p2.attrs.rowspan - 1;
        }
      }
      return l;
    }
    function Cp(t2, e, n, r, o) {
      let i = n ? t2.doc.nodeAt(n - 1) : t2.doc;
      if (!i)
        throw new Error("No table found");
      let s = ut.get(i);
      const { top: a, left: l } = r, c2 = l + o.width, u = a + o.height, d = t2.tr;
      let p2 = 0;
      function f() {
        if (i = n ? d.doc.nodeAt(n - 1) : d.doc, !i)
          throw new Error("No table found");
        s = ut.get(i), p2 = d.mapping.maps.length;
      }
      dT(d, s, i, n, c2, u, p2) && f(), _p(d, s, i, n, l, c2, a, p2) && f(), _p(d, s, i, n, l, c2, u, p2) && f(), Sp(d, s, i, n, a, u, l, p2) && f(), Sp(d, s, i, n, a, u, c2, p2) && f();
      for (let h2 = a; h2 < u; h2++) {
        const m = s.positionAt(h2, l, i), g = s.positionAt(h2, c2, i);
        d.replace(
          d.mapping.slice(p2).map(m + n),
          d.mapping.slice(p2).map(g + n),
          new K(o.rows[h2 - a], 0, 0)
        );
      }
      f(), d.setSelection(
        new Ye(
          d.doc.resolve(n + s.positionAt(a, l, i)),
          d.doc.resolve(n + s.positionAt(u - 1, c2 - 1, i))
        )
      ), e(d);
    }
    var pT = $c({
      ArrowLeft: ls("horiz", -1),
      ArrowRight: ls("horiz", 1),
      ArrowUp: ls("vert", -1),
      ArrowDown: ls("vert", 1),
      "Shift-ArrowLeft": cs("horiz", -1),
      "Shift-ArrowRight": cs("horiz", 1),
      "Shift-ArrowUp": cs("vert", -1),
      "Shift-ArrowDown": cs("vert", 1),
      Backspace: as,
      "Mod-Backspace": as,
      Delete: as,
      "Mod-Delete": as
    });
    function Ns(t2, e, n) {
      return n.eq(t2.selection) ? false : (e && e(t2.tr.setSelection(n).scrollIntoView()), true);
    }
    function ls(t2, e) {
      return (n, r, o) => {
        if (!o) return false;
        const i = n.selection;
        if (i instanceof Ye)
          return Ns(
            n,
            r,
            ue.near(i.$headCell, e)
          );
        if (t2 != "horiz" && !i.empty) return false;
        const s = Km(o, t2, e);
        if (s == null) return false;
        if (t2 == "horiz")
          return Ns(
            n,
            r,
            ue.near(n.doc.resolve(i.head + e), e)
          );
        {
          const a = n.doc.resolve(s), l = $m(a, t2, e);
          let c2;
          return l ? c2 = ue.near(l, 1) : e < 0 ? c2 = ue.near(n.doc.resolve(a.before(-1)), -1) : c2 = ue.near(n.doc.resolve(a.after(-1)), 1), Ns(n, r, c2);
        }
      };
    }
    function cs(t2, e) {
      return (n, r, o) => {
        if (!o) return false;
        const i = n.selection;
        let s;
        if (i instanceof Ye)
          s = i;
        else {
          const l = Km(o, t2, e);
          if (l == null) return false;
          s = new Ye(n.doc.resolve(l));
        }
        const a = $m(s.$headCell, t2, e);
        return a ? Ns(
          n,
          r,
          new Ye(s.$anchorCell, a)
        ) : false;
      };
    }
    function fT(t2, e) {
      const n = t2.state.doc, r = Ko(n.resolve(e));
      return r ? (t2.dispatch(t2.state.tr.setSelection(new Ye(r))), true) : false;
    }
    function hT(t2, e, n) {
      if (!Bn(t2.state)) return false;
      let r = lT(n);
      const o = t2.state.selection;
      if (o instanceof Ye) {
        r || (r = {
          width: 1,
          height: 1,
          rows: [
            R.from(
              fc(Ht(t2.state.schema).cell, n)
            )
          ]
        });
        const i = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), a = ut.get(i).rectBetween(
          o.$anchorCell.pos - s,
          o.$headCell.pos - s
        );
        return r = uT(r, a.right - a.left, a.bottom - a.top), Cp(t2.state, t2.dispatch, s, a, r), true;
      } else if (r) {
        const i = Ka(t2.state), s = i.start(-1);
        return Cp(
          t2.state,
          t2.dispatch,
          s,
          ut.get(i.node(-1)).findCell(i.pos - s),
          r
        ), true;
      } else
        return false;
    }
    function mT(t2, e) {
      var n;
      if (e.ctrlKey || e.metaKey) return;
      const r = xp(t2, e.target);
      let o;
      if (e.shiftKey && t2.state.selection instanceof Ye)
        i(t2.state.selection.$anchorCell, e), e.preventDefault();
      else if (e.shiftKey && r && (o = Ko(t2.state.selection.$anchor)) != null && ((n = Cl(t2, e)) == null ? void 0 : n.pos) != o.pos)
        i(o, e), e.preventDefault();
      else if (!r)
        return;
      function i(l, c2) {
        let u = Cl(t2, c2);
        const d = Cr.getState(t2.state) == null;
        if (!u || !du(l, u))
          if (d) u = l;
          else return;
        const p2 = new Ye(l, u);
        if (d || !t2.state.selection.eq(p2)) {
          const f = t2.state.tr.setSelection(p2);
          d && f.setMeta(Cr, l.pos), t2.dispatch(f);
        }
      }
      function s() {
        t2.root.removeEventListener("mouseup", s), t2.root.removeEventListener("dragstart", s), t2.root.removeEventListener("mousemove", a), Cr.getState(t2.state) != null && t2.dispatch(t2.state.tr.setMeta(Cr, -1));
      }
      function a(l) {
        const c2 = l, u = Cr.getState(t2.state);
        let d;
        if (u != null)
          d = t2.state.doc.resolve(u);
        else if (xp(t2, c2.target) != r && (d = Cl(t2, e), !d))
          return s();
        d && i(d, c2);
      }
      t2.root.addEventListener("mouseup", s), t2.root.addEventListener("dragstart", s), t2.root.addEventListener("mousemove", a);
    }
    function Km(t2, e, n) {
      if (!(t2.state.selection instanceof ie)) return null;
      const { $head: r } = t2.state.selection;
      for (let o = r.depth - 1; o >= 0; o--) {
        const i = r.node(o);
        if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)) return null;
        if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
          const a = r.before(o), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
          return t2.endOfTextblock(l) ? a : null;
        }
      }
      return null;
    }
    function xp(t2, e) {
      for (; e && e != t2.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
          return e;
      return null;
    }
    function Cl(t2, e) {
      const n = t2.posAtCoords({
        left: e.clientX,
        top: e.clientY
      });
      return n && n ? Ko(t2.state.doc.resolve(n.pos)) : null;
    }
    var gT = class {
      constructor(e, n) {
        this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
          "--default-cell-min-width",
          `${n}px`
        ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), hc(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type != this.node.type ? false : (this.node = e, hc(
          e,
          this.colgroup,
          this.table,
          this.defaultCellMinWidth
        ), true);
      }
      ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
      }
    };
    function hc(t2, e, n, r, o, i) {
      var s;
      let a = 0, l = true, c2 = e.firstChild;
      const u = t2.firstChild;
      if (u) {
        for (let d = 0, p2 = 0; d < u.childCount; d++) {
          const { colspan: f, colwidth: h2 } = u.child(d).attrs;
          for (let m = 0; m < f; m++, p2++) {
            const g = o == p2 ? i : h2 && h2[m], b = g ? g + "px" : "";
            if (a += g || r, g || (l = false), c2)
              c2.style.width != b && (c2.style.width = b), c2 = c2.nextSibling;
            else {
              const E = document.createElement("col");
              E.style.width = b, e.appendChild(E);
            }
          }
        }
        for (; c2; ) {
          const d = c2.nextSibling;
          (s = c2.parentNode) == null || s.removeChild(c2), c2 = d;
        }
        l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
      }
    }
    var dn = new Je(
      "tableColumnResizing"
    );
    function bT({
      handleWidth: t2 = 5,
      cellMinWidth: e = 25,
      defaultCellMinWidth: n = 100,
      View: r = gT,
      lastColumnResizable: o = true
    } = {}) {
      const i = new Ue({
        key: dn,
        state: {
          init(s, a) {
            var l, c2;
            const u = (c2 = (l = i.spec) == null ? void 0 : l.props) == null ? void 0 : c2.nodeViews, d = Ht(a.schema).table.name;
            return r && u && (u[d] = (p2, f) => new r(p2, n, f)), new yT(-1, false);
          },
          apply(s, a) {
            return a.apply(s);
          }
        },
        props: {
          attributes: (s) => {
            const a = dn.getState(s);
            return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
          },
          handleDOMEvents: {
            mousemove: (s, a) => {
              vT(s, a, t2, o);
            },
            mouseleave: (s) => {
              ET(s);
            },
            mousedown: (s, a) => {
              kT(s, a, e, n);
            }
          },
          decorations: (s) => {
            const a = dn.getState(s);
            if (a && a.activeHandle > -1)
              return xT(s, a.activeHandle);
          },
          nodeViews: {}
        }
      });
      return i;
    }
    var yT = class As {
      constructor(e, n) {
        this.activeHandle = e, this.dragging = n;
      }
      apply(e) {
        const n = this, r = e.getMeta(dn);
        if (r && r.setHandle != null)
          return new As(r.setHandle, false);
        if (r && r.setDragging !== void 0)
          return new As(n.activeHandle, r.setDragging);
        if (n.activeHandle > -1 && e.docChanged) {
          let o = e.mapping.map(n.activeHandle, -1);
          return pc(e.doc.resolve(o)) || (o = -1), new As(o, n.dragging);
        }
        return n;
      }
    };
    function vT(t2, e, n, r) {
      if (!t2.editable) return;
      const o = dn.getState(t2.state);
      if (o && !o.dragging) {
        const i = _T(e.target);
        let s = -1;
        if (i) {
          const { left: a, right: l } = i.getBoundingClientRect();
          e.clientX - a <= n ? s = Tp(t2, e, "left", n) : l - e.clientX <= n && (s = Tp(t2, e, "right", n));
        }
        if (s != o.activeHandle) {
          if (!r && s !== -1) {
            const a = t2.state.doc.resolve(s), l = a.node(-1), c2 = ut.get(l), u = a.start(-1);
            if (c2.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c2.width - 1)
              return;
          }
          qm(t2, s);
        }
      }
    }
    function ET(t2) {
      if (!t2.editable) return;
      const e = dn.getState(t2.state);
      e && e.activeHandle > -1 && !e.dragging && qm(t2, -1);
    }
    function kT(t2, e, n, r) {
      var o;
      if (!t2.editable) return false;
      const i = (o = t2.dom.ownerDocument.defaultView) != null ? o : window, s = dn.getState(t2.state);
      if (!s || s.activeHandle == -1 || s.dragging)
        return false;
      const a = t2.state.doc.nodeAt(s.activeHandle), l = wT(t2, s.activeHandle, a.attrs);
      t2.dispatch(
        t2.state.tr.setMeta(dn, {
          setDragging: { startX: e.clientX, startWidth: l }
        })
      );
      function c2(d) {
        i.removeEventListener("mouseup", c2), i.removeEventListener("mousemove", u);
        const p2 = dn.getState(t2.state);
        p2 != null && p2.dragging && (ST(
          t2,
          p2.activeHandle,
          Op(p2.dragging, d, n)
        ), t2.dispatch(
          t2.state.tr.setMeta(dn, { setDragging: null })
        ));
      }
      function u(d) {
        if (!d.which) return c2(d);
        const p2 = dn.getState(t2.state);
        if (p2 && p2.dragging) {
          const f = Op(p2.dragging, d, n);
          Np(
            t2,
            p2.activeHandle,
            f,
            r
          );
        }
      }
      return Np(
        t2,
        s.activeHandle,
        l,
        r
      ), i.addEventListener("mouseup", c2), i.addEventListener("mousemove", u), e.preventDefault(), true;
    }
    function wT(t2, e, { colspan: n, colwidth: r }) {
      const o = r && r[r.length - 1];
      if (o) return o;
      const i = t2.domAtPos(e);
      let a = i.node.childNodes[i.offset].offsetWidth, l = n;
      if (r)
        for (let c2 = 0; c2 < n; c2++)
          r[c2] && (a -= r[c2], l--);
      return a / l;
    }
    function _T(t2) {
      for (; t2 && t2.nodeName != "TD" && t2.nodeName != "TH"; )
        t2 = t2.classList && t2.classList.contains("ProseMirror") ? null : t2.parentNode;
      return t2;
    }
    function Tp(t2, e, n, r) {
      const o = n == "right" ? -r : r, i = t2.posAtCoords({
        left: e.clientX + o,
        top: e.clientY
      });
      if (!i) return -1;
      const { pos: s } = i, a = Ko(t2.state.doc.resolve(s));
      if (!a) return -1;
      if (n == "right") return a.pos;
      const l = ut.get(a.node(-1)), c2 = a.start(-1), u = l.map.indexOf(a.pos - c2);
      return u % l.width == 0 ? -1 : c2 + l.map[u - 1];
    }
    function Op(t2, e, n) {
      const r = e.clientX - t2.startX;
      return Math.max(n, t2.startWidth + r);
    }
    function qm(t2, e) {
      t2.dispatch(
        t2.state.tr.setMeta(dn, { setHandle: e })
      );
    }
    function ST(t2, e, n) {
      const r = t2.state.doc.resolve(e), o = r.node(-1), i = ut.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = t2.state.tr;
      for (let c2 = 0; c2 < i.height; c2++) {
        const u = c2 * i.width + a;
        if (c2 && i.map[u] == i.map[u - i.width]) continue;
        const d = i.map[u], p2 = o.nodeAt(d).attrs, f = p2.colspan == 1 ? 0 : a - i.colCount(d);
        if (p2.colwidth && p2.colwidth[f] == n) continue;
        const h2 = p2.colwidth ? p2.colwidth.slice() : CT(p2.colspan);
        h2[f] = n, l.setNodeMarkup(s + d, null, { ...p2, colwidth: h2 });
      }
      l.docChanged && t2.dispatch(l);
    }
    function Np(t2, e, n, r) {
      const o = t2.state.doc.resolve(e), i = o.node(-1), s = o.start(-1), a = ut.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
      let l = t2.domAtPos(o.start(-1)).node;
      for (; l && l.nodeName != "TABLE"; )
        l = l.parentNode;
      l && hc(
        i,
        l.firstChild,
        l,
        r,
        a,
        n
      );
    }
    function CT(t2) {
      return Array(t2).fill(0);
    }
    function xT(t2, e) {
      var n;
      const r = [], o = t2.doc.resolve(e), i = o.node(-1);
      if (!i)
        return He.empty;
      const s = ut.get(i), a = o.start(-1), l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
      for (let c2 = 0; c2 < s.height; c2++) {
        const u = l + c2 * s.width;
        if ((l == s.width - 1 || s.map[u] != s.map[u + 1]) && (c2 == 0 || s.map[u] != s.map[u - s.width])) {
          const d = s.map[u], p2 = a + d + i.nodeAt(d).nodeSize - 1, f = document.createElement("div");
          f.className = "column-resize-handle", (n = dn.getState(t2)) != null && n.dragging && r.push(
            ht.node(
              a + d,
              a + d + i.nodeAt(d).nodeSize,
              {
                class: "column-resize-dragging"
              }
            )
          ), r.push(ht.widget(p2, f));
        }
      }
      return He.create(t2.doc, r);
    }
    function TT({
      allowTableNodeSelection: t2 = false
    } = {}) {
      return new Ue({
        key: Cr,
        // This piece of state is used to remember when a mouse-drag
        // cell-selection is happening, so that it can continue even as
        // transactions (which might move its anchor cell) come in.
        state: {
          init() {
            return null;
          },
          apply(e, n) {
            const r = e.getMeta(Cr);
            if (r != null) return r == -1 ? null : r;
            if (n == null || !e.docChanged) return n;
            const { deleted: o, pos: i } = e.mapping.mapResult(n);
            return o ? null : i;
          }
        },
        props: {
          decorations: zx,
          handleDOMEvents: {
            mousedown: mT
          },
          createSelectionBetween(e) {
            return Cr.getState(e.state) != null ? e.state.selection : null;
          },
          handleTripleClick: fT,
          handleKeyDown: pT,
          handlePaste: hT
        },
        appendTransaction(e, n, r) {
          return Vx(
            r,
            Um(r, n),
            t2
          );
        }
      });
    }
    function mc(t2, e) {
      return e ? ["width", `${Math.max(e, t2)}px`] : ["min-width", `${t2}px`];
    }
    function Ap(t2, e, n, r, o, i) {
      var s;
      let a = 0, l = true, c2 = e.firstChild;
      const u = t2.firstChild;
      if (u !== null)
        for (let d = 0, p2 = 0; d < u.childCount; d += 1) {
          const { colspan: f, colwidth: h2 } = u.child(d).attrs;
          for (let m = 0; m < f; m += 1, p2 += 1) {
            const g = o === p2 ? i : h2 && h2[m], b = g ? `${g}px` : "";
            if (a += g || r, g || (l = false), c2) {
              if (c2.style.width !== b) {
                const [E, _] = mc(r, g);
                c2.style.setProperty(E, _);
              }
              c2 = c2.nextSibling;
            } else {
              const E = document.createElement("col"), [_, v] = mc(r, g);
              E.style.setProperty(_, v), e.appendChild(E);
            }
          }
        }
      for (; c2; ) {
        const d = c2.nextSibling;
        (s = c2.parentNode) === null || s === void 0 || s.removeChild(c2), c2 = d;
      }
      l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
    }
    class OT {
      constructor(e, n) {
        this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Ap(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, Ap(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    function NT(t2, e, n, r) {
      let o = 0, i = true;
      const s = [], a = t2.firstChild;
      if (!a)
        return {};
      for (let d = 0, p2 = 0; d < a.childCount; d += 1) {
        const { colspan: f, colwidth: h2 } = a.child(d).attrs;
        for (let m = 0; m < f; m += 1, p2 += 1) {
          const g = n === p2 ? r : h2 && h2[m];
          o += g || e, g || (i = false);
          const [b, E] = mc(e, g);
          s.push([
            "col",
            { style: `${b}: ${E}` }
          ]);
        }
      }
      const l = i ? `${o}px` : "", c2 = i ? "" : `${o}px`;
      return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c2 };
    }
    function Mp(t2, e) {
      return t2.createAndFill();
    }
    function AT(t2) {
      if (t2.cached.tableNodeTypes)
        return t2.cached.tableNodeTypes;
      const e = {};
      return Object.keys(t2.nodes).forEach((n) => {
        const r = t2.nodes[n];
        r.spec.tableRole && (e[r.spec.tableRole] = r);
      }), t2.cached.tableNodeTypes = e, e;
    }
    function Gm(t2, e, n, r, o) {
      const i = AT(t2), s = [], a = [];
      for (let c2 = 0; c2 < n; c2 += 1) {
        const u = Mp(i.cell);
        if (u && a.push(u), r) {
          const d = Mp(i.header_cell);
          d && s.push(d);
        }
      }
      const l = [];
      for (let c2 = 0; c2 < e; c2 += 1)
        l.push(i.row.createChecked(null, r && c2 === 0 ? s : a));
      return i.table.createChecked(null, l);
    }
    function MT(t2) {
      return t2 instanceof Ye;
    }
    const us = ({ editor: t2 }) => {
      const { selection: e } = t2.state;
      if (!MT(e))
        return false;
      let n = 0;
      const r = Uh(e.ranges[0].$from, (i) => i.type.name === "table");
      return r == null || r.node.descendants((i) => {
        if (i.type.name === "table")
          return false;
        ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
      }), n === e.ranges.length ? (t2.commands.deleteTable(), true) : false;
    }, jm = it.create({
      name: "table",
      // @ts-ignore
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: false,
          handleWidth: 5,
          cellMinWidth: 25,
          // TODO: fix
          View: OT,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      content: "tableRow+",
      tableRole: "table",
      isolating: true,
      group: "block",
      parseHTML() {
        return [{ tag: "table" }];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        const { colgroup: n, tableWidth: r, tableMinWidth: o } = NT(t2, this.options.cellMinWidth);
        return [
          "table",
          Be(this.options.HTMLAttributes, e, {
            style: r ? `width: ${r}` : `min-width: ${o}`
          }),
          n,
          ["tbody", 0]
        ];
      },
      addCommands() {
        return {
          insertTable: ({ rows: t2 = 3, cols: e = 3, withHeaderRow: n = true } = {}) => ({ tr: r, dispatch: o, editor: i }) => {
            const s = Gm(i.schema, t2, e, n);
            if (o) {
              const a = r.selection.from + 1;
              r.replaceSelectionWith(s).scrollIntoView().setSelection(ie.near(r.doc.resolve(a)));
            }
            return true;
          },
          addColumnBefore: () => ({ state: t2, dispatch: e }) => qx(t2, e),
          addColumnAfter: () => ({ state: t2, dispatch: e }) => Gx(t2, e),
          deleteColumn: () => ({ state: t2, dispatch: e }) => Yx(t2, e),
          addRowBefore: () => ({ state: t2, dispatch: e }) => Xx(t2, e),
          addRowAfter: () => ({ state: t2, dispatch: e }) => Zx(t2, e),
          deleteRow: () => ({ state: t2, dispatch: e }) => eT(t2, e),
          deleteTable: () => ({ state: t2, dispatch: e }) => aT(t2, e),
          mergeCells: () => ({ state: t2, dispatch: e }) => vp(t2, e),
          splitCell: () => ({ state: t2, dispatch: e }) => Ep(t2, e),
          toggleHeaderColumn: () => ({ state: t2, dispatch: e }) => Mi("column")(t2, e),
          toggleHeaderRow: () => ({ state: t2, dispatch: e }) => Mi("row")(t2, e),
          toggleHeaderCell: () => ({ state: t2, dispatch: e }) => iT(t2, e),
          mergeOrSplit: () => ({ state: t2, dispatch: e }) => vp(t2, e) ? true : Ep(t2, e),
          setCellAttribute: (t2, e) => ({ state: n, dispatch: r }) => rT(t2, e)(n, r),
          goToNextCell: () => ({ state: t2, dispatch: e }) => wp(1)(t2, e),
          goToPreviousCell: () => ({ state: t2, dispatch: e }) => wp(-1)(t2, e),
          fixTables: () => ({ state: t2, dispatch: e }) => (e && Um(t2), true),
          setCellSelection: (t2) => ({ tr: e, dispatch: n }) => {
            if (n) {
              const r = Ye.create(e.doc, t2.anchorCell, t2.headCell);
              e.setSelection(r);
            }
            return true;
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          Tab: () => this.editor.commands.goToNextCell() ? true : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : false,
          "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
          Backspace: us,
          "Mod-Backspace": us,
          Delete: us,
          "Mod-Delete": us
        };
      },
      addProseMirrorPlugins() {
        return [
          ...this.options.resizable && this.editor.isEditable ? [
            bT({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              View: this.options.View,
              lastColumnResizable: this.options.lastColumnResizable
            })
          ] : [],
          TT({
            allowTableNodeSelection: this.options.allowTableNodeSelection
          })
        ];
      },
      extendNodeSchema(t2) {
        const e = {
          name: t2.name,
          options: t2.options,
          storage: t2.storage
        };
        return {
          tableRole: Te(Z(t2, "tableRole", e))
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function Rp(t2, e, n, r, o, i) {
      let s = 0, a = true, l = e.firstChild;
      const c2 = t2.firstChild;
      for (let u = 0, d = 0; u < c2.childCount; u += 1) {
        const { colspan: p2, colwidth: f } = c2.child(u).attrs;
        for (let h2 = 0; h2 < p2; h2 += 1, d += 1) {
          const m = o === d ? i : f && f[h2], g = m ? `${m}px` : "";
          if (s += m || r, m || (a = false), l)
            l.style.width !== g && (l.style.width = g), l = l.nextSibling;
          else {
            const b = document.createElement("col");
            b.className = `col-${d}`, e.appendChild(b).style.width = g;
          }
        }
      }
      for (; l; ) {
        const u = l.nextSibling;
        l.parentNode.removeChild(l), l = u;
      }
      a ? (n.style.width = `${s}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${s}px`);
    }
    class RT {
      constructor(e, n, r) {
        this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Rp(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        );
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, Rp(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    const IT = jm.extend({
      addOptions() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          HTMLAttributes: {},
          resizable: true,
          handleWidth: 5,
          cellMinWidth: 25,
          View: RT,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      addCommands() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          insertTable: (e) => ({ editor: n, commands: r, tr: o, dispatch: i }) => {
            const { rows: s = 3, cols: a = 3, withHeaderRow: l = true } = e || {}, c2 = Gm(n.schema, s, a, l);
            if (i) {
              const u = o.selection.anchor + 1;
              r.insertContent({
                type: "table-wrapper",
                content: [c2.toJSON()]
              }), o.scrollIntoView().setSelection(
                ie.near(o.doc.resolve(u))
              );
            }
            return true;
          },
          deleteTable: () => ({ state: e, dispatch: n }) => {
            const r = e.selection.$anchor;
            for (let o = r.depth; o > 0; o--)
              if (r.node(o).type.name === "table-wrapper")
                return n && n(
                  e.tr.delete(r.before(o), r.after(o)).scrollIntoView()
                ), true;
            return false;
          },
          selectRow: (e) => ({ tr: n, dispatch: r }) => {
            if (r) {
              const o = n.doc.resolve(e), i = Ye.rowSelection(o);
              n.setSelection(i);
            }
            return true;
          },
          selectColumn: (e) => ({ tr: n, dispatch: r }) => {
            if (r) {
              const o = n.doc.resolve(e), i = Ye.colSelection(o);
              n.setSelection(i);
            }
            return true;
          }
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function DT({
      node: t2,
      types: e
    }) {
      return Array.isArray(e) && e.includes(t2.type) || t2.type === e;
    }
    function ds({
      node: t2,
      types: e
    }) {
      return t2 ? !DT({ node: t2, types: e }) : false;
    }
    const LT = Ke.create({
      name: "trailingNode",
      addOptions() {
        return {
          node: "paragraph",
          notAfter: ["paragraph"]
        };
      },
      addProseMirrorPlugins() {
        const t2 = new Je(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
        return [
          new Ue({
            key: t2,
            appendTransaction: (n, r, o) => {
              const { doc: i, tr: s, schema: a } = o, l = t2.getState(o), c2 = i.content.size, u = a.nodes[this.options.node];
              if (!(!l || !u))
                return s.insert(c2, u.create());
            },
            state: {
              init: (n, r) => {
                const o = r.tr.doc.lastChild, i = (o == null ? void 0 : o.firstChild) ?? null;
                return ds({ node: o, types: e }) || ds({ node: i, types: e });
              },
              apply: (n, r) => {
                var s;
                if (!n.docChanged) return r;
                const o = n.doc.lastChild, i = ((s = n.doc.lastChild) == null ? void 0 : s.firstChild) ?? null;
                return ds({ node: o, types: e }) || ds({ node: i, types: e });
              }
            }
          })
        ];
      }
    }), PT = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, r) => (openBlock(), createBlock(unref(mr), mergeProps(e, { class: "o-blockquote-view" }), {
          default: withCtx(() => [
            createBaseVNode("blockquote", null, [
              createVNode(unref(hr))
            ])
          ]),
          _: 1
        }, 16));
      }
    }), BT = ym.extend({
      draggable: true,
      addNodeView() {
        return Ln(PT);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const $T = it.create({
      name: "callout",
      group: "block",
      content: "block+",
      draggable: true,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return {
          icon: {
            default: "🌾"
          },
          borderColor: {
            default: "#dddddd"
          },
          borderColorDark: {
            default: "#333333"
          },
          backColor: {
            default: "#eeeeee"
          },
          backColorDark: {
            default: "rgba(101, 117, 133, 0.16)"
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: 'div[data-type="callout"]'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return [
          "div",
          Be(t2, { "data-type": "callout" }),
          0
        ];
      },
      addCommands() {
        return {
          setCallout: () => ({ commands: t2 }) => t2.wrapIn(this.name),
          toggleCallout: () => ({ commands: t2 }) => t2.toggleWrap(this.name),
          unsetCallout: () => ({ commands: t2 }) => t2.lift(this.name)
        };
      }
    }), FT = { class: "callout-container" }, zT = { class: "callout-icon" }, HT = { class: "callout-content" }, UT = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { theme: n } = Va(), r = ref(false), o = ref(false), i = ref({}), s = computed(() => {
          e.editor.isActive("callout");
          const { selection: g } = e.editor.view.state, b = g.from, E = e.getPos(), _ = E + e.node.nodeSize;
          return b >= E && b <= _;
        });
        computed(() => e.node.attrs);
        const a = computed({
          get() {
            return e.node.attrs.backColor;
          },
          set(g) {
            e.updateAttributes({ backColor: g });
          }
        }), l = computed({
          get() {
            return e.node.attrs.backColorDark;
          },
          set(g) {
            e.updateAttributes({ backColorDark: g });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.borderColor;
          },
          set(g) {
            console.log("action", g), e.updateAttributes({ borderColor: g });
          }
        }), u = computed({
          get() {
            return e.node.attrs.borderColorDark;
          },
          set(g) {
            e.updateAttributes({ borderColorDark: g });
          }
        }), d = computed(() => n.value === "dark" ? l.value : a.value), p2 = computed(() => n.value === "dark" ? u.value : c2.value);
        function f(g) {
          switch (r.value = false, g.value) {
            case "palette":
              m(true);
              break;
          }
        }
        function h2(g) {
          r.value = true, i.value = g;
        }
        function m(g) {
          o.value = g;
        }
        return watch(s, (g) => {
          console.log("isFocused", e.node.attrs), m(g);
        }), (g, b) => (openBlock(), createBlock(unref(mr), mergeProps(e, {
          class: "o-callout-view",
          style: `--callout-border-color: ${p2.value}; --callout-back-color: ${d.value}`,
          onContextmenu: withModifiers(h2, ["prevent"])
        }), {
          default: withCtx(() => [
            createBaseVNode("div", FT, [
              createBaseVNode("div", zT, toDisplayString(g.node.attrs.icon), 1),
              createBaseVNode("div", HT, [
                createVNode(unref(hr))
              ]),
              createVNode(unref(au), {
                modelValue: r.value,
                "onUpdate:modelValue": b[0] || (b[0] = (E) => r.value = E),
                event: i.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Wo), mergeProps(e, { onAction: f }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ])
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), VT = $T.extend({
      addNodeView() {
        return Ln(UT);
      }
    });
    function WT(t2) {
      return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
    }
    function Ym(t2) {
      return t2 instanceof Map ? t2.clear = t2.delete = t2.set = function() {
        throw new Error("map is read-only");
      } : t2 instanceof Set && (t2.add = t2.clear = t2.delete = function() {
        throw new Error("set is read-only");
      }), Object.freeze(t2), Object.getOwnPropertyNames(t2).forEach((e) => {
        const n = t2[e], r = typeof n;
        (r === "object" || r === "function") && !Object.isFrozen(n) && Ym(n);
      }), t2;
    }
    class Ip {
      /**
       * @param {CompiledMode} mode
       */
      constructor(e) {
        e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function Jm(t2) {
      return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function Ar(t2, ...e) {
      const n = /* @__PURE__ */ Object.create(null);
      for (const r in t2)
        n[r] = t2[r];
      return e.forEach(function(r) {
        for (const o in r)
          n[o] = r[o];
      }), /** @type {T} */
      n;
    }
    const KT = "</span>", Dp = (t2) => !!t2.scope, qT = (t2, { prefix: e }) => {
      if (t2.startsWith("language:"))
        return t2.replace("language:", "language-");
      if (t2.includes(".")) {
        const n = t2.split(".");
        return [
          `${e}${n.shift()}`,
          ...n.map((r, o) => `${r}${"_".repeat(o + 1)}`)
        ].join(" ");
      }
      return `${e}${t2}`;
    };
    class GT {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(e, n) {
        this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(e) {
        this.buffer += Jm(e);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(e) {
        if (!Dp(e)) return;
        const n = qT(
          e.scope,
          { prefix: this.classPrefix }
        );
        this.span(n);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(e) {
        Dp(e) && (this.buffer += KT);
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(e) {
        this.buffer += `<span class="${e}">`;
      }
    }
    const Lp = (t2 = {}) => {
      const e = { children: [] };
      return Object.assign(e, t2), e;
    };
    class pu {
      constructor() {
        this.rootNode = Lp(), this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(e) {
        this.top.children.push(e);
      }
      /** @param {string} scope */
      openNode(e) {
        const n = Lp({ scope: e });
        this.add(n), this.stack.push(n);
      }
      closeNode() {
        if (this.stack.length > 1)
          return this.stack.pop();
      }
      closeAllNodes() {
        for (; this.closeNode(); ) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(e) {
        return this.constructor._walk(e, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(e, n) {
        return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
      }
      /**
       * @param {Node} node
       */
      static _collapse(e) {
        typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
          pu._collapse(n);
        }));
      }
    }
    class jT extends pu {
      /**
       * @param {*} options
       */
      constructor(e) {
        super(), this.options = e;
      }
      /**
       * @param {string} text
       */
      addText(e) {
        e !== "" && this.add(e);
      }
      /** @param {string} scope */
      startScope(e) {
        this.openNode(e);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(e, n) {
        const r = e.root;
        n && (r.scope = `language:${n}`), this.add(r);
      }
      toHTML() {
        return new GT(this, this.options).value();
      }
      finalize() {
        return this.closeAllNodes(), true;
      }
    }
    function Ri(t2) {
      return t2 ? typeof t2 == "string" ? t2 : t2.source : null;
    }
    function Xm(t2) {
      return mo("(?=", t2, ")");
    }
    function YT(t2) {
      return mo("(?:", t2, ")*");
    }
    function JT(t2) {
      return mo("(?:", t2, ")?");
    }
    function mo(...t2) {
      return t2.map((n) => Ri(n)).join("");
    }
    function XT(t2) {
      const e = t2[t2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (t2.splice(t2.length - 1, 1), e) : {};
    }
    function fu(...t2) {
      return "(" + (XT(t2).capture ? "" : "?:") + t2.map((r) => Ri(r)).join("|") + ")";
    }
    function Zm(t2) {
      return new RegExp(t2.toString() + "|").exec("").length - 1;
    }
    function ZT(t2, e) {
      const n = t2 && t2.exec(e);
      return n && n.index === 0;
    }
    const QT = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function hu(t2, { joinWith: e }) {
      let n = 0;
      return t2.map((r) => {
        n += 1;
        const o = n;
        let i = Ri(r), s = "";
        for (; i.length > 0; ) {
          const a = QT.exec(i);
          if (!a) {
            s += i;
            break;
          }
          s += i.substring(0, a.index), i = i.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + o) : (s += a[0], a[0] === "(" && n++);
        }
        return s;
      }).map((r) => `(${r})`).join(e);
    }
    const e1 = /\b\B/, Qm = "[a-zA-Z]\\w*", mu = "[a-zA-Z_]\\w*", eg = "\\b\\d+(\\.\\d+)?", tg = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", ng = "\\b(0b[01]+)", t1 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", n1 = (t2 = {}) => {
      const e = /^#![ ]*\//;
      return t2.binary && (t2.begin = mo(
        e,
        /.*\b/,
        t2.binary,
        /\b.*/
      )), Ar({
        scope: "meta",
        begin: e,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (n, r) => {
          n.index !== 0 && r.ignoreMatch();
        }
      }, t2);
    }, Ii = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    }, r1 = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [Ii]
    }, o1 = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [Ii]
    }, i1 = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    }, qa = function(t2, e, n = {}) {
      const r = Ar(
        {
          scope: "comment",
          begin: t2,
          end: e,
          contains: []
        },
        n
      );
      r.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const o = fu(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      return r.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: mo(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            o,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      ), r;
    }, s1 = qa("//", "$"), a1 = qa("/\\*", "\\*/"), l1 = qa("#", "$"), c1 = {
      scope: "number",
      begin: eg,
      relevance: 0
    }, u1 = {
      scope: "number",
      begin: tg,
      relevance: 0
    }, d1 = {
      scope: "number",
      begin: ng,
      relevance: 0
    }, p1 = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        Ii,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [Ii]
        }
      ]
    }, f1 = {
      scope: "title",
      begin: Qm,
      relevance: 0
    }, h1 = {
      scope: "title",
      begin: mu,
      relevance: 0
    }, m1 = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + mu,
      relevance: 0
    }, g1 = function(t2) {
      return Object.assign(
        t2,
        {
          /** @type {ModeCallback} */
          "on:begin": (e, n) => {
            n.data._beginMatch = e[1];
          },
          /** @type {ModeCallback} */
          "on:end": (e, n) => {
            n.data._beginMatch !== e[1] && n.ignoreMatch();
          }
        }
      );
    };
    var ps = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE: r1,
      BACKSLASH_ESCAPE: Ii,
      BINARY_NUMBER_MODE: d1,
      BINARY_NUMBER_RE: ng,
      COMMENT: qa,
      C_BLOCK_COMMENT_MODE: a1,
      C_LINE_COMMENT_MODE: s1,
      C_NUMBER_MODE: u1,
      C_NUMBER_RE: tg,
      END_SAME_AS_BEGIN: g1,
      HASH_COMMENT_MODE: l1,
      IDENT_RE: Qm,
      MATCH_NOTHING_RE: e1,
      METHOD_GUARD: m1,
      NUMBER_MODE: c1,
      NUMBER_RE: eg,
      PHRASAL_WORDS_MODE: i1,
      QUOTE_STRING_MODE: o1,
      REGEXP_MODE: p1,
      RE_STARTERS_RE: t1,
      SHEBANG: n1,
      TITLE_MODE: f1,
      UNDERSCORE_IDENT_RE: mu,
      UNDERSCORE_TITLE_MODE: h1
    });
    function b1(t2, e) {
      t2.input[t2.index - 1] === "." && e.ignoreMatch();
    }
    function y1(t2, e) {
      t2.className !== void 0 && (t2.scope = t2.className, delete t2.className);
    }
    function v1(t2, e) {
      e && t2.beginKeywords && (t2.begin = "\\b(" + t2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t2.__beforeBegin = b1, t2.keywords = t2.keywords || t2.beginKeywords, delete t2.beginKeywords, t2.relevance === void 0 && (t2.relevance = 0));
    }
    function E1(t2, e) {
      Array.isArray(t2.illegal) && (t2.illegal = fu(...t2.illegal));
    }
    function k1(t2, e) {
      if (t2.match) {
        if (t2.begin || t2.end) throw new Error("begin & end are not supported with match");
        t2.begin = t2.match, delete t2.match;
      }
    }
    function w1(t2, e) {
      t2.relevance === void 0 && (t2.relevance = 1);
    }
    const _1 = (t2, e) => {
      if (!t2.beforeMatch) return;
      if (t2.starts) throw new Error("beforeMatch cannot be used with starts");
      const n = Object.assign({}, t2);
      Object.keys(t2).forEach((r) => {
        delete t2[r];
      }), t2.keywords = n.keywords, t2.begin = mo(n.beforeMatch, Xm(n.begin)), t2.starts = {
        relevance: 0,
        contains: [
          Object.assign(n, { endsParent: true })
        ]
      }, t2.relevance = 0, delete n.beforeMatch;
    }, S1 = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ], C1 = "keyword";
    function rg(t2, e, n = C1) {
      const r = /* @__PURE__ */ Object.create(null);
      return typeof t2 == "string" ? o(n, t2.split(" ")) : Array.isArray(t2) ? o(n, t2) : Object.keys(t2).forEach(function(i) {
        Object.assign(
          r,
          rg(t2[i], e, i)
        );
      }), r;
      function o(i, s) {
        e && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
          const l = a.split("|");
          r[l[0]] = [i, x1(l[0], l[1])];
        });
      }
    }
    function x1(t2, e) {
      return e ? Number(e) : T1(t2) ? 0 : 1;
    }
    function T1(t2) {
      return S1.includes(t2.toLowerCase());
    }
    const Pp = {}, oo = (t2) => {
      console.error(t2);
    }, Bp = (t2, ...e) => {
      console.log(`WARN: ${t2}`, ...e);
    }, vo = (t2, e) => {
      Pp[`${t2}/${e}`] || (console.log(`Deprecated as of ${t2}. ${e}`), Pp[`${t2}/${e}`] = true);
    }, Xs = new Error();
    function og(t2, e, { key: n }) {
      let r = 0;
      const o = t2[n], i = {}, s = {};
      for (let a = 1; a <= e.length; a++)
        s[a + r] = o[a], i[a + r] = true, r += Zm(e[a - 1]);
      t2[n] = s, t2[n]._emit = i, t2[n]._multi = true;
    }
    function O1(t2) {
      if (Array.isArray(t2.begin)) {
        if (t2.skip || t2.excludeBegin || t2.returnBegin)
          throw oo("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Xs;
        if (typeof t2.beginScope != "object" || t2.beginScope === null)
          throw oo("beginScope must be object"), Xs;
        og(t2, t2.begin, { key: "beginScope" }), t2.begin = hu(t2.begin, { joinWith: "" });
      }
    }
    function N1(t2) {
      if (Array.isArray(t2.end)) {
        if (t2.skip || t2.excludeEnd || t2.returnEnd)
          throw oo("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Xs;
        if (typeof t2.endScope != "object" || t2.endScope === null)
          throw oo("endScope must be object"), Xs;
        og(t2, t2.end, { key: "endScope" }), t2.end = hu(t2.end, { joinWith: "" });
      }
    }
    function A1(t2) {
      t2.scope && typeof t2.scope == "object" && t2.scope !== null && (t2.beginScope = t2.scope, delete t2.scope);
    }
    function M1(t2) {
      A1(t2), typeof t2.beginScope == "string" && (t2.beginScope = { _wrap: t2.beginScope }), typeof t2.endScope == "string" && (t2.endScope = { _wrap: t2.endScope }), O1(t2), N1(t2);
    }
    function R1(t2) {
      function e(s, a) {
        return new RegExp(
          Ri(s),
          "m" + (t2.case_insensitive ? "i" : "") + (t2.unicodeRegex ? "u" : "") + (a ? "g" : "")
        );
      }
      class n {
        constructor() {
          this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += Zm(a) + 1;
        }
        compile() {
          this.regexes.length === 0 && (this.exec = () => null);
          const a = this.regexes.map((l) => l[1]);
          this.matcherRe = e(hu(a, { joinWith: "|" }), true), this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(a) {
          this.matcherRe.lastIndex = this.lastIndex;
          const l = this.matcherRe.exec(a);
          if (!l)
            return null;
          const c2 = l.findIndex((d, p2) => p2 > 0 && d !== void 0), u = this.matchIndexes[c2];
          return l.splice(0, c2), Object.assign(l, u);
        }
      }
      class r {
        constructor() {
          this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(a) {
          if (this.multiRegexes[a]) return this.multiRegexes[a];
          const l = new n();
          return this.rules.slice(a).forEach(([c2, u]) => l.addRule(c2, u)), l.compile(), this.multiRegexes[a] = l, l;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          this.rules.push([a, l]), l.type === "begin" && this.count++;
        }
        /** @param {string} s */
        exec(a) {
          const l = this.getMatcher(this.regexIndex);
          l.lastIndex = this.lastIndex;
          let c2 = l.exec(a);
          if (this.resumingScanAtSamePosition() && !(c2 && c2.index === this.lastIndex)) {
            const u = this.getMatcher(0);
            u.lastIndex = this.lastIndex + 1, c2 = u.exec(a);
          }
          return c2 && (this.regexIndex += c2.position + 1, this.regexIndex === this.count && this.considerAll()), c2;
        }
      }
      function o(s) {
        const a = new r();
        return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
      }
      function i(s, a) {
        const l = (
          /** @type CompiledMode */
          s
        );
        if (s.isCompiled) return l;
        [
          y1,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          k1,
          M1,
          _1
        ].forEach((u) => u(s, a)), t2.compilerExtensions.forEach((u) => u(s, a)), s.__beforeBegin = null, [
          v1,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          E1,
          // default to 1 relevance if not specified
          w1
        ].forEach((u) => u(s, a)), s.isCompiled = true;
        let c2 = null;
        return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), c2 = s.keywords.$pattern, delete s.keywords.$pattern), c2 = c2 || /\w+/, s.keywords && (s.keywords = rg(s.keywords, t2.case_insensitive)), l.keywordPatternRe = e(c2, true), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = e(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = e(l.end)), l.terminatorEnd = Ri(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = e(
          /** @type {RegExp | string} */
          s.illegal
        )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(u) {
          return I1(u === "self" ? s : u);
        })), s.contains.forEach(function(u) {
          i(
            /** @type Mode */
            u,
            l
          );
        }), s.starts && i(s.starts, a), l.matcher = o(l), l;
      }
      if (t2.compilerExtensions || (t2.compilerExtensions = []), t2.contains && t2.contains.includes("self"))
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      return t2.classNameAliases = Ar(t2.classNameAliases || {}), i(
        /** @type Mode */
        t2
      );
    }
    function ig(t2) {
      return t2 ? t2.endsWithParent || ig(t2.starts) : false;
    }
    function I1(t2) {
      return t2.variants && !t2.cachedVariants && (t2.cachedVariants = t2.variants.map(function(e) {
        return Ar(t2, { variants: null }, e);
      })), t2.cachedVariants ? t2.cachedVariants : ig(t2) ? Ar(t2, { starts: t2.starts ? Ar(t2.starts) : null }) : Object.isFrozen(t2) ? Ar(t2) : t2;
    }
    var D1 = "11.10.0";
    class L1 extends Error {
      constructor(e, n) {
        super(e), this.name = "HTMLInjectionError", this.html = n;
      }
    }
    const xl = Jm, $p = Ar, Fp = Symbol("nomatch"), P1 = 7, sg = function(t2) {
      const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
      let o = true;
      const i = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: true, name: "Plain text", contains: [] };
      let a = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: jT
      };
      function l(N) {
        return a.noHighlightRe.test(N);
      }
      function c2(N) {
        let D = N.className + " ";
        D += N.parentNode ? N.parentNode.className : "";
        const Y = a.languageDetectRe.exec(D);
        if (Y) {
          const oe = L(Y[1]);
          return oe || (Bp(i.replace("{}", Y[1])), Bp("Falling back to no-highlight mode for this block.", N)), oe ? Y[1] : "no-highlight";
        }
        return D.split(/\s+/).find((oe) => l(oe) || L(oe));
      }
      function u(N, D, Y) {
        let oe = "", ce = "";
        typeof D == "object" ? (oe = N, Y = D.ignoreIllegals, ce = D.language) : (vo("10.7.0", "highlight(lang, code, ...args) has been deprecated."), vo("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ce = N, oe = D), Y === void 0 && (Y = true);
        const Se = {
          code: oe,
          language: ce
        };
        fe("before:highlight", Se);
        const Fe = Se.result ? Se.result : d(Se.language, Se.code, Y);
        return Fe.code = Se.code, fe("after:highlight", Fe), Fe;
      }
      function d(N, D, Y, oe) {
        const ce = /* @__PURE__ */ Object.create(null);
        function Se(H, J) {
          return H.keywords[J];
        }
        function Fe() {
          if (!le.keywords) {
            qe.addText(Re);
            return;
          }
          let H = 0;
          le.keywordPatternRe.lastIndex = 0;
          let J = le.keywordPatternRe.exec(Re), we = "";
          for (; J; ) {
            we += Re.substring(H, J.index);
            const Ie = ve.case_insensitive ? J[0].toLowerCase() : J[0], gt = Se(le, Ie);
            if (gt) {
              const [an, qo] = gt;
              if (qe.addText(we), we = "", ce[Ie] = (ce[Ie] || 0) + 1, ce[Ie] <= P1 && (Wt += qo), an.startsWith("_"))
                we += J[0];
              else {
                const O = ve.classNameAliases[an] || an;
                Qe(J[0], O);
              }
            } else
              we += J[0];
            H = le.keywordPatternRe.lastIndex, J = le.keywordPatternRe.exec(Re);
          }
          we += Re.substring(H), qe.addText(we);
        }
        function kt() {
          if (Re === "") return;
          let H = null;
          if (typeof le.subLanguage == "string") {
            if (!e[le.subLanguage]) {
              qe.addText(Re);
              return;
            }
            H = d(le.subLanguage, Re, true, Vt[le.subLanguage]), Vt[le.subLanguage] = /** @type {CompiledMode} */
            H._top;
          } else
            H = f(Re, le.subLanguage.length ? le.subLanguage : null);
          le.relevance > 0 && (Wt += H.relevance), qe.__addSublanguage(H._emitter, H.language);
        }
        function ze() {
          le.subLanguage != null ? kt() : Fe(), Re = "";
        }
        function Qe(H, J) {
          H !== "" && (qe.startScope(J), qe.addText(H), qe.endScope());
        }
        function on2(H, J) {
          let we = 1;
          const Ie = J.length - 1;
          for (; we <= Ie; ) {
            if (!H._emit[we]) {
              we++;
              continue;
            }
            const gt = ve.classNameAliases[H[we]] || H[we], an = J[we];
            gt ? Qe(an, gt) : (Re = an, Fe(), Re = ""), we++;
          }
        }
        function Nt(H, J) {
          return H.scope && typeof H.scope == "string" && qe.openNode(ve.classNameAliases[H.scope] || H.scope), H.beginScope && (H.beginScope._wrap ? (Qe(Re, ve.classNameAliases[H.beginScope._wrap] || H.beginScope._wrap), Re = "") : H.beginScope._multi && (on2(H.beginScope, J), Re = "")), le = Object.create(H, { parent: { value: le } }), le;
        }
        function hn(H, J, we) {
          let Ie = ZT(H.endRe, we);
          if (Ie) {
            if (H["on:end"]) {
              const gt = new Ip(H);
              H["on:end"](J, gt), gt.isMatchIgnored && (Ie = false);
            }
            if (Ie) {
              for (; H.endsParent && H.parent; )
                H = H.parent;
              return H;
            }
          }
          if (H.endsWithParent)
            return hn(H.parent, J, we);
        }
        function At(H) {
          return le.matcher.regexIndex === 0 ? (Re += H[0], 1) : (Kt = true, 0);
        }
        function mn(H) {
          const J = H[0], we = H.rule, Ie = new Ip(we), gt = [we.__beforeBegin, we["on:begin"]];
          for (const an of gt)
            if (an && (an(H, Ie), Ie.isMatchIgnored))
              return At(J);
          return we.skip ? Re += J : (we.excludeBegin && (Re += J), ze(), !we.returnBegin && !we.excludeBegin && (Re = J)), Nt(we, H), we.returnBegin ? 0 : J.length;
        }
        function $n(H) {
          const J = H[0], we = D.substring(H.index), Ie = hn(le, H, we);
          if (!Ie)
            return Fp;
          const gt = le;
          le.endScope && le.endScope._wrap ? (ze(), Qe(J, le.endScope._wrap)) : le.endScope && le.endScope._multi ? (ze(), on2(le.endScope, H)) : gt.skip ? Re += J : (gt.returnEnd || gt.excludeEnd || (Re += J), ze(), gt.excludeEnd && (Re = J));
          do
            le.scope && qe.closeNode(), !le.skip && !le.subLanguage && (Wt += le.relevance), le = le.parent;
          while (le !== Ie.parent);
          return Ie.starts && Nt(Ie.starts, H), gt.returnEnd ? 0 : J.length;
        }
        function On() {
          const H = [];
          for (let J = le; J !== ve; J = J.parent)
            J.scope && H.unshift(J.scope);
          H.forEach((J) => qe.openNode(J));
        }
        let sn = {};
        function Nn(H, J) {
          const we = J && J[0];
          if (Re += H, we == null)
            return ze(), 0;
          if (sn.type === "begin" && J.type === "end" && sn.index === J.index && we === "") {
            if (Re += D.slice(J.index, J.index + 1), !o) {
              const Ie = new Error(`0 width match regex (${N})`);
              throw Ie.languageName = N, Ie.badRule = sn.rule, Ie;
            }
            return 1;
          }
          if (sn = J, J.type === "begin")
            return mn(J);
          if (J.type === "illegal" && !Y) {
            const Ie = new Error('Illegal lexeme "' + we + '" for mode "' + (le.scope || "<unnamed>") + '"');
            throw Ie.mode = le, Ie;
          } else if (J.type === "end") {
            const Ie = $n(J);
            if (Ie !== Fp)
              return Ie;
          }
          if (J.type === "illegal" && we === "")
            return 1;
          if (An > 1e5 && An > J.index * 3)
            throw new Error("potential infinite loop, way more iterations than matches");
          return Re += we, we.length;
        }
        const ve = L(N);
        if (!ve)
          throw oo(i.replace("{}", N)), new Error('Unknown language: "' + N + '"');
        const Xt = R1(ve);
        let Bt = "", le = oe || Xt;
        const Vt = {}, qe = new a.__emitter(a);
        On();
        let Re = "", Wt = 0, pt = 0, An = 0, Kt = false;
        try {
          if (ve.__emitTokens)
            ve.__emitTokens(D, qe);
          else {
            for (le.matcher.considerAll(); ; ) {
              An++, Kt ? Kt = false : le.matcher.considerAll(), le.matcher.lastIndex = pt;
              const H = le.matcher.exec(D);
              if (!H) break;
              const J = D.substring(pt, H.index), we = Nn(J, H);
              pt = H.index + we;
            }
            Nn(D.substring(pt));
          }
          return qe.finalize(), Bt = qe.toHTML(), {
            language: N,
            value: Bt,
            relevance: Wt,
            illegal: false,
            _emitter: qe,
            _top: le
          };
        } catch (H) {
          if (H.message && H.message.includes("Illegal"))
            return {
              language: N,
              value: xl(D),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: H.message,
                index: pt,
                context: D.slice(pt - 100, pt + 100),
                mode: H.mode,
                resultSoFar: Bt
              },
              _emitter: qe
            };
          if (o)
            return {
              language: N,
              value: xl(D),
              illegal: false,
              relevance: 0,
              errorRaised: H,
              _emitter: qe,
              _top: le
            };
          throw H;
        }
      }
      function p2(N) {
        const D = {
          value: xl(N),
          illegal: false,
          relevance: 0,
          _top: s,
          _emitter: new a.__emitter(a)
        };
        return D._emitter.addText(N), D;
      }
      function f(N, D) {
        D = D || a.languages || Object.keys(e);
        const Y = p2(N), oe = D.filter(L).filter(te).map(
          (ze) => d(ze, N, false)
        );
        oe.unshift(Y);
        const ce = oe.sort((ze, Qe) => {
          if (ze.relevance !== Qe.relevance) return Qe.relevance - ze.relevance;
          if (ze.language && Qe.language) {
            if (L(ze.language).supersetOf === Qe.language)
              return 1;
            if (L(Qe.language).supersetOf === ze.language)
              return -1;
          }
          return 0;
        }), [Se, Fe] = ce, kt = Se;
        return kt.secondBest = Fe, kt;
      }
      function h2(N, D, Y) {
        const oe = D && n[D] || Y;
        N.classList.add("hljs"), N.classList.add(`language-${oe}`);
      }
      function m(N) {
        let D = null;
        const Y = c2(N);
        if (l(Y)) return;
        if (fe(
          "before:highlightElement",
          { el: N, language: Y }
        ), N.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", N);
          return;
        }
        if (N.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(N)), a.throwUnescapedHTML))
          throw new L1(
            "One of your code blocks includes unescaped HTML.",
            N.innerHTML
          );
        D = N;
        const oe = D.textContent, ce = Y ? u(oe, { language: Y, ignoreIllegals: true }) : f(oe);
        N.innerHTML = ce.value, N.dataset.highlighted = "yes", h2(N, Y, ce.language), N.result = {
          language: ce.language,
          // TODO: remove with version 11.0
          re: ce.relevance,
          relevance: ce.relevance
        }, ce.secondBest && (N.secondBest = {
          language: ce.secondBest.language,
          relevance: ce.secondBest.relevance
        }), fe("after:highlightElement", { el: N, result: ce, text: oe });
      }
      function g(N) {
        a = $p(a, N);
      }
      const b = () => {
        v(), vo("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function E() {
        v(), vo("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let _ = false;
      function v() {
        if (document.readyState === "loading") {
          _ = true;
          return;
        }
        document.querySelectorAll(a.cssSelector).forEach(m);
      }
      function T() {
        _ && v();
      }
      typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", T, false);
      function S(N, D) {
        let Y = null;
        try {
          Y = D(t2);
        } catch (oe) {
          if (oo("Language definition for '{}' could not be registered.".replace("{}", N)), o)
            oo(oe);
          else
            throw oe;
          Y = s;
        }
        Y.name || (Y.name = N), e[N] = Y, Y.rawDefinition = D.bind(null, t2), Y.aliases && W(Y.aliases, { languageName: N });
      }
      function F(N) {
        delete e[N];
        for (const D of Object.keys(n))
          n[D] === N && delete n[D];
      }
      function V() {
        return Object.keys(e);
      }
      function L(N) {
        return N = (N || "").toLowerCase(), e[N] || e[n[N]];
      }
      function W(N, { languageName: D }) {
        typeof N == "string" && (N = [N]), N.forEach((Y) => {
          n[Y.toLowerCase()] = D;
        });
      }
      function te(N) {
        const D = L(N);
        return D && !D.disableAutodetect;
      }
      function de(N) {
        N["before:highlightBlock"] && !N["before:highlightElement"] && (N["before:highlightElement"] = (D) => {
          N["before:highlightBlock"](
            Object.assign({ block: D.el }, D)
          );
        }), N["after:highlightBlock"] && !N["after:highlightElement"] && (N["after:highlightElement"] = (D) => {
          N["after:highlightBlock"](
            Object.assign({ block: D.el }, D)
          );
        });
      }
      function ke(N) {
        de(N), r.push(N);
      }
      function Ee(N) {
        const D = r.indexOf(N);
        D !== -1 && r.splice(D, 1);
      }
      function fe(N, D) {
        const Y = N;
        r.forEach(function(oe) {
          oe[Y] && oe[Y](D);
        });
      }
      function he(N) {
        return vo("10.7.0", "highlightBlock will be removed entirely in v12.0"), vo("10.7.0", "Please use highlightElement now."), m(N);
      }
      Object.assign(t2, {
        highlight: u,
        highlightAuto: f,
        highlightAll: v,
        highlightElement: m,
        // TODO: Remove with v12 API
        highlightBlock: he,
        configure: g,
        initHighlighting: b,
        initHighlightingOnLoad: E,
        registerLanguage: S,
        unregisterLanguage: F,
        listLanguages: V,
        getLanguage: L,
        registerAliases: W,
        autoDetection: te,
        inherit: $p,
        addPlugin: ke,
        removePlugin: Ee
      }), t2.debugMode = function() {
        o = false;
      }, t2.safeMode = function() {
        o = true;
      }, t2.versionString = D1, t2.regex = {
        concat: mo,
        lookahead: Xm,
        either: fu,
        optional: JT,
        anyNumberOfTimes: YT
      };
      for (const N in ps)
        typeof ps[N] == "object" && Ym(ps[N]);
      return Object.assign(t2, ps), t2;
    }, zo = sg({});
    zo.newInstance = () => sg({});
    var B1 = zo;
    zo.HighlightJS = zo;
    zo.default = zo;
    var $1 = /* @__PURE__ */ WT(B1);
    function ag(t2, e = []) {
      return t2.map((n) => {
        const r = [...e, ...n.properties ? n.properties.className : []];
        return n.children ? ag(n.children, r) : {
          text: n.value,
          classes: r
        };
      }).flat();
    }
    function zp(t2) {
      return t2.value || t2.children || [];
    }
    function F1(t2) {
      return !!$1.getLanguage(t2);
    }
    function Hp({ doc: t2, name: e, lowlight: n, defaultLanguage: r }) {
      const o = [];
      return tc(t2, (i) => i.type.name === e).forEach((i) => {
        var s;
        let a = i.pos + 1;
        const l = i.node.attrs.language || r, c2 = n.listLanguages(), u = l && (c2.includes(l) || F1(l) || !((s = n.registered) === null || s === void 0) && s.call(n, l)) ? zp(n.highlight(l, i.node.textContent)) : zp(n.highlightAuto(i.node.textContent));
        ag(u).forEach((d) => {
          const p2 = a + d.text.length;
          if (d.classes.length) {
            const f = ht.inline(a, p2, {
              class: d.classes.join(" ")
            });
            o.push(f);
          }
          a = p2;
        });
      }), He.create(t2, o);
    }
    function z1(t2) {
      return typeof t2 == "function";
    }
    function H1({ name: t2, lowlight: e, defaultLanguage: n }) {
      if (!["highlight", "highlightAuto", "listLanguages"].every((o) => z1(e[o])))
        throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
      const r = new Ue({
        key: new Je("lowlight"),
        state: {
          init: (o, { doc: i }) => Hp({
            doc: i,
            name: t2,
            lowlight: e,
            defaultLanguage: n
          }),
          apply: (o, i, s, a) => {
            const l = s.selection.$head.parent.type.name, c2 = a.selection.$head.parent.type.name, u = tc(s.doc, (p2) => p2.type.name === t2), d = tc(a.doc, (p2) => p2.type.name === t2);
            return o.docChanged && ([l, c2].includes(t2) || d.length !== u.length || o.steps.some((p2) => (
              // @ts-ignore
              p2.from !== void 0 && p2.to !== void 0 && u.some((f) => (
                // @ts-ignore
                f.pos >= p2.from && f.pos + f.node.nodeSize <= p2.to
              ))
            ))) ? Hp({
              doc: o.doc,
              name: t2,
              lowlight: e,
              defaultLanguage: n
            }) : i.map(o.mapping, o.doc);
          }
        },
        props: {
          decorations(o) {
            return r.getState(o);
          }
        }
      });
      return r;
    }
    const U1 = vm.extend({
      addOptions() {
        var t2;
        return {
          ...(t2 = this.parent) === null || t2 === void 0 ? void 0 : t2.call(this),
          lowlight: {},
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      addProseMirrorPlugins() {
        var t2;
        return [
          ...((t2 = this.parent) === null || t2 === void 0 ? void 0 : t2.call(this)) || [],
          H1({
            name: this.name,
            lowlight: this.options.lowlight,
            defaultLanguage: this.options.defaultLanguage
          })
        ];
      }
    });
    function V1(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + t2.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + t2.IDENT_RE + "\\s*\\(", h2 = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], m = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], g = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], b = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: m,
        keyword: h2,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: g
      }, T = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: b
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          t2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        T,
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], F = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, V = {
        className: "function",
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: v,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          F,
          V,
          T,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: t2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function W1(t2) {
      const e = {
        type: [
          "boolean",
          "byte",
          "word",
          "String"
        ],
        built_in: [
          "KeyboardController",
          "MouseController",
          "SoftwareSerial",
          "EthernetServer",
          "EthernetClient",
          "LiquidCrystal",
          "RobotControl",
          "GSMVoiceCall",
          "EthernetUDP",
          "EsploraTFT",
          "HttpClient",
          "RobotMotor",
          "WiFiClient",
          "GSMScanner",
          "FileSystem",
          "Scheduler",
          "GSMServer",
          "YunClient",
          "YunServer",
          "IPAddress",
          "GSMClient",
          "GSMModem",
          "Keyboard",
          "Ethernet",
          "Console",
          "GSMBand",
          "Esplora",
          "Stepper",
          "Process",
          "WiFiUDP",
          "GSM_SMS",
          "Mailbox",
          "USBHost",
          "Firmata",
          "PImage",
          "Client",
          "Server",
          "GSMPIN",
          "FileIO",
          "Bridge",
          "Serial",
          "EEPROM",
          "Stream",
          "Mouse",
          "Audio",
          "Servo",
          "File",
          "Task",
          "GPRS",
          "WiFi",
          "Wire",
          "TFT",
          "GSM",
          "SPI",
          "SD"
        ],
        _hints: [
          "setup",
          "loop",
          "runShellCommandAsynchronously",
          "analogWriteResolution",
          "retrieveCallingNumber",
          "printFirmwareVersion",
          "analogReadResolution",
          "sendDigitalPortPair",
          "noListenOnLocalhost",
          "readJoystickButton",
          "setFirmwareVersion",
          "readJoystickSwitch",
          "scrollDisplayRight",
          "getVoiceCallStatus",
          "scrollDisplayLeft",
          "writeMicroseconds",
          "delayMicroseconds",
          "beginTransmission",
          "getSignalStrength",
          "runAsynchronously",
          "getAsynchronously",
          "listenOnLocalhost",
          "getCurrentCarrier",
          "readAccelerometer",
          "messageAvailable",
          "sendDigitalPorts",
          "lineFollowConfig",
          "countryNameWrite",
          "runShellCommand",
          "readStringUntil",
          "rewindDirectory",
          "readTemperature",
          "setClockDivider",
          "readLightSensor",
          "endTransmission",
          "analogReference",
          "detachInterrupt",
          "countryNameRead",
          "attachInterrupt",
          "encryptionType",
          "readBytesUntil",
          "robotNameWrite",
          "readMicrophone",
          "robotNameRead",
          "cityNameWrite",
          "userNameWrite",
          "readJoystickY",
          "readJoystickX",
          "mouseReleased",
          "openNextFile",
          "scanNetworks",
          "noInterrupts",
          "digitalWrite",
          "beginSpeaker",
          "mousePressed",
          "isActionDone",
          "mouseDragged",
          "displayLogos",
          "noAutoscroll",
          "addParameter",
          "remoteNumber",
          "getModifiers",
          "keyboardRead",
          "userNameRead",
          "waitContinue",
          "processInput",
          "parseCommand",
          "printVersion",
          "readNetworks",
          "writeMessage",
          "blinkVersion",
          "cityNameRead",
          "readMessage",
          "setDataMode",
          "parsePacket",
          "isListening",
          "setBitOrder",
          "beginPacket",
          "isDirectory",
          "motorsWrite",
          "drawCompass",
          "digitalRead",
          "clearScreen",
          "serialEvent",
          "rightToLeft",
          "setTextSize",
          "leftToRight",
          "requestFrom",
          "keyReleased",
          "compassRead",
          "analogWrite",
          "interrupts",
          "WiFiServer",
          "disconnect",
          "playMelody",
          "parseFloat",
          "autoscroll",
          "getPINUsed",
          "setPINUsed",
          "setTimeout",
          "sendAnalog",
          "readSlider",
          "analogRead",
          "beginWrite",
          "createChar",
          "motorsStop",
          "keyPressed",
          "tempoWrite",
          "readButton",
          "subnetMask",
          "debugPrint",
          "macAddress",
          "writeGreen",
          "randomSeed",
          "attachGPRS",
          "readString",
          "sendString",
          "remotePort",
          "releaseAll",
          "mouseMoved",
          "background",
          "getXChange",
          "getYChange",
          "answerCall",
          "getResult",
          "voiceCall",
          "endPacket",
          "constrain",
          "getSocket",
          "writeJSON",
          "getButton",
          "available",
          "connected",
          "findUntil",
          "readBytes",
          "exitValue",
          "readGreen",
          "writeBlue",
          "startLoop",
          "IPAddress",
          "isPressed",
          "sendSysex",
          "pauseMode",
          "gatewayIP",
          "setCursor",
          "getOemKey",
          "tuneWrite",
          "noDisplay",
          "loadImage",
          "switchPIN",
          "onRequest",
          "onReceive",
          "changePIN",
          "playFile",
          "noBuffer",
          "parseInt",
          "overflow",
          "checkPIN",
          "knobRead",
          "beginTFT",
          "bitClear",
          "updateIR",
          "bitWrite",
          "position",
          "writeRGB",
          "highByte",
          "writeRed",
          "setSpeed",
          "readBlue",
          "noStroke",
          "remoteIP",
          "transfer",
          "shutdown",
          "hangCall",
          "beginSMS",
          "endWrite",
          "attached",
          "maintain",
          "noCursor",
          "checkReg",
          "checkPUK",
          "shiftOut",
          "isValid",
          "shiftIn",
          "pulseIn",
          "connect",
          "println",
          "localIP",
          "pinMode",
          "getIMEI",
          "display",
          "noBlink",
          "process",
          "getBand",
          "running",
          "beginSD",
          "drawBMP",
          "lowByte",
          "setBand",
          "release",
          "bitRead",
          "prepare",
          "pointTo",
          "readRed",
          "setMode",
          "noFill",
          "remove",
          "listen",
          "stroke",
          "detach",
          "attach",
          "noTone",
          "exists",
          "buffer",
          "height",
          "bitSet",
          "circle",
          "config",
          "cursor",
          "random",
          "IRread",
          "setDNS",
          "endSMS",
          "getKey",
          "micros",
          "millis",
          "begin",
          "print",
          "write",
          "ready",
          "flush",
          "width",
          "isPIN",
          "blink",
          "clear",
          "press",
          "mkdir",
          "rmdir",
          "close",
          "point",
          "yield",
          "image",
          "BSSID",
          "click",
          "delay",
          "read",
          "text",
          "move",
          "peek",
          "beep",
          "rect",
          "line",
          "open",
          "seek",
          "fill",
          "size",
          "turn",
          "stop",
          "home",
          "find",
          "step",
          "tone",
          "sqrt",
          "RSSI",
          "SSID",
          "end",
          "bit",
          "tan",
          "cos",
          "sin",
          "pow",
          "map",
          "abs",
          "max",
          "min",
          "get",
          "run",
          "put"
        ],
        literal: [
          "DIGITAL_MESSAGE",
          "FIRMATA_STRING",
          "ANALOG_MESSAGE",
          "REPORT_DIGITAL",
          "REPORT_ANALOG",
          "INPUT_PULLUP",
          "SET_PIN_MODE",
          "INTERNAL2V56",
          "SYSTEM_RESET",
          "LED_BUILTIN",
          "INTERNAL1V1",
          "SYSEX_START",
          "INTERNAL",
          "EXTERNAL",
          "DEFAULT",
          "OUTPUT",
          "INPUT",
          "HIGH",
          "LOW"
        ]
      }, n = V1(t2), r = (
        /** @type {Record<string,any>} */
        n.keywords
      );
      return r.type = [
        ...r.type,
        ...e.type
      ], r.literal = [
        ...r.literal,
        ...e.literal
      ], r.built_in = [
        ...r.built_in,
        ...e.built_in
      ], r._hints = e._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
    }
    function K1(t2) {
      const e = t2.regex, n = {}, r = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [n]
          }
          // default values
        ]
      };
      Object.assign(n, {
        className: "variable",
        variants: [
          { begin: e.concat(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            "(?![\\w\\d])(?![$])"
          ) },
          r
        ]
      });
      const o = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [t2.BACKSLASH_ESCAPE]
      }, i = t2.inherit(
        t2.COMMENT(),
        {
          match: [
            /(^|\s)/,
            /#.*$/
          ],
          scope: {
            2: "comment"
          }
        }
      ), s = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          t2.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      }, a = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          t2.BACKSLASH_ESCAPE,
          n,
          o
        ]
      };
      o.contains.push(a);
      const l = {
        match: /\\"/
      }, c2 = {
        className: "string",
        begin: /'/,
        end: /'/
      }, u = {
        match: /\\'/
      }, d = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          t2.NUMBER_MODE,
          n
        ]
      }, p2 = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ], f = t2.SHEBANG({
        binary: `(${p2.join("|")})`,
        relevance: 10
      }), h2 = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [t2.inherit(t2.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      }, m = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ], g = [
        "true",
        "false"
      ], b = { match: /(\/[a-z._-]+)+/ }, E = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ], _ = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ], v = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ], T = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        // "false", // keyword literal already
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        // "true", // keyword literal already
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: m,
          literal: g,
          built_in: [
            ...E,
            ..._,
            // Shell modifiers
            "set",
            "shopt",
            ...v,
            ...T
          ]
        },
        contains: [
          f,
          // to catch known shells and boost relevancy
          t2.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          h2,
          d,
          i,
          s,
          b,
          a,
          l,
          c2,
          u,
          n
        ]
      };
    }
    function q1(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        variants: [
          { begin: "\\b[a-z\\d_]*_t\\b" },
          { match: /\batomic_[a-z]{3,6}\b/ }
        ]
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          { match: /\b(0b[01']+)/ },
          { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
          { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + t2.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + t2.IDENT_RE + "\\s*\\(", g = {
        keyword: [
          "asm",
          "auto",
          "break",
          "case",
          "continue",
          "default",
          "do",
          "else",
          "enum",
          "extern",
          "for",
          "fortran",
          "goto",
          "if",
          "inline",
          "register",
          "restrict",
          "return",
          "sizeof",
          "typeof",
          "typeof_unqual",
          "struct",
          "switch",
          "typedef",
          "union",
          "volatile",
          "while",
          "_Alignas",
          "_Alignof",
          "_Atomic",
          "_Generic",
          "_Noreturn",
          "_Static_assert",
          "_Thread_local",
          // aliases
          "alignas",
          "alignof",
          "noreturn",
          "static_assert",
          "thread_local",
          // not a C keyword but is, for all intents and purposes, treated exactly like one.
          "_Pragma"
        ],
        type: [
          "float",
          "double",
          "signed",
          "unsigned",
          "int",
          "short",
          "long",
          "char",
          "void",
          "_Bool",
          "_BitInt",
          "_Complex",
          "_Imaginary",
          "_Decimal32",
          "_Decimal64",
          "_Decimal96",
          "_Decimal128",
          "_Decimal64x",
          "_Decimal128x",
          "_Float16",
          "_Float32",
          "_Float64",
          "_Float128",
          "_Float32x",
          "_Float64x",
          "_Float128x",
          // modifiers
          "const",
          "static",
          "constexpr",
          // aliases
          "complex",
          "bool",
          "imaginary"
        ],
        literal: "true false NULL",
        // TODO: apply hinting work similar to what was done in cpp.js
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      }, b = [
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], E = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: g,
        contains: b.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            contains: b.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, _ = {
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: g,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: g,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [t2.inherit(p2, { className: "title.function" })],
            relevance: 0
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: g,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: g,
        // Until differentiations are added between `c` and `cpp`, `c` will
        // not be auto-detected to avoid auto-detect conflicts between C and C++
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(
          E,
          _,
          b,
          [
            d,
            {
              begin: t2.IDENT_RE + "::",
              keywords: g
            },
            {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [
                { beginKeywords: "final class struct" },
                t2.TITLE_MODE
              ]
            }
          ]
        ),
        exports: {
          preprocessor: d,
          strings: c2,
          keywords: g
        }
      };
    }
    function G1(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + t2.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + t2.IDENT_RE + "\\s*\\(", h2 = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], m = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], g = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], b = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: m,
        keyword: h2,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: g
      }, T = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: b
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          t2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        T,
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], F = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, V = {
        className: "function",
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: v,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          F,
          V,
          T,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: t2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function j1(t2) {
      const e = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ], n = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ], r = [
        "default",
        "false",
        "null",
        "true"
      ], o = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ], i = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ], s = {
        keyword: o.concat(i),
        built_in: e,
        literal: r
      }, a = t2.inherit(t2.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      }, c2 = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      }, u = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      }, d = t2.inherit(u, { illegal: /\n/ }), p2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: s
      }, f = t2.inherit(p2, { illegal: /\n/ }), h2 = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          t2.BACKSLASH_ESCAPE,
          f
        ]
      }, m = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          p2
        ]
      }, g = t2.inherit(m, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          f
        ]
      });
      p2.contains = [
        m,
        h2,
        u,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        l,
        t2.C_BLOCK_COMMENT_MODE
      ], f.contains = [
        g,
        h2,
        d,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        l,
        t2.inherit(t2.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const b = { variants: [
        c2,
        m,
        h2,
        u,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE
      ] }, E = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          a
        ]
      }, _ = t2.IDENT_RE + "(<" + t2.IDENT_RE + "(\\s*,\\s*" + t2.IDENT_RE + ")*>)?(\\[\\])?", v = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + t2.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: s,
        illegal: /::/,
        contains: [
          t2.COMMENT(
            "///",
            "$",
            {
              returnBegin: true,
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: "///",
                      relevance: 0
                    },
                    { begin: "<!--|-->" },
                    {
                      begin: "</?",
                      end: ">"
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          b,
          l,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              a,
              E,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              E,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + _ + "\\s+)+" + t2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: s,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: n.join(" "),
                relevance: 0
              },
              {
                begin: t2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  t2.TITLE_MODE,
                  E
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: s,
                relevance: 0,
                contains: [
                  b,
                  l,
                  t2.C_BLOCK_COMMENT_MODE
                ]
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          v
        ]
      };
    }
    const Y1 = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), J1 = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], X1 = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], Z1 = [
      ...J1,
      ...X1
    ], Q1 = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), eO = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), tO = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), nO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function rO(t2) {
      const e = t2.regex, n = Y1(t2), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, o = "and or not only", i = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          n.BLOCK_COMMENT,
          r,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          n.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + s,
            relevance: 0
          },
          n.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + eO.join("|") + ")" },
              { begin: ":(:)?(" + tO.join("|") + ")" }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          n.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + nO.join("|") + ")\\b"
          },
          // attribute values
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              n.BLOCK_COMMENT,
              n.HEXCOLOR,
              n.IMPORTANT,
              n.CSS_NUMBER_MODE,
              ...a,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                // from keywords
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...a,
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              n.FUNCTION_DISPATCH
            ]
          },
          {
            begin: e.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            // break on Less variables @var: ...
            contains: [
              {
                className: "keyword",
                begin: i
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: o,
                  attribute: Q1.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...a,
                  n.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + Z1.join("|") + ")\\b"
          }
        ]
      };
    }
    function oO(t2) {
      const e = t2.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: e.either(
              /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
              /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
              /^--- +\d+,\d+ +----$/
            )
          },
          {
            className: "comment",
            variants: [
              {
                begin: e.either(
                  /Index: /,
                  /^index/,
                  /={3,}/,
                  /^-{3}/,
                  /^\*{3} /,
                  /^\+{3}/,
                  /^diff --git/
                ),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    function iO(t2) {
      const i = {
        keyword: [
          "break",
          "case",
          "chan",
          "const",
          "continue",
          "default",
          "defer",
          "else",
          "fallthrough",
          "for",
          "func",
          "go",
          "goto",
          "if",
          "import",
          "interface",
          "map",
          "package",
          "range",
          "return",
          "select",
          "struct",
          "switch",
          "type",
          "var"
        ],
        type: [
          "bool",
          "byte",
          "complex64",
          "complex128",
          "error",
          "float32",
          "float64",
          "int8",
          "int16",
          "int32",
          "int64",
          "string",
          "uint8",
          "uint16",
          "uint32",
          "uint64",
          "int",
          "uint",
          "uintptr",
          "rune"
        ],
        literal: [
          "true",
          "false",
          "iota",
          "nil"
        ],
        built_in: [
          "append",
          "cap",
          "close",
          "complex",
          "copy",
          "imag",
          "len",
          "make",
          "new",
          "panic",
          "print",
          "println",
          "real",
          "recover",
          "delete"
        ]
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: i,
        illegal: "</",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                // hex without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                // hex with a present digit before . (making a digit afterwards optional)
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                // leading 0o octal
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                // decimal without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                // decimal with a present digit before . (making a digit afterwards optional)
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
            // relevance booster
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              t2.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: i,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    function sO(t2) {
      const e = t2.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: [
            "true",
            "false",
            "null"
          ]
        },
        contains: [
          t2.HASH_COMMENT_MODE,
          t2.QUOTE_STRING_MODE,
          t2.NUMBER_MODE,
          {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          },
          {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          },
          {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          },
          {
            scope: "meta",
            match: /@\w+/,
            excludeEnd: true
          },
          {
            scope: "symbol",
            begin: e.concat(n, e.lookahead(/\s*:/)),
            relevance: 0
          }
        ],
        illegal: [
          /[;<']/,
          /BEGIN/
        ]
      };
    }
    function aO(t2) {
      const e = t2.regex, n = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: /([+-]+)?[\d]+_[\d_]+/ },
          { begin: t2.NUMBER_RE }
        ]
      }, r = t2.COMMENT();
      r.variants = [
        {
          begin: /;/,
          end: /$/
        },
        {
          begin: /#/,
          end: /$/
        }
      ];
      const o = {
        className: "variable",
        variants: [
          { begin: /\$[\w\d"][\w\d_]*/ },
          { begin: /\$\{(.*?)\}/ }
        ]
      }, i = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      }, s = {
        className: "string",
        contains: [t2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: "'''",
            end: "'''",
            relevance: 10
          },
          {
            begin: '"""',
            end: '"""',
            relevance: 10
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "'",
            end: "'"
          }
        ]
      }, a = {
        begin: /\[/,
        end: /\]/,
        contains: [
          r,
          i,
          o,
          s,
          n,
          "self"
        ],
        relevance: 0
      }, l = /[A-Za-z0-9_-]+/, c2 = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
        l,
        c2,
        u
      ), p2 = e.concat(
        d,
        "(\\s*\\.\\s*",
        d,
        ")*",
        e.lookahead(/\s*=\s*[^#\s]/)
      );
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [
          r,
          {
            className: "section",
            begin: /\[+/,
            end: /\]+/
          },
          {
            begin: p2,
            className: "attr",
            starts: {
              end: /$/,
              contains: [
                r,
                a,
                i,
                o,
                s,
                n
              ]
            }
          }
        ]
      };
    }
    var _o = "[0-9](_*[0-9])*", fs = `\\.(${_o})`, hs = "[0-9a-fA-F](_*[0-9a-fA-F])*", Up = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${_o})((${fs})|\\.)?|(${fs}))[eE][+-]?(${_o})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${_o})((${fs})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${fs})[fFdD]?\\b` },
        { begin: `\\b(${_o})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hs})\\.?|(${hs})?\\.(${hs}))[pP][+-]?(${_o})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${hs})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function lg(t2, e, n) {
      return n === -1 ? "" : t2.replace(e, (r) => lg(t2, e, n - 1));
    }
    function lO(t2) {
      const e = t2.regex, n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", r = n + lg("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
        keyword: [
          "synchronized",
          "abstract",
          "private",
          "var",
          "static",
          "if",
          "const ",
          "for",
          "while",
          "strictfp",
          "finally",
          "protected",
          "import",
          "native",
          "final",
          "void",
          "enum",
          "else",
          "break",
          "transient",
          "catch",
          "instanceof",
          "volatile",
          "case",
          "assert",
          "package",
          "default",
          "public",
          "try",
          "switch",
          "continue",
          "throws",
          "protected",
          "public",
          "private",
          "module",
          "requires",
          "exports",
          "do",
          "sealed",
          "yield",
          "permits",
          "goto",
          "when"
        ],
        literal: [
          "false",
          "true",
          "null"
        ],
        type: [
          "char",
          "boolean",
          "long",
          "float",
          "int",
          "byte",
          "short",
          "double"
        ],
        built_in: [
          "super",
          "this"
        ]
      }, c2 = {
        className: "meta",
        begin: "@" + n,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
            // allow nested () inside our annotation
          }
        ]
      }, u = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: l,
        relevance: 0,
        contains: [t2.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: l,
        illegal: /<\/|#/,
        contains: [
          t2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/,
                  relevance: 0
                },
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              n
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            // Exceptions for hyphenated keywords
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              e.concat(/(?!else)/, n),
              /\s+/,
              n,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              n
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              u,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + r + "\\s+)",
              t2.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: l,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: l,
                relevance: 0,
                contains: [
                  c2,
                  t2.APOS_STRING_MODE,
                  t2.QUOTE_STRING_MODE,
                  Up,
                  t2.C_BLOCK_COMMENT_MODE
                ]
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          Up,
          c2
        ]
      };
    }
    const Vp = "[A-Za-z$_][0-9A-Za-z$_]*", cO = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], uO = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], cg = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], ug = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], dg = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], dO = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], pO = [].concat(
      dg,
      cg,
      ug
    );
    function fO(t2) {
      const e = t2.regex, n = (D, { after: Y }) => {
        const oe = "</" + D[0].slice(1);
        return D.input.indexOf(oe, Y) !== -1;
      }, r = Vp, o = {
        begin: "<>",
        end: "</>"
      }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (D, Y) => {
          const oe = D[0].length + D.index, ce = D.input[oe];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ce === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ce === ","
          ) {
            Y.ignoreMatch();
            return;
          }
          ce === ">" && (n(D, { after: oe }) || Y.ignoreMatch());
          let Se;
          const Fe = D.input.substring(oe);
          if (Se = Fe.match(/^\s*=/)) {
            Y.ignoreMatch();
            return;
          }
          if ((Se = Fe.match(/^\s+extends\s+/)) && Se.index === 0) {
            Y.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: Vp,
        keyword: cO,
        literal: uO,
        built_in: pO,
        "variable.language": dO
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, f = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, h2 = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, m = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, g = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          t2.BACKSLASH_ESCAPE,
          p2
        ]
      }, E = {
        className: "comment",
        variants: [
          t2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: r + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_LINE_COMMENT_MODE
        ]
      }, _ = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        f,
        h2,
        m,
        g,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = _.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(_)
      });
      const v = [].concat(E, p2.contains), T = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: T
      }, F = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              r,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(r, "(", e.concat(/\./, r), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              r
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, V = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...cg,
            ...ug
          ]
        }
      }, L = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, W = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              r,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, te = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function de(D) {
        return e.concat("(?!", D.join("|"), ")");
      }
      const ke = {
        match: e.concat(
          /\b/,
          de([
            ...dg,
            "super",
            "import"
          ].map((D) => `${D}\\s*\\(`)),
          r,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, Ee = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(r, /(?![0-9A-Za-z$_(])/)
        )),
        end: r,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, fe = {
        match: [
          /get|set/,
          /\s+/,
          r,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          r,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: T, CLASS_REFERENCE: V },
        illegal: /#(?![$_A-z])/,
        contains: [
          t2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          L,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          f,
          h2,
          m,
          g,
          E,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          V,
          {
            scope: "attr",
            match: r + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + t2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              E,
              t2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: t2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: T
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: o.begin, end: o.end },
                  { match: i },
                  {
                    begin: s.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": s.isTrulyOpeningTag,
                    end: s.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: s.begin,
                    end: s.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          W,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + t2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              t2.inherit(t2.TITLE_MODE, { begin: r, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          Ee,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + r,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ke,
          te,
          F,
          fe,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function hO(t2) {
      const e = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      }, n = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      }, r = [
        "true",
        "false",
        "null"
      ], o = {
        scope: "literal",
        beginKeywords: r.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: r
        },
        contains: [
          e,
          n,
          t2.QUOTE_STRING_MODE,
          o,
          t2.C_NUMBER_MODE,
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    var So = "[0-9](_*[0-9])*", ms = `\\.(${So})`, gs = "[0-9a-fA-F](_*[0-9a-fA-F])*", mO = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${So})((${ms})|\\.)?|(${ms}))[eE][+-]?(${So})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${So})((${ms})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${ms})[fFdD]?\\b` },
        { begin: `\\b(${So})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${gs})\\.?|(${gs})?\\.(${gs}))[pP][+-]?(${So})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${gs})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function gO(t2) {
      const e = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      }, n = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      }, r = {
        className: "symbol",
        begin: t2.UNDERSCORE_IDENT_RE + "@"
      }, o = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [t2.C_NUMBER_MODE]
      }, i = {
        className: "variable",
        begin: "\\$" + t2.UNDERSCORE_IDENT_RE
      }, s = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              i,
              o
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              i,
              o
            ]
          }
        ]
      };
      o.contains.push(s);
      const a = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t2.UNDERSCORE_IDENT_RE + ")?"
      }, l = {
        className: "meta",
        begin: "@" + t2.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              t2.inherit(s, { className: "string" }),
              "self"
            ]
          }
        ]
      }, c2 = mO, u = t2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [t2.C_BLOCK_COMMENT_MODE] }
      ), d = { variants: [
        {
          className: "type",
          begin: t2.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
          // defined later
        }
      ] }, p2 = d;
      return p2.variants[1].contains = [d], d.variants[1].contains = [p2], {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: e,
        contains: [
          t2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          t2.C_LINE_COMMENT_MODE,
          u,
          n,
          r,
          a,
          l,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: e,
            relevance: 5,
            contains: [
              {
                begin: t2.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [t2.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: e,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      d,
                      t2.C_LINE_COMMENT_MODE,
                      u
                    ],
                    relevance: 0
                  },
                  t2.C_LINE_COMMENT_MODE,
                  u,
                  a,
                  l,
                  s,
                  t2.C_NUMBER_MODE
                ]
              },
              u
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              t2.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              t2.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              a,
              l
            ]
          },
          s,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: `
`
          },
          c2
        ]
      };
    }
    const bO = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), yO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], vO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], EO = [
      ...yO,
      ...vO
    ], kO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), pg = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), fg = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), wO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse(), _O = pg.concat(fg).sort().reverse();
    function SO(t2) {
      const e = bO(t2), n = _O, r = "and or not only", o = "[\\w-]+", i = "(" + o + "|@\\{" + o + "\\})", s = [], a = [], l = function(_) {
        return {
          // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
          className: "string",
          begin: "~?" + _ + ".*?" + _
        };
      }, c2 = function(_, v, T) {
        return {
          className: _,
          begin: v,
          relevance: T
        };
      }, u = {
        $pattern: /[a-z-]+/,
        keyword: r,
        attribute: kO.join(" ")
      }, d = {
        // used only to properly balance nested parens inside mixin call, def. arg list
        begin: "\\(",
        end: "\\)",
        contains: a,
        keywords: u,
        relevance: 0
      };
      a.push(
        t2.C_LINE_COMMENT_MODE,
        t2.C_BLOCK_COMMENT_MODE,
        l("'"),
        l('"'),
        e.CSS_NUMBER_MODE,
        // fixme: it does not include dot for numbers like .5em :(
        {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        },
        e.HEXCOLOR,
        d,
        c2("variable", "@@?" + o, 10),
        c2("variable", "@\\{" + o + "\\}"),
        c2("built_in", "~?`[^`]*?`"),
        // inline javascript (or whatever host language) *multiline* string
        {
          // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
          className: "attribute",
          begin: o + "\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        },
        e.IMPORTANT,
        { beginKeywords: "and not" },
        e.FUNCTION_DISPATCH
      );
      const p2 = a.concat({
        begin: /\{/,
        end: /\}/,
        contains: s
      }), f = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{ beginKeywords: "and not" }].concat(a)
        // using this form to override VALUE’s 'function' match
      }, h2 = {
        begin: i + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + wO.join("|") + ")\\b",
            end: /(?=:)/,
            starts: {
              endsWithParent: true,
              illegal: "[<=$]",
              relevance: 0,
              contains: a
            }
          }
        ]
      }, m = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: u,
          returnEnd: true,
          contains: a,
          relevance: 0
        }
      }, g = {
        className: "variable",
        variants: [
          // using more strict pattern for higher relevance to increase chances of Less detection.
          // this is *the only* Less specific statement used in most of the sources, so...
          // (we’ll still often loose to the css-parser unless there's '//' comment,
          // simply because 1 variable just can't beat 99 properties :)
          {
            begin: "@" + o + "\\s*:",
            relevance: 15
          },
          { begin: "@" + o }
        ],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: p2
        }
      }, b = {
        // first parse unambiguous selectors (i.e. those not starting with tag)
        // then fall into the scary lookahead-discriminator variant.
        // this mode also handles mixin definitions and calls
        variants: [
          {
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
            // mixin calls end with ';'
          },
          {
            begin: i,
            end: /\{/
          }
        ],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          f,
          c2("keyword", "all\\b"),
          c2("variable", "@\\{" + o + "\\}"),
          // otherwise it’s identified as tag
          {
            begin: "\\b(" + EO.join("|") + ")\\b",
            className: "selector-tag"
          },
          e.CSS_NUMBER_MODE,
          c2("selector-tag", i, 0),
          c2("selector-id", "#" + i),
          c2("selector-class", "\\." + i, 0),
          c2("selector-tag", "&", 0),
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            begin: ":(" + pg.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + fg.join("|") + ")"
          },
          {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: p2
          },
          // argument list of parametric mixins
          { begin: "!important" },
          // eat !important after mixin call or it will be colored as tag
          e.FUNCTION_DISPATCH
        ]
      }, E = {
        begin: o + `:(:)?(${n.join("|")})`,
        returnBegin: true,
        contains: [b]
      };
      return s.push(
        t2.C_LINE_COMMENT_MODE,
        t2.C_BLOCK_COMMENT_MODE,
        m,
        g,
        E,
        h2,
        b,
        f,
        e.FUNCTION_DISPATCH
      ), {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: s
      };
    }
    function CO(t2) {
      const e = "\\[=*\\[", n = "\\]=*\\]", r = {
        begin: e,
        end: n,
        contains: ["self"]
      }, o = [
        t2.COMMENT("--(?!" + e + ")", "$"),
        t2.COMMENT(
          "--" + e,
          n,
          {
            contains: [r],
            relevance: 10
          }
        )
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: t2.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: (
            // Metatags and globals:
            "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          )
        },
        contains: o.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              t2.inherit(t2.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: o
              }
            ].concat(o)
          },
          t2.C_NUMBER_MODE,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: e,
            end: n,
            contains: [r],
            relevance: 5
          }
        ])
      };
    }
    function xO(t2) {
      const e = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + t2.UNDERSCORE_IDENT_RE + "\\)",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      }, n = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          t2.BACKSLASH_ESCAPE,
          e
        ]
      }, r = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          e,
          n
          // Added QUOTE_STRING as they can be a part of functions
        ]
      }, o = { begin: "^" + t2.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, i = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      }, s = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [e]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          t2.HASH_COMMENT_MODE,
          e,
          n,
          r,
          o,
          i,
          s
        ]
      };
    }
    function TO(t2) {
      const e = t2.regex, n = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      }, r = {
        begin: "^[-\\*]{3,}",
        end: "$"
      }, o = {
        className: "code",
        variants: [
          // TODO: fix to allow these to work with sublanguage also
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          // needed to allow markdown as a sublanguage to work
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            // use contains to gobble up multiple lines to allow the block to be whatever size
            // but only have a single open/close tag vs one per line
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      }, i = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      }, s = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
        variants: [
          // too much like nested array access in so many languages
          // to have any real relevance
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          // popular internet URLs
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
            relevance: 2
          },
          // relative urls
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          // whatever else, lower relevance (might not be a link at all)
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            // empty strings for alt or link text
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      }, c2 = {
        className: "strong",
        contains: [],
        // defined later
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      }, u = {
        className: "emphasis",
        contains: [],
        // defined later
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      }, d = t2.inherit(c2, { contains: [] }), p2 = t2.inherit(u, { contains: [] });
      c2.contains.push(p2), u.contains.push(d);
      let f = [
        n,
        l
      ];
      return [
        c2,
        u,
        d,
        p2
      ].forEach((b) => {
        b.contains = b.contains.concat(f);
      }), f = f.concat(c2, u), {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          {
            className: "section",
            variants: [
              {
                begin: "^#{1,6}",
                end: "$",
                contains: f
              },
              {
                begin: "(?=^.+?\\n[=-]{2,}$)",
                contains: [
                  { begin: "^[=-]*$" },
                  {
                    begin: "^",
                    end: "\\n",
                    contains: f
                  }
                ]
              }
            ]
          },
          n,
          i,
          c2,
          u,
          {
            className: "quote",
            begin: "^>\\s+",
            contains: f,
            end: "$"
          },
          o,
          r,
          l,
          s,
          {
            //https://spec.commonmark.org/0.31.2/#entity-references
            scope: "literal",
            match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
          }
        ]
      };
    }
    function OO(t2) {
      const e = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: n,
        keyword: [
          "while",
          "export",
          "sizeof",
          "typedef",
          "const",
          "struct",
          "for",
          "union",
          "volatile",
          "static",
          "mutable",
          "if",
          "do",
          "return",
          "goto",
          "enum",
          "else",
          "break",
          "extern",
          "asm",
          "case",
          "default",
          "register",
          "explicit",
          "typename",
          "switch",
          "continue",
          "inline",
          "readonly",
          "assign",
          "readwrite",
          "self",
          "@synchronized",
          "id",
          "typeof",
          "nonatomic",
          "IBOutlet",
          "IBAction",
          "strong",
          "weak",
          "copy",
          "in",
          "out",
          "inout",
          "bycopy",
          "byref",
          "oneway",
          "__strong",
          "__weak",
          "__block",
          "__autoreleasing",
          "@private",
          "@protected",
          "@public",
          "@try",
          "@property",
          "@end",
          "@throw",
          "@catch",
          "@finally",
          "@autoreleasepool",
          "@synthesize",
          "@dynamic",
          "@selector",
          "@optional",
          "@required",
          "@encode",
          "@package",
          "@import",
          "@defs",
          "@compatibility_alias",
          "__bridge",
          "__bridge_transfer",
          "__bridge_retained",
          "__bridge_retain",
          "__covariant",
          "__contravariant",
          "__kindof",
          "_Nonnull",
          "_Nullable",
          "_Null_unspecified",
          "__FUNCTION__",
          "__PRETTY_FUNCTION__",
          "__attribute__",
          "getter",
          "setter",
          "retain",
          "unsafe_unretained",
          "nonnull",
          "nullable",
          "null_unspecified",
          "null_resettable",
          "class",
          "instancetype",
          "NS_DESIGNATED_INITIALIZER",
          "NS_UNAVAILABLE",
          "NS_REQUIRES_SUPER",
          "NS_RETURNS_INNER_POINTER",
          "NS_INLINE",
          "NS_AVAILABLE",
          "NS_DEPRECATED",
          "NS_ENUM",
          "NS_OPTIONS",
          "NS_SWIFT_UNAVAILABLE",
          "NS_ASSUME_NONNULL_BEGIN",
          "NS_ASSUME_NONNULL_END",
          "NS_REFINED_FOR_SWIFT",
          "NS_SWIFT_NAME",
          "NS_SWIFT_NOTHROW",
          "NS_DURING",
          "NS_HANDLER",
          "NS_ENDHANDLER",
          "NS_VALUERETURN",
          "NS_VOIDRETURN"
        ],
        literal: [
          "false",
          "true",
          "FALSE",
          "TRUE",
          "nil",
          "YES",
          "NO",
          "NULL"
        ],
        built_in: [
          "dispatch_once_t",
          "dispatch_queue_t",
          "dispatch_sync",
          "dispatch_async",
          "dispatch_once"
        ],
        type: [
          "int",
          "float",
          "char",
          "unsigned",
          "signed",
          "short",
          "long",
          "double",
          "wchar_t",
          "unichar",
          "void",
          "bool",
          "BOOL",
          "id|0",
          "_Bool"
        ]
      }, l = {
        $pattern: n,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: a,
        illegal: "</",
        contains: [
          e,
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_NUMBER_MODE,
          t2.QUOTE_STRING_MODE,
          t2.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [t2.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              t2.inherit(t2.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + l.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: l,
            contains: [t2.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + t2.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    function NO(t2) {
      const e = t2.regex, n = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ], r = /[dualxmsipngr]{0,12}/, o = {
        $pattern: /[\w.]+/,
        keyword: n.join(" ")
      }, i = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: o
      }, s = {
        begin: /->\{/,
        end: /\}/
        // contains defined later
      }, a = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      }, l = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: e.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              // negative look-ahead tries to avoid matching patterns that are not
              // Perl at all like $ident$, @ident@, etc.
              "(?![A-Za-z])(?![@$%])"
            )
          },
          {
            // Only $= is a special Perl variable and one can't declare @= or %=.
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [a]
      }, c2 = {
        className: "number",
        variants: [
          // decimal numbers:
          // include the case where a number starts with a dot (eg. .9), and
          // the leading 0? avoids mixing the first and second match on 0.x cases
          { match: /0?\.[0-9][0-9_]+\b/ },
          // include the special versioned number (eg. v5.38)
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          // non-decimal numbers:
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      }, u = [
        t2.BACKSLASH_ESCAPE,
        i,
        l
      ], d = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        // valid but infrequent and weird
        /#/
        // valid but infrequent and weird
      ], p2 = (m, g, b = "\\1") => {
        const E = b === "\\1" ? b : e.concat(b, g);
        return e.concat(
          e.concat("(?:", m, ")"),
          g,
          /(?:\\.|[^\\\/])*?/,
          E,
          /(?:\\.|[^\\\/])*?/,
          b,
          r
        );
      }, f = (m, g, b) => e.concat(
        e.concat("(?:", m, ")"),
        g,
        /(?:\\.|[^\\\/])*?/,
        b,
        r
      ), h2 = [
        l,
        t2.HASH_COMMENT_MODE,
        t2.COMMENT(
          /^=\w/,
          /=cut/,
          { endsWithParent: true }
        ),
        s,
        {
          className: "string",
          contains: u,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [t2.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [t2.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        c2,
        {
          // regexp container
          begin: "(\\/\\/|" + t2.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            t2.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                // allow matching common delimiters
                { begin: p2("s|tr|y", e.either(...d, { capture: true })) },
                // and then paired delmis
                { begin: p2("s|tr|y", "\\(", "\\)") },
                { begin: p2("s|tr|y", "\\[", "\\]") },
                { begin: p2("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  // could be a comment in many languages so do not count
                  // as relevant
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                // prefix is optional with /regex/
                { begin: f("(?:m|qr)?", /\//, /\//) },
                // allow matching common delimiters
                { begin: f("m|qr", e.either(...d, { capture: true }), /\1/) },
                // allow common paired delmins
                { begin: f("m|qr", /\(/, /\)/) },
                { begin: f("m|qr", /\[/, /\]/) },
                { begin: f("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [t2.TITLE_MODE, a]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [t2.TITLE_MODE, a, c2]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      return i.contains = h2, s.contains = h2, {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: o,
        contains: h2
      };
    }
    function AO(t2) {
      const e = t2.regex, n = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
        n
      ), o = e.concat(
        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
        n
      ), i = e.concat(
        /[A-Z]+/,
        n
      ), s = {
        scope: "variable",
        match: "\\$+" + r
      }, a = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          // boost for obvious PHP
          { begin: /<\?=/ },
          // less relevant per PSR-1 which says not to use short-tags
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
          // end php tag
        ]
      }, l = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      }, c2 = t2.inherit(t2.APOS_STRING_MODE, { illegal: null }), u = t2.inherit(t2.QUOTE_STRING_MODE, {
        illegal: null,
        contains: t2.QUOTE_STRING_MODE.contains.concat(l)
      }), d = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: t2.QUOTE_STRING_MODE.contains.concat(l),
        "on:begin": (Ee, fe) => {
          fe.data._beginMatch = Ee[1] || Ee[2];
        },
        "on:end": (Ee, fe) => {
          fe.data._beginMatch !== Ee[1] && fe.ignoreMatch();
        }
      }, p2 = t2.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      }), f = `[ 	
]`, h2 = {
        scope: "string",
        variants: [
          u,
          c2,
          d,
          p2
        ]
      }, m = {
        scope: "number",
        variants: [
          { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
          // Binary w/ underscore support
          { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
          // Octals w/ underscore support
          { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
          // Hex w/ underscore support
          // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
          { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
        ],
        relevance: 0
      }, g = [
        "false",
        "null",
        "true"
      ], b = [
        // Magic constants:
        // <https://www.php.net/manual/en/language.constants.predefined.php>
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        // Function that look like language construct or language construct that look like function:
        // List of keywords that may not require parenthesis
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
        // Other keywords:
        // <https://www.php.net/manual/en/reserved.php>
        // <https://www.php.net/manual/en/language.types.type-juggling.php>
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ], E = [
        // Standard PHP library:
        // <https://www.php.net/manual/en/book.spl.php>
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        // Reserved interfaces:
        // <https://www.php.net/manual/en/reserved.interfaces.php>
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        // Reserved classes:
        // <https://www.php.net/manual/en/reserved.classes.php>
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ], v = {
        keyword: b,
        literal: ((Ee) => {
          const fe = [];
          return Ee.forEach((he) => {
            fe.push(he), he.toLowerCase() === he ? fe.push(he.toUpperCase()) : fe.push(he.toLowerCase());
          }), fe;
        })(g),
        built_in: E
      }, T = (Ee) => Ee.map((fe) => fe.replace(/\|\d+$/, "")), S = { variants: [
        {
          match: [
            /new/,
            e.concat(f, "+"),
            // to prevent built ins from being confused as the class constructor call
            e.concat("(?!", T(E).join("\\b|"), "\\b)"),
            o
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] }, F = e.concat(r, "\\b(?!\\()"), V = { variants: [
        {
          match: [
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            F
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            o,
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            F
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            o,
            e.concat(
              "::",
              e.lookahead(/(?!class\b)/)
            )
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            o,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] }, L = {
        scope: "attr",
        match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
      }, W = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: [
          L,
          s,
          V,
          t2.C_BLOCK_COMMENT_MODE,
          h2,
          m,
          S
        ]
      }, te = {
        relevance: 0,
        match: [
          /\b/,
          // to prevent keywords from being confused as the function title
          e.concat("(?!fn\\b|function\\b|", T(b).join("\\b|"), "|", T(E).join("\\b|"), "\\b)"),
          r,
          e.concat(f, "*"),
          e.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [W]
      };
      W.contains.push(te);
      const de = [
        L,
        V,
        t2.C_BLOCK_COMMENT_MODE,
        h2,
        m,
        S
      ], ke = {
        begin: e.concat(
          /#\[\s*\\?/,
          e.either(
            o,
            i
          )
        ),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: g,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: g,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...de
            ]
          },
          ...de,
          {
            scope: "meta",
            variants: [
              { match: o },
              { match: i }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: v,
        contains: [
          ke,
          t2.HASH_COMMENT_MODE,
          t2.COMMENT("//", "$"),
          t2.COMMENT(
            "/\\*",
            "\\*/",
            { contains: [
              {
                scope: "doctag",
                match: "@[A-Za-z]+"
              }
            ] }
          ),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: t2.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          a,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          s,
          te,
          V,
          {
            match: [
              /const/,
              /\s/,
              r
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          S,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              t2.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                // No markup, just a relevance booster
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: v,
                contains: [
                  "self",
                  ke,
                  s,
                  V,
                  t2.C_BLOCK_COMMENT_MODE,
                  h2,
                  m
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              t2.UNDERSCORE_TITLE_MODE
            ]
          },
          // both use and namespace still use "old style" rules (vs multi-match)
          // because the namespace name can include `\` and we still want each
          // element to be treated as its own *individual* title
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [t2.inherit(t2.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              // TODO: title.function vs title.class
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              // TODO: could be title.class or title.function
              t2.UNDERSCORE_TITLE_MODE
            ]
          },
          h2,
          m
        ]
      };
    }
    function MO(t2) {
      return {
        name: "PHP template",
        subLanguage: "xml",
        contains: [
          {
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [
              // We don't want the php closing tag ?> to close the PHP block when
              // inside any of the following blocks:
              {
                begin: "/\\*",
                end: "\\*/",
                skip: true
              },
              {
                begin: 'b"',
                end: '"',
                skip: true
              },
              {
                begin: "b'",
                end: "'",
                skip: true
              },
              t2.inherit(t2.APOS_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              }),
              t2.inherit(t2.QUOTE_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              })
            ]
          }
        ]
      };
    }
    function RO(t2) {
      return {
        name: "Plain text",
        aliases: [
          "text",
          "txt"
        ],
        disableAutodetect: true
      };
    }
    function IO(t2) {
      const e = t2.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ], a = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: r,
        built_in: [
          "__import__",
          "abs",
          "all",
          "any",
          "ascii",
          "bin",
          "bool",
          "breakpoint",
          "bytearray",
          "bytes",
          "callable",
          "chr",
          "classmethod",
          "compile",
          "complex",
          "delattr",
          "dict",
          "dir",
          "divmod",
          "enumerate",
          "eval",
          "exec",
          "filter",
          "float",
          "format",
          "frozenset",
          "getattr",
          "globals",
          "hasattr",
          "hash",
          "help",
          "hex",
          "id",
          "input",
          "int",
          "isinstance",
          "issubclass",
          "iter",
          "len",
          "list",
          "locals",
          "map",
          "max",
          "memoryview",
          "min",
          "next",
          "object",
          "oct",
          "open",
          "ord",
          "pow",
          "print",
          "property",
          "range",
          "repr",
          "reversed",
          "round",
          "set",
          "setattr",
          "slice",
          "sorted",
          "staticmethod",
          "str",
          "sum",
          "super",
          "tuple",
          "type",
          "vars",
          "zip"
        ],
        literal: [
          "__debug__",
          "Ellipsis",
          "False",
          "None",
          "NotImplemented",
          "True"
        ],
        type: [
          "Any",
          "Callable",
          "Coroutine",
          "Dict",
          "List",
          "Literal",
          "Generic",
          "Optional",
          "Sequence",
          "Set",
          "Tuple",
          "Type",
          "Union"
        ]
      }, l = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      }, c2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: a,
        illegal: /#/
      }, u = {
        begin: /\{\{/,
        relevance: 0
      }, d = {
        className: "string",
        contains: [t2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      }, p2 = "[0-9](_?[0-9])*", f = `(\\b(${p2}))?\\.(${p2})|\\b(${p2})\\.`, h2 = `\\b|${r.join("|")}`, m = {
        className: "number",
        relevance: 0,
        variants: [
          // exponentfloat, pointfloat
          // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
          // optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          // Note: no leading \b because floats can start with a decimal point
          // and we don't want to mishandle e.g. `fn(.5)`,
          // no trailing \b for pointfloat because it can end with a decimal point
          // and we don't want to mishandle e.g. `0..hex()`; this should be safe
          // because both MUST contain a decimal point and so cannot be confused with
          // the interior part of an identifier
          {
            begin: `(\\b(${p2})|(${f}))[eE][+-]?(${p2})[jJ]?(?=${h2})`
          },
          {
            begin: `(${f})[jJ]?`
          },
          // decinteger, bininteger, octinteger, hexinteger
          // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
          // optionally "long" in Python 2
          // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
          // decinteger is optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h2})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${h2})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h2})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h2})`
          },
          // imagnumber (digitpart-based)
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b(${p2})[jJ](?=${h2})`
          }
        ]
      }, g = {
        className: "comment",
        begin: e.lookahead(/# type:/),
        end: /$/,
        keywords: a,
        contains: [
          {
            // prevent keywords from coloring `type`
            begin: /# type:/
          },
          // comment within a datatype comment includes no keywords
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      }, b = {
        className: "params",
        variants: [
          // Exclude params in functions without params
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: a,
            contains: [
              "self",
              l,
              m,
              d,
              t2.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      return c2.contains = [
        d,
        m,
        l
      ], {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: a,
        illegal: /(<\/|\?)|=>/,
        contains: [
          l,
          m,
          {
            // very common convention
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            // eat "if" prior to string so that it won't accidentally be
            // labeled as an f-string
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          d,
          g,
          t2.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              n
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [b]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  n,
                  /\s*/,
                  /\(\s*/,
                  n,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  n
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              m,
              b,
              d
            ]
          }
        ]
      };
    }
    function DO(t2) {
      return {
        aliases: ["pycon"],
        contains: [
          {
            className: "meta.prompt",
            starts: {
              // a space separates the REPL prefix from the actual code
              // this is purely for cleaner HTML output
              end: / |$/,
              starts: {
                end: "$",
                subLanguage: "python"
              }
            },
            variants: [
              { begin: /^>>>(?=[ ]|$)/ },
              { begin: /^\.\.\.(?=[ ]|$)/ }
            ]
          }
        ]
      };
    }
    function LO(t2) {
      const e = t2.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(
        // Special case: only hexadecimal binary powers can contain fractions
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        // Hexadecimal numbers without fraction and optional binary power
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        // Decimal numbers
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ), o = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, i = e.either(
        /[()]/,
        /[{}]/,
        /\[\[/,
        /[[\]]/,
        /\\/,
        /,/
      );
      return {
        name: "R",
        keywords: {
          $pattern: n,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: (
            // Builtin constants
            "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          )
        },
        contains: [
          // Roxygen comments
          t2.COMMENT(
            /#'/,
            /$/,
            { contains: [
              {
                // Handle `@examples` separately to cause all subsequent code
                // until the next `@`-tag on its own line to be kept as-is,
                // preventing highlighting. This code is example R code, so nested
                // doctags shouldn’t be treated as such. See
                // `test/markup/r/roxygen.txt` for an example.
                scope: "doctag",
                match: /@examples/,
                starts: {
                  end: e.lookahead(e.either(
                    // end if another doc comment
                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                    // or a line with no comment
                    /\n^(?!#')/
                  )),
                  endsParent: true
                }
              },
              {
                // Handle `@param` to highlight the parameter name following
                // after.
                scope: "doctag",
                begin: "@param",
                end: /$/,
                contains: [
                  {
                    scope: "variable",
                    variants: [
                      { match: n },
                      { match: /`(?:\\.|[^`\\])+`/ }
                    ],
                    endsParent: true
                  }
                ]
              },
              {
                scope: "doctag",
                match: /@[a-zA-Z]+/
              },
              {
                scope: "keyword",
                match: /\\[a-zA-Z]+/
              }
            ] }
          ),
          t2.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [t2.BACKSLASH_ESCAPE],
            variants: [
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          // Matching numbers immediately following punctuation and operators is
          // tricky since we need to look at the character ahead of a number to
          // ensure the number is not part of an identifier, and we cannot use
          // negative look-behind assertions. So instead we explicitly handle all
          // possible combinations of (operator|punctuation), number.
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  o,
                  r
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  r
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  i,
                  r
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  // not part of an identifier, or start of document
                  r
                ]
              }
            ]
          },
          // Operators/punctuation when they're not directly followed by numbers
          {
            // Relevance boost for the most common assignment form.
            scope: { 3: "operator" },
            match: [
              n,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: o },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: i
          },
          {
            // Escaped identifier
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    function PO(t2) {
      const e = t2.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
        /\b([A-Z]+[a-z0-9]+)+/,
        // ends in caps
        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
      ), o = e.concat(r, /(::\w+)*/), s = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...[
            "include",
            "extend",
            "prepend",
            "public",
            "private",
            "protected",
            "raise",
            "throw"
          ]
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      }, a = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      }, l = {
        begin: "#<",
        end: ">"
      }, c2 = [
        t2.COMMENT(
          "#",
          "$",
          { contains: [a] }
        ),
        t2.COMMENT(
          "^=begin",
          "^=end",
          {
            contains: [a],
            relevance: 10
          }
        ),
        t2.COMMENT("^__END__", t2.MATCH_NOTHING_RE)
      ], u = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: s
      }, d = {
        className: "string",
        contains: [
          t2.BACKSLASH_ESCAPE,
          u
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
          // where ? is the last character of a preceding identifier, as in: `func?4`
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          // heredocs
          {
            // this guard makes sure that we have an entire heredoc and not a false
            // positive (auto-detect, etc.)
            begin: e.concat(
              /<<[-~]?'?/,
              e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
            ),
            contains: [
              t2.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  t2.BACKSLASH_ESCAPE,
                  u
                ]
              })
            ]
          }
        ]
      }, p2 = "[1-9](_?[0-9])*|0", f = "[0-9](_?[0-9])*", h2 = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal integer/float, optionally exponential or rational, optionally imaginary
          { begin: `\\b(${p2})(\\.(${f}))?([eE][+-]?(${f})|r)?i?\\b` },
          // explicit decimal/binary/octal/hexadecimal integer,
          // optionally rational and/or imaginary
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          // 0-prefixed implicit octal integer, optionally rational and/or imaginary
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      }, m = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: s
          }
        ]
      }, S = [
        d,
        {
          variants: [
            {
              match: [
                /class\s+/,
                o,
                /\s+<\s+/,
                o
              ]
            },
            {
              match: [
                /\b(class|module)\s+/,
                o
              ]
            }
          ],
          scope: {
            2: "title.class",
            4: "title.class.inherited"
          },
          keywords: s
        },
        {
          match: [
            /(include|extend)\s+/,
            o
          ],
          scope: {
            2: "title.class"
          },
          keywords: s
        },
        {
          relevance: 0,
          match: [
            o,
            /\.new[. (]/
          ],
          scope: {
            1: "title.class"
          }
        },
        {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        },
        {
          relevance: 0,
          match: r,
          scope: "title.class"
        },
        {
          match: [
            /def/,
            /\s+/,
            n
          ],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [
            m
          ]
        },
        {
          // swallow namespace qualifiers before symbols
          begin: t2.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: t2.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            d,
            { begin: n }
          ],
          relevance: 0
        },
        h2,
        {
          // negative-look forward attempts to prevent false matches like:
          // @ident@ or $ident$ that might indicate this is not ruby at all
          className: "variable",
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          // this could be a lot of things (in other languages) other than params
          keywords: s
        },
        {
          // regexp container
          begin: "(" + t2.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                t2.BACKSLASH_ESCAPE,
                u
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(l, c2),
          relevance: 0
        }
      ].concat(l, c2);
      u.contains = S, m.contains = S;
      const W = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: S
          }
        },
        {
          className: "meta.prompt",
          begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
          starts: {
            end: "$",
            keywords: s,
            contains: S
          }
        }
      ];
      return c2.unshift(l), {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: s,
        illegal: /\/\*/,
        contains: [t2.SHEBANG({ binary: "ruby" })].concat(W).concat(c2).concat(S)
      };
    }
    function BO(t2) {
      const e = t2.regex, n = /(r#)?/, r = e.concat(n, t2.UNDERSCORE_IDENT_RE), o = e.concat(n, t2.IDENT_RE), i = {
        className: "title.function.invoke",
        relevance: 0,
        begin: e.concat(
          /\b/,
          /(?!let|for|while|if|else|match\b)/,
          o,
          e.lookahead(/\s*\(/)
        )
      }, s = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ], l = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ], c2 = [
        // functions
        "drop ",
        // traits
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        // macros
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ], u = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: t2.IDENT_RE + "!?",
          type: u,
          keyword: a,
          literal: l,
          built_in: c2
        },
        illegal: "</",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          t2.inherit(t2.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            // negative lookahead to avoid matching `'`
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + s },
              { begin: "\\b0o([0-7_]+)" + s },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  t2.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              r
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          // must come before impl/for rule later
          {
            begin: [
              /for/,
              /\s+/,
              r,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: t2.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: c2,
              type: u
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          i
        ]
      };
    }
    const $O = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), FO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], zO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], HO = [
      ...FO,
      ...zO
    ], UO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), VO = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), WO = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), KO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function qO(t2) {
      const e = $O(t2), n = WO, r = VO, o = "@[a-z-]+", i = "and or not only", a = {
        className: "variable",
        begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          e.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          },
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-tag",
            begin: "\\b(" + HO.join("|") + ")\\b",
            // was there, before, but why?
            relevance: 0
          },
          {
            className: "selector-pseudo",
            begin: ":(" + r.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + n.join("|") + ")"
          },
          a,
          {
            // pseudo-selector params
            begin: /\(/,
            end: /\)/,
            contains: [e.CSS_NUMBER_MODE]
          },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + KO.join("|") + ")\\b"
          },
          { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
          {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [
              e.BLOCK_COMMENT,
              a,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE,
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              e.IMPORTANT,
              e.FUNCTION_DISPATCH
            ]
          },
          // matching these here allows us to treat them more like regular CSS
          // rules so everything between the {} gets regular rule highlighting,
          // which is what we want for page and font-face
          {
            begin: "@(page|font-face)",
            keywords: {
              $pattern: o,
              keyword: "@page @font-face"
            }
          },
          {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: UO.join(" ")
            },
            contains: [
              {
                begin: o,
                className: "keyword"
              },
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              a,
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE
            ]
          },
          e.FUNCTION_DISPATCH
        ]
      };
    }
    function GO(t2) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
            // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
            // echo /path/to/home > t.exe
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    function jO(t2) {
      const e = t2.regex, n = t2.COMMENT("--", "$"), r = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      }, o = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      }, i = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ], s = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ], a = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        // modifier (character varying)
        "varbinary"
      ], l = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ], c2 = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ], u = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ], d = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ], p2 = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ], f = u, h2 = [
        ...c2,
        ...l
      ].filter((T) => !u.includes(T)), m = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      }, g = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      }, b = {
        match: e.concat(/\b/, e.either(...f), /\s*\(/),
        relevance: 0,
        keywords: { built_in: f }
      };
      function E(T) {
        return e.concat(
          /\b/,
          e.either(...T.map((S) => S.replace(/\s+/, "\\s+"))),
          /\b/
        );
      }
      const _ = {
        scope: "keyword",
        match: E(p2),
        relevance: 0
      };
      function v(T, {
        exceptions: S,
        when: F
      } = {}) {
        const V = F;
        return S = S || [], T.map((L) => L.match(/\|\d+$/) || S.includes(L) ? L : V(L) ? `${L}|0` : L);
      }
      return {
        name: "SQL",
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: v(h2, { when: (T) => T.length < 3 }),
          literal: i,
          type: a,
          built_in: d
        },
        contains: [
          {
            scope: "type",
            match: E(s)
          },
          _,
          b,
          m,
          r,
          o,
          t2.C_NUMBER_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          n,
          g
        ]
      };
    }
    function hg(t2) {
      return t2 ? typeof t2 == "string" ? t2 : t2.source : null;
    }
    function Xo(t2) {
      return Ge("(?=", t2, ")");
    }
    function Ge(...t2) {
      return t2.map((n) => hg(n)).join("");
    }
    function YO(t2) {
      const e = t2[t2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (t2.splice(t2.length - 1, 1), e) : {};
    }
    function Gt(...t2) {
      return "(" + (YO(t2).capture ? "" : "?:") + t2.map((r) => hg(r)).join("|") + ")";
    }
    const gu = (t2) => Ge(
      /\b/,
      t2,
      /\w$/.test(t2) ? /\b/ : /\B/
    ), JO = [
      "Protocol",
      // contextual
      "Type"
      // contextual
    ].map(gu), Wp = [
      "init",
      "self"
    ].map(gu), XO = [
      "Any",
      "Self"
    ], Tl = [
      // strings below will be fed into the regular `keywords` engine while regex
      // will result in additional modes being created to scan for those keywords to
      // avoid conflicts with other rules
      "actor",
      "any",
      // contextual
      "associatedtype",
      "async",
      "await",
      /as\?/,
      // operator
      /as!/,
      // operator
      "as",
      // operator
      "borrowing",
      // contextual
      "break",
      "case",
      "catch",
      "class",
      "consume",
      // contextual
      "consuming",
      // contextual
      "continue",
      "convenience",
      // contextual
      "copy",
      // contextual
      "default",
      "defer",
      "deinit",
      "didSet",
      // contextual
      "distributed",
      "do",
      "dynamic",
      // contextual
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      // contextual
      "for",
      "func",
      "get",
      // contextual
      "guard",
      "if",
      "import",
      "indirect",
      // contextual
      "infix",
      // contextual
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      // operator
      "isolated",
      // contextual
      "nonisolated",
      // contextual
      "lazy",
      // contextual
      "let",
      "macro",
      "mutating",
      // contextual
      "nonmutating",
      // contextual
      /open\(set\)/,
      // contextual
      "open",
      // contextual
      "operator",
      "optional",
      // contextual
      "override",
      // contextual
      "package",
      "postfix",
      // contextual
      "precedencegroup",
      "prefix",
      // contextual
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      // contextual
      "rethrows",
      "return",
      "set",
      // contextual
      "some",
      // contextual
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      // operator
      /try!/,
      // operator
      "try",
      // operator
      "typealias",
      /unowned\(safe\)/,
      // contextual
      /unowned\(unsafe\)/,
      // contextual
      "unowned",
      // contextual
      "var",
      "weak",
      // contextual
      "where",
      "while",
      "willSet"
      // contextual
    ], Kp = [
      "false",
      "nil",
      "true"
    ], ZO = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ], QO = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ], qp = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ], mg = Gt(
      /[/=\-+!*%<>&|^~?]/,
      /[\u00A1-\u00A7]/,
      /[\u00A9\u00AB]/,
      /[\u00AC\u00AE]/,
      /[\u00B0\u00B1]/,
      /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
      /[\u2016-\u2017]/,
      /[\u2020-\u2027]/,
      /[\u2030-\u203E]/,
      /[\u2041-\u2053]/,
      /[\u2055-\u205E]/,
      /[\u2190-\u23FF]/,
      /[\u2500-\u2775]/,
      /[\u2794-\u2BFF]/,
      /[\u2E00-\u2E7F]/,
      /[\u3001-\u3003]/,
      /[\u3008-\u3020]/,
      /[\u3030]/
    ), gg = Gt(
      mg,
      /[\u0300-\u036F]/,
      /[\u1DC0-\u1DFF]/,
      /[\u20D0-\u20FF]/,
      /[\uFE00-\uFE0F]/,
      /[\uFE20-\uFE2F]/
      // TODO: The following characters are also allowed, but the regex isn't supported yet.
      // /[\u{E0100}-\u{E01EF}]/u
    ), Ol = Ge(mg, gg, "*"), bg = Gt(
      /[a-zA-Z_]/,
      /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
      /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
      /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
      /[\u1E00-\u1FFF]/,
      /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
      /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
      /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
      /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
      /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
      /[\uFE47-\uFEFE\uFF00-\uFFFD]/
      // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
      // The following characters are also allowed, but the regexes aren't supported yet.
      // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
      // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
      // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
      // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
    ), Zs = Gt(
      bg,
      /\d/,
      /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
    ), Hn = Ge(bg, Zs, "*"), bs = Ge(/[A-Z]/, Zs, "*"), eN = [
      "attached",
      "autoclosure",
      Ge(/convention\(/, Gt("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      Ge(/objc\(/, Hn, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ], tN = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function nN(t2) {
      const e = {
        match: /\s+/,
        relevance: 0
      }, n = t2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: ["self"] }
      ), r = [
        t2.C_LINE_COMMENT_MODE,
        n
      ], o = {
        match: [
          /\./,
          Gt(...JO, ...Wp)
        ],
        className: { 2: "keyword" }
      }, i = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: Ge(/\./, Gt(...Tl)),
        relevance: 0
      }, s = Tl.filter((ve) => typeof ve == "string").concat(["_|0"]), a = Tl.filter((ve) => typeof ve != "string").concat(XO).map(gu), l = { variants: [
        {
          className: "keyword",
          match: Gt(...a, ...Wp)
        }
      ] }, c2 = {
        $pattern: Gt(
          /\b\w+/,
          // regular keywords
          /#\w+/
          // number keywords
        ),
        keyword: s.concat(QO),
        literal: Kp
      }, u = [
        o,
        i,
        l
      ], d = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: Ge(/\./, Gt(...qp)),
        relevance: 0
      }, p2 = {
        className: "built_in",
        match: Ge(/\b/, Gt(...qp), /(?=\()/)
      }, f = [
        d,
        p2
      ], h2 = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
      }, m = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: Ol },
          {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: `\\.(\\.|${gg})+`
          }
        ]
      }, g = [
        h2,
        m
      ], b = "([0-9]_*)+", E = "([0-9a-fA-F]_*)+", _ = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal floating-point-literal (subsumes decimal-literal)
          { match: `\\b(${b})(\\.(${b}))?([eE][+-]?(${b}))?\\b` },
          // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
          { match: `\\b0x(${E})(\\.(${E}))?([pP][+-]?(${b}))?\\b` },
          // octal-literal
          { match: /\b0o([0-7]_*)+\b/ },
          // binary-literal
          { match: /\b0b([01]_*)+\b/ }
        ]
      }, v = (ve = "") => ({
        className: "subst",
        variants: [
          { match: Ge(/\\/, ve, /[0\\tnr"']/) },
          { match: Ge(/\\/, ve, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      }), T = (ve = "") => ({
        className: "subst",
        match: Ge(/\\/, ve, /[\t ]*(?:[\r\n]|\r\n)/)
      }), S = (ve = "") => ({
        className: "subst",
        label: "interpol",
        begin: Ge(/\\/, ve, /\(/),
        end: /\)/
      }), F = (ve = "") => ({
        begin: Ge(ve, /"""/),
        end: Ge(/"""/, ve),
        contains: [
          v(ve),
          T(ve),
          S(ve)
        ]
      }), V = (ve = "") => ({
        begin: Ge(ve, /"/),
        end: Ge(/"/, ve),
        contains: [
          v(ve),
          S(ve)
        ]
      }), L = {
        className: "string",
        variants: [
          F(),
          F("#"),
          F("##"),
          F("###"),
          V(),
          V("#"),
          V("##"),
          V("###")
        ]
      }, W = [
        t2.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [t2.BACKSLASH_ESCAPE]
        }
      ], te = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: W
      }, de = (ve) => {
        const Xt = Ge(ve, /\//), Bt = Ge(/\//, ve);
        return {
          begin: Xt,
          end: Bt,
          contains: [
            ...W,
            {
              scope: "comment",
              begin: `#(?!.*${Bt})`,
              end: /$/
            }
          ]
        };
      }, ke = {
        scope: "regexp",
        variants: [
          de("###"),
          de("##"),
          de("#"),
          te
        ]
      }, Ee = { match: Ge(/`/, Hn, /`/) }, fe = {
        className: "variable",
        match: /\$\d+/
      }, he = {
        className: "variable",
        match: `\\$${Zs}+`
      }, N = [
        Ee,
        fe,
        he
      ], D = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: tN,
            contains: [
              ...g,
              _,
              L
            ]
          }
        ] }
      }, Y = {
        scope: "keyword",
        match: Ge(/@/, Gt(...eN), Xo(Gt(/\(/, /\s+/)))
      }, oe = {
        scope: "meta",
        match: Ge(/@/, Hn)
      }, ce = [
        D,
        Y,
        oe
      ], Se = {
        match: Xo(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            // Common Apple frameworks, for relevance boost
            className: "type",
            match: Ge(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Zs, "+")
          },
          {
            // Type identifier
            className: "type",
            match: bs,
            relevance: 0
          },
          {
            // Optional type
            match: /[?!]+/,
            relevance: 0
          },
          {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
          },
          {
            // Protocol composition
            match: Ge(/\s+&\s+/, Xo(bs)),
            relevance: 0
          }
        ]
      }, Fe = {
        begin: /</,
        end: />/,
        keywords: c2,
        contains: [
          ...r,
          ...u,
          ...ce,
          h2,
          Se
        ]
      };
      Se.contains.push(Fe);
      const kt = {
        match: Ge(Hn, /\s*:/),
        keywords: "_|0",
        relevance: 0
      }, ze = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: c2,
        contains: [
          "self",
          kt,
          ...r,
          ke,
          ...u,
          ...f,
          ...g,
          _,
          L,
          ...N,
          ...ce,
          Se
        ]
      }, Qe = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...r,
          Se
        ]
      }, on2 = {
        begin: Gt(
          Xo(Ge(Hn, /\s*:/)),
          Xo(Ge(Hn, /\s+/, Hn, /\s*:/))
        ),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: Hn
          }
        ]
      }, Nt = {
        begin: /\(/,
        end: /\)/,
        keywords: c2,
        contains: [
          on2,
          ...r,
          ...u,
          ...g,
          _,
          L,
          ...ce,
          Se,
          ze
        ],
        endsParent: true,
        illegal: /["']/
      }, hn = {
        match: [
          /(func|macro)/,
          /\s+/,
          Gt(Ee.match, Hn, Ol)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          Qe,
          Nt,
          e
        ],
        illegal: [
          /\[/,
          /%/
        ]
      }, At = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          Qe,
          Nt,
          e
        ],
        illegal: /\[|%/
      }, mn = {
        match: [
          /operator/,
          /\s+/,
          Ol
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      }, $n = {
        begin: [
          /precedencegroup/,
          /\s+/,
          bs
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [Se],
        keywords: [
          ...ZO,
          ...Kp
        ],
        end: /}/
      }, On = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      }, sn = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      }, Nn = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          Hn,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: c2,
        contains: [
          Qe,
          ...u,
          {
            begin: /:/,
            end: /\{/,
            keywords: c2,
            contains: [
              {
                scope: "title.class.inherited",
                match: bs
              },
              ...u
            ],
            relevance: 0
          }
        ]
      };
      for (const ve of L.variants) {
        const Xt = ve.contains.find((le) => le.label === "interpol");
        Xt.keywords = c2;
        const Bt = [
          ...u,
          ...f,
          ...g,
          _,
          L,
          ...N
        ];
        Xt.contains = [
          ...Bt,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...Bt
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: c2,
        contains: [
          ...r,
          hn,
          At,
          On,
          sn,
          Nn,
          mn,
          $n,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...r],
            relevance: 0
          },
          ke,
          ...u,
          ...f,
          ...g,
          _,
          L,
          ...N,
          ...ce,
          Se,
          ze
        ]
      };
    }
    const Qs = "[A-Za-z$_][0-9A-Za-z$_]*", yg = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], vg = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], Eg = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], kg = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], wg = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], _g = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], Sg = [].concat(
      wg,
      Eg,
      kg
    );
    function rN(t2) {
      const e = t2.regex, n = (D, { after: Y }) => {
        const oe = "</" + D[0].slice(1);
        return D.input.indexOf(oe, Y) !== -1;
      }, r = Qs, o = {
        begin: "<>",
        end: "</>"
      }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (D, Y) => {
          const oe = D[0].length + D.index, ce = D.input[oe];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ce === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ce === ","
          ) {
            Y.ignoreMatch();
            return;
          }
          ce === ">" && (n(D, { after: oe }) || Y.ignoreMatch());
          let Se;
          const Fe = D.input.substring(oe);
          if (Se = Fe.match(/^\s*=/)) {
            Y.ignoreMatch();
            return;
          }
          if ((Se = Fe.match(/^\s+extends\s+/)) && Se.index === 0) {
            Y.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: Qs,
        keyword: yg,
        literal: vg,
        built_in: Sg,
        "variable.language": _g
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, f = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, h2 = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, m = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, g = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          t2.BACKSLASH_ESCAPE,
          p2
        ]
      }, E = {
        className: "comment",
        variants: [
          t2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: r + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_LINE_COMMENT_MODE
        ]
      }, _ = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        f,
        h2,
        m,
        g,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = _.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(_)
      });
      const v = [].concat(E, p2.contains), T = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: T
      }, F = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              r,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(r, "(", e.concat(/\./, r), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              r
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, V = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...Eg,
            ...kg
          ]
        }
      }, L = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, W = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              r,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, te = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function de(D) {
        return e.concat("(?!", D.join("|"), ")");
      }
      const ke = {
        match: e.concat(
          /\b/,
          de([
            ...wg,
            "super",
            "import"
          ].map((D) => `${D}\\s*\\(`)),
          r,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, Ee = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(r, /(?![0-9A-Za-z$_(])/)
        )),
        end: r,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, fe = {
        match: [
          /get|set/,
          /\s+/,
          r,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          r,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: T, CLASS_REFERENCE: V },
        illegal: /#(?![$_A-z])/,
        contains: [
          t2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          L,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          f,
          h2,
          m,
          g,
          E,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          V,
          {
            scope: "attr",
            match: r + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + t2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              E,
              t2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: t2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: T
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: o.begin, end: o.end },
                  { match: i },
                  {
                    begin: s.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": s.isTrulyOpeningTag,
                    end: s.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: s.begin,
                    end: s.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          W,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + t2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              t2.inherit(t2.TITLE_MODE, { begin: r, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          Ee,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + r,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ke,
          te,
          F,
          fe,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function oN(t2) {
      const e = t2.regex, n = rN(t2), r = Qs, o = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ], i = {
        begin: [
          /namespace/,
          /\s+/,
          t2.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      }, s = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: o
        },
        contains: [n.exports.CLASS_REFERENCE]
      }, a = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      }, l = [
        "type",
        // "namespace",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ], c2 = {
        $pattern: Qs,
        keyword: yg.concat(l),
        literal: vg,
        built_in: Sg.concat(o),
        "variable.language": _g
      }, u = {
        className: "meta",
        begin: "@" + r
      }, d = (m, g, b) => {
        const E = m.contains.findIndex((_) => _.label === g);
        if (E === -1)
          throw new Error("can not find mode to replace");
        m.contains.splice(E, 1, b);
      };
      Object.assign(n.keywords, c2), n.exports.PARAMS_CONTAINS.push(u);
      const p2 = n.contains.find((m) => m.scope === "attr"), f = Object.assign(
        {},
        p2,
        { match: e.concat(r, e.lookahead(/\s*\?:/)) }
      );
      n.exports.PARAMS_CONTAINS.push([
        n.exports.CLASS_REFERENCE,
        // class reference for highlighting the params types
        p2,
        // highlight the params key
        f
        // Added for optional property assignment highlighting
      ]), n.contains = n.contains.concat([
        u,
        i,
        s,
        f
        // Added for optional property assignment highlighting
      ]), d(n, "shebang", t2.SHEBANG()), d(n, "use_strict", a);
      const h2 = n.contains.find((m) => m.label === "func.def");
      return h2.relevance = 0, Object.assign(n, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      }), n;
    }
    function iN(t2) {
      const e = t2.regex, n = {
        className: "string",
        begin: /"(""|[^/n])"C\b/
      }, r = {
        className: "string",
        begin: /"/,
        end: /"/,
        illegal: /\n/,
        contains: [
          {
            // double quote escape
            begin: /""/
          }
        ]
      }, o = /\d{1,2}\/\d{1,2}\/\d{4}/, i = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
        className: "literal",
        variants: [
          {
            // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
            begin: e.concat(/# */, e.either(i, o), / *#/)
          },
          {
            // #H:mm[:ss]# (24h Time)
            begin: e.concat(/# */, a, / *#/)
          },
          {
            // #h[:mm[:ss]] A# (12h Time)
            begin: e.concat(/# */, s, / *#/)
          },
          {
            // date plus time
            begin: e.concat(
              /# */,
              e.either(i, o),
              / +/,
              e.either(s, a),
              / *#/
            )
          }
        ]
      }, c2 = {
        className: "number",
        relevance: 0,
        variants: [
          {
            // Float
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          },
          {
            // Integer (base 10)
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 16)
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 8)
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 2)
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }
        ]
      }, u = {
        className: "label",
        begin: /^\w+:/
      }, d = t2.COMMENT(/'''/, /$/, { contains: [
        {
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }
      ] }), p2 = t2.COMMENT(null, /$/, { variants: [
        { begin: /'/ },
        {
          // TODO: Use multi-class for leading spaces
          begin: /([\t ]|^)REM(?=\s)/
        }
      ] });
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: { label: "symbol" },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: (
            // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
            "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
          ),
          type: (
            // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
            "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
          ),
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [
          n,
          r,
          l,
          c2,
          u,
          d,
          p2,
          {
            className: "meta",
            // TODO: Use multi-class for indentation once available
            begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
            end: /$/,
            keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
            contains: [p2]
          }
        ]
      };
    }
    function sN(t2) {
      t2.regex;
      const e = t2.COMMENT(/\(;/, /;\)/);
      e.contains.push("self");
      const n = t2.COMMENT(/;;/, /$/), r = [
        "anyfunc",
        "block",
        "br",
        "br_if",
        "br_table",
        "call",
        "call_indirect",
        "data",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "func",
        "global.get",
        "global.set",
        "local.get",
        "local.set",
        "local.tee",
        "get_global",
        "get_local",
        "global",
        "if",
        "import",
        "local",
        "loop",
        "memory",
        "memory.grow",
        "memory.size",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "return",
        "select",
        "set_global",
        "set_local",
        "start",
        "table",
        "tee_local",
        "then",
        "type",
        "unreachable"
      ], o = {
        begin: [
          /(?:func|call|call_indirect)/,
          /\s+/,
          /\$[^\s)]+/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      }, i = {
        className: "variable",
        begin: /\$[\w_]+/
      }, s = {
        match: /(\((?!;)|\))+/,
        className: "punctuation",
        relevance: 0
      }, a = {
        className: "number",
        relevance: 0,
        // borrowed from Prism, TODO: split out into variants
        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
      }, l = {
        // look-ahead prevents us from gobbling up opcodes
        match: /(i32|i64|f32|f64)(?!\.)/,
        className: "type"
      }, c2 = {
        className: "keyword",
        // borrowed from Prism, TODO: split out into variants
        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
      };
      return {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: r
        },
        contains: [
          n,
          e,
          {
            match: [
              /(?:offset|align)/,
              /\s*/,
              /=/
            ],
            className: {
              1: "keyword",
              3: "operator"
            }
          },
          i,
          s,
          o,
          t2.QUOTE_STRING_MODE,
          l,
          c2,
          a
        ]
      };
    }
    function aN(t2) {
      const e = t2.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      }, i = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      }, s = t2.inherit(i, {
        begin: /\(/,
        end: /\)/
      }), a = t2.inherit(t2.APOS_STRING_MODE, { className: "string" }), l = t2.inherit(t2.QUOTE_STRING_MODE, { className: "string" }), c2 = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: r,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [o]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [o]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              i,
              l,
              a,
              s,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      i,
                      s,
                      l,
                      a
                    ]
                  }
                ]
              }
            ]
          },
          t2.COMMENT(
            /<!--/,
            /-->/,
            { relevance: 10 }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          o,
          // xml processing instructions
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  l
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending bracket.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [c2],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [c2],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: e.concat(
              /</,
              e.lookahead(e.concat(
                n,
                // <tag/>
                // <tag>
                // <tag ...
                e.either(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: n,
                relevance: 0,
                starts: c2
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: e.concat(
              /<\//,
              e.lookahead(e.concat(
                n,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: n,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    function lN(t2) {
      const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
        className: "attr",
        variants: [
          // added brackets support and special char support
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets and special char support
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets and special char support
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      }, o = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      }, i = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      }, s = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          t2.BACKSLASH_ESCAPE,
          o
        ]
      }, a = t2.inherit(s, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] }), p2 = {
        className: "number",
        begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
      }, f = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: e,
        relevance: 0
      }, h2 = {
        begin: /\{/,
        end: /\}/,
        contains: [f],
        illegal: "\\n",
        relevance: 0
      }, m = {
        begin: "\\[",
        end: "\\]",
        contains: [f],
        illegal: "\\n",
        relevance: 0
      }, g = [
        r,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + n
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + n + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + n
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + n
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + t2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + t2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        t2.HASH_COMMENT_MODE,
        {
          beginKeywords: e,
          keywords: { literal: e }
        },
        p2,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: t2.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        h2,
        m,
        i,
        s
      ], b = [...g];
      return b.pop(), b.push(a), f.contains = b, {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: g
      };
    }
    const cN = {
      arduino: W1,
      bash: K1,
      c: q1,
      cpp: G1,
      csharp: j1,
      css: rO,
      diff: oO,
      go: iO,
      graphql: sO,
      ini: aO,
      java: lO,
      javascript: fO,
      json: hO,
      kotlin: gO,
      less: SO,
      lua: CO,
      makefile: xO,
      markdown: TO,
      objectivec: OO,
      perl: NO,
      php: AO,
      "php-template": MO,
      plaintext: RO,
      python: IO,
      "python-repl": DO,
      r: LO,
      ruby: PO,
      rust: BO,
      scss: qO,
      shell: GO,
      sql: jO,
      swift: nN,
      typescript: oN,
      vbnet: iN,
      wasm: sN,
      xml: aN,
      yaml: lN
    };
    function uN(t2) {
      return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
    }
    var Nl, Gp;
    function dN() {
      if (Gp) return Nl;
      Gp = 1;
      function t2(k) {
        return k instanceof Map ? k.clear = k.delete = k.set = function() {
          throw new Error("map is read-only");
        } : k instanceof Set && (k.add = k.clear = k.delete = function() {
          throw new Error("set is read-only");
        }), Object.freeze(k), Object.getOwnPropertyNames(k).forEach((M) => {
          const U = k[M], me = typeof U;
          (me === "object" || me === "function") && !Object.isFrozen(U) && t2(U);
        }), k;
      }
      class e {
        /**
         * @param {CompiledMode} mode
         */
        constructor(M) {
          M.data === void 0 && (M.data = {}), this.data = M.data, this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function n(k) {
        return k.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function r(k, ...M) {
        const U = /* @__PURE__ */ Object.create(null);
        for (const me in k)
          U[me] = k[me];
        return M.forEach(function(me) {
          for (const rt in me)
            U[rt] = me[rt];
        }), /** @type {T} */
        U;
      }
      const o = "</span>", i = (k) => !!k.scope, s = (k, { prefix: M }) => {
        if (k.startsWith("language:"))
          return k.replace("language:", "language-");
        if (k.includes(".")) {
          const U = k.split(".");
          return [
            `${M}${U.shift()}`,
            ...U.map((me, rt) => `${me}${"_".repeat(rt + 1)}`)
          ].join(" ");
        }
        return `${M}${k}`;
      };
      class a {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(M, U) {
          this.buffer = "", this.classPrefix = U.classPrefix, M.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(M) {
          this.buffer += n(M);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(M) {
          if (!i(M)) return;
          const U = s(
            M.scope,
            { prefix: this.classPrefix }
          );
          this.span(U);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(M) {
          i(M) && (this.buffer += o);
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(M) {
          this.buffer += `<span class="${M}">`;
        }
      }
      const l = (k = {}) => {
        const M = { children: [] };
        return Object.assign(M, k), M;
      };
      class c2 {
        constructor() {
          this.rootNode = l(), this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(M) {
          this.top.children.push(M);
        }
        /** @param {string} scope */
        openNode(M) {
          const U = l({ scope: M });
          this.add(U), this.stack.push(U);
        }
        closeNode() {
          if (this.stack.length > 1)
            return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); ) ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(M) {
          return this.constructor._walk(M, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(M, U) {
          return typeof U == "string" ? M.addText(U) : U.children && (M.openNode(U), U.children.forEach((me) => this._walk(M, me)), M.closeNode(U)), M;
        }
        /**
         * @param {Node} node
         */
        static _collapse(M) {
          typeof M != "string" && M.children && (M.children.every((U) => typeof U == "string") ? M.children = [M.children.join("")] : M.children.forEach((U) => {
            c2._collapse(U);
          }));
        }
      }
      class u extends c2 {
        /**
         * @param {*} options
         */
        constructor(M) {
          super(), this.options = M;
        }
        /**
         * @param {string} text
         */
        addText(M) {
          M !== "" && this.add(M);
        }
        /** @param {string} scope */
        startScope(M) {
          this.openNode(M);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(M, U) {
          const me = M.root;
          U && (me.scope = `language:${U}`), this.add(me);
        }
        toHTML() {
          return new a(this, this.options).value();
        }
        finalize() {
          return this.closeAllNodes(), true;
        }
      }
      function d(k) {
        return k ? typeof k == "string" ? k : k.source : null;
      }
      function p2(k) {
        return m("(?=", k, ")");
      }
      function f(k) {
        return m("(?:", k, ")*");
      }
      function h2(k) {
        return m("(?:", k, ")?");
      }
      function m(...k) {
        return k.map((U) => d(U)).join("");
      }
      function g(k) {
        const M = k[k.length - 1];
        return typeof M == "object" && M.constructor === Object ? (k.splice(k.length - 1, 1), M) : {};
      }
      function b(...k) {
        return "(" + (g(k).capture ? "" : "?:") + k.map((me) => d(me)).join("|") + ")";
      }
      function E(k) {
        return new RegExp(k.toString() + "|").exec("").length - 1;
      }
      function _(k, M) {
        const U = k && k.exec(M);
        return U && U.index === 0;
      }
      const v = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function T(k, { joinWith: M }) {
        let U = 0;
        return k.map((me) => {
          U += 1;
          const rt = U;
          let et = d(me), ee = "";
          for (; et.length > 0; ) {
            const X = v.exec(et);
            if (!X) {
              ee += et;
              break;
            }
            ee += et.substring(0, X.index), et = et.substring(X.index + X[0].length), X[0][0] === "\\" && X[1] ? ee += "\\" + String(Number(X[1]) + rt) : (ee += X[0], X[0] === "(" && U++);
          }
          return ee;
        }).map((me) => `(${me})`).join(M);
      }
      const S = /\b\B/, F = "[a-zA-Z]\\w*", V = "[a-zA-Z_]\\w*", L = "\\b\\d+(\\.\\d+)?", W = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", te = "\\b(0b[01]+)", de = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ke = (k = {}) => {
        const M = /^#![ ]*\//;
        return k.binary && (k.begin = m(
          M,
          /.*\b/,
          k.binary,
          /\b.*/
        )), r({
          scope: "meta",
          begin: M,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (U, me) => {
            U.index !== 0 && me.ignoreMatch();
          }
        }, k);
      }, Ee = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      }, fe = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [Ee]
      }, he = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [Ee]
      }, N = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      }, D = function(k, M, U = {}) {
        const me = r(
          {
            scope: "comment",
            begin: k,
            end: M,
            contains: []
          },
          U
        );
        me.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const rt = b(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        return me.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: m(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              rt,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        ), me;
      }, Y = D("//", "$"), oe = D("/\\*", "\\*/"), ce = D("#", "$"), Se = {
        scope: "number",
        begin: L,
        relevance: 0
      }, Fe = {
        scope: "number",
        begin: W,
        relevance: 0
      }, kt = {
        scope: "number",
        begin: te,
        relevance: 0
      }, ze = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          Ee,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [Ee]
          }
        ]
      }, Qe = {
        scope: "title",
        begin: F,
        relevance: 0
      }, on2 = {
        scope: "title",
        begin: V,
        relevance: 0
      }, Nt = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + V,
        relevance: 0
      };
      var At = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: fe,
        BACKSLASH_ESCAPE: Ee,
        BINARY_NUMBER_MODE: kt,
        BINARY_NUMBER_RE: te,
        COMMENT: D,
        C_BLOCK_COMMENT_MODE: oe,
        C_LINE_COMMENT_MODE: Y,
        C_NUMBER_MODE: Fe,
        C_NUMBER_RE: W,
        END_SAME_AS_BEGIN: function(k) {
          return Object.assign(
            k,
            {
              /** @type {ModeCallback} */
              "on:begin": (M, U) => {
                U.data._beginMatch = M[1];
              },
              /** @type {ModeCallback} */
              "on:end": (M, U) => {
                U.data._beginMatch !== M[1] && U.ignoreMatch();
              }
            }
          );
        },
        HASH_COMMENT_MODE: ce,
        IDENT_RE: F,
        MATCH_NOTHING_RE: S,
        METHOD_GUARD: Nt,
        NUMBER_MODE: Se,
        NUMBER_RE: L,
        PHRASAL_WORDS_MODE: N,
        QUOTE_STRING_MODE: he,
        REGEXP_MODE: ze,
        RE_STARTERS_RE: de,
        SHEBANG: ke,
        TITLE_MODE: Qe,
        UNDERSCORE_IDENT_RE: V,
        UNDERSCORE_TITLE_MODE: on2
      });
      function mn(k, M) {
        k.input[k.index - 1] === "." && M.ignoreMatch();
      }
      function $n(k, M) {
        k.className !== void 0 && (k.scope = k.className, delete k.className);
      }
      function On(k, M) {
        M && k.beginKeywords && (k.begin = "\\b(" + k.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", k.__beforeBegin = mn, k.keywords = k.keywords || k.beginKeywords, delete k.beginKeywords, k.relevance === void 0 && (k.relevance = 0));
      }
      function sn(k, M) {
        Array.isArray(k.illegal) && (k.illegal = b(...k.illegal));
      }
      function Nn(k, M) {
        if (k.match) {
          if (k.begin || k.end) throw new Error("begin & end are not supported with match");
          k.begin = k.match, delete k.match;
        }
      }
      function ve(k, M) {
        k.relevance === void 0 && (k.relevance = 1);
      }
      const Xt = (k, M) => {
        if (!k.beforeMatch) return;
        if (k.starts) throw new Error("beforeMatch cannot be used with starts");
        const U = Object.assign({}, k);
        Object.keys(k).forEach((me) => {
          delete k[me];
        }), k.keywords = U.keywords, k.begin = m(U.beforeMatch, p2(U.begin)), k.starts = {
          relevance: 0,
          contains: [
            Object.assign(U, { endsParent: true })
          ]
        }, k.relevance = 0, delete U.beforeMatch;
      }, Bt = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ], le = "keyword";
      function Vt(k, M, U = le) {
        const me = /* @__PURE__ */ Object.create(null);
        return typeof k == "string" ? rt(U, k.split(" ")) : Array.isArray(k) ? rt(U, k) : Object.keys(k).forEach(function(et) {
          Object.assign(
            me,
            Vt(k[et], M, et)
          );
        }), me;
        function rt(et, ee) {
          M && (ee = ee.map((X) => X.toLowerCase())), ee.forEach(function(X) {
            const ge = X.split("|");
            me[ge[0]] = [et, qe(ge[0], ge[1])];
          });
        }
      }
      function qe(k, M) {
        return M ? Number(M) : Re(k) ? 0 : 1;
      }
      function Re(k) {
        return Bt.includes(k.toLowerCase());
      }
      const Wt = {}, pt = (k) => {
        console.error(k);
      }, An = (k, ...M) => {
        console.log(`WARN: ${k}`, ...M);
      }, Kt = (k, M) => {
        Wt[`${k}/${M}`] || (console.log(`Deprecated as of ${k}. ${M}`), Wt[`${k}/${M}`] = true);
      }, H = new Error();
      function J(k, M, { key: U }) {
        let me = 0;
        const rt = k[U], et = {}, ee = {};
        for (let X = 1; X <= M.length; X++)
          ee[X + me] = rt[X], et[X + me] = true, me += E(M[X - 1]);
        k[U] = ee, k[U]._emit = et, k[U]._multi = true;
      }
      function we(k) {
        if (Array.isArray(k.begin)) {
          if (k.skip || k.excludeBegin || k.returnBegin)
            throw pt("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), H;
          if (typeof k.beginScope != "object" || k.beginScope === null)
            throw pt("beginScope must be object"), H;
          J(k, k.begin, { key: "beginScope" }), k.begin = T(k.begin, { joinWith: "" });
        }
      }
      function Ie(k) {
        if (Array.isArray(k.end)) {
          if (k.skip || k.excludeEnd || k.returnEnd)
            throw pt("skip, excludeEnd, returnEnd not compatible with endScope: {}"), H;
          if (typeof k.endScope != "object" || k.endScope === null)
            throw pt("endScope must be object"), H;
          J(k, k.end, { key: "endScope" }), k.end = T(k.end, { joinWith: "" });
        }
      }
      function gt(k) {
        k.scope && typeof k.scope == "object" && k.scope !== null && (k.beginScope = k.scope, delete k.scope);
      }
      function an(k) {
        gt(k), typeof k.beginScope == "string" && (k.beginScope = { _wrap: k.beginScope }), typeof k.endScope == "string" && (k.endScope = { _wrap: k.endScope }), we(k), Ie(k);
      }
      function qo(k) {
        function M(ee, X) {
          return new RegExp(
            d(ee),
            "m" + (k.case_insensitive ? "i" : "") + (k.unicodeRegex ? "u" : "") + (X ? "g" : "")
          );
        }
        class U {
          constructor() {
            this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
          }
          // @ts-ignore
          addRule(X, ge) {
            ge.position = this.position++, this.matchIndexes[this.matchAt] = ge, this.regexes.push([ge, X]), this.matchAt += E(X) + 1;
          }
          compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            const X = this.regexes.map((ge) => ge[1]);
            this.matcherRe = M(T(X, { joinWith: "|" }), true), this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(X) {
            this.matcherRe.lastIndex = this.lastIndex;
            const ge = this.matcherRe.exec(X);
            if (!ge)
              return null;
            const _t = ge.findIndex((jo, ja) => ja > 0 && jo !== void 0), bt = this.matchIndexes[_t];
            return ge.splice(0, _t), Object.assign(ge, bt);
          }
        }
        class me {
          constructor() {
            this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(X) {
            if (this.multiRegexes[X]) return this.multiRegexes[X];
            const ge = new U();
            return this.rules.slice(X).forEach(([_t, bt]) => ge.addRule(_t, bt)), ge.compile(), this.multiRegexes[X] = ge, ge;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(X, ge) {
            this.rules.push([X, ge]), ge.type === "begin" && this.count++;
          }
          /** @param {string} s */
          exec(X) {
            const ge = this.getMatcher(this.regexIndex);
            ge.lastIndex = this.lastIndex;
            let _t = ge.exec(X);
            if (this.resumingScanAtSamePosition() && !(_t && _t.index === this.lastIndex)) {
              const bt = this.getMatcher(0);
              bt.lastIndex = this.lastIndex + 1, _t = bt.exec(X);
            }
            return _t && (this.regexIndex += _t.position + 1, this.regexIndex === this.count && this.considerAll()), _t;
          }
        }
        function rt(ee) {
          const X = new me();
          return ee.contains.forEach((ge) => X.addRule(ge.begin, { rule: ge, type: "begin" })), ee.terminatorEnd && X.addRule(ee.terminatorEnd, { type: "end" }), ee.illegal && X.addRule(ee.illegal, { type: "illegal" }), X;
        }
        function et(ee, X) {
          const ge = (
            /** @type CompiledMode */
            ee
          );
          if (ee.isCompiled) return ge;
          [
            $n,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            Nn,
            an,
            Xt
          ].forEach((bt) => bt(ee, X)), k.compilerExtensions.forEach((bt) => bt(ee, X)), ee.__beforeBegin = null, [
            On,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            sn,
            // default to 1 relevance if not specified
            ve
          ].forEach((bt) => bt(ee, X)), ee.isCompiled = true;
          let _t = null;
          return typeof ee.keywords == "object" && ee.keywords.$pattern && (ee.keywords = Object.assign({}, ee.keywords), _t = ee.keywords.$pattern, delete ee.keywords.$pattern), _t = _t || /\w+/, ee.keywords && (ee.keywords = Vt(ee.keywords, k.case_insensitive)), ge.keywordPatternRe = M(_t, true), X && (ee.begin || (ee.begin = /\B|\b/), ge.beginRe = M(ge.begin), !ee.end && !ee.endsWithParent && (ee.end = /\B|\b/), ee.end && (ge.endRe = M(ge.end)), ge.terminatorEnd = d(ge.end) || "", ee.endsWithParent && X.terminatorEnd && (ge.terminatorEnd += (ee.end ? "|" : "") + X.terminatorEnd)), ee.illegal && (ge.illegalRe = M(
            /** @type {RegExp | string} */
            ee.illegal
          )), ee.contains || (ee.contains = []), ee.contains = [].concat(...ee.contains.map(function(bt) {
            return Q(bt === "self" ? ee : bt);
          })), ee.contains.forEach(function(bt) {
            et(
              /** @type Mode */
              bt,
              ge
            );
          }), ee.starts && et(ee.starts, X), ge.matcher = rt(ge), ge;
        }
        if (k.compilerExtensions || (k.compilerExtensions = []), k.contains && k.contains.includes("self"))
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return k.classNameAliases = r(k.classNameAliases || {}), et(
          /** @type Mode */
          k
        );
      }
      function O(k) {
        return k ? k.endsWithParent || O(k.starts) : false;
      }
      function Q(k) {
        return k.variants && !k.cachedVariants && (k.cachedVariants = k.variants.map(function(M) {
          return r(k, { variants: null }, M);
        })), k.cachedVariants ? k.cachedVariants : O(k) ? r(k, { starts: k.starts ? r(k.starts) : null }) : Object.isFrozen(k) ? r(k) : k;
      }
      var pe = "11.11.1";
      class $e extends Error {
        constructor(M, U) {
          super(M), this.name = "HTMLInjectionError", this.html = U;
        }
      }
      const Ae = n, wt = r, qt = Symbol("nomatch"), gr = 7, Go = function(k) {
        const M = /* @__PURE__ */ Object.create(null), U = /* @__PURE__ */ Object.create(null), me = [];
        let rt = true;
        const et = "Could not find the language '{}', did you forget to load/include a language module?", ee = { disableAutodetect: true, name: "Plain text", contains: [] };
        let X = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: u
        };
        function ge(z) {
          return X.noHighlightRe.test(z);
        }
        function _t(z) {
          let se = z.className + " ";
          se += z.parentNode ? z.parentNode.className : "";
          const Me = X.languageDetectRe.exec(se);
          if (Me) {
            const tt2 = br(Me[1]);
            return tt2 || (An(et.replace("{}", Me[1])), An("Falling back to no-highlight mode for this block.", z)), tt2 ? Me[1] : "no-highlight";
          }
          return se.split(/\s+/).find((tt2) => ge(tt2) || br(tt2));
        }
        function bt(z, se, Me) {
          let tt2 = "", vt = "";
          typeof se == "object" ? (tt2 = z, Me = se.ignoreIllegals, vt = se.language) : (Kt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Kt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), vt = z, tt2 = se), Me === void 0 && (Me = true);
          const Mn = {
            code: tt2,
            language: vt
          };
          qi("before:highlight", Mn);
          const yr = Mn.result ? Mn.result : jo(Mn.language, Mn.code, Me);
          return yr.code = Mn.code, qi("after:highlight", yr), yr;
        }
        function jo(z, se, Me, tt2) {
          const vt = /* @__PURE__ */ Object.create(null);
          function Mn(j, ne) {
            return j.keywords[ne];
          }
          function yr() {
            if (!_e.keywords) {
              Mt.addText(nt);
              return;
            }
            let j = 0;
            _e.keywordPatternRe.lastIndex = 0;
            let ne = _e.keywordPatternRe.exec(nt), Oe = "";
            for (; ne; ) {
              Oe += nt.substring(j, ne.index);
              const Ve = zn.case_insensitive ? ne[0].toLowerCase() : ne[0], $t = Mn(_e, Ve);
              if ($t) {
                const [er, tb] = $t;
                if (Mt.addText(Oe), Oe = "", vt[Ve] = (vt[Ve] || 0) + 1, vt[Ve] <= gr && (Yi += tb), er.startsWith("_"))
                  Oe += ne[0];
                else {
                  const nb = zn.classNameAliases[er] || er;
                  Fn(ne[0], nb);
                }
              } else
                Oe += ne[0];
              j = _e.keywordPatternRe.lastIndex, ne = _e.keywordPatternRe.exec(nt);
            }
            Oe += nt.substring(j), Mt.addText(Oe);
          }
          function Gi() {
            if (nt === "") return;
            let j = null;
            if (typeof _e.subLanguage == "string") {
              if (!M[_e.subLanguage]) {
                Mt.addText(nt);
                return;
              }
              j = jo(_e.subLanguage, nt, true, Iu[_e.subLanguage]), Iu[_e.subLanguage] = /** @type {CompiledMode} */
              j._top;
            } else
              j = Ya(nt, _e.subLanguage.length ? _e.subLanguage : null);
            _e.relevance > 0 && (Yi += j.relevance), Mt.__addSublanguage(j._emitter, j.language);
          }
          function ln() {
            _e.subLanguage != null ? Gi() : yr(), nt = "";
          }
          function Fn(j, ne) {
            j !== "" && (Mt.startScope(ne), Mt.addText(j), Mt.endScope());
          }
          function Nu(j, ne) {
            let Oe = 1;
            const Ve = ne.length - 1;
            for (; Oe <= Ve; ) {
              if (!j._emit[Oe]) {
                Oe++;
                continue;
              }
              const $t = zn.classNameAliases[j[Oe]] || j[Oe], er = ne[Oe];
              $t ? Fn(er, $t) : (nt = er, yr(), nt = ""), Oe++;
            }
          }
          function Au(j, ne) {
            return j.scope && typeof j.scope == "string" && Mt.openNode(zn.classNameAliases[j.scope] || j.scope), j.beginScope && (j.beginScope._wrap ? (Fn(nt, zn.classNameAliases[j.beginScope._wrap] || j.beginScope._wrap), nt = "") : j.beginScope._multi && (Nu(j.beginScope, ne), nt = "")), _e = Object.create(j, { parent: { value: _e } }), _e;
          }
          function Mu(j, ne, Oe) {
            let Ve = _(j.endRe, Oe);
            if (Ve) {
              if (j["on:end"]) {
                const $t = new e(j);
                j["on:end"](ne, $t), $t.isMatchIgnored && (Ve = false);
              }
              if (Ve) {
                for (; j.endsParent && j.parent; )
                  j = j.parent;
                return j;
              }
            }
            if (j.endsWithParent)
              return Mu(j.parent, ne, Oe);
          }
          function Jg(j) {
            return _e.matcher.regexIndex === 0 ? (nt += j[0], 1) : (Qa = true, 0);
          }
          function Xg(j) {
            const ne = j[0], Oe = j.rule, Ve = new e(Oe), $t = [Oe.__beforeBegin, Oe["on:begin"]];
            for (const er of $t)
              if (er && (er(j, Ve), Ve.isMatchIgnored))
                return Jg(ne);
            return Oe.skip ? nt += ne : (Oe.excludeBegin && (nt += ne), ln(), !Oe.returnBegin && !Oe.excludeBegin && (nt = ne)), Au(Oe, j), Oe.returnBegin ? 0 : ne.length;
          }
          function Zg(j) {
            const ne = j[0], Oe = se.substring(j.index), Ve = Mu(_e, j, Oe);
            if (!Ve)
              return qt;
            const $t = _e;
            _e.endScope && _e.endScope._wrap ? (ln(), Fn(ne, _e.endScope._wrap)) : _e.endScope && _e.endScope._multi ? (ln(), Nu(_e.endScope, j)) : $t.skip ? nt += ne : ($t.returnEnd || $t.excludeEnd || (nt += ne), ln(), $t.excludeEnd && (nt = ne));
            do
              _e.scope && Mt.closeNode(), !_e.skip && !_e.subLanguage && (Yi += _e.relevance), _e = _e.parent;
            while (_e !== Ve.parent);
            return Ve.starts && Au(Ve.starts, j), $t.returnEnd ? 0 : ne.length;
          }
          function Qg() {
            const j = [];
            for (let ne = _e; ne !== zn; ne = ne.parent)
              ne.scope && j.unshift(ne.scope);
            j.forEach((ne) => Mt.openNode(ne));
          }
          let ji = {};
          function Ru(j, ne) {
            const Oe = ne && ne[0];
            if (nt += j, Oe == null)
              return ln(), 0;
            if (ji.type === "begin" && ne.type === "end" && ji.index === ne.index && Oe === "") {
              if (nt += se.slice(ne.index, ne.index + 1), !rt) {
                const Ve = new Error(`0 width match regex (${z})`);
                throw Ve.languageName = z, Ve.badRule = ji.rule, Ve;
              }
              return 1;
            }
            if (ji = ne, ne.type === "begin")
              return Xg(ne);
            if (ne.type === "illegal" && !Me) {
              const Ve = new Error('Illegal lexeme "' + Oe + '" for mode "' + (_e.scope || "<unnamed>") + '"');
              throw Ve.mode = _e, Ve;
            } else if (ne.type === "end") {
              const Ve = Zg(ne);
              if (Ve !== qt)
                return Ve;
            }
            if (ne.type === "illegal" && Oe === "")
              return nt += `
`, 1;
            if (Za > 1e5 && Za > ne.index * 3)
              throw new Error("potential infinite loop, way more iterations than matches");
            return nt += Oe, Oe.length;
          }
          const zn = br(z);
          if (!zn)
            throw pt(et.replace("{}", z)), new Error('Unknown language: "' + z + '"');
          const eb = qo(zn);
          let Xa = "", _e = tt2 || eb;
          const Iu = {}, Mt = new X.__emitter(X);
          Qg();
          let nt = "", Yi = 0, Vr = 0, Za = 0, Qa = false;
          try {
            if (zn.__emitTokens)
              zn.__emitTokens(se, Mt);
            else {
              for (_e.matcher.considerAll(); ; ) {
                Za++, Qa ? Qa = false : _e.matcher.considerAll(), _e.matcher.lastIndex = Vr;
                const j = _e.matcher.exec(se);
                if (!j) break;
                const ne = se.substring(Vr, j.index), Oe = Ru(ne, j);
                Vr = j.index + Oe;
              }
              Ru(se.substring(Vr));
            }
            return Mt.finalize(), Xa = Mt.toHTML(), {
              language: z,
              value: Xa,
              relevance: Yi,
              illegal: false,
              _emitter: Mt,
              _top: _e
            };
          } catch (j) {
            if (j.message && j.message.includes("Illegal"))
              return {
                language: z,
                value: Ae(se),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: j.message,
                  index: Vr,
                  context: se.slice(Vr - 100, Vr + 100),
                  mode: j.mode,
                  resultSoFar: Xa
                },
                _emitter: Mt
              };
            if (rt)
              return {
                language: z,
                value: Ae(se),
                illegal: false,
                relevance: 0,
                errorRaised: j,
                _emitter: Mt,
                _top: _e
              };
            throw j;
          }
        }
        function ja(z) {
          const se = {
            value: Ae(z),
            illegal: false,
            relevance: 0,
            _top: ee,
            _emitter: new X.__emitter(X)
          };
          return se._emitter.addText(z), se;
        }
        function Ya(z, se) {
          se = se || X.languages || Object.keys(M);
          const Me = ja(z), tt2 = se.filter(br).filter(Ou).map(
            (ln) => jo(ln, z, false)
          );
          tt2.unshift(Me);
          const vt = tt2.sort((ln, Fn) => {
            if (ln.relevance !== Fn.relevance) return Fn.relevance - ln.relevance;
            if (ln.language && Fn.language) {
              if (br(ln.language).supersetOf === Fn.language)
                return 1;
              if (br(Fn.language).supersetOf === ln.language)
                return -1;
            }
            return 0;
          }), [Mn, yr] = vt, Gi = Mn;
          return Gi.secondBest = yr, Gi;
        }
        function Fg(z, se, Me) {
          const tt2 = se && U[se] || Me;
          z.classList.add("hljs"), z.classList.add(`language-${tt2}`);
        }
        function Ja(z) {
          let se = null;
          const Me = _t(z);
          if (ge(Me)) return;
          if (qi(
            "before:highlightElement",
            { el: z, language: Me }
          ), z.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", z);
            return;
          }
          if (z.children.length > 0 && (X.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(z)), X.throwUnescapedHTML))
            throw new $e(
              "One of your code blocks includes unescaped HTML.",
              z.innerHTML
            );
          se = z;
          const tt2 = se.textContent, vt = Me ? bt(tt2, { language: Me, ignoreIllegals: true }) : Ya(tt2);
          z.innerHTML = vt.value, z.dataset.highlighted = "yes", Fg(z, Me, vt.language), z.result = {
            language: vt.language,
            // TODO: remove with version 11.0
            re: vt.relevance,
            relevance: vt.relevance
          }, vt.secondBest && (z.secondBest = {
            language: vt.secondBest.language,
            relevance: vt.secondBest.relevance
          }), qi("after:highlightElement", { el: z, result: vt, text: tt2 });
        }
        function zg(z) {
          X = wt(X, z);
        }
        const Hg = () => {
          Ki(), Kt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function Ug() {
          Ki(), Kt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let xu = false;
        function Ki() {
          function z() {
            Ki();
          }
          if (document.readyState === "loading") {
            xu || window.addEventListener("DOMContentLoaded", z, false), xu = true;
            return;
          }
          document.querySelectorAll(X.cssSelector).forEach(Ja);
        }
        function Vg(z, se) {
          let Me = null;
          try {
            Me = se(k);
          } catch (tt2) {
            if (pt("Language definition for '{}' could not be registered.".replace("{}", z)), rt)
              pt(tt2);
            else
              throw tt2;
            Me = ee;
          }
          Me.name || (Me.name = z), M[z] = Me, Me.rawDefinition = se.bind(null, k), Me.aliases && Tu(Me.aliases, { languageName: z });
        }
        function Wg(z) {
          delete M[z];
          for (const se of Object.keys(U))
            U[se] === z && delete U[se];
        }
        function Kg() {
          return Object.keys(M);
        }
        function br(z) {
          return z = (z || "").toLowerCase(), M[z] || M[U[z]];
        }
        function Tu(z, { languageName: se }) {
          typeof z == "string" && (z = [z]), z.forEach((Me) => {
            U[Me.toLowerCase()] = se;
          });
        }
        function Ou(z) {
          const se = br(z);
          return se && !se.disableAutodetect;
        }
        function qg(z) {
          z["before:highlightBlock"] && !z["before:highlightElement"] && (z["before:highlightElement"] = (se) => {
            z["before:highlightBlock"](
              Object.assign({ block: se.el }, se)
            );
          }), z["after:highlightBlock"] && !z["after:highlightElement"] && (z["after:highlightElement"] = (se) => {
            z["after:highlightBlock"](
              Object.assign({ block: se.el }, se)
            );
          });
        }
        function Gg(z) {
          qg(z), me.push(z);
        }
        function jg(z) {
          const se = me.indexOf(z);
          se !== -1 && me.splice(se, 1);
        }
        function qi(z, se) {
          const Me = z;
          me.forEach(function(tt2) {
            tt2[Me] && tt2[Me](se);
          });
        }
        function Yg(z) {
          return Kt("10.7.0", "highlightBlock will be removed entirely in v12.0"), Kt("10.7.0", "Please use highlightElement now."), Ja(z);
        }
        Object.assign(k, {
          highlight: bt,
          highlightAuto: Ya,
          highlightAll: Ki,
          highlightElement: Ja,
          // TODO: Remove with v12 API
          highlightBlock: Yg,
          configure: zg,
          initHighlighting: Hg,
          initHighlightingOnLoad: Ug,
          registerLanguage: Vg,
          unregisterLanguage: Wg,
          listLanguages: Kg,
          getLanguage: br,
          registerAliases: Tu,
          autoDetection: Ou,
          inherit: wt,
          addPlugin: Gg,
          removePlugin: jg
        }), k.debugMode = function() {
          rt = false;
        }, k.safeMode = function() {
          rt = true;
        }, k.versionString = pe, k.regex = {
          concat: m,
          lookahead: p2,
          either: b,
          optional: h2,
          anyNumberOfTimes: f
        };
        for (const z in At)
          typeof At[z] == "object" && t2(At[z]);
        return Object.assign(k, At), k;
      }, Zt = Go({});
      return Zt.newInstance = () => Go({}), Nl = Zt, Zt.HighlightJS = Zt, Zt.default = Zt, Nl;
    }
    var pN = /* @__PURE__ */ dN();
    const fN = /* @__PURE__ */ uN(pN), jp = {}, hN = "hljs-";
    function mN(t2) {
      const e = fN.newInstance();
      return t2 && i(t2), {
        highlight: n,
        highlightAuto: r,
        listLanguages: o,
        register: i,
        registerAlias: s,
        registered: a
      };
      function n(l, c2, u) {
        const d = u || jp, p2 = typeof d.prefix == "string" ? d.prefix : hN;
        if (!e.getLanguage(l))
          throw new Error("Unknown language: `" + l + "` is not registered");
        e.configure({ __emitter: gN, classPrefix: p2 });
        const f = (
          /** @type {HighlightResult & {_emitter: HastEmitter}} */
          e.highlight(c2, { ignoreIllegals: true, language: l })
        );
        if (f.errorRaised)
          throw new Error("Could not highlight with `Highlight.js`", {
            cause: f.errorRaised
          });
        const h2 = f._emitter.root, m = (
          /** @type {RootData} */
          h2.data
        );
        return m.language = f.language, m.relevance = f.relevance, h2;
      }
      function r(l, c2) {
        const d = (c2 || jp).subset || o();
        let p2 = -1, f = 0, h2;
        for (; ++p2 < d.length; ) {
          const m = d[p2];
          if (!e.getLanguage(m)) continue;
          const g = n(m, l, c2);
          g.data && g.data.relevance !== void 0 && g.data.relevance > f && (f = g.data.relevance, h2 = g);
        }
        return h2 || {
          type: "root",
          children: [],
          data: { language: void 0, relevance: f }
        };
      }
      function o() {
        return e.listLanguages();
      }
      function i(l, c2) {
        if (typeof l == "string")
          e.registerLanguage(l, c2);
        else {
          let u;
          for (u in l)
            Object.hasOwn(l, u) && e.registerLanguage(u, l[u]);
        }
      }
      function s(l, c2) {
        if (typeof l == "string")
          e.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof c2 == "string" ? c2 : [...c2],
            { languageName: l }
          );
        else {
          let u;
          for (u in l)
            if (Object.hasOwn(l, u)) {
              const d = l[u];
              e.registerAliases(
                // Note: copy needed because hljs doesn’t accept readonly arrays yet.
                typeof d == "string" ? d : [...d],
                { languageName: u }
              );
            }
        }
      }
      function a(l) {
        return !!e.getLanguage(l);
      }
    }
    class gN {
      /**
       * @param {Readonly<HljsOptions>} options
       *   Configuration.
       * @returns
       *   Instance.
       */
      constructor(e) {
        this.options = e, this.root = {
          type: "root",
          children: [],
          data: { language: void 0, relevance: 0 }
        }, this.stack = [this.root];
      }
      /**
       * @param {string} value
       *   Text to add.
       * @returns {undefined}
       *   Nothing.
       *
       */
      addText(e) {
        if (e === "") return;
        const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
        r && r.type === "text" ? r.value += e : n.children.push({ type: "text", value: e });
      }
      /**
       *
       * @param {unknown} rawName
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      startScope(e) {
        this.openNode(String(e));
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      endScope() {
        this.closeNode();
      }
      /**
       * @param {HastEmitter} other
       *   Other emitter.
       * @param {string} name
       *   Name of the sublanguage.
       * @returns {undefined}
       *   Nothing.
       */
      __addSublanguage(e, n) {
        const r = this.stack[this.stack.length - 1], o = (
          /** @type {Array<ElementContent>} */
          e.root.children
        );
        n ? r.children.push({
          type: "element",
          tagName: "span",
          properties: { className: [n] },
          children: o
        }) : r.children.push(...o);
      }
      /**
       * @param {string} name
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      openNode(e) {
        const n = this, r = e.split(".").map(function(s, a) {
          return a ? s + "_".repeat(a) : n.options.classPrefix + s;
        }), o = this.stack[this.stack.length - 1], i = {
          type: "element",
          tagName: "span",
          properties: { className: r },
          children: []
        };
        o.children.push(i), this.stack.push(i);
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      closeNode() {
        this.stack.pop();
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      finalize() {
      }
      /**
       * @returns {string}
       *   Nothing.
       */
      toHTML() {
        return "";
      }
    }
    function bN(t2) {
      const e = document.createElement("textarea");
      e.value = t2, e.contentEditable = "true", e.style.position = "fixed", document.body.appendChild(e), e.focus(), e.select();
      const n = document.execCommand("copy");
      return e.remove(), n;
    }
    function yN(t2) {
      return navigator.clipboard !== void 0 ? navigator.clipboard.writeText(t2) : new Promise((e, n) => {
        const r = bN(t2);
        r ? e(true) : n(r);
      });
    }
    const vN = { class: "code-block-toolbar" }, EN = { class: "wrap editable" }, kN = { class: "wrap" }, wN = { class: "language readonly" }, _N = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref("content_copy"), r = computed({
          get() {
            return e.node.attrs.language;
          },
          set(c2) {
            e.updateAttributes({ language: c2 });
          }
        }), o = computed({
          get() {
            return e.node.attrs.wrap;
          },
          set(c2) {
            e.updateAttributes({ wrap: c2 });
          }
        }), i = computed(() => o.value ? "text_select_move_down" : "format_text_wrap");
        function s(c2) {
          r.value = c2;
        }
        function a() {
          const c2 = e.node.content.content[0].text;
          yN(c2).then(() => {
            n.value = "done", setTimeout(() => {
              n.value = "content_copy";
            }, 2e3);
          });
        }
        function l() {
          o.value = !o.value;
        }
        return (c2, u) => (openBlock(), createBlock(unref(mr), mergeProps(e, { class: "o-code-block-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", vN, [
              createBaseVNode("div", EN, [
                createVNode(unref(gS), {
                  language: r.value,
                  onSelect: s
                }, null, 8, ["language"])
              ]),
              createBaseVNode("div", kN, [
                createBaseVNode("div", wN, toDisplayString(r.value), 1),
                createVNode(unref(je), {
                  icon: i.value,
                  "icon-class": { "rotate-270": o.value },
                  tooltip: "Wrap",
                  class: "editable",
                  onClick: l
                }, null, 8, ["icon", "icon-class"]),
                createVNode(unref(je), {
                  icon: n.value,
                  tooltip: "Copy",
                  onClick: a
                }, null, 8, ["icon"])
              ])
            ]),
            createBaseVNode("pre", null, [
              createVNode(unref(hr), {
                as: "code",
                class: normalizeClass({ wrap: o.value })
              }, null, 8, ["class"])
            ])
          ]),
          _: 1
        }, 16));
      }
    }), SN = mN(cN), CN = U1.extend({
      draggable: true,
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          wrap: {
            default: true,
            rendered: false
          }
        };
      },
      addNodeView() {
        return Ln(_N);
      }
    }).configure({
      languageClassPrefix: "language-",
      defaultLanguage: "bash",
      lowlight: SN
    }), xN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = computed(() => e.node.attrs.level);
        return (r, o) => (openBlock(), createBlock(unref(mr), mergeProps(e, {
          class: ["o-heading-view", `h${n.value}`],
          "data-id": r.node.attrs["data-id"],
          style: `text-align: ${r.node.attrs.textAlign}`
        }), {
          default: withCtx(() => [
            createVNode(unref(hr))
          ]),
          _: 1
        }, 16, ["class", "data-id", "style"]));
      }
    }), TN = km.extend({
      draggable: true,
      addNodeView() {
        return Ln(xN);
      }
    }), ON = { class: "horizontal" }, NN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, r) => (openBlock(), createBlock(unref(mr), mergeProps(e, { class: "o-horizontal-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", ON, [
              createVNode(unref(hr), {
                as: "div",
                class: "divider"
              })
            ])
          ]),
          _: 1
        }, 16));
      }
    }), AN = xm.extend({
      draggable: true,
      addNodeView() {
        return Ln(NN);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const MN = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, RN = it.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["img", Be(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setImage: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: MN,
            type: this.type,
            getAttributes: (t2) => {
              const [, , e, n, r] = t2;
              return { src: n, alt: e, title: r };
            }
          })
        ];
      }
    }), IN = RN.extend({
      draggable: true,
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          size: {
            default: "",
            rendered: false
          },
          // small, medium, large
          ratio: {
            default: "",
            rendered: false
          },
          isDraggable: {
            default: true,
            renderHTML: (e) => ({})
          }
        };
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return e.size = t2.attrs.size, e.ratio = t2.attrs.ratio, ["img", Be(this.options.HTMLAttributes, e)];
      }
    }), DN = {
      key: 1,
      class: "image-container"
    }, LN = { key: 1 }, PN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref(false), r = ref(false), o = ref({}), i = ref(null), s = ref(false), a = computed(() => e.node.attrs), l = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.title;
          },
          set(g) {
            e.updateAttributes({ title: g });
          }
        });
        function u() {
          s.value = true, setTimeout(() => {
            var g;
            (g = i.value) == null || g.focus();
          }, 0);
        }
        function d() {
          s.value = false;
        }
        function p2() {
          l.value === "init" && m(true);
        }
        function f(g) {
          switch (n.value = false, g.value) {
            case "replace":
              m(true);
              break;
          }
        }
        function h2(g) {
          l.value = g, m(false);
        }
        function m(g) {
          r.value = g;
        }
        return onMounted(() => {
          m(l.value === "init");
        }), (g, b) => {
          var E;
          return openBlock(), createBlock(unref(mr), mergeProps(e, {
            class: ["o-image-view", {
              "with-caption": a.value.alt,
              "with-ratio": a.value.ratio,
              readonly: !((E = g.editor) != null && E.isEditable),
              init: l.value === "init"
            }],
            size: a.value.size,
            as: "div",
            onClick: p2
          }), {
            default: withCtx(() => [
              createVNode(unref(Ai), {
                modelValue: r.value,
                "onUpdate:modelValue": b[1] || (b[1] = (_) => r.value = _),
                placement: l.value === "init" ? "bottom" : "top",
                "show-arrow": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(Rm), {
                    val: l.value === "init" ? "" : l.value,
                    type: "image",
                    onInput: h2
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var _;
                  return [
                    l.value === "init" ? (openBlock(), createBlock(unref(Nm), {
                      key: 0,
                      icon: "image",
                      placeholder: "Add an image"
                    })) : (openBlock(), createElementBlock("div", DN, [
                      createVNode(unref(Am), mergeProps(e, { onAction: f }), {
                        default: withCtx(() => [
                          createVNode(unref(je), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: u
                          })
                        ]),
                        _: 1
                      }, 16),
                      createBaseVNode("img", mergeProps(a.value, {
                        draggable: "true",
                        "data-drag-handle": ""
                      }), null, 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: u
                      }, [
                        (_ = g.editor) != null && _.isEditable && s.value ? (openBlock(), createBlock(unref(Wi), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: i,
                          class: "caption-input",
                          modelValue: c2.value,
                          "onUpdate:modelValue": b[0] || (b[0] = (v) => c2.value = v),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: d
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", LN, toDisplayString(c2.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(au), {
                modelValue: n.value,
                "onUpdate:modelValue": b[2] || (b[2] = (_) => n.value = _),
                event: o.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Wo), mergeProps(e, { onAction: f }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class", "size"]);
        };
      }
    }), BN = IN.extend({
      addNodeView() {
        return Ln(PN);
      }
    }).configure({
      inline: true
    }), $N = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", FN = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Ho = (t2, e) => {
      for (const n in e)
        t2[n] = e[n];
      return t2;
    }, gc = "numeric", bc = "ascii", yc = "alpha", ui = "asciinumeric", ni = "alphanumeric", vc = "domain", Cg = "emoji", zN = "scheme", HN = "slashscheme", Al = "whitespace";
    function UN(t2, e) {
      return t2 in e || (e[t2] = []), e[t2];
    }
    function Jr(t2, e, n) {
      e[gc] && (e[ui] = true, e[ni] = true), e[bc] && (e[ui] = true, e[yc] = true), e[ui] && (e[ni] = true), e[yc] && (e[ni] = true), e[ni] && (e[vc] = true), e[Cg] && (e[vc] = true);
      for (const r in e) {
        const o = UN(r, n);
        o.indexOf(t2) < 0 && o.push(t2);
      }
    }
    function VN(t2, e) {
      const n = {};
      for (const r in e)
        e[r].indexOf(t2) >= 0 && (n[r] = true);
      return n;
    }
    function Qt(t2 = null) {
      this.j = {}, this.jr = [], this.jd = null, this.t = t2;
    }
    Qt.groups = {};
    Qt.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(t2) {
        const e = this, n = e.j[t2];
        if (n)
          return n;
        for (let r = 0; r < e.jr.length; r++) {
          const o = e.jr[r][0], i = e.jr[r][1];
          if (i && o.test(t2))
            return i;
        }
        return e.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(t2, e = false) {
        return e ? t2 in this.j : !!this.go(t2);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(t2, e, n, r) {
        for (let o = 0; o < t2.length; o++)
          this.tt(t2[o], e, n, r);
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(t2, e, n, r) {
        r = r || Qt.groups;
        let o;
        return e && e.j ? o = e : (o = new Qt(e), n && r && Jr(e, n, r)), this.jr.push([t2, o]), o;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(t2, e, n, r) {
        let o = this;
        const i = t2.length;
        if (!i)
          return o;
        for (let s = 0; s < i - 1; s++)
          o = o.tt(t2[s]);
        return o.tt(t2[i - 1], e, n, r);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(t2, e, n, r) {
        r = r || Qt.groups;
        const o = this;
        if (e && e.j)
          return o.j[t2] = e, e;
        const i = e;
        let s, a = o.go(t2);
        if (a ? (s = new Qt(), Ho(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new Qt(), i) {
          if (r)
            if (s.t && typeof s.t == "string") {
              const l = Ho(VN(s.t, r), n);
              Jr(i, l, r);
            } else n && Jr(i, n, r);
          s.t = i;
        }
        return o.j[t2] = s, s;
      }
    };
    const xe = (t2, e, n, r, o) => t2.ta(e, n, r, o), lt = (t2, e, n, r, o) => t2.tr(e, n, r, o), Yp = (t2, e, n, r, o) => t2.ts(e, n, r, o), $ = (t2, e, n, r, o) => t2.tt(e, n, r, o), ir = "WORD", Ec = "UWORD", xg = "ASCIINUMERICAL", Tg = "ALPHANUMERICAL", Di = "LOCALHOST", kc = "TLD", wc = "UTLD", Ms = "SCHEME", Co = "SLASH_SCHEME", bu = "NUM", _c = "WS", yu = "NL", di = "OPENBRACE", pi = "CLOSEBRACE", ea = "OPENBRACKET", ta = "CLOSEBRACKET", na = "OPENPAREN", ra = "CLOSEPAREN", oa = "OPENANGLEBRACKET", ia = "CLOSEANGLEBRACKET", sa = "FULLWIDTHLEFTPAREN", aa = "FULLWIDTHRIGHTPAREN", la = "LEFTCORNERBRACKET", ca = "RIGHTCORNERBRACKET", ua = "LEFTWHITECORNERBRACKET", da = "RIGHTWHITECORNERBRACKET", pa = "FULLWIDTHLESSTHAN", fa = "FULLWIDTHGREATERTHAN", ha = "AMPERSAND", vu = "APOSTROPHE", ma = "ASTERISK", _r = "AT", ga = "BACKSLASH", ba = "BACKTICK", ya = "CARET", xr = "COLON", Eu = "COMMA", va = "DOLLAR", Vn = "DOT", Ea = "EQUALS", ku = "EXCLAMATION", bn = "HYPHEN", fi = "PERCENT", ka = "PIPE", wa = "PLUS", _a = "POUND", hi = "QUERY", wu = "QUOTE", Og = "FULLWIDTHMIDDLEDOT", _u = "SEMI", Wn = "SLASH", mi = "TILDE", Sa = "UNDERSCORE", Ng = "EMOJI", Ca = "SYM";
    var Ag = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      WORD: ir,
      UWORD: Ec,
      ASCIINUMERICAL: xg,
      ALPHANUMERICAL: Tg,
      LOCALHOST: Di,
      TLD: kc,
      UTLD: wc,
      SCHEME: Ms,
      SLASH_SCHEME: Co,
      NUM: bu,
      WS: _c,
      NL: yu,
      OPENBRACE: di,
      CLOSEBRACE: pi,
      OPENBRACKET: ea,
      CLOSEBRACKET: ta,
      OPENPAREN: na,
      CLOSEPAREN: ra,
      OPENANGLEBRACKET: oa,
      CLOSEANGLEBRACKET: ia,
      FULLWIDTHLEFTPAREN: sa,
      FULLWIDTHRIGHTPAREN: aa,
      LEFTCORNERBRACKET: la,
      RIGHTCORNERBRACKET: ca,
      LEFTWHITECORNERBRACKET: ua,
      RIGHTWHITECORNERBRACKET: da,
      FULLWIDTHLESSTHAN: pa,
      FULLWIDTHGREATERTHAN: fa,
      AMPERSAND: ha,
      APOSTROPHE: vu,
      ASTERISK: ma,
      AT: _r,
      BACKSLASH: ga,
      BACKTICK: ba,
      CARET: ya,
      COLON: xr,
      COMMA: Eu,
      DOLLAR: va,
      DOT: Vn,
      EQUALS: Ea,
      EXCLAMATION: ku,
      HYPHEN: bn,
      PERCENT: fi,
      PIPE: ka,
      PLUS: wa,
      POUND: _a,
      QUERY: hi,
      QUOTE: wu,
      FULLWIDTHMIDDLEDOT: Og,
      SEMI: _u,
      SLASH: Wn,
      TILDE: mi,
      UNDERSCORE: Sa,
      EMOJI: Ng,
      SYM: Ca
    });
    const nr = /[a-z]/, Zo = new RegExp("\\p{L}", "u"), Ml = new RegExp("\\p{Emoji}", "u"), rr = /\d/, Rl = /\s/, Jp = "\r", Il = `
`, WN = "️", KN = "‍", Dl = "￼";
    let ys = null, vs = null;
    function qN(t2 = []) {
      const e = {};
      Qt.groups = e;
      const n = new Qt();
      ys == null && (ys = Xp($N)), vs == null && (vs = Xp(FN)), $(n, "'", vu), $(n, "{", di), $(n, "}", pi), $(n, "[", ea), $(n, "]", ta), $(n, "(", na), $(n, ")", ra), $(n, "<", oa), $(n, ">", ia), $(n, "（", sa), $(n, "）", aa), $(n, "「", la), $(n, "」", ca), $(n, "『", ua), $(n, "』", da), $(n, "＜", pa), $(n, "＞", fa), $(n, "&", ha), $(n, "*", ma), $(n, "@", _r), $(n, "`", ba), $(n, "^", ya), $(n, ":", xr), $(n, ",", Eu), $(n, "$", va), $(n, ".", Vn), $(n, "=", Ea), $(n, "!", ku), $(n, "-", bn), $(n, "%", fi), $(n, "|", ka), $(n, "+", wa), $(n, "#", _a), $(n, "?", hi), $(n, '"', wu), $(n, "/", Wn), $(n, ";", _u), $(n, "~", mi), $(n, "_", Sa), $(n, "\\", ga), $(n, "・", Og);
      const r = lt(n, rr, bu, {
        [gc]: true
      });
      lt(r, rr, r);
      const o = lt(r, nr, xg, {
        [ui]: true
      }), i = lt(r, Zo, Tg, {
        [ni]: true
      }), s = lt(n, nr, ir, {
        [bc]: true
      });
      lt(s, rr, o), lt(s, nr, s), lt(o, rr, o), lt(o, nr, o);
      const a = lt(n, Zo, Ec, {
        [yc]: true
      });
      lt(a, nr), lt(a, rr, i), lt(a, Zo, a), lt(i, rr, i), lt(i, nr), lt(i, Zo, i);
      const l = $(n, Il, yu, {
        [Al]: true
      }), c2 = $(n, Jp, _c, {
        [Al]: true
      }), u = lt(n, Rl, _c, {
        [Al]: true
      });
      $(n, Dl, u), $(c2, Il, l), $(c2, Dl, u), lt(c2, Rl, u), $(u, Jp), $(u, Il), lt(u, Rl, u), $(u, Dl, u);
      const d = lt(n, Ml, Ng, {
        [Cg]: true
      });
      $(d, "#"), lt(d, Ml, d), $(d, WN, d);
      const p2 = $(d, KN);
      $(p2, "#"), lt(p2, Ml, d);
      const f = [[nr, s], [rr, o]], h2 = [[nr, null], [Zo, a], [rr, i]];
      for (let m = 0; m < ys.length; m++)
        vr(n, ys[m], kc, ir, f);
      for (let m = 0; m < vs.length; m++)
        vr(n, vs[m], wc, Ec, h2);
      Jr(kc, {
        tld: true,
        ascii: true
      }, e), Jr(wc, {
        utld: true,
        alpha: true
      }, e), vr(n, "file", Ms, ir, f), vr(n, "mailto", Ms, ir, f), vr(n, "http", Co, ir, f), vr(n, "https", Co, ir, f), vr(n, "ftp", Co, ir, f), vr(n, "ftps", Co, ir, f), Jr(Ms, {
        scheme: true,
        ascii: true
      }, e), Jr(Co, {
        slashscheme: true,
        ascii: true
      }, e), t2 = t2.sort((m, g) => m[0] > g[0] ? 1 : -1);
      for (let m = 0; m < t2.length; m++) {
        const g = t2[m][0], E = t2[m][1] ? {
          [zN]: true
        } : {
          [HN]: true
        };
        g.indexOf("-") >= 0 ? E[vc] = true : nr.test(g) ? rr.test(g) ? E[ui] = true : E[bc] = true : E[gc] = true, Yp(n, g, g, E);
      }
      return Yp(n, "localhost", Di, {
        ascii: true
      }), n.jd = new Qt(Ca), {
        start: n,
        tokens: Ho({
          groups: e
        }, Ag)
      };
    }
    function Mg(t2, e) {
      const n = GN(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, o = [];
      let i = 0, s = 0;
      for (; s < r; ) {
        let a = t2, l = null, c2 = 0, u = null, d = -1, p2 = -1;
        for (; s < r && (l = a.go(n[s])); )
          a = l, a.accepts() ? (d = 0, p2 = 0, u = a) : d >= 0 && (d += n[s].length, p2++), c2 += n[s].length, i += n[s].length, s++;
        i -= d, s -= p2, c2 -= d, o.push({
          t: u.t,
          // token type/name
          v: e.slice(i - c2, i),
          // string value
          s: i - c2,
          // start index
          e: i
          // end index (excluding)
        });
      }
      return o;
    }
    function GN(t2) {
      const e = [], n = t2.length;
      let r = 0;
      for (; r < n; ) {
        let o = t2.charCodeAt(r), i, s = o < 55296 || o > 56319 || r + 1 === n || (i = t2.charCodeAt(r + 1)) < 56320 || i > 57343 ? t2[r] : t2.slice(r, r + 2);
        e.push(s), r += s.length;
      }
      return e;
    }
    function vr(t2, e, n, r, o) {
      let i;
      const s = e.length;
      for (let a = 0; a < s - 1; a++) {
        const l = e[a];
        t2.j[l] ? i = t2.j[l] : (i = new Qt(r), i.jr = o.slice(), t2.j[l] = i), t2 = i;
      }
      return i = new Qt(n), i.jr = o.slice(), t2.j[e[s - 1]] = i, i;
    }
    function Xp(t2) {
      const e = [], n = [];
      let r = 0, o = "0123456789";
      for (; r < t2.length; ) {
        let i = 0;
        for (; o.indexOf(t2[r + i]) >= 0; )
          i++;
        if (i > 0) {
          e.push(n.join(""));
          for (let s = parseInt(t2.substring(r, r + i), 10); s > 0; s--)
            n.pop();
          r += i;
        } else
          n.push(t2[r]), r++;
      }
      return e;
    }
    const Li = {
      defaultProtocol: "http",
      events: null,
      format: Zp,
      formatHref: Zp,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: 1 / 0,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    function Su(t2, e = null) {
      let n = Ho({}, Li);
      t2 && (n = Ho(n, t2 instanceof Su ? t2.o : t2));
      const r = n.ignoreTags, o = [];
      for (let i = 0; i < r.length; i++)
        o.push(r[i].toUpperCase());
      this.o = n, e && (this.defaultRender = e), this.ignoreTags = o;
    }
    Su.prototype = {
      o: Li,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(t2) {
        return t2;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(t2) {
        return this.get("validate", t2.toString(), t2);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(t2, e, n) {
        const r = e != null;
        let o = this.o[t2];
        return o && (typeof o == "object" ? (o = n.t in o ? o[n.t] : Li[t2], typeof o == "function" && r && (o = o(e, n))) : typeof o == "function" && r && (o = o(e, n.t, n)), o);
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(t2, e, n) {
        let r = this.o[t2];
        return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(t2) {
        const e = t2.render(this);
        return (this.get("render", null, t2) || this.defaultRender)(e, t2.t, t2);
      }
    };
    function Zp(t2) {
      return t2;
    }
    function Rg(t2, e) {
      this.t = "token", this.v = t2, this.tk = e;
    }
    Rg.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
       */
      toHref(t2) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(t2) {
        const e = this.toString(), n = t2.get("truncate", e, this), r = t2.get("format", e, this);
        return n && r.length > n ? r.substring(0, n) + "…" : r;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(t2) {
        return t2.get("formatHref", this.toHref(t2.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(t2 = Li.defaultProtocol) {
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(t2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(t2) {
        return {
          type: this.t,
          value: this.toFormattedString(t2),
          isLink: this.isLink,
          href: this.toFormattedHref(t2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(t2) {
        return t2.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(t2) {
        const e = this, n = this.toHref(t2.get("defaultProtocol")), r = t2.get("formatHref", n, this), o = t2.get("tagName", n, e), i = this.toFormattedString(t2), s = {}, a = t2.get("className", n, e), l = t2.get("target", n, e), c2 = t2.get("rel", n, e), u = t2.getObj("attributes", n, e), d = t2.getObj("events", n, e);
        return s.href = r, a && (s.class = a), l && (s.target = l), c2 && (s.rel = c2), u && Ho(s, u), {
          tagName: o,
          attributes: s,
          content: i,
          eventListeners: d
        };
      }
    };
    function Ga(t2, e) {
      class n extends Rg {
        constructor(o, i) {
          super(o, i), this.t = t2;
        }
      }
      for (const r in e)
        n.prototype[r] = e[r];
      return n.t = t2, n;
    }
    const Qp = Ga("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    }), ef = Ga("text"), jN = Ga("nl"), Es = Ga("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(t2 = Li.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${t2}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const t2 = this.tk;
        return t2.length >= 2 && t2[0].t !== Di && t2[1].t === xr;
      }
    }), gn = (t2) => new Qt(t2);
    function YN({
      groups: t2
    }) {
      const e = t2.domain.concat([ha, ma, _r, ga, ba, ya, va, Ea, bn, bu, fi, ka, wa, _a, Wn, Ca, mi, Sa]), n = [xr, Eu, Vn, ku, fi, hi, wu, _u, oa, ia, di, pi, ta, ea, na, ra, sa, aa, la, ca, ua, da, pa, fa], r = [ha, vu, ma, ga, ba, ya, va, Ea, bn, di, pi, fi, ka, wa, _a, hi, Wn, Ca, mi, Sa], o = gn(), i = $(o, mi);
      xe(i, r, i), xe(i, t2.domain, i);
      const s = gn(), a = gn(), l = gn();
      xe(o, t2.domain, s), xe(o, t2.scheme, a), xe(o, t2.slashscheme, l), xe(s, r, i), xe(s, t2.domain, s);
      const c2 = $(s, _r);
      $(i, _r, c2), $(a, _r, c2), $(l, _r, c2);
      const u = $(i, Vn);
      xe(u, r, i), xe(u, t2.domain, i);
      const d = gn();
      xe(c2, t2.domain, d), xe(d, t2.domain, d);
      const p2 = $(d, Vn);
      xe(p2, t2.domain, d);
      const f = gn(Qp);
      xe(p2, t2.tld, f), xe(p2, t2.utld, f), $(c2, Di, f);
      const h2 = $(d, bn);
      $(h2, bn, h2), xe(h2, t2.domain, d), xe(f, t2.domain, d), $(f, Vn, p2), $(f, bn, h2);
      const m = $(f, xr);
      xe(m, t2.numeric, Qp);
      const g = $(s, bn), b = $(s, Vn);
      $(g, bn, g), xe(g, t2.domain, s), xe(b, r, i), xe(b, t2.domain, s);
      const E = gn(Es);
      xe(b, t2.tld, E), xe(b, t2.utld, E), xe(E, t2.domain, s), xe(E, r, i), $(E, Vn, b), $(E, bn, g), $(E, _r, c2);
      const _ = $(E, xr), v = gn(Es);
      xe(_, t2.numeric, v);
      const T = gn(Es), S = gn();
      xe(T, e, T), xe(T, n, S), xe(S, e, T), xe(S, n, S), $(E, Wn, T), $(v, Wn, T);
      const F = $(a, xr), V = $(l, xr), L = $(V, Wn), W = $(L, Wn);
      xe(a, t2.domain, s), $(a, Vn, b), $(a, bn, g), xe(l, t2.domain, s), $(l, Vn, b), $(l, bn, g), xe(F, t2.domain, T), $(F, Wn, T), $(F, hi, T), xe(W, t2.domain, T), xe(W, e, T), $(W, Wn, T);
      const te = [
        [di, pi],
        // {}
        [ea, ta],
        // []
        [na, ra],
        // ()
        [oa, ia],
        // <>
        [sa, aa],
        // （）
        [la, ca],
        // 「」
        [ua, da],
        // 『』
        [pa, fa]
        // ＜＞
      ];
      for (let de = 0; de < te.length; de++) {
        const [ke, Ee] = te[de], fe = $(T, ke);
        $(S, ke, fe), $(fe, Ee, T);
        const he = gn(Es);
        xe(fe, e, he);
        const N = gn();
        xe(fe, n), xe(he, e, he), xe(he, n, N), xe(N, e, he), xe(N, n, N), $(he, Ee, T), $(N, Ee, T);
      }
      return $(o, Di, E), $(o, yu, jN), {
        start: o,
        tokens: Ag
      };
    }
    function JN(t2, e, n) {
      let r = n.length, o = 0, i = [], s = [];
      for (; o < r; ) {
        let a = t2, l = null, c2 = null, u = 0, d = null, p2 = -1;
        for (; o < r && !(l = a.go(n[o].t)); )
          s.push(n[o++]);
        for (; o < r && (c2 = l || a.go(n[o].t)); )
          l = null, a = c2, a.accepts() ? (p2 = 0, d = a) : p2 >= 0 && p2++, o++, u++;
        if (p2 < 0)
          o -= u, o < r && (s.push(n[o]), o++);
        else {
          s.length > 0 && (i.push(Ll(ef, e, s)), s = []), o -= p2, u -= p2;
          const f = d.t, h2 = n.slice(o - u, o);
          i.push(Ll(f, e, h2));
        }
      }
      return s.length > 0 && i.push(Ll(ef, e, s)), i;
    }
    function Ll(t2, e, n) {
      const r = n[0].s, o = n[n.length - 1].e, i = e.slice(r, o);
      return new t2(i, n);
    }
    const XN = typeof console < "u" && console && console.warn || (() => {
    }), ZN = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", ot = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
    function QN() {
      return Qt.groups = {}, ot.scanner = null, ot.parser = null, ot.tokenQueue = [], ot.pluginQueue = [], ot.customSchemes = [], ot.initialized = false, ot;
    }
    function tf(t2, e = false) {
      if (ot.initialized && XN(`linkifyjs: already initialized - will not register custom scheme "${t2}" ${ZN}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t2))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
      ot.customSchemes.push([t2, e]);
    }
    function eA() {
      ot.scanner = qN(ot.customSchemes);
      for (let t2 = 0; t2 < ot.tokenQueue.length; t2++)
        ot.tokenQueue[t2][1]({
          scanner: ot.scanner
        });
      ot.parser = YN(ot.scanner.tokens);
      for (let t2 = 0; t2 < ot.pluginQueue.length; t2++)
        ot.pluginQueue[t2][1]({
          scanner: ot.scanner,
          parser: ot.parser
        });
      return ot.initialized = true, ot;
    }
    function Cu(t2) {
      return ot.initialized || eA(), JN(ot.parser.start, t2, Mg(ot.scanner.start, t2));
    }
    Cu.scan = Mg;
    function Ig(t2, e = null, n = null) {
      if (e && typeof e == "object") {
        if (n)
          throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        n = e, e = null;
      }
      const r = new Su(n), o = Cu(t2), i = [];
      for (let s = 0; s < o.length; s++) {
        const a = o[s];
        a.isLink && (!e || a.t === e) && r.check(a) && i.push(a.toFormattedObject(r));
      }
      return i;
    }
    function tA(t2) {
      return t2.length === 1 ? t2[0].isLink : t2.length === 3 && t2[1].isLink ? ["()", "[]"].includes(t2[0].value + t2[2].value) : false;
    }
    function nA(t2) {
      return new Ue({
        key: new Je("autolink"),
        appendTransaction: (e, n, r) => {
          const o = e.some((c2) => c2.docChanged) && !n.doc.eq(r.doc), i = e.some((c2) => c2.getMeta("preventAutolink"));
          if (!o || i)
            return;
          const { tr: s } = r, a = EE(n.doc, [...e]);
          if (xE(a).forEach(({ newRange: c2 }) => {
            const u = wE(r.doc, c2, (f) => f.isTextblock);
            let d, p2;
            if (u.length > 1 ? (d = u[0], p2 = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && r.doc.textBetween(c2.from, c2.to, " ", " ").endsWith(" ") && (d = u[0], p2 = r.doc.textBetween(d.pos, c2.to, void 0, " ")), d && p2) {
              const f = p2.split(" ").filter((b) => b !== "");
              if (f.length <= 0)
                return false;
              const h2 = f[f.length - 1], m = d.pos + p2.lastIndexOf(h2);
              if (!h2)
                return false;
              const g = Cu(h2).map((b) => b.toObject(t2.defaultProtocol));
              if (!tA(g))
                return false;
              g.filter((b) => b.isLink).map((b) => ({
                ...b,
                from: m + b.start + 1,
                to: m + b.end + 1
              })).filter((b) => r.schema.marks.code ? !r.doc.rangeHasMark(b.from, b.to, r.schema.marks.code) : true).filter((b) => t2.validate(b.value)).filter((b) => t2.shouldAutoLink(b.value)).forEach((b) => {
                jc(b.from, b.to, r.doc).some((E) => E.mark.type === t2.type) || s.addMark(b.from, b.to, t2.type.create({
                  href: b.href
                }));
              });
            }
          }), !!s.steps.length)
            return s;
        }
      });
    }
    function rA(t2) {
      return new Ue({
        key: new Je("handleClickLink"),
        props: {
          handleClick: (e, n, r) => {
            var o, i;
            if (r.button !== 0 || !e.editable)
              return false;
            let s = r.target;
            const a = [];
            for (; s.nodeName !== "DIV"; )
              a.push(s), s = s.parentNode;
            if (!a.find((p2) => p2.nodeName === "A"))
              return false;
            const l = Wh(e.state, t2.type.name), c2 = r.target, u = (o = c2 == null ? void 0 : c2.href) !== null && o !== void 0 ? o : l.href, d = (i = c2 == null ? void 0 : c2.target) !== null && i !== void 0 ? i : l.target;
            return c2 && u ? (window.open(u, d), true) : false;
          }
        }
      });
    }
    function oA(t2) {
      return new Ue({
        key: new Je("handlePasteLink"),
        props: {
          handlePaste: (e, n, r) => {
            const { state: o } = e, { selection: i } = o, { empty: s } = i;
            if (s)
              return false;
            let a = "";
            r.content.forEach((c2) => {
              a += c2.textContent;
            });
            const l = Ig(a, { defaultProtocol: t2.defaultProtocol }).find((c2) => c2.isLink && c2.value === a);
            return !a || !l ? false : t2.editor.commands.setMark(t2.type, {
              href: l.href
            });
          }
        }
      });
    }
    const iA = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
    function Wr(t2, e) {
      const n = [
        "http",
        "https",
        "ftp",
        "ftps",
        "mailto",
        "tel",
        "callto",
        "sms",
        "cid",
        "xmpp"
      ];
      return e && e.forEach((r) => {
        const o = typeof r == "string" ? r : r.scheme;
        o && n.push(o);
      }), !t2 || t2.replace(iA, "").match(new RegExp(
        // eslint-disable-next-line no-useless-escape
        `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
        "i"
      ));
    }
    const Dg = _n.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      exitable: true,
      onCreate() {
        this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t2) => {
          if (typeof t2 == "string") {
            tf(t2);
            return;
          }
          tf(t2.scheme, t2.optionalSlashes);
        });
      },
      onDestroy() {
        QN();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          defaultProtocol: "http",
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          isAllowedUri: (t2, e) => !!Wr(t2, e.protocols),
          validate: (t2) => !!t2,
          shouldAutoLink: (t2) => !!t2
        };
      },
      addAttributes() {
        return {
          href: {
            default: null,
            parseHTML(t2) {
              return t2.getAttribute("href");
            }
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]",
            getAttrs: (t2) => {
              const e = t2.getAttribute("href");
              return !e || !this.options.isAllowedUri(e, {
                defaultValidate: (n) => !!Wr(n, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol
              }) ? false : null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return this.options.isAllowedUri(t2.href, {
          defaultValidate: (e) => !!Wr(e, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? ["a", Be(this.options.HTMLAttributes, t2), 0] : [
          "a",
          Be(this.options.HTMLAttributes, { ...t2, href: "" }),
          0
        ];
      },
      addCommands() {
        return {
          setLink: (t2) => ({ chain: e }) => {
            const { href: n } = t2;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Wr(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().setMark(this.name, t2).setMeta("preventAutolink", true).run() : false;
          },
          toggleLink: (t2) => ({ chain: e }) => {
            const { href: n } = t2;
            return this.options.isAllowedUri(n, {
              defaultValidate: (r) => !!Wr(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().toggleMark(this.name, t2, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() : false;
          },
          unsetLink: () => ({ chain: t2 }) => t2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run()
        };
      },
      addPasteRules() {
        return [
          $r({
            find: (t2) => {
              const e = [];
              if (t2) {
                const { protocols: n, defaultProtocol: r } = this.options, o = Ig(t2).filter((i) => i.isLink && this.options.isAllowedUri(i.value, {
                  defaultValidate: (s) => !!Wr(s, n),
                  protocols: n,
                  defaultProtocol: r
                }));
                o.length && o.forEach((i) => e.push({
                  text: i.value,
                  data: {
                    href: i.href
                  },
                  index: i.start
                }));
              }
              return e;
            },
            type: this.type,
            getAttributes: (t2) => {
              var e;
              return {
                href: (e = t2.data) === null || e === void 0 ? void 0 : e.href
              };
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const t2 = [], { protocols: e, defaultProtocol: n } = this.options;
        return this.options.autolink && t2.push(nA({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (r) => this.options.isAllowedUri(r, {
            defaultValidate: (o) => !!Wr(o, e),
            protocols: e,
            defaultProtocol: n
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })), this.options.openOnClick === true && t2.push(rA({
          type: this.type
        })), this.options.linkOnPaste && t2.push(oA({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })), t2;
      }
    });
    function sA(t2) {
      return new Ue({
        key: new Je("handleClickSelectLink"),
        props: {
          handleClick: (e, n, r) => {
            const { schema: o, doc: i, tr: s } = e.state, a = Vo(i.resolve(n), o.marks.link);
            if (!a) return false;
            const l = i.resolve(a.from), c2 = i.resolve(a.to), u = s.setSelection(new ie(l, c2));
            return e.dispatch(u), true;
          }
        }
      });
    }
    const aA = Dg.extend({
      addProseMirrorPlugins() {
        var t2;
        return [
          ...((t2 = this.parent) == null ? void 0 : t2.call(this)) || [],
          sA({
            type: this.type
          })
        ];
      }
    }).configure({
      openOnClick: false
    }), lA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, r) => (openBlock(), createBlock(unref(mr), mergeProps(e, { class: "o-paragraph-view" }), {
          default: withCtx(() => [
            createVNode(unref(hr), {
              as: "p",
              style: normalizeStyle(`text-align: ${n.node.attrs.textAlign}`)
            }, null, 8, ["style"])
          ]),
          _: 1
        }, 16));
      }
    }), cA = Tm.extend({
      draggable: false,
      addNodeView() {
        return Ln(lA, {
          stopEvent: () => false
        });
      }
    }), Lg = it.create({
      name: "tableCell",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (t2) => {
              const e = t2.getAttribute("colwidth");
              return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
            }
          }
        };
      },
      tableRole: "cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "td" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["td", Be(this.options.HTMLAttributes, t2), 0];
      }
    }), uA = { class: "add" }, dA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(false);
        function i() {
          o.value = true;
        }
        function s() {
          a("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function a(l, c2 = {}) {
          l === "tableDeleteRow" && (o.value = false), setTimeout(() => {
            r(e.editor, l, c2);
          }, 0);
        }
        return (l, c2) => (openBlock(), createBlock(unref(ou), mergeProps({
          class: "o-table-cell-view",
          as: "td"
        }, l.node.attrs, {
          style: { background: l.node.attrs.background }
        }), {
          default: withCtx(() => {
            var u;
            return [
              (u = l.editor) != null && u.isEditable ? (openBlock(), createBlock(unref(Ai), {
                key: 0,
                modelValue: o.value,
                "onUpdate:modelValue": c2[2] || (c2[2] = (d) => o.value = d),
                placement: "left",
                "tippy-class": "o-row-popover",
                offset: [16, 40],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(Pt), {
                    icon: "select_all",
                    tooltip: unref(n)("table.removeColumn"),
                    onClick: s
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(Pt), {
                    icon: "delete",
                    tooltip: unref(n)("table.removeRow"),
                    onClick: c2[1] || (c2[1] = (d) => a("tableDeleteRow"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["row-handler", { active: o.value }]),
                    onClick: i
                  }, [
                    createBaseVNode("div", uA, [
                      c2[3] || (c2[3] = createBaseVNode("div", { class: "indicator" }, [
                        createBaseVNode("svg", {
                          width: "3",
                          height: "3",
                          viewBox: "0 0 3 3",
                          fill: "none"
                        }, [
                          createBaseVNode("circle", {
                            cx: "1.5",
                            cy: "1.5",
                            r: "1.5",
                            fill: "#BBBFC4"
                          })
                        ])
                      ], -1)),
                      createVNode(unref(cc), {
                        icon: "add_circle",
                        color: unref(Pe).blue,
                        tooltip: unref(n)("table.addRow"),
                        placement: "left",
                        onClick: c2[0] || (c2[0] = withModifiers((d) => a("tableAddRow"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"])) : createCommentVNode("", true),
              createVNode(unref(hr))
            ];
          }),
          _: 1
        }, 16, ["style"]));
      }
    }), pA = Lg.extend({
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Ln(dA, {
          stopEvent: () => false
        });
      }
    }), Pg = it.create({
      name: "tableHeader",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (t2) => {
              const e = t2.getAttribute("colwidth");
              return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
            }
          }
        };
      },
      tableRole: "header_cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "th" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["th", Be(this.options.HTMLAttributes, t2), 0];
      }
    }), fA = { class: "add" }, hA = { class: "add" }, mA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { tr: n } = Le(), { run: r } = Ze(), o = ref(false), i = ref(false);
        function s() {
          setTimeout(() => {
            o.value = true;
          }, 0);
        }
        function a() {
          i.value = true;
        }
        function l() {
          o.value = false, u("tableSelectColumn", {
            pos: e.getPos()
          });
        }
        function c2() {
          u("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function u(d, p2 = {}) {
          d === "tableDeleteRow" ? i.value = false : d === "tableDeleteColumn" && (o.value = false), setTimeout(() => {
            r(e.editor, d, p2);
          }, 0);
        }
        return (d, p2) => (openBlock(), createBlock(unref(ou), mergeProps({
          class: "o-table-header-view",
          as: "th"
        }, d.node.attrs, {
          style: { background: d.node.attrs.background }
        }), {
          default: withCtx(() => {
            var f;
            return [
              (f = d.editor) != null && f.isEditable ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createVNode(unref(Ai), {
                  modelValue: o.value,
                  "onUpdate:modelValue": p2[2] || (p2[2] = (h2) => o.value = h2),
                  placement: "top",
                  "tippy-class": "o-column-popover",
                  offset: [0, 20],
                  "hide-click-outside": ""
                }, {
                  "popover-content": withCtx(() => [
                    createVNode(unref(Pt), {
                      icon: "select_all",
                      tooltip: unref(n)("table.removeColumn"),
                      onClick: l
                    }, null, 8, ["tooltip"]),
                    createVNode(unref(Pt), {
                      icon: "delete",
                      tooltip: unref(n)("table.removeColumn"),
                      onClick: p2[1] || (p2[1] = (h2) => u("tableDeleteColumn"))
                    }, null, 8, ["tooltip"])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("section", {
                      class: normalizeClass(["col-handler", { active: o.value }]),
                      onClick: s
                    }, [
                      createBaseVNode("div", fA, [
                        p2[6] || (p2[6] = createBaseVNode("div", { class: "indicator" }, [
                          createBaseVNode("svg", {
                            width: "3",
                            height: "3",
                            viewBox: "0 0 3 3",
                            fill: "none"
                          }, [
                            createBaseVNode("circle", {
                              cx: "1.5",
                              cy: "1.5",
                              r: "1.5",
                              fill: "#BBBFC4"
                            })
                          ])
                        ], -1)),
                        createVNode(unref(cc), {
                          icon: "add_circle",
                          color: unref(Pe).blue,
                          tooltip: unref(n)("table.addColumn"),
                          onClick: p2[0] || (p2[0] = withModifiers((h2) => u("tableAddColumn"), ["stop"]))
                        }, null, 8, ["color", "tooltip"])
                      ])
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createVNode(unref(Ai), {
                  modelValue: i.value,
                  "onUpdate:modelValue": p2[5] || (p2[5] = (h2) => i.value = h2),
                  placement: "left",
                  "tippy-class": "o-row-popover",
                  offset: [15, 40],
                  "hide-click-outside": ""
                }, {
                  "popover-content": withCtx(() => [
                    createVNode(unref(Pt), {
                      icon: "select_all",
                      tooltip: unref(n)("table.removeColumn"),
                      onClick: c2
                    }, null, 8, ["tooltip"]),
                    createVNode(unref(Pt), {
                      icon: "delete",
                      tooltip: unref(n)("table.removeRow"),
                      onClick: p2[4] || (p2[4] = (h2) => u("tableDeleteRow"))
                    }, null, 8, ["tooltip"])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("section", {
                      class: normalizeClass(["row-handler", { active: i.value }]),
                      onClick: a
                    }, [
                      createBaseVNode("div", hA, [
                        p2[7] || (p2[7] = createBaseVNode("div", { class: "indicator" }, [
                          createBaseVNode("svg", {
                            width: "3",
                            height: "3",
                            viewBox: "0 0 3 3",
                            fill: "none"
                          }, [
                            createBaseVNode("circle", {
                              cx: "1.5",
                              cy: "1.5",
                              r: "1.5",
                              fill: "#BBBFC4"
                            })
                          ])
                        ], -1)),
                        createVNode(unref(cc), {
                          icon: "add_circle",
                          color: unref(Pe).blue,
                          tooltip: unref(n)("table.addRow"),
                          placement: "left",
                          onClick: p2[3] || (p2[3] = withModifiers((h2) => u("tableAddRow"), ["stop"]))
                        }, null, 8, ["color", "tooltip"])
                      ])
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ], 64)) : createCommentVNode("", true),
              createVNode(unref(hr))
            ];
          }),
          _: 1
        }, 16, ["style"]));
      }
    }), gA = Pg.extend({
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Ln(mA, {
          stopEvent: () => false
        });
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const bA = it.create({
      name: "table-wrapper",
      group: "block",
      content: "table",
      draggable: true,
      parseHTML() {
        return [{ tag: "table-wrapper" }];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["table-wrapper", Be(t2), 0];
      }
    }), yA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = inject("sideNode", { value: false }), r = ref(false), o = computed(() => {
          const { selection: s } = e.editor.view.state, a = s.from, l = e.getPos(), c2 = l + e.node.nodeSize;
          return a >= l && a <= c2;
        });
        function i(s) {
          r.value = s;
        }
        return watch(o, (s) => {
          i(s);
        }), (s, a) => (openBlock(), createBlock(unref(mr), mergeProps(e, {
          class: ["o-table-wrapper-view", { "side-node-enabled": unref(n) }]
        }), {
          default: withCtx(() => [
            createVNode(unref(hr), { as: "table" })
          ]),
          _: 1
        }, 16, ["class"]));
      }
    }), vA = bA.extend({
      addNodeView() {
        return Ln(yA, {
          stopEvent: () => false
        });
      }
    });
    var Rt = [];
    for (var Pl = 0; Pl < 256; ++Pl)
      Rt.push((Pl + 256).toString(16).slice(1));
    function EA(t2, e = 0) {
      return (Rt[t2[e + 0]] + Rt[t2[e + 1]] + Rt[t2[e + 2]] + Rt[t2[e + 3]] + "-" + Rt[t2[e + 4]] + Rt[t2[e + 5]] + "-" + Rt[t2[e + 6]] + Rt[t2[e + 7]] + "-" + Rt[t2[e + 8]] + Rt[t2[e + 9]] + "-" + Rt[t2[e + 10]] + Rt[t2[e + 11]] + Rt[t2[e + 12]] + Rt[t2[e + 13]] + Rt[t2[e + 14]] + Rt[t2[e + 15]]).toLowerCase();
    }
    var ks, kA = new Uint8Array(16);
    function wA() {
      if (!ks && (ks = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ks))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return ks(kA);
    }
    var _A = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const nf = {
      randomUUID: _A
    };
    function SA(t2, e, n) {
      if (nf.randomUUID && !t2)
        return nf.randomUUID();
      t2 = t2 || {};
      var r = t2.random || (t2.rng || wA)();
      return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, EA(r);
    }
    const CA = () => SA(), xA = Ke.create({
      name: "uniqueID",
      priority: 1e4,
      addOptions: () => ({
        attributeName: "data-id",
        types: ["heading"],
        enableRender: false,
        generateId: () => CA()
      }),
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              [this.options.attributeName]: {
                default: this.options.generateId(),
                parseHTML: (t2) => t2.getAttribute(this.options.attributeName),
                renderHTML: (t2) => this.options.enableRender ? {
                  [this.options.attributeName]: t2[this.options.attributeName]
                } : {}
              }
            }
          }
        ];
      }
    }), TA = {
      key: 1,
      class: "video-container"
    }, OA = { key: 1 }, NA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref(false), r = ref({}), o = ref(null), i = ref(false), s = ref(false), a = computed({
          get() {
            return e.node.attrs.caption;
          },
          set(g) {
            e.updateAttributes({ caption: g });
          }
        }), l = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        });
        function c2(g) {
          switch (n.value = false, g.value) {
            case "replace":
              m(true);
              break;
          }
        }
        function u() {
          i.value = true, setTimeout(() => {
            var g;
            (g = o.value) == null || g.focus();
          }, 0);
        }
        function d() {
          i.value = false;
        }
        function p2() {
          l.value === "init" && m(true);
        }
        function f(g) {
          n.value = true, r.value = g;
        }
        function h2(g) {
          l.value = g, m(false);
        }
        function m(g) {
          s.value = g;
        }
        return onMounted(() => {
          m(l.value === "init");
        }), (g, b) => {
          var E;
          return openBlock(), createBlock(unref(mr), mergeProps(e, {
            class: ["o-video-view", {
              readonly: !((E = g.editor) != null && E.isEditable),
              init: l.value === "init"
            }],
            as: "div",
            onContextmenu: withModifiers(f, ["prevent"]),
            onClick: p2
          }), {
            default: withCtx(() => [
              createVNode(unref(Ai), {
                modelValue: s.value,
                "onUpdate:modelValue": b[1] || (b[1] = (_) => s.value = _),
                placement: l.value === "init" ? "bottom" : "top"
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(Rm), {
                    val: l.value === "init" ? "" : l.value,
                    type: "video",
                    onInput: h2
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var _;
                  return [
                    l.value === "init" ? (openBlock(), createBlock(unref(Nm), {
                      key: 0,
                      icon: "videocam",
                      placeholder: "Add a video"
                    })) : (openBlock(), createElementBlock("div", TA, [
                      b[3] || (b[3] = createBaseVNode("div", { class: "video-cover" }, null, -1)),
                      createVNode(unref(Am), mergeProps(e, { onAction: c2 }), {
                        default: withCtx(() => [
                          createVNode(unref(je), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: u
                          })
                        ]),
                        _: 1
                      }, 16),
                      createBaseVNode("video", mergeProps(g.node.attrs, {
                        draggable: "true",
                        "data-drag-handle": "",
                        controls: ""
                      }), [
                        createBaseVNode("source", normalizeProps(guardReactiveProps(g.node.attrs)), null, 16)
                      ], 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: u
                      }, [
                        (_ = g.editor) != null && _.isEditable && i.value ? (openBlock(), createBlock(unref(Wi), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: o,
                          class: "caption-input",
                          modelValue: a.value,
                          "onUpdate:modelValue": b[0] || (b[0] = (v) => a.value = v),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: d
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", OA, toDisplayString(a.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(au), {
                modelValue: n.value,
                "onUpdate:modelValue": b[2] || (b[2] = (_) => n.value = _),
                event: r.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Wo), mergeProps(e, { onAction: c2 }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class"]);
        };
      }
    }), AA = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, MA = it.create({
      name: "video",
      draggable: true,
      addOptions() {
        return {
          inline: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      addAttributes() {
        return {
          // small, medium, large
          caption: {
            default: "",
            rendered: false
          },
          src: {
            default: null,
            parseHTML: (t2) => {
              const e = t2.firstElementChild;
              return (e == null ? void 0 : e.src) ?? "";
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "video"
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "video",
          {
            caption: t2.attrs.caption
          },
          ["source", Be(this.options.HTMLAttributes, e)]
        ];
      },
      addCommands() {
        return {
          setVideo: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: AA,
            type: this.type,
            getAttributes: (t2) => {
              const [e] = t2;
              return { src: e };
            }
          })
        ];
      },
      addNodeView() {
        return Ln(NA);
      }
    }), RA = [
      "BackColor",
      "Focus",
      "FontFamily",
      "ForeColor",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline",
      "OHorizontalRule",
      "OUniqueID"
    ], IA = [
      "BackColor",
      "Blockquote",
      "Bold",
      "BulletList",
      "Code",
      "CodeBlockLowlight",
      "Focus",
      "FontFamily",
      "ForeColor",
      "HorizontalRule",
      "Image",
      "Italic",
      "Link",
      "ListItem",
      "OrderedList",
      "Strike",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline"
    ], DA = [
      "OBlockquote",
      "OCallout",
      "OCodeBlock",
      "OColon",
      "OColorHighlighter",
      "OColumnExtension",
      "ODiagram",
      "ODoc",
      "ODraggableItem",
      "OEmbed",
      "OFocus",
      "OFontFamily",
      "OFormatClear",
      "OHeading",
      "OHorizontalRule",
      "OIframe",
      "OImage",
      "OIndent",
      "OInsertHtml",
      "OKatexBlock",
      "OKatexInline",
      "OLineHeight",
      "OLink",
      "OModelViewer",
      "OParagraph",
      "OPrint",
      "OSlash",
      "OSlashZh",
      "OTOC",
      "OTableWrapper",
      "OTitle",
      "OTodoItem",
      "OTrailingNode",
      "OUniqueID",
      "OVideo"
    ], LA = [...IA, ...DA], PA = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, BA = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, $A = _n.create({
      name: "highlight",
      addOptions() {
        return {
          multicolor: false,
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return this.options.multicolor ? {
          color: {
            default: null,
            parseHTML: (t2) => t2.getAttribute("data-color") || t2.style.backgroundColor,
            renderHTML: (t2) => t2.color ? {
              "data-color": t2.color,
              style: `background-color: ${t2.color}; color: inherit`
            } : {}
          }
        } : {};
      },
      parseHTML() {
        return [
          {
            tag: "mark"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["mark", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setHighlight: (t2) => ({ commands: e }) => e.setMark(this.name, t2),
          toggleHighlight: (t2) => ({ commands: e }) => e.toggleMark(this.name, t2),
          unsetHighlight: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
        };
      },
      addInputRules() {
        return [
          lo({
            find: PA,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          $r({
            find: BA,
            type: this.type
          })
        ];
      }
    }), FA = Ke.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Je("focus"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const { isEditable: n, isFocused: r } = this.editor, { anchor: o } = e, i = [];
                if (!n || !r)
                  return He.create(t2, []);
                let s = 0;
                this.options.mode === "deepest" && t2.descendants((l, c2) => {
                  if (l.isText)
                    return;
                  if (!(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  s += 1;
                });
                let a = 0;
                return t2.descendants((l, c2) => {
                  if (l.isText || !(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  i.push(ht.node(c2, c2 + l.nodeSize, {
                    class: this.options.className
                  }));
                }), He.create(t2, i);
              }
            }
          })
        ];
      }
    }), zA = Ke.create({
      name: "fontFamily",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontFamily: {
                default: null,
                parseHTML: (t2) => t2.style.fontFamily,
                renderHTML: (t2) => t2.fontFamily ? {
                  style: `font-family: ${t2.fontFamily}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontFamily: (t2) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t2 }).run(),
          unsetFontFamily: () => ({ chain: t2 }) => t2().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
        };
      }
    }), HA = Ke.create({
      name: "color",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (t2) => {
                  var e;
                  return (e = t2.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
                },
                renderHTML: (t2) => t2.color ? {
                  style: `color: ${t2.color}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setColor: (t2) => ({ chain: e }) => e().setMark("textStyle", { color: t2 }).run(),
          unsetColor: () => ({ chain: t2 }) => t2().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
        };
      }
    }), UA = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, VA = it.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["img", Be(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setImage: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: UA,
            type: this.type,
            getAttributes: (t2) => {
              const [, , e, n, r] = t2;
              return { src: n, alt: e, title: r };
            }
          })
        ];
      }
    }), WA = /^\s*(\[([( |x])?\])\s$/, KA = it.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList"
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (t2) => {
              const e = t2.getAttribute("data-checked");
              return e === "" || e === "true";
            },
            renderHTML: (t2) => ({
              "data-checked": t2.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "li",
          Be(this.options.HTMLAttributes, e, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: t2.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      addKeyboardShortcuts() {
        const t2 = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        return this.options.nested ? {
          ...t2,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        } : t2;
      },
      addNodeView() {
        return ({ node: t2, HTMLAttributes: e, getPos: n, editor: r }) => {
          const o = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
          return i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c2) => c2.preventDefault()), a.addEventListener("change", (c2) => {
            if (!r.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked;
              return;
            }
            const { checked: u } = c2.target;
            r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: d }) => {
              const p2 = n();
              if (typeof p2 != "number")
                return false;
              const f = d.doc.nodeAt(p2);
              return d.setNodeMarkup(p2, void 0, {
                ...f == null ? void 0 : f.attrs,
                checked: u
              }), true;
            }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t2, u) || (a.checked = !a.checked));
          }), Object.entries(this.options.HTMLAttributes).forEach(([c2, u]) => {
            o.setAttribute(c2, u);
          }), o.dataset.checked = t2.attrs.checked, a.checked = t2.attrs.checked, i.append(a, s), o.append(i, l), Object.entries(e).forEach(([c2, u]) => {
            o.setAttribute(c2, u);
          }), {
            dom: o,
            contentDOM: l,
            update: (c2) => c2.type !== this.type ? false : (o.dataset.checked = c2.attrs.checked, a.checked = c2.attrs.checked, true)
          };
        };
      },
      addInputRules() {
        return [
          Lo({
            find: WA,
            type: this.type,
            getAttributes: (t2) => ({
              checked: t2[t2.length - 1] === "x"
            })
          })
        ];
      }
    }), qA = it.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["ul", Be(this.options.HTMLAttributes, t2, { "data-type": this.name }), 0];
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: t2 }) => t2.toggleList(this.name, this.options.itemTypeName)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    }), GA = Ke.create({
      name: "textAlign",
      addOptions() {
        return {
          types: [],
          alignments: ["left", "center", "right", "justify"],
          defaultAlignment: null
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              textAlign: {
                default: this.options.defaultAlignment,
                parseHTML: (t2) => {
                  const e = t2.style.textAlign;
                  return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
                },
                renderHTML: (t2) => t2.textAlign ? { style: `text-align: ${t2.textAlign}` } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setTextAlign: (t2) => ({ commands: e }) => this.options.alignments.includes(t2) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t2 })).every((n) => n) : false,
          unsetTextAlign: () => ({ commands: t2 }) => this.options.types.map((e) => t2.resetAttributes(e, "textAlign")).every((e) => e)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
          "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
          "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
          "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
        };
      }
    }), jA = (t2) => dt({
      find: /--$/,
      replace: t2 ?? "—"
    }), YA = (t2) => dt({
      find: /\.\.\.$/,
      replace: t2 ?? "…"
    }), JA = (t2) => dt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
      replace: t2 ?? "“"
    }), XA = (t2) => dt({
      find: /"$/,
      replace: t2 ?? "”"
    }), ZA = (t2) => dt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
      replace: t2 ?? "‘"
    }), QA = (t2) => dt({
      find: /'$/,
      replace: t2 ?? "’"
    }), eM = (t2) => dt({
      find: /<-$/,
      replace: t2 ?? "←"
    }), tM = (t2) => dt({
      find: /->$/,
      replace: t2 ?? "→"
    }), nM = (t2) => dt({
      find: /\(c\)$/,
      replace: t2 ?? "©"
    }), rM = (t2) => dt({
      find: /\(tm\)$/,
      replace: t2 ?? "™"
    }), oM = (t2) => dt({
      find: /\(sm\)$/,
      replace: t2 ?? "℠"
    }), iM = (t2) => dt({
      find: /\(r\)$/,
      replace: t2 ?? "®"
    }), sM = (t2) => dt({
      find: /(?:^|\s)(1\/2)\s$/,
      replace: t2 ?? "½"
    }), aM = (t2) => dt({
      find: /\+\/-$/,
      replace: t2 ?? "±"
    }), lM = (t2) => dt({
      find: /!=$/,
      replace: t2 ?? "≠"
    }), cM = (t2) => dt({
      find: /<<$/,
      replace: t2 ?? "«"
    }), uM = (t2) => dt({
      find: />>$/,
      replace: t2 ?? "»"
    }), dM = (t2) => dt({
      find: /\d+\s?([*x])\s?\d+$/,
      replace: t2 ?? "×"
    }), pM = (t2) => dt({
      find: /\^2$/,
      replace: t2 ?? "²"
    }), fM = (t2) => dt({
      find: /\^3$/,
      replace: t2 ?? "³"
    }), hM = (t2) => dt({
      find: /(?:^|\s)(1\/4)\s$/,
      replace: t2 ?? "¼"
    }), mM = (t2) => dt({
      find: /(?:^|\s)(3\/4)\s$/,
      replace: t2 ?? "¾"
    }), gM = Ke.create({
      name: "typography",
      addOptions() {
        return {
          closeDoubleQuote: "”",
          closeSingleQuote: "’",
          copyright: "©",
          ellipsis: "…",
          emDash: "—",
          laquo: "«",
          leftArrow: "←",
          multiplication: "×",
          notEqual: "≠",
          oneHalf: "½",
          oneQuarter: "¼",
          openDoubleQuote: "“",
          openSingleQuote: "‘",
          plusMinus: "±",
          raquo: "»",
          registeredTrademark: "®",
          rightArrow: "→",
          servicemark: "℠",
          superscriptThree: "³",
          superscriptTwo: "²",
          threeQuarters: "¾",
          trademark: "™"
        };
      },
      addInputRules() {
        const t2 = [];
        return this.options.emDash !== false && t2.push(jA(this.options.emDash)), this.options.ellipsis !== false && t2.push(YA(this.options.ellipsis)), this.options.openDoubleQuote !== false && t2.push(JA(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== false && t2.push(XA(this.options.closeDoubleQuote)), this.options.openSingleQuote !== false && t2.push(ZA(this.options.openSingleQuote)), this.options.closeSingleQuote !== false && t2.push(QA(this.options.closeSingleQuote)), this.options.leftArrow !== false && t2.push(eM(this.options.leftArrow)), this.options.rightArrow !== false && t2.push(tM(this.options.rightArrow)), this.options.copyright !== false && t2.push(nM(this.options.copyright)), this.options.trademark !== false && t2.push(rM(this.options.trademark)), this.options.servicemark !== false && t2.push(oM(this.options.servicemark)), this.options.registeredTrademark !== false && t2.push(iM(this.options.registeredTrademark)), this.options.oneHalf !== false && t2.push(sM(this.options.oneHalf)), this.options.plusMinus !== false && t2.push(aM(this.options.plusMinus)), this.options.notEqual !== false && t2.push(lM(this.options.notEqual)), this.options.laquo !== false && t2.push(cM(this.options.laquo)), this.options.raquo !== false && t2.push(uM(this.options.raquo)), this.options.multiplication !== false && t2.push(dM(this.options.multiplication)), this.options.superscriptTwo !== false && t2.push(pM(this.options.superscriptTwo)), this.options.superscriptThree !== false && t2.push(fM(this.options.superscriptThree)), this.options.oneQuarter !== false && t2.push(hM(this.options.oneQuarter)), this.options.threeQuarters !== false && t2.push(mM(this.options.threeQuarters)), t2;
      }
    }), bM = _n.create({
      name: "underline",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "u"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (t2) => t2.includes("underline") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["u", Be(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setUnderline: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleUnderline: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetUnderline: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline()
        };
      }
    }), Bg = it.create({
      name: "tableRow",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "(tableCell | tableHeader)*",
      tableRole: "row",
      parseHTML() {
        return [
          { tag: "tr" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["tr", Be(this.options.HTMLAttributes, t2), 0];
      }
    });
    function yM(t2) {
      var e;
      const { char: n, allowSpaces: r, allowToIncludeChar: o, allowedPrefixes: i, startOfLine: s, $position: a } = t2, l = r && !o, c2 = ok(n), u = new RegExp(`\\s${c2}$`), d = s ? "^" : "", p2 = o ? "" : c2, f = l ? new RegExp(`${d}${c2}.*?(?=\\s${p2}|$)`, "gm") : new RegExp(`${d}(?:^)?${c2}[^\\s${p2}]*`, "gm"), h2 = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
      if (!h2)
        return null;
      const m = a.pos - h2.length, g = Array.from(h2.matchAll(f)).pop();
      if (!g || g.input === void 0 || g.index === void 0)
        return null;
      const b = g.input.slice(Math.max(0, g.index - 1), g.index), E = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(b);
      if (i !== null && !E)
        return null;
      const _ = m + g.index;
      let v = _ + g[0].length;
      return l && u.test(h2.slice(v - 1, v + 1)) && (g[0] += " ", v += 1), _ < a.pos && v >= a.pos ? {
        range: {
          from: _,
          to: v
        },
        query: g[0].slice(n.length),
        text: g[0]
      } : null;
    }
    const vM = new Je("suggestion");
    function $g({ pluginKey: t2 = vM, editor: e, char: n = "@", allowSpaces: r = false, allowToIncludeChar: o = false, allowedPrefixes: i = [" "], startOfLine: s = false, decorationTag: a = "span", decorationClass: l = "suggestion", command: c2 = () => null, items: u = () => [], render: d = () => ({}), allow: p2 = () => true, findSuggestionMatch: f = yM }) {
      let h2;
      const m = d == null ? void 0 : d(), g = new Ue({
        key: t2,
        view() {
          return {
            update: async (b, E) => {
              var _, v, T, S, F, V, L;
              const W = (_ = this.key) === null || _ === void 0 ? void 0 : _.getState(E), te = (v = this.key) === null || v === void 0 ? void 0 : v.getState(b.state), de = W.active && te.active && W.range.from !== te.range.from, ke = !W.active && te.active, Ee = W.active && !te.active, fe = !ke && !Ee && W.query !== te.query, he = ke || de && fe, N = fe || de, D = Ee || de && fe;
              if (!he && !N && !D)
                return;
              const Y = D && !he ? W : te, oe = b.dom.querySelector(`[data-decoration-id="${Y.decorationId}"]`);
              h2 = {
                editor: e,
                range: Y.range,
                query: Y.query,
                text: Y.text,
                items: [],
                command: (ce) => c2({
                  editor: e,
                  range: Y.range,
                  props: ce
                }),
                decorationNode: oe,
                // virtual node for popper.js or tippy.js
                // this can be used for building popups without a DOM node
                clientRect: oe ? () => {
                  var ce;
                  const { decorationId: Se } = (ce = this.key) === null || ce === void 0 ? void 0 : ce.getState(e.state), Fe = b.dom.querySelector(`[data-decoration-id="${Se}"]`);
                  return (Fe == null ? void 0 : Fe.getBoundingClientRect()) || null;
                } : null
              }, he && ((T = m == null ? void 0 : m.onBeforeStart) === null || T === void 0 || T.call(m, h2)), N && ((S = m == null ? void 0 : m.onBeforeUpdate) === null || S === void 0 || S.call(m, h2)), (N || he) && (h2.items = await u({
                editor: e,
                query: Y.query
              })), D && ((F = m == null ? void 0 : m.onExit) === null || F === void 0 || F.call(m, h2)), N && ((V = m == null ? void 0 : m.onUpdate) === null || V === void 0 || V.call(m, h2)), he && ((L = m == null ? void 0 : m.onStart) === null || L === void 0 || L.call(m, h2));
            },
            destroy: () => {
              var b;
              h2 && ((b = m == null ? void 0 : m.onExit) === null || b === void 0 || b.call(m, h2));
            }
          };
        },
        state: {
          // Initialize the plugin's internal state.
          init() {
            return {
              active: false,
              range: {
                from: 0,
                to: 0
              },
              query: null,
              text: null,
              composing: false
            };
          },
          // Apply changes to the plugin state from a view transaction.
          apply(b, E, _, v) {
            const { isEditable: T } = e, { composing: S } = e.view, { selection: F } = b, { empty: V, from: L } = F, W = { ...E };
            if (W.composing = S, T && (V || e.view.composing)) {
              (L < E.range.from || L > E.range.to) && !S && !E.composing && (W.active = false);
              const te = f({
                char: n,
                allowSpaces: r,
                allowToIncludeChar: o,
                allowedPrefixes: i,
                startOfLine: s,
                $position: F.$from
              }), de = `id_${Math.floor(Math.random() * 4294967295)}`;
              te && p2({
                editor: e,
                state: v,
                range: te.range,
                isActive: E.active
              }) ? (W.active = true, W.decorationId = E.decorationId ? E.decorationId : de, W.range = te.range, W.query = te.query, W.text = te.text) : W.active = false;
            } else
              W.active = false;
            return W.active || (W.decorationId = null, W.range = { from: 0, to: 0 }, W.query = null, W.text = null), W;
          }
        },
        props: {
          // Call the keydown hook if suggestion is active.
          handleKeyDown(b, E) {
            var _;
            const { active: v, range: T } = g.getState(b.state);
            return v && ((_ = m == null ? void 0 : m.onKeyDown) === null || _ === void 0 ? void 0 : _.call(m, { view: b, event: E, range: T })) || false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(b) {
            const { active: E, range: _, decorationId: v } = g.getState(b);
            return E ? He.create(b.doc, [
              ht.inline(_.from, _.to, {
                nodeName: a,
                class: l,
                "data-decoration-id": v
              })
            ]) : null;
          }
        }
      });
      return g;
    }
    const EM = Ke.create({
      name: "slash",
      addOptions() {
        return {
          suggestion: {
            char: "/",
            command: ({
              editor: t2,
              range: e,
              props: n
            }) => {
              n.command({ editor: t2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          $g({
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), kM = Ke.create({
      name: "slash-zh",
      addOptions() {
        return {
          suggestion: {
            char: "、",
            command: ({
              editor: t2,
              range: e,
              props: n
            }) => {
              n.command({ editor: t2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          $g({
            pluginKey: new Je("slash-zh-suggestion"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), wM = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: t2, tr: e } = Le(), { onCommand: n } = Ze();
        return {
          locale: t2,
          tr: e,
          onCommand: n
        };
      },
      data() {
        return {
          view: "main",
          selectedIndex: 0
        };
      },
      components: {
        ODivider: xn,
        OIcon: ye,
        OList: Pn,
        OListItem: Tn
      },
      watch: {
        items() {
          this.selectedIndex = 0;
        }
      },
      methods: {
        onClick(t2) {
          switch (t2.value) {
            default:
              this.run(t2);
              break;
          }
          return true;
        },
        run(t2) {
          const e = this.editor.chain().focus().deleteRange(this.range), n = this.editor.commands;
          switch (t2.value) {
            case "codeBlock":
              n.deleteRange(this.range), this.editor.commands.setCodeBlock({ language: "bash" });
              break;
            case "content":
              n.deleteRange(this.range), this.editor.commands.insertContent(t2.options.content);
              break;
            case "taskList":
              n.deleteRange(this.range), this.editor.commands.toggleTaskList();
              break;
            default:
              this.onCommand(n, e, t2.value, t2.options);
              break;
          }
        },
        onKeyDown({ event: t2 }) {
          return t2.key === "ArrowUp" ? (this.upHandler(), true) : t2.key === "ArrowDown" ? (this.downHandler(), true) : t2.key === "Enter" ? (this.enterHandler(), true) : false;
        },
        upHandler() {
          this.selectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
        },
        downHandler() {
          this.selectedIndex = (this.selectedIndex + 1) % this.items.length;
        },
        enterHandler() {
          this.selectItem(this.selectedIndex);
        },
        selectItem(t2) {
          const e = this.items[t2];
          e && this.onClick(e);
        },
        setEmoji(t2) {
          this.onClick({ value: "content", options: { content: t2 } });
        }
      },
      computed: {
        basicBlocks() {
          return Vi.slice(1);
        }
      },
      mounted() {
        this.selectedIndex = 0;
      }
    }, _M = (t2, e) => {
      const n = t2.__vccOpts || t2;
      for (const [r, o] of e)
        n[r] = o;
      return n;
    }, SM = {
      key: 0,
      class: "view-main"
    }, CM = { class: "group o-tips" }, xM = { class: "o-tips" }, TM = {
      key: 1,
      class: "item"
    }, OM = {
      key: 1,
      class: "view-emoji"
    }, NM = {
      key: 2,
      class: "view-emoji"
    };
    function AM(t2, e, n, r, o, i) {
      const s = resolveComponent("o-divider"), a = resolveComponent("o-icon"), l = resolveComponent("o-list-item"), c2 = resolveComponent("o-list");
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(["o-slash-view o-shadow-3 o-menu o-scroll", `view-${o.view}`])
      }, [
        o.view === "main" ? (openBlock(), createElementBlock("section", SM, [
          createVNode(c2, {
            hoverable: "",
            clickable: ""
          }, {
            default: withCtx(() => [
              n.items.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(n.items, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                u.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  d > 0 ? (openBlock(), createBlock(s, { key: 0 })) : createCommentVNode("", true),
                  createBaseVNode("div", CM, toDisplayString(r.tr(u.group)), 1)
                ], 64)) : createCommentVNode("", true),
                createVNode(l, {
                  class: normalizeClass(["item", { "is-active": d === o.selectedIndex }]),
                  clickable: "",
                  onClick: (p2) => i.onClick(u)
                }, {
                  prefix: withCtx(() => [
                    createVNode(a, {
                      name: u.icon,
                      color: u.color
                    }, null, 8, ["name", "color"])
                  ]),
                  suffix: withCtx(() => [
                    createBaseVNode("span", xM, toDisplayString(u.tips), 1)
                  ]),
                  default: withCtx(() => [
                    createTextVNode(" " + toDisplayString(r.tr(u.label)), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])
              ], 64))), 128)) : (openBlock(), createElementBlock("div", TM, "No result"))
            ]),
            _: 1
          })
        ])) : o.view === "emoji" ? (openBlock(), createElementBlock("section", OM)) : o.view === "ai" ? (openBlock(), createElementBlock("section", NM)) : createCommentVNode("", true)
      ], 2);
    }
    const MM = /* @__PURE__ */ _M(wM, [["render", AM]]), rf = {
      items: ({ query: t2 }) => su.filter(
        (e) => e.value.toLowerCase().startsWith(t2.toLowerCase())
      ),
      render: () => {
        let t2, e;
        return {
          onStart: (n) => {
            t2 = new bm(MM, {
              props: n,
              editor: n.editor
            }), e = Zn("body", {
              getReferenceClientRect: n.clientRect,
              appendTo: () => document.body,
              content: t2.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false
            });
          },
          onUpdate(n) {
            t2.updateProps(n), e[0].setProps({
              getReferenceClientRect: n.clientRect
            });
          },
          onKeyDown(n) {
            var r;
            return n.event.key === "Escape" ? (e[0].hide(), t2.destroy(), true) : (r = t2.ref) == null ? void 0 : r.onKeyDown(n);
          },
          onExit() {
            e[0].destroy(), t2.destroy();
          }
        };
      }
    }, RM = {
      // default
      BackColor: $A.configure({
        multicolor: true
      }),
      Focus: FA,
      ForeColor: HA,
      FontFamily: zA,
      Image: VA,
      Link: Dg,
      TextAlign: GA.configure({
        types: ["heading", "paragraph"]
      }),
      // task
      TaskItem: KA,
      TaskList: qA.configure({
        itemTypeName: "taskItem"
      }),
      Underline: bM,
      Typography: gM,
      // Custom extensions
      OSlash: EM.configure({
        suggestion: rf
      }),
      OSlashZh: kM.configure({
        suggestion: rf
      }),
      // // custom
      // OTOC: TOC,
      // OModelViewer: ModelViewer,
      OBlockquote: BT,
      OCallout: VT,
      OCodeBlock: CN,
      OColorHighlighter: Nx,
      OHeading: TN,
      OHorizontalRule: AN,
      OImage: BN,
      OLink: aA.configure({
        openOnClick: false
      }),
      OParagraph: cA,
      OTrailingNode: LT,
      // OColumnExtension: ColumnExtension,
      // OColon: Colon.configure({
      //   suggestion: colonSuggestion
      // }),
      OUniqueID: xA.configure({
        attributeName: "data-id",
        enableRender: false,
        types: ["heading", "paragraph"]
      }),
      OVideo: MA
    };
    class IM {
      constructor(e) {
        return RM[e];
      }
    }
    const DM = [
      vA,
      IT.configure({
        resizable: true
      }),
      Bg,
      gA,
      pA
    ];
    jm.configure({
      resizable: true
    });
    const LM = ["data-theme"], PM = /* @__PURE__ */ defineComponent({
      __name: "YiiEditor",
      props: {
        content: {
          type: [String, Object],
          default: ""
        },
        editable: {
          type: Boolean,
          default: true
        },
        locale: {
          type: String,
          default: "en"
        },
        darkMode: {
          type: Boolean,
          default: false
        },
        showMainMenu: {
          type: Boolean,
          default: false
        },
        showBubbleMenu: {
          type: Boolean,
          default: false
        },
        showFloatingMenu: {
          type: Boolean,
          default: false
        },
        showSideMenu: {
          type: Boolean,
          default: false
        },
        showSideNode: {
          type: Boolean,
          default: false
        },
        showContent: {
          type: Boolean,
          default: true
        },
        showGuide: {
          type: Boolean,
          default: false
        },
        scrollable: {
          type: Boolean,
          default: false
        },
        editorProps: {
          type: Object,
          default: function() {
            return {};
          }
        },
        extensions: {
          type: Array,
          default: function() {
            return [];
          }
        },
        mainMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        bubbleMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        floatingMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        pageView: {
          type: String,
          default: "page"
        },
        options: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["transaction", "update"],
      setup(t2, { expose: e, emit: n }) {
        const r = t2, o = n, { tr: i } = Le(), s = ref(false), a = ref("en"), l = ref(false);
        provide("darkMode", s), provide("locale", a), provide("sideNode", l);
        const c2 = computed(() => m()), u = Vw({
          editable: r.editable,
          content: r.content,
          extensions: c2.value,
          onUpdate: () => {
            var E, _;
            const g = (E = u.value) == null ? void 0 : E.getJSON(), b = (_ = u.value) == null ? void 0 : _.getHTML();
            o("update", { json: g, html: b });
          },
          onTransaction: ({ editor: g, transaction: b }) => {
            o("transaction", { editor: g, transaction: b });
          }
        }), d = computed(() => ({
          editor: u.value,
          menu: r.mainMenu
        })), p2 = computed(() => ({
          editor: u.value,
          menu: r.bubbleMenu
        })), f = computed(() => ({
          editor: u.value,
          menu: r.floatingMenu
        })), h2 = computed(() => ({
          editor: u.value,
          menu: []
        }));
        function m() {
          const g = [];
          r.extensions.includes("OColumn") || g.push(
            Em.extend({
              content: "heading block*"
            })
          ), g.push(
            Ax.configure({
              placeholder: ({ editor: E, node: _, pos: v }) => {
                if (_.type.name === "heading") {
                  const T = _.attrs.level;
                  return v > 0 ? `H${T}` : i("label.untitled");
                } else return _.type.name === "paragraph" ? i("label.typeForCommands") : "";
              }
            })
          ), g.push(z_), g.push(
            $_.configure({
              document: false,
              blockquote: r.extensions.includes("OBlockquote") ? false : {},
              codeBlock: false,
              heading: r.extensions.includes("OHeading") ? false : {
                levels: [1, 2, 3, 4, 5]
              },
              paragraph: r.extensions.includes("OParagraph") ? false : {},
              dropcursor: {
                width: 5,
                color: "skyblue",
                class: "yiitap-dropcursor"
              },
              horizontalRule: false
            })
          );
          const b = RA.concat(r.extensions);
          for (const E of b)
            if (typeof E == "string") {
              if (!LA.includes(E))
                continue;
              switch (E) {
                case "Table":
                  g.push(...DM);
                  break;
                default:
                  try {
                    const _ = new IM(E);
                    g.push(_);
                  } catch (_) {
                    console.error(_.message);
                  }
                  break;
              }
            } else
              g.push(E);
          return g;
        }
        return watch(
          () => r.darkMode,
          (g) => {
            s.value = g;
          }
        ), watch(
          () => r.locale,
          (g) => {
            a.value = g;
          }
        ), watch(
          () => r.editable,
          (g) => {
            var b;
            (b = u.value) == null || b.setEditable(g);
          }
        ), onBeforeMount(() => {
          s.value = r.darkMode, a.value = r.locale, l.value = !r.showSideMenu && r.showSideNode;
        }), e({
          editor: u,
          darkModeAlt: s,
          localeAlt: a
        }), (g, b) => {
          var E, _, v;
          return openBlock(), createElementBlock("main", {
            class: "yiitap yiitap-editor",
            "data-theme": s.value ? "dark" : ""
          }, [
            t2.showMainMenu ? (openBlock(), createBlock(ux, mergeProps({ key: 0 }, d.value, { class: "desktop-only" }), {
              left: withCtx(() => [
                renderSlot(g.$slots, "toolbar-left")
              ]),
              right: withCtx(() => [
                renderSlot(g.$slots, "toolbar-right")
              ]),
              _: 3
            }, 16)) : createCommentVNode("", true),
            (E = unref(u)) != null && E.isEditable && t2.showBubbleMenu ? (openBlock(), createBlock(fx, normalizeProps(mergeProps({ key: 1 }, p2.value)), null, 16)) : createCommentVNode("", true),
            (_ = unref(u)) != null && _.isEditable && t2.showFloatingMenu ? (openBlock(), createBlock(gx, normalizeProps(mergeProps({ key: 2 }, f.value)), null, 16)) : createCommentVNode("", true),
            (v = unref(u)) != null && v.isEditable && t2.showSideMenu ? (openBlock(), createBlock(Ox, normalizeProps(mergeProps({ key: 3 }, h2.value)), null, 16)) : createCommentVNode("", true),
            createVNode(unref(Hw), {
              class: normalizeClass(["editor-content", t2.pageView]),
              editor: unref(u)
            }, null, 8, ["class", "editor"])
          ], 8, LM);
        };
      }
    });
    const BasicFeaturesArticle = `
<h1>Introduction</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em> </em></strong></span>is a WYSIWYG rich-text block-based editor built on top of <span style="font-family: &quot;Arial Black&quot;">tiptap</span>.🔥</p><h2>Callout</h2><div icon="🌾" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>Announcement</strong></p><p>Make writing stand out.</p></div><h2>Blockquote</h2><blockquote><p>A gentleman should constantly strike to become stronger just like the evolution of the universe.</p><p>A gentleman should generously cultivate to become tolerant just like the earth bears everything on it.</p></blockquote><h2>Table</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th4</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">Cell Background</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>Merged Cell</p></td></tr></tbody></table></table-wrapper><h2>Image</h2><blockquote><p>A picture is worth a thousand of words.</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="Title" size="large" ratio="5/1"></p><h2>Video</h2><video caption="Caption"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>Model View</h2><h2>List</h2><h3>Unordered List</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>Ordered List</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>Task</h3><ul data-type="taskList"><li data-checked="true" data-type="taskItem"><label><input type="checkbox" checked="checked"><span></span></label><div><p>Model Viewer</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Diagram</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Math Formula</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Draggable handler for all blocks</p></div></li></ul><h2>Code Block</h2><blockquote><p>Friendly to developer, with syntax highlight.</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Shortcut</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Remarks</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Heading</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Blockquote</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code Block</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>Typography</h2><h3>Heading 3</h3><h4>Heading 4</h4><h3>Paragraph</h3><p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p><p>Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p><p>Whether 60 or 16, there is in every human being’s heart the lure of wonder, the unfailing childlike appetite of what’s next and the joy of the game of living. In the center of your heart and my heart there is a wireless station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the Infinite, so long are you young.</p><p>When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at 20, but as long as your aerials are up, to catch waves of optimism, there is hope you may die young at 80.</p><h3>Smart</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Input</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Output</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>Copyright</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code></p></td><td colspan="1" rowspan="1" background=""><p>©</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Right</p></td><td colspan="1" rowspan="1" background=""><p><code>(r)</code></p></td><td colspan="1" rowspan="1" background=""><p>®</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>»</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>→</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Not equal</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p>≠</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Ratio</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code>&nbsp;&nbsp;<code>1/4</code>&nbsp;&nbsp;<code>3/4</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>½ ¼ ¾&nbsp;</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Dash</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p>—</p></td></tr></tbody></table></table-wrapper><h3>Color Highlighter</h3><p>#abc, #00ff00, Info color #2080f0</p><h2>Text</h2><p><span style="font-family: &quot;Arial Black&quot;"><strong>Bold text</strong></span></p><p><em>Italic text</em></p><p><u>Underline text</u></p><p><s>Strike through text</s></p><hr><p><code>Inline code</code></p><p><span style="color: rgb(255, 77, 79)">Text with color</span></p><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">Text with highlight background</mark></p><p></p>
`;
    const BasicFeaturesArticleZh = `
<h1>Yiitap</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em>&nbsp;</em></strong></span>是一个所见即所得的编辑器，基于<a target="_blank" rel="noopener noreferrer nofollow" href="https://tiptap.dev/"><span style="font-family: system-ui">Tiptap</span></a>🔥。</p><h2>高亮块</h2><div icon="🌾" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>通知</strong></p><p>着重强调的内容</p></div><h2>引用</h2><blockquote><p>天行健，君子以自强不息；<br>地势坤，君子以厚德载物。</p></blockquote><h2>表格</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th3</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">单元格背景</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>合并单元格</p></td></tr></tbody></table></table-wrapper><h2>图片</h2><blockquote><p>一图胜千言。</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="图片描述" size="large" ratio="5/1"></p><h2>视频</h2><video caption="视频描述"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>列表</h2><h3>无序列表</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>有序列表</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>任务</h3><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>表情</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>图表</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>数学公式</p></div></li></ul><h2>代码块</h2><blockquote><p>对开发人员友好，支持代码高亮。</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">名称</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">快捷</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">备注</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>标题</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>引用</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>行内代码</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>代码块</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>排版</h2><h3>标题 3</h3><h4>标题 4</h4><h3>段落</h3><p>青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的感情；青春是生命的深泉在涌流。</p><p>青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。</p><p>岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p><p>无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p><p>一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p><h3>快捷输入</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">名称</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">输入</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">输出</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>版权</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code>&nbsp; <code>(r)</code>&nbsp; <code>(tm)</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>© ® ™ </p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>箭头</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>»</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>箭头</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>→</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>不等号</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p>≠</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>分类</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code></p></td><td colspan="1" rowspan="1" background=""><p>½</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>长横线</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p>—</p></td></tr></tbody></table></table-wrapper><h2>文本</h2><ul><li><p><span style="font-family: &quot;Arial Black&quot;"><strong>加粗文本</strong></span></p></li><li><p><em>斜体文本</em></p></li><li><p><u>下划线</u></p></li><li><p><s>删除线</s></p></li><li><p><code>行内代码</code></p></li><li><p><span style="color: rgb(255, 77, 79)">文本颜色 </span></p></li><li><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">高亮颜色</mark></p></li></ul><p></p>
`;
    const _hoisted_1 = { class: "layout-toolbar" };
    const _hoisted_2 = { class: "actions" };
    const _hoisted_3 = { class: "toolbar" };
    const _hoisted_4 = { class: "layout-content" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "Demo",
      emits: ["mode"],
      setup(__props, { emit: __emit }) {
        const emit2 = __emit;
        const yiiEditor = ref();
        const locale = ref("en");
        const darkMode = ref(false);
        const editable = ref(true);
        const showDrawer = ref(false);
        provide("locale", locale);
        provide("darkMode", darkMode);
        const options = computed(() => {
          return {
            locale: locale.value,
            darkMode: darkMode.value,
            editable: editable.value,
            content: content.value,
            showMainMenu: false,
            showBubbleMenu: true,
            showFloatingMenu: true,
            showSideMenu: true,
            // showSideNode: true,
            pageView: "page",
            mainMenu: [
              "bold",
              "italic",
              "text-format-dropdown",
              "separator",
              "heading",
              "font-family",
              "text-color-dropdown",
              "fore-color",
              "back-color",
              "clearFormat",
              "separator",
              "align-dropdown",
              "separator",
              "horizontalRule",
              "blockquote",
              "list-dropdown",
              "codeBlock",
              "link",
              "image",
              "video",
              "table",
              "callout",
              "emoji"
            ],
            extensions: [
              "OBlockquote",
              "OCallout",
              "OCodeBlock",
              "OColorHighlighter",
              "OHeading",
              "OImage",
              "OParagraph",
              "OSlash",
              "OSlashZh",
              "OLink",
              "OTrailingNode",
              "OVideo"
            ]
          };
        });
        const content = computed(() => {
          return locale.value === "zh" ? BasicFeaturesArticleZh : BasicFeaturesArticle;
        });
        function onToggleDrawer() {
          showDrawer.value = !showDrawer.value;
        }
        function onGithub() {
          window.open("https://github.com/yiitap/yiitap", "_blank");
        }
        function onMode() {
          emit2("mode", darkMode.value);
        }
        function onUpdate({ json, html }) {
        }
        watch(locale, (newValue) => {
          var _a2;
          (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor.commands.setContent(content.value);
        });
        onMounted(() => {
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("section", {
            class: normalizeClass(["page-demo", { dark: darkMode.value }])
          }, [
            createBaseVNode("section", _hoisted_1, [
              createBaseVNode("header", null, [
                _cache[4] || (_cache[4] = createBaseVNode("section", { class: "info" }, [
                  createBaseVNode("img", {
                    src: _imports_0,
                    alt: "Logo"
                  }),
                  createBaseVNode("div", { class: "title" }, "Yiitap Editor")
                ], -1)),
                createBaseVNode("section", _hoisted_2, [
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onGithub
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ye), { name: "github" })
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onToggleDrawer
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ye), { name: "menu" })
                    ]),
                    _: 1
                  })
                ])
              ]),
              createBaseVNode("div", _hoisted_3, [
                createVNode(unref(ux), {
                  editor: (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor,
                  menu: options.value.mainMenu,
                  "data-theme": darkMode.value ? "dark" : ""
                }, null, 8, ["editor", "menu", "data-theme"])
              ])
            ]),
            createBaseVNode("section", _hoisted_4, [
              createVNode(unref(PM), mergeProps({
                ref_key: "yiiEditor",
                ref: yiiEditor
              }, options.value, { onUpdate }), null, 16)
            ]),
            createVNode(unref(NDrawer), {
              show: showDrawer.value,
              "onUpdate:show": _cache[3] || (_cache[3] = ($event) => showDrawer.value = $event),
              "default-width": 400,
              placement: "right",
              resizable: ""
            }, {
              default: withCtx(() => [
                createVNode(unref(NDrawerContent), {
                  title: "Yii Editor",
                  closable: ""
                }, {
                  default: withCtx(() => [
                    createVNode(unref(NForm), {
                      ref: "form",
                      "label-placement": "left",
                      "label-width": "auto"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), { label: "Language" }, {
                          default: withCtx(() => [
                            createVNode(unref(NRadioGroup), {
                              value: locale.value,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => locale.value = $event),
                              name: "radiogroup1"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NSpace), null, {
                                  default: withCtx(() => [
                                    createVNode(unref(NRadio), { value: "en" }, {
                                      default: withCtx(() => _cache[5] || (_cache[5] = [
                                        createTextVNode(" English ")
                                      ])),
                                      _: 1
                                    }),
                                    createVNode(unref(NRadio), { value: "zh" }, {
                                      default: withCtx(() => _cache[6] || (_cache[6] = [
                                        createTextVNode(" 中文 ")
                                      ])),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Mode" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: darkMode.value,
                              "onUpdate:value": [
                                _cache[1] || (_cache[1] = ($event) => darkMode.value = $event),
                                onMode
                              ]
                            }, {
                              checked: withCtx(() => _cache[7] || (_cache[7] = [
                                createTextVNode(" Dark ")
                              ])),
                              unchecked: withCtx(() => _cache[8] || (_cache[8] = [
                                createTextVNode(" Light ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Edit" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: editable.value,
                              "onUpdate:value": _cache[2] || (_cache[2] = ($event) => editable.value = $event)
                            }, {
                              checked: withCtx(() => _cache[9] || (_cache[9] = [
                                createTextVNode(" Editable ")
                              ])),
                              unchecked: withCtx(() => _cache[10] || (_cache[10] = [
                                createTextVNode(" Readonly ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["show"])
          ], 2);
        };
      }
    });
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const darkMode = ref(false);
        const theme = computed(() => {
          return darkMode.value ? darkTheme : null;
        });
        function onMode(value) {
          darkMode.value = value;
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(NConfigProvider), { theme: theme.value }, {
            default: withCtx(() => [
              createVNode(_sfc_main$1, { onMode })
            ]),
            _: 1
          }, 8, ["theme"]);
        };
      }
    });
    const app = createApp(_sfc_main);
    app.mount("#app");
  }
});
export default require_index_001();
