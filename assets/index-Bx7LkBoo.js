var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-Bx7LkBoo.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map[key] = 1;
      return (val) => val in map;
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO$1 = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$9 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$9.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props) return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length) return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b) return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a2;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].pause();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].resume();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].resume();
            }
          }
        }
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          this.effects.length = 0;
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeSub;
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn) {
        this.fn = fn;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= -65;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= -3;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= -2;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed = false) {
      sub.flags |= 8;
      if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head;
      let tail = sub.depsTail;
      let link = tail;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail) tail = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head;
      sub.depsTail = tail;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= -17;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= -3;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= -3;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= -5;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (false) ;
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      ""
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      ""
    );
    const ARRAY_ITERATE_KEY = Symbol(
      ""
    );
    function track(target, type, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        {
          dep.track();
        }
      }
    }
    function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run = (dep) => {
        if (dep) {
          {
            dep.trigger();
          }
        }
      };
      startBatch();
      if (type === "clear") {
        depsMap.forEach(run);
      } else {
        const targetIsArray = isArray$1(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
              run(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run(depsMap.get(key));
          }
          if (isArrayIndex) {
            run(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type) {
            case "add":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap(target)) {
                run(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function getDepFromReactive(object, key) {
      const depMap = targetMap.get(object);
      return depMap && depMap.get(key);
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn, thisArg) {
        return apply$1(this, "every", fn, thisArg, void 0, arguments);
      },
      filter(fn, thisArg) {
        return apply$1(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn, thisArg) {
        return apply$1(this, "find", fn, thisArg, toReactive, arguments);
      },
      findIndex(fn, thisArg) {
        return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
      },
      findLast(fn, thisArg) {
        return apply$1(this, "findLast", fn, thisArg, toReactive, arguments);
      },
      findLastIndex(fn, thisArg) {
        return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn, thisArg) {
        return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn, thisArg) {
        return apply$1(this, "map", fn, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn, ...args) {
        return reduce(this, "reduce", fn, args);
      },
      reduceRight(fn, ...args) {
        return reduce(this, "reduceRight", fn, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn, thisArg) {
        return apply$1(this, "some", fn, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto$1 = Array.prototype;
    function apply$1(self2, method, fn, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto$1[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn.call(this, toReactive(item), index, self2);
          };
        } else if (fn.length > 2) {
          wrappedFn = function(item, index) {
            return fn.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    function hasOwnProperty$8(key) {
      if (!isSymbol$1(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          let fn;
          if (targetIsArray && (fn = arrayInstrumentations[key])) {
            return fn;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$8;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger$1(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger$1(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            const oldValue = get2.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger$1(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger$1(target, "set", key, value);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            get2 ? get2.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger$1(target, "delete", key, void 0);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const result = target.clear();
            if (hadItems) {
              trigger$1(
                target,
                "clear",
                void 0,
                void 0
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, isShallow2) {
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
      }
      get value() {
        {
          this.dep.track();
        }
        return this._value;
      }
      set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          {
            this.dep.trigger();
          }
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this["__v_isRef"] = true;
        this._value = void 0;
        const dep = this.dep = new Dep();
        const { get: get2, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
        this._get = get2;
        this._set = set;
      }
      get value() {
        return this._value = this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
      }
      get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
      }
      get value() {
        return this._value = this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(fn, setter, isSSR) {
        this.fn = fn;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        }
      }
      get value() {
        const link = this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction$1(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      return cRef;
    }
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      }
    }
    function watch$1(source, cb2, options = EMPTY_OBJ) {
      const { immediate, deep, once, scheduler: scheduler2, augmentJob, call: call2 } = options;
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return call2 ? call2(s, 2) : s();
          } else ;
        });
      } else if (isFunction$1(source)) {
        if (cb2) {
          getter = call2 ? () => call2(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb2 && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope && scope.active) {
          remove(scope.effects, effect2);
        }
      };
      if (once && cb2) {
        const _cb = cb2;
        cb2 = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb2) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call2 ? call2(cb2, 3, args) : (
                // @ts-expect-error
                cb2(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler2 ? () => scheduler2(job, false) : job;
      boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call2) {
            call2(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      if (cb2) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler2) {
        scheduler2(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack$1 = [];
    let isWarning = false;
    function warn$1$1(msg2, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg2 + args.map((a) => {
              var _a2, _b2;
              return (_b2 = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b2 : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack$1[stack$1.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction$1(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$1(fn)) {
        const values = [];
        for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
      if (throwInProd) {
        throw err;
      } else {
        console.error(err);
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb2) {
      if (!isArray$1(cb2)) {
        if (activePostFlushCbs && cb2.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb2);
        } else if (!(cb2.flags & 1)) {
          pendingPostFlushCbs.push(cb2);
          cb2.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb2);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
      for (; i < queue.length; i++) {
        const cb2 = queue[i];
        if (cb2 && cb2.flags & 2) {
          if (instance && cb2.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          if (cb2.flags & 4) {
            cb2.flags &= -2;
          }
          cb2();
          if (!(cb2.flags & 4)) {
            cb2.flags &= -2;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb2 = activePostFlushCbs[postFlushIndex];
          if (cb2.flags & 4) {
            cb2.flags &= -2;
          }
          if (!(cb2.flags & 8)) cb2();
          cb2.flags &= -2;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (false) ;
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= -2;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs();
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn, ctx2 = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx2) return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx2);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n12 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const mount2 = (container2, anchor2) => {
            if (shapeFlag & 16) {
              if (parentComponent && parentComponent.isCE) {
                parentComponent.ce._teleportTarget = container2;
              }
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountToTarget = () => {
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = prepareAnchor(target, n2, createText, insert);
            if (target) {
              if (namespace2 !== "svg" && isTargetSVG(target)) {
                namespace2 = "svg";
              } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
                namespace2 = "mathml";
              }
              if (!disabled) {
                mount2(target, targetAnchor);
                updateCssVars(n2, false);
              }
            }
          };
          if (disabled) {
            mount2(container, mainAnchor);
            updateCssVars(n2, true);
          }
          if (isTeleportDeferred(n2.props)) {
            queuePostRenderEffect(() => {
              mountToTarget();
              n2.el.__isMounted = true;
            }, parentSuspense);
          } else {
            mountToTarget();
          }
        } else {
          if (isTeleportDeferred(n2.props) && !n12.el.__isMounted) {
            queuePostRenderEffect(() => {
              TeleportImpl.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
              delete n12.el.__isMounted;
            }, parentSuspense);
            return;
          }
          n2.el = n12.el;
          n2.targetStart = n12.targetStart;
          const mainAnchor = n2.anchor = n12.anchor;
          const target = n2.target = n12.target;
          const targetAnchor = n2.targetAnchor = n12.targetAnchor;
          const wasDisabled = isTeleportDisabled(n12.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace2 === "svg" || isTargetSVG(target)) {
            namespace2 = "svg";
          } else if (namespace2 === "mathml" || isTargetMathML(target)) {
            namespace2 = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            traverseStaticChildren(n12, n2, true);
          } else if (!optimized) {
            patchChildren(
              n12,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n12.props && n2.props.to !== n12.props.to) {
                n2.props.to = n12.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
          updateCssVars(n2, disabled);
        }
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount2(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (disabled) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode, disabled);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode, isDisabled) {
      const ctx2 = vnode.ctx;
      if (ctx2 && ctx2.ut) {
        let node, anchor;
        if (isDisabled) {
          node = vnode.el;
          anchor = vnode.anchor;
        } else {
          node = vnode.targetStart;
          anchor = vnode.targetAnchor;
        }
        while (node && node !== anchor) {
          if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx2.uid);
          node = node.nextSibling;
        }
        ctx2.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const child = findNonCommentChild(children);
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getInnerChild$1(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          if (innerChild.type !== Comment) {
            setTransitionHooks(innerChild, enterHooks);
          }
          let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            let leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (!(instance.job.flags & 8)) {
                  instance.update();
                }
                delete leavingHooks.afterLeave;
                oldInnerChild = void 0;
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
                enterHooks.delayedLeave = () => {
                  delayedLeave();
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
              };
            } else {
              oldInnerChild = void 0;
            }
          } else if (oldInnerChild) {
            oldInnerChild = void 0;
          }
          return child;
        };
      }
    };
    function findNonCommentChild(children) {
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      return child;
    }
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1)) done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called) return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called) return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone) postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getInnerChild$1(vnode) {
      if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) {
          return findNonCommentChild(vnode.children);
        }
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$1(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128) keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8236: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    getGlobalThis().requestIdleCallback || ((cb2) => setTimeout(cb2, 1));
    getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderList(source, renderItem, cache2, index) {
      let ret;
      const cached = cache2;
      const sourceIsArray = isArray$1(source);
      if (sourceIsArray || isString(source)) {
        const sourceIsReactiveArray = sourceIsArray && isReactive(source);
        let needsWrap = false;
        if (sourceIsReactiveArray) {
          needsWrap = !isShallow(source);
          source = shallowReadArray(source);
        }
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(
            needsWrap ? toReactive(source[i]) : source[i],
            i,
            void 0,
            cached
          );
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached)
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            ret[i] = renderItem(source[key], key, i, cached);
          }
        }
      } else {
        ret = [];
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(
          Fragment,
          null,
          [createVNode("slot", props, fallback)],
          64
        );
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key;
      const rendered = createBlock(
        Fragment,
        {
          key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
          ""
        },
        validSlotContent || [],
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $host: (i) => i.ce,
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx: ctx2, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx2[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
            accessCache[key] = 4;
            return ctx2[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx: ctx2 } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx2[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx2 = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx2[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data)) ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set
          });
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx2, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx2[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx2, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx2[raw];
        if (isFunction$1(handler)) {
          {
            watch(getter, handler);
          }
        }
      } else if (isFunction$1(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$1(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from[key]) : from[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from) {
      if (!from) {
        return to2;
      }
      if (!to2) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to2) ? to2.call(this, this) : to2,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to2, from) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from) {
      return to2 ? [...new Set([].concat(to2, from))] : from;
    }
    function mergeObjectOptions(to2, from) {
      return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
    }
    function mergeEmitsOrPropsOptions(to2, from) {
      if (to2) {
        if (isArray$1(to2) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to2, from) {
      if (!to2) return from;
      if (!from) return to2;
      const merged = extend(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from) {
        merged[key] = mergeAsArray(to2[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO$1,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted2 = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin2, ...options) {
            if (installedPlugins.has(plugin2)) ;
            else if (plugin2 && isFunction$1(plugin2.install)) {
              installedPlugins.add(plugin2);
              plugin2.install(app2, ...options);
            } else if (isFunction$1(plugin2)) {
              installedPlugins.add(plugin2);
              plugin2(app2, ...options);
            } else ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace2) {
            if (!isMounted2) {
              const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace2 === true) {
                namespace2 = "svg";
              } else if (namespace2 === false) {
                namespace2 = void 0;
              }
              {
                render2(vnode, rootContainer, namespace2);
              }
              isMounted2 = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getComponentPublicInstance(vnode.component);
            }
          },
          onUnmount(cleanupFn) {
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted2) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app2._instance,
                16
              );
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
      }
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$1(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type = propType[index];
                const typeName = isFunction$1(type) && type.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$1(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx2) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false) ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx2);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx2 = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx2);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n12 === n2) {
          return;
        }
        if (n12 && !isSameVNodeType(n12, n2)) {
          anchor = getNextHostNode(n12);
          unmount2(n12, parentComponent, parentSuspense, true);
          n12 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n12, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n12, n2, container, anchor);
            break;
          case Static:
            if (n12 == null) {
              mountStaticNode(n2, container, anchor, namespace2);
            }
            break;
          case Fragment:
            processFragment(
              n12,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
        }
      };
      const processText = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n12.el;
          if (n2.children !== n12.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n12.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace2 = "svg";
        } else if (n2.type === "math") {
          namespace2 = "mathml";
        }
        if (n12 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n12,
            n2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace2),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], namespace2, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace2);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n12, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const el = n2.el = n12.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n12.patchFlag & 16;
        const oldProps = n12.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n12.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n12,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, oldProps, newProps, parentComponent, namespace2);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, namespace2, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n12.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, oldProps, newProps, parentComponent, namespace2);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
            dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, oldProps, newProps, parentComponent, namespace2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace2,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, namespace2, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
          }
        }
      };
      const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n12 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n12.dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n12,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n12,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n12 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              optimized
            );
          }
        } else {
          updateComponent(n12, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      };
      const updateComponent = (n12, n2, optimized) => {
        const instance = n2.component = n12.component;
        if (shouldUpdateComponent(n12, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n12.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm: bm2, m, parent, root: root2, type } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm2) {
              invokeArrayFns(bm2);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            {
              if (root2.ce) {
                root2.ce._injectChildStyle(type);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace2
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu: bu2, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu2) {
              invokeArrayFns(bu2);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
        const c12 = n12 && n12.children;
        const prevShapeFlag = n12 ? n12.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c12, parentComponent, parentSuspense);
          }
          if (c2 !== c12) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c12,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c12, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c12, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        c12 = c12 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c12.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c12[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c12,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c12, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e12 = c12.length - 1;
        let e2 = l2 - 1;
        while (i <= e12 && i <= e2) {
          const n12 = c12[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e12 && i <= e2) {
          const n12 = c12[e12];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e12--;
          e2--;
        }
        if (i > e12) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e12) {
            unmount2(c12[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s12 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
          for (i = s12; i <= e12; i++) {
            const prevChild = c12[i];
            if (patched >= toBePatched) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, job, subTree, um: um2, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (job) {
          job.flags |= 8;
          unmount2(subTree, instance, parentSuspense, doRemove);
        }
        if (um2) {
          queuePostRenderEffect(um2, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount2(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
      };
      let isFlushing = false;
      const render2 = (vnode, container, namespace2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount2(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace2
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount2,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= -33;
        job.flags &= -5;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n12, n2, shallow = false) {
      const ch1 = n12.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c12 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c12.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c12, c2);
          }
          if (c2.type === Text) {
            c2.el = c12.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c2;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c2 = u + v >> 1;
            if (arr[result[c2]] < arrI) {
              u = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].flags |= 8;
      }
    }
    const ssrContextKey$1 = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx2 = inject(ssrContextKey$1);
        return ctx2;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watch(source, cb2, options) {
      return doWatch(source, cb2, options);
    }
    function doWatch(source, cb2, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once } = options;
      const baseWatchOptions = extend({}, options);
      const runsImmediately = cb2 && immediate || !cb2 && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx2 = useSSRContext();
          ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb2) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb2, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb2;
      if (isFunction$1(value)) {
        cb2 = value;
      } else {
        cb2 = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb2.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx2, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx2;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx: ctx2,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx2
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false) ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        setTransitionHooks(root2, vnode.transition);
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n12, n2) {
      return n12.type === n2.type && n12.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style2)) {
          if (isProxy(style2) && !isArray$1(style2)) {
            style2 = extend({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup: setup2 } = Component;
      if (setup2) {
        pauseTracking();
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        const isAsyncSetup = isPromise(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult);
        }
      } else {
        finishComponentSetup(instance);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else ;
      finishComponentSetup(instance);
    }
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c2;
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.5.13";
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt = typeof window !== "undefined" && window.trustedTypes;
    if (tt) {
      try {
        policy = /* @__PURE__ */ tt.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace2, is2, props) => {
        const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace2, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace2 === "svg" || namespace2 === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const decorate$1 = (t) => {
      t.displayName = "Transition";
      t.props = TransitionPropsValidators;
      return t;
    };
    const Transition = /* @__PURE__ */ decorate$1(
      (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration: duration2,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration2);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done, isCancelled) => {
        el._enterCancelled = isCancelled;
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          if (!el._enterCancelled) {
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
          } else {
            addTransitionClass(el, leaveActiveClass);
            forceReflow();
          }
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false, void 0, true);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true, void 0, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration2) {
      if (duration2 == null) {
        return null;
      } else if (isObject$1(duration2)) {
        return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
      } else {
        const n = NumberOf(duration2);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb2) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb2);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout != null) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto") return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG2) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG2) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style2 = el.style;
      const isCssString = isString(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style2, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style2[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style2.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
        if (el[vShowHidden]) {
          style2.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null) val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG2, instance, isBoolean = isSpecialBooleanAttr(key)) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(
            key,
            isBoolean ? "" : isSymbol$1(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(attrName || key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace2, parentComponent) => {
      const isSVG2 = namespace2 === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el, key, nextValue, isSVG2, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
      ) {
        patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString(value)) {
        return false;
      }
      return key in el;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const decorate = (t) => {
      delete t.props.mode;
      return t;
    };
    const TransitionGroupImpl = /* @__PURE__ */ decorate({
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style2 = el.style;
            addTransitionClass(el, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb2 = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb2);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb2);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    });
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx2 = oldPos.left - newPos.left;
      const dy2 = oldPos.top - newPos.top;
      if (dx2 || dy2) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx2}px,${dy2}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing) return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$2(el);
          const checked = el.checked;
          const assign = el[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      let checked;
      if (isArray$1(value)) {
        checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        checked = value.has(vnode.props.value);
      } else {
        if (value === oldValue) return;
        checked = looseEqual(value, getCheckboxValue(el, true));
      }
      if (el.checked !== checked) {
        el.checked = checked;
      }
    }
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache2 = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render$1 = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount: mount2 } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount2(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    function plugin$1(options) {
      let _bPrefix = ".";
      let _ePrefix = "__";
      let _mPrefix = "--";
      let c2;
      if (options) {
        let t = options.blockPrefix;
        if (t) {
          _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
          _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
          _mPrefix = t;
        }
      }
      const _plugin = {
        install(instance) {
          c2 = instance.c;
          const ctx2 = instance.context;
          ctx2.bem = {};
          ctx2.bem.b = null;
          ctx2.bem.els = null;
        }
      };
      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx2) {
            memorizedB = ctx2.bem.b;
            memorizedE = ctx2.bem.els;
            ctx2.bem.els = null;
          },
          after(ctx2) {
            ctx2.bem.b = memorizedB;
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }
        };
      }
      function e(arg) {
        let memorizedE;
        return {
          before(ctx2) {
            memorizedE = ctx2.bem.els;
          },
          after(ctx2) {
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.els = arg.split(",").map((v) => v.trim());
            return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
          }
        };
      }
      function m(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const modifiers = arg.split(",").map((v) => v.trim());
            function elementToSelector(el) {
              return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
            }
            const els = context.bem.els;
            if (els !== null) {
              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }
        };
      }
      function notM(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const els = context.bem.els;
            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
          }
        };
      }
      const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
      const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
      const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
      const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
      Object.assign(_plugin, {
        cB: cB2,
        cE: cE2,
        cM: cM2,
        cNotM: cNotM2
      });
      return _plugin;
    }
    function ampCount(selector) {
      let cnt = 0;
      for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === "&")
          ++cnt;
      }
      return cnt;
    }
    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        let round = ampCount(partialSelector);
        if (!round) {
          amp.forEach((partialAmp) => {
            nextAmp.push(
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              (partialAmp && partialAmp + " ") + partialSelector
            );
          });
          return;
        } else if (round === 1) {
          amp.forEach((partialAmp) => {
            nextAmp.push(partialSelector.replace("&", partialAmp));
          });
          return;
        }
        let partialNextAmp = [
          partialSelector
        ];
        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach((selectorItr) => {
            amp.forEach((partialAmp) => {
              nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach((part) => nextAmp.push(part));
      });
      return nextAmp;
    }
    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        amp.forEach((partialAmp) => {
          nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
        });
      });
      return nextAmp;
    }
    function parseSelectorPath(selectorPaths) {
      let amp = [""];
      selectorPaths.forEach((selector) => {
        selector = selector && selector.trim();
        if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector
        ) {
          return;
        }
        if (selector.includes("&")) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(", ").replace(extraSpaceRegex, " ");
    }
    function removeElement(el) {
      if (!el)
        return;
      const parentElement = el.parentElement;
      if (parentElement)
        parentElement.removeChild(el);
    }
    function queryElement(id2, parent) {
      return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id2}"]`);
    }
    function createElement(id2) {
      const el = document.createElement("style");
      el.setAttribute("cssr-id", id2);
      return el;
    }
    function isMediaOrSupports(selector) {
      if (!selector)
        return false;
      return /^\s*@(s|m)/.test(selector);
    }
    const kebabRegex = /[A-Z]/g;
    function kebabCase(pattern) {
      return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
    }
    function unwrapProperty(prop, indent = "  ") {
      if (typeof prop === "object" && prop !== null) {
        return " {\n" + Object.entries(prop).map((v) => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join("\n") + "\n" + indent + "}";
      }
      return `: ${prop};`;
    }
    function unwrapProperties(props, instance, params) {
      if (typeof props === "function") {
        return props({
          context: instance.context,
          props: params
        });
      }
      return props;
    }
    function createStyle(selector, props, instance, params) {
      if (!props)
        return "";
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
        return "";
      if (typeof unwrappedProps === "string") {
        return `${selector} {
${unwrappedProps}
}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
          return selector + " {\n}";
        return "";
      }
      const statements = selector ? [
        selector + " {"
      ] : [];
      propertyNames.forEach((propertyName) => {
        const property = unwrappedProps[propertyName];
        if (propertyName === "raw") {
          statements.push("\n" + property + "\n");
          return;
        }
        propertyName = kebabCase(propertyName);
        if (property !== null && property !== void 0) {
          statements.push(`  ${propertyName}${unwrapProperty(property)}`);
        }
      });
      if (selector) {
        statements.push("}");
      }
      return statements.join("\n");
    }
    function loopCNodeListWithCallback(children, options, callback) {
      if (!children)
        return;
      children.forEach((child) => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === "function") {
          const grandChildren = child(options);
          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }
    function traverseCNode(node, selectorPaths, styles, instance, params) {
      const $2 = node.$;
      let blockSelector = "";
      if (!$2 || typeof $2 === "string") {
        if (isMediaOrSupports($2)) {
          blockSelector = $2;
        } else {
          selectorPaths.push($2);
        }
      } else if (typeof $2 === "function") {
        const selector2 = $2({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      } else {
        if ($2.before)
          $2.before(instance.context);
        if (!$2.$ || typeof $2.$ === "string") {
          if (isMediaOrSupports($2.$)) {
            blockSelector = $2.$;
          } else {
            selectorPaths.push($2.$);
          }
        } else if ($2.$) {
          const selector2 = $2.$({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style2 = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
        styles.push(`${blockSelector} {`);
      } else if (style2.length) {
        styles.push(style2);
      }
      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, (childNode) => {
          if (typeof childNode === "string") {
            const style3 = createStyle(selector, { raw: childNode }, instance, params);
            styles.push(style3);
          } else {
            traverseCNode(childNode, selectorPaths, styles, instance, params);
          }
        });
      }
      selectorPaths.pop();
      if (blockSelector) {
        styles.push("}");
      }
      if ($2 && $2.after)
        $2.after(instance.context);
    }
    function render(node, instance, props) {
      const styles = [];
      traverseCNode(node, [], styles, instance, props);
      return styles.join("\n\n");
    }
    function murmur2(str) {
      var h2 = 0;
      var k, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= /* k >>> r: */
        k >>> 24;
        h2 = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
    function unmount(instance, node, id2, parent) {
      const { els } = node;
      if (id2 === void 0) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id2, parent);
        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter((el) => el !== target);
        }
      }
    }
    function addElementToList(els, target) {
      els.push(target);
    }
    function mount(instance, node, id2, props, head, force, anchorMetaName, parent, ssrAdapter2) {
      let style2;
      if (id2 === void 0) {
        style2 = node.render(props);
        id2 = murmur2(style2);
      }
      if (ssrAdapter2) {
        ssrAdapter2.adapter(id2, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
        return;
      }
      if (parent === void 0) {
        parent = document.head;
      }
      const queriedTarget = queryElement(id2, parent);
      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id2);
      if (style2 === void 0)
        style2 = node.render(props);
      target.textContent = style2;
      if (queriedTarget !== null)
        return queriedTarget;
      if (anchorMetaName) {
        const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
        if (anchorMetaEl) {
          parent.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }
      if (head) {
        parent.insertBefore(target, parent.querySelector("style, link"));
      } else {
        parent.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
    }
    function wrappedRender(props) {
      return render(this, this.instance, props);
    }
    function wrappedMount(options = {}) {
      const { id: id2, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
      const targetElement = mount(this.instance, this, id2, props, head, force, anchorMetaName, parent, ssr);
      return targetElement;
    }
    function wrappedUnmount(options = {}) {
      const { id: id2, parent } = options;
      unmount(this.instance, this, id2, parent);
    }
    const createCNode = function(instance, $2, props, children) {
      return {
        instance,
        $: $2,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    const c$1 = function(instance, $2, props, children) {
      if (Array.isArray($2)) {
        return createCNode(instance, { $: null }, null, $2);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $2, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $2, props, children);
      } else {
        return createCNode(instance, $2, props, null);
      }
    };
    function CssRender(config = {}) {
      const cssr2 = {
        c: (...args) => c$1(cssr2, ...args),
        use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
        find: queryElement,
        context: {},
        config
      };
      return cssr2;
    }
    function exists(id2, ssr) {
      if (id2 === void 0)
        return false;
      if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id2);
      }
      return queryElement(id2) !== null;
    }
    const namespace = "n";
    const prefix$1 = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix$1,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const {
      c,
      find
    } = cssr;
    const {
      cB,
      cE: cE$1,
      cM: cM$1,
      cNotM
    } = plugin;
    function createKey(prefix2, suffix2) {
      return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
    }
    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }
    function depx(value) {
      if (typeof value === "string") {
        if (value.endsWith("px")) {
          return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
      }
      return value;
    }
    function pxfy(value) {
      if (value === void 0 || value === null)
        return void 0;
      if (typeof value === "number")
        return `${value}px`;
      if (value.endsWith("px"))
        return value;
      return `${value}px`;
    }
    function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
        top: parts[0]
      };
      switch (parts.length) {
        case 1:
          margin.right = parts[0];
          margin.bottom = parts[0];
          margin.left = parts[0];
          break;
        case 2:
          margin.right = parts[1];
          margin.left = parts[1];
          margin.bottom = parts[0];
          break;
        case 3:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[1];
          break;
        case 4:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[3];
          break;
        default:
          throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
      }
      return margin;
    }
    function getGap(value, orient) {
      const [rowGap, colGap] = value.split(" ");
      return {
        row: rowGap,
        col: colGap || rowGap
      };
    }
    const colors = {
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#0FF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000",
      blanchedalmond: "#FFEBCD",
      blue: "#00F",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#0FF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgrey: "#A9A9A9",
      darkgreen: "#006400",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#F0F",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgrey: "#D3D3D3",
      lightgreen: "#90EE90",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#0F0",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#F0F",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#F00",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FF0",
      yellowgreen: "#9ACD32",
      transparent: "#0000"
    };
    function hsv2rgb(h2, s, v) {
      s /= 100;
      v /= 100;
      let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5) * 255, f(3) * 255, f(1) * 255];
    }
    function hsl2rgb(h2, s, l) {
      s /= 100;
      l /= 100;
      let a = s * Math.min(l, 1 - l);
      let f = (n, k = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0) * 255, f(8) * 255, f(4) * 255];
    }
    const prefix = "^\\s*";
    const suffix = "\\s*$";
    const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
    const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    const hex = "([0-9A-Fa-f])";
    const dhex = "([0-9A-Fa-f]{2})";
    const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
    function parseHex(value) {
      return parseInt(value, 16);
    }
    function hsla(color) {
      try {
        let i;
        if (i = hslaRegex.exec(color)) {
          return [
            roundDeg(i[1]),
            roundPercent(i[5]),
            roundPercent(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = hslRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function hsva(color) {
      try {
        let i;
        if (i = hsvaRegex.exec(color)) {
          return [
            roundDeg(i[1]),
            roundPercent(i[5]),
            roundPercent(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = hsvRegex.exec(color)) {
          return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
        }
        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function rgba(color) {
      try {
        let i;
        if (i = hexRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        } else if (i = rgbRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        } else if (i = rgbaRegex.exec(color)) {
          return [
            roundChannel(i[1]),
            roundChannel(i[5]),
            roundChannel(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = sHexRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            1
          ];
        } else if (i = hexaRegex.exec(color)) {
          return [
            parseHex(i[1]),
            parseHex(i[2]),
            parseHex(i[3]),
            roundAlpha(parseHex(i[4]) / 255)
          ];
        } else if (i = sHexaRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            roundAlpha(parseHex(i[4] + i[4]) / 255)
          ];
        } else if (color in colors) {
          return rgba(colors[color]);
        } else if (hslRegex.test(color) || hslaRegex.test(color)) {
          const [h2, s, l, a] = hsla(color);
          return [...hsl2rgb(h2, s, l), a];
        } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
          const [h2, s, v, a] = hsva(color);
          return [...hsv2rgb(h2, s, v), a];
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function normalizeAlpha(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }
    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
    }
    function compositeChannel(v12, a12, v2, a2, a) {
      return roundChannel((v12 * a12 * (1 - a2) + v2 * a2) / a);
    }
    function composite(background, overlay2) {
      if (!Array.isArray(background))
        background = rgba(background);
      if (!Array.isArray(overlay2))
        overlay2 = rgba(overlay2);
      const a12 = background[3];
      const a2 = overlay2[3];
      const alpha = roundAlpha(a12 + a2 - a12 * a2);
      return stringifyRgba(compositeChannel(background[0], a12, overlay2[0], a2, alpha), compositeChannel(background[1], a12, overlay2[1], a2, alpha), compositeChannel(background[2], a12, overlay2[2], a2, alpha), alpha);
    }
    function changeColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      if (typeof options.alpha === "number") {
        return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
        return 1;
      if (v < 0)
        return 0;
      return v;
    }
    function roundDeg(value) {
      const v = Math.round(Number(value));
      if (v >= 360)
        return 0;
      if (v < 0)
        return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
        return 255;
      if (v < 0)
        return 0;
      return v;
    }
    function roundPercent(value) {
      const v = Math.round(Number(value));
      if (v > 100)
        return 100;
      if (v < 0)
        return 0;
      return v;
    }
    function toRgbaString(base2) {
      const [r, g, b] = base2;
      if (3 in base2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function createId(length = 8) {
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }
    const traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
    function createTrapHandler(name, el, originalHandler) {
      if (name === "mousemoveoutside") {
        const moveHandler = (e) => {
          if (el.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === "clickoutside") {
        let mouseDownOutside = false;
        const downHandler = (e) => {
          mouseDownOutside = !el.contains(getEventTarget(e));
        };
        const upHanlder = (e) => {
          if (!mouseDownOutside)
            return;
          if (el.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }
      console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
      );
      return {};
    }
    function ensureTrapHandlers(name, el, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el);
      if (elHandlers === void 0) {
        handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === void 0) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
      }
      return trapHandler;
    }
    function trapOn(name, el, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach((key) => {
          on$1(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function trapOff(name, el, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el, handler);
        Object.keys(trapHandlers).forEach((key) => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function createDelegate() {
      if (typeof window === "undefined") {
        return {
          on: () => {
          },
          off: () => {
          }
        };
      }
      const propagationStopped = /* @__PURE__ */ new WeakMap();
      const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
      function trackPropagation() {
        propagationStopped.set(this, true);
      }
      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn) {
        const source = event[propName];
        event[propName] = function() {
          fn.apply(event, arguments);
          return source.apply(event, arguments);
        };
        return event;
      }
      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }
      const currentTargets = /* @__PURE__ */ new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
      function getCurrentTarget() {
        var _a2;
        return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === void 0)
          return;
        Object.defineProperty(event, "currentTarget", {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }
      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
        const delegeteHandler = function(e) {
          const { type, eventPhase, bubbles } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2)
            return;
          const phase = eventPhase === 1 ? "capture" : "bubble";
          let cursor = target;
          const path = [];
          while (true) {
            if (cursor === null)
              cursor = window;
            path.push(cursor);
            if (cursor === window) {
              break;
            }
            cursor = cursor.parentNode || null;
          }
          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
          spy(e, "stopPropagation", trackPropagation);
          spy(e, "stopImmediatePropagation", trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);
          if (phase === "capture") {
            if (captureElToHandlers === void 0)
              return;
            for (let i = path.length - 1; i >= 0; --i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = captureElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
              if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                const bubbleHandlers = bubbleElToHandlers.get(target2);
                if (bubbleHandlers !== void 0) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === "bubble") {
            if (bubbleElToHandlers === void 0)
              return;
            for (let i = 0; i < path.length; ++i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = bubbleElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
          unspy(e, "stopPropagation");
          unspy(e, "stopImmediatePropagation");
          defineCurrentTarget(e);
        };
        delegeteHandler.displayName = "evtdUnifiedHandler";
        return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
        const delegateHandler = function(e) {
          const { type, eventPhase } = e;
          if (eventPhase !== 2)
            return;
          const handlers = typeToWindowEventHandlers[type];
          if (handlers === void 0)
            return;
          handlers.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
        return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type] === void 0) {
          phaseHandlers[type] = /* @__PURE__ */ new Map();
          window.addEventListener(type, unifiedHandler, phase === "capture");
        }
        return phaseHandlers[type];
      }
      function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        if (windowEventHandlers === void 0) {
          typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
          window.addEventListener(type, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type];
      }
      function ensureHandlers(elToHandlers, el) {
        let elHandlers = elToHandlers.get(el);
        if (elHandlers === void 0) {
          elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
        }
        return elHandlers;
      }
      function handlerExist(el, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type];
        if (elToHandlers !== void 0) {
          const handlers = elToHandlers.get(el);
          if (handlers !== void 0) {
            if (handlers.has(handler))
              return true;
          }
        }
        return false;
      }
      function windowEventHandlerExist(type, handler) {
        const handlers = typeToWindowEventHandlers[type];
        if (handlers !== void 0) {
          if (handlers.has(handler)) {
            return true;
          }
        }
        return false;
      }
      function on2(type, el, handler, options) {
        let mergedHandler;
        if (typeof options === "object" && options.once === true) {
          mergedHandler = (e) => {
            off2(type, el, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }
        const trapped = trapOn(type, el, mergedHandler, options);
        if (trapped)
          return;
        const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);
        if (!handlers.has(mergedHandler))
          handlers.add(mergedHandler);
        if (el === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type);
          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }
      function off2(type, el, handler, options) {
        const trapped = trapOff(type, el, handler, options);
        if (trapped)
          return;
        const capture = options === true || typeof options === "object" && options.capture === true;
        const phase = capture ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el);
        if (el === window) {
          const mirrorPhase = capture ? "bubble" : "capture";
          if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
            const windowEventHandlers = typeToWindowEventHandlers[type];
            windowEventHandlers.delete(handler);
            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type] = void 0;
            }
          }
        }
        if (handlers.has(handler))
          handlers.delete(handler);
        if (handlers.size === 0) {
          elToHandlers.delete(el);
        }
        if (elToHandlers.size === 0) {
          window.removeEventListener(type, unifiedHandler, phase === "capture");
          phaseToTypeToElToHandlers[phase][type] = void 0;
        }
      }
      return {
        on: on2,
        off: off2
      };
    }
    const { on: on$1, off } = createDelegate();
    function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
        return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return readonly(currentRef);
    }
    function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
        valueRef.value = value;
      });
      if (typeof getterOrOptions === "function") {
        return valueRef;
      } else {
        return {
          __v_isRef: true,
          get value() {
            return valueRef.value;
          },
          set value(v) {
            getterOrOptions.set(v);
          }
        };
      }
    }
    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, (value) => {
        if (value !== void 0) {
          uncontrolledStateRef.value = value;
        }
      });
      return computed(() => {
        if (controlledStateRef.value === void 0) {
          return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
      });
    }
    function isMounted() {
      const isMounted2 = ref(false);
      onMounted(() => {
        isMounted2.value = true;
      });
      return readonly(isMounted2);
    }
    const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }
    function createInjectionKey(key) {
      return key;
    }
    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const drawerInjectionKey = createInjectionKey("n-drawer");
    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a2;
      const injection = inject(injectionName, null);
      if (injection === null) return;
      const vm2 = (_a2 = getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
        if (!injection) return;
        const collection = injection[collectionKey];
        if (oldKey !== void 0) removeInstance(collection, oldKey);
        if (key !== void 0) addInstance(collection, key);
      }
      function removeInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm2), 1);
      }
      function addInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm2)) {
          collection[key].push(vm2);
        }
      }
    }
    const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
    const isComposingRef = ref(false);
    function compositionStartHandler() {
      isComposingRef.value = true;
    }
    function compositionEndHandler() {
      isComposingRef.value = false;
    }
    let mountedCount = 0;
    function useIsComposing() {
      if (isBrowser$1) {
        onBeforeMount(() => {
          if (!mountedCount) {
            window.addEventListener("compositionstart", compositionStartHandler);
            window.addEventListener("compositionend", compositionEndHandler);
          }
          mountedCount++;
        });
        onBeforeUnmount(() => {
          if (mountedCount <= 1) {
            window.removeEventListener("compositionstart", compositionStartHandler);
            window.removeEventListener("compositionend", compositionEndHandler);
            mountedCount = 0;
          } else {
            mountedCount--;
          }
        });
      }
      return isComposingRef;
    }
    let lockCount = 0;
    let originalMarginRight = "";
    let originalOverflow = "";
    let originalOverflowX = "";
    let originalOverflowY = "";
    const lockHtmlScrollRightCompensationRef = ref("0px");
    function useLockHtmlScroll(lockRef) {
      if (typeof document === "undefined") return;
      const el = document.documentElement;
      let watchStopHandle;
      let activated = false;
      const unlock = () => {
        el.style.marginRight = originalMarginRight;
        el.style.overflow = originalOverflow;
        el.style.overflowX = originalOverflowX;
        el.style.overflowY = originalOverflowY;
        lockHtmlScrollRightCompensationRef.value = "0px";
      };
      onMounted(() => {
        watchStopHandle = watch(lockRef, (value) => {
          if (value) {
            if (!lockCount) {
              const scrollbarWidth = window.innerWidth - el.offsetWidth;
              if (scrollbarWidth > 0) {
                originalMarginRight = el.style.marginRight;
                el.style.marginRight = `${scrollbarWidth}px`;
                lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
              }
              originalOverflow = el.style.overflow;
              originalOverflowX = el.style.overflowX;
              originalOverflowY = el.style.overflowY;
              el.style.overflow = "hidden";
              el.style.overflowX = "hidden";
              el.style.overflowY = "hidden";
            }
            activated = true;
            lockCount++;
          } else {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
        if (activated) {
          lockCount--;
          if (!lockCount) {
            unlock();
          }
          activated = false;
        }
      });
    }
    function useReactivated(callback) {
      const isDeactivatedRef = {
        isDeactivated: false
      };
      let activateStateInitialized = false;
      onActivated(() => {
        isDeactivatedRef.isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        callback();
      });
      onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }
    function getSlot$1(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
    }
    const ctxKey = "@@coContext";
    const clickoutside = {
      mounted(el, { value, modifiers }) {
        el[ctxKey] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el[ctxKey].handler = value;
          on$1("clickoutside", el, value, {
            capture: modifiers.capture
          });
        }
      },
      updated(el, { value, modifiers }) {
        const ctx2 = el[ctxKey];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("clickoutside", el, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = value;
              on$1("clickoutside", el, value, {
                capture: modifiers.capture
              });
            }
          } else {
            el[ctxKey].handler = value;
            on$1("clickoutside", el, value, {
              capture: modifiers.capture
            });
          }
        } else {
          if (ctx2.handler) {
            off("clickoutside", el, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el, { modifiers }) {
        const { handler } = el[ctxKey];
        if (handler) {
          off("clickoutside", el, handler, {
            capture: modifiers.capture
          });
        }
        el[ctxKey].handler = void 0;
      }
    };
    function warn$2(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }
    class ZIndexManager {
      constructor() {
        this.elementZIndex = /* @__PURE__ */ new Map();
        this.nextZIndex = 2e3;
      }
      get elementCount() {
        return this.elementZIndex.size;
      }
      ensureZIndex(el, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== void 0) {
          el.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el);
          return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el)) {
          const currentZIndex = elementZIndex.get(el);
          if (currentZIndex + 1 === this.nextZIndex)
            return;
        }
        el.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }
      unregister(el, zIndex) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el)) {
          elementZIndex.delete(el);
        } else if (zIndex === void 0) {
          warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
        }
        this.squashState();
      }
      squashState() {
        const { elementCount } = this;
        if (!elementCount) {
          this.nextZIndex = 2e3;
        }
        if (this.nextZIndex - elementCount > 2500)
          this.rearrange();
      }
      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2e3;
        elementZIndexPair.forEach((pair) => {
          const el = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el.style.zIndex)
            el.style.zIndex = `${zIndex}`;
        });
      }
    }
    const zIndexManager = new ZIndexManager();
    const ctx = "@@ziContext";
    const zindexable = {
      mounted(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        el[ctx] = {
          enabled: !!enabled,
          initialized: false
        };
        if (enabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }
      },
      updated(el, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el[ctx].enabled;
        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el, zIndex);
          el[ctx].initialized = true;
        }
        el[ctx].enabled = !!enabled;
      },
      unmounted(el, bindings) {
        if (!el[ctx].initialized)
          return;
        const { value = {} } = bindings;
        const { zIndex } = value;
        zIndexManager.unregister(el, zIndex);
      }
    };
    const ssrContextKey = "@css-render/vue3-ssr";
    function createStyleString(id2, style2) {
      return `<style cssr-id="${id2}">
${style2}
</style>`;
    }
    function ssrAdapter(id2, style2, ssrContext) {
      const { styles, ids } = ssrContext;
      if (ids.has(id2))
        return;
      if (styles !== null) {
        ids.add(id2);
        styles.push(createStyleString(id2, style2));
      }
    }
    const isBrowser = typeof document !== "undefined";
    function useSsrAdapter() {
      if (isBrowser)
        return void 0;
      const context = inject(ssrContextKey, null);
      if (context === null)
        return void 0;
      return {
        adapter: (id2, style2) => ssrAdapter(id2, style2, context),
        context
      };
    }
    function warn$1(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }
    function resolveTo(selector) {
      if (typeof selector === "string") {
        return document.querySelector(selector);
      }
      return selector();
    }
    const LazyTeleport = /* @__PURE__ */ defineComponent({
      name: "LazyTeleport",
      props: {
        to: {
          type: [String, Object],
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(toRef(props, "show")),
          mergedTo: computed(() => {
            const { to: to2 } = props;
            return to2 !== null && to2 !== void 0 ? to2 : "body";
          })
        };
      },
      render() {
        return this.showTeleport ? this.disabled ? getSlot$1("lazy-teleport", this.$slots) : h(Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot$1("lazy-teleport", this.$slots)) : null;
      }
    });
    var resizeObservers = [];
    var hasActiveObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.activeTargets.length > 0;
      });
    };
    var hasSkippedObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.skippedTargets.length > 0;
      });
    };
    var msg = "ResizeObserver loop completed with undelivered notifications.";
    var deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
    var ResizeObserverBoxOptions;
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
    var freeze = function(obj) {
      return Object.freeze(obj);
    };
    var ResizeObserverSize = /* @__PURE__ */ function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
    var DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
    var isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    var isHidden = function(target) {
      if (isSVG(target)) {
        var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
        return !width && !height;
      }
      var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function(obj) {
      var _a2;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
    var global$1 = typeof window !== "undefined" ? window : {};
    var cache = /* @__PURE__ */ new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE$1 = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
    var parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    var size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs2 = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE$1 && cs2.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs2.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs2.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs2.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs2.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs2.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs2.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs2.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs2.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs2.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs2.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs2.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs2.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs2.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    var calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
    var ResizeObserverEntry = /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
    var calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
    var broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro2) {
        if (ro2.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro2.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro2.callback.call(ro2.observer, entries, ro2.observer);
        });
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
      });
      for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
        var callback = callbacks_1[_i2];
        callback();
      }
      return shallowestDepth;
    };
    var gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro2) {
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
        ro2.skippedTargets.splice(0, ro2.skippedTargets.length);
        ro2.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro2.activeTargets.push(ot);
            } else {
              ro2.skippedTargets.push(ot);
            }
          }
        });
      });
    };
    var process = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
    var trigger;
    var callbacks = [];
    var notify = function() {
      return callbacks.splice(0).forEach(function(cb2) {
        return cb2();
      });
    };
    var queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
    var queueResizeObserver = function(cb2) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb2);
      });
    };
    var watching = 0;
    var isWatching = function() {
      return !!watching;
    };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    var time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb2 = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb2() : global$1.addEventListener("DOMContentLoaded", cb2);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    var scheduler = new Scheduler();
    var updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
    var skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    var ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverDetail = /* @__PURE__ */ function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
    var observerMap = /* @__PURE__ */ new WeakMap();
    var getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
        this.elHandlersMap = /* @__PURE__ */ new Map();
      }
      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);
          if (handler !== void 0) {
            handler(entry);
          }
        }
      }
      registerHandler(el, handler) {
        this.elHandlersMap.set(el, handler);
        this.observer.observe(el);
      }
      unregisterHandler(el) {
        if (!this.elHandlersMap.has(el)) {
          return;
        }
        this.elHandlersMap.delete(el);
        this.observer.unobserve(el);
      }
    }
    const resizeObserverManager = new ResizeObserverDelegate();
    const VResizeObserver = /* @__PURE__ */ defineComponent({
      name: "ResizeObserver",
      props: {
        onResize: Function
      },
      setup(props) {
        let registered = false;
        const proxy = getCurrentInstance().proxy;
        function handleResize(entry) {
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        onMounted(() => {
          const el = proxy.$el;
          if (el === void 0) {
            warn$1("resize-observer", "$el does not exist.");
            return;
          }
          if (el.nextElementSibling !== el.nextSibling) {
            if (el.nodeType === 3 && el.nodeValue !== "") {
              warn$1("resize-observer", "$el can not be observed (it may be a text node).");
              return;
            }
          }
          if (el.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
            registered = true;
          }
        });
        onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },
      render() {
        return renderSlot(this.$slots, "default");
      }
    });
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }
    function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }
      try {
        element.focus({ preventScroll: true });
      } catch (e) {
      }
      return document.activeElement === element;
    }
    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.getAttribute("disabled")) {
        return false;
      }
      switch (element.nodeName) {
        case "A":
          return !!element.href && element.rel !== "ignore";
        case "INPUT":
          return element.type !== "hidden" && element.type !== "file";
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
          return true;
        default:
          return false;
      }
    }
    let stack = [];
    const FocusTrap = /* @__PURE__ */ defineComponent({
      name: "FocusTrap",
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        const id2 = createId();
        const focusableStartRef = ref(null);
        const focusableEndRef = ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id2;
        }
        function handleDocumentKeydown(e) {
          var _a2;
          if (e.code === "Escape") {
            if (isCurrentActive()) {
              (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
            }
          }
        }
        onMounted(() => {
          watch(() => props.active, (value) => {
            if (value) {
              activate();
              on$1("keydown", document, handleDocumentKeydown);
            } else {
              off("keydown", document, handleDocumentKeydown);
              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          off("keydown", document, handleDocumentKeydown);
          if (activated)
            deactivate();
        });
        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (mainEl.contains(getPreciseEventTarget(e)))
              return;
            resetFocusTo("first");
          }
        }
        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null)
            return null;
          let mainEl = focusableStartEl;
          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null)
              break;
            if (mainEl instanceof Element && mainEl.tagName === "DIV") {
              break;
            }
          }
          return mainEl;
        }
        function activate() {
          var _a2;
          if (props.disabled)
            return;
          stack.push(id2);
          if (props.autoFocus) {
            const { initialFocusTo } = props;
            if (initialFocusTo === void 0) {
              resetFocusTo("first");
            } else {
              (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
            }
          }
          activated = true;
          document.addEventListener("focus", handleDocumentFocus, true);
        }
        function deactivate() {
          var _a2;
          if (props.disabled)
            return;
          document.removeEventListener("focus", handleDocumentFocus, true);
          stack = stack.filter((idInStack) => idInStack !== id2);
          if (isCurrentActive())
            return;
          const { finalFocusTo } = props;
          if (finalFocusTo !== void 0) {
            (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
        function resetFocusTo(target) {
          if (!isCurrentActive())
            return;
          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;
            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();
              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
                return;
              }
              ignoreInternalFocusChange = true;
              const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;
              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }
        function handleStartFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        function handleEndFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: "position: absolute; height: 0; width: 0;",
          handleStartFocus,
          handleEndFocus
        };
      },
      render() {
        const { default: defaultSlot } = this.$slots;
        if (defaultSlot === void 0)
          return null;
        if (this.disabled)
          return defaultSlot();
        const { active, focusableStyle } = this;
        return h(Fragment, null, [
          h("div", {
            "aria-hidden": "true",
            tabindex: active ? "0" : "-1",
            ref: "focusableStartRef",
            style: focusableStyle,
            onFocus: this.handleStartFocus
          }),
          defaultSlot(),
          h("div", {
            "aria-hidden": "true",
            style: focusableStyle,
            ref: "focusableEndRef",
            tabindex: active ? "0" : "-1",
            onFocus: this.handleEndFocus
          })
        ]);
      }
    });
    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s|\./g, "_");
    }
    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length, {
      c: c2 = 1,
      offset = 0,
      attachPx = true
    } = {}) {
      if (typeof length === "number") {
        const result = (length + offset) * c2;
        if (result === 0) return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c2;
          if (attachPx) {
            if (result === 0) return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result) return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
        }
      }
      return length;
    }
    function rtlInset(inset) {
      const {
        left,
        right,
        top,
        bottom
      } = getMargin(inset);
      return `${top} ${left} ${bottom} ${right}`;
    }
    const eventSet = /* @__PURE__ */ new WeakSet();
    function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
    }
    function warn(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }
    function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
      } else {
        return funcs(...args);
      }
    }
    function flatten(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null) return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment) {
          if (vNode.children === null) return;
          if (Array.isArray(vNode.children)) {
            flatten(vNode.children, filterCommentNode, result);
          }
        } else {
          if (vNode.type === Comment && filterCommentNode) return;
          result.push(vNode);
        }
      });
      return result;
    }
    function getSlot(instance, slotName = "default", fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0) return fallback;
      return slot();
    }
    function keysOf(obj) {
      return Object.keys(obj);
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) {
          return true;
        }
        if (child.type === Comment) {
          return false;
        }
        if (child.type === Fragment && !ensureValidVNode(child.children)) {
          return false;
        }
        return true;
      }) ? vnodes : null;
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      render() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    });
    const configProviderInjectionKey = createInjectionKey("n-config-provider");
    const defaultClsPrefix = "n";
    function useConfig(props = {}, options = {
      defaultBordered: true
    }) {
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      return {
        // NConfigProvider,
        inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
        mergedBorderedRef: computed(() => {
          var _a2, _b2;
          const {
            bordered
          } = props;
          if (bordered !== void 0) return bordered;
          return (_b2 = (_a2 = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
        }),
        mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
        namespaceRef: computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
      };
    }
    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
      const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
      const themeClassRef = ref("");
      const ssrAdapter2 = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash) finalThemeHash += `-${themeHash}`;
        if (hashValue) finalThemeHash += `-${hashValue}`;
        const {
          themeOverrides,
          builtinThemeOverrides
        } = props;
        if (themeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
        }
        if (builtinThemeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
        }
        themeClassRef.value = finalThemeHash;
        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style2 = "";
          for (const key in cssVars) {
            style2 += `${key}: ${cssVars[key]};`;
          }
          c(`.${finalThemeHash}`, style2).mount({
            id: finalThemeHash,
            ssr: ssrAdapter2,
            parent: styleMountTarget
          });
          renderCallback = void 0;
        };
      };
      watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
        }
      };
    }
    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props, {
      defaultSize = "medium",
      mergedSize,
      mergedDisabled
    } = {}) {
      const NFormItem2 = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
        const {
          size: size2
        } = props;
        if (size2) return size2;
        if (NFormItem2) {
          const {
            mergedSize: mergedSize2
          } = NFormItem2;
          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }
        return defaultSize;
      });
      const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
        const {
          disabled
        } = props;
        if (disabled !== void 0) {
          return disabled;
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      });
      const mergedStatusRef = computed(() => {
        const {
          status
        } = props;
        if (status) return status;
        return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
        if (NFormItem2) {
          NFormItem2.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur() {
          if (NFormItem2) {
            NFormItem2.handleContentBlur();
          }
        },
        nTriggerFormChange() {
          if (NFormItem2) {
            NFormItem2.handleContentChange();
          }
        },
        nTriggerFormFocus() {
          if (NFormItem2) {
            NFormItem2.handleContentFocus();
          }
        },
        nTriggerFormInput() {
          if (NFormItem2) {
            NFormItem2.handleContentInput();
          }
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$9.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$8 = Object.prototype;
    var nativeObjectToString = objectProto$8.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$1 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return false ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsZWJ$1 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      {
        return buffer.slice();
      }
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const cssrAnchorMetaName = "naive-ui-style";
    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef) return void 0;
      const ssrAdapter2 = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
        const {
          value: rtlState
        } = rtlStateRef;
        if (!rtlState) {
          return void 0;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
          return void 0;
        }
        return componentRtlState;
      });
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        watchEffect(() => {
          const {
            value: clsPrefix
          } = clsPrefixRef;
          const id2 = `${clsPrefix}${mountId}Rtl`;
          if (exists(id2, ssrAdapter2)) return;
          const {
            value: componentRtlState
          } = componentRtlStateRef;
          if (!componentRtlState) return;
          componentRtlState.style.mount({
            id: id2,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        });
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
    }
    const commonVariables$n = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      // private now, it's too small
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };
    const {
      fontSize,
      fontFamily,
      lineHeight
    } = commonVariables$n;
    const globalStyle = c("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
    function useStyle(mountId, style2, clsPrefixRef) {
      if (!style2) {
        return;
      }
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
        if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    function createTheme(theme) {
      return theme;
    }
    function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      if (style2) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          onBeforeMount(mountStyle);
        }
      }
      const mergedThemeRef = computed(() => {
        var _a2;
        const {
          theme: {
            common: selfCommon,
            self: self2,
            peers = {}
          } = {},
          themeOverrides: selfOverrides = {},
          builtinThemeOverrides: builtinOverrides = {}
        } = props;
        const {
          common: selfCommonOverrides,
          peers: peersOverrides
        } = selfOverrides;
        const {
          common: globalCommon = void 0,
          [resolveId]: {
            common: globalSelfCommon = void 0,
            self: globalSelf = void 0,
            peers: globalPeers = {}
          } = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
        const {
          common: globalCommonOverrides = void 0,
          [resolveId]: globalSelfOverrides = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
        const {
          common: globalSelfCommonOverrides,
          peers: globalPeersOverrides = {}
        } = globalSelfOverrides;
        const mergedCommon = merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = merge(
          // {}, executed every time, no need for empty obj
          (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
          builtinOverrides,
          globalSelfOverrides,
          selfOverrides
        );
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: merge({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: merge({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }
    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };
    const style$b = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c("svg", `
 height: 1em;
 width: 1em;
 `)]);
    const NBaseIcon = /* @__PURE__ */ defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$b, toRef(props, "clsPrefix"));
      },
      render() {
        return h("i", {
          class: `${this.clsPrefix}-base-icon`,
          onClick: this.onClick,
          onMousedown: this.onMousedown,
          onMouseup: this.onMouseup,
          role: this.role,
          "aria-label": this.ariaLabel,
          "aria-hidden": this.ariaHidden,
          "aria-disabled": this.ariaDisabled
        }, this.$slots);
      }
    });
    const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, {
        slots
      }) {
        const isMountedRef = isMounted();
        return () => h(Transition, {
          name: "icon-switch-transition",
          appear: isMountedRef.value
        }, slots);
      }
    });
    function replaceable(name, icon) {
      const IconComponent = /* @__PURE__ */ defineComponent({
        render() {
          return icon();
        }
      });
      return /* @__PURE__ */ defineComponent({
        name: upperFirst(name),
        setup() {
          var _a2;
          const mergedIconsRef = (_a2 = inject(configProviderInjectionKey, null)) === null || _a2 === void 0 ? void 0 : _a2.mergedIconsRef;
          return () => {
            var _a3;
            const iconOverride = (_a3 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a3 === void 0 ? void 0 : _a3[name];
            return iconOverride ? iconOverride() : h(IconComponent, null);
          };
        }
      });
    }
    const ErrorIcon = replaceable("close", () => h("svg", {
      viewBox: "0 0 12 12",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": true
    }, h("g", {
      stroke: "none",
      "stroke-width": "1",
      fill: "none",
      "fill-rule": "evenodd"
    }, h("g", {
      fill: "currentColor",
      "fill-rule": "nonzero"
    }, h("path", {
      d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
    })))));
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$n;
    function iconSwitchTransition({
      originalTransform = "",
      left = 0,
      top = 0,
      transition = `all .3s ${cubicBezierEaseInOut$3} !important`
    } = {}) {
      return [c("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: `${originalTransform} scale(0.75)`,
        left,
        top,
        opacity: 0
      }), c("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }
    const style$a = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM$1("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM$1("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM$1("round", [c("&::before", `
 border-radius: 50%;
 `)])]);
    const NBaseClose = /* @__PURE__ */ defineComponent({
      name: "BaseClose",
      props: {
        isButtonTag: {
          type: Boolean,
          default: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$a, toRef(props, "clsPrefix"));
        return () => {
          const {
            clsPrefix,
            disabled,
            absolute,
            round,
            isButtonTag
          } = props;
          const Tag = isButtonTag ? "button" : "div";
          return h(Tag, {
            type: isButtonTag ? "button" : void 0,
            tabindex: disabled || !props.focusable ? -1 : 0,
            "aria-disabled": disabled,
            "aria-label": "close",
            role: isButtonTag ? void 0 : "button",
            disabled,
            class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round && `${clsPrefix}-base-close--round`],
            onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            },
            onClick: props.onClick
          }, h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => h(ErrorIcon, null)
          }));
        };
      }
    });
    const NFadeInExpandTransition = /* @__PURE__ */ defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
      },
      setup(props, {
        slots
      }) {
        function handleBeforeLeave(el) {
          if (props.width) {
            el.style.maxWidth = `${el.offsetWidth}px`;
          } else {
            el.style.maxHeight = `${el.offsetHeight}px`;
          }
          void el.offsetWidth;
        }
        function handleLeave(el) {
          if (props.width) {
            el.style.maxWidth = "0";
          } else {
            el.style.maxHeight = "0";
          }
          void el.offsetWidth;
          const {
            onLeave
          } = props;
          if (onLeave) onLeave();
        }
        function handleAfterLeave(el) {
          if (props.width) {
            el.style.maxWidth = "";
          } else {
            el.style.maxHeight = "";
          }
          const {
            onAfterLeave
          } = props;
          if (onAfterLeave) onAfterLeave();
        }
        function handleEnter(el) {
          el.style.transition = "none";
          if (props.width) {
            const memorizedWidth = el.offsetWidth;
            el.style.maxWidth = "0";
            void el.offsetWidth;
            el.style.transition = "";
            el.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el.style.maxHeight = `${el.offsetHeight}px`;
              void el.offsetHeight;
              el.style.transition = "";
              el.style.maxHeight = "0";
            } else {
              const memorizedHeight = el.offsetHeight;
              el.style.maxHeight = "0";
              void el.offsetWidth;
              el.style.transition = "";
              el.style.maxHeight = `${memorizedHeight}px`;
            }
          }
          void el.offsetWidth;
        }
        function handleAfterEnter(el) {
          var _a2;
          if (props.width) {
            el.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el.style.maxHeight = "";
            }
          }
          (_a2 = props.onAfterEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        return () => {
          const {
            group,
            width,
            appear,
            mode
          } = props;
          const type = group ? TransitionGroup : Transition;
          const resolvedProps = {
            name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          };
          if (!group) {
            resolvedProps.mode = mode;
          }
          return h(type, resolvedProps, slots);
        };
      }
    });
    const style$9 = c([c("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE$1("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE$1("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("container", `
 animation: rotator 3s linear infinite both;
 `, [cE$1("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
    const duration = "1.6s";
    const exposedLoadingProps = {
      strokeWidth: {
        type: Number,
        default: 28
      },
      stroke: {
        type: String,
        default: void 0
      }
    };
    const NBaseLoading = /* @__PURE__ */ defineComponent({
      name: "BaseLoading",
      props: Object.assign({
        clsPrefix: {
          type: String,
          required: true
        },
        show: {
          type: Boolean,
          default: true
        },
        scale: {
          type: Number,
          default: 1
        },
        radius: {
          type: Number,
          default: 100
        }
      }, exposedLoadingProps),
      setup(props) {
        useStyle("-base-loading", style$9, toRef(props, "clsPrefix"));
      },
      render() {
        const {
          clsPrefix,
          radius,
          strokeWidth,
          stroke,
          scale
        } = this;
        const scaledRadius = radius / scale;
        return h("div", {
          class: `${clsPrefix}-base-loading`,
          role: "img",
          "aria-label": "loading"
        }, h(NIconSwitchTransition, null, {
          default: () => this.show ? h("div", {
            key: "icon",
            class: `${clsPrefix}-base-loading__transition-wrapper`
          }, h("div", {
            class: `${clsPrefix}-base-loading__container`
          }, h("svg", {
            class: `${clsPrefix}-base-loading__icon`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: {
              color: stroke
            }
          }, h("g", null, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("circle", {
            class: `${clsPrefix}-base-loading__icon`,
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 5.67 * radius,
            "stroke-dashoffset": 18.48 * radius
          }, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("animate", {
            attributeName: "stroke-dashoffset",
            values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          })))))) : h("div", {
            key: "placeholder",
            class: `${clsPrefix}-base-loading__placeholder`
          }, this.$slots)
        }));
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$n;
    function fadeInTransition({
      name = "fade-in",
      enterDuration = "0.2s",
      leaveDuration = "0.2s",
      enterCubicBezier = cubicBezierEaseInOut$2,
      leaveCubicBezier = cubicBezierEaseInOut$2
    } = {}) {
      return [c(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }
    const base$1 = {
      neutralBase: "#000",
      neutralInvertBase: "#fff",
      neutralTextBase: "#fff",
      neutralPopover: "rgb(72, 72, 78)",
      neutralCard: "rgb(24, 24, 28)",
      neutralModal: "rgb(44, 44, 50)",
      neutralBody: "rgb(16, 16, 20)",
      alpha1: "0.9",
      alpha2: "0.82",
      alpha3: "0.52",
      alpha4: "0.38",
      alpha5: "0.28",
      alphaClose: "0.52",
      alphaDisabled: "0.38",
      alphaDisabledInput: "0.06",
      alphaPending: "0.09",
      alphaTablePending: "0.06",
      alphaTableStriped: "0.05",
      alphaPressed: "0.05",
      alphaAvatar: "0.18",
      alphaRail: "0.2",
      alphaProgressRail: "0.12",
      alphaBorder: "0.24",
      alphaDivider: "0.09",
      alphaInput: "0.1",
      alphaAction: "0.06",
      alphaTab: "0.04",
      alphaScrollbar: "0.2",
      alphaScrollbarHover: "0.3",
      alphaCode: "0.12",
      alphaTag: "0.2",
      // primary
      primaryHover: "#7fe7c4",
      primaryDefault: "#63e2b7",
      primaryActive: "#5acea7",
      primarySuppl: "rgb(42, 148, 125)",
      // info
      infoHover: "#8acbec",
      infoDefault: "#70c0e8",
      infoActive: "#66afd3",
      infoSuppl: "rgb(56, 137, 197)",
      // error
      errorHover: "#e98b8b",
      errorDefault: "#e88080",
      errorActive: "#e57272",
      errorSuppl: "rgb(208, 58, 82)",
      // warning
      warningHover: "#f5d599",
      warningDefault: "#f2c97d",
      warningActive: "#e6c260",
      warningSuppl: "rgb(240, 138, 0)",
      // success
      successHover: "#7fe7c4",
      successDefault: "#63e2b7",
      successActive: "#5acea7",
      successSuppl: "rgb(42, 148, 125)"
    };
    const baseBackgroundRgb$1 = rgba(base$1.neutralBase);
    const baseInvertBackgroundRgb$1 = rgba(base$1.neutralInvertBase);
    const overlayPrefix$1 = `rgba(${baseInvertBackgroundRgb$1.slice(0, 3).join(", ")}, `;
    function overlay$1(alpha) {
      return `${overlayPrefix$1 + String(alpha)})`;
    }
    function neutral$1(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb$1, overlayRgba);
    }
    const derived$1 = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base$1.neutralBase,
      // primary color
      primaryColor: base$1.primaryDefault,
      primaryColorHover: base$1.primaryHover,
      primaryColorPressed: base$1.primaryActive,
      primaryColorSuppl: base$1.primarySuppl,
      // info color
      infoColor: base$1.infoDefault,
      infoColorHover: base$1.infoHover,
      infoColorPressed: base$1.infoActive,
      infoColorSuppl: base$1.infoSuppl,
      // success color
      successColor: base$1.successDefault,
      successColorHover: base$1.successHover,
      successColorPressed: base$1.successActive,
      successColorSuppl: base$1.successSuppl,
      // warning color
      warningColor: base$1.warningDefault,
      warningColorHover: base$1.warningHover,
      warningColorPressed: base$1.warningActive,
      warningColorSuppl: base$1.warningSuppl,
      // error color
      errorColor: base$1.errorDefault,
      errorColorHover: base$1.errorHover,
      errorColorPressed: base$1.errorActive,
      errorColorSuppl: base$1.errorSuppl,
      // text color
      textColorBase: base$1.neutralTextBase,
      textColor1: overlay$1(base$1.alpha1),
      textColor2: overlay$1(base$1.alpha2),
      textColor3: overlay$1(base$1.alpha3),
      // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
      // textColor5: overlay(base.alpha5),
      textColorDisabled: overlay$1(base$1.alpha4),
      placeholderColor: overlay$1(base$1.alpha4),
      placeholderColorDisabled: overlay$1(base$1.alpha5),
      iconColor: overlay$1(base$1.alpha4),
      iconColorDisabled: overlay$1(base$1.alpha5),
      iconColorHover: overlay$1(Number(base$1.alpha4) * 1.25),
      iconColorPressed: overlay$1(Number(base$1.alpha4) * 0.8),
      opacity1: base$1.alpha1,
      opacity2: base$1.alpha2,
      opacity3: base$1.alpha3,
      opacity4: base$1.alpha4,
      opacity5: base$1.alpha5,
      dividerColor: overlay$1(base$1.alphaDivider),
      borderColor: overlay$1(base$1.alphaBorder),
      // close
      closeIconColorHover: overlay$1(Number(base$1.alphaClose)),
      closeIconColor: overlay$1(Number(base$1.alphaClose)),
      closeIconColorPressed: overlay$1(Number(base$1.alphaClose)),
      closeColorHover: "rgba(255, 255, 255, .12)",
      closeColorPressed: "rgba(255, 255, 255, .08)",
      // clear
      clearColor: overlay$1(base$1.alpha4),
      clearColorHover: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 1.25
      }),
      clearColorPressed: scaleColor(overlay$1(base$1.alpha4), {
        alpha: 0.8
      }),
      scrollbarColor: overlay$1(base$1.alphaScrollbar),
      scrollbarColorHover: overlay$1(base$1.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: overlay$1(base$1.alphaProgressRail),
      railColor: overlay$1(base$1.alphaRail),
      popoverColor: base$1.neutralPopover,
      tableColor: base$1.neutralCard,
      cardColor: base$1.neutralCard,
      modalColor: base$1.neutralModal,
      bodyColor: base$1.neutralBody,
      tagColor: neutral$1(base$1.alphaTag),
      avatarColor: overlay$1(base$1.alphaAvatar),
      invertedColor: base$1.neutralBase,
      inputColor: overlay$1(base$1.alphaInput),
      codeColor: overlay$1(base$1.alphaCode),
      tabColor: overlay$1(base$1.alphaTab),
      actionColor: overlay$1(base$1.alphaAction),
      tableHeaderColor: overlay$1(base$1.alphaAction),
      hoverColor: overlay$1(base$1.alphaPending),
      tableColorHover: overlay$1(base$1.alphaTablePending),
      tableColorStriped: overlay$1(base$1.alphaTableStriped),
      pressedColor: overlay$1(base$1.alphaPressed),
      opacityDisabled: base$1.alphaDisabled,
      inputColorDisabled: overlay$1(base$1.alphaDisabledInput),
      buttonColor2: "rgba(255, 255, 255, .08)",
      buttonColor2Hover: "rgba(255, 255, 255, .12)",
      buttonColor2Pressed: "rgba(255, 255, 255, .08)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const base = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      // disabled text, placeholder, icon
      alpha5: "0.18",
      // disabled placeholder
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaAvatar: "0.2",
      alphaProgressRail: ".08",
      alphaInput: "0",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      // primary
      primaryHover: "#36ad6a",
      primaryDefault: "#18a058",
      primaryActive: "#0c7a43",
      primarySuppl: "#36ad6a",
      // info
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      // error
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      // warning
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      // success
      successHover: "#36ad6a",
      successDefault: "#18a058",
      successActive: "#0c7a43",
      successSuppl: "#36ad6a"
    };
    const baseBackgroundRgb = rgba(base.neutralBase);
    const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
    const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
    function overlay(alpha) {
      return `${overlayPrefix + String(alpha)})`;
    }
    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }
    const derived = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base.neutralBase,
      // primary color
      primaryColor: base.primaryDefault,
      primaryColorHover: base.primaryHover,
      primaryColorPressed: base.primaryActive,
      primaryColorSuppl: base.primarySuppl,
      // info color
      infoColor: base.infoDefault,
      infoColorHover: base.infoHover,
      infoColorPressed: base.infoActive,
      infoColorSuppl: base.infoSuppl,
      // success color
      successColor: base.successDefault,
      successColorHover: base.successHover,
      successColorPressed: base.successActive,
      successColorSuppl: base.successSuppl,
      // warning color
      warningColor: base.warningDefault,
      warningColorHover: base.warningHover,
      warningColorPressed: base.warningActive,
      warningColorSuppl: base.warningSuppl,
      // error color
      errorColor: base.errorDefault,
      errorColorHover: base.errorHover,
      errorColorPressed: base.errorActive,
      errorColorSuppl: base.errorSuppl,
      // text color
      textColorBase: base.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base.alpha4),
      placeholderColor: neutral(base.alpha4),
      placeholderColorDisabled: neutral(base.alpha5),
      iconColor: neutral(base.alpha4),
      iconColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      iconColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      iconColorDisabled: neutral(base.alpha5),
      opacity1: base.alpha1,
      opacity2: base.alpha2,
      opacity3: base.alpha3,
      opacity4: base.alpha4,
      opacity5: base.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      // close
      closeIconColor: neutral(Number(base.alphaClose)),
      closeIconColorHover: neutral(Number(base.alphaClose)),
      closeIconColorPressed: neutral(Number(base.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      // clear
      clearColor: neutral(base.alpha4),
      clearColorHover: scaleColor(neutral(base.alpha4), {
        lightness: 0.75
      }),
      clearColorPressed: scaleColor(neutral(base.alpha4), {
        lightness: 0.9
      }),
      scrollbarColor: overlay(base.alphaScrollbar),
      scrollbarColorHover: overlay(base.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base.neutralPopover,
      tableColor: base.neutralCard,
      cardColor: base.neutralCard,
      modalColor: base.neutralModal,
      bodyColor: base.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const commonVars$d = {
      railInsetHorizontalBottom: "auto 2px 4px 2px",
      railInsetHorizontalTop: "4px 2px auto 2px",
      railInsetVerticalRight: "2px 4px 2px auto",
      railInsetVerticalLeft: "2px auto 2px 4px",
      railColor: "transparent"
    };
    function self$S(vars) {
      const {
        scrollbarColor,
        scrollbarColorHover,
        scrollbarHeight,
        scrollbarWidth,
        scrollbarBorderRadius
      } = vars;
      return Object.assign(Object.assign({}, commonVars$d), {
        height: scrollbarHeight,
        width: scrollbarWidth,
        borderRadius: scrollbarBorderRadius,
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      });
    }
    const scrollbarLight = {
      name: "Scrollbar",
      common: derived,
      self: self$S
    };
    const scrollbarDark = {
      name: "Scrollbar",
      common: derived$1,
      self: self$S
    };
    const style$8 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c(">", [
      // We can't set overflow hidden since it affects positioning.
      cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
    ])])]), c(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM$1("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c(">", [cE$1("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM$1("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM$1("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM$1("vertical", `
 width: var(--n-scrollbar-width);
 `, [c(">", [cE$1("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM$1("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM$1("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM$1("disabled", [c(">", [cE$1("scrollbar", "pointer-events: none;")])]), c(">", [cE$1("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
    const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      // If container is set, resize observer won't not attached
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: [String, Array],
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean,
      yPlacement: {
        type: String,
        default: "right"
      },
      xPlacement: {
        type: String,
        default: "bottom"
      }
    });
    const Scrollbar = /* @__PURE__ */ defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      inheritAttrs: false,
      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = ref(null);
        const containerRef = ref(null);
        const contentRef = ref(null);
        const yRailRef = ref(null);
        const xRailRef = ref(null);
        const contentHeightRef = ref(null);
        const contentWidthRef = ref(null);
        const containerHeightRef = ref(null);
        const containerWidthRef = ref(null);
        const yRailSizeRef = ref(null);
        const xRailSizeRef = ref(null);
        const containerScrollTopRef = ref(0);
        const containerScrollLeftRef = ref(0);
        const isShowXBarRef = ref(false);
        const isShowYBarRef = ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos2 = useIsIos();
        const themeRef = useTheme("Scrollbar", "-scrollbar", style$8, scrollbarLight, props, mergedClsPrefixRef);
        const yBarSizeRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
          }
        });
        const yBarSizePxRef = computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
          }
        });
        const xBarSizePxRef = computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: containerScrollTop
          } = containerScrollTopRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff) return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: containerScrollLeft
          } = containerScrollLeftRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff) return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = computed(() => {
          const {
            container
          } = props;
          if (container) return container();
          return containerRef.value;
        });
        const mergedContentRef = computed(() => {
          const {
            content
          } = props;
          if (content) return content();
          return contentRef.value;
        });
        const scrollTo = (options, y) => {
          if (!props.scrollable) return;
          if (typeof options === "number") {
            scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
            return;
          }
          const {
            left,
            top,
            index,
            elSize,
            position,
            behavior,
            el,
            debounce = true
          } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
          }
          if (el !== void 0) {
            scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated) return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated) return;
          const {
            onResize
          } = props;
          if (onResize) onResize(e);
          sync();
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable) return;
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (debounce) {
            const {
              scrollTop,
              offsetHeight
            } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight) ;
              else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const {
            onScroll
          } = props;
          if (onScroll) onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          }
        }
        function syncPositionState() {
          const {
            value: content
          } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable) return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          var _a2;
          return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on$1("mousemove", window, handleXScrollMouseMove, true);
          on$1("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xBarSize
          } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null) return;
          const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            const {
              internalOnUpdateScrollLeft
            } = props;
            if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on$1("mousemove", window, handleYScrollMouseMove, true);
          on$1("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yBarSize
          } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null) return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        watchEffect(() => {
          const {
            value: needXBar
          } = needXBarRef;
          const {
            value: needYBar
          } = needYBarRef;
          const {
            value: mergedClsPrefix
          } = mergedClsPrefixRef;
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
        });
        onMounted(() => {
          if (props.container) return;
          sync();
        });
        onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              color,
              colorHover,
              height,
              width,
              borderRadius,
              railInsetHorizontalTop,
              railInsetHorizontalBottom,
              railInsetVerticalRight,
              railInsetVerticalLeft,
              railColor
            }
          } = themeRef.value;
          const {
            top: railTopHorizontalTop,
            right: railRightHorizontalTop,
            bottom: railBottomHorizontalTop,
            left: railLeftHorizontalTop
          } = getMargin(railInsetHorizontalTop);
          const {
            top: railTopHorizontalBottom,
            right: railRightHorizontalBottom,
            bottom: railBottomHorizontalBottom,
            left: railLeftHorizontalBottom
          } = getMargin(railInsetHorizontalBottom);
          const {
            top: railTopVerticalRight,
            right: railRightVerticalRight,
            bottom: railBottomVerticalRight,
            left: railLeftVerticalRight
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
          const {
            top: railTopVerticalLeft,
            right: railRightVerticalLeft,
            bottom: railBottomVerticalLeft,
            left: railLeftVerticalLeft
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut2,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": borderRadius,
            "--n-scrollbar-width": width,
            "--n-scrollbar-height": height,
            "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
            "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
            "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
            "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
            "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
            "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
            "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
            "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
            "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
            "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
            "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
            "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
            "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
            "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
            "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
            "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
            "--n-scrollbar-rail-color": railColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos: isIos2,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a2;
        const {
          $slots,
          mergedClsPrefix,
          triggerDisplayManually,
          rtlEnabled,
          internalHoistYRail,
          yPlacement,
          xPlacement,
          xScrollable
        } = this;
        if (!this.scrollable) return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        const triggerIsNone = this.trigger === "none";
        const createYRail = (className, style2) => {
          return h("div", {
            ref: "yRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
            "data-scrollbar-rail": true,
            style: [style2 || "", this.verticalRailStyle],
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                height: this.yBarSizePx,
                top: this.yBarTopPx
              },
              onMousedown: this.handleYScrollMouseDown
            }) : null
          }));
        };
        const createChildren = () => {
          var _a3, _b2;
          (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
          return h("div", mergeProps(this.$attrs, {
            role: "none",
            ref: "wrapperRef",
            class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
            style: this.cssVars,
            onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
            onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
          }), [this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h("div", {
            role: "none",
            ref: "containerRef",
            class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
            style: this.containerStyle,
            onScroll: this.handleScroll,
            onWheel: this.onWheel
          }, h(VResizeObserver, {
            onResize: this.handleContentResize
          }, {
            default: () => h("div", {
              ref: "contentRef",
              role: "none",
              style: [{
                width: this.xScrollable ? "fit-content" : null
              }, this.contentStyle],
              class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
            }, $slots)
          })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && h("div", {
            ref: "xRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
            style: this.horizontalRailStyle,
            "data-scrollbar-rail": true,
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                width: this.xBarSizePx,
                right: rtlEnabled ? this.xBarLeftPx : void 0,
                left: rtlEnabled ? void 0 : this.xBarLeftPx
              },
              onMousedown: this.handleXScrollMouseDown
            }) : null
          }))]);
        };
        const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, {
          onResize: this.handleContainerResize
        }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return h(Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
        } else {
          return scrollbarNode;
        }
      }
    });
    const commonVars$c = {
      iconSizeTiny: "28px",
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };
    function self$R(vars) {
      const {
        textColorDisabled,
        iconColor,
        textColor2,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVars$c), {
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      });
    }
    const emptyLight = {
      name: "Empty",
      common: derived,
      self: self$R
    };
    const emptyDark = {
      name: "Empty",
      common: derived$1,
      self: self$R
    };
    const commonVariables$m = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingTiny: "4px 0",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingTiny: "0 12px",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };
    function self$Q(vars) {
      const {
        borderRadius,
        popoverColor,
        textColor3,
        dividerColor,
        textColor2,
        primaryColorPressed,
        textColorDisabled,
        primaryColor,
        opacityDisabled,
        hoverColor,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$m), {
        optionFontSizeTiny: fontSizeTiny,
        optionFontSizeSmall: fontSizeSmall,
        optionFontSizeMedium: fontSizeMedium,
        optionFontSizeLarge: fontSizeLarge,
        optionFontSizeHuge: fontSizeHuge,
        optionHeightTiny: heightTiny,
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        color: popoverColor,
        groupHeaderTextColor: textColor3,
        actionDividerColor: dividerColor,
        optionTextColor: textColor2,
        optionTextColorPressed: primaryColorPressed,
        optionTextColorDisabled: textColorDisabled,
        optionTextColorActive: primaryColor,
        optionOpacityDisabled: opacityDisabled,
        optionCheckColor: primaryColor,
        optionColorPending: hoverColor,
        optionColorActive: "rgba(0, 0, 0, 0)",
        optionColorActivePending: hoverColor,
        actionTextColor: textColor2,
        loadingColor: primaryColor
      });
    }
    const internalSelectMenuDark = {
      name: "InternalSelectMenu",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self: self$Q
    };
    const commonVariables$l = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };
    function self$P(vars) {
      const {
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        fontSize: fontSize2,
        dividerColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$l), {
        fontSize: fontSize2,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const popoverDark = {
      name: "Popover",
      common: derived$1,
      self: self$P
    };
    const commonVariables$k = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px"
    };
    const tagDark = {
      name: "Tag",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          primaryColorHover,
          primaryColorPressed,
          primaryColor,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          baseColor,
          borderColor,
          tagColor,
          opacityDisabled,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderRadiusSmall: borderRadius,
          fontSizeMini,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          heightMini,
          heightTiny,
          heightSmall,
          heightMedium,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$k), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          // checked
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          // default
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "#0000",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          colorBorderedPrimary: "#0000",
          closeIconColorPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorHoverPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorPressedPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeColorHoverPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          closeColorPressedPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          borderInfo: `1px solid ${changeColor(infoColor, {
            alpha: 0.3
          })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          colorBorderedInfo: "#0000",
          closeIconColorInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorHoverInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorPressedInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeColorHoverInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          closeColorPressedInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          borderSuccess: `1px solid ${changeColor(successColor, {
            alpha: 0.3
          })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          colorBorderedSuccess: "#0000",
          closeIconColorSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorHoverSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorPressedSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeColorHoverSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          closeColorPressedSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          borderWarning: `1px solid ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          colorBorderedWarning: "#0000",
          closeIconColorWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorHoverWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorPressedWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeColorHoverWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          closeColorPressedWarning: changeColor(warningColor, {
            alpha: 0.11
          }),
          borderError: `1px solid ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, {
            alpha: 0.16
          }),
          colorBorderedError: "#0000",
          closeIconColorError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorHoverError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorPressedError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeColorHoverError: changeColor(errorColor, {
            alpha: 0.16
          }),
          closeColorPressedError: changeColor(errorColor, {
            alpha: 0.12
          })
        });
      }
    };
    const commonVariables$j = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };
    const internalSelectionDark = {
      name: "InternalSelection",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          textColor2,
          textColorDisabled,
          inputColor,
          inputColorDisabled,
          primaryColor,
          primaryColorHover,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          iconColor,
          iconColorDisabled,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$j), {
          fontWeight,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          // default
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: changeColor(primaryColor, {
            alpha: 0.1
          }),
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          // warning
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          colorActiveWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          caretColorWarning: warningColor,
          // error
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          colorActiveError: changeColor(errorColor, {
            alpha: 0.1
          }),
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      }
    };
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1
    } = commonVariables$n;
    function fadeInWidthExpandTransition({
      duration: duration2 = ".2s",
      delay = ".1s"
    } = {}) {
      return [c("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1},
 max-width ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-left ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-right ${duration2} ${cubicBezierEaseInOut$1} ${delay};
 `), c("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 max-width ${duration2} ${cubicBezierEaseInOut$1},
 margin-left ${duration2} ${cubicBezierEaseInOut$1},
 margin-right ${duration2} ${cubicBezierEaseInOut$1};
 `)];
    }
    const style$7 = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
    const NBaseWave = /* @__PURE__ */ defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$7, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const activeRef = ref(false);
        let animationTimerId = null;
        onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void nextTick(() => {
              var _a2;
              void ((_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight);
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const {
          clsPrefix
        } = this;
        return h("div", {
          ref: "selfRef",
          "aria-hidden": true,
          class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
        });
      }
    });
    const commonVars$b = {
      iconMargin: "11px 8px 0 12px",
      iconMarginRtl: "11px 12px 0 8px",
      iconSize: "24px",
      closeIconSize: "16px",
      closeSize: "20px",
      closeMargin: "13px 14px 0 0",
      closeMarginRtl: "13px 0 0 14px",
      padding: "13px"
    };
    const alertDark = {
      name: "Alert",
      common: derived$1,
      self(vars) {
        const {
          lineHeight: lineHeight2,
          borderRadius,
          fontWeightStrong,
          dividerColor,
          inputColor,
          textColor1,
          textColor2,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$b), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: inputColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${changeColor(infoColorSuppl, {
            alpha: 0.35
          })}`,
          colorInfo: changeColor(infoColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColorSuppl,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${changeColor(successColorSuppl, {
            alpha: 0.35
          })}`,
          colorSuccess: changeColor(successColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColorSuppl,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${changeColor(warningColorSuppl, {
            alpha: 0.35
          })}`,
          colorWarning: changeColor(warningColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColorSuppl,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${changeColor(errorColorSuppl, {
            alpha: 0.35
          })}`,
          colorError: changeColor(errorColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorError: textColor1,
          iconColorError: errorColorSuppl,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        });
      }
    };
    const commonVars$a = {
      linkFontSize: "13px",
      linkPadding: "0 0 0 16px",
      railWidth: "4px"
    };
    function self$O(vars) {
      const {
        borderRadius,
        railColor,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$a), {
        borderRadius,
        railColor,
        railColorActive: primaryColor,
        linkColor: changeColor(primaryColor, {
          alpha: 0.15
        }),
        linkTextColor: textColor2,
        linkTextColorHover: primaryColorHover,
        linkTextColorPressed: primaryColorPressed,
        linkTextColorActive: primaryColor
      });
    }
    const anchorDark = {
      name: "Anchor",
      common: derived$1,
      self: self$O
    };
    const isChrome = isBrowser$1 && "chrome" in window;
    isBrowser$1 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$1 && navigator.userAgent.includes("Safari") && !isChrome;
    const commonVariables$i = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };
    const inputDark = {
      name: "Input",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          textColor3,
          textColorDisabled,
          primaryColor,
          primaryColorHover,
          inputColor,
          inputColorDisabled,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderRadius,
          lineHeight: lineHeight2,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$i), {
          fontWeight,
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: inputColor,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          groupLabelTextColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: changeColor(primaryColor, {
            alpha: 0.1
          }),
          groupLabelBorder: "1px solid #0000",
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: "1px solid #0000",
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          loadingColor: primaryColor,
          // warning
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          caretColorWarning: warningColor,
          // error
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: changeColor(errorColor, {
            alpha: 0.1
          }),
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      }
    };
    function self$N(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const autoCompleteDark = {
      name: "AutoComplete",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self: self$N
    };
    function self$M(vars) {
      const {
        borderRadius,
        avatarColor,
        cardColor,
        fontSize: fontSize2,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        modalColor,
        popoverColor
      } = vars;
      return {
        borderRadius,
        fontSize: fontSize2,
        border: `2px solid ${cardColor}`,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        color: composite(cardColor, avatarColor),
        colorModal: composite(modalColor, avatarColor),
        colorPopover: composite(popoverColor, avatarColor)
      };
    }
    const avatarDark = {
      name: "Avatar",
      common: derived$1,
      self: self$M
    };
    function self$L() {
      return {
        gap: "-12px"
      };
    }
    const avatarGroupDark = {
      name: "AvatarGroup",
      common: derived$1,
      peers: {
        Avatar: avatarDark
      },
      self: self$L
    };
    const commonVariables$h = {
      width: "44px",
      height: "44px",
      borderRadius: "22px",
      iconSize: "26px"
    };
    const backTopDark = {
      name: "BackTop",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          primaryColorHover,
          primaryColorPressed
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$h), {
          color: popoverColor,
          textColor: textColor2,
          iconColor: textColor2,
          iconColorHover: primaryColorHover,
          iconColorPressed: primaryColorPressed,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
        });
      }
    };
    const badgeDark = {
      name: "Badge",
      common: derived$1,
      self(vars) {
        const {
          errorColorSuppl,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          fontFamily: fontFamily2
        } = vars;
        return {
          color: errorColorSuppl,
          colorInfo: infoColorSuppl,
          colorSuccess: successColorSuppl,
          colorError: errorColorSuppl,
          colorWarning: warningColorSuppl,
          fontSize: "12px",
          fontFamily: fontFamily2
        };
      }
    };
    const commonVariables$g = {
      fontWeightActive: "400"
    };
    function self$K(vars) {
      const {
        fontSize: fontSize2,
        textColor3,
        textColor2,
        borderRadius,
        buttonColor2Hover,
        buttonColor2Pressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$g), {
        fontSize: fontSize2,
        itemLineHeight: "1.25",
        itemTextColor: textColor3,
        itemTextColorHover: textColor2,
        itemTextColorPressed: textColor2,
        itemTextColorActive: textColor2,
        itemBorderRadius: borderRadius,
        itemColorHover: buttonColor2Hover,
        itemColorPressed: buttonColor2Pressed,
        separatorColor: textColor3
      });
    }
    const breadcrumbDark = {
      name: "Breadcrumb",
      common: derived$1,
      self: self$K
    };
    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }
    const buttonGroupInjectionKey = createInjectionKey("n-button-group");
    const commonVariables$f = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };
    function self$J(vars) {
      const {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        textColor2,
        textColor3,
        primaryColorHover,
        primaryColorPressed,
        borderColor,
        primaryColor,
        baseColor,
        infoColor,
        infoColorHover,
        infoColorPressed,
        successColor,
        successColorHover,
        successColorPressed,
        warningColor,
        warningColorHover,
        warningColorPressed,
        errorColor,
        errorColorHover,
        errorColorPressed,
        fontWeight,
        buttonColor2,
        buttonColor2Hover,
        buttonColor2Pressed,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$f), {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        // secondary
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        // tertiary
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        // quaternary
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        // default type
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        // primary
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        // info
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        // success
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        // warning
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        // error
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      });
    }
    const buttonLight = {
      common: derived,
      self: self$J
    };
    const buttonDark = {
      name: "Button",
      common: derived$1,
      self(vars) {
        const commonSelf = self$J(vars);
        commonSelf.waveOpacity = "0.8";
        commonSelf.colorOpacitySecondary = "0.16";
        commonSelf.colorOpacitySecondaryHover = "0.2";
        commonSelf.colorOpacitySecondaryPressed = "0.12";
        return commonSelf;
      }
    };
    const style$6 = c([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM$1("color", [cE$1("border", {
      borderColor: "var(--n-border-color)"
    }), cM$1("disabled", [cE$1("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c("&:focus", [cE$1("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c("&:hover", [cE$1("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c("&:active", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM$1("pressed", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM$1("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE$1("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE$1("state-border", {
      border: "var(--n-border-focus)"
    })]), c("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE$1("state-border", {
      border: "var(--n-border-hover)"
    })]), c("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM$1("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM$1("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM$1("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$1 && "MozBoxSizing" in document.createElement("div").style ? c("&::moz-focus-inner", {
      border: 0
    }) : null, cE$1("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE$1("border", {
      border: "var(--n-border)"
    }), cE$1("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE$1("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE$1("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c("~", [cE$1("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM$1("block", `
 display: flex;
 width: 100%;
 `), cM$1("dashed", [cE$1("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM$1("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        // don't use exact 5px since chrome will display the animation with glitches
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);
    const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
      color: String,
      textColor: String,
      text: Boolean,
      block: Boolean,
      loading: Boolean,
      disabled: Boolean,
      circle: Boolean,
      size: String,
      ghost: Boolean,
      round: Boolean,
      secondary: Boolean,
      tertiary: Boolean,
      quaternary: Boolean,
      strong: Boolean,
      focusable: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      tag: {
        type: String,
        default: "button"
      },
      type: {
        type: String,
        default: "default"
      },
      dashed: Boolean,
      renderIcon: Function,
      iconPlacement: {
        type: String,
        default: "left"
      },
      attrType: {
        type: String,
        default: "button"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      onClick: [Function, Array],
      nativeFocusBehavior: {
        type: Boolean,
        default: !isSafari
      }
    });
    const Button = /* @__PURE__ */ defineComponent({
      name: "Button",
      props: buttonProps,
      slots: Object,
      setup(props) {
        const selfElRef = ref(null);
        const waveElRef = ref(null);
        const enterPressedRef = ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup = inject(buttonGroupInjectionKey, {});
        const {
          mergedSizeRef
        } = useFormItem({}, {
          defaultSize: "medium",
          mergedSize: (NFormItem2) => {
            const {
              size: size2
            } = props;
            if (size2) return size2;
            const {
              size: buttonGroupSize
            } = NButtonGroup;
            if (buttonGroupSize) return buttonGroupSize;
            const {
              mergedSize: formItemSize2
            } = NFormItem2 || {};
            if (formItemSize2) {
              return formItemSize2.value;
            }
            return "medium";
          }
        });
        const mergedFocusableRef = computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          var _a2;
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            (_a2 = selfElRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus({
              preventScroll: true
            });
          }
        };
        const handleClick = (e) => {
          var _a2;
          if (!props.disabled && !props.loading) {
            const {
              onClick
            } = props;
            if (onClick) call(onClick, e);
            if (!props.text) {
              (_a2 = waveElRef.value) === null || _a2 === void 0 ? void 0 : _a2.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Button", "-button", style$6, buttonLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const theme = themeRef.value;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: self2
          } = theme;
          const {
            rippleDuration,
            opacityDisabled,
            fontWeight,
            fontWeightStrong
          } = self2;
          const size2 = mergedSizeRef.value;
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          const fontProps = {
            "--n-font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type === "tertiary";
          const typeIsDefault = type === "default";
          const mergedType = typeIsTertiary ? "default" : type;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type !== "default" && type !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondary)
              }) : self2.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryPressed)
              }) : self2.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-disabled": self2.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self2.colorTertiary;
              colorProps["--n-color-hover"] = self2.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self2.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self2.colorTertiary;
            } else {
              colorProps["--n-color"] = self2.colorQuaternary;
              colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self2.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self2[createKey("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
              "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self2[createKey("border", mergedType)],
              "--n-border-hover": self2[createKey("borderHover", mergedType)],
              "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
              "--n-border-focus": self2[createKey("borderFocus", mergedType)],
              "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
            };
          }
          const {
            [createKey("height", size2)]: height,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("padding", size2)]: padding,
            [createKey("paddingRound", size2)]: paddingRound,
            [createKey("iconSize", size2)]: iconSize,
            [createKey("borderRadius", size2)]: borderRadius,
            [createKey("iconMargin", size2)]: iconMargin,
            waveOpacity
          } = self2;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize2,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-ease-out": cubicBezierEaseOut2,
            "--n-ripple-duration": rippleDuration,
            "--n-opacity-disabled": opacityDisabled,
            "--n-wave-opacity": waveOpacity
          }, fontProps), colorProps), borderProps), sizeProps);
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
          let hash = "";
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          if (dashed) hash += "a";
          if (ghost) hash += "b";
          if (text) hash += "c";
          if (round) hash += "d";
          if (circle) hash += "e";
          if (secondary) hash += "f";
          if (tertiary) hash += "g";
          if (quaternary) hash += "h";
          if (strong) hash += "i";
          if (color) hash += `j${color2Class(color)}`;
          if (textColor) hash += `k${color2Class(textColor)}`;
          const {
            value: size2
          } = mergedSizeRef;
          hash += `l${size2[0]}`;
          hash += `m${type[0]}`;
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: computed(() => {
            const {
              color
            } = props;
            if (!color) return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          tag: Component,
          onRender
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", {
          class: `${mergedClsPrefix}-button__content`
        }, children2));
        return h(Component, {
          ref: "selfElRef",
          class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
            // required for button group border collapse
          ],
          tabindex: this.mergedFocusable ? 0 : -1,
          type: this.attrType,
          style: this.cssVars,
          disabled: this.disabled,
          onClick: this.handleClick,
          onBlur: this.handleBlur,
          onMousedown: this.handleMousedown,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, this.iconPlacement === "right" && children, h(NFadeInExpandTransition, {
          width: true
        }, {
          default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h("span", {
            class: `${mergedClsPrefix}-button__icon`,
            style: {
              margin: isSlotEmpty(this.$slots.default) ? "0" : ""
            }
          }, h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              clsPrefix: mergedClsPrefix,
              key: "loading",
              class: `${mergedClsPrefix}-icon-slot`,
              strokeWidth: 20
            }) : h("div", {
              key: "icon",
              class: `${mergedClsPrefix}-icon-slot`,
              role: "none"
            }, this.renderIcon ? this.renderIcon() : children2)
          })))
        }), this.iconPlacement === "left" && children, !this.text ? h(NBaseWave, {
          ref: "waveElRef",
          clsPrefix: mergedClsPrefix
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__border`,
          style: this.customColorCssVars
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__state-border`,
          style: this.customColorCssVars
        }) : null);
      }
    });
    const commonVariables$e = {
      titleFontSize: "22px"
    };
    function self$I(vars) {
      const {
        borderRadius,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        textColor2,
        textColor1,
        textColorDisabled,
        dividerColor,
        fontWeightStrong,
        primaryColor,
        baseColor,
        hoverColor,
        cardColor,
        modalColor,
        popoverColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$e), {
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        textColor: textColor2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        dayTextColor: textColorDisabled,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        dateColorCurrent: primaryColor,
        dateTextColorCurrent: baseColor,
        cellColorHover: composite(cardColor, hoverColor),
        cellColorHoverModal: composite(modalColor, hoverColor),
        cellColorHoverPopover: composite(popoverColor, hoverColor),
        cellColor: cardColor,
        cellColorModal: modalColor,
        cellColorPopover: popoverColor,
        barColor: primaryColor
      });
    }
    const calendarDark = {
      name: "Calendar",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$I
    };
    const commonVariables$d = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };
    function self$H(vars) {
      const {
        primaryColor,
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        cardColor,
        textColor2,
        textColor1,
        dividerColor,
        fontWeightStrong,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        modalColor,
        boxShadow1,
        popoverColor,
        actionColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$d), {
        lineHeight: lineHeight2,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        colorEmbeddedModal: actionColor,
        colorEmbeddedPopover: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize2,
        fontSizeMedium: fontSize2,
        fontSizeLarge: fontSize2,
        fontSizeHuge: fontSize2,
        boxShadow: boxShadow1,
        borderRadius
      });
    }
    const cardDark = {
      name: "Card",
      common: derived$1,
      self(vars) {
        const commonSelf = self$H(vars);
        const {
          cardColor,
          modalColor,
          popoverColor
        } = vars;
        commonSelf.colorEmbedded = cardColor;
        commonSelf.colorEmbeddedModal = modalColor;
        commonSelf.colorEmbeddedPopover = popoverColor;
        return commonSelf;
      }
    };
    function self$G() {
      return {
        dotSize: "8px",
        dotColor: "rgba(255, 255, 255, .3)",
        dotColorActive: "rgba(255, 255, 255, 1)",
        dotColorFocus: "rgba(255, 255, 255, .5)",
        dotLineWidth: "16px",
        dotLineWidthActive: "24px",
        arrowColor: "#eee"
      };
    }
    const carouselDark = {
      name: "Carousel",
      common: derived$1,
      self: self$G
    };
    const commonVariables$c = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    function self$F(vars) {
      const {
        baseColor,
        inputColorDisabled,
        cardColor,
        modalColor,
        popoverColor,
        textColorDisabled,
        borderColor,
        primaryColor,
        textColor2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadiusSmall,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), {
        labelLineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        textColor: textColor2,
        textColorDisabled
      });
    }
    const checkboxDark = {
      name: "Checkbox",
      common: derived$1,
      self(vars) {
        const {
          cardColor
        } = vars;
        const commonSelf = self$F(vars);
        commonSelf.color = "#0000";
        commonSelf.checkMarkColor = cardColor;
        return commonSelf;
      }
    };
    function self$E(vars) {
      const {
        borderRadius,
        boxShadow2,
        popoverColor,
        textColor2,
        textColor3,
        primaryColor,
        textColorDisabled,
        dividerColor,
        hoverColor,
        fontSizeMedium,
        heightMedium
      } = vars;
      return {
        menuBorderRadius: borderRadius,
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuDividerColor: dividerColor,
        menuHeight: "calc(var(--n-option-height) * 6.6)",
        optionArrowColor: textColor3,
        optionHeight: heightMedium,
        optionFontSize: fontSizeMedium,
        optionColorHover: hoverColor,
        optionTextColor: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorDisabled: textColorDisabled,
        optionCheckMarkColor: primaryColor,
        loadingColor: primaryColor,
        columnWidth: "180px"
      };
    }
    const cascaderDark = {
      name: "Cascader",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        InternalSelection: internalSelectionDark,
        Scrollbar: scrollbarDark,
        Checkbox: checkboxDark,
        Empty: emptyLight
      },
      self: self$E
    };
    const codeDark = {
      name: "Code",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          textColor3
        } = vars;
        return {
          textColor: textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          // extracted from hljs atom-one-dark.scss
          "mono-3": "#5c6370",
          "hue-1": "#56b6c2",
          "hue-2": "#61aeee",
          "hue-3": "#c678dd",
          "hue-4": "#98c379",
          "hue-5": "#e06c75",
          "hue-5-2": "#be5046",
          "hue-6": "#d19a66",
          "hue-6-2": "#e6c07b",
          // line-number styles
          lineNumberTextColor: textColor3
        };
      }
    };
    function self$D(vars) {
      const {
        fontWeight,
        textColor1,
        textColor2,
        textColorDisabled,
        dividerColor,
        fontSize: fontSize2
      } = vars;
      return {
        titleFontSize: fontSize2,
        titleFontWeight: fontWeight,
        dividerColor,
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        fontSize: fontSize2,
        textColor: textColor2,
        arrowColor: textColor2,
        arrowColorDisabled: textColorDisabled,
        itemMargin: "16px 0 0 0",
        titlePadding: "16px 0 0 0"
      };
    }
    const collapseDark = {
      name: "Collapse",
      common: derived$1,
      self: self$D
    };
    function self$C(vars) {
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut2
      } = vars;
      return {
        bezier: cubicBezierEaseInOut2
      };
    }
    const collapseTransitionDark = {
      name: "CollapseTransition",
      common: derived$1,
      self: self$C
    };
    function self$B(vars) {
      const {
        fontSize: fontSize2,
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        borderColor,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      } = vars;
      return {
        panelFontSize: fontSize2,
        boxShadow: boxShadow2,
        color: popoverColor,
        textColor: textColor2,
        borderRadius,
        border: `1px solid ${borderColor}`,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      };
    }
    const colorPickerDark = {
      name: "ColorPicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self: self$B
    };
    const configProviderProps = {
      abstract: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: String,
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
        type: String,
        default: "div"
      },
      hljs: Object,
      katex: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      styleMountTarget: Object,
      inlineThemeDisabled: {
        type: Boolean,
        default: void 0
      },
      // deprecated
      as: {
        type: String,
        validator: () => {
          warn("config-provider", "`as` is deprecated, please use `tag` instead.");
          return true;
        },
        default: void 0
      }
    };
    const NConfigProvider = /* @__PURE__ */ defineComponent({
      name: "ConfigProvider",
      alias: ["App"],
      props: configProviderProps,
      setup(props) {
        const NConfigProvider2 = inject(configProviderInjectionKey, null);
        const mergedThemeRef = computed(() => {
          const {
            theme
          } = props;
          if (theme === null) return void 0;
          const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
          return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = computed(() => {
          const {
            themeOverrides
          } = props;
          if (themeOverrides === null) return void 0;
          if (themeOverrides === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
          } else {
            const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            if (inheritedThemeOverrides === void 0) {
              return themeOverrides;
            } else {
              return merge({}, inheritedThemeOverrides, themeOverrides);
            }
          }
        });
        const mergedNamespaceRef = useMemo(() => {
          const {
            namespace: namespace2
          } = props;
          return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
        });
        const mergedBorderedRef = useMemo(() => {
          const {
            bordered
          } = props;
          return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
        });
        const mergedIconsRef = computed(() => {
          const {
            icons
          } = props;
          return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = computed(() => {
          const {
            componentOptions
          } = props;
          if (componentOptions !== void 0) return componentOptions;
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = computed(() => {
          const {
            clsPrefix
          } = props;
          if (clsPrefix !== void 0) return clsPrefix;
          if (NConfigProvider2) return NConfigProvider2.mergedClsPrefixRef.value;
          return defaultClsPrefix;
        });
        const mergedRtlRef = computed(() => {
          var _a2;
          const {
            rtl
          } = props;
          if (rtl === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
          }
          const rtlEnabledState = {};
          for (const rtlInfo of rtl) {
            rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
            (_a2 = rtlInfo.peers) === null || _a2 === void 0 ? void 0 : _a2.forEach((peerRtlInfo) => {
              if (!(peerRtlInfo.name in rtlEnabledState)) {
                rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
              }
            });
          }
          return rtlEnabledState;
        });
        const mergedBreakpointsRef = computed(() => {
          return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
        });
        const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
        const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
        const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
        const mergedThemeHashRef = computed(() => {
          const {
            value: theme
          } = mergedThemeRef;
          const {
            value: mergedThemeOverrides
          } = mergedThemeOverridesRef;
          const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
          const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
          if (themeName) {
            if (hasThemeOverrides) {
              return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
            }
            return themeName;
          } else {
            if (hasThemeOverrides) {
              return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
            }
            return "";
          }
        });
        provide(configProviderInjectionKey, {
          mergedThemeHashRef,
          mergedBreakpointsRef,
          mergedRtlRef,
          mergedIconsRef,
          mergedComponentPropsRef,
          mergedBorderedRef,
          mergedNamespaceRef,
          mergedClsPrefixRef,
          mergedLocaleRef: computed(() => {
            const {
              locale
            } = props;
            if (locale === null) return void 0;
            return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
          }),
          mergedDateLocaleRef: computed(() => {
            const {
              dateLocale
            } = props;
            if (dateLocale === null) return void 0;
            return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
          }),
          mergedHljsRef: computed(() => {
            const {
              hljs
            } = props;
            return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
          }),
          mergedKatexRef: computed(() => {
            const {
              katex
            } = props;
            return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
          }),
          mergedThemeRef,
          mergedThemeOverridesRef,
          inlineThemeDisabled: inlineThemeDisabled || false,
          preflightStyleDisabled: preflightStyleDisabled || false,
          styleMountTarget
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedNamespace: mergedNamespaceRef,
          mergedTheme: mergedThemeRef,
          mergedThemeOverrides: mergedThemeOverridesRef
        };
      },
      render() {
        var _a2, _b2, _c2, _d2;
        return !this.abstract ? h(this.as || this.tag, {
          class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
        }, (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) : (_d2 = (_c2 = this.$slots).default) === null || _d2 === void 0 ? void 0 : _d2.call(_c2);
      }
    });
    const popselect = {
      name: "Popselect",
      common: derived$1,
      peers: {
        Popover: popoverDark,
        InternalSelectMenu: internalSelectMenuDark
      }
    };
    function self$A(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectDark = {
      name: "Select",
      common: derived$1,
      peers: {
        InternalSelection: internalSelectionDark,
        InternalSelectMenu: internalSelectMenuDark
      },
      self: self$A
    };
    const commonVariables$b = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };
    function self$z(vars) {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        // item font size
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        // item size
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), {
        buttonColor: "#0000",
        buttonColorHover: "#0000",
        buttonColorPressed: "#0000",
        buttonBorder: `1px solid ${borderColor}`,
        buttonBorderHover: `1px solid ${borderColor}`,
        buttonBorderPressed: `1px solid ${borderColor}`,
        buttonIconColor: textColor2,
        buttonIconColorHover: textColor2,
        buttonIconColorPressed: textColor2,
        itemTextColor: textColor2,
        itemTextColorHover: primaryColorHover,
        itemTextColorPressed: primaryColorPressed,
        itemTextColorActive: primaryColor,
        itemTextColorDisabled: textColorDisabled,
        itemColor: "#0000",
        itemColorHover: "#0000",
        itemColorPressed: "#0000",
        itemColorActive: "#0000",
        itemColorActiveHover: "#0000",
        itemColorDisabled: inputColorDisabled,
        itemBorder: "1px solid #0000",
        itemBorderHover: "1px solid #0000",
        itemBorderPressed: "1px solid #0000",
        itemBorderActive: `1px solid ${primaryColor}`,
        itemBorderDisabled: `1px solid ${borderColor}`,
        itemBorderRadius: borderRadius,
        itemSizeSmall: heightTiny,
        itemSizeMedium: heightSmall,
        itemSizeLarge: heightMedium,
        itemFontSizeSmall: fontSizeTiny,
        itemFontSizeMedium: fontSizeSmall,
        itemFontSizeLarge: fontSizeMedium,
        jumperFontSizeSmall: fontSizeTiny,
        jumperFontSizeMedium: fontSizeSmall,
        jumperFontSizeLarge: fontSizeMedium,
        jumperTextColor: textColor2,
        jumperTextColorDisabled: textColorDisabled
      });
    }
    const paginationDark = {
      name: "Pagination",
      common: derived$1,
      peers: {
        Select: selectDark,
        Input: inputDark,
        Popselect: popselect
      },
      self(vars) {
        const {
          primaryColor,
          opacity3
        } = vars;
        const borderColorActive = changeColor(primaryColor, {
          alpha: Number(opacity3)
        });
        const commonSelf = self$z(vars);
        commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
        commonSelf.itemBorderDisabled = "1px solid #0000";
        return commonSelf;
      }
    };
    const commonVariables$a = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };
    function self$y(vars) {
      const {
        primaryColor,
        textColor2,
        dividerColor,
        hoverColor,
        popoverColor,
        invertedColor,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        textColor3,
        opacityDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), {
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        // non-inverted
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        groupHeaderTextColor: textColor3,
        // inverted
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      });
    }
    const dropdownDark = {
      name: "Dropdown",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          primaryColorSuppl,
          primaryColor,
          popoverColor
        } = vars;
        const commonSelf = self$y(vars);
        commonSelf.colorInverted = popoverColor;
        commonSelf.optionColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.optionColorActiveInverted = primaryColorSuppl;
        commonSelf.optionColorHoverInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const commonVars$9 = {
      padding: "8px 14px"
    };
    const tooltipDark = {
      name: "Tooltip",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          boxShadow2,
          popoverColor,
          textColor2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$9), {
          borderRadius,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2
        });
      }
    };
    const ellipsisDark = {
      name: "Ellipsis",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      }
    };
    const commonVariables$9 = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const radioDark = {
      name: "Radio",
      common: derived$1,
      self(vars) {
        const {
          borderColor,
          primaryColor,
          baseColor,
          textColorDisabled,
          inputColorDisabled,
          textColor2,
          opacityDisabled,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightSmall,
          heightMedium,
          heightLarge,
          lineHeight: lineHeight2
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$9), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: "#0000",
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: primaryColor,
          buttonColor: "#0000",
          buttonColorActive: primaryColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: baseColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      }
    };
    function self$x(vars) {
      const {
        borderColor,
        primaryColor,
        baseColor,
        textColorDisabled,
        inputColorDisabled,
        textColor2,
        opacityDisabled,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightSmall,
        heightMedium,
        heightLarge,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), {
        labelLineHeight: lineHeight2,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        colorActive: "#0000",
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      });
    }
    const radioLight = {
      common: derived,
      self: self$x
    };
    const commonVariables$8 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      resizableContainerSize: "8px",
      resizableSize: "2px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };
    function self$w(vars) {
      const {
        cardColor,
        modalColor,
        popoverColor,
        textColor2,
        textColor1,
        tableHeaderColor,
        tableColorHover,
        iconColor,
        primaryColor,
        fontWeightStrong,
        borderRadius,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor,
        heightSmall,
        opacityDisabled,
        tableColorStriped
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), {
        actionDividerColor: dividerColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorSorting: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        thColorSorting: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        // modal
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorSortingModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        thColorSortingModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        // popover
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorSortingPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        thColorSortingPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        // loading
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      });
    }
    const dataTableDark = {
      name: "DataTable",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Checkbox: checkboxDark,
        Radio: radioDark,
        Pagination: paginationDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark,
        Popover: popoverDark,
        Ellipsis: ellipsisDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const commonSelf = self$w(vars);
        commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
        commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
        return commonSelf;
      }
    };
    const style$5 = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM$1("checked", [cE$1("dot", `
 background-color: var(--n-color-active);
 `)]), cE$1("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE$1("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM$1("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE$1("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM$1("disabled", `
 cursor: not-allowed;
 `, [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM$1("checked", `
 opacity: 1;
 `)]), cE$1("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
    const radioBaseProps = {
      name: String,
      value: {
        type: [String, Number, Boolean],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      // deprecated
      checkedValue: {
        type: Boolean,
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");
    function setup(props) {
      const NRadioGroup2 = inject(radioGroupInjectionKey, null);
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const {
            size: size2
          } = props;
          if (size2 !== void 0) return size2;
          if (NRadioGroup2) {
            const {
              mergedSizeRef: {
                value: mergedSize
              }
            } = NRadioGroup2;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            return NFormItem2.mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          if (props.disabled) return true;
          if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value) return true;
          if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value) return true;
          return false;
        }
      });
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup2) return NRadioGroup2.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const {
          name
        } = props;
        if (name !== void 0) return name;
        if (NRadioGroup2) return NRadioGroup2.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
        if (NRadioGroup2) {
          const {
            doUpdateValue
          } = NRadioGroup2;
          const {
            value
          } = props;
          call(doUpdateValue, value);
        } else {
          const {
            onUpdateChecked,
            "onUpdate:checked": _onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (onUpdateChecked) call(onUpdateChecked, true);
          if (_onUpdateChecked) call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }
      function toggle() {
        if (mergedDisabledRef.value) return;
        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }
      function handleRadioInputChange() {
        toggle();
        if (inputRef.value) {
          inputRef.value.checked = renderSafeCheckedRef.value;
        }
      }
      function handleRadioInputBlur() {
        focusRef.value = false;
      }
      function handleRadioInputFocus() {
        focusRef.value = true;
      }
      return {
        mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }
    const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
    const NRadio = /* @__PURE__ */ defineComponent({
      name: "Radio",
      props: radioProps,
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme("Radio", "-radio", style$5, radioLight, props, radio.mergedClsPrefix);
        const cssVarsRef = computed(() => {
          const {
            mergedSize: {
              value: size2
            }
          } = radio;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              boxShadow,
              boxShadowActive,
              boxShadowDisabled,
              boxShadowFocus,
              boxShadowHover,
              color,
              colorDisabled,
              colorActive,
              textColor,
              textColorDisabled,
              dotColorActive,
              dotColorDisabled,
              labelPadding,
              labelLineHeight,
              labelFontWeight,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("radioSize", size2)]: radioSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize2,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          onRender,
          label
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h("label", {
          class: [`${mergedClsPrefix}-radio`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-radio--rtl`, this.mergedDisabled && `${mergedClsPrefix}-radio--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio--checked`, this.focus && `${mergedClsPrefix}-radio--focus`],
          style: this.cssVars
        }, h("input", {
          ref: "inputRef",
          type: "radio",
          class: `${mergedClsPrefix}-radio-input`,
          value: this.value,
          name: this.mergedName,
          checked: this.renderSafeChecked,
          disabled: this.mergedDisabled,
          onChange: this.handleRadioInputChange,
          onFocus: this.handleRadioInputFocus,
          onBlur: this.handleRadioInputBlur
        }), h("div", {
          class: `${mergedClsPrefix}-radio__dot-wrapper`
        }, " ", h("div", {
          class: [`${mergedClsPrefix}-radio__dot`, this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`]
        })), resolveWrappedSlot($slots.default, (children) => {
          if (!children && !label) return null;
          return h("div", {
            ref: "labelRef",
            class: `${mergedClsPrefix}-radio__label`
          }, children || label);
        }));
      }
    });
    const style$4 = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE$1("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM$1("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM$1("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM$1("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE$1("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE$1("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM$1("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM$1("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
    function mapSlot(defaultSlot, value, clsPrefix) {
      var _a2;
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = (_a2 = wrappedInstance.type) === null || _a2 === void 0 ? void 0 : _a2.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(h("div", {
            class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
          }), wrappedInstance);
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), {
      name: String,
      value: [String, Number, Boolean],
      defaultValue: {
        type: [String, Number, Boolean],
        default: null
      },
      size: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    });
    const NRadioGroup = /* @__PURE__ */ defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = ref(null);
        const {
          mergedSizeRef,
          mergedDisabledRef,
          nTriggerFormChange,
          nTriggerFormInput,
          nTriggerFormBlur,
          nTriggerFormFocus
        } = useFormItem(props);
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Radio", "-radio-group", style$4, radioLight, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue
          } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormBlur();
        }
        provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              buttonBorderColor,
              buttonBorderColorActive,
              buttonBorderRadius,
              buttonBoxShadow,
              buttonBoxShadowFocus,
              buttonBoxShadowHover,
              buttonColor,
              buttonColorActive,
              buttonTextColor,
              buttonTextColorActive,
              buttonTextColorHover,
              opacityDisabled,
              [createKey("buttonHeight", size2)]: height,
              [createKey("fontSize", size2)]: fontSize2
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color": buttonColor,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a2;
        const {
          mergedValue,
          mergedClsPrefix,
          handleFocusin,
          handleFocusout
        } = this;
        const {
          children,
          isButtonGroup
        } = mapSlot(flatten(getSlot(this)), mergedValue, mergedClsPrefix);
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        return h("div", {
          onFocusin: handleFocusin,
          onFocusout: handleFocusout,
          ref: "selfElRef",
          class: [`${mergedClsPrefix}-radio-group`, this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`, this.themeClass, isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`],
          style: this.cssVars
        }, children);
      }
    });
    function self$v(vars) {
      const {
        textColorBase,
        opacity1,
        opacity2,
        opacity3,
        opacity4,
        opacity5
      } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    }
    const iconDark$1 = {
      name: "Icon",
      common: derived$1,
      self: self$v
    };
    const commonVars$8 = {
      itemFontSize: "12px",
      itemHeight: "36px",
      itemWidth: "52px",
      panelActionPadding: "8px 0"
    };
    function self$u(vars) {
      const {
        popoverColor,
        textColor2,
        primaryColor,
        hoverColor,
        dividerColor,
        opacityDisabled,
        boxShadow2,
        borderRadius,
        iconColor,
        iconColorDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVars$8), {
        panelColor: popoverColor,
        panelBoxShadow: boxShadow2,
        panelDividerColor: dividerColor,
        itemTextColor: textColor2,
        itemTextColorActive: primaryColor,
        itemColorHover: hoverColor,
        itemOpacityDisabled: opacityDisabled,
        itemBorderRadius: borderRadius,
        borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const timePickerDark = {
      name: "TimePicker",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Button: buttonDark,
        Input: inputDark
      },
      self: self$u
    };
    const commonVars$7 = {
      itemSize: "24px",
      itemCellWidth: "38px",
      itemCellHeight: "32px",
      scrollItemWidth: "80px",
      scrollItemHeight: "40px",
      panelExtraFooterPadding: "8px 12px",
      panelActionPadding: "8px 12px",
      calendarTitlePadding: "0",
      calendarTitleHeight: "28px",
      arrowSize: "14px",
      panelHeaderPadding: "8px 12px",
      calendarDaysHeight: "32px",
      calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
      // type
      calendarLeftPaddingDate: "6px 12px 4px 12px",
      calendarLeftPaddingDatetime: "4px 12px",
      calendarLeftPaddingDaterange: "6px 12px 4px 12px",
      calendarLeftPaddingDatetimerange: "4px 12px",
      calendarLeftPaddingMonth: "0",
      // TODO: make it actually effective
      calendarLeftPaddingYear: "0",
      calendarLeftPaddingQuarter: "0",
      calendarLeftPaddingMonthrange: "0",
      calendarLeftPaddingQuarterrange: "0",
      calendarLeftPaddingYearrange: "0",
      calendarLeftPaddingWeek: "6px 12px 4px 12px",
      calendarRightPaddingDate: "6px 12px 4px 12px",
      calendarRightPaddingDatetime: "4px 12px",
      calendarRightPaddingDaterange: "6px 12px 4px 12px",
      calendarRightPaddingDatetimerange: "4px 12px",
      calendarRightPaddingMonth: "0",
      calendarRightPaddingYear: "0",
      calendarRightPaddingQuarter: "0",
      calendarRightPaddingMonthrange: "0",
      calendarRightPaddingQuarterrange: "0",
      calendarRightPaddingYearrange: "0",
      calendarRightPaddingWeek: "0"
    };
    function self$t(vars) {
      const {
        hoverColor,
        fontSize: fontSize2,
        textColor2,
        textColorDisabled,
        popoverColor,
        primaryColor,
        borderRadiusSmall,
        iconColor,
        iconColorDisabled,
        textColor1,
        dividerColor,
        boxShadow2,
        borderRadius,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVars$7), {
        itemFontSize: fontSize2,
        calendarDaysFontSize: fontSize2,
        calendarTitleFontSize: fontSize2,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemTextColorActive: popoverColor,
        itemTextColorCurrent: primaryColor,
        itemColorIncluded: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorHover: hoverColor,
        itemColorDisabled: hoverColor,
        itemColorActive: primaryColor,
        itemBorderRadius: borderRadiusSmall,
        panelColor: popoverColor,
        panelTextColor: textColor2,
        arrowColor: iconColor,
        calendarTitleTextColor: textColor1,
        calendarTitleColorHover: hoverColor,
        calendarDaysTextColor: textColor2,
        panelHeaderDividerColor: dividerColor,
        calendarDaysDividerColor: dividerColor,
        calendarDividerColor: dividerColor,
        panelActionDividerColor: dividerColor,
        panelBoxShadow: boxShadow2,
        panelBorderRadius: borderRadius,
        calendarTitleFontWeight: fontWeightStrong,
        scrollItemBorderRadius: borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const datePickerDark = {
      name: "DatePicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        TimePicker: timePickerDark,
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          popoverColor,
          hoverColor,
          primaryColor
        } = vars;
        const commonSelf = self$t(vars);
        commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
        commonSelf.itemColorIncluded = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorHover = composite(popoverColor, hoverColor);
        return commonSelf;
      }
    };
    const commonVariables$7 = {
      thPaddingBorderedSmall: "8px 12px",
      thPaddingBorderedMedium: "12px 16px",
      thPaddingBorderedLarge: "16px 24px",
      thPaddingSmall: "0",
      thPaddingMedium: "0",
      thPaddingLarge: "0",
      tdPaddingBorderedSmall: "8px 12px",
      tdPaddingBorderedMedium: "12px 16px",
      tdPaddingBorderedLarge: "16px 24px",
      tdPaddingSmall: "0 0 8px 0",
      tdPaddingMedium: "0 0 12px 0",
      tdPaddingLarge: "0 0 16px 0"
    };
    function self$s(vars) {
      const {
        tableHeaderColor,
        textColor2,
        textColor1,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), {
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        titleTextColor: textColor1,
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        tdTextColor: textColor2,
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius
      });
    }
    const descriptionsDark = {
      name: "Descriptions",
      common: derived$1,
      self: self$s
    };
    const commonVars$6 = {
      titleFontSize: "18px",
      padding: "16px 28px 20px 28px",
      iconSize: "28px",
      actionSpace: "12px",
      contentMargin: "8px 0 16px 0",
      iconMargin: "0 4px 0 0",
      iconMarginIconTop: "4px 0 8px 0",
      closeSize: "22px",
      closeIconSize: "18px",
      closeMargin: "20px 26px 0 0",
      closeMarginIconTop: "10px 16px 0 0"
    };
    function self$r(vars) {
      const {
        textColor1,
        textColor2,
        modalColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        primaryColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$6), {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        border: `1px solid ${dividerColor}`,
        titleTextColor: textColor1,
        textColor: textColor2,
        color: modalColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        iconColor: primaryColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        borderRadius,
        titleFontWeight: fontWeightStrong
      });
    }
    const dialogDark = {
      name: "Dialog",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$r
    };
    function self$q(vars) {
      const {
        modalColor,
        textColor2,
        boxShadow3
      } = vars;
      return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
      };
    }
    const modalDark = {
      name: "Modal",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Dialog: dialogDark,
        Card: cardDark
      },
      self: self$q
    };
    const loadingBarDark = {
      name: "LoadingBar",
      common: derived$1,
      self(vars) {
        const {
          primaryColor
        } = vars;
        return {
          colorError: "red",
          colorLoading: primaryColor,
          height: "2px"
        };
      }
    };
    const commonVariables$6 = {
      margin: "0 0 8px 0",
      padding: "10px 20px",
      maxWidth: "720px",
      minWidth: "420px",
      iconMargin: "0 10px 0 0",
      closeMargin: "0 0 0 10px",
      closeSize: "20px",
      closeIconSize: "16px",
      iconSize: "20px",
      fontSize: "14px"
    };
    function self$p(vars) {
      const {
        textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        infoColor,
        successColor,
        errorColor,
        warningColor,
        popoverColor,
        boxShadow2,
        primaryColor,
        lineHeight: lineHeight2,
        borderRadius,
        closeColorHover,
        closeColorPressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$6), {
        closeBorderRadius: borderRadius,
        textColor: textColor2,
        textColorInfo: textColor2,
        textColorSuccess: textColor2,
        textColorError: textColor2,
        textColorWarning: textColor2,
        textColorLoading: textColor2,
        color: popoverColor,
        colorInfo: popoverColor,
        colorSuccess: popoverColor,
        colorError: popoverColor,
        colorWarning: popoverColor,
        colorLoading: popoverColor,
        boxShadow: boxShadow2,
        boxShadowInfo: boxShadow2,
        boxShadowSuccess: boxShadow2,
        boxShadowError: boxShadow2,
        boxShadowWarning: boxShadow2,
        boxShadowLoading: boxShadow2,
        iconColor: textColor2,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        iconColorLoading: primaryColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        closeColorHoverLoading: closeColorHover,
        closeColorPressedLoading: closeColorPressed,
        closeIconColorLoading: closeIconColor,
        closeIconColorHoverLoading: closeIconColorHover,
        closeIconColorPressedLoading: closeIconColorPressed,
        loadingColor: primaryColor,
        lineHeight: lineHeight2,
        borderRadius
      });
    }
    const messageDark = {
      name: "Message",
      common: derived$1,
      self: self$p
    };
    const commonVars$5 = {
      closeMargin: "16px 12px",
      closeSize: "20px",
      closeIconSize: "16px",
      width: "365px",
      padding: "16px",
      titleFontSize: "16px",
      metaFontSize: "12px",
      descriptionFontSize: "12px"
    };
    function self$o(vars) {
      const {
        textColor2,
        successColor,
        infoColor,
        warningColor,
        errorColor,
        popoverColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        textColor1,
        textColor3,
        borderRadius,
        fontWeightStrong,
        boxShadow2,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$5), {
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        headerFontWeight: fontWeightStrong,
        iconColor: textColor2,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        color: popoverColor,
        textColor: textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        headerTextColor: textColor1,
        descriptionTextColor: textColor3,
        actionTextColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const notificationDark = {
      name: "Notification",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$o
    };
    function self$n(vars) {
      const {
        textColor1,
        dividerColor,
        fontWeightStrong
      } = vars;
      return {
        textColor: textColor1,
        color: dividerColor,
        fontWeight: fontWeightStrong
      };
    }
    const dividerDark = {
      name: "Divider",
      common: derived$1,
      self: self$n
    };
    function self$m(vars) {
      const {
        modalColor,
        textColor1,
        textColor2,
        boxShadow3,
        lineHeight: lineHeight2,
        fontWeightStrong,
        dividerColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderRadius,
        primaryColorHover
      } = vars;
      return {
        bodyPadding: "16px 24px",
        borderRadius,
        headerPadding: "16px 24px",
        footerPadding: "16px 24px",
        color: modalColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        titleFontSize: "18px",
        titleFontWeight: fontWeightStrong,
        boxShadow: boxShadow3,
        lineHeight: lineHeight2,
        headerBorderBottom: `1px solid ${dividerColor}`,
        footerBorderTop: `1px solid ${dividerColor}`,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeSize: "22px",
        closeIconSize: "18px",
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        resizableTriggerColorHover: primaryColorHover
      };
    }
    const drawerLight = createTheme({
      name: "Drawer",
      common: derived,
      peers: {
        Scrollbar: scrollbarLight
      },
      self: self$m
    });
    const drawerDark = {
      name: "Drawer",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$m
    };
    const NDrawerBodyWrapper = /* @__PURE__ */ defineComponent({
      name: "NDrawerContent",
      inheritAttrs: false,
      props: {
        blockScroll: Boolean,
        show: {
          type: Boolean,
          default: void 0
        },
        displayDirective: {
          type: String,
          required: true
        },
        placement: {
          type: String,
          required: true
        },
        contentClass: String,
        contentStyle: [Object, String],
        nativeScrollbar: {
          type: Boolean,
          required: true
        },
        scrollbarProps: Object,
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          required: true
        },
        maxWidth: Number,
        maxHeight: Number,
        minWidth: Number,
        minHeight: Number,
        resizable: Boolean,
        onClickoutside: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const displayedRef = ref(!!props.show);
        const bodyRef = ref(null);
        const NDrawer2 = inject(drawerInjectionKey);
        let startPosition = 0;
        let memoizedBodyStyleCursor = "";
        let hoverTimerId = null;
        const isHoverOnResizeTriggerRef = ref(false);
        const isDraggingRef = ref(false);
        const isVertical = computed(() => {
          return props.placement === "top" || props.placement === "bottom";
        });
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
        const handleBodyMouseleave = handleBodyMouseup;
        const handleMousedownResizeTrigger = (e) => {
          isDraggingRef.value = true;
          startPosition = isVertical.value ? e.clientY : e.clientX;
          memoizedBodyStyleCursor = document.body.style.cursor;
          document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
          document.body.addEventListener("mousemove", handleBodyMousemove);
          document.body.addEventListener("mouseleave", handleBodyMouseleave);
          document.body.addEventListener("mouseup", handleBodyMouseup);
        };
        const handleMouseenterResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          if (isDraggingRef.value) {
            isHoverOnResizeTriggerRef.value = true;
          } else {
            hoverTimerId = window.setTimeout(() => {
              isHoverOnResizeTriggerRef.value = true;
            }, 300);
          }
        };
        const handleMouseleaveResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          isHoverOnResizeTriggerRef.value = false;
        };
        const {
          doUpdateHeight,
          doUpdateWidth
        } = NDrawer2;
        const regulateWidth = (size2) => {
          const {
            maxWidth
          } = props;
          if (maxWidth && size2 > maxWidth) return maxWidth;
          const {
            minWidth
          } = props;
          if (minWidth && size2 < minWidth) return minWidth;
          return size2;
        };
        const regulateHeight = (size2) => {
          const {
            maxHeight
          } = props;
          if (maxHeight && size2 > maxHeight) return maxHeight;
          const {
            minHeight
          } = props;
          if (minHeight && size2 < minHeight) return minHeight;
          return size2;
        };
        function handleBodyMousemove(e) {
          var _a2, _b2;
          if (isDraggingRef.value) {
            if (isVertical.value) {
              let height = ((_a2 = bodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
              const increment = startPosition - e.clientY;
              height += props.placement === "bottom" ? increment : -increment;
              height = regulateHeight(height);
              doUpdateHeight(height);
              startPosition = e.clientY;
            } else {
              let width = ((_b2 = bodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.offsetWidth) || 0;
              const increment = startPosition - e.clientX;
              width += props.placement === "right" ? increment : -increment;
              width = regulateWidth(width);
              doUpdateWidth(width);
              startPosition = e.clientX;
            }
          }
        }
        function handleBodyMouseup() {
          if (isDraggingRef.value) {
            startPosition = 0;
            isDraggingRef.value = false;
            document.body.style.cursor = memoizedBodyStyleCursor;
            document.body.removeEventListener("mousemove", handleBodyMousemove);
            document.body.removeEventListener("mouseup", handleBodyMouseup);
            document.body.removeEventListener("mouseleave", handleBodyMouseleave);
          }
        }
        watchEffect(() => {
          if (props.show) displayedRef.value = true;
        });
        watch(() => props.show, (value) => {
          if (!value) {
            handleBodyMouseup();
          }
        });
        onBeforeUnmount(() => {
          handleBodyMouseup();
        });
        const bodyDirectivesRef = computed(() => {
          const {
            show
          } = props;
          const directives = [[vShow, show]];
          if (!props.showMask) {
            directives.push([clickoutside, props.onClickoutside, void 0, {
              capture: true
            }]);
          }
          return directives;
        });
        function handleAfterLeave() {
          var _a2;
          displayedRef.value = false;
          (_a2 = props.onAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
        provide(drawerBodyInjectionKey, bodyRef);
        provide(popoverBodyInjectionKey, null);
        provide(modalBodyInjectionKey, null);
        return {
          bodyRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef,
          isMounted: NDrawer2.isMountedRef,
          mergedTheme: NDrawer2.mergedThemeRef,
          displayed: displayedRef,
          transitionName: computed(() => {
            return {
              right: "slide-in-from-right-transition",
              left: "slide-in-from-left-transition",
              top: "slide-in-from-top-transition",
              bottom: "slide-in-from-bottom-transition"
            }[props.placement];
          }),
          handleAfterLeave,
          bodyDirectives: bodyDirectivesRef,
          handleMousedownResizeTrigger,
          handleMouseenterResizeTrigger,
          handleMouseleaveResizeTrigger,
          isDragging: isDraggingRef,
          isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix
        } = this;
        return this.displayDirective === "show" || this.displayed || this.show ? withDirectives(
          /* Keep the wrapper dom. Make sure the drawer has a host.
          Nor the detached content will disappear without transition */
          h("div", {
            role: "none"
          }, h(FocusTrap, {
            disabled: !this.showMask || !this.trapFocus,
            active: this.show,
            autoFocus: this.autoFocus,
            onEsc: this.onEsc
          }, {
            default: () => h(Transition, {
              name: this.transitionName,
              appear: this.isMounted,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.handleAfterLeave
            }, {
              default: () => withDirectives(h("div", mergeProps(this.$attrs, {
                role: "dialog",
                ref: "bodyRef",
                "aria-modal": "true",
                class: [
                  `${mergedClsPrefix}-drawer`,
                  this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                  `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                  /**
                   * When the mouse is pressed to resize the drawer,
                   * disable text selection
                   */
                  this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                  this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                ]
              }), [this.resizable ? h("div", {
                class: [`${mergedClsPrefix}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`],
                onMouseenter: this.handleMouseenterResizeTrigger,
                onMouseleave: this.handleMouseleaveResizeTrigger,
                onMousedown: this.handleMousedownResizeTrigger
              }) : null, this.nativeScrollbar ? h("div", {
                class: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                style: this.contentStyle,
                role: "none"
              }, $slots) : h(Scrollbar, Object.assign({}, this.scrollbarProps, {
                contentStyle: this.contentStyle,
                contentClass: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                theme: this.mergedTheme.peers.Scrollbar,
                themeOverrides: this.mergedTheme.peerOverrides.Scrollbar
              }), $slots)]), this.bodyDirectives)
            })
          })),
          [[vShow, this.displayDirective === "if" || this.displayed || this.show]]
        ) : null;
      }
    });
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$3,
      cubicBezierEaseOut: cubicBezierEaseOut$3
    } = commonVariables$n;
    function slideInFromBottomTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-bottom"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$3}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$2,
      cubicBezierEaseOut: cubicBezierEaseOut$2
    } = commonVariables$n;
    function slideInFromLeftTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-left"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$2}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(-100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$1,
      cubicBezierEaseOut: cubicBezierEaseOut$1
    } = commonVariables$n;
    function slideInFromRightTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-right"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$1}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(100%)"
      })];
    }
    const {
      cubicBezierEaseIn,
      cubicBezierEaseOut
    } = commonVariables$n;
    function slideInFromTopTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-top"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(-100%)"
      })];
    }
    const style$3 = c([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM$1("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM$1("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE$1("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM$1("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM$1("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE$1("main", `
 flex: 1;
 `), cE$1("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM$1("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM$1("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM$1("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM$1("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c("body", [c(">", [cB("drawer-container", `
 position: fixed;
 `)])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c("> *", `
 pointer-events: all;
 `)]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM$1("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
      enterDuration: "0.2s",
      leaveDuration: "0.2s",
      enterCubicBezier: "var(--n-bezier-in)",
      leaveCubicBezier: "var(--n-bezier-out)"
    })])]);
    const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
      show: Boolean,
      width: [Number, String],
      height: [Number, String],
      placement: {
        type: String,
        default: "right"
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        default: true
      },
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      onMaskClick: Function,
      scrollbarProps: Object,
      contentClass: String,
      contentStyle: [Object, String],
      trapFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: {
        type: Boolean,
        default: true
      },
      maxWidth: Number,
      maxHeight: Number,
      minWidth: Number,
      minHeight: Number,
      resizable: Boolean,
      defaultWidth: {
        type: [Number, String],
        default: 251
      },
      defaultHeight: {
        type: [Number, String],
        default: 251
      },
      onUpdateWidth: [Function, Array],
      onUpdateHeight: [Function, Array],
      "onUpdate:width": [Function, Array],
      "onUpdate:height": [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      /** @deprecated */
      drawerStyle: [String, Object],
      drawerClass: String,
      target: null,
      onShow: Function,
      onHide: Function
    });
    const NDrawer = /* @__PURE__ */ defineComponent({
      name: "Drawer",
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const isMountedRef = isMounted();
        const themeRef = useTheme("Drawer", "-drawer", style$3, drawerLight, props, mergedClsPrefixRef);
        const uncontrolledWidthRef = ref(props.defaultWidth);
        const uncontrolledHeightRef = ref(props.defaultHeight);
        const mergedWidthRef = useMergedState(toRef(props, "width"), uncontrolledWidthRef);
        const mergedHeightRef = useMergedState(toRef(props, "height"), uncontrolledHeightRef);
        const styleWidthRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "top" || placement === "bottom") return "";
          return formatLength(mergedWidthRef.value);
        });
        const styleHeightRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "left" || placement === "right") return "";
          return formatLength(mergedHeightRef.value);
        });
        const doUpdateWidth = (value) => {
          const {
            onUpdateWidth,
            "onUpdate:width": _onUpdateWidth
          } = props;
          if (onUpdateWidth) call(onUpdateWidth, value);
          if (_onUpdateWidth) call(_onUpdateWidth, value);
          uncontrolledWidthRef.value = value;
        };
        const doUpdateHeight = (value) => {
          const {
            onUpdateHeight,
            "onUpdate:width": _onUpdateHeight
          } = props;
          if (onUpdateHeight) call(onUpdateHeight, value);
          if (_onUpdateHeight) call(_onUpdateHeight, value);
          uncontrolledHeightRef.value = value;
        };
        const mergedBodyStyleRef = computed(() => {
          return [{
            width: styleWidthRef.value,
            height: styleHeightRef.value
          }, props.drawerStyle || ""];
        });
        function handleMaskClick(e) {
          const {
            onMaskClick,
            maskClosable
          } = props;
          if (maskClosable) {
            doUpdateShow(false);
          }
          if (onMaskClick) onMaskClick(e);
        }
        function handleOutsideClick(e) {
          handleMaskClick(e);
        }
        const isComposingRef2 = useIsComposing();
        function handleEsc(e) {
          var _a2;
          (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props);
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            if (!isComposingRef2.value) {
              doUpdateShow(false);
            }
          }
        }
        function doUpdateShow(show) {
          const {
            onHide,
            onUpdateShow,
            "onUpdate:show": _onUpdateShow
          } = props;
          if (onUpdateShow) call(onUpdateShow, show);
          if (_onUpdateShow) call(_onUpdateShow, show);
          if (onHide && !show) call(onHide, show);
        }
        provide(drawerInjectionKey, {
          isMountedRef,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          doUpdateShow,
          doUpdateHeight,
          doUpdateWidth
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseIn: cubicBezierEaseIn2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: {
              color,
              textColor,
              boxShadow,
              lineHeight: lineHeight2,
              headerPadding,
              footerPadding,
              borderRadius,
              bodyPadding,
              titleFontSize,
              titleTextColor,
              titleFontWeight,
              headerBorderBottom,
              footerBorderTop,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeColorHover,
              closeColorPressed,
              closeIconSize,
              closeSize,
              closeBorderRadius,
              resizableTriggerColorHover
            }
          } = themeRef.value;
          return {
            "--n-line-height": lineHeight2,
            "--n-color": color,
            "--n-border-radius": borderRadius,
            "--n-text-color": textColor,
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-out": cubicBezierEaseOut2,
            "--n-bezier-in": cubicBezierEaseIn2,
            "--n-header-padding": headerPadding,
            "--n-body-padding": bodyPadding,
            "--n-footer-padding": footerPadding,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-header-border-bottom": headerBorderBottom,
            "--n-footer-border-top": footerBorderTop,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-size": closeSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-resize-trigger-color-hover": resizableTriggerColorHover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedBodyStyle: mergedBodyStyleRef,
          handleOutsideClick,
          handleMaskClick,
          handleEsc,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
          isMounted: isMountedRef
        };
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h(LazyTeleport, {
          to: this.to,
          show: this.show
        }, {
          default: () => {
            var _a2;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return withDirectives(h("div", {
              class: [`${mergedClsPrefix}-drawer-container`, this.namespace, this.themeClass],
              style: this.cssVars,
              role: "none"
            }, this.showMask ? h(Transition, {
              name: "fade-in-transition",
              appear: this.isMounted
            }, {
              default: () => this.show ? h("div", {
                "aria-hidden": true,
                class: [`${mergedClsPrefix}-drawer-mask`, this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`],
                onClick: this.handleMaskClick
              }) : null
            }) : null, h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, {
              class: [this.drawerClass, this.$attrs.class],
              style: [this.mergedBodyStyle, this.$attrs.style],
              blockScroll: this.blockScroll,
              contentStyle: this.contentStyle,
              contentClass: this.contentClass,
              placement: this.placement,
              scrollbarProps: this.scrollbarProps,
              show: this.show,
              displayDirective: this.displayDirective,
              nativeScrollbar: this.nativeScrollbar,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.onAfterLeave,
              trapFocus: this.trapFocus,
              autoFocus: this.autoFocus,
              resizable: this.resizable,
              maxHeight: this.maxHeight,
              minHeight: this.minHeight,
              maxWidth: this.maxWidth,
              minWidth: this.minWidth,
              showMask: this.showMask,
              onEsc: this.handleEsc,
              onClickoutside: this.handleOutsideClick
            }), this.$slots)), [[zindexable, {
              zIndex: this.zIndex,
              enabled: this.show
            }]]);
          }
        });
      }
    });
    const drawerContentProps = {
      title: String,
      headerClass: String,
      headerStyle: [Object, String],
      footerClass: String,
      footerStyle: [Object, String],
      bodyClass: String,
      bodyStyle: [Object, String],
      bodyContentClass: String,
      bodyContentStyle: [Object, String],
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      scrollbarProps: Object,
      closable: Boolean
    };
    const NDrawerContent = /* @__PURE__ */ defineComponent({
      name: "DrawerContent",
      props: drawerContentProps,
      slots: Object,
      setup() {
        const NDrawer2 = inject(drawerInjectionKey, null);
        if (!NDrawer2) {
          throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
        }
        const {
          doUpdateShow
        } = NDrawer2;
        function handleCloseClick() {
          doUpdateShow(false);
        }
        return {
          handleCloseClick,
          mergedTheme: NDrawer2.mergedThemeRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef
        };
      },
      render() {
        const {
          title,
          mergedClsPrefix,
          nativeScrollbar,
          mergedTheme,
          bodyClass,
          bodyStyle,
          bodyContentClass,
          bodyContentStyle,
          headerClass,
          headerStyle,
          footerClass,
          footerStyle,
          scrollbarProps: scrollbarProps2,
          closable,
          $slots
        } = this;
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-drawer-content`, nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`]
        }, $slots.header || title || closable ? h("div", {
          class: [`${mergedClsPrefix}-drawer-header`, headerClass],
          style: headerStyle,
          role: "none"
        }, h("div", {
          class: `${mergedClsPrefix}-drawer-header__main`,
          role: "heading",
          "aria-level": "1"
        }, $slots.header !== void 0 ? $slots.header() : title), closable && h(NBaseClose, {
          onClick: this.handleCloseClick,
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-drawer-header__close`,
          absolute: true
        })) : null, nativeScrollbar ? h("div", {
          class: [`${mergedClsPrefix}-drawer-body`, bodyClass],
          style: bodyStyle,
          role: "none"
        }, h("div", {
          class: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          style: bodyContentStyle,
          role: "none"
        }, $slots)) : h(Scrollbar, Object.assign({
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          theme: mergedTheme.peers.Scrollbar
        }, scrollbarProps2, {
          class: `${mergedClsPrefix}-drawer-body`,
          contentClass: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          contentStyle: bodyContentStyle
        }), $slots), $slots.footer ? h("div", {
          class: [`${mergedClsPrefix}-drawer-footer`, footerClass],
          style: footerStyle,
          role: "none"
        }, $slots.footer()) : null);
      }
    });
    const commonVariables$5 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };
    const dynamicInputDark = {
      name: "DynamicInput",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self() {
        return commonVariables$5;
      }
    };
    const commonVars$4 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const spaceDark = {
      name: "Space",
      self() {
        return commonVars$4;
      }
    };
    function self$l() {
      return commonVars$4;
    }
    const spaceLight = {
      self: self$l
    };
    let supportFlexGap;
    function ensureSupportFlexGap() {
      if (!isBrowser$1) return true;
      if (supportFlexGap === void 0) {
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        const isSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return supportFlexGap = isSupported;
      }
      return supportFlexGap;
    }
    const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
      align: String,
      justify: {
        type: String,
        default: "start"
      },
      inline: Boolean,
      vertical: Boolean,
      reverse: Boolean,
      size: {
        type: [String, Number, Array],
        default: "medium"
      },
      wrapItem: {
        type: Boolean,
        default: true
      },
      itemClass: String,
      itemStyle: [String, Object],
      wrap: {
        type: Boolean,
        default: true
      },
      // internal
      internalUseGap: {
        type: Boolean,
        default: void 0
      }
    });
    const NSpace = /* @__PURE__ */ defineComponent({
      name: "Space",
      props: spaceProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Space", "-space", void 0, spaceLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
        return {
          useGap: ensureSupportFlexGap(),
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          margin: computed(() => {
            const {
              size: size2
            } = props;
            if (Array.isArray(size2)) {
              return {
                horizontal: size2[0],
                vertical: size2[1]
              };
            }
            if (typeof size2 === "number") {
              return {
                horizontal: size2,
                vertical: size2
              };
            }
            const {
              self: {
                [createKey("gap", size2)]: gap
              }
            } = themeRef.value;
            const {
              row,
              col
            } = getGap(gap);
            return {
              horizontal: depx(col),
              vertical: depx(row)
            };
          })
        };
      },
      render() {
        const {
          vertical,
          reverse,
          align,
          inline,
          justify,
          itemClass,
          itemStyle,
          margin,
          wrap,
          mergedClsPrefix,
          rtlEnabled,
          useGap,
          wrapItem,
          internalUseGap
        } = this;
        const children = flatten(getSlot(this), false);
        if (!children.length) return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith("space-");
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-space`, rtlEnabled && `${mergedClsPrefix}-space--rtl`],
          style: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: (() => {
              if (vertical && !reverse) return "column";
              if (vertical && reverse) return "column-reverse";
              if (!vertical && reverse) return "row-reverse";
              else return "row";
            })(),
            justifyContent: ["start", "end"].includes(justify) ? `flex-${justify}` : justify,
            flexWrap: !wrap || vertical ? "nowrap" : "wrap",
            marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            alignItems: align,
            gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
          }
        }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => child.type === Comment ? child : h("div", {
          role: "none",
          class: itemClass,
          style: [itemStyle, {
            maxWidth: "100%"
          }, useGap ? "" : vertical ? {
            marginBottom: index !== lastIndex ? verticalMargin : ""
          } : rtlEnabled ? {
            marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          } : {
            marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          }]
        }, child)));
      }
    });
    const dynamicTagsDark = {
      name: "DynamicTags",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        Tag: tagDark,
        Space: spaceDark
      },
      self() {
        return {
          inputWidth: "64px"
        };
      }
    };
    const elementDark = {
      name: "Element",
      common: derived$1
    };
    const commonVars$3 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const flexDark = {
      name: "Flex",
      self() {
        return commonVars$3;
      }
    };
    const buttonGroupDark = {
      name: "ButtonGroup",
      common: derived$1
    };
    const commonVariables$4 = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right",
      labelFontWeight: "400"
    };
    function self$k(vars) {
      const {
        heightSmall,
        heightMedium,
        heightLarge,
        textColor1,
        errorColor,
        warningColor,
        lineHeight: lineHeight2,
        textColor3
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), {
        blankHeightSmall: heightSmall,
        blankHeightMedium: heightMedium,
        blankHeightLarge: heightLarge,
        lineHeight: lineHeight2,
        labelTextColor: textColor1,
        asteriskColor: errorColor,
        feedbackTextColorError: errorColor,
        feedbackTextColorWarning: warningColor,
        feedbackTextColor: textColor3
      });
    }
    const formLight = {
      common: derived,
      self: self$k
    };
    const formItemDark = {
      name: "Form",
      common: derived$1,
      self: self$k
    };
    const gradientTextDark = {
      name: "GradientText",
      common: derived$1,
      self(vars) {
        const {
          primaryColor,
          successColor,
          warningColor,
          errorColor,
          infoColor,
          primaryColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          infoColorSuppl,
          fontWeightStrong
        } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: primaryColor,
          colorEndPrimary: primaryColorSuppl,
          colorStartInfo: infoColor,
          colorEndInfo: infoColorSuppl,
          colorStartWarning: warningColor,
          colorEndWarning: warningColorSuppl,
          colorStartError: errorColor,
          colorEndError: errorColorSuppl,
          colorStartSuccess: successColor,
          colorEndSuccess: successColorSuppl
        };
      }
    };
    const inputNumberDark = {
      name: "InputNumber",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Input: inputDark
      },
      self(vars) {
        const {
          textColorDisabled
        } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      }
    };
    const layoutDark = {
      name: "Layout",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          textColor2,
          bodyColor,
          popoverColor,
          cardColor,
          dividerColor,
          scrollbarColor,
          scrollbarColorHover
        } = vars;
        return {
          textColor: textColor2,
          textColorInverted: textColor2,
          color: bodyColor,
          colorEmbedded: bodyColor,
          headerColor: cardColor,
          headerColorInverted: cardColor,
          footerColor: cardColor,
          footerColorInverted: cardColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: dividerColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: dividerColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: dividerColor,
          siderColor: cardColor,
          siderColorInverted: cardColor,
          siderToggleButtonBorder: "1px solid transparent",
          siderToggleButtonColor: popoverColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          __invertScrollbar: "false"
        };
      }
    };
    const rowDark = {
      name: "Row",
      common: derived$1
    };
    function self$j(vars) {
      const {
        textColor2,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontSize: fontSize2,
        hoverColor
      } = vars;
      return {
        textColor: textColor2,
        color: cardColor,
        colorHover: hoverColor,
        colorModal: modalColor,
        colorHoverModal: composite(modalColor, hoverColor),
        colorPopover: popoverColor,
        colorHoverPopover: composite(popoverColor, hoverColor),
        borderColor: dividerColor,
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius,
        fontSize: fontSize2
      };
    }
    const listDark$1 = {
      name: "List",
      common: derived$1,
      self: self$j
    };
    const logDark = {
      name: "Log",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Code: codeDark
      },
      self(vars) {
        const {
          textColor2,
          inputColor,
          fontSize: fontSize2,
          primaryColor
        } = vars;
        return {
          loaderFontSize: fontSize2,
          loaderTextColor: textColor2,
          loaderColor: inputColor,
          loaderBorder: "1px solid #0000",
          loadingColor: primaryColor
        };
      }
    };
    const listDark = {
      name: "Mention",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
    };
    function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
        itemColorHoverInverted: "#0000",
        itemColorActiveInverted: activeItemColor,
        itemColorActiveHoverInverted: activeItemColor,
        itemColorActiveCollapsedInverted: activeItemColor,
        itemTextColorInverted: color,
        itemTextColorHoverInverted: activeTextColor,
        itemTextColorChildActiveInverted: activeTextColor,
        itemTextColorChildActiveHoverInverted: activeTextColor,
        itemTextColorActiveInverted: activeTextColor,
        itemTextColorActiveHoverInverted: activeTextColor,
        itemTextColorHorizontalInverted: color,
        itemTextColorHoverHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
        itemTextColorActiveHorizontalInverted: activeTextColor,
        itemTextColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorInverted: color,
        itemIconColorHoverInverted: activeTextColor,
        itemIconColorActiveInverted: activeTextColor,
        itemIconColorActiveHoverInverted: activeTextColor,
        itemIconColorChildActiveInverted: activeTextColor,
        itemIconColorChildActiveHoverInverted: activeTextColor,
        itemIconColorCollapsedInverted: color,
        itemIconColorHorizontalInverted: color,
        itemIconColorHoverHorizontalInverted: activeTextColor,
        itemIconColorActiveHorizontalInverted: activeTextColor,
        itemIconColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
        arrowColorInverted: color,
        arrowColorHoverInverted: activeTextColor,
        arrowColorActiveInverted: activeTextColor,
        arrowColorActiveHoverInverted: activeTextColor,
        arrowColorChildActiveInverted: activeTextColor,
        arrowColorChildActiveHoverInverted: activeTextColor,
        groupTextColorInverted: groupTextColor
      };
    }
    function self$i(vars) {
      const {
        borderRadius,
        textColor3,
        primaryColor,
        textColor2,
        textColor1,
        fontSize: fontSize2,
        dividerColor,
        hoverColor,
        primaryColorHover
      } = vars;
      return Object.assign({
        borderRadius,
        color: "#0000",
        groupTextColor: textColor3,
        itemColorHover: hoverColor,
        itemColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveHover: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveCollapsed: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemTextColor: textColor2,
        itemTextColorHover: textColor2,
        itemTextColorActive: primaryColor,
        itemTextColorActiveHover: primaryColor,
        itemTextColorChildActive: primaryColor,
        itemTextColorChildActiveHover: primaryColor,
        itemTextColorHorizontal: textColor2,
        itemTextColorHoverHorizontal: primaryColorHover,
        itemTextColorActiveHorizontal: primaryColor,
        itemTextColorActiveHoverHorizontal: primaryColor,
        itemTextColorChildActiveHorizontal: primaryColor,
        itemTextColorChildActiveHoverHorizontal: primaryColor,
        itemIconColor: textColor1,
        itemIconColorHover: textColor1,
        itemIconColorActive: primaryColor,
        itemIconColorActiveHover: primaryColor,
        itemIconColorChildActive: primaryColor,
        itemIconColorChildActiveHover: primaryColor,
        itemIconColorCollapsed: textColor1,
        itemIconColorHorizontal: textColor1,
        itemIconColorHoverHorizontal: primaryColorHover,
        itemIconColorActiveHorizontal: primaryColor,
        itemIconColorActiveHoverHorizontal: primaryColor,
        itemIconColorChildActiveHorizontal: primaryColor,
        itemIconColorChildActiveHoverHorizontal: primaryColor,
        itemHeight: "42px",
        arrowColor: textColor2,
        arrowColorHover: textColor2,
        arrowColorActive: primaryColor,
        arrowColorActiveHover: primaryColor,
        arrowColorChildActive: primaryColor,
        arrowColorChildActiveHover: primaryColor,
        colorInverted: "#0000",
        borderColorHorizontal: "#0000",
        fontSize: fontSize2,
        dividerColor
      }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
    }
    const menuDark = {
      name: "Menu",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const {
          primaryColor,
          primaryColorSuppl
        } = vars;
        const commonSelf = self$i(vars);
        commonSelf.itemColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveHover = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveInverted = primaryColorSuppl;
        commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
        commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const common = {
      titleFontSize: "18px",
      backSize: "22px"
    };
    function self$h(vars) {
      const {
        textColor1,
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeightStrong,
        primaryColorHover,
        primaryColorPressed
      } = vars;
      return Object.assign(Object.assign({}, common), {
        titleFontWeight: fontWeightStrong,
        fontSize: fontSize2,
        titleTextColor: textColor1,
        backColor: textColor2,
        backColorHover: primaryColorHover,
        backColorPressed: primaryColorPressed,
        subtitleTextColor: textColor3
      });
    }
    const pageHeaderDark = {
      name: "PageHeader",
      common: derived$1,
      self: self$h
    };
    const commonVars$2 = {
      iconSize: "22px"
    };
    function self$g(vars) {
      const {
        fontSize: fontSize2,
        warningColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars$2), {
        fontSize: fontSize2,
        iconColor: warningColor
      });
    }
    const popconfirmDark = {
      name: "Popconfirm",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Popover: popoverDark
      },
      self: self$g
    };
    function self$f(vars) {
      const {
        infoColor,
        successColor,
        warningColor,
        errorColor,
        textColor2,
        progressRailColor,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        fontSize: fontSize2,
        fontSizeCircle: "28px",
        fontWeightCircle: fontWeight,
        railColor: progressRailColor,
        railHeight: "8px",
        iconSizeCircle: "36px",
        iconSizeLine: "18px",
        iconColor: infoColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        textColorCircle: textColor2,
        textColorLineInner: "rgb(255, 255, 255)",
        textColorLineOuter: textColor2,
        fillColor: infoColor,
        fillColorInfo: infoColor,
        fillColorSuccess: successColor,
        fillColorWarning: warningColor,
        fillColorError: errorColor,
        lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
      };
    }
    const progressDark = {
      name: "Progress",
      common: derived$1,
      self(vars) {
        const commonSelf = self$f(vars);
        commonSelf.textColorLineInner = "rgb(0, 0, 0)";
        commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
        return commonSelf;
      }
    };
    const rateDark = {
      name: "Rate",
      common: derived$1,
      self(vars) {
        const {
          railColor
        } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#CCAA33",
          itemSize: "20px",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      }
    };
    const commonVariables$3 = {
      titleFontSizeSmall: "26px",
      titleFontSizeMedium: "32px",
      titleFontSizeLarge: "40px",
      titleFontSizeHuge: "48px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      iconSizeSmall: "64px",
      iconSizeMedium: "80px",
      iconSizeLarge: "100px",
      iconSizeHuge: "125px",
      iconColor418: void 0,
      iconColor404: void 0,
      iconColor403: void 0,
      iconColor500: void 0
    };
    function self$e(vars) {
      const {
        textColor2,
        textColor1,
        errorColor,
        successColor,
        infoColor,
        warningColor,
        lineHeight: lineHeight2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), {
        lineHeight: lineHeight2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        textColor: textColor2,
        iconColorError: errorColor,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor
      });
    }
    const resultDark = {
      name: "Result",
      common: derived$1,
      self: self$e
    };
    const sizeVariables$3 = {
      railHeight: "4px",
      railWidthVertical: "4px",
      handleSize: "18px",
      dotHeight: "8px",
      dotWidth: "8px",
      dotBorderRadius: "4px"
    };
    const sliderDark = {
      name: "Slider",
      common: derived$1,
      self(vars) {
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const {
          railColor,
          modalColor,
          primaryColorSuppl,
          popoverColor,
          textColor2,
          cardColor,
          borderRadius,
          fontSize: fontSize2,
          opacityDisabled
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables$3), {
          fontSize: fontSize2,
          markFontSize: fontSize2,
          railColor,
          railColorHover: railColor,
          fillColor: primaryColorSuppl,
          fillColorHover: primaryColorSuppl,
          opacityDisabled,
          handleColor: "#FFF",
          dotColor: cardColor,
          dotColorModal: modalColor,
          dotColorPopover: popoverColor,
          handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          indicatorColor: popoverColor,
          indicatorBoxShadow: boxShadow,
          indicatorTextColor: textColor2,
          indicatorBorderRadius: borderRadius,
          dotBorder: `2px solid ${railColor}`,
          dotBorderActive: `2px solid ${primaryColorSuppl}`,
          dotBoxShadow: ""
        });
      }
    };
    function self$d(vars) {
      const {
        opacityDisabled,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        primaryColor,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        textColor: primaryColor,
        sizeTiny: heightTiny,
        sizeSmall: heightSmall,
        sizeMedium: heightMedium,
        sizeLarge: heightLarge,
        sizeHuge: heightHuge,
        color: primaryColor,
        opacitySpinning: opacityDisabled
      };
    }
    const spinDark = {
      name: "Spin",
      common: derived$1,
      self: self$d
    };
    function self$c(vars) {
      const {
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        labelFontSize: fontSize2,
        labelFontWeight: fontWeight,
        valueFontWeight: fontWeight,
        valueFontSize: "24px",
        labelTextColor: textColor3,
        valuePrefixTextColor: textColor2,
        valueSuffixTextColor: textColor2,
        valueTextColor: textColor2
      };
    }
    const statisticDark = {
      name: "Statistic",
      common: derived$1,
      self: self$c
    };
    const commonVariables$2 = {
      stepHeaderFontSizeSmall: "14px",
      stepHeaderFontSizeMedium: "16px",
      indicatorIndexFontSizeSmall: "14px",
      indicatorIndexFontSizeMedium: "16px",
      indicatorSizeSmall: "22px",
      indicatorSizeMedium: "28px",
      indicatorIconSizeSmall: "14px",
      indicatorIconSizeMedium: "18px"
    };
    function self$b(vars) {
      const {
        fontWeightStrong,
        baseColor,
        textColorDisabled,
        primaryColor,
        errorColor,
        textColor1,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), {
        stepHeaderFontWeight: fontWeightStrong,
        indicatorTextColorProcess: baseColor,
        indicatorTextColorWait: textColorDisabled,
        indicatorTextColorFinish: primaryColor,
        indicatorTextColorError: errorColor,
        indicatorBorderColorProcess: primaryColor,
        indicatorBorderColorWait: textColorDisabled,
        indicatorBorderColorFinish: primaryColor,
        indicatorBorderColorError: errorColor,
        indicatorColorProcess: primaryColor,
        indicatorColorWait: "#0000",
        indicatorColorFinish: "#0000",
        indicatorColorError: "#0000",
        splitorColorProcess: textColorDisabled,
        splitorColorWait: textColorDisabled,
        splitorColorFinish: primaryColor,
        splitorColorError: textColorDisabled,
        headerTextColorProcess: textColor1,
        headerTextColorWait: textColorDisabled,
        headerTextColorFinish: textColorDisabled,
        headerTextColorError: errorColor,
        descriptionTextColorProcess: textColor2,
        descriptionTextColorWait: textColorDisabled,
        descriptionTextColorFinish: textColorDisabled,
        descriptionTextColorError: errorColor
      });
    }
    const stepsDark = {
      name: "Steps",
      common: derived$1,
      self: self$b
    };
    const commonVars$1 = {
      buttonHeightSmall: "14px",
      buttonHeightMedium: "18px",
      buttonHeightLarge: "22px",
      buttonWidthSmall: "14px",
      buttonWidthMedium: "18px",
      buttonWidthLarge: "22px",
      buttonWidthPressedSmall: "20px",
      buttonWidthPressedMedium: "24px",
      buttonWidthPressedLarge: "28px",
      railHeightSmall: "18px",
      railHeightMedium: "22px",
      railHeightLarge: "26px",
      railWidthSmall: "32px",
      railWidthMedium: "40px",
      railWidthLarge: "48px"
    };
    const switchDark = {
      name: "Switch",
      common: derived$1,
      self(vars) {
        const {
          primaryColorSuppl,
          opacityDisabled,
          borderRadius,
          primaryColor,
          textColor2,
          baseColor
        } = vars;
        const railOverlayColor = "rgba(255, 255, 255, .20)";
        return Object.assign(Object.assign({}, commonVars$1), {
          iconColor: baseColor,
          textColor: textColor2,
          loadingColor: primaryColorSuppl,
          opacityDisabled,
          railColor: railOverlayColor,
          railColorActive: primaryColorSuppl,
          buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          buttonColor: "#FFF",
          railBorderRadiusSmall: borderRadius,
          railBorderRadiusMedium: borderRadius,
          railBorderRadiusLarge: borderRadius,
          buttonBorderRadiusSmall: borderRadius,
          buttonBorderRadiusMedium: borderRadius,
          buttonBorderRadiusLarge: borderRadius,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`
        });
      }
    };
    function self$a(vars) {
      const {
        primaryColor,
        opacityDisabled,
        borderRadius,
        textColor3
      } = vars;
      const railOverlayColor = "rgba(0, 0, 0, .14)";
      return Object.assign(Object.assign({}, commonVars$1), {
        iconColor: textColor3,
        textColor: "white",
        loadingColor: primaryColor,
        opacityDisabled,
        railColor: railOverlayColor,
        railColorActive: primaryColor,
        buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        buttonColor: "#FFF",
        railBorderRadiusSmall: borderRadius,
        railBorderRadiusMedium: borderRadius,
        railBorderRadiusLarge: borderRadius,
        buttonBorderRadiusSmall: borderRadius,
        buttonBorderRadiusMedium: borderRadius,
        buttonBorderRadiusLarge: borderRadius,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`
      });
    }
    const switchLight = {
      common: derived,
      self: self$a
    };
    const sizeVariables$2 = {
      thPaddingSmall: "6px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "6px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px"
    };
    function self$9(vars) {
      const {
        dividerColor,
        cardColor,
        modalColor,
        popoverColor,
        tableHeaderColor,
        tableColorStriped,
        textColor1,
        textColor2,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$2), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight: lineHeight2,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        tdColorStriped: composite(cardColor, tableColorStriped),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        tdTextColor: textColor2,
        thFontWeight: fontWeightStrong
      });
    }
    const tableDark = {
      name: "Table",
      common: derived$1,
      self: self$9
    };
    const sizeVariables$1 = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabGapSmallLineVertical: "8px",
      tabGapMediumLineVertical: "8px",
      tabGapLargeLineVertical: "8px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabPaddingVerticalSmallLine: "6px 12px",
      tabPaddingVerticalMediumLine: "8px 16px",
      tabPaddingVerticalLargeLine: "10px 20px",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabGapSmallBarVertical: "8px",
      tabGapMediumBarVertical: "8px",
      tabGapLargeBarVertical: "8px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabPaddingVerticalSmallBar: "6px 12px",
      tabPaddingVerticalMediumBar: "8px 16px",
      tabPaddingVerticalLargeBar: "10px 20px",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabGapSmallCardVertical: "4px",
      tabGapMediumCardVertical: "4px",
      tabGapLargeCardVertical: "4px",
      tabPaddingSmallCard: "8px 16px",
      tabPaddingMediumCard: "10px 20px",
      tabPaddingLargeCard: "12px 24px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabPaddingVerticalLargeSegment: "0 8px",
      tabPaddingVerticalSmallCard: "8px 12px",
      tabPaddingVerticalMediumCard: "10px 16px",
      tabPaddingVerticalLargeCard: "12px 20px",
      tabPaddingVerticalSmallSegment: "0 4px",
      tabPaddingVerticalMediumSegment: "0 6px",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      tabGapSmallSegmentVertical: "0",
      tabGapMediumSegmentVertical: "0",
      tabGapLargeSegmentVertical: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };
    function self$8(vars) {
      const {
        textColor2,
        primaryColor,
        textColorDisabled,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        tabColor,
        baseColor,
        dividerColor,
        fontWeight,
        textColor1,
        borderRadius,
        fontSize: fontSize2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$1), {
        colorSegment: tabColor,
        tabFontSizeCard: fontSize2,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      });
    }
    const tabsDark = {
      name: "Tabs",
      common: derived$1,
      self(vars) {
        const commonSelf = self$8(vars);
        const {
          inputColor
        } = vars;
        commonSelf.colorSegment = inputColor;
        commonSelf.tabColorSegment = inputColor;
        return commonSelf;
      }
    };
    function self$7(vars) {
      const {
        textColor1,
        textColor2,
        fontWeightStrong,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        titleTextColor: textColor1,
        textColor: textColor2,
        titleFontWeight: fontWeightStrong
      };
    }
    const thingDark = {
      name: "Thing",
      common: derived$1,
      self: self$7
    };
    const sizeVariables = {
      titleMarginMedium: "0 0 6px 0",
      titleMarginLarge: "-2px 0 6px 0",
      titleFontSizeMedium: "14px",
      titleFontSizeLarge: "16px",
      iconSizeMedium: "14px",
      iconSizeLarge: "14px"
    };
    const timelineDark = {
      name: "Timeline",
      common: derived$1,
      self(vars) {
        const {
          textColor3,
          infoColorSuppl,
          errorColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          textColor1,
          textColor2,
          railColor,
          fontWeightStrong,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables), {
          contentFontSize: fontSize2,
          titleFontWeight: fontWeightStrong,
          circleBorder: `2px solid ${textColor3}`,
          circleBorderInfo: `2px solid ${infoColorSuppl}`,
          circleBorderError: `2px solid ${errorColorSuppl}`,
          circleBorderSuccess: `2px solid ${successColorSuppl}`,
          circleBorderWarning: `2px solid ${warningColorSuppl}`,
          iconColor: textColor3,
          iconColorInfo: infoColorSuppl,
          iconColorError: errorColorSuppl,
          iconColorSuccess: successColorSuppl,
          iconColorWarning: warningColorSuppl,
          titleTextColor: textColor1,
          contentTextColor: textColor2,
          metaTextColor: textColor3,
          lineColor: railColor
        });
      }
    };
    const commonVariables$1 = {
      extraFontSizeSmall: "12px",
      extraFontSizeMedium: "12px",
      extraFontSizeLarge: "14px",
      titleFontSizeSmall: "14px",
      titleFontSizeMedium: "16px",
      titleFontSizeLarge: "16px",
      closeSize: "20px",
      closeIconSize: "16px",
      headerHeightSmall: "44px",
      headerHeightMedium: "44px",
      headerHeightLarge: "50px"
    };
    const transferDark$1 = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          textColor3,
          hoverColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          dividerColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        });
      }
    };
    function self$6(vars) {
      const {
        borderRadiusSmall,
        dividerColor,
        hoverColor,
        pressedColor,
        primaryColor,
        textColor3,
        textColor2,
        textColorDisabled,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: "1.5",
        nodeHeight: "30px",
        nodeWrapperPadding: "3px 0",
        nodeBorderRadius: borderRadiusSmall,
        nodeColorHover: hoverColor,
        nodeColorPressed: pressedColor,
        nodeColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        arrowColor: textColor3,
        nodeTextColor: textColor2,
        nodeTextColorDisabled: textColorDisabled,
        loadingColor: primaryColor,
        dropMarkColor: primaryColor,
        lineColor: dividerColor
      };
    }
    const treeDark = {
      name: "Tree",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self(vars) {
        const {
          primaryColor
        } = vars;
        const commonSelf = self$6(vars);
        commonSelf.nodeColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        return commonSelf;
      }
    };
    const treeSelectDark = {
      name: "TreeSelect",
      common: derived$1,
      peers: {
        Tree: treeDark,
        Empty: emptyDark,
        InternalSelection: internalSelectionDark
      }
    };
    const commonVars = {
      headerFontSize1: "30px",
      headerFontSize2: "22px",
      headerFontSize3: "18px",
      headerFontSize4: "16px",
      headerFontSize5: "16px",
      headerFontSize6: "16px",
      headerMargin1: "28px 0 20px 0",
      headerMargin2: "28px 0 20px 0",
      headerMargin3: "28px 0 20px 0",
      headerMargin4: "28px 0 18px 0",
      headerMargin5: "28px 0 18px 0",
      headerMargin6: "28px 0 18px 0",
      headerPrefixWidth1: "16px",
      headerPrefixWidth2: "16px",
      headerPrefixWidth3: "12px",
      headerPrefixWidth4: "12px",
      headerPrefixWidth5: "12px",
      headerPrefixWidth6: "12px",
      headerBarWidth1: "4px",
      headerBarWidth2: "4px",
      headerBarWidth3: "3px",
      headerBarWidth4: "3px",
      headerBarWidth5: "3px",
      headerBarWidth6: "3px",
      pMargin: "16px 0 16px 0",
      liMargin: ".25em 0 0 0",
      olPadding: "0 0 0 2em",
      ulPadding: "0 0 0 2em"
    };
    function self$5(vars) {
      const {
        primaryColor,
        textColor2,
        borderColor,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        borderRadiusSmall,
        dividerColor,
        fontWeightStrong,
        textColor1,
        textColor3,
        infoColor,
        warningColor,
        errorColor,
        successColor,
        codeColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars), {
        aTextColor: primaryColor,
        blockquoteTextColor: textColor2,
        blockquotePrefixColor: borderColor,
        blockquoteLineHeight: lineHeight2,
        blockquoteFontSize: fontSize2,
        codeBorderRadius: borderRadiusSmall,
        liTextColor: textColor2,
        liLineHeight: lineHeight2,
        liFontSize: fontSize2,
        hrColor: dividerColor,
        headerFontWeight: fontWeightStrong,
        headerTextColor: textColor1,
        pTextColor: textColor2,
        pTextColor1Depth: textColor1,
        pTextColor2Depth: textColor2,
        pTextColor3Depth: textColor3,
        pLineHeight: lineHeight2,
        pFontSize: fontSize2,
        headerBarColor: primaryColor,
        headerBarColorPrimary: primaryColor,
        headerBarColorInfo: infoColor,
        headerBarColorError: errorColor,
        headerBarColorWarning: warningColor,
        headerBarColorSuccess: successColor,
        textColor: textColor2,
        textColor1Depth: textColor1,
        textColor2Depth: textColor2,
        textColor3Depth: textColor3,
        textColorPrimary: primaryColor,
        textColorInfo: infoColor,
        textColorSuccess: successColor,
        textColorWarning: warningColor,
        textColorError: errorColor,
        codeTextColor: textColor2,
        codeColor,
        codeBorder: "1px solid #0000"
      });
    }
    const typographyDark = {
      name: "Typography",
      common: derived$1,
      self: self$5
    };
    function self$4(vars) {
      const {
        iconColor,
        primaryColor,
        errorColor,
        textColor2,
        successColor,
        opacityDisabled,
        actionColor,
        borderColor,
        hoverColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        borderRadius,
        draggerColor: actionColor,
        draggerBorder: `1px dashed ${borderColor}`,
        draggerBorderHover: `1px dashed ${primaryColor}`,
        itemColorHover: hoverColor,
        itemColorHoverError: changeColor(errorColor, {
          alpha: 0.06
        }),
        itemTextColor: textColor2,
        itemTextColorError: errorColor,
        itemTextColorSuccess: successColor,
        itemIconColor: iconColor,
        itemDisabledOpacity: opacityDisabled,
        itemBorderImageCardError: `1px solid ${errorColor}`,
        itemBorderImageCard: `1px solid ${borderColor}`
      };
    }
    const uploadDark = {
      name: "Upload",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Progress: progressDark
      },
      self(vars) {
        const {
          errorColor
        } = vars;
        const commonSelf = self$4(vars);
        commonSelf.itemColorHoverError = changeColor(errorColor, {
          alpha: 0.09
        });
        return commonSelf;
      }
    };
    const watermarkDark = {
      name: "Watermark",
      common: derived$1,
      self(vars) {
        const {
          fontFamily: fontFamily2
        } = vars;
        return {
          fontFamily: fontFamily2
        };
      }
    };
    const floatButtonDark = {
      name: "FloatButton",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          buttonColor2Hover,
          buttonColor2Pressed,
          primaryColor,
          primaryColorHover,
          primaryColorPressed,
          baseColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          textColor: textColor2,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          colorHover: buttonColor2Hover,
          colorPressed: buttonColor2Pressed,
          colorPrimary: primaryColor,
          colorPrimaryHover: primaryColorHover,
          colorPrimaryPressed: primaryColorPressed,
          textColorPrimary: baseColor,
          borderRadiusSquare: borderRadius
        };
      }
    };
    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
    const style$2 = cB("form", [cM$1("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c("&:last-child", {
      marginRight: 0
    })])])]);
    var __awaiter$1 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formProps = Object.assign(Object.assign({}, useTheme.props), {
      inline: Boolean,
      labelWidth: [Number, String],
      labelAlign: String,
      labelPlacement: {
        type: String,
        default: "top"
      },
      model: {
        type: Object,
        default: () => {
        }
      },
      rules: Object,
      disabled: Boolean,
      size: String,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: true
      },
      onSubmit: {
        type: Function,
        default: (e) => {
          e.preventDefault();
        }
      },
      showLabel: {
        type: Boolean,
        default: void 0
      },
      validateMessages: Object
    });
    const NForm = /* @__PURE__ */ defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const {
          mergedClsPrefixRef
        } = useConfig(props);
        useTheme("Form", "-form", style$2, formLight, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        function validate(validateCallback_1) {
          return __awaiter$1(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
            return yield new Promise((resolve2, reject) => {
              const formItemValidationPromises = [];
              for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                  if (formItemInstance.path) {
                    formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                  }
                }
              }
              void Promise.all(formItemValidationPromises).then((results) => {
                const formInvalid = results.some((result) => !result.valid);
                const errors = [];
                const warnings = [];
                results.forEach((result) => {
                  var _a2, _b2;
                  if ((_a2 = result.errors) === null || _a2 === void 0 ? void 0 : _a2.length) {
                    errors.push(result.errors);
                  }
                  if ((_b2 = result.warnings) === null || _b2 === void 0 ? void 0 : _b2.length) {
                    warnings.push(result.warnings);
                  }
                });
                if (validateCallback) {
                  validateCallback(errors.length ? errors : void 0, {
                    warnings: warnings.length ? warnings : void 0
                  });
                }
                if (formInvalid) {
                  reject(errors.length ? errors : void 0);
                } else {
                  resolve2({
                    warnings: warnings.length ? warnings : void 0
                  });
                }
              });
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        provide(formItemInstsInjectionKey, {
          formItems
        });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h("form", {
          class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
          onSubmit: this.onSubmit
        }, this.$slots);
      }
    });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
        o2.__proto__ = p22;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i >= len) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip2 = function ip22(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip2.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip2.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip2.v4().source;
      var ipv6 = ip2.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float2(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex2(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc2) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc22() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys = options.keys || Object.keys(this.rules);
        keys.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb2, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e) {
              return cb2(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys = Object.keys(rule);
        var messageIndex = keys.indexOf("message");
        if (messageIndex !== -1) {
          keys.splice(messageIndex, 1);
        }
        if (keys.length === 1 && keys[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    const {
      cubicBezierEaseInOut
    } = commonVariables$n;
    function fadeDownTransition({
      name = "fade-down",
      fromOffset = "-4px",
      enterDuration = ".3s",
      leaveDuration = ".3s",
      enterCubicBezier = cubicBezierEaseInOut,
      leaveCubicBezier = cubicBezierEaseInOut
    } = {}) {
      return [c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }
    const style$1 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE$1("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE$1("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM$1("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM$1("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM$1("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM$1("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM$1("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM$1("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE$1("text", `
 grid-area: text; 
 `), cE$1("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM$1("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM$1("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM$1("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM$1("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);
    function formItemSize(props) {
      const NForm2 = inject(formInjectionKey, null);
      return {
        mergedSize: computed(() => {
          if (props.size !== void 0) return props.size;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0) return NForm2.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm2 = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
        const {
          labelPlacement
        } = props;
        if (labelPlacement !== void 0) return labelPlacement;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement) return NForm2.props.labelPlacement;
        return "top";
      });
      const isAutoLabelWidthRef = computed(() => {
        return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
      });
      const mergedLabelWidthRef = computed(() => {
        if (mergedLabelPlacementRef.value === "top") return;
        const {
          labelWidth
        } = props;
        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }
        if (isAutoLabelWidthRef.value) {
          const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
          return formatLength(NForm2.props.labelWidth);
        }
        return void 0;
      });
      const mergedLabelAlignRef = computed(() => {
        const {
          labelAlign
        } = props;
        if (labelAlign) return labelAlign;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign) return NForm2.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = computed(() => {
        var _a2;
        return [(_a2 = props.labelProps) === null || _a2 === void 0 ? void 0 : _a2.style, props.labelStyle, {
          width: mergedLabelWidthRef.value
        }];
      });
      const mergedShowRequireMarkRef = computed(() => {
        const {
          showRequireMark
        } = props;
        if (showRequireMark !== void 0) return showRequireMark;
        return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
        const {
          requireMarkPlacement
        } = props;
        if (requireMarkPlacement !== void 0) return requireMarkPlacement;
        return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = ref(false);
      const validationWarnedRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
        const {
          validationStatus
        } = props;
        if (validationStatus !== void 0) return validationStatus;
        if (validationErroredRef.value) return "error";
        if (validationWarnedRef.value) return "warning";
        return void 0;
      });
      const mergedShowFeedbackRef = computed(() => {
        const {
          showFeedback
        } = props;
        if (showFeedback !== void 0) return showFeedback;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0) return NForm2.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = computed(() => {
        const {
          showLabel
        } = props;
        if (showLabel !== void 0) return showLabel;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0) return NForm2.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        validationWarned: validationWarnedRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef,
        isAutoLabelWidth: isAutoLabelWidthRef
      };
    }
    function formItemRule(props) {
      const NForm2 = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
        const {
          rulePath
        } = props;
        if (rulePath !== void 0) return rulePath;
        const {
          path
        } = props;
        if (path !== void 0) return path;
        return void 0;
      });
      const mergedRulesRef = computed(() => {
        const rules2 = [];
        const {
          rule
        } = props;
        if (rule !== void 0) {
          if (Array.isArray(rule)) rules2.push(...rule);
          else rules2.push(rule);
        }
        if (NForm2) {
          const {
            rules: formRules
          } = NForm2.props;
          const {
            value: rulePath
          } = compatibleRulePathRef;
          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = get(formRules, rulePath);
            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules2.push(...formRule);
              } else {
                rules2.push(formRule);
              }
            }
          }
        }
        return rules2;
      });
      const hasRequiredRuleRef = computed(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
      });
      const mergedRequiredRef = computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }
    var __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
      label: String,
      labelWidth: [Number, String],
      labelStyle: [String, Object],
      labelAlign: String,
      labelPlacement: String,
      path: String,
      first: Boolean,
      rulePath: String,
      required: Boolean,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: void 0
      },
      rule: [Object, Array],
      size: String,
      ignorePathChange: Boolean,
      validationStatus: String,
      feedback: String,
      feedbackClass: String,
      feedbackStyle: [String, Object],
      showLabel: {
        type: Boolean,
        default: void 0
      },
      labelProps: Object
    });
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
            return true;
          }
        } catch (err) {
          warn("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
          console.error(err);
          return void 0;
        }
      };
    }
    const NFormItem = /* @__PURE__ */ defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const NForm2 = inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const {
          validationErrored: validationErroredRef,
          validationWarned: validationWarnedRef
        } = formItemMiscRefs;
        const {
          mergedRequired: mergedRequiredRef,
          mergedRules: mergedRulesRef
        } = formItemRule(props);
        const {
          mergedSize: mergedSizeRef
        } = formItemSizeRefs;
        const {
          mergedLabelPlacement: labelPlacementRef,
          mergedLabelAlign: labelTextAlignRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
        } = formItemMiscRefs;
        const renderExplainsRef = ref([]);
        const feedbackIdRef = ref(createId());
        const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
        const themeRef = useTheme("Form", "-form-item", style$1, formLight, props, mergedClsPrefixRef);
        watch(toRef(props, "path"), () => {
          if (props.ignorePathChange) return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          validationWarnedRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        const internalValidate = (...args_1) => __awaiter(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) {
          const {
            path
          } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first) options.first = props.first;
          }
          const {
            value: rules2
          } = mergedRulesRef;
          const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          })).filter(shouldRuleBeApplied).map((rule, i) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
          const activeWarningRules = activeRules.filter((r) => r.level === "warning");
          const validationResult = {
            valid: true,
            errors: void 0,
            warnings: void 0
          };
          if (!activeRules.length) return validationResult;
          const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
          const validator = new Schema({
            [mergedPath]: activeErrorRules
          });
          const warningValidator = new Schema({
            [mergedPath]: activeWarningRules
          });
          const {
            validateMessages
          } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
          if (validateMessages) {
            validator.messages(validateMessages);
            warningValidator.messages(validateMessages);
          }
          const renderMessages = (errors) => {
            renderExplainsRef.value = errors.map((error) => {
              const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
              return {
                key: transformedMessage,
                render: () => {
                  if (transformedMessage.startsWith("__renderMessage__")) {
                    return messageRenderers[transformedMessage]();
                  }
                  return transformedMessage;
                }
              };
            });
            errors.forEach((error) => {
              var _a2;
              if ((_a2 = error.message) === null || _a2 === void 0 ? void 0 : _a2.startsWith("__renderMessage__")) {
                error.message = originalMessageRendersMessage[error.message];
              }
            });
          };
          if (activeErrorRules.length) {
            const errors = yield new Promise((resolve2) => {
              void validator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (errors === null || errors === void 0 ? void 0 : errors.length) {
              validationResult.valid = false;
              validationResult.errors = errors;
              renderMessages(errors);
            }
          }
          if (activeWarningRules.length && !validationResult.errors) {
            const warnings = yield new Promise((resolve2) => {
              void warningValidator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
              renderMessages(warnings);
              validationResult.warnings = warnings;
            }
          }
          if (!validationResult.errors && !validationResult.warnings) {
            restoreValidation();
          } else {
            validationErroredRef.value = !!validationResult.errors;
            validationWarnedRef.value = !!validationResult.warnings;
          }
          return validationResult;
        });
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        function validate(options, callback) {
          return __awaiter(this, void 0, void 0, function* () {
            let trigger2;
            let validateCallback;
            let shouldRuleBeApplied;
            let asyncValidatorOptions;
            if (typeof options === "string") {
              trigger2 = options;
              validateCallback = callback;
            } else if (options !== null && typeof options === "object") {
              trigger2 = options.trigger;
              validateCallback = options.callback;
              shouldRuleBeApplied = options.shouldRuleBeApplied;
              asyncValidatorOptions = options.options;
            }
            return yield new Promise((resolve2, reject) => {
              void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
                valid,
                errors,
                warnings
              }) => {
                if (valid) {
                  if (validateCallback) {
                    validateCallback(void 0, {
                      warnings
                    });
                  }
                  resolve2({
                    warnings
                  });
                } else {
                  if (validateCallback) {
                    validateCallback(errors, {
                      warnings
                    });
                  }
                  reject(errors);
                }
              });
            });
          });
        }
        provide(formItemInjectionKey, {
          path: toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = ref(null);
        onMounted(() => {
          if (!formItemMiscRefs.isAutoLabelWidth.value) return;
          const labelElement = labelElementRef.value;
          if (labelElement !== null) {
            const memoizedWhitespace = labelElement.style.whiteSpace;
            labelElement.style.whiteSpace = "nowrap";
            labelElement.style.width = "";
            NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
            labelElement.style.whiteSpace = memoizedWhitespace;
          }
        });
        const cssVarsRef = computed(() => {
          var _a2;
          const {
            value: size2
          } = mergedSizeRef;
          const {
            value: labelPlacement
          } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              labelTextColor,
              asteriskColor,
              lineHeight: lineHeight2,
              feedbackTextColor,
              feedbackTextColorWarning,
              feedbackTextColorError,
              feedbackPadding,
              labelFontWeight,
              [createKey("labelHeight", size2)]: labelHeight,
              [createKey("blankHeight", size2)]: blankHeight,
              [createKey("feedbackFontSize", size2)]: feedbackFontSize,
              [createKey("feedbackHeight", size2)]: feedbackHeight,
              [createKey("labelPadding", direction)]: labelPadding,
              [createKey("labelTextAlign", direction)]: labelTextAlign,
              [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize
            }
          } = themeRef.value;
          let mergedLabelTextAlign = (_a2 = labelTextAlignRef.value) !== null && _a2 !== void 0 ? _a2 : labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-line-height": lineHeight2,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-label-font-weight": labelFontWeight,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
          var _a2;
          return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a2 = labelTextAlignRef.value) === null || _a2 === void 0 ? void 0 : _a2[0]) || ""}`;
        }), cssVarsRef, props) : void 0;
        const reverseColSpaceRef = computed(() => {
          return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
        });
        return Object.assign(Object.assign(Object.assign(Object.assign({
          labelElementRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRequired: mergedRequiredRef,
          feedbackId: feedbackIdRef,
          renderExplains: renderExplainsRef,
          reverseColSpace: reverseColSpaceRef
        }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          mergedShowLabel,
          mergedShowRequireMark,
          mergedRequireMarkPlacement,
          onRender
        } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderLabel = () => {
          const labelText = this.$slots.label ? this.$slots.label() : this.label;
          if (!labelText) return null;
          const textNode = h("span", {
            class: `${mergedClsPrefix}-form-item-label__text`
          }, labelText);
          const markNode = renderedShowRequireMark ? h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk`
          }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
          }, " *");
          const {
            labelProps
          } = this;
          return h("label", Object.assign({}, labelProps, {
            class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
            style: this.mergedLabelStyle,
            ref: "labelElementRef"
          }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
        };
        return h("div", {
          class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
          style: this.cssVars
        }, mergedShowLabel && renderLabel(), h("div", {
          class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]
        }, $slots), this.mergedShowFeedback ? h("div", {
          key: this.feedbackId,
          style: this.feedbackStyle,
          class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
        }, h(Transition, {
          name: "fade-down-transition",
          mode: "out-in"
        }, {
          default: () => {
            const {
              mergedValidationStatus
            } = this;
            return resolveWrappedSlot($slots.feedback, (children) => {
              var _a2;
              const {
                feedback
              } = this;
              const feedbackNodes = children || feedback ? h("div", {
                key: "__feedback__",
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, children || feedback) : this.renderExplains.length ? (_a2 = this.renderExplains) === null || _a2 === void 0 ? void 0 : _a2.map(({
                key,
                render: render2
              }) => h("div", {
                key,
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, render2())) : null;
              return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", {
                key: "controlled-warning",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
              }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", {
                key: "controlled-error",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
              }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", {
                key: "controlled-success",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
              }, feedbackNodes) : h("div", {
                key: "controlled-default",
                class: `${mergedClsPrefix}-form-item-feedback`
              }, feedbackNodes) : null;
            });
          }
        })) : null);
      }
    });
    function self$3(vars) {
      const {
        primaryColor,
        baseColor
      } = vars;
      return {
        color: primaryColor,
        iconColor: baseColor
      };
    }
    const iconDark = {
      name: "IconWrapper",
      common: derived$1,
      self: self$3
    };
    const imageDark = {
      name: "Image",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      },
      self: (vars) => {
        const {
          textColor2
        } = vars;
        return {
          toolbarIconColor: textColor2,
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
    };
    const commonVariables = {
      extraFontSize: "12px",
      width: "440px"
    };
    const transferDark = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          iconColorDisabled,
          iconColor,
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          heightSmall,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          hoverColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: "#0000",
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        });
      }
    };
    function self$2() {
      return {};
    }
    const marqueeDark = {
      name: "Marquee",
      common: derived$1,
      self: self$2
    };
    const qrcodeDark = {
      name: "QrCode",
      common: derived$1,
      self: (vars) => {
        return {
          borderRadius: vars.borderRadius
        };
      }
    };
    const skeletonDark = {
      name: "Skeleton",
      common: derived$1,
      self(vars) {
        const {
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius
        } = vars;
        return {
          color: "rgba(255, 255, 255, 0.12)",
          colorEnd: "rgba(255, 255, 255, 0.18)",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      }
    };
    const splitDark = {
      name: "Split",
      common: derived$1
    };
    const style = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE$1("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE$1("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE$1("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE$1("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE$1("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c("&:focus", [cE$1("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM$1("round", [cE$1("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE$1("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM$1("rubber-band", [cM$1("pressed", [cE$1("rail", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cE$1("rail", [c("&:active", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cM$1("active", [cM$1("pressed", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE$1("rail", [c("&:active", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM$1("active", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE$1("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE$1("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE$1("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM$1("active", [cE$1("rail", "background-color: var(--n-rail-color-active);")]), cM$1("loading", [cE$1("rail", `
 cursor: wait;
 `)]), cM$1("disabled", [cE$1("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
    const switchProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      loading: Boolean,
      defaultValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      round: {
        type: Boolean,
        default: true
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      railStyle: Function,
      rubberBand: {
        type: Boolean,
        default: true
      },
      /** @deprecated */
      onChange: [Function, Array]
    });
    let supportCssMax;
    const NSwitch = /* @__PURE__ */ defineComponent({
      name: "Switch",
      props: switchProps,
      slots: Object,
      setup(props) {
        if (supportCssMax === void 0) {
          if (typeof CSS !== "undefined") {
            if (typeof CSS.supports !== "undefined") {
              supportCssMax = CSS.supports("width", "max(1px)");
            } else {
              supportCssMax = false;
            }
          } else {
            supportCssMax = true;
          }
        }
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Switch", "-switch", style, switchLight, props, mergedClsPrefixRef);
        const formItem = useFormItem(props);
        const {
          mergedSizeRef,
          mergedDisabledRef
        } = formItem;
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedRef = computed(() => {
          return mergedValueRef.value === props.checkedValue;
        });
        const pressedRef = ref(false);
        const focusedRef = ref(false);
        const mergedRailStyleRef = computed(() => {
          const {
            railStyle
          } = props;
          if (!railStyle) return void 0;
          return railStyle({
            focused: focusedRef.value,
            checked: checkedRef.value
          });
        });
        function doUpdateValue(value) {
          const {
            "onUpdate:value": _onUpdateValue,
            onChange,
            onUpdateValue
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (_onUpdateValue) call(_onUpdateValue, value);
          if (onUpdateValue) call(onUpdateValue, value);
          if (onChange) call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doFocus() {
          const {
            nTriggerFormFocus
          } = formItem;
          nTriggerFormFocus();
        }
        function doBlur() {
          const {
            nTriggerFormBlur
          } = formItem;
          nTriggerFormBlur();
        }
        function handleClick() {
          if (props.loading || mergedDisabledRef.value) return;
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
        }
        function handleFocus() {
          focusedRef.value = true;
          doFocus();
        }
        function handleBlur() {
          focusedRef.value = false;
          doBlur();
          pressedRef.value = false;
        }
        function handleKeyup(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
            pressedRef.value = false;
          }
        }
        function handleKeydown(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            e.preventDefault();
            pressedRef.value = true;
          }
        }
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            self: {
              opacityDisabled,
              railColor,
              railColorActive,
              buttonBoxShadow,
              buttonColor,
              boxShadowFocus,
              loadingColor,
              textColor,
              iconColor,
              [createKey("buttonHeight", size2)]: buttonHeight,
              [createKey("buttonWidth", size2)]: buttonWidth,
              [createKey("buttonWidthPressed", size2)]: buttonWidthPressed,
              [createKey("railHeight", size2)]: railHeight,
              [createKey("railWidth", size2)]: railWidth,
              [createKey("railBorderRadius", size2)]: railBorderRadius,
              [createKey("buttonBorderRadius", size2)]: buttonBorderRadius
            },
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            }
          } = themeRef.value;
          let offset;
          let height;
          let width;
          if (supportCssMax) {
            offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
            height = `max(${railHeight}, ${buttonHeight})`;
            width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
          } else {
            offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
            height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
            width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
          }
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-color": buttonColor,
            "--n-button-width": buttonWidth,
            "--n-button-width-pressed": buttonWidthPressed,
            "--n-button-height": buttonHeight,
            "--n-height": height,
            "--n-offset": offset,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-border-radius": railBorderRadius,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-height": railHeight,
            "--n-rail-width": railWidth,
            "--n-width": width,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", computed(() => {
          return mergedSizeRef.value[0];
        }), cssVarsRef, props) : void 0;
        return {
          handleClick,
          handleBlur,
          handleFocus,
          handleKeyup,
          handleKeydown,
          mergedRailStyle: mergedRailStyleRef,
          pressed: pressedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          checked: checkedRef,
          mergedDisabled: mergedDisabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedDisabled,
          checked,
          mergedRailStyle,
          onRender,
          $slots
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const {
          checked: checkedSlot,
          unchecked: uncheckedSlot,
          icon: iconSlot,
          "checked-icon": checkedIconSlot,
          "unchecked-icon": uncheckedIconSlot
        } = $slots;
        const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
        return h("div", {
          role: "switch",
          "aria-checked": checked,
          class: [`${mergedClsPrefix}-switch`, this.themeClass, hasIcon && `${mergedClsPrefix}-switch--icon`, checked && `${mergedClsPrefix}-switch--active`, mergedDisabled && `${mergedClsPrefix}-switch--disabled`, this.round && `${mergedClsPrefix}-switch--round`, this.loading && `${mergedClsPrefix}-switch--loading`, this.pressed && `${mergedClsPrefix}-switch--pressed`, this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`],
          tabindex: !this.mergedDisabled ? 0 : void 0,
          style: this.cssVars,
          onClick: this.handleClick,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, h("div", {
          class: `${mergedClsPrefix}-switch__rail`,
          "aria-hidden": "true",
          style: mergedRailStyle
        }, resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
          if (checkedSlotChildren || uncheckedSlotChildren) {
            return h("div", {
              "aria-hidden": true,
              class: `${mergedClsPrefix}-switch__children-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), checkedSlotChildren), h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), uncheckedSlotChildren));
          }
          return null;
        })), h("div", {
          class: `${mergedClsPrefix}-switch__button`
        }, resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
          return h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              key: "loading",
              clsPrefix: mergedClsPrefix,
              strokeWidth: 20
            }) : this.checked && (checkedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: checkedIcon ? "checked-icon" : "icon"
            }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: uncheckedIcon ? "unchecked-icon" : "icon"
            }, uncheckedIcon || icon) : null
          });
        }))), resolveWrappedSlot(checkedSlot, (children) => children && h("div", {
          key: "checked",
          class: `${mergedClsPrefix}-switch__checked`
        }, children)), resolveWrappedSlot(uncheckedSlot, (children) => children && h("div", {
          key: "unchecked",
          class: `${mergedClsPrefix}-switch__unchecked`
        }, children)))));
      }
    });
    const self$1 = () => ({});
    const equationDark = {
      name: "Equation",
      common: derived$1,
      self: self$1
    };
    const floatButtonGroupDark = {
      name: "FloatButtonGroup",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          dividerColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          buttonBorderColor: dividerColor,
          borderRadiusSquare: borderRadius,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)"
        };
      }
    };
    const darkTheme = {
      name: "dark",
      common: derived$1,
      Alert: alertDark,
      Anchor: anchorDark,
      AutoComplete: autoCompleteDark,
      Avatar: avatarDark,
      AvatarGroup: avatarGroupDark,
      BackTop: backTopDark,
      Badge: badgeDark,
      Breadcrumb: breadcrumbDark,
      Button: buttonDark,
      ButtonGroup: buttonGroupDark,
      Calendar: calendarDark,
      Card: cardDark,
      Carousel: carouselDark,
      Cascader: cascaderDark,
      Checkbox: checkboxDark,
      Code: codeDark,
      Collapse: collapseDark,
      CollapseTransition: collapseTransitionDark,
      ColorPicker: colorPickerDark,
      DataTable: dataTableDark,
      DatePicker: datePickerDark,
      Descriptions: descriptionsDark,
      Dialog: dialogDark,
      Divider: dividerDark,
      Drawer: drawerDark,
      Dropdown: dropdownDark,
      DynamicInput: dynamicInputDark,
      DynamicTags: dynamicTagsDark,
      Element: elementDark,
      Empty: emptyDark,
      Ellipsis: ellipsisDark,
      Equation: equationDark,
      Flex: flexDark,
      Form: formItemDark,
      GradientText: gradientTextDark,
      Icon: iconDark$1,
      IconWrapper: iconDark,
      Image: imageDark,
      Input: inputDark,
      InputNumber: inputNumberDark,
      LegacyTransfer: transferDark,
      Layout: layoutDark,
      List: listDark$1,
      LoadingBar: loadingBarDark,
      Log: logDark,
      Menu: menuDark,
      Mention: listDark,
      Message: messageDark,
      Modal: modalDark,
      Notification: notificationDark,
      PageHeader: pageHeaderDark,
      Pagination: paginationDark,
      Popconfirm: popconfirmDark,
      Popover: popoverDark,
      Popselect: popselect,
      Progress: progressDark,
      QrCode: qrcodeDark,
      Radio: radioDark,
      Rate: rateDark,
      Result: resultDark,
      Row: rowDark,
      Scrollbar: scrollbarDark,
      Select: selectDark,
      Skeleton: skeletonDark,
      Slider: sliderDark,
      Space: spaceDark,
      Spin: spinDark,
      Statistic: statisticDark,
      Steps: stepsDark,
      Switch: switchDark,
      Table: tableDark,
      Tabs: tabsDark,
      Tag: tagDark,
      Thing: thingDark,
      TimePicker: timePickerDark,
      Timeline: timelineDark,
      Tooltip: tooltipDark,
      Transfer: transferDark$1,
      Tree: treeDark,
      TreeSelect: treeSelectDark,
      Typography: typographyDark,
      Upload: uploadDark,
      Watermark: watermarkDark,
      Split: splitDark,
      FloatButton: floatButtonDark,
      FloatButtonGroup: floatButtonGroupDark,
      Marquee: marqueeDark
    };
    const _imports_0 = "/yiitap/logo.png";
    var cg = Object.defineProperty;
    var ug = (t2, e, n) => e in t2 ? cg(t2, e, { enumerable: true, configurable: true, writable: true, value: n }) : t2[e] = n;
    var ft = (t2, e, n) => ug(t2, typeof e != "symbol" ? e + "" : e, n);
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function It(t2) {
      this.content = t2;
    }
    It.prototype = {
      constructor: It,
      find: function(t2) {
        for (var e = 0; e < this.content.length; e += 2)
          if (this.content[e] === t2) return e;
        return -1;
      },
      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(t2) {
        var e = this.find(t2);
        return e == -1 ? void 0 : this.content[e + 1];
      },
      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(t2, e, n) {
        var o = n && n != t2 ? this.remove(n) : this, i = o.find(t2), s = o.content.slice();
        return i == -1 ? s.push(n || t2, e) : (s[i + 1] = e, n && (s[i] = n)), new It(s);
      },
      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(t2) {
        var e = this.find(t2);
        if (e == -1) return this;
        var n = this.content.slice();
        return n.splice(e, 2), new It(n);
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(t2, e) {
        return new It([t2, e].concat(this.remove(t2).content));
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(t2, e) {
        var n = this.remove(t2).content.slice();
        return n.push(t2, e), new It(n);
      },
      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(t2, e, n) {
        var o = this.remove(e), i = o.content.slice(), s = o.find(t2);
        return i.splice(s == -1 ? i.length : s, 0, e, n), new It(i);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(t2) {
        for (var e = 0; e < this.content.length; e += 2)
          t2(this.content[e], this.content[e + 1]);
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(t2) {
        return t2 = It.from(t2), t2.size ? new It(t2.content.concat(this.subtract(t2).content)) : this;
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(t2) {
        return t2 = It.from(t2), t2.size ? new It(this.subtract(t2).content.concat(t2.content)) : this;
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(t2) {
        var e = this;
        t2 = It.from(t2);
        for (var n = 0; n < t2.content.length; n += 2)
          e = e.remove(t2.content[n]);
        return e;
      },
      // :: () → Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var t2 = {};
        return this.forEach(function(e, n) {
          t2[e] = n;
        }), t2;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    It.from = function(t2) {
      if (t2 instanceof It) return t2;
      var e = [];
      if (t2) for (var n in t2) e.push(n, t2[n]);
      return new It(e);
    };
    function fm(t2, e, n) {
      for (let o = 0; ; o++) {
        if (o == t2.childCount || o == e.childCount)
          return t2.childCount == e.childCount ? null : n;
        let i = t2.child(o), s = e.child(o);
        if (i == s) {
          n += i.nodeSize;
          continue;
        }
        if (!i.sameMarkup(s))
          return n;
        if (i.isText && i.text != s.text) {
          for (let r = 0; i.text[r] == s.text[r]; r++)
            n++;
          return n;
        }
        if (i.content.size || s.content.size) {
          let r = fm(i.content, s.content, n + 1);
          if (r != null)
            return r;
        }
        n += i.nodeSize;
      }
    }
    function _m(t2, e, n, o) {
      for (let i = t2.childCount, s = e.childCount; ; ) {
        if (i == 0 || s == 0)
          return i == s ? null : { a: n, b: o };
        let r = t2.child(--i), a = e.child(--s), l = r.nodeSize;
        if (r == a) {
          n -= l, o -= l;
          continue;
        }
        if (!r.sameMarkup(a))
          return { a: n, b: o };
        if (r.isText && r.text != a.text) {
          let c2 = 0, u = Math.min(r.text.length, a.text.length);
          for (; c2 < u && r.text[r.text.length - c2 - 1] == a.text[a.text.length - c2 - 1]; )
            c2++, n--, o--;
          return { a: n, b: o };
        }
        if (r.content.size || a.content.size) {
          let c2 = _m(r.content, a.content, n - 1, o - 1);
          if (c2)
            return c2;
        }
        n -= l, o -= l;
      }
    }
    class D {
      /**
      @internal
      */
      constructor(e, n) {
        if (this.content = e, this.size = n || 0, n == null)
          for (let o = 0; o < e.length; o++)
            this.size += e[o].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(e, n, o, i = 0, s) {
        for (let r = 0, a = 0; a < n; r++) {
          let l = this.content[r], c2 = a + l.nodeSize;
          if (c2 > e && o(l, i + a, s || null, r) !== false && l.content.size) {
            let u = a + 1;
            l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), o, i + u);
          }
          a = c2;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(e) {
        this.nodesBetween(0, this.size, e);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(e, n, o, i) {
        let s = "", r = true;
        return this.nodesBetween(e, n, (a, l) => {
          let c2 = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
          a.isBlock && (a.isLeaf && c2 || a.isTextblock) && o && (r ? r = false : s += o), s += c2;
        }, 0), s;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(e) {
        if (!e.size)
          return this;
        if (!this.size)
          return e;
        let n = this.lastChild, o = e.firstChild, i = this.content.slice(), s = 0;
        for (n.isText && n.sameMarkup(o) && (i[i.length - 1] = n.withText(n.text + o.text), s = 1); s < e.content.length; s++)
          i.push(e.content[s]);
        return new D(i, this.size + e.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(e, n = this.size) {
        if (e == 0 && n == this.size)
          return this;
        let o = [], i = 0;
        if (n > e)
          for (let s = 0, r = 0; r < n; s++) {
            let a = this.content[s], l = r + a.nodeSize;
            l > e && ((r < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - r), Math.min(a.text.length, n - r)) : a = a.cut(Math.max(0, e - r - 1), Math.min(a.content.size, n - r - 1))), o.push(a), i += a.nodeSize), r = l;
          }
        return new D(o, i);
      }
      /**
      @internal
      */
      cutByIndex(e, n) {
        return e == n ? D.empty : e == 0 && n == this.content.length ? this : new D(this.content.slice(e, n));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(e, n) {
        let o = this.content[e];
        if (o == n)
          return this;
        let i = this.content.slice(), s = this.size + n.nodeSize - o.nodeSize;
        return i[e] = n, new D(i, s);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(e) {
        return new D([e].concat(this.content), this.size + e.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(e) {
        return new D(this.content.concat(e), this.size + e.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(e) {
        if (this.content.length != e.content.length)
          return false;
        for (let n = 0; n < this.content.length; n++)
          if (!this.content[n].eq(e.content[n]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(e) {
        let n = this.content[e];
        if (!n)
          throw new RangeError("Index " + e + " out of range for " + this);
        return n;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content[e] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        for (let n = 0, o = 0; n < this.content.length; n++) {
          let i = this.content[n];
          e(i, o, n), o += i.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(e, n = 0) {
        return fm(this, e, n);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(e, n = this.size, o = e.size) {
        return _m(this, e, n, o);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(e, n = -1) {
        if (e == 0)
          return Qs(0, e);
        if (e == this.size)
          return Qs(this.content.length, e);
        if (e > this.size || e < 0)
          throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let o = 0, i = 0; ; o++) {
          let s = this.child(o), r = i + s.nodeSize;
          if (r >= e)
            return r == e || n > 0 ? Qs(o + 1, r) : Qs(o, i);
          i = r;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((e) => e.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          return D.empty;
        if (!Array.isArray(n))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new D(n.map(e.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(e) {
        if (!e.length)
          return D.empty;
        let n, o = 0;
        for (let i = 0; i < e.length; i++) {
          let s = e[i];
          o += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s);
        }
        return new D(n || e, o);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(e) {
        if (!e)
          return D.empty;
        if (e instanceof D)
          return e;
        if (Array.isArray(e))
          return this.fromArray(e);
        if (e.attrs)
          return new D([e], e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }
    D.empty = new D([], 0);
    const tl = { index: 0, offset: 0 };
    function Qs(t2, e) {
      return tl.index = t2, tl.offset = e, tl;
    }
    function Ir(t2, e) {
      if (t2 === e)
        return true;
      if (!(t2 && typeof t2 == "object") || !(e && typeof e == "object"))
        return false;
      let n = Array.isArray(t2);
      if (Array.isArray(e) != n)
        return false;
      if (n) {
        if (t2.length != e.length)
          return false;
        for (let o = 0; o < t2.length; o++)
          if (!Ir(t2[o], e[o]))
            return false;
      } else {
        for (let o in t2)
          if (!(o in e) || !Ir(t2[o], e[o]))
            return false;
        for (let o in e)
          if (!(o in t2))
            return false;
      }
      return true;
    }
    let Ze = class Bl {
      /**
      @internal
      */
      constructor(e, n) {
        this.type = e, this.attrs = n;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(e) {
        let n, o = false;
        for (let i = 0; i < e.length; i++) {
          let s = e[i];
          if (this.eq(s))
            return e;
          if (this.type.excludes(s.type))
            n || (n = e.slice(0, i));
          else {
            if (s.type.excludes(this.type))
              return e;
            !o && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), o = true), n && n.push(s);
          }
        }
        return n || (n = e.slice()), o || n.push(this), n;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(e) {
        for (let n = 0; n < e.length; n++)
          if (this.eq(e[n]))
            return e.slice(0, n).concat(e.slice(n + 1));
        return e;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(e) {
        for (let n = 0; n < e.length; n++)
          if (this.eq(e[n]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(e) {
        return this == e || this.type == e.type && Ir(this.attrs, e.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let n in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return e;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(e, n) {
        if (!n)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let o = e.marks[n.type];
        if (!o)
          throw new RangeError(`There is no mark type ${n.type} in this schema`);
        let i = o.create(n.attrs);
        return o.checkAttrs(i.attrs), i;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(e, n) {
        if (e == n)
          return true;
        if (e.length != n.length)
          return false;
        for (let o = 0; o < e.length; o++)
          if (!e[o].eq(n[o]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
          return Bl.none;
        if (e instanceof Bl)
          return [e];
        let n = e.slice();
        return n.sort((o, i) => o.type.rank - i.type.rank), n;
      }
    };
    Ze.none = [];
    class Dr extends Error {
    }
    class K {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragment—i.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(e, n, o) {
        this.content = e, this.openStart = n, this.openEnd = o;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(e, n) {
        let o = gm(this.content, e + this.openStart, n);
        return o && new K(o, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(e, n) {
        return new K(hm(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let e = { content: this.content.toJSON() };
        return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          return K.empty;
        let o = n.openStart || 0, i = n.openEnd || 0;
        if (typeof o != "number" || typeof i != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new K(D.fromJSON(e, n.content), o, i);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(e, n = true) {
        let o = 0, i = 0;
        for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
          o++;
        for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
          i++;
        return new K(e, o, i);
      }
    }
    K.empty = new K(D.empty, 0, 0);
    function hm(t2, e, n) {
      let { index: o, offset: i } = t2.findIndex(e), s = t2.maybeChild(o), { index: r, offset: a } = t2.findIndex(n);
      if (i == e || s.isText) {
        if (a != n && !t2.child(r).isText)
          throw new RangeError("Removing non-flat range");
        return t2.cut(0, e).append(t2.cut(n));
      }
      if (o != r)
        throw new RangeError("Removing non-flat range");
      return t2.replaceChild(o, s.copy(hm(s.content, e - i - 1, n - i - 1)));
    }
    function gm(t2, e, n, o) {
      let { index: i, offset: s } = t2.findIndex(e), r = t2.maybeChild(i);
      if (s == e || r.isText)
        return t2.cut(0, e).append(n).append(t2.cut(e));
      let a = gm(r.content, e - s - 1, n);
      return a && t2.replaceChild(i, r.copy(a));
    }
    function kg(t2, e, n) {
      if (n.openStart > t2.depth)
        throw new Dr("Inserted content deeper than insertion position");
      if (t2.depth - n.openStart != e.depth - n.openEnd)
        throw new Dr("Inconsistent open depths");
      return vm(t2, e, n, 0);
    }
    function vm(t2, e, n, o) {
      let i = t2.index(o), s = t2.node(o);
      if (i == e.index(o) && o < t2.depth - n.openStart) {
        let r = vm(t2, e, n, o + 1);
        return s.copy(s.content.replaceChild(i, r));
      } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t2.depth == o && e.depth == o) {
          let r = t2.parent, a = r.content;
          return Qo(r, a.cut(0, t2.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
        } else {
          let { start: r, end: a } = yg(n, t2);
          return Qo(s, km(t2, r, a, e, o));
        }
      else return Qo(s, Lr(t2, e, o));
    }
    function bm(t2, e) {
      if (!e.type.compatibleContent(t2.type))
        throw new Dr("Cannot join " + e.type.name + " onto " + t2.type.name);
    }
    function $l(t2, e, n) {
      let o = t2.node(n);
      return bm(o, e.node(n)), o;
    }
    function Zo(t2, e) {
      let n = e.length - 1;
      n >= 0 && t2.isText && t2.sameMarkup(e[n]) ? e[n] = t2.withText(e[n].text + t2.text) : e.push(t2);
    }
    function rs(t2, e, n, o) {
      let i = (e || t2).node(n), s = 0, r = e ? e.index(n) : i.childCount;
      t2 && (s = t2.index(n), t2.depth > n ? s++ : t2.textOffset && (Zo(t2.nodeAfter, o), s++));
      for (let a = s; a < r; a++)
        Zo(i.child(a), o);
      e && e.depth == n && e.textOffset && Zo(e.nodeBefore, o);
    }
    function Qo(t2, e) {
      return t2.type.checkContent(e), t2.copy(e);
    }
    function km(t2, e, n, o, i) {
      let s = t2.depth > i && $l(t2, e, i + 1), r = o.depth > i && $l(n, o, i + 1), a = [];
      return rs(null, t2, i, a), s && r && e.index(i) == n.index(i) ? (bm(s, r), Zo(Qo(s, km(t2, e, n, o, i + 1)), a)) : (s && Zo(Qo(s, Lr(t2, e, i + 1)), a), rs(e, n, i, a), r && Zo(Qo(r, Lr(n, o, i + 1)), a)), rs(o, null, i, a), new D(a);
    }
    function Lr(t2, e, n) {
      let o = [];
      if (rs(null, t2, n, o), t2.depth > n) {
        let i = $l(t2, e, n + 1);
        Zo(Qo(i, Lr(t2, e, n + 1)), o);
      }
      return rs(e, null, n, o), new D(o);
    }
    function yg(t2, e) {
      let n = e.depth - t2.openStart, i = e.node(n).copy(t2.content);
      for (let s = n - 1; s >= 0; s--)
        i = e.node(s).copy(D.from(i));
      return {
        start: i.resolveNoCache(t2.openStart + n),
        end: i.resolveNoCache(i.content.size - t2.openEnd - n)
      };
    }
    class bs {
      /**
      @internal
      */
      constructor(e, n, o) {
        this.pos = e, this.path = n, this.parentOffset = o, this.depth = n.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parent—text nodes are ‘flat’ in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(e) {
        return this.path[this.resolveDepth(e) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(e) {
        return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(e) {
        return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(e) {
        return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let e = this.parent, n = this.index(this.depth);
        if (n == e.childCount)
          return null;
        let o = this.pos - this.path[this.path.length - 1], i = e.child(n);
        return o ? e.child(n).cut(o) : i;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(e, n) {
        n = this.resolveDepth(n);
        let o = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let s = 0; s < e; s++)
          i += o.child(s).nodeSize;
        return i;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let e = this.parent, n = this.index();
        if (e.content.size == 0)
          return Ze.none;
        if (this.textOffset)
          return e.child(n).marks;
        let o = e.maybeChild(n - 1), i = e.maybeChild(n);
        if (!o) {
          let a = o;
          o = i, i = a;
        }
        let s = o.marks;
        for (var r = 0; r < s.length; r++)
          s[r].type.spec.inclusive === false && (!i || !s[r].isInSet(i.marks)) && (s = s[r--].removeFromSet(s));
        return s;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross(e) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
          return null;
        let o = n.marks, i = e.parent.maybeChild(e.index());
        for (var s = 0; s < o.length; s++)
          o[s].type.spec.inclusive === false && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
        return o;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(e) {
        for (let n = this.depth; n > 0; n--)
          if (this.start(n) <= e && this.end(n) >= e)
            return n;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(e = this, n) {
        if (e.pos < this.pos)
          return e.blockRange(this);
        for (let o = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); o >= 0; o--)
          if (e.pos <= this.end(o) && (!n || n(this.node(o))))
            return new Pr(this, e, o);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(e) {
        return e.pos > this.pos ? e : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(e) {
        return e.pos < this.pos ? e : this;
      }
      /**
      @internal
      */
      toString() {
        let e = "";
        for (let n = 1; n <= this.depth; n++)
          e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return e + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(e, n) {
        if (!(n >= 0 && n <= e.content.size))
          throw new RangeError("Position " + n + " out of range");
        let o = [], i = 0, s = n;
        for (let r = e; ; ) {
          let { index: a, offset: l } = r.content.findIndex(s), c2 = s - l;
          if (o.push(r, a, i + l), !c2 || (r = r.child(a), r.isText))
            break;
          s = c2 - 1, i += l + 1;
        }
        return new bs(n, o, s);
      }
      /**
      @internal
      */
      static resolveCached(e, n) {
        let o = Uu.get(e);
        if (o)
          for (let s = 0; s < o.elts.length; s++) {
            let r = o.elts[s];
            if (r.pos == n)
              return r;
          }
        else
          Uu.set(e, o = new wg());
        let i = o.elts[o.i] = bs.resolve(e, n);
        return o.i = (o.i + 1) % jg, i;
      }
    }
    class wg {
      constructor() {
        this.elts = [], this.i = 0;
      }
    }
    const jg = 12, Uu = /* @__PURE__ */ new WeakMap();
    class Pr {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor(e, n, o) {
        this.$from = e, this.$to = n, this.depth = o;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    }
    const Eg = /* @__PURE__ */ Object.create(null);
    let Mo = class zl {
      /**
      @internal
      */
      constructor(e, n, o, i = Ze.none) {
        this.type = e, this.attrs = n, this.marks = i, this.content = o || D.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(e) {
        return this.content.child(e);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content.maybeChild(e);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        this.content.forEach(e);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(e, n, o, i = 0) {
        this.content.nodesBetween(e, n, o, i, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(e) {
        this.nodesBetween(0, this.content.size, e);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(e, n, o, i) {
        return this.content.textBetween(e, n, o, i);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(e, n, o) {
        return this.type == e && Ir(this.attrs, n || e.defaultAttrs || Eg) && Ze.sameSet(this.marks, o || Ze.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(e = null) {
        return e == this.content ? this : new zl(this.type, this.attrs, e, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(e) {
        return e == this.marks ? this : new zl(this.type, this.attrs, this.content, e);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(e, n = this.content.size) {
        return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(e, n = this.content.size, o = false) {
        if (e == n)
          return K.empty;
        let i = this.resolve(e), s = this.resolve(n), r = o ? 0 : i.sharedDepth(n), a = i.start(r), c2 = i.node(r).content.cut(i.pos - a, s.pos - a);
        return new K(c2, i.depth - r, s.depth - r);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(e, n, o) {
        return kg(this.resolve(e), this.resolve(n), o);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(e) {
        for (let n = this; ; ) {
          let { index: o, offset: i } = n.content.findIndex(e);
          if (n = n.maybeChild(o), !n)
            return null;
          if (i == e || n.isText)
            return n;
          e -= i + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(e) {
        let { index: n, offset: o } = this.content.findIndex(e);
        return { node: this.content.maybeChild(n), index: n, offset: o };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(e) {
        if (e == 0)
          return { node: null, index: 0, offset: 0 };
        let { index: n, offset: o } = this.content.findIndex(e);
        if (o < e)
          return { node: this.content.child(n), index: n, offset: o };
        let i = this.content.child(n - 1);
        return { node: i, index: n - 1, offset: o - i.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(e) {
        return bs.resolveCached(this, e);
      }
      /**
      @internal
      */
      resolveNoCache(e) {
        return bs.resolve(this, e);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(e, n, o) {
        let i = false;
        return n > e && this.nodesBetween(e, n, (s) => (o.isInSet(s.marks) && (i = true), !i)), i;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"), ym(this.marks, e);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(e) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!n)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return n;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(e, n, o = D.empty, i = 0, s = o.childCount) {
        let r = this.contentMatchAt(e).matchFragment(o, i, s), a = r && r.matchFragment(this.content, n);
        if (!a || !a.validEnd)
          return false;
        for (let l = i; l < s; l++)
          if (!this.type.allowsMarks(o.child(l).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(e, n, o, i) {
        if (i && !this.type.allowsMarks(i))
          return false;
        let s = this.contentMatchAt(e).matchType(o), r = s && s.matchFragment(this.content, n);
        return r ? r.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
        let e = Ze.none;
        for (let n = 0; n < this.marks.length; n++) {
          let o = this.marks[n];
          o.type.checkAttrs(o.attrs), e = o.addToSet(e);
        }
        if (!Ze.sameSet(e, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
        this.content.forEach((n) => n.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let n in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(e, n) {
        if (!n)
          throw new RangeError("Invalid input for Node.fromJSON");
        let o;
        if (n.marks) {
          if (!Array.isArray(n.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          o = n.marks.map(e.markFromJSON);
        }
        if (n.type == "text") {
          if (typeof n.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return e.text(n.text, o);
        }
        let i = D.fromJSON(e, n.content), s = e.nodeType(n.type).create(n.attrs, i, o);
        return s.type.checkAttrs(s.attrs), s;
      }
    };
    Mo.prototype.text = void 0;
    class Br extends Mo {
      /**
      @internal
      */
      constructor(e, n, o, i) {
        if (super(e, n, null, i), !o)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = o;
      }
      toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : ym(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(e, n) {
        return this.text.slice(e, n);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(e) {
        return e == this.marks ? this : new Br(this.type, this.attrs, this.text, e);
      }
      withText(e) {
        return e == this.text ? this : new Br(this.type, this.attrs, e, this.marks);
      }
      cut(e = 0, n = this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
      }
      eq(e) {
        return this.sameMarkup(e) && this.text == e.text;
      }
      toJSON() {
        let e = super.toJSON();
        return e.text = this.text, e;
      }
    }
    function ym(t2, e) {
      for (let n = t2.length - 1; n >= 0; n--)
        e = t2[n].type.name + "(" + e + ")";
      return e;
    }
    class ri {
      /**
      @internal
      */
      constructor(e) {
        this.validEnd = e, this.next = [], this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(e, n) {
        let o = new Sg(e, n);
        if (o.next == null)
          return ri.empty;
        let i = wm(o);
        o.next && o.err("Unexpected trailing text");
        let s = Mg(Ag(i));
        return Rg(s, o), s;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(e) {
        for (let n = 0; n < this.next.length; n++)
          if (this.next[n].type == e)
            return this.next[n].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(e, n = 0, o = e.childCount) {
        let i = this;
        for (let s = n; i && s < o; s++)
          i = i.matchType(e.child(s).type);
        return i;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
          let { type: n } = this.next[e];
          if (!(n.isText || n.hasRequiredAttrs()))
            return n;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(e) {
        for (let n = 0; n < this.next.length; n++)
          for (let o = 0; o < e.next.length; o++)
            if (this.next[n].type == e.next[o].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(e, n = false, o = 0) {
        let i = [this];
        function s(r, a) {
          let l = r.matchFragment(e, o);
          if (l && (!n || l.validEnd))
            return D.from(a.map((c2) => c2.createAndFill()));
          for (let c2 = 0; c2 < r.next.length; c2++) {
            let { type: u, next: d } = r.next[c2];
            if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(d) == -1) {
              i.push(d);
              let p2 = s(d, a.concat(u));
              if (p2)
                return p2;
            }
          }
          return null;
        }
        return s(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(e) {
        for (let o = 0; o < this.wrapCache.length; o += 2)
          if (this.wrapCache[o] == e)
            return this.wrapCache[o + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n), n;
      }
      /**
      @internal
      */
      computeWrapping(e) {
        let n = /* @__PURE__ */ Object.create(null), o = [{ match: this, type: null, via: null }];
        for (; o.length; ) {
          let i = o.shift(), s = i.match;
          if (s.matchType(e)) {
            let r = [];
            for (let a = i; a.type; a = a.via)
              r.push(a.type);
            return r.reverse();
          }
          for (let r = 0; r < s.next.length; r++) {
            let { type: a, next: l } = s.next[r];
            !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || l.validEnd) && (o.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = true);
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_​th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(e) {
        if (e >= this.next.length)
          throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e];
      }
      /**
      @internal
      */
      toString() {
        let e = [];
        function n(o) {
          e.push(o);
          for (let i = 0; i < o.next.length; i++)
            e.indexOf(o.next[i].next) == -1 && n(o.next[i].next);
        }
        return n(this), e.map((o, i) => {
          let s = i + (o.validEnd ? "*" : " ") + " ";
          for (let r = 0; r < o.next.length; r++)
            s += (r ? ", " : "") + o.next[r].type.name + "->" + e.indexOf(o.next[r].next);
          return s;
        }).join(`
`);
      }
    }
    ri.empty = new ri(true);
    class Sg {
      constructor(e, n) {
        this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(e) {
        return this.next == e && (this.pos++ || true);
      }
      err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')");
      }
    }
    function wm(t2) {
      let e = [];
      do
        e.push(Cg(t2));
      while (t2.eat("|"));
      return e.length == 1 ? e[0] : { type: "choice", exprs: e };
    }
    function Cg(t2) {
      let e = [];
      do
        e.push(xg(t2));
      while (t2.next && t2.next != ")" && t2.next != "|");
      return e.length == 1 ? e[0] : { type: "seq", exprs: e };
    }
    function xg(t2) {
      let e = Ng(t2);
      for (; ; )
        if (t2.eat("+"))
          e = { type: "plus", expr: e };
        else if (t2.eat("*"))
          e = { type: "star", expr: e };
        else if (t2.eat("?"))
          e = { type: "opt", expr: e };
        else if (t2.eat("{"))
          e = Tg(t2, e);
        else
          break;
      return e;
    }
    function Vu(t2) {
      /\D/.test(t2.next) && t2.err("Expected number, got '" + t2.next + "'");
      let e = Number(t2.next);
      return t2.pos++, e;
    }
    function Tg(t2, e) {
      let n = Vu(t2), o = n;
      return t2.eat(",") && (t2.next != "}" ? o = Vu(t2) : o = -1), t2.eat("}") || t2.err("Unclosed braced range"), { type: "range", min: n, max: o, expr: e };
    }
    function Og(t2, e) {
      let n = t2.nodeTypes, o = n[e];
      if (o)
        return [o];
      let i = [];
      for (let s in n) {
        let r = n[s];
        r.isInGroup(e) && i.push(r);
      }
      return i.length == 0 && t2.err("No node type or group '" + e + "' found"), i;
    }
    function Ng(t2) {
      if (t2.eat("(")) {
        let e = wm(t2);
        return t2.eat(")") || t2.err("Missing closing paren"), e;
      } else if (/\W/.test(t2.next))
        t2.err("Unexpected token '" + t2.next + "'");
      else {
        let e = Og(t2, t2.next).map((n) => (t2.inline == null ? t2.inline = n.isInline : t2.inline != n.isInline && t2.err("Mixing inline and block content"), { type: "name", value: n }));
        return t2.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
      }
    }
    function Ag(t2) {
      let e = [[]];
      return i(s(t2, 0), n()), e;
      function n() {
        return e.push([]) - 1;
      }
      function o(r, a, l) {
        let c2 = { term: l, to: a };
        return e[r].push(c2), c2;
      }
      function i(r, a) {
        r.forEach((l) => l.to = a);
      }
      function s(r, a) {
        if (r.type == "choice")
          return r.exprs.reduce((l, c2) => l.concat(s(c2, a)), []);
        if (r.type == "seq")
          for (let l = 0; ; l++) {
            let c2 = s(r.exprs[l], a);
            if (l == r.exprs.length - 1)
              return c2;
            i(c2, a = n());
          }
        else if (r.type == "star") {
          let l = n();
          return o(a, l), i(s(r.expr, l), l), [o(l)];
        } else if (r.type == "plus") {
          let l = n();
          return i(s(r.expr, a), l), i(s(r.expr, l), l), [o(l)];
        } else {
          if (r.type == "opt")
            return [o(a)].concat(s(r.expr, a));
          if (r.type == "range") {
            let l = a;
            for (let c2 = 0; c2 < r.min; c2++) {
              let u = n();
              i(s(r.expr, l), u), l = u;
            }
            if (r.max == -1)
              i(s(r.expr, l), l);
            else
              for (let c2 = r.min; c2 < r.max; c2++) {
                let u = n();
                o(l, u), i(s(r.expr, l), u), l = u;
              }
            return [o(l)];
          } else {
            if (r.type == "name")
              return [o(a, void 0, r.value)];
            throw new Error("Unknown expr type");
          }
        }
      }
    }
    function jm(t2, e) {
      return e - t2;
    }
    function qu(t2, e) {
      let n = [];
      return o(e), n.sort(jm);
      function o(i) {
        let s = t2[i];
        if (s.length == 1 && !s[0].term)
          return o(s[0].to);
        n.push(i);
        for (let r = 0; r < s.length; r++) {
          let { term: a, to: l } = s[r];
          !a && n.indexOf(l) == -1 && o(l);
        }
      }
    }
    function Mg(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      return n(qu(t2, 0));
      function n(o) {
        let i = [];
        o.forEach((r) => {
          t2[r].forEach(({ term: a, to: l }) => {
            if (!a)
              return;
            let c2;
            for (let u = 0; u < i.length; u++)
              i[u][0] == a && (c2 = i[u][1]);
            qu(t2, l).forEach((u) => {
              c2 || i.push([a, c2 = []]), c2.indexOf(u) == -1 && c2.push(u);
            });
          });
        });
        let s = e[o.join(",")] = new ri(o.indexOf(t2.length - 1) > -1);
        for (let r = 0; r < i.length; r++) {
          let a = i[r][1].sort(jm);
          s.next.push({ type: i[r][0], next: e[a.join(",")] || n(a) });
        }
        return s;
      }
    }
    function Rg(t2, e) {
      for (let n = 0, o = [t2]; n < o.length; n++) {
        let i = o[n], s = !i.validEnd, r = [];
        for (let a = 0; a < i.next.length; a++) {
          let { type: l, next: c2 } = i.next[a];
          r.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = false), o.indexOf(c2) == -1 && o.push(c2);
        }
        s && e.err("Only non-generatable nodes (" + r.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function Em(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let n in t2) {
        let o = t2[n];
        if (!o.hasDefault)
          return null;
        e[n] = o.default;
      }
      return e;
    }
    function Sm(t2, e) {
      let n = /* @__PURE__ */ Object.create(null);
      for (let o in t2) {
        let i = e && e[o];
        if (i === void 0) {
          let s = t2[o];
          if (s.hasDefault)
            i = s.default;
          else
            throw new RangeError("No value supplied for attribute " + o);
        }
        n[o] = i;
      }
      return n;
    }
    function Cm(t2, e, n, o) {
      for (let i in e)
        if (!(i in t2))
          throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
      for (let i in t2) {
        let s = t2[i];
        s.validate && s.validate(e[i]);
      }
    }
    function xm(t2, e) {
      let n = /* @__PURE__ */ Object.create(null);
      if (e)
        for (let o in e)
          n[o] = new Dg(t2, o, e[o]);
      return n;
    }
    let Ku = class Tm {
      /**
      @internal
      */
      constructor(e, n, o) {
        this.name = e, this.schema = n, this.spec = o, this.markSet = null, this.groups = o.group ? o.group.split(" ") : [], this.attrs = xm(e, o.attrs), this.defaultAttrs = Em(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(o.inline || e == "text"), this.isText = e == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == ri.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(e) {
        return this.groups.indexOf(e) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let e in this.attrs)
          if (this.attrs[e].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : Sm(this.attrs, e);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(e = null, n, o) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Mo(this, this.computeAttrs(e), D.from(n), Ze.setFrom(o));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(e = null, n, o) {
        return n = D.from(n), this.checkContent(n), new Mo(this, this.computeAttrs(e), n, Ze.setFrom(o));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(e = null, n, o) {
        if (e = this.computeAttrs(e), n = D.from(n), n.size) {
          let r = this.contentMatch.fillBefore(n);
          if (!r)
            return null;
          n = r.append(n);
        }
        let i = this.contentMatch.matchFragment(n), s = i && i.fillBefore(D.empty, true);
        return s ? new Mo(this, e, n.append(s), Ze.setFrom(o)) : null;
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(e) {
        let n = this.contentMatch.matchFragment(e);
        if (!n || !n.validEnd)
          return false;
        for (let o = 0; o < e.childCount; o++)
          if (!this.allowsMarks(e.child(o).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(e) {
        if (!this.validContent(e))
          throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Cm(this.attrs, e, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(e) {
        if (this.markSet == null)
          return true;
        for (let n = 0; n < e.length; n++)
          if (!this.allowsMarkType(e[n].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(e) {
        if (this.markSet == null)
          return e;
        let n;
        for (let o = 0; o < e.length; o++)
          this.allowsMarkType(e[o].type) ? n && n.push(e[o]) : n || (n = e.slice(0, o));
        return n ? n.length ? n : Ze.none : e;
      }
      /**
      @internal
      */
      static compile(e, n) {
        let o = /* @__PURE__ */ Object.create(null);
        e.forEach((s, r) => o[s] = new Tm(s, n, r));
        let i = n.spec.topNode || "doc";
        if (!o[i])
          throw new RangeError("Schema is missing its top node type ('" + i + "')");
        if (!o.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let s in o.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return o;
      }
    };
    function Ig(t2, e, n) {
      let o = n.split("|");
      return (i) => {
        let s = i === null ? "null" : typeof i;
        if (o.indexOf(s) < 0)
          throw new RangeError(`Expected value of type ${o} for attribute ${e} on type ${t2}, got ${s}`);
      };
    }
    class Dg {
      constructor(e, n, o) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(o, "default"), this.default = o.default, this.validate = typeof o.validate == "string" ? Ig(e, n, o.validate) : o.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    }
    class Ta {
      /**
      @internal
      */
      constructor(e, n, o, i) {
        this.name = e, this.rank = n, this.schema = o, this.spec = i, this.attrs = xm(e, i.attrs), this.excluded = null;
        let s = Em(this.attrs);
        this.instance = s ? new Ze(this, s) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(e = null) {
        return !e && this.instance ? this.instance : new Ze(this, Sm(this.attrs, e));
      }
      /**
      @internal
      */
      static compile(e, n) {
        let o = /* @__PURE__ */ Object.create(null), i = 0;
        return e.forEach((s, r) => o[s] = new Ta(s, i++, n, r)), o;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(e) {
        for (var n = 0; n < e.length; n++)
          e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
        return e;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(e) {
        for (let n = 0; n < e.length; n++)
          if (e[n].type == this)
            return e[n];
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Cm(this.attrs, e, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(e) {
        return this.excluded.indexOf(e) > -1;
      }
    }
    class Om {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(e) {
        this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
        let n = this.spec = {};
        for (let i in e)
          n[i] = e[i];
        n.nodes = It.from(e.nodes), n.marks = It.from(e.marks || {}), this.nodes = Ku.compile(this.spec.nodes, this), this.marks = Ta.compile(this.spec.marks, this);
        let o = /* @__PURE__ */ Object.create(null);
        for (let i in this.nodes) {
          if (i in this.marks)
            throw new RangeError(i + " can not be both a node and a mark");
          let s = this.nodes[i], r = s.spec.content || "", a = s.spec.marks;
          if (s.contentMatch = o[r] || (o[r] = ri.parse(r, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!s.isInline || !s.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = s;
          }
          s.markSet = a == "_" ? null : a ? Wu(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
        }
        for (let i in this.marks) {
          let s = this.marks[i], r = s.spec.excludes;
          s.excluded = r == null ? [s] : r == "" ? [] : Wu(this, r.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(e, n = null, o, i) {
        if (typeof e == "string")
          e = this.nodeType(e);
        else if (e instanceof Ku) {
          if (e.schema != this)
            throw new RangeError("Node type from different schema used (" + e.name + ")");
        } else throw new RangeError("Invalid node type: " + e);
        return e.createChecked(n, o, i);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(e, n) {
        let o = this.nodes.text;
        return new Br(o, o.defaultAttrs, e, Ze.setFrom(n));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(e, n) {
        return typeof e == "string" && (e = this.marks[e]), e.create(n);
      }
      /**
      Deserialize a node from its JSON representation. This method is
      bound.
      */
      nodeFromJSON(e) {
        return Mo.fromJSON(this, e);
      }
      /**
      Deserialize a mark from its JSON representation. This method is
      bound.
      */
      markFromJSON(e) {
        return Ze.fromJSON(this, e);
      }
      /**
      @internal
      */
      nodeType(e) {
        let n = this.nodes[e];
        if (!n)
          throw new RangeError("Unknown node type: " + e);
        return n;
      }
    }
    function Wu(t2, e) {
      let n = [];
      for (let o = 0; o < e.length; o++) {
        let i = e[o], s = t2.marks[i], r = s;
        if (s)
          n.push(s);
        else
          for (let a in t2.marks) {
            let l = t2.marks[a];
            (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(r = l);
          }
        if (!r)
          throw new SyntaxError("Unknown mark type: '" + e[o] + "'");
      }
      return n;
    }
    function Lg(t2) {
      return t2.tag != null;
    }
    function Pg(t2) {
      return t2.style != null;
    }
    let as = class Fl {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(e, n) {
        this.schema = e, this.rules = n, this.tags = [], this.styles = [];
        let o = this.matchedStyles = [];
        n.forEach((i) => {
          if (Lg(i))
            this.tags.push(i);
          else if (Pg(i)) {
            let s = /[^=]*/.exec(i.style)[0];
            o.indexOf(s) < 0 && o.push(s), this.styles.push(i);
          }
        }), this.normalizeLists = !this.tags.some((i) => {
          if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
            return false;
          let s = e.nodes[i.node];
          return s.contentMatch.matchType(s);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(e, n = {}) {
        let o = new Ju(this, n, false);
        return o.addAll(e, Ze.none, n.from, n.to), o.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(e, n = {}) {
        let o = new Ju(this, n, true);
        return o.addAll(e, Ze.none, n.from, n.to), K.maxOpen(o.finish());
      }
      /**
      @internal
      */
      matchTag(e, n, o) {
        for (let i = o ? this.tags.indexOf(o) + 1 : 0; i < this.tags.length; i++) {
          let s = this.tags[i];
          if (zg(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
            if (s.getAttrs) {
              let r = s.getAttrs(e);
              if (r === false)
                continue;
              s.attrs = r || void 0;
            }
            return s;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(e, n, o, i) {
        for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
          let r = this.styles[s], a = r.style;
          if (!(a.indexOf(e) != 0 || r.context && !o.matchesContext(r.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
            if (r.getAttrs) {
              let l = r.getAttrs(n);
              if (l === false)
                continue;
              r.attrs = l || void 0;
            }
            return r;
          }
        }
      }
      /**
      @internal
      */
      static schemaRules(e) {
        let n = [];
        function o(i) {
          let s = i.priority == null ? 50 : i.priority, r = 0;
          for (; r < n.length; r++) {
            let a = n[r];
            if ((a.priority == null ? 50 : a.priority) < s)
              break;
          }
          n.splice(r, 0, i);
        }
        for (let i in e.marks) {
          let s = e.marks[i].spec.parseDOM;
          s && s.forEach((r) => {
            o(r = Yu(r)), r.mark || r.ignore || r.clearMark || (r.mark = i);
          });
        }
        for (let i in e.nodes) {
          let s = e.nodes[i].spec.parseDOM;
          s && s.forEach((r) => {
            o(r = Yu(r)), r.node || r.ignore || r.mark || (r.node = i);
          });
        }
        return n;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new Fl(e, Fl.schemaRules(e)));
      }
    };
    const Nm = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    }, Bg = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    }, Am = { ol: true, ul: true }, ks = 1, Hl = 2, jr = 4;
    function Gu(t2, e, n) {
      return e != null ? (e ? ks : 0) | (e === "full" ? Hl : 0) : t2 && t2.whitespace == "pre" ? ks | Hl : n & -5;
    }
    class er {
      constructor(e, n, o, i, s, r) {
        this.type = e, this.attrs = n, this.marks = o, this.solid = i, this.options = r, this.content = [], this.activeMarks = Ze.none, this.match = s || (r & jr ? null : e.contentMatch);
      }
      findWrapping(e) {
        if (!this.match) {
          if (!this.type)
            return [];
          let n = this.type.contentMatch.fillBefore(D.from(e));
          if (n)
            this.match = this.type.contentMatch.matchFragment(n);
          else {
            let o = this.type.contentMatch, i;
            return (i = o.findWrapping(e.type)) ? (this.match = o, i) : null;
          }
        }
        return this.match.findWrapping(e.type);
      }
      finish(e) {
        if (!(this.options & ks)) {
          let o = this.content[this.content.length - 1], i;
          if (o && o.isText && (i = /[ \t\r\n\u000c]+$/.exec(o.text))) {
            let s = o;
            o.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
          }
        }
        let n = D.from(this.content);
        return !e && this.match && (n = n.append(this.match.fillBefore(D.empty, true))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
      }
      inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Nm.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
      }
    }
    class Ju {
      constructor(e, n, o) {
        this.parser = e, this.options = n, this.isOpen = o, this.open = 0, this.localPreserveWS = false;
        let i = n.topNode, s, r = Gu(null, n.preserveWhitespace, 0) | (o ? jr : 0);
        i ? s = new er(i.type, i.attrs, Ze.none, true, n.topMatch || i.type.contentMatch, r) : o ? s = new er(null, null, Ze.none, true, null, r) : s = new er(e.schema.topNodeType, null, Ze.none, true, null, r), this.nodes = [s], this.find = n.findPositions, this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(e, n) {
        e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
      }
      addTextNode(e, n) {
        let o = e.nodeValue, i = this.top, s = i.options & Hl ? "full" : this.localPreserveWS || (i.options & ks) > 0;
        if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(o)) {
          if (s)
            s !== "full" ? o = o.replace(/\r?\n|\r/g, " ") : o = o.replace(/\r\n?/g, `
`);
          else if (o = o.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(o) && this.open == this.nodes.length - 1) {
            let r = i.content[i.content.length - 1], a = e.previousSibling;
            (!r || a && a.nodeName == "BR" || r.isText && /[ \t\r\n\u000c]$/.test(r.text)) && (o = o.slice(1));
          }
          o && this.insertNode(this.parser.schema.text(o), n), this.findInText(e);
        } else
          this.findInside(e);
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(e, n, o) {
        let i = this.localPreserveWS, s = this.top;
        (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
        let r = e.nodeName.toLowerCase(), a;
        Am.hasOwnProperty(r) && this.parser.normalizeLists && $g(e);
        let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, o));
        e: if (l ? l.ignore : Bg.hasOwnProperty(r))
          this.findInside(e), this.ignoreFallback(e, n);
        else if (!l || l.skip || l.closeParent) {
          l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
          let c2, u = this.needsBlock;
          if (Nm.hasOwnProperty(r))
            s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c2 = true, s.type || (this.needsBlock = true);
          else if (!e.firstChild) {
            this.leafFallback(e, n);
            break e;
          }
          let d = l && l.skip ? n : this.readStyles(e, n);
          d && this.addAll(e, d), c2 && this.sync(s), this.needsBlock = u;
        } else {
          let c2 = this.readStyles(e, n);
          c2 && this.addElementByRule(e, l, c2, l.consuming === false ? a : void 0);
        }
        this.localPreserveWS = i;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(e, n) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
      }
      // Called for ignored nodes
      ignoreFallback(e, n) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(e, n) {
        let o = e.style;
        if (o && o.length)
          for (let i = 0; i < this.parser.matchedStyles.length; i++) {
            let s = this.parser.matchedStyles[i], r = o.getPropertyValue(s);
            if (r)
              for (let a = void 0; ; ) {
                let l = this.parser.matchStyle(s, r, this, a);
                if (!l)
                  break;
                if (l.ignore)
                  return null;
                if (l.clearMark ? n = n.filter((c2) => !l.clearMark(c2)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === false)
                  a = l;
                else
                  break;
              }
          }
        return n;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(e, n, o, i) {
        let s, r;
        if (n.node)
          if (r = this.parser.schema.nodes[n.node], r.isLeaf)
            this.insertNode(r.create(n.attrs), o) || this.leafFallback(e, o);
          else {
            let l = this.enter(r, n.attrs || null, o, n.preserveWhitespace);
            l && (s = true, o = l);
          }
        else {
          let l = this.parser.schema.marks[n.mark];
          o = o.concat(l.create(n.attrs));
        }
        let a = this.top;
        if (r && r.isLeaf)
          this.findInside(e);
        else if (i)
          this.addElement(e, o, i);
        else if (n.getContent)
          this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, o));
        else {
          let l = e;
          typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, true), this.addAll(l, o), this.findAround(e, l, false);
        }
        s && this.sync(a) && this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(e, n, o, i) {
        let s = o || 0;
        for (let r = o ? e.childNodes[o] : e.firstChild, a = i == null ? null : e.childNodes[i]; r != a; r = r.nextSibling, ++s)
          this.findAtPoint(e, s), this.addDOM(r, n);
        this.findAtPoint(e, s);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(e, n) {
        let o, i;
        for (let s = this.open; s >= 0; s--) {
          let r = this.nodes[s], a = r.findWrapping(e);
          if (a && (!o || o.length > a.length) && (o = a, i = r, !a.length) || r.solid)
            break;
        }
        if (!o)
          return null;
        this.sync(i);
        for (let s = 0; s < o.length; s++)
          n = this.enterInner(o[s], null, n, false);
        return n;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(e, n) {
        if (e.isInline && this.needsBlock && !this.top.type) {
          let i = this.textblockFromContext();
          i && (n = this.enterInner(i, null, n));
        }
        let o = this.findPlace(e, n);
        if (o) {
          this.closeExtra();
          let i = this.top;
          i.match && (i.match = i.match.matchType(e.type));
          let s = Ze.none;
          for (let r of o.concat(e.marks))
            (i.type ? i.type.allowsMarkType(r.type) : Xu(r.type, e.type)) && (s = r.addToSet(s));
          return i.content.push(e.mark(s)), true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(e, n, o, i) {
        let s = this.findPlace(e.create(n), o);
        return s && (s = this.enterInner(e, n, o, true, i)), s;
      }
      // Open a node of the given type
      enterInner(e, n, o, i = false, s) {
        this.closeExtra();
        let r = this.top;
        r.match = r.match && r.match.matchType(e);
        let a = Gu(e, s, r.options);
        r.options & jr && r.content.length == 0 && (a |= jr);
        let l = Ze.none;
        return o = o.filter((c2) => (r.type ? r.type.allowsMarkType(c2.type) : Xu(c2.type, e)) ? (l = c2.addToSet(l), false) : true), this.nodes.push(new er(e, n, l, i, null, a)), this.open++, o;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(e = false) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
          for (; n > this.open; n--)
            this.nodes[n - 1].content.push(this.nodes[n].finish(e));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(e) {
        for (let n = this.open; n >= 0; n--) {
          if (this.nodes[n] == e)
            return this.open = n, true;
          this.localPreserveWS && (this.nodes[n].options |= ks);
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let n = this.open; n >= 0; n--) {
          let o = this.nodes[n].content;
          for (let i = o.length - 1; i >= 0; i--)
            e += o[i].nodeSize;
          n && e++;
        }
        return e;
      }
      findAtPoint(e, n) {
        if (this.find)
          for (let o = 0; o < this.find.length; o++)
            this.find[o].node == e && this.find[o].offset == n && (this.find[o].pos = this.currentPos);
      }
      findInside(e) {
        if (this.find)
          for (let n = 0; n < this.find.length; n++)
            this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
      }
      findAround(e, n, o) {
        if (e != n && this.find)
          for (let i = 0; i < this.find.length; i++)
            this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (o ? 2 : 4) && (this.find[i].pos = this.currentPos);
      }
      findInText(e) {
        if (this.find)
          for (let n = 0; n < this.find.length; n++)
            this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
      }
      // Determines whether the given context string matches this context.
      matchesContext(e) {
        if (e.indexOf("|") > -1)
          return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = e.split("/"), o = this.options.context, i = !this.isOpen && (!o || o.parent.type == this.nodes[0].type), s = -(o ? o.depth + 1 : 0) + (i ? 0 : 1), r = (a, l) => {
          for (; a >= 0; a--) {
            let c2 = n[a];
            if (c2 == "") {
              if (a == n.length - 1 || a == 0)
                continue;
              for (; l >= s; l--)
                if (r(a - 1, l))
                  return true;
              return false;
            } else {
              let u = l > 0 || l == 0 && i ? this.nodes[l].type : o && l >= s ? o.node(l - s).type : null;
              if (!u || u.name != c2 && !u.isInGroup(c2))
                return false;
              l--;
            }
          }
          return true;
        };
        return r(n.length - 1, this.open);
      }
      textblockFromContext() {
        let e = this.options.context;
        if (e)
          for (let n = e.depth; n >= 0; n--) {
            let o = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
            if (o && o.isTextblock && o.defaultAttrs)
              return o;
          }
        for (let n in this.parser.schema.nodes) {
          let o = this.parser.schema.nodes[n];
          if (o.isTextblock && o.defaultAttrs)
            return o;
        }
      }
    }
    function $g(t2) {
      for (let e = t2.firstChild, n = null; e; e = e.nextSibling) {
        let o = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        o && Am.hasOwnProperty(o) && n ? (n.appendChild(e), e = n) : o == "li" ? n = e : o && (n = null);
      }
    }
    function zg(t2, e) {
      return (t2.matches || t2.msMatchesSelector || t2.webkitMatchesSelector || t2.mozMatchesSelector).call(t2, e);
    }
    function Yu(t2) {
      let e = {};
      for (let n in t2)
        e[n] = t2[n];
      return e;
    }
    function Xu(t2, e) {
      let n = e.schema.nodes;
      for (let o in n) {
        let i = n[o];
        if (!i.allowsMarkType(t2))
          continue;
        let s = [], r = (a) => {
          s.push(a);
          for (let l = 0; l < a.edgeCount; l++) {
            let { type: c2, next: u } = a.edge(l);
            if (c2 == e || s.indexOf(u) < 0 && r(u))
              return true;
          }
        };
        if (r(i.contentMatch))
          return true;
      }
    }
    class mi {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(e, n) {
        this.nodes = e, this.marks = n;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(e, n = {}, o) {
        o || (o = nl(n).createDocumentFragment());
        let i = o, s = [];
        return e.forEach((r) => {
          if (s.length || r.marks.length) {
            let a = 0, l = 0;
            for (; a < s.length && l < r.marks.length; ) {
              let c2 = r.marks[l];
              if (!this.marks[c2.type.name]) {
                l++;
                continue;
              }
              if (!c2.eq(s[a][0]) || c2.type.spec.spanning === false)
                break;
              a++, l++;
            }
            for (; a < s.length; )
              i = s.pop()[1];
            for (; l < r.marks.length; ) {
              let c2 = r.marks[l++], u = this.serializeMark(c2, r.isInline, n);
              u && (s.push([c2, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
            }
          }
          i.appendChild(this.serializeNodeInner(r, n));
        }), o;
      }
      /**
      @internal
      */
      serializeNodeInner(e, n) {
        let { dom: o, contentDOM: i } = Er(nl(n), this.nodes[e.type.name](e), null, e.attrs);
        if (i) {
          if (e.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(e.content, n, i);
        }
        return o;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(e, n = {}) {
        let o = this.serializeNodeInner(e, n);
        for (let i = e.marks.length - 1; i >= 0; i--) {
          let s = this.serializeMark(e.marks[i], e.isInline, n);
          s && ((s.contentDOM || s.dom).appendChild(o), o = s.dom);
        }
        return o;
      }
      /**
      @internal
      */
      serializeMark(e, n, o = {}) {
        let i = this.marks[e.type.name];
        return i && Er(nl(o), i(e, n), null, e.attrs);
      }
      static renderSpec(e, n, o = null, i) {
        return Er(e, n, o, i);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new mi(this.nodesFromSchema(e), this.marksFromSchema(e)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(e) {
        let n = Zu(e.nodes);
        return n.text || (n.text = (o) => o.text), n;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(e) {
        return Zu(e.marks);
      }
    }
    function Zu(t2) {
      let e = {};
      for (let n in t2) {
        let o = t2[n].spec.toDOM;
        o && (e[n] = o);
      }
      return e;
    }
    function nl(t2) {
      return t2.document || window.document;
    }
    const Qu = /* @__PURE__ */ new WeakMap();
    function Fg(t2) {
      let e = Qu.get(t2);
      return e === void 0 && Qu.set(t2, e = Hg(t2)), e;
    }
    function Hg(t2) {
      let e = null;
      function n(o) {
        if (o && typeof o == "object")
          if (Array.isArray(o))
            if (typeof o[0] == "string")
              e || (e = []), e.push(o);
            else
              for (let i = 0; i < o.length; i++)
                n(o[i]);
          else
            for (let i in o)
              n(o[i]);
      }
      return n(t2), e;
    }
    function Er(t2, e, n, o) {
      if (typeof e == "string")
        return { dom: t2.createTextNode(e) };
      if (e.nodeType != null)
        return { dom: e };
      if (e.dom && e.dom.nodeType != null)
        return e;
      let i = e[0], s;
      if (typeof i != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (o && (s = Fg(o)) && s.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let r = i.indexOf(" ");
      r > 0 && (n = i.slice(0, r), i = i.slice(r + 1));
      let a, l = n ? t2.createElementNS(n, i) : t2.createElement(i), c2 = e[1], u = 1;
      if (c2 && typeof c2 == "object" && c2.nodeType == null && !Array.isArray(c2)) {
        u = 2;
        for (let d in c2)
          if (c2[d] != null) {
            let p2 = d.indexOf(" ");
            p2 > 0 ? l.setAttributeNS(d.slice(0, p2), d.slice(p2 + 1), c2[d]) : l.setAttribute(d, c2[d]);
          }
      }
      for (let d = u; d < e.length; d++) {
        let p2 = e[d];
        if (p2 === 0) {
          if (d < e.length - 1 || d > u)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom: l, contentDOM: l };
        } else {
          let { dom: m, contentDOM: f } = Er(t2, p2, n, o);
          if (l.appendChild(m), f) {
            if (a)
              throw new RangeError("Multiple content holes");
            a = f;
          }
        }
      }
      return { dom: l, contentDOM: a };
    }
    const Mm = 65535, Rm = Math.pow(2, 16);
    function Ug(t2, e) {
      return t2 + e * Rm;
    }
    function ed(t2) {
      return t2 & Mm;
    }
    function Vg(t2) {
      return (t2 - (t2 & Mm)) / Rm;
    }
    const Im = 1, Dm = 2, Sr = 4, Lm = 8;
    class Ul {
      /**
      @internal
      */
      constructor(e, n, o) {
        this.pos = e, this.delInfo = n, this.recover = o;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & Lm) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (Im | Sr)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (Dm | Sr)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & Sr) > 0;
      }
    }
    class cn {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(e, n = false) {
        if (this.ranges = e, this.inverted = n, !e.length && cn.empty)
          return cn.empty;
      }
      /**
      @internal
      */
      recover(e) {
        let n = 0, o = ed(e);
        if (!this.inverted)
          for (let i = 0; i < o; i++)
            n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
        return this.ranges[o * 3] + n + Vg(e);
      }
      mapResult(e, n = 1) {
        return this._map(e, n, false);
      }
      map(e, n = 1) {
        return this._map(e, n, true);
      }
      /**
      @internal
      */
      _map(e, n, o) {
        let i = 0, s = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? i : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + s], u = this.ranges[a + r], d = l + c2;
          if (e <= d) {
            let p2 = c2 ? e == l ? -1 : e == d ? 1 : n : n, m = l + i + (p2 < 0 ? 0 : u);
            if (o)
              return m;
            let f = e == (n < 0 ? l : d) ? null : Ug(a / 3, e - l), _ = e == l ? Dm : e == d ? Im : Sr;
            return (n < 0 ? e != l : e != d) && (_ |= Lm), new Ul(m, _, f);
          }
          i += u - c2;
        }
        return o ? e + i : new Ul(e + i, 0, null);
      }
      /**
      @internal
      */
      touches(e, n) {
        let o = 0, i = ed(n), s = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? o : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + s], u = l + c2;
          if (e <= u && a == i * 3)
            return true;
          o += this.ranges[a + r] - c2;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(e) {
        let n = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
        for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
          let r = this.ranges[i], a = r - (this.inverted ? s : 0), l = r + (this.inverted ? 0 : s), c2 = this.ranges[i + n], u = this.ranges[i + o];
          e(a, a + c2, l, l + u), s += u - c2;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new cn(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(e) {
        return e == 0 ? cn.empty : new cn(e < 0 ? [0, -e, 0] : [0, 0, e]);
      }
    }
    cn.empty = new cn([]);
    class ys {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(e, n, o = 0, i = e ? e.length : 0) {
        this.mirror = n, this.from = o, this.to = i, this._maps = e || [], this.ownData = !(e || n);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(e = 0, n = this.maps.length) {
        return new ys(this._maps, this.mirror, e, n);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(e, n) {
        this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(e) {
        for (let n = 0, o = this._maps.length; n < e._maps.length; n++) {
          let i = e.getMirror(n);
          this.appendMap(e._maps[n], i != null && i < n ? o + i : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(e) {
        if (this.mirror) {
          for (let n = 0; n < this.mirror.length; n++)
            if (this.mirror[n] == e)
              return this.mirror[n + (n % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(e, n) {
        this.mirror || (this.mirror = []), this.mirror.push(e, n);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(e) {
        for (let n = e.maps.length - 1, o = this._maps.length + e._maps.length; n >= 0; n--) {
          let i = e.getMirror(n);
          this.appendMap(e._maps[n].invert(), i != null && i > n ? o - i - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let e = new ys();
        return e.appendMappingInverted(this), e;
      }
      /**
      Map a position through this mapping.
      */
      map(e, n = 1) {
        if (this.mirror)
          return this._map(e, n, true);
        for (let o = this.from; o < this.to; o++)
          e = this._maps[o].map(e, n);
        return e;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(e, n = 1) {
        return this._map(e, n, false);
      }
      /**
      @internal
      */
      _map(e, n, o) {
        let i = 0;
        for (let s = this.from; s < this.to; s++) {
          let r = this._maps[s], a = r.mapResult(e, n);
          if (a.recover != null) {
            let l = this.getMirror(s);
            if (l != null && l > s && l < this.to) {
              s = l, e = this._maps[l].recover(a.recover);
              continue;
            }
          }
          i |= a.delInfo, e = a.pos;
        }
        return o ? e : new Ul(e, i, null);
      }
    }
    const ol = /* @__PURE__ */ Object.create(null);
    class Ht {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return cn.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(e) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(e, n) {
        if (!n || !n.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let o = ol[n.stepType];
        if (!o)
          throw new RangeError(`No step type ${n.stepType} defined`);
        return o.fromJSON(e, n);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(e, n) {
        if (e in ol)
          throw new RangeError("Duplicate use of step JSON ID " + e);
        return ol[e] = n, n.prototype.jsonID = e, n;
      }
    }
    class vt {
      /**
      @internal
      */
      constructor(e, n) {
        this.doc = e, this.failed = n;
      }
      /**
      Create a successful step result.
      */
      static ok(e) {
        return new vt(e, null);
      }
      /**
      Create a failed step result.
      */
      static fail(e) {
        return new vt(null, e);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(e, n, o, i) {
        try {
          return vt.ok(e.replace(n, o, i));
        } catch (s) {
          if (s instanceof Dr)
            return vt.fail(s.message);
          throw s;
        }
      }
    }
    function Cc(t2, e, n) {
      let o = [];
      for (let i = 0; i < t2.childCount; i++) {
        let s = t2.child(i);
        s.content.size && (s = s.copy(Cc(s.content, e, s))), s.isInline && (s = e(s, n, i)), o.push(s);
      }
      return D.fromArray(o);
    }
    class To extends Ht {
      /**
      Create a mark step.
      */
      constructor(e, n, o) {
        super(), this.from = e, this.to = n, this.mark = o;
      }
      apply(e) {
        let n = e.slice(this.from, this.to), o = e.resolve(this.from), i = o.node(o.sharedDepth(this.to)), s = new K(Cc(n.content, (r, a) => !r.isAtom || !a.type.allowsMarkType(this.mark.type) ? r : r.mark(this.mark.addToSet(r.marks)), i), n.openStart, n.openEnd);
        return vt.fromReplace(e, this.from, this.to, s);
      }
      invert() {
        return new Gn(this.from, this.to, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return n.deleted && o.deleted || n.pos >= o.pos ? null : new To(n.pos, o.pos, this.mark);
      }
      merge(e) {
        return e instanceof To && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new To(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new To(n.from, n.to, e.markFromJSON(n.mark));
      }
    }
    Ht.jsonID("addMark", To);
    class Gn extends Ht {
      /**
      Create a mark-removing step.
      */
      constructor(e, n, o) {
        super(), this.from = e, this.to = n, this.mark = o;
      }
      apply(e) {
        let n = e.slice(this.from, this.to), o = new K(Cc(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
        return vt.fromReplace(e, this.from, this.to, o);
      }
      invert() {
        return new To(this.from, this.to, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return n.deleted && o.deleted || n.pos >= o.pos ? null : new Gn(n.pos, o.pos, this.mark);
      }
      merge(e) {
        return e instanceof Gn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Gn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new Gn(n.from, n.to, e.markFromJSON(n.mark));
      }
    }
    Ht.jsonID("removeMark", Gn);
    class Oo extends Ht {
      /**
      Create a node mark step.
      */
      constructor(e, n) {
        super(), this.pos = e, this.mark = n;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return vt.fail("No node at mark step's position");
        let o = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return vt.fromReplace(e, this.pos, this.pos + 1, new K(D.from(o), 0, n.isLeaf ? 0 : 1));
      }
      invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
          let o = this.mark.addToSet(n.marks);
          if (o.length == n.marks.length) {
            for (let i = 0; i < n.marks.length; i++)
              if (!n.marks[i].isInSet(o))
                return new Oo(this.pos, n.marks[i]);
            return new Oo(this.pos, this.mark);
          }
        }
        return new Ai(this.pos, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Oo(n.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new Oo(n.pos, e.markFromJSON(n.mark));
      }
    }
    Ht.jsonID("addNodeMark", Oo);
    class Ai extends Ht {
      /**
      Create a mark-removing step.
      */
      constructor(e, n) {
        super(), this.pos = e, this.mark = n;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return vt.fail("No node at mark step's position");
        let o = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return vt.fromReplace(e, this.pos, this.pos + 1, new K(D.from(o), 0, n.isLeaf ? 0 : 1));
      }
      invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new Oo(this.pos, this.mark);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Ai(n.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new Ai(n.pos, e.markFromJSON(n.mark));
      }
    }
    Ht.jsonID("removeNodeMark", Ai);
    class Et extends Ht {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`—the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(e, n, o, i = false) {
        super(), this.from = e, this.to = n, this.slice = o, this.structure = i;
      }
      apply(e) {
        return this.structure && Vl(e, this.from, this.to) ? vt.fail("Structure replace would overwrite content") : vt.fromReplace(e, this.from, this.to, this.slice);
      }
      getMap() {
        return new cn([this.from, this.to - this.from, this.slice.size]);
      }
      invert(e) {
        return new Et(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
      }
      map(e) {
        let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return n.deletedAcross && o.deletedAcross ? null : new Et(n.pos, Math.max(n.pos, o.pos), this.slice);
      }
      merge(e) {
        if (!(e instanceof Et) || e.structure || this.structure)
          return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
          let n = this.slice.size + e.slice.size == 0 ? K.empty : new K(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
          return new Et(this.from, this.to + (e.to - e.from), n, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
          let n = this.slice.size + e.slice.size == 0 ? K.empty : new K(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
          return new Et(e.from, this.to, n, this.structure);
        } else
          return null;
      }
      toJSON() {
        let e = { stepType: "replace", from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new Et(n.from, n.to, K.fromJSON(e, n.slice), !!n.structure);
      }
    }
    Ht.jsonID("replace", Et);
    class Ct extends Ht {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(e, n, o, i, s, r, a = false) {
        super(), this.from = e, this.to = n, this.gapFrom = o, this.gapTo = i, this.slice = s, this.insert = r, this.structure = a;
      }
      apply(e) {
        if (this.structure && (Vl(e, this.from, this.gapFrom) || Vl(e, this.gapTo, this.to)))
          return vt.fail("Structure gap-replace would overwrite content");
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
          return vt.fail("Gap is not a flat range");
        let o = this.slice.insertAt(this.insert, n.content);
        return o ? vt.fromReplace(e, this.from, this.to, o) : vt.fail("Content does not fit in gap");
      }
      getMap() {
        return new cn([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new Ct(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(e) {
        let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? o.pos : e.map(this.gapTo, 1);
        return n.deletedAcross && o.deletedAcross || i < n.pos || s > o.pos ? null : new Ct(n.pos, o.pos, i, s, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let e = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new Ct(n.from, n.to, n.gapFrom, n.gapTo, K.fromJSON(e, n.slice), n.insert, !!n.structure);
      }
    }
    Ht.jsonID("replaceAround", Ct);
    function Vl(t2, e, n) {
      let o = t2.resolve(e), i = n - e, s = o.depth;
      for (; i > 0 && s > 0 && o.indexAfter(s) == o.node(s).childCount; )
        s--, i--;
      if (i > 0) {
        let r = o.node(s).maybeChild(o.indexAfter(s));
        for (; i > 0; ) {
          if (!r || r.isLeaf)
            return true;
          r = r.firstChild, i--;
        }
      }
      return false;
    }
    function qg(t2, e, n, o) {
      let i = [], s = [], r, a;
      t2.doc.nodesBetween(e, n, (l, c2, u) => {
        if (!l.isInline)
          return;
        let d = l.marks;
        if (!o.isInSet(d) && u.type.allowsMarkType(o.type)) {
          let p2 = Math.max(c2, e), m = Math.min(c2 + l.nodeSize, n), f = o.addToSet(d);
          for (let _ = 0; _ < d.length; _++)
            d[_].isInSet(f) || (r && r.to == p2 && r.mark.eq(d[_]) ? r.to = m : i.push(r = new Gn(p2, m, d[_])));
          a && a.to == p2 ? a.to = m : s.push(a = new To(p2, m, o));
        }
      }), i.forEach((l) => t2.step(l)), s.forEach((l) => t2.step(l));
    }
    function Kg(t2, e, n, o) {
      let i = [], s = 0;
      t2.doc.nodesBetween(e, n, (r, a) => {
        if (!r.isInline)
          return;
        s++;
        let l = null;
        if (o instanceof Ta) {
          let c2 = r.marks, u;
          for (; u = o.isInSet(c2); )
            (l || (l = [])).push(u), c2 = u.removeFromSet(c2);
        } else o ? o.isInSet(r.marks) && (l = [o]) : l = r.marks;
        if (l && l.length) {
          let c2 = Math.min(a + r.nodeSize, n);
          for (let u = 0; u < l.length; u++) {
            let d = l[u], p2;
            for (let m = 0; m < i.length; m++) {
              let f = i[m];
              f.step == s - 1 && d.eq(i[m].style) && (p2 = f);
            }
            p2 ? (p2.to = c2, p2.step = s) : i.push({ style: d, from: Math.max(a, e), to: c2, step: s });
          }
        }
      }), i.forEach((r) => t2.step(new Gn(r.from, r.to, r.style)));
    }
    function xc(t2, e, n, o = n.contentMatch, i = true) {
      let s = t2.doc.nodeAt(e), r = [], a = e + 1;
      for (let l = 0; l < s.childCount; l++) {
        let c2 = s.child(l), u = a + c2.nodeSize, d = o.matchType(c2.type);
        if (!d)
          r.push(new Et(a, u, K.empty));
        else {
          o = d;
          for (let p2 = 0; p2 < c2.marks.length; p2++)
            n.allowsMarkType(c2.marks[p2].type) || t2.step(new Gn(a, u, c2.marks[p2]));
          if (i && c2.isText && n.whitespace != "pre") {
            let p2, m = /\r?\n|\r/g, f;
            for (; p2 = m.exec(c2.text); )
              f || (f = new K(D.from(n.schema.text(" ", n.allowedMarks(c2.marks))), 0, 0)), r.push(new Et(a + p2.index, a + p2.index + p2[0].length, f));
          }
        }
        a = u;
      }
      if (!o.validEnd) {
        let l = o.fillBefore(D.empty, true);
        t2.replace(a, a, new K(l, 0, 0));
      }
      for (let l = r.length - 1; l >= 0; l--)
        t2.step(r[l]);
    }
    function Wg(t2, e, n) {
      return (e == 0 || t2.canReplace(e, t2.childCount)) && (n == t2.childCount || t2.canReplace(0, n));
    }
    function Hi(t2) {
      let n = t2.parent.content.cutByIndex(t2.startIndex, t2.endIndex);
      for (let o = t2.depth; ; --o) {
        let i = t2.$from.node(o), s = t2.$from.index(o), r = t2.$to.indexAfter(o);
        if (o < t2.depth && i.canReplace(s, r, n))
          return o;
        if (o == 0 || i.type.spec.isolating || !Wg(i, s, r))
          break;
      }
      return null;
    }
    function Gg(t2, e, n) {
      let { $from: o, $to: i, depth: s } = e, r = o.before(s + 1), a = i.after(s + 1), l = r, c2 = a, u = D.empty, d = 0;
      for (let f = s, _ = false; f > n; f--)
        _ || o.index(f) > 0 ? (_ = true, u = D.from(o.node(f).copy(u)), d++) : l--;
      let p2 = D.empty, m = 0;
      for (let f = s, _ = false; f > n; f--)
        _ || i.after(f + 1) < i.end(f) ? (_ = true, p2 = D.from(i.node(f).copy(p2)), m++) : c2++;
      t2.step(new Ct(l, c2, r, a, new K(u.append(p2), d, m), u.size - d, true));
    }
    function Tc(t2, e, n = null, o = t2) {
      let i = Jg(t2, e), s = i && Yg(o, e);
      return s ? i.map(td).concat({ type: e, attrs: n }).concat(s.map(td)) : null;
    }
    function td(t2) {
      return { type: t2, attrs: null };
    }
    function Jg(t2, e) {
      let { parent: n, startIndex: o, endIndex: i } = t2, s = n.contentMatchAt(o).findWrapping(e);
      if (!s)
        return null;
      let r = s.length ? s[0] : e;
      return n.canReplaceWith(o, i, r) ? s : null;
    }
    function Yg(t2, e) {
      let { parent: n, startIndex: o, endIndex: i } = t2, s = n.child(o), r = e.contentMatch.findWrapping(s.type);
      if (!r)
        return null;
      let l = (r.length ? r[r.length - 1] : e).contentMatch;
      for (let c2 = o; l && c2 < i; c2++)
        l = l.matchType(n.child(c2).type);
      return !l || !l.validEnd ? null : r;
    }
    function Xg(t2, e, n) {
      let o = D.empty;
      for (let r = n.length - 1; r >= 0; r--) {
        if (o.size) {
          let a = n[r].type.contentMatch.matchFragment(o);
          if (!a || !a.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        o = D.from(n[r].type.create(n[r].attrs, o));
      }
      let i = e.start, s = e.end;
      t2.step(new Ct(i, s, i, s, new K(o, 0, 0), n.length, true));
    }
    function Zg(t2, e, n, o, i) {
      if (!o.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let s = t2.steps.length;
      t2.doc.nodesBetween(e, n, (r, a) => {
        let l = typeof i == "function" ? i(r) : i;
        if (r.isTextblock && !r.hasMarkup(o, l) && Qg(t2.doc, t2.mapping.slice(s).map(a), o)) {
          let c2 = null;
          if (o.schema.linebreakReplacement) {
            let m = o.whitespace == "pre", f = !!o.contentMatch.matchType(o.schema.linebreakReplacement);
            m && !f ? c2 = false : !m && f && (c2 = true);
          }
          c2 === false && Bm(t2, r, a, s), xc(t2, t2.mapping.slice(s).map(a, 1), o, void 0, c2 === null);
          let u = t2.mapping.slice(s), d = u.map(a, 1), p2 = u.map(a + r.nodeSize, 1);
          return t2.step(new Ct(d, p2, d + 1, p2 - 1, new K(D.from(o.create(l, null, r.marks)), 0, 0), 1, true)), c2 === true && Pm(t2, r, a, s), false;
        }
      });
    }
    function Pm(t2, e, n, o) {
      e.forEach((i, s) => {
        if (i.isText) {
          let r, a = /\r?\n|\r/g;
          for (; r = a.exec(i.text); ) {
            let l = t2.mapping.slice(o).map(n + 1 + s + r.index);
            t2.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function Bm(t2, e, n, o) {
      e.forEach((i, s) => {
        if (i.type == i.type.schema.linebreakReplacement) {
          let r = t2.mapping.slice(o).map(n + 1 + s);
          t2.replaceWith(r, r + 1, e.type.schema.text(`
`));
        }
      });
    }
    function Qg(t2, e, n) {
      let o = t2.resolve(e), i = o.index();
      return o.parent.canReplaceWith(i, i + 1, n);
    }
    function ev(t2, e, n, o, i) {
      let s = t2.doc.nodeAt(e);
      if (!s)
        throw new RangeError("No node at given position");
      n || (n = s.type);
      let r = n.create(o, null, i || s.marks);
      if (s.isLeaf)
        return t2.replaceWith(e, e + s.nodeSize, r);
      if (!n.validContent(s.content))
        throw new RangeError("Invalid content for node type " + n.name);
      t2.step(new Ct(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new K(D.from(r), 0, 0), 1, true));
    }
    function uo(t2, e, n = 1, o) {
      let i = t2.resolve(e), s = i.depth - n, r = o && o[o.length - 1] || i.parent;
      if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !r.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
        return false;
      for (let c2 = i.depth - 1, u = n - 2; c2 > s; c2--, u--) {
        let d = i.node(c2), p2 = i.index(c2);
        if (d.type.spec.isolating)
          return false;
        let m = d.content.cutByIndex(p2, d.childCount), f = o && o[u + 1];
        f && (m = m.replaceChild(0, f.type.create(f.attrs)));
        let _ = o && o[u] || d;
        if (!d.canReplace(p2 + 1, d.childCount) || !_.type.validContent(m))
          return false;
      }
      let a = i.indexAfter(s), l = o && o[0];
      return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type);
    }
    function tv(t2, e, n = 1, o) {
      let i = t2.doc.resolve(e), s = D.empty, r = D.empty;
      for (let a = i.depth, l = i.depth - n, c2 = n - 1; a > l; a--, c2--) {
        s = D.from(i.node(a).copy(s));
        let u = o && o[c2];
        r = D.from(u ? u.type.create(u.attrs, r) : i.node(a).copy(r));
      }
      t2.step(new Et(e, e, new K(s.append(r), n, n), true));
    }
    function $o(t2, e) {
      let n = t2.resolve(e), o = n.index();
      return $m(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(o, o + 1);
    }
    function nv(t2, e) {
      e.content.size || t2.type.compatibleContent(e.type);
      let n = t2.contentMatchAt(t2.childCount), { linebreakReplacement: o } = t2.type.schema;
      for (let i = 0; i < e.childCount; i++) {
        let s = e.child(i), r = s.type == o ? t2.type.schema.nodes.text : s.type;
        if (n = n.matchType(r), !n || !t2.type.allowsMarks(s.marks))
          return false;
      }
      return n.validEnd;
    }
    function $m(t2, e) {
      return !!(t2 && e && !t2.isLeaf && nv(t2, e));
    }
    function Oa(t2, e, n = -1) {
      let o = t2.resolve(e);
      for (let i = o.depth; ; i--) {
        let s, r, a = o.index(i);
        if (i == o.depth ? (s = o.nodeBefore, r = o.nodeAfter) : n > 0 ? (s = o.node(i + 1), a++, r = o.node(i).maybeChild(a)) : (s = o.node(i).maybeChild(a - 1), r = o.node(i + 1)), s && !s.isTextblock && $m(s, r) && o.node(i).canReplace(a, a + 1))
          return e;
        if (i == 0)
          break;
        e = n < 0 ? o.before(i) : o.after(i);
      }
    }
    function ov(t2, e, n) {
      let o = null, { linebreakReplacement: i } = t2.doc.type.schema, s = t2.doc.resolve(e - n), r = s.node().type;
      if (i && r.inlineContent) {
        let u = r.whitespace == "pre", d = !!r.contentMatch.matchType(i);
        u && !d ? o = false : !u && d && (o = true);
      }
      let a = t2.steps.length;
      if (o === false) {
        let u = t2.doc.resolve(e + n);
        Bm(t2, u.node(), u.before(), a);
      }
      r.inlineContent && xc(t2, e + n - 1, r, s.node().contentMatchAt(s.index()), o == null);
      let l = t2.mapping.slice(a), c2 = l.map(e - n);
      if (t2.step(new Et(c2, l.map(e + n, -1), K.empty, true)), o === true) {
        let u = t2.doc.resolve(c2);
        Pm(t2, u.node(), u.before(), t2.steps.length);
      }
      return t2;
    }
    function iv(t2, e, n) {
      let o = t2.resolve(e);
      if (o.parent.canReplaceWith(o.index(), o.index(), n))
        return e;
      if (o.parentOffset == 0)
        for (let i = o.depth - 1; i >= 0; i--) {
          let s = o.index(i);
          if (o.node(i).canReplaceWith(s, s, n))
            return o.before(i + 1);
          if (s > 0)
            return null;
        }
      if (o.parentOffset == o.parent.content.size)
        for (let i = o.depth - 1; i >= 0; i--) {
          let s = o.indexAfter(i);
          if (o.node(i).canReplaceWith(s, s, n))
            return o.after(i + 1);
          if (s < o.node(i).childCount)
            return null;
        }
      return null;
    }
    function zm(t2, e, n) {
      let o = t2.resolve(e);
      if (!n.content.size)
        return e;
      let i = n.content;
      for (let s = 0; s < n.openStart; s++)
        i = i.firstChild.content;
      for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
        for (let r = o.depth; r >= 0; r--) {
          let a = r == o.depth ? 0 : o.pos <= (o.start(r + 1) + o.end(r + 1)) / 2 ? -1 : 1, l = o.index(r) + (a > 0 ? 1 : 0), c2 = o.node(r), u = false;
          if (s == 1)
            u = c2.canReplace(l, l, i);
          else {
            let d = c2.contentMatchAt(l).findWrapping(i.firstChild.type);
            u = d && c2.canReplaceWith(l, l, d[0]);
          }
          if (u)
            return a == 0 ? o.pos : a < 0 ? o.before(r + 1) : o.after(r + 1);
        }
      return null;
    }
    function Na(t2, e, n = e, o = K.empty) {
      if (e == n && !o.size)
        return null;
      let i = t2.resolve(e), s = t2.resolve(n);
      return Fm(i, s, o) ? new Et(e, n, o) : new sv(i, s, o).fit();
    }
    function Fm(t2, e, n) {
      return !n.openStart && !n.openEnd && t2.start() == e.start() && t2.parent.canReplace(t2.index(), e.index(), n.content);
    }
    class sv {
      constructor(e, n, o) {
        this.$from = e, this.$to = n, this.unplaced = o, this.frontier = [], this.placed = D.empty;
        for (let i = 0; i <= e.depth; i++) {
          let s = e.node(i);
          this.frontier.push({
            type: s.type,
            match: s.contentMatchAt(e.indexAfter(i))
          });
        }
        for (let i = e.depth; i > 0; i--)
          this.placed = D.from(e.node(i).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        for (; this.unplaced.size; ) {
          let c2 = this.findFittable();
          c2 ? this.placeNodes(c2) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, o = this.$from, i = this.close(e < 0 ? this.$to : o.doc.resolve(e));
        if (!i)
          return null;
        let s = this.placed, r = o.depth, a = i.depth;
        for (; r && a && s.childCount == 1; )
          s = s.firstChild.content, r--, a--;
        let l = new K(s, r, a);
        return e > -1 ? new Ct(o.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || o.pos != this.$to.pos ? new Et(o.pos, i.pos, l) : null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, o = 0, i = this.unplaced.openEnd; o < e; o++) {
          let s = n.firstChild;
          if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= o) {
            e = o;
            break;
          }
          n = s.content;
        }
        for (let n = 1; n <= 2; n++)
          for (let o = n == 1 ? e : this.unplaced.openStart; o >= 0; o--) {
            let i, s = null;
            o ? (s = il(this.unplaced.content, o - 1).firstChild, i = s.content) : i = this.unplaced.content;
            let r = i.firstChild;
            for (let a = this.depth; a >= 0; a--) {
              let { type: l, match: c2 } = this.frontier[a], u, d = null;
              if (n == 1 && (r ? c2.matchType(r.type) || (d = c2.fillBefore(D.from(r), false)) : s && l.compatibleContent(s.type)))
                return { sliceDepth: o, frontierDepth: a, parent: s, inject: d };
              if (n == 2 && r && (u = c2.findWrapping(r.type)))
                return { sliceDepth: o, frontierDepth: a, parent: s, wrap: u };
              if (s && c2.matchType(s.type))
                break;
            }
          }
      }
      openMore() {
        let { content: e, openStart: n, openEnd: o } = this.unplaced, i = il(e, n);
        return !i.childCount || i.firstChild.isLeaf ? false : (this.unplaced = new K(e, n + 1, Math.max(o, i.size + n >= e.size - o ? n + 1 : 0)), true);
      }
      dropNode() {
        let { content: e, openStart: n, openEnd: o } = this.unplaced, i = il(e, n);
        if (i.childCount <= 1 && n > 0) {
          let s = e.size - n <= n + i.size;
          this.unplaced = new K(ts(e, n - 1, 1), n - 1, s ? n - 1 : o);
        } else
          this.unplaced = new K(ts(e, n, 1), n, o);
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth: e, frontierDepth: n, parent: o, inject: i, wrap: s }) {
        for (; this.depth > n; )
          this.closeFrontierNode();
        if (s)
          for (let _ = 0; _ < s.length; _++)
            this.openFrontierNode(s[_]);
        let r = this.unplaced, a = o ? o.content : r.content, l = r.openStart - e, c2 = 0, u = [], { match: d, type: p2 } = this.frontier[n];
        if (i) {
          for (let _ = 0; _ < i.childCount; _++)
            u.push(i.child(_));
          d = d.matchFragment(i);
        }
        let m = a.size + e - (r.content.size - r.openEnd);
        for (; c2 < a.childCount; ) {
          let _ = a.child(c2), h2 = d.matchType(_.type);
          if (!h2)
            break;
          c2++, (c2 > 1 || l == 0 || _.content.size) && (d = h2, u.push(Hm(_.mark(p2.allowedMarks(_.marks)), c2 == 1 ? l : 0, c2 == a.childCount ? m : -1)));
        }
        let f = c2 == a.childCount;
        f || (m = -1), this.placed = ns(this.placed, n, D.from(u)), this.frontier[n].match = d, f && m < 0 && o && o.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let _ = 0, h2 = a; _ < m; _++) {
          let g = h2.lastChild;
          this.frontier.push({ type: g.type, match: g.contentMatchAt(g.childCount) }), h2 = g.content;
        }
        this.unplaced = f ? e == 0 ? K.empty : new K(ts(r.content, e - 1, 1), e - 1, m < 0 ? r.openEnd : e - 1) : new K(ts(r.content, e, c2), r.openStart, r.openEnd);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let e = this.frontier[this.depth], n;
        if (!e.type.isTextblock || !sl(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
          return -1;
        let { depth: o } = this.$to, i = this.$to.after(o);
        for (; o > 1 && i == this.$to.end(--o); )
          ++i;
        return i;
      }
      findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
          let { match: o, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), r = sl(e, n, i, o, s);
          if (r) {
            for (let a = n - 1; a >= 0; a--) {
              let { match: l, type: c2 } = this.frontier[a], u = sl(e, a, c2, l, true);
              if (!u || u.childCount)
                continue e;
            }
            return { depth: n, fit: r, move: s ? e.doc.resolve(e.after(n + 1)) : e };
          }
        }
      }
      close(e) {
        let n = this.findCloseLevel(e);
        if (!n)
          return null;
        for (; this.depth > n.depth; )
          this.closeFrontierNode();
        n.fit.childCount && (this.placed = ns(this.placed, n.depth, n.fit)), e = n.move;
        for (let o = n.depth + 1; o <= e.depth; o++) {
          let i = e.node(o), s = i.type.contentMatch.fillBefore(i.content, true, e.index(o));
          this.openFrontierNode(i.type, i.attrs, s);
        }
        return e;
      }
      openFrontierNode(e, n = null, o) {
        let i = this.frontier[this.depth];
        i.match = i.match.matchType(e), this.placed = ns(this.placed, this.depth, D.from(e.create(n, o))), this.frontier.push({ type: e, match: e.contentMatch });
      }
      closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(D.empty, true);
        n.childCount && (this.placed = ns(this.placed, this.frontier.length, n));
      }
    }
    function ts(t2, e, n) {
      return e == 0 ? t2.cutByIndex(n, t2.childCount) : t2.replaceChild(0, t2.firstChild.copy(ts(t2.firstChild.content, e - 1, n)));
    }
    function ns(t2, e, n) {
      return e == 0 ? t2.append(n) : t2.replaceChild(t2.childCount - 1, t2.lastChild.copy(ns(t2.lastChild.content, e - 1, n)));
    }
    function il(t2, e) {
      for (let n = 0; n < e; n++)
        t2 = t2.firstChild.content;
      return t2;
    }
    function Hm(t2, e, n) {
      if (e <= 0)
        return t2;
      let o = t2.content;
      return e > 1 && (o = o.replaceChild(0, Hm(o.firstChild, e - 1, o.childCount == 1 ? n - 1 : 0))), e > 0 && (o = t2.type.contentMatch.fillBefore(o).append(o), n <= 0 && (o = o.append(t2.type.contentMatch.matchFragment(o).fillBefore(D.empty, true)))), t2.copy(o);
    }
    function sl(t2, e, n, o, i) {
      let s = t2.node(e), r = i ? t2.indexAfter(e) : t2.index(e);
      if (r == s.childCount && !n.compatibleContent(s.type))
        return null;
      let a = o.fillBefore(s.content, true, r);
      return a && !rv(n, s.content, r) ? a : null;
    }
    function rv(t2, e, n) {
      for (let o = n; o < e.childCount; o++)
        if (!t2.allowsMarks(e.child(o).marks))
          return true;
      return false;
    }
    function av(t2) {
      return t2.spec.defining || t2.spec.definingForContent;
    }
    function lv(t2, e, n, o) {
      if (!o.size)
        return t2.deleteRange(e, n);
      let i = t2.doc.resolve(e), s = t2.doc.resolve(n);
      if (Fm(i, s, o))
        return t2.step(new Et(e, n, o));
      let r = Vm(i, t2.doc.resolve(n));
      r[r.length - 1] == 0 && r.pop();
      let a = -(i.depth + 1);
      r.unshift(a);
      for (let p2 = i.depth, m = i.pos - 1; p2 > 0; p2--, m--) {
        let f = i.node(p2).type.spec;
        if (f.defining || f.definingAsContext || f.isolating)
          break;
        r.indexOf(p2) > -1 ? a = p2 : i.before(p2) == m && r.splice(1, 0, -p2);
      }
      let l = r.indexOf(a), c2 = [], u = o.openStart;
      for (let p2 = o.content, m = 0; ; m++) {
        let f = p2.firstChild;
        if (c2.push(f), m == o.openStart)
          break;
        p2 = f.content;
      }
      for (let p2 = u - 1; p2 >= 0; p2--) {
        let m = c2[p2], f = av(m.type);
        if (f && !m.sameMarkup(i.node(Math.abs(a) - 1)))
          u = p2;
        else if (f || !m.type.isTextblock)
          break;
      }
      for (let p2 = o.openStart; p2 >= 0; p2--) {
        let m = (p2 + u + 1) % (o.openStart + 1), f = c2[m];
        if (f)
          for (let _ = 0; _ < r.length; _++) {
            let h2 = r[(_ + l) % r.length], g = true;
            h2 < 0 && (g = false, h2 = -h2);
            let k = i.node(h2 - 1), j = i.index(h2 - 1);
            if (k.canReplaceWith(j, j, f.type, f.marks))
              return t2.replace(i.before(h2), g ? s.after(h2) : n, new K(Um(o.content, 0, o.openStart, m), m, o.openEnd));
          }
      }
      let d = t2.steps.length;
      for (let p2 = r.length - 1; p2 >= 0 && (t2.replace(e, n, o), !(t2.steps.length > d)); p2--) {
        let m = r[p2];
        m < 0 || (e = i.before(m), n = s.after(m));
      }
    }
    function Um(t2, e, n, o, i) {
      if (e < n) {
        let s = t2.firstChild;
        t2 = t2.replaceChild(0, s.copy(Um(s.content, e + 1, n, o, s)));
      }
      if (e > o) {
        let s = i.contentMatchAt(0), r = s.fillBefore(t2).append(t2);
        t2 = r.append(s.matchFragment(r).fillBefore(D.empty, true));
      }
      return t2;
    }
    function cv(t2, e, n, o) {
      if (!o.isInline && e == n && t2.doc.resolve(e).parent.content.size) {
        let i = iv(t2.doc, e, o.type);
        i != null && (e = n = i);
      }
      t2.replaceRange(e, n, new K(D.from(o), 0, 0));
    }
    function uv(t2, e, n) {
      let o = t2.doc.resolve(e), i = t2.doc.resolve(n), s = Vm(o, i);
      for (let r = 0; r < s.length; r++) {
        let a = s[r], l = r == s.length - 1;
        if (l && a == 0 || o.node(a).type.contentMatch.validEnd)
          return t2.delete(o.start(a), i.end(a));
        if (a > 0 && (l || o.node(a - 1).canReplace(o.index(a - 1), i.indexAfter(a - 1))))
          return t2.delete(o.before(a), i.after(a));
      }
      for (let r = 1; r <= o.depth && r <= i.depth; r++)
        if (e - o.start(r) == o.depth - r && n > o.end(r) && i.end(r) - n != i.depth - r && o.start(r - 1) == i.start(r - 1) && o.node(r - 1).canReplace(o.index(r - 1), i.index(r - 1)))
          return t2.delete(o.before(r), n);
      t2.delete(e, n);
    }
    function Vm(t2, e) {
      let n = [], o = Math.min(t2.depth, e.depth);
      for (let i = o; i >= 0; i--) {
        let s = t2.start(i);
        if (s < t2.pos - (t2.depth - i) || e.end(i) > e.pos + (e.depth - i) || t2.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
          break;
        (s == e.start(i) || i == t2.depth && i == e.depth && t2.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i);
      }
      return n;
    }
    class Oi extends Ht {
      /**
      Construct an attribute step.
      */
      constructor(e, n, o) {
        super(), this.pos = e, this.attr = n, this.value = o;
      }
      apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
          return vt.fail("No node at attribute step's position");
        let o = /* @__PURE__ */ Object.create(null);
        for (let s in n.attrs)
          o[s] = n.attrs[s];
        o[this.attr] = this.value;
        let i = n.type.create(o, null, n.marks);
        return vt.fromReplace(e, this.pos, this.pos + 1, new K(D.from(i), 0, n.isLeaf ? 0 : 1));
      }
      getMap() {
        return cn.empty;
      }
      invert(e) {
        return new Oi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
      }
      map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Oi(n.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(e, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Oi(n.pos, n.attr, n.value);
      }
    }
    Ht.jsonID("attr", Oi);
    class ws extends Ht {
      /**
      Construct an attribute step.
      */
      constructor(e, n) {
        super(), this.attr = e, this.value = n;
      }
      apply(e) {
        let n = /* @__PURE__ */ Object.create(null);
        for (let i in e.attrs)
          n[i] = e.attrs[i];
        n[this.attr] = this.value;
        let o = e.type.create(n, e.content, e.marks);
        return vt.ok(o);
      }
      getMap() {
        return cn.empty;
      }
      invert(e) {
        return new ws(this.attr, e.attrs[this.attr]);
      }
      map(e) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(e, n) {
        if (typeof n.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new ws(n.attr, n.value);
      }
    }
    Ht.jsonID("docAttr", ws);
    let Mi = class extends Error {
    };
    Mi = function t(e) {
      let n = Error.call(this, e);
      return n.__proto__ = t.prototype, n;
    };
    Mi.prototype = Object.create(Error.prototype);
    Mi.prototype.constructor = Mi;
    Mi.prototype.name = "TransformError";
    class Oc {
      /**
      Create a transform that starts with the given document.
      */
      constructor(e) {
        this.doc = e, this.steps = [], this.docs = [], this.mapping = new ys();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(e) {
        let n = this.maybeStep(e);
        if (n.failed)
          throw new Mi(n.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc), n;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(e, n) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(e, n = e, o = K.empty) {
        let i = Na(this.doc, e, n, o);
        return i && this.step(i), this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(e, n, o) {
        return this.replace(e, n, new K(D.from(o), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(e, n) {
        return this.replace(e, n, K.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(e, n) {
        return this.replaceWith(e, e, n);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(e, n, o) {
        return lv(this, e, n, o), this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(e, n, o) {
        return cv(this, e, n, o), this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(e, n) {
        return uv(this, e, n), this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(e, n) {
        return Gg(this, e, n), this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(e, n = 1) {
        return ov(this, e, n), this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(e, n) {
        return Xg(this, e, n), this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(e, n = e, o, i = null) {
        return Zg(this, e, n, o, i), this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(e, n, o = null, i) {
        return ev(this, e, n, o, i), this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(e, n, o) {
        return this.step(new Oi(e, n, o)), this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(e, n) {
        return this.step(new ws(e, n)), this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(e, n) {
        return this.step(new Oo(e, n)), this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(e, n) {
        if (!(n instanceof Ze)) {
          let o = this.doc.nodeAt(e);
          if (!o)
            throw new RangeError("No node at position " + e);
          if (n = n.isInSet(o.marks), !n)
            return this;
        }
        return this.step(new Ai(e, n)), this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(e, n = 1, o) {
        return tv(this, e, n, o), this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(e, n, o) {
        return qg(this, e, n, o), this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(e, n, o) {
        return Kg(this, e, n, o), this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(e, n, o) {
        return xc(this, e, n, o), this;
      }
    }
    const rl = /* @__PURE__ */ Object.create(null);
    class de {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor(e, n, o) {
        this.$anchor = e, this.$head = n, this.ranges = o || [new qm(e.min(n), e.max(n))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let e = this.ranges;
        for (let n = 0; n < e.length; n++)
          if (e[n].$from.pos != e[n].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(e, n = K.empty) {
        let o = n.content.lastChild, i = null;
        for (let a = 0; a < n.openEnd; a++)
          i = o, o = o.lastChild;
        let s = e.steps.length, r = this.ranges;
        for (let a = 0; a < r.length; a++) {
          let { $from: l, $to: c2 } = r[a], u = e.mapping.slice(s);
          e.replaceRange(u.map(l.pos), u.map(c2.pos), a ? K.empty : n), a == 0 && id(e, s, (o ? o.isInline : i && i.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(e, n) {
        let o = e.steps.length, i = this.ranges;
        for (let s = 0; s < i.length; s++) {
          let { $from: r, $to: a } = i[s], l = e.mapping.slice(o), c2 = l.map(r.pos), u = l.map(a.pos);
          s ? e.deleteRange(c2, u) : (e.replaceRangeWith(c2, u, n), id(e, o, n.isInline ? -1 : 1));
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom(e, n, o = false) {
        let i = e.parent.inlineContent ? new re(e) : bi(e.node(0), e.parent, e.pos, e.index(), n, o);
        if (i)
          return i;
        for (let s = e.depth - 1; s >= 0; s--) {
          let r = n < 0 ? bi(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, o) : bi(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, o);
          if (r)
            return r;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near(e, n = 1) {
        return this.findFrom(e, n) || this.findFrom(e, -n) || new pn(e.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(e) {
        return bi(e, e, 0, 0, 1) || new pn(e);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(e) {
        return bi(e, e, e.content.size, e.childCount, -1) || new pn(e);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(e, n) {
        if (!n || !n.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let o = rl[n.type];
        if (!o)
          throw new RangeError(`No selection type ${n.type} defined`);
        return o.fromJSON(e, n);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(e, n) {
        if (e in rl)
          throw new RangeError("Duplicate use of selection JSON ID " + e);
        return rl[e] = n, n.prototype.jsonID = e, n;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return re.between(this.$anchor, this.$head).getBookmark();
      }
    }
    de.prototype.visible = true;
    class qm {
      /**
      Create a range.
      */
      constructor(e, n) {
        this.$from = e, this.$to = n;
      }
    }
    let nd = false;
    function od(t2) {
      !nd && !t2.parent.inlineContent && (nd = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t2.parent.type.name + ")"));
    }
    class re extends de {
      /**
      Construct a text selection between the given points.
      */
      constructor(e, n = e) {
        od(e), od(n), super(e, n);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(e, n) {
        let o = e.resolve(n.map(this.head));
        if (!o.parent.inlineContent)
          return de.near(o);
        let i = e.resolve(n.map(this.anchor));
        return new re(i.parent.inlineContent ? i : o, o);
      }
      replace(e, n = K.empty) {
        if (super.replace(e, n), n == K.empty) {
          let o = this.$from.marksAcross(this.$to);
          o && e.ensureMarks(o);
        }
      }
      eq(e) {
        return e instanceof re && e.anchor == this.anchor && e.head == this.head;
      }
      getBookmark() {
        return new Aa(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new re(e.resolve(n.anchor), e.resolve(n.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(e, n, o = n) {
        let i = e.resolve(n);
        return new this(i, o == n ? i : e.resolve(o));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between(e, n, o) {
        let i = e.pos - n.pos;
        if ((!o || i) && (o = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
          let s = de.findFrom(n, o, true) || de.findFrom(n, -o, true);
          if (s)
            n = s.$head;
          else
            return de.near(n, o);
        }
        return e.parent.inlineContent || (i == 0 ? e = n : (e = (de.findFrom(e, -o, true) || de.findFrom(e, o, true)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new re(e, n);
      }
    }
    de.jsonID("text", re);
    class Aa {
      constructor(e, n) {
        this.anchor = e, this.head = n;
      }
      map(e) {
        return new Aa(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        return re.between(e.resolve(this.anchor), e.resolve(this.head));
      }
    }
    class ie extends de {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor(e) {
        let n = e.nodeAfter, o = e.node(0).resolve(e.pos + n.nodeSize);
        super(e, o), this.node = n;
      }
      map(e, n) {
        let { deleted: o, pos: i } = n.mapResult(this.anchor), s = e.resolve(i);
        return o ? de.near(s) : new ie(s);
      }
      content() {
        return new K(D.from(this.node), 0, 0);
      }
      eq(e) {
        return e instanceof ie && e.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new Nc(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new ie(e.resolve(n.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(e, n) {
        return new ie(e.resolve(n));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== false;
      }
    }
    ie.prototype.visible = false;
    de.jsonID("node", ie);
    class Nc {
      constructor(e) {
        this.anchor = e;
      }
      map(e) {
        let { deleted: n, pos: o } = e.mapResult(this.anchor);
        return n ? new Aa(o, o) : new Nc(o);
      }
      resolve(e) {
        let n = e.resolve(this.anchor), o = n.nodeAfter;
        return o && ie.isSelectable(o) ? new ie(n) : de.near(n);
      }
    }
    class pn extends de {
      /**
      Create an all-selection over the given document.
      */
      constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size));
      }
      replace(e, n = K.empty) {
        if (n == K.empty) {
          e.delete(0, e.doc.content.size);
          let o = de.atStart(e.doc);
          o.eq(e.selection) || e.setSelection(o);
        } else
          super.replace(e, n);
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(e) {
        return new pn(e);
      }
      map(e) {
        return new pn(e);
      }
      eq(e) {
        return e instanceof pn;
      }
      getBookmark() {
        return dv;
      }
    }
    de.jsonID("all", pn);
    const dv = {
      map() {
        return this;
      },
      resolve(t2) {
        return new pn(t2);
      }
    };
    function bi(t2, e, n, o, i, s = false) {
      if (e.inlineContent)
        return re.create(t2, n);
      for (let r = o - (i > 0 ? 0 : 1); i > 0 ? r < e.childCount : r >= 0; r += i) {
        let a = e.child(r);
        if (a.isAtom) {
          if (!s && ie.isSelectable(a))
            return ie.create(t2, n - (i < 0 ? a.nodeSize : 0));
        } else {
          let l = bi(t2, a, n + i, i < 0 ? a.childCount : 0, i, s);
          if (l)
            return l;
        }
        n += a.nodeSize * i;
      }
      return null;
    }
    function id(t2, e, n) {
      let o = t2.steps.length - 1;
      if (o < e)
        return;
      let i = t2.steps[o];
      if (!(i instanceof Et || i instanceof Ct))
        return;
      let s = t2.mapping.maps[o], r;
      s.forEach((a, l, c2, u) => {
        r == null && (r = u);
      }), t2.setSelection(de.near(t2.doc.resolve(r), n));
    }
    const sd = 1, rd = 2, ad = 4;
    class pv extends Oc {
      /**
      @internal
      */
      constructor(e) {
        super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(e) {
        if (e.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | sd) & -3, this.storedMarks = null, this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & sd) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(e) {
        return this.storedMarks = e, this.updated |= rd, this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(e) {
        return Ze.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & rd) > 0;
      }
      /**
      @internal
      */
      addStep(e, n) {
        super.addStep(e, n), this.updated = this.updated & -3, this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(e) {
        return this.time = e, this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(e) {
        return this.selection.replace(this, e), this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(e, n = true) {
        let o = this.selection;
        return n && (e = e.mark(this.storedMarks || (o.empty ? o.$from.marks() : o.$from.marksAcross(o.$to) || Ze.none))), o.replaceWith(this, e), this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        return this.selection.replace(this), this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(e, n, o) {
        let i = this.doc.type.schema;
        if (n == null)
          return e ? this.replaceSelectionWith(i.text(e), true) : this.deleteSelection();
        {
          if (o == null && (o = n), o = o ?? n, !e)
            return this.deleteRange(n, o);
          let s = this.storedMarks;
          if (!s) {
            let r = this.doc.resolve(n);
            s = o == n ? r.marks() : r.marksAcross(this.doc.resolve(o));
          }
          return this.replaceRangeWith(n, o, i.text(e, s)), this.selection.empty || this.setSelection(de.near(this.selection.$to)), this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(e, n) {
        return this.meta[typeof e == "string" ? e : e.key] = n, this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let e in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        return this.updated |= ad, this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & ad) > 0;
      }
    }
    function ld(t2, e) {
      return !e || !t2 ? t2 : t2.bind(e);
    }
    class is {
      constructor(e, n, o) {
        this.name = e, this.init = ld(n.init, o), this.apply = ld(n.apply, o);
      }
    }
    const mv = [
      new is("doc", {
        init(t2) {
          return t2.doc || t2.schema.topNodeType.createAndFill();
        },
        apply(t2) {
          return t2.doc;
        }
      }),
      new is("selection", {
        init(t2, e) {
          return t2.selection || de.atStart(e.doc);
        },
        apply(t2) {
          return t2.selection;
        }
      }),
      new is("storedMarks", {
        init(t2) {
          return t2.storedMarks || null;
        },
        apply(t2, e, n, o) {
          return o.selection.$cursor ? t2.storedMarks : null;
        }
      }),
      new is("scrollToSelection", {
        init() {
          return 0;
        },
        apply(t2, e) {
          return t2.scrolledIntoView ? e + 1 : e;
        }
      })
    ];
    class al {
      constructor(e, n) {
        this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = mv.slice(), n && n.forEach((o) => {
          if (this.pluginsByKey[o.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + o.key + ")");
          this.plugins.push(o), this.pluginsByKey[o.key] = o, o.spec.state && this.fields.push(new is(o.key, o.spec.state, o));
        });
      }
    }
    class Ci {
      /**
      @internal
      */
      constructor(e) {
        this.config = e;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(e) {
        return this.applyTransaction(e).state;
      }
      /**
      @internal
      */
      filterTransaction(e, n = -1) {
        for (let o = 0; o < this.config.plugins.length; o++)
          if (o != n) {
            let i = this.config.plugins[o];
            if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(e) {
        if (!this.filterTransaction(e))
          return { state: this, transactions: [] };
        let n = [e], o = this.applyInner(e), i = null;
        for (; ; ) {
          let s = false;
          for (let r = 0; r < this.config.plugins.length; r++) {
            let a = this.config.plugins[r];
            if (a.spec.appendTransaction) {
              let l = i ? i[r].n : 0, c2 = i ? i[r].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c2, o);
              if (u && o.filterTransaction(u, r)) {
                if (u.setMeta("appendedTransaction", e), !i) {
                  i = [];
                  for (let d = 0; d < this.config.plugins.length; d++)
                    i.push(d < r ? { state: o, n: n.length } : { state: this, n: 0 });
                }
                n.push(u), o = o.applyInner(u), s = true;
              }
              i && (i[r] = { state: o, n: n.length });
            }
          }
          if (!s)
            return { state: o, transactions: n };
        }
      }
      /**
      @internal
      */
      applyInner(e) {
        if (!e.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let n = new Ci(this.config), o = this.config.fields;
        for (let i = 0; i < o.length; i++) {
          let s = o[i];
          n[s.name] = s.apply(e, this[s.name], this, n);
        }
        return n;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new pv(this);
      }
      /**
      Create a new state.
      */
      static create(e) {
        let n = new al(e.doc ? e.doc.type.schema : e.schema, e.plugins), o = new Ci(n);
        for (let i = 0; i < n.fields.length; i++)
          o[n.fields[i].name] = n.fields[i].init(e, o);
        return o;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(e) {
        let n = new al(this.schema, e.plugins), o = n.fields, i = new Ci(n);
        for (let s = 0; s < o.length; s++) {
          let r = o[s].name;
          i[r] = this.hasOwnProperty(r) ? this[r] : o[s].init(e, i);
        }
        return i;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(e) {
        let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map((o) => o.toJSON())), e && typeof e == "object")
          for (let o in e) {
            if (o == "doc" || o == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let i = e[o], s = i.spec.state;
            s && s.toJSON && (n[o] = s.toJSON.call(i, this[i.key]));
          }
        return n;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(e, n, o) {
        if (!n)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
          throw new RangeError("Required config field 'schema' missing");
        let i = new al(e.schema, e.plugins), s = new Ci(i);
        return i.fields.forEach((r) => {
          if (r.name == "doc")
            s.doc = Mo.fromJSON(e.schema, n.doc);
          else if (r.name == "selection")
            s.selection = de.fromJSON(s.doc, n.selection);
          else if (r.name == "storedMarks")
            n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
          else {
            if (o)
              for (let a in o) {
                let l = o[a], c2 = l.spec.state;
                if (l.key == r.name && c2 && c2.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
                  s[r.name] = c2.fromJSON.call(l, e, n[a], s);
                  return;
                }
              }
            s[r.name] = r.init(e, s);
          }
        }), s;
      }
    }
    function Km(t2, e, n) {
      for (let o in t2) {
        let i = t2[o];
        i instanceof Function ? i = i.bind(e) : o == "handleDOMEvents" && (i = Km(i, e, {})), n[o] = i;
      }
      return n;
    }
    class ze {
      /**
      Create a plugin.
      */
      constructor(e) {
        this.spec = e, this.props = {}, e.props && Km(e.props, this, this.props), this.key = e.key ? e.key.key : Wm("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const ll = /* @__PURE__ */ Object.create(null);
    function Wm(t2) {
      return t2 in ll ? t2 + "$" + ++ll[t2] : (ll[t2] = 0, t2 + "$");
    }
    class Fe {
      /**
      Create a plugin key.
      */
      constructor(e = "key") {
        this.key = Wm(e);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(e) {
        return e.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const Dt = function(t2) {
      for (var e = 0; ; e++)
        if (t2 = t2.previousSibling, !t2)
          return e;
    }, js = function(t2) {
      let e = t2.assignedSlot || t2.parentNode;
      return e && e.nodeType == 11 ? e.host : e;
    };
    let ql = null;
    const ro = function(t2, e, n) {
      let o = ql || (ql = document.createRange());
      return o.setEnd(t2, n ?? t2.nodeValue.length), o.setStart(t2, e || 0), o;
    }, fv = function() {
      ql = null;
    }, ai = function(t2, e, n, o) {
      return n && (cd(t2, e, n, o, -1) || cd(t2, e, n, o, 1));
    }, _v = /^(img|br|input|textarea|hr)$/i;
    function cd(t2, e, n, o, i) {
      for (; ; ) {
        if (t2 == n && e == o)
          return true;
        if (e == (i < 0 ? 0 : bn(t2))) {
          let s = t2.parentNode;
          if (!s || s.nodeType != 1 || Fs(t2) || _v.test(t2.nodeName) || t2.contentEditable == "false")
            return false;
          e = Dt(t2) + (i < 0 ? 0 : 1), t2 = s;
        } else if (t2.nodeType == 1) {
          if (t2 = t2.childNodes[e + (i < 0 ? -1 : 0)], t2.contentEditable == "false")
            return false;
          e = i < 0 ? bn(t2) : 0;
        } else
          return false;
      }
    }
    function bn(t2) {
      return t2.nodeType == 3 ? t2.nodeValue.length : t2.childNodes.length;
    }
    function hv(t2, e) {
      for (; ; ) {
        if (t2.nodeType == 3 && e)
          return t2;
        if (t2.nodeType == 1 && e > 0) {
          if (t2.contentEditable == "false")
            return null;
          t2 = t2.childNodes[e - 1], e = bn(t2);
        } else if (t2.parentNode && !Fs(t2))
          e = Dt(t2), t2 = t2.parentNode;
        else
          return null;
      }
    }
    function gv(t2, e) {
      for (; ; ) {
        if (t2.nodeType == 3 && e < t2.nodeValue.length)
          return t2;
        if (t2.nodeType == 1 && e < t2.childNodes.length) {
          if (t2.contentEditable == "false")
            return null;
          t2 = t2.childNodes[e], e = 0;
        } else if (t2.parentNode && !Fs(t2))
          e = Dt(t2) + 1, t2 = t2.parentNode;
        else
          return null;
      }
    }
    function vv(t2, e, n) {
      for (let o = e == 0, i = e == bn(t2); o || i; ) {
        if (t2 == n)
          return true;
        let s = Dt(t2);
        if (t2 = t2.parentNode, !t2)
          return false;
        o = o && s == 0, i = i && s == bn(t2);
      }
    }
    function Fs(t2) {
      let e;
      for (let n = t2; n && !(e = n.pmViewDesc); n = n.parentNode)
        ;
      return e && e.node && e.node.isBlock && (e.dom == t2 || e.contentDOM == t2);
    }
    const Ma = function(t2) {
      return t2.focusNode && ai(t2.focusNode, t2.focusOffset, t2.anchorNode, t2.anchorOffset);
    };
    function Wo(t2, e) {
      let n = document.createEvent("Event");
      return n.initEvent("keydown", true, true), n.keyCode = t2, n.key = n.code = e, n;
    }
    function bv(t2) {
      let e = t2.activeElement;
      for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
      return e;
    }
    function kv(t2, e, n) {
      if (t2.caretPositionFromPoint)
        try {
          let o = t2.caretPositionFromPoint(e, n);
          if (o)
            return { node: o.offsetNode, offset: Math.min(bn(o.offsetNode), o.offset) };
        } catch {
        }
      if (t2.caretRangeFromPoint) {
        let o = t2.caretRangeFromPoint(e, n);
        if (o)
          return { node: o.startContainer, offset: Math.min(bn(o.startContainer), o.startOffset) };
      }
    }
    const Yn = typeof navigator < "u" ? navigator : null, ud = typeof document < "u" ? document : null, zo = Yn && Yn.userAgent || "", Kl = /Edge\/(\d+)/.exec(zo), Gm = /MSIE \d/.exec(zo), Wl = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(zo), en = !!(Gm || Wl || Kl), Ro = Gm ? document.documentMode : Wl ? +Wl[1] : Kl ? +Kl[1] : 0, Dn = !en && /gecko\/(\d+)/i.test(zo);
    Dn && +(/Firefox\/(\d+)/.exec(zo) || [0, 0])[1];
    const Gl = !en && /Chrome\/(\d+)/.exec(zo), zt = !!Gl, Jm = Gl ? +Gl[1] : 0, Gt = !en && !!Yn && /Apple Computer/.test(Yn.vendor), Ri = Gt && (/Mobile\/\w+/.test(zo) || !!Yn && Yn.maxTouchPoints > 2), vn = Ri || (Yn ? /Mac/.test(Yn.platform) : false), yv = Yn ? /Win/.test(Yn.platform) : false, lo = /Android \d/.test(zo), Hs = !!ud && "webkitFontSmoothing" in ud.documentElement.style, wv = Hs ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function jv(t2) {
      let e = t2.defaultView && t2.defaultView.visualViewport;
      return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
      } : {
        left: 0,
        right: t2.documentElement.clientWidth,
        top: 0,
        bottom: t2.documentElement.clientHeight
      };
    }
    function to(t2, e) {
      return typeof t2 == "number" ? t2 : t2[e];
    }
    function Ev(t2) {
      let e = t2.getBoundingClientRect(), n = e.width / t2.offsetWidth || 1, o = e.height / t2.offsetHeight || 1;
      return {
        left: e.left,
        right: e.left + t2.clientWidth * n,
        top: e.top,
        bottom: e.top + t2.clientHeight * o
      };
    }
    function dd(t2, e, n) {
      let o = t2.someProp("scrollThreshold") || 0, i = t2.someProp("scrollMargin") || 5, s = t2.dom.ownerDocument;
      for (let r = n || t2.dom; r; r = js(r)) {
        if (r.nodeType != 1)
          continue;
        let a = r, l = a == s.body, c2 = l ? jv(s) : Ev(a), u = 0, d = 0;
        if (e.top < c2.top + to(o, "top") ? d = -(c2.top - e.top + to(i, "top")) : e.bottom > c2.bottom - to(o, "bottom") && (d = e.bottom - e.top > c2.bottom - c2.top ? e.top + to(i, "top") - c2.top : e.bottom - c2.bottom + to(i, "bottom")), e.left < c2.left + to(o, "left") ? u = -(c2.left - e.left + to(i, "left")) : e.right > c2.right - to(o, "right") && (u = e.right - c2.right + to(i, "right")), u || d)
          if (l)
            s.defaultView.scrollBy(u, d);
          else {
            let p2 = a.scrollLeft, m = a.scrollTop;
            d && (a.scrollTop += d), u && (a.scrollLeft += u);
            let f = a.scrollLeft - p2, _ = a.scrollTop - m;
            e = { left: e.left - f, top: e.top - _, right: e.right - f, bottom: e.bottom - _ };
          }
        if (l || /^(fixed|sticky)$/.test(getComputedStyle(r).position))
          break;
      }
    }
    function Sv(t2) {
      let e = t2.dom.getBoundingClientRect(), n = Math.max(0, e.top), o, i;
      for (let s = (e.left + e.right) / 2, r = n + 1; r < Math.min(innerHeight, e.bottom); r += 5) {
        let a = t2.root.elementFromPoint(s, r);
        if (!a || a == t2.dom || !t2.dom.contains(a))
          continue;
        let l = a.getBoundingClientRect();
        if (l.top >= n - 20) {
          o = a, i = l.top;
          break;
        }
      }
      return { refDOM: o, refTop: i, stack: Ym(t2.dom) };
    }
    function Ym(t2) {
      let e = [], n = t2.ownerDocument;
      for (let o = t2; o && (e.push({ dom: o, top: o.scrollTop, left: o.scrollLeft }), t2 != n); o = js(o))
        ;
      return e;
    }
    function Cv({ refDOM: t2, refTop: e, stack: n }) {
      let o = t2 ? t2.getBoundingClientRect().top : 0;
      Xm(n, o == 0 ? 0 : o - e);
    }
    function Xm(t2, e) {
      for (let n = 0; n < t2.length; n++) {
        let { dom: o, top: i, left: s } = t2[n];
        o.scrollTop != i + e && (o.scrollTop = i + e), o.scrollLeft != s && (o.scrollLeft = s);
      }
    }
    let _i = null;
    function xv(t2) {
      if (t2.setActive)
        return t2.setActive();
      if (_i)
        return t2.focus(_i);
      let e = Ym(t2);
      t2.focus(_i == null ? {
        get preventScroll() {
          return _i = { preventScroll: true }, true;
        }
      } : void 0), _i || (_i = false, Xm(e, 0));
    }
    function Zm(t2, e) {
      let n, o = 2e8, i, s = 0, r = e.top, a = e.top, l, c2;
      for (let u = t2.firstChild, d = 0; u; u = u.nextSibling, d++) {
        let p2;
        if (u.nodeType == 1)
          p2 = u.getClientRects();
        else if (u.nodeType == 3)
          p2 = ro(u).getClientRects();
        else
          continue;
        for (let m = 0; m < p2.length; m++) {
          let f = p2[m];
          if (f.top <= r && f.bottom >= a) {
            r = Math.max(f.bottom, r), a = Math.min(f.top, a);
            let _ = f.left > e.left ? f.left - e.left : f.right < e.left ? e.left - f.right : 0;
            if (_ < o) {
              n = u, o = _, i = _ && n.nodeType == 3 ? {
                left: f.right < e.left ? f.right : f.left,
                top: e.top
              } : e, u.nodeType == 1 && _ && (s = d + (e.left >= (f.left + f.right) / 2 ? 1 : 0));
              continue;
            }
          } else f.top > e.top && !l && f.left <= e.left && f.right >= e.left && (l = u, c2 = { left: Math.max(f.left, Math.min(f.right, e.left)), top: f.top });
          !n && (e.left >= f.right && e.top >= f.top || e.left >= f.left && e.top >= f.bottom) && (s = d + 1);
        }
      }
      return !n && l && (n = l, i = c2, o = 0), n && n.nodeType == 3 ? Tv(n, i) : !n || o && n.nodeType == 1 ? { node: t2, offset: s } : Zm(n, i);
    }
    function Tv(t2, e) {
      let n = t2.nodeValue.length, o = document.createRange();
      for (let i = 0; i < n; i++) {
        o.setEnd(t2, i + 1), o.setStart(t2, i);
        let s = yo(o, 1);
        if (s.top != s.bottom && Ac(e, s))
          return { node: t2, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
      }
      return { node: t2, offset: 0 };
    }
    function Ac(t2, e) {
      return t2.left >= e.left - 1 && t2.left <= e.right + 1 && t2.top >= e.top - 1 && t2.top <= e.bottom + 1;
    }
    function Ov(t2, e) {
      let n = t2.parentNode;
      return n && /^li$/i.test(n.nodeName) && e.left < t2.getBoundingClientRect().left ? n : t2;
    }
    function Nv(t2, e, n) {
      let { node: o, offset: i } = Zm(e, n), s = -1;
      if (o.nodeType == 1 && !o.firstChild) {
        let r = o.getBoundingClientRect();
        s = r.left != r.right && n.left > (r.left + r.right) / 2 ? 1 : -1;
      }
      return t2.docView.posFromDOM(o, i, s);
    }
    function Av(t2, e, n, o) {
      let i = -1;
      for (let s = e, r = false; s != t2.dom; ) {
        let a = t2.docView.nearestDesc(s, true), l;
        if (!a)
          return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
        ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!r && l.left > o.left || l.top > o.top ? i = a.posBefore : (!r && l.right < o.left || l.bottom < o.top) && (i = a.posAfter), r = true), !a.contentDOM && i < 0 && !a.node.isText))
          return (a.node.isBlock ? o.top < (l.top + l.bottom) / 2 : o.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
        s = a.dom.parentNode;
      }
      return i > -1 ? i : t2.docView.posFromDOM(e, n, -1);
    }
    function Qm(t2, e, n) {
      let o = t2.childNodes.length;
      if (o && n.top < n.bottom)
        for (let i = Math.max(0, Math.min(o - 1, Math.floor(o * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ; ) {
          let r = t2.childNodes[s];
          if (r.nodeType == 1) {
            let a = r.getClientRects();
            for (let l = 0; l < a.length; l++) {
              let c2 = a[l];
              if (Ac(e, c2))
                return Qm(r, e, c2);
            }
          }
          if ((s = (s + 1) % o) == i)
            break;
        }
      return t2;
    }
    function Mv(t2, e) {
      let n = t2.dom.ownerDocument, o, i = 0, s = kv(n, e.left, e.top);
      s && ({ node: o, offset: i } = s);
      let r = (t2.root.elementFromPoint ? t2.root : n).elementFromPoint(e.left, e.top), a;
      if (!r || !t2.dom.contains(r.nodeType != 1 ? r.parentNode : r)) {
        let c2 = t2.dom.getBoundingClientRect();
        if (!Ac(e, c2) || (r = Qm(t2.dom, e, c2), !r))
          return null;
      }
      if (Gt)
        for (let c2 = r; o && c2; c2 = js(c2))
          c2.draggable && (o = void 0);
      if (r = Ov(r, e), o) {
        if (Dn && o.nodeType == 1 && (i = Math.min(i, o.childNodes.length), i < o.childNodes.length)) {
          let u = o.childNodes[i], d;
          u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++;
        }
        let c2;
        Hs && i && o.nodeType == 1 && (c2 = o.childNodes[i - 1]).nodeType == 1 && c2.contentEditable == "false" && c2.getBoundingClientRect().top >= e.top && i--, o == t2.dom && i == o.childNodes.length - 1 && o.lastChild.nodeType == 1 && e.top > o.lastChild.getBoundingClientRect().bottom ? a = t2.state.doc.content.size : (i == 0 || o.nodeType != 1 || o.childNodes[i - 1].nodeName != "BR") && (a = Av(t2, o, i, e));
      }
      a == null && (a = Nv(t2, r, e));
      let l = t2.docView.nearestDesc(r, true);
      return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
    }
    function pd(t2) {
      return t2.top < t2.bottom || t2.left < t2.right;
    }
    function yo(t2, e) {
      let n = t2.getClientRects();
      if (n.length) {
        let o = n[e < 0 ? 0 : n.length - 1];
        if (pd(o))
          return o;
      }
      return Array.prototype.find.call(n, pd) || t2.getBoundingClientRect();
    }
    const Rv = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function ef(t2, e, n) {
      let { node: o, offset: i, atom: s } = t2.docView.domFromPos(e, n < 0 ? -1 : 1), r = Hs || Dn;
      if (o.nodeType == 3)
        if (r && (Rv.test(o.nodeValue) || (n < 0 ? !i : i == o.nodeValue.length))) {
          let l = yo(ro(o, i, i), n);
          if (Dn && i && /\s/.test(o.nodeValue[i - 1]) && i < o.nodeValue.length) {
            let c2 = yo(ro(o, i - 1, i - 1), -1);
            if (c2.top == l.top) {
              let u = yo(ro(o, i, i + 1), -1);
              if (u.top != l.top)
                return Yi(u, u.left < c2.left);
            }
          }
          return l;
        } else {
          let l = i, c2 = i, u = n < 0 ? 1 : -1;
          return n < 0 && !i ? (c2++, u = -1) : n >= 0 && i == o.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c2++, Yi(yo(ro(o, l, c2), u), u < 0);
        }
      if (!t2.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
        if (s == null && i && (n < 0 || i == bn(o))) {
          let l = o.childNodes[i - 1];
          if (l.nodeType == 1)
            return cl(l.getBoundingClientRect(), false);
        }
        if (s == null && i < bn(o)) {
          let l = o.childNodes[i];
          if (l.nodeType == 1)
            return cl(l.getBoundingClientRect(), true);
        }
        return cl(o.getBoundingClientRect(), n >= 0);
      }
      if (s == null && i && (n < 0 || i == bn(o))) {
        let l = o.childNodes[i - 1], c2 = l.nodeType == 3 ? ro(l, bn(l) - (r ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c2)
          return Yi(yo(c2, 1), false);
      }
      if (s == null && i < bn(o)) {
        let l = o.childNodes[i];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
          l = l.nextSibling;
        let c2 = l ? l.nodeType == 3 ? ro(l, 0, r ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c2)
          return Yi(yo(c2, -1), true);
      }
      return Yi(yo(o.nodeType == 3 ? ro(o) : o, -n), n >= 0);
    }
    function Yi(t2, e) {
      if (t2.width == 0)
        return t2;
      let n = e ? t2.left : t2.right;
      return { top: t2.top, bottom: t2.bottom, left: n, right: n };
    }
    function cl(t2, e) {
      if (t2.height == 0)
        return t2;
      let n = e ? t2.top : t2.bottom;
      return { top: n, bottom: n, left: t2.left, right: t2.right };
    }
    function tf(t2, e, n) {
      let o = t2.state, i = t2.root.activeElement;
      o != e && t2.updateState(e), i != t2.dom && t2.focus();
      try {
        return n();
      } finally {
        o != e && t2.updateState(o), i != t2.dom && i && i.focus();
      }
    }
    function Iv(t2, e, n) {
      let o = e.selection, i = n == "up" ? o.$from : o.$to;
      return tf(t2, e, () => {
        let { node: s } = t2.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
        for (; ; ) {
          let a = t2.docView.nearestDesc(s, true);
          if (!a)
            break;
          if (a.node.isBlock) {
            s = a.contentDOM || a.dom;
            break;
          }
          s = a.dom.parentNode;
        }
        let r = ef(t2, i.pos, 1);
        for (let a = s.firstChild; a; a = a.nextSibling) {
          let l;
          if (a.nodeType == 1)
            l = a.getClientRects();
          else if (a.nodeType == 3)
            l = ro(a, 0, a.nodeValue.length).getClientRects();
          else
            continue;
          for (let c2 = 0; c2 < l.length; c2++) {
            let u = l[c2];
            if (u.bottom > u.top + 1 && (n == "up" ? r.top - u.top > (u.bottom - r.top) * 2 : u.bottom - r.bottom > (r.bottom - u.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    const Dv = /[\u0590-\u08ac]/;
    function Lv(t2, e, n) {
      let { $head: o } = e.selection;
      if (!o.parent.isTextblock)
        return false;
      let i = o.parentOffset, s = !i, r = i == o.parent.content.size, a = t2.domSelection();
      return a ? !Dv.test(o.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? s : r : tf(t2, e, () => {
        let { focusNode: l, focusOffset: c2, anchorNode: u, anchorOffset: d } = t2.domSelectionRange(), p2 = a.caretBidiLevel;
        a.modify("move", n, "character");
        let m = o.depth ? t2.docView.domAfterPos(o.before()) : t2.dom, { focusNode: f, focusOffset: _ } = t2.domSelectionRange(), h2 = f && !m.contains(f.nodeType == 1 ? f : f.parentNode) || l == f && c2 == _;
        try {
          a.collapse(u, d), l && (l != u || c2 != d) && a.extend && a.extend(l, c2);
        } catch {
        }
        return p2 != null && (a.caretBidiLevel = p2), h2;
      }) : o.pos == o.start() || o.pos == o.end();
    }
    let md = null, fd = null, _d = false;
    function Pv(t2, e, n) {
      return md == e && fd == n ? _d : (md = e, fd = n, _d = n == "up" || n == "down" ? Iv(t2, e, n) : Lv(t2, e, n));
    }
    const yn = 0, hd = 1, Jo = 2, Xn = 3;
    class Us {
      constructor(e, n, o, i) {
        this.parent = e, this.children = n, this.dom = o, this.contentDOM = i, this.dirty = yn, o.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(e) {
        return false;
      }
      matchesMark(e) {
        return false;
      }
      matchesNode(e, n, o) {
        return false;
      }
      matchesHack(e) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(e) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let e = 0;
        for (let n = 0; n < this.children.length; n++)
          e += this.children[n].size;
        return e;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
          this.children[e].destroy();
      }
      posBeforeChild(e) {
        for (let n = 0, o = this.posAtStart; ; n++) {
          let i = this.children[n];
          if (i == e)
            return o;
          o += i.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(e, n, o) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
          if (o < 0) {
            let s, r;
            if (e == this.contentDOM)
              s = e.childNodes[n - 1];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              s = e.previousSibling;
            }
            for (; s && !((r = s.pmViewDesc) && r.parent == this); )
              s = s.previousSibling;
            return s ? this.posBeforeChild(r) + r.size : this.posAtStart;
          } else {
            let s, r;
            if (e == this.contentDOM)
              s = e.childNodes[n];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              s = e.nextSibling;
            }
            for (; s && !((r = s.pmViewDesc) && r.parent == this); )
              s = s.nextSibling;
            return s ? this.posBeforeChild(r) : this.posAtEnd;
          }
        let i;
        if (e == this.dom && this.contentDOM)
          i = n > Dt(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          i = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (n == 0)
            for (let s = e; ; s = s.parentNode) {
              if (s == this.dom) {
                i = false;
                break;
              }
              if (s.previousSibling)
                break;
            }
          if (i == null && n == e.childNodes.length)
            for (let s = e; ; s = s.parentNode) {
              if (s == this.dom) {
                i = true;
                break;
              }
              if (s.nextSibling)
                break;
            }
        }
        return i ?? o > 0 ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(e, n = false) {
        for (let o = true, i = e; i; i = i.parentNode) {
          let s = this.getDesc(i), r;
          if (s && (!n || s.node))
            if (o && (r = s.nodeDOM) && !(r.nodeType == 1 ? r.contains(e.nodeType == 1 ? e : e.parentNode) : r == e))
              o = false;
            else
              return s;
        }
      }
      getDesc(e) {
        let n = e.pmViewDesc;
        for (let o = n; o; o = o.parent)
          if (o == this)
            return n;
      }
      posFromDOM(e, n, o) {
        for (let i = e; i; i = i.parentNode) {
          let s = this.getDesc(i);
          if (s)
            return s.localPosFromDOM(e, n, o);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(e) {
        for (let n = 0, o = 0; n < this.children.length; n++) {
          let i = this.children[n], s = o + i.size;
          if (o == e && s != o) {
            for (; !i.border && i.children.length; )
              for (let r = 0; r < i.children.length; r++) {
                let a = i.children[r];
                if (a.size) {
                  i = a;
                  break;
                }
              }
            return i;
          }
          if (e < s)
            return i.descAt(e - o - i.border);
          o = s;
        }
      }
      domFromPos(e, n) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: e + 1 };
        let o = 0, i = 0;
        for (let s = 0; o < this.children.length; o++) {
          let r = this.children[o], a = s + r.size;
          if (a > e || r instanceof of) {
            i = e - s;
            break;
          }
          s = a;
        }
        if (i)
          return this.children[o].domFromPos(i - this.children[o].border, n);
        for (let s; o && !(s = this.children[o - 1]).size && s instanceof nf && s.side >= 0; o--)
          ;
        if (n <= 0) {
          let s, r = true;
          for (; s = o ? this.children[o - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); o--, r = false)
            ;
          return s && n && r && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? Dt(s.dom) + 1 : 0 };
        } else {
          let s, r = true;
          for (; s = o < this.children.length ? this.children[o] : null, !(!s || s.dom.parentNode == this.contentDOM); o++, r = false)
            ;
          return s && r && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? Dt(s.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(e, n, o = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let i = -1, s = -1;
        for (let r = o, a = 0; ; a++) {
          let l = this.children[a], c2 = r + l.size;
          if (i == -1 && e <= c2) {
            let u = r + l.border;
            if (e >= u && n <= c2 - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
              return l.parseRange(e, n, u);
            e = r;
            for (let d = a; d > 0; d--) {
              let p2 = this.children[d - 1];
              if (p2.size && p2.dom.parentNode == this.contentDOM && !p2.emptyChildAt(1)) {
                i = Dt(p2.dom) + 1;
                break;
              }
              e -= p2.size;
            }
            i == -1 && (i = 0);
          }
          if (i > -1 && (c2 > n || a == this.children.length - 1)) {
            n = c2;
            for (let u = a + 1; u < this.children.length; u++) {
              let d = this.children[u];
              if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
                s = Dt(d.dom);
                break;
              }
              n += d.size;
            }
            s == -1 && (s = this.contentDOM.childNodes.length);
            break;
          }
          r = c2;
        }
        return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s };
      }
      emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let n = this.children[e < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(e);
      }
      domAfterPos(e) {
        let { node: n, offset: o } = this.domFromPos(e, 0);
        if (n.nodeType != 1 || o == n.childNodes.length)
          throw new RangeError("No node after pos " + e);
        return n.childNodes[o];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(e, n, o, i = false) {
        let s = Math.min(e, n), r = Math.max(e, n);
        for (let m = 0, f = 0; m < this.children.length; m++) {
          let _ = this.children[m], h2 = f + _.size;
          if (s > f && r < h2)
            return _.setSelection(e - f - _.border, n - f - _.border, o, i);
          f = h2;
        }
        let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c2 = o.root.getSelection(), u = o.domSelectionRange(), d = false;
        if ((Dn || Gt) && e == n) {
          let { node: m, offset: f } = a;
          if (m.nodeType == 3) {
            if (d = !!(f && m.nodeValue[f - 1] == `
`), d && f == m.nodeValue.length)
              for (let _ = m, h2; _; _ = _.parentNode) {
                if (h2 = _.nextSibling) {
                  h2.nodeName == "BR" && (a = l = { node: h2.parentNode, offset: Dt(h2) + 1 });
                  break;
                }
                let g = _.pmViewDesc;
                if (g && g.node && g.node.isBlock)
                  break;
              }
          } else {
            let _ = m.childNodes[f - 1];
            d = _ && (_.nodeName == "BR" || _.contentEditable == "false");
          }
        }
        if (Dn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
          let m = u.focusNode.childNodes[u.focusOffset];
          m && m.contentEditable == "false" && (i = true);
        }
        if (!(i || d && Gt) && ai(a.node, a.offset, u.anchorNode, u.anchorOffset) && ai(l.node, l.offset, u.focusNode, u.focusOffset))
          return;
        let p2 = false;
        if ((c2.extend || e == n) && !d) {
          c2.collapse(a.node, a.offset);
          try {
            e != n && c2.extend(l.node, l.offset), p2 = true;
          } catch {
          }
        }
        if (!p2) {
          if (e > n) {
            let f = a;
            a = l, l = f;
          }
          let m = document.createRange();
          m.setEnd(l.node, l.offset), m.setStart(a.node, a.offset), c2.removeAllRanges(), c2.addRange(m);
        }
      }
      ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(e, n) {
        for (let o = 0, i = 0; i < this.children.length; i++) {
          let s = this.children[i], r = o + s.size;
          if (o == r ? e <= r && n >= o : e < r && n > o) {
            let a = o + s.border, l = r - s.border;
            if (e >= a && n <= l) {
              this.dirty = e == o || n == r ? Jo : hd, e == a && n == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Xn : s.markDirty(e - a, n - a);
              return;
            } else
              s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Jo : Xn;
          }
          o = r;
        }
        this.dirty = Jo;
      }
      markParentsDirty() {
        let e = 1;
        for (let n = this.parent; n; n = n.parent, e++) {
          let o = e == 1 ? Jo : hd;
          n.dirty < o && (n.dirty = o);
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      isText(e) {
        return false;
      }
    }
    class nf extends Us {
      constructor(e, n, o, i) {
        let s, r = n.type.toDOM;
        if (typeof r == "function" && (r = r(o, () => {
          if (!s)
            return i;
          if (s.parent)
            return s.parent.posBeforeChild(s);
        })), !n.type.spec.raw) {
          if (r.nodeType != 1) {
            let a = document.createElement("span");
            a.appendChild(r), r = a;
          }
          r.contentEditable = "false", r.classList.add("ProseMirror-widget");
        }
        super(e, [], r, null), this.widget = n, this.widget = n, s = this;
      }
      matchesWidget(e) {
        return this.dirty == yn && e.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(e) {
        let n = this.widget.spec.stopEvent;
        return n ? n(e) : false;
      }
      ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom), super.destroy();
      }
      get domAtom() {
        return true;
      }
      get side() {
        return this.widget.type.side;
      }
    }
    class Bv extends Us {
      constructor(e, n, o, i) {
        super(e, [], n, null), this.textDOM = o, this.text = i;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(e, n) {
        return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
      }
      domFromPos(e) {
        return { node: this.textDOM, offset: e };
      }
      ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue;
      }
    }
    class li extends Us {
      constructor(e, n, o, i, s) {
        super(e, [], o, i), this.mark = n, this.spec = s;
      }
      static create(e, n, o, i) {
        let s = i.nodeViews[n.type.name], r = s && s(n, i, o);
        return (!r || !r.dom) && (r = mi.renderSpec(document, n.type.spec.toDOM(n, o), null, n.attrs)), new li(e, n, r.dom, r.contentDOM || r.dom, r);
      }
      parseRule() {
        return this.dirty & Xn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(e) {
        return this.dirty != Xn && this.mark.eq(e);
      }
      markDirty(e, n) {
        if (super.markDirty(e, n), this.dirty != yn) {
          let o = this.parent;
          for (; !o.node; )
            o = o.parent;
          o.dirty < this.dirty && (o.dirty = this.dirty), this.dirty = yn;
        }
      }
      slice(e, n, o) {
        let i = li.create(this.parent, this.mark, true, o), s = this.children, r = this.size;
        n < r && (s = Yl(s, n, r, o)), e > 0 && (s = Yl(s, 0, e, o));
        for (let a = 0; a < s.length; a++)
          s[a].parent = i;
        return i.children = s, i;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
    }
    class Io extends Us {
      constructor(e, n, o, i, s, r, a, l, c2) {
        super(e, [], s, r), this.node = n, this.outerDeco = o, this.innerDeco = i, this.nodeDOM = a;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(e, n, o, i, s, r) {
        let a = s.nodeViews[n.type.name], l, c2 = a && a(n, s, () => {
          if (!l)
            return r;
          if (l.parent)
            return l.parent.posBeforeChild(l);
        }, o, i), u = c2 && c2.dom, d = c2 && c2.contentDOM;
        if (n.isText) {
          if (!u)
            u = document.createTextNode(n.text);
          else if (u.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else u || ({ dom: u, contentDOM: d } = mi.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
        !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = true));
        let p2 = u;
        return u = af(u, o, n), c2 ? l = new $v(e, n, o, i, u, d || null, p2, c2, s, r + 1) : n.isText ? new Ra(e, n, o, i, u, p2, s) : new Io(e, n, o, i, u, d || null, p2, s, r + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let e = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
          e.getContent = () => this.node.content;
        else if (!this.contentLost)
          e.contentElement = this.contentDOM;
        else {
          for (let n = this.children.length - 1; n >= 0; n--) {
            let o = this.children[n];
            if (this.dom.contains(o.dom.parentNode)) {
              e.contentElement = o.dom.parentNode;
              break;
            }
          }
          e.contentElement || (e.getContent = () => D.empty);
        }
        return e;
      }
      matchesNode(e, n, o) {
        return this.dirty == yn && e.eq(this.node) && $r(n, this.outerDeco) && o.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(e, n) {
        let o = this.node.inlineContent, i = n, s = e.composing ? this.localCompositionInfo(e, n) : null, r = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new Fv(this, r && r.node, e);
        Vv(this.node, this.innerDeco, (c2, u, d) => {
          c2.spec.marks ? l.syncToMarks(c2.spec.marks, o, e) : c2.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Ze.none : this.node.child(u).marks, o, e), l.placeWidget(c2, e, i);
        }, (c2, u, d, p2) => {
          l.syncToMarks(c2.marks, o, e);
          let m;
          l.findNodeMatch(c2, u, d, p2) || a && e.state.selection.from > i && e.state.selection.to < i + c2.nodeSize && (m = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c2, u, d, m, e) || l.updateNextNode(c2, u, d, e, p2, i) || l.addNode(c2, u, d, e, i), i += c2.nodeSize;
        }), l.syncToMarks([], o, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Jo) && (r && this.protectLocalComposition(e, r), sf(this.contentDOM, this.children, e), Ri && qv(this.dom));
      }
      localCompositionInfo(e, n) {
        let { from: o, to: i } = e.state.selection;
        if (!(e.state.selection instanceof re) || o < n || i > n + this.node.content.size)
          return null;
        let s = e.input.compositionNode;
        if (!s || !this.dom.contains(s.parentNode))
          return null;
        if (this.node.inlineContent) {
          let r = s.nodeValue, a = Kv(this.node.content, r, o - n, i - n);
          return a < 0 ? null : { node: s, pos: a, text: r };
        } else
          return { node: s, pos: -1, text: "" };
      }
      protectLocalComposition(e, { node: n, pos: o, text: i }) {
        if (this.getDesc(n))
          return;
        let s = n;
        for (; s.parentNode != this.contentDOM; s = s.parentNode) {
          for (; s.previousSibling; )
            s.parentNode.removeChild(s.previousSibling);
          for (; s.nextSibling; )
            s.parentNode.removeChild(s.nextSibling);
          s.pmViewDesc && (s.pmViewDesc = void 0);
        }
        let r = new Bv(this, s, n, i);
        e.input.compositionNodes.push(r), this.children = Yl(this.children, o, o + i.length, e, r);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(e, n, o, i) {
        return this.dirty == Xn || !e.sameMarkup(this.node) ? false : (this.updateInner(e, n, o, i), true);
      }
      updateInner(e, n, o, i) {
        this.updateOuterDeco(n), this.node = e, this.innerDeco = o, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = yn;
      }
      updateOuterDeco(e) {
        if ($r(e, this.outerDeco))
          return;
        let n = this.nodeDOM.nodeType != 1, o = this.dom;
        this.dom = rf(this.dom, this.nodeDOM, Jl(this.outerDeco, this.node, n), Jl(e, this.node, n)), this.dom != o && (o.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
      }
      // Mark this node as being the selected node.
      selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
      }
      // Remove selected node marking from this node.
      deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
      }
      get domAtom() {
        return this.node.isAtom;
      }
    }
    function gd(t2, e, n, o, i) {
      af(o, e, t2);
      let s = new Io(void 0, t2, e, n, o, o, o, i, 0);
      return s.contentDOM && s.updateChildren(i, 0), s;
    }
    class Ra extends Io {
      constructor(e, n, o, i, s, r, a) {
        super(e, n, o, i, s, null, r, a, 0);
      }
      parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco; )
          e = e.parentNode;
        return { skip: e || true };
      }
      update(e, n, o, i) {
        return this.dirty == Xn || this.dirty != yn && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(n), (this.dirty != yn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = yn, true);
      }
      inParent() {
        let e = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
          if (n == e)
            return true;
        return false;
      }
      domFromPos(e) {
        return { node: this.nodeDOM, offset: e };
      }
      localPosFromDOM(e, n, o) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, o);
      }
      ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection";
      }
      slice(e, n, o) {
        let i = this.node.cut(e, n), s = document.createTextNode(i.text);
        return new Ra(this.parent, i, this.outerDeco, this.innerDeco, s, s, o);
      }
      markDirty(e, n) {
        super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Xn);
      }
      get domAtom() {
        return false;
      }
      isText(e) {
        return this.node.text == e;
      }
    }
    class of extends Us {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(e) {
        return this.dirty == yn && this.dom.nodeName == e;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    }
    class $v extends Io {
      constructor(e, n, o, i, s, r, a, l, c2, u) {
        super(e, n, o, i, s, r, a, c2, u), this.spec = l;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(e, n, o, i) {
        if (this.dirty == Xn)
          return false;
        if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
          let s = this.spec.update(e, n, o);
          return s && this.updateInner(e, n, o, i), s;
        } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, n, o, i);
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(e, n, o, i) {
        this.spec.setSelection ? this.spec.setSelection(e, n, o.root) : super.setSelection(e, n, o, i);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
      stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
    }
    function sf(t2, e, n) {
      let o = t2.firstChild, i = false;
      for (let s = 0; s < e.length; s++) {
        let r = e[s], a = r.dom;
        if (a.parentNode == t2) {
          for (; a != o; )
            o = vd(o), i = true;
          o = o.nextSibling;
        } else
          i = true, t2.insertBefore(a, o);
        if (r instanceof li) {
          let l = o ? o.previousSibling : t2.lastChild;
          sf(r.contentDOM, r.children, n), o = l ? l.nextSibling : t2.firstChild;
        }
      }
      for (; o; )
        o = vd(o), i = true;
      i && n.trackWrites == t2 && (n.trackWrites = null);
    }
    const ls = function(t2) {
      t2 && (this.nodeName = t2);
    };
    ls.prototype = /* @__PURE__ */ Object.create(null);
    const Yo = [new ls()];
    function Jl(t2, e, n) {
      if (t2.length == 0)
        return Yo;
      let o = n ? Yo[0] : new ls(), i = [o];
      for (let s = 0; s < t2.length; s++) {
        let r = t2[s].type.attrs;
        if (r) {
          r.nodeName && i.push(o = new ls(r.nodeName));
          for (let a in r) {
            let l = r[a];
            l != null && (n && i.length == 1 && i.push(o = new ls(e.isInline ? "span" : "div")), a == "class" ? o.class = (o.class ? o.class + " " : "") + l : a == "style" ? o.style = (o.style ? o.style + ";" : "") + l : a != "nodeName" && (o[a] = l));
          }
        }
      }
      return i;
    }
    function rf(t2, e, n, o) {
      if (n == Yo && o == Yo)
        return e;
      let i = e;
      for (let s = 0; s < o.length; s++) {
        let r = o[s], a = n[s];
        if (s) {
          let l;
          a && a.nodeName == r.nodeName && i != t2 && (l = i.parentNode) && l.nodeName.toLowerCase() == r.nodeName || (l = document.createElement(r.nodeName), l.pmIsDeco = true, l.appendChild(i), a = Yo[0]), i = l;
        }
        zv(i, a || Yo[0], r);
      }
      return i;
    }
    function zv(t2, e, n) {
      for (let o in e)
        o != "class" && o != "style" && o != "nodeName" && !(o in n) && t2.removeAttribute(o);
      for (let o in n)
        o != "class" && o != "style" && o != "nodeName" && n[o] != e[o] && t2.setAttribute(o, n[o]);
      if (e.class != n.class) {
        let o = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let s = 0; s < o.length; s++)
          i.indexOf(o[s]) == -1 && t2.classList.remove(o[s]);
        for (let s = 0; s < i.length; s++)
          o.indexOf(i[s]) == -1 && t2.classList.add(i[s]);
        t2.classList.length == 0 && t2.removeAttribute("class");
      }
      if (e.style != n.style) {
        if (e.style) {
          let o = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
          for (; i = o.exec(e.style); )
            t2.style.removeProperty(i[1]);
        }
        n.style && (t2.style.cssText += n.style);
      }
    }
    function af(t2, e, n) {
      return rf(t2, t2, Yo, Jl(e, n, t2.nodeType != 1));
    }
    function $r(t2, e) {
      if (t2.length != e.length)
        return false;
      for (let n = 0; n < t2.length; n++)
        if (!t2[n].type.eq(e[n].type))
          return false;
      return true;
    }
    function vd(t2) {
      let e = t2.nextSibling;
      return t2.parentNode.removeChild(t2), e;
    }
    class Fv {
      constructor(e, n, o) {
        this.lock = n, this.view = o, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = Hv(e.node.content, e);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(e, n) {
        if (e != n) {
          for (let o = e; o < n; o++)
            this.top.children[o].destroy();
          this.top.children.splice(e, n - e), this.changed = true;
        }
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(e, n, o) {
        let i = 0, s = this.stack.length >> 1, r = Math.min(s, e.length);
        for (; i < r && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== false; )
          i++;
        for (; i < s; )
          this.destroyRest(), this.top.dirty = yn, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
        for (; s < e.length; ) {
          this.stack.push(this.top, this.index + 1);
          let a = -1;
          for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
            let c2 = this.top.children[l];
            if (c2.matchesMark(e[s]) && !this.isLocked(c2.dom)) {
              a = l;
              break;
            }
          }
          if (a > -1)
            a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
          else {
            let l = li.create(this.top, e[s], n, o);
            this.top.children.splice(this.index, 0, l), this.top = l, this.changed = true;
          }
          this.index = 0, s++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(e, n, o, i) {
        let s = -1, r;
        if (i >= this.preMatch.index && (r = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && r.matchesNode(e, n, o))
          s = this.top.children.indexOf(r, this.index);
        else
          for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
            let c2 = this.top.children[a];
            if (c2.matchesNode(e, n, o) && !this.preMatch.matched.has(c2)) {
              s = a;
              break;
            }
          }
        return s < 0 ? false : (this.destroyBetween(this.index, s), this.index++, true);
      }
      updateNodeAt(e, n, o, i, s) {
        let r = this.top.children[i];
        return r.dirty == Xn && r.dom == r.contentDOM && (r.dirty = Jo), r.update(e, n, o, s) ? (this.destroyBetween(this.index, i), this.index++, true) : false;
      }
      findIndexWithChild(e) {
        for (; ; ) {
          let n = e.parentNode;
          if (!n)
            return -1;
          if (n == this.top.contentDOM) {
            let o = e.pmViewDesc;
            if (o) {
              for (let i = this.index; i < this.top.children.length; i++)
                if (this.top.children[i] == o)
                  return i;
            }
            return -1;
          }
          e = n;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(e, n, o, i, s, r) {
        for (let a = this.index; a < this.top.children.length; a++) {
          let l = this.top.children[a];
          if (l instanceof Io) {
            let c2 = this.preMatch.matched.get(l);
            if (c2 != null && c2 != s)
              return false;
            let u = l.dom, d, p2 = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Xn && $r(n, l.outerDeco));
            if (!p2 && l.update(e, n, o, i))
              return this.destroyBetween(this.index, a), l.dom != u && (this.changed = true), this.index++, true;
            if (!p2 && (d = this.recreateWrapper(l, e, n, o, i, r)))
              return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Jo, d.updateChildren(i, r + 1), d.dirty = yn), this.changed = true, this.index++, true;
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(e, n, o, i, s, r) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !$r(o, e.outerDeco) || !i.eq(e.innerDeco))
          return null;
        let a = Io.create(this.top, n, o, i, s, r);
        if (a.contentDOM) {
          a.children = e.children, e.children = [];
          for (let l of a.children)
            l.parent = a;
        }
        return e.destroy(), a;
      }
      // Insert the node as a newly created node desc.
      addNode(e, n, o, i, s) {
        let r = Io.create(this.top, e, n, o, i, s);
        r.contentDOM && r.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, r), this.changed = true;
      }
      placeWidget(e, n, o) {
        let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
          this.index++;
        else {
          let s = new nf(this.top, e, n, o);
          this.top.children.splice(this.index++, 0, s), this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let e = this.top.children[this.index - 1], n = this.top;
        for (; e instanceof li; )
          n = e, e = n.children[n.children.length - 1];
        (!e || // Empty textblock
        !(e instanceof Ra) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Gt || zt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
      }
      addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
          this.index++;
        else {
          let o = document.createElement(e);
          e == "IMG" && (o.className = "ProseMirror-separator", o.alt = ""), e == "BR" && (o.className = "ProseMirror-trailingBreak");
          let i = new of(this.top, [], o, null);
          n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = true;
        }
      }
      isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
      }
    }
    function Hv(t2, e) {
      let n = e, o = n.children.length, i = t2.childCount, s = /* @__PURE__ */ new Map(), r = [];
      e: for (; i > 0; ) {
        let a;
        for (; ; )
          if (o) {
            let c2 = n.children[o - 1];
            if (c2 instanceof li)
              n = c2, o = c2.children.length;
            else {
              a = c2, o--;
              break;
            }
          } else {
            if (n == e)
              break e;
            o = n.parent.children.indexOf(n), n = n.parent;
          }
        let l = a.node;
        if (l) {
          if (l != t2.child(i - 1))
            break;
          --i, s.set(a, i), r.push(a);
        }
      }
      return { index: i, matched: s, matches: r.reverse() };
    }
    function Uv(t2, e) {
      return t2.type.side - e.type.side;
    }
    function Vv(t2, e, n, o) {
      let i = e.locals(t2), s = 0;
      if (i.length == 0) {
        for (let c2 = 0; c2 < t2.childCount; c2++) {
          let u = t2.child(c2);
          o(u, i, e.forChild(s, u), c2), s += u.nodeSize;
        }
        return;
      }
      let r = 0, a = [], l = null;
      for (let c2 = 0; ; ) {
        let u, d;
        for (; r < i.length && i[r].to == s; ) {
          let h2 = i[r++];
          h2.widget && (u ? (d || (d = [u])).push(h2) : u = h2);
        }
        if (u)
          if (d) {
            d.sort(Uv);
            for (let h2 = 0; h2 < d.length; h2++)
              n(d[h2], c2, !!l);
          } else
            n(u, c2, !!l);
        let p2, m;
        if (l)
          m = -1, p2 = l, l = null;
        else if (c2 < t2.childCount)
          m = c2, p2 = t2.child(c2++);
        else
          break;
        for (let h2 = 0; h2 < a.length; h2++)
          a[h2].to <= s && a.splice(h2--, 1);
        for (; r < i.length && i[r].from <= s && i[r].to > s; )
          a.push(i[r++]);
        let f = s + p2.nodeSize;
        if (p2.isText) {
          let h2 = f;
          r < i.length && i[r].from < h2 && (h2 = i[r].from);
          for (let g = 0; g < a.length; g++)
            a[g].to < h2 && (h2 = a[g].to);
          h2 < f && (l = p2.cut(h2 - s), p2 = p2.cut(0, h2 - s), f = h2, m = -1);
        } else
          for (; r < i.length && i[r].to < f; )
            r++;
        let _ = p2.isInline && !p2.isLeaf ? a.filter((h2) => !h2.inline) : a.slice();
        o(p2, _, e.forChild(s, p2), m), s = f;
      }
    }
    function qv(t2) {
      if (t2.nodeName == "UL" || t2.nodeName == "OL") {
        let e = t2.style.cssText;
        t2.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t2).listStyle, t2.style.cssText = e;
      }
    }
    function Kv(t2, e, n, o) {
      for (let i = 0, s = 0; i < t2.childCount && s <= o; ) {
        let r = t2.child(i++), a = s;
        if (s += r.nodeSize, !r.isText)
          continue;
        let l = r.text;
        for (; i < t2.childCount; ) {
          let c2 = t2.child(i++);
          if (s += c2.nodeSize, !c2.isText)
            break;
          l += c2.text;
        }
        if (s >= n) {
          if (s >= o && l.slice(o - e.length - a, o - a) == e)
            return o - e.length;
          let c2 = a < o ? l.lastIndexOf(e, o - a - 1) : -1;
          if (c2 >= 0 && c2 + e.length + a >= n)
            return a + c2;
          if (n == o && l.length >= o + e.length - a && l.slice(o - a, o - a + e.length) == e)
            return o;
        }
      }
      return -1;
    }
    function Yl(t2, e, n, o, i) {
      let s = [];
      for (let r = 0, a = 0; r < t2.length; r++) {
        let l = t2[r], c2 = a, u = a += l.size;
        c2 >= n || u <= e ? s.push(l) : (c2 < e && s.push(l.slice(0, e - c2, o)), i && (s.push(i), i = void 0), u > n && s.push(l.slice(n - c2, l.size, o)));
      }
      return s;
    }
    function Mc(t2, e = null) {
      let n = t2.domSelectionRange(), o = t2.state.doc;
      if (!n.focusNode)
        return null;
      let i = t2.docView.nearestDesc(n.focusNode), s = i && i.size == 0, r = t2.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
      if (r < 0)
        return null;
      let a = o.resolve(r), l, c2;
      if (Ma(n)) {
        for (l = r; i && !i.node; )
          i = i.parent;
        let d = i.node;
        if (i && d.isAtom && ie.isSelectable(d) && i.parent && !(d.isInline && vv(n.focusNode, n.focusOffset, i.dom))) {
          let p2 = i.posBefore;
          c2 = new ie(r == p2 ? a : o.resolve(p2));
        }
      } else {
        if (n instanceof t2.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
          let d = r, p2 = r;
          for (let m = 0; m < n.rangeCount; m++) {
            let f = n.getRangeAt(m);
            d = Math.min(d, t2.docView.posFromDOM(f.startContainer, f.startOffset, 1)), p2 = Math.max(p2, t2.docView.posFromDOM(f.endContainer, f.endOffset, -1));
          }
          if (d < 0)
            return null;
          [l, r] = p2 == t2.state.selection.anchor ? [p2, d] : [d, p2], a = o.resolve(r);
        } else
          l = t2.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (l < 0)
          return null;
      }
      let u = o.resolve(l);
      if (!c2) {
        let d = e == "pointer" || t2.state.selection.head < a.pos && !s ? 1 : -1;
        c2 = Rc(t2, u, a, d);
      }
      return c2;
    }
    function lf(t2) {
      return t2.editable ? t2.hasFocus() : uf(t2) && document.activeElement && document.activeElement.contains(t2.dom);
    }
    function po(t2, e = false) {
      let n = t2.state.selection;
      if (cf(t2, n), !!lf(t2)) {
        if (!e && t2.input.mouseDown && t2.input.mouseDown.allowDefault && zt) {
          let o = t2.domSelectionRange(), i = t2.domObserver.currentSelection;
          if (o.anchorNode && i.anchorNode && ai(o.anchorNode, o.anchorOffset, i.anchorNode, i.anchorOffset)) {
            t2.input.mouseDown.delayedSelectionSync = true, t2.domObserver.setCurSelection();
            return;
          }
        }
        if (t2.domObserver.disconnectSelection(), t2.cursorWrapper)
          Gv(t2);
        else {
          let { anchor: o, head: i } = n, s, r;
          bd && !(n instanceof re) && (n.$from.parent.inlineContent || (s = kd(t2, n.from)), !n.empty && !n.$from.parent.inlineContent && (r = kd(t2, n.to))), t2.docView.setSelection(o, i, t2, e), bd && (s && yd(s), r && yd(r)), n.visible ? t2.dom.classList.remove("ProseMirror-hideselection") : (t2.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Wv(t2));
        }
        t2.domObserver.setCurSelection(), t2.domObserver.connectSelection();
      }
    }
    const bd = Gt || zt && Jm < 63;
    function kd(t2, e) {
      let { node: n, offset: o } = t2.docView.domFromPos(e, 0), i = o < n.childNodes.length ? n.childNodes[o] : null, s = o ? n.childNodes[o - 1] : null;
      if (Gt && i && i.contentEditable == "false")
        return ul(i);
      if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
        if (i)
          return ul(i);
        if (s)
          return ul(s);
      }
    }
    function ul(t2) {
      return t2.contentEditable = "true", Gt && t2.draggable && (t2.draggable = false, t2.wasDraggable = true), t2;
    }
    function yd(t2) {
      t2.contentEditable = "false", t2.wasDraggable && (t2.draggable = true, t2.wasDraggable = null);
    }
    function Wv(t2) {
      let e = t2.dom.ownerDocument;
      e.removeEventListener("selectionchange", t2.input.hideSelectionGuard);
      let n = t2.domSelectionRange(), o = n.anchorNode, i = n.anchorOffset;
      e.addEventListener("selectionchange", t2.input.hideSelectionGuard = () => {
        (n.anchorNode != o || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t2.input.hideSelectionGuard), setTimeout(() => {
          (!lf(t2) || t2.state.selection.visible) && t2.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
      });
    }
    function Gv(t2) {
      let e = t2.domSelection(), n = document.createRange();
      if (!e)
        return;
      let o = t2.cursorWrapper.dom, i = o.nodeName == "IMG";
      i ? n.setStart(o.parentNode, Dt(o) + 1) : n.setStart(o, 0), n.collapse(true), e.removeAllRanges(), e.addRange(n), !i && !t2.state.selection.visible && en && Ro <= 11 && (o.disabled = true, o.disabled = false);
    }
    function cf(t2, e) {
      if (e instanceof ie) {
        let n = t2.docView.descAt(e.from);
        n != t2.lastSelectedViewDesc && (wd(t2), n && n.selectNode(), t2.lastSelectedViewDesc = n);
      } else
        wd(t2);
    }
    function wd(t2) {
      t2.lastSelectedViewDesc && (t2.lastSelectedViewDesc.parent && t2.lastSelectedViewDesc.deselectNode(), t2.lastSelectedViewDesc = void 0);
    }
    function Rc(t2, e, n, o) {
      return t2.someProp("createSelectionBetween", (i) => i(t2, e, n)) || re.between(e, n, o);
    }
    function jd(t2) {
      return t2.editable && !t2.hasFocus() ? false : uf(t2);
    }
    function uf(t2) {
      let e = t2.domSelectionRange();
      if (!e.anchorNode)
        return false;
      try {
        return t2.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t2.editable || t2.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
      } catch {
        return false;
      }
    }
    function Jv(t2) {
      let e = t2.docView.domFromPos(t2.state.selection.anchor, 0), n = t2.domSelectionRange();
      return ai(e.node, e.offset, n.anchorNode, n.anchorOffset);
    }
    function Xl(t2, e) {
      let { $anchor: n, $head: o } = t2.selection, i = e > 0 ? n.max(o) : n.min(o), s = i.parent.inlineContent ? i.depth ? t2.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
      return s && de.findFrom(s, e);
    }
    function wo(t2, e) {
      return t2.dispatch(t2.state.tr.setSelection(e).scrollIntoView()), true;
    }
    function Ed(t2, e, n) {
      let o = t2.state.selection;
      if (o instanceof re)
        if (n.indexOf("s") > -1) {
          let { $head: i } = o, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
          if (!s || s.isText || !s.isLeaf)
            return false;
          let r = t2.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
          return wo(t2, new re(o.$anchor, r));
        } else if (o.empty) {
          if (t2.endOfTextblock(e > 0 ? "forward" : "backward")) {
            let i = Xl(t2.state, e);
            return i && i instanceof ie ? wo(t2, i) : false;
          } else if (!(vn && n.indexOf("m") > -1)) {
            let i = o.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, r;
            if (!s || s.isText)
              return false;
            let a = e < 0 ? i.pos - s.nodeSize : i.pos;
            return s.isAtom || (r = t2.docView.descAt(a)) && !r.contentDOM ? ie.isSelectable(s) ? wo(t2, new ie(e < 0 ? t2.state.doc.resolve(i.pos - s.nodeSize) : i)) : Hs ? wo(t2, new re(t2.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : false : false;
          }
        } else return false;
      else {
        if (o instanceof ie && o.node.isInline)
          return wo(t2, new re(e > 0 ? o.$to : o.$from));
        {
          let i = Xl(t2.state, e);
          return i ? wo(t2, i) : false;
        }
      }
    }
    function zr(t2) {
      return t2.nodeType == 3 ? t2.nodeValue.length : t2.childNodes.length;
    }
    function cs(t2, e) {
      let n = t2.pmViewDesc;
      return n && n.size == 0 && (e < 0 || t2.nextSibling || t2.nodeName != "BR");
    }
    function hi(t2, e) {
      return e < 0 ? Yv(t2) : Xv(t2);
    }
    function Yv(t2) {
      let e = t2.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
      if (!n)
        return;
      let i, s, r = false;
      for (Dn && n.nodeType == 1 && o < zr(n) && cs(n.childNodes[o], -1) && (r = true); ; )
        if (o > 0) {
          if (n.nodeType != 1)
            break;
          {
            let a = n.childNodes[o - 1];
            if (cs(a, -1))
              i = n, s = --o;
            else if (a.nodeType == 3)
              n = a, o = n.nodeValue.length;
            else
              break;
          }
        } else {
          if (df(n))
            break;
          {
            let a = n.previousSibling;
            for (; a && cs(a, -1); )
              i = n.parentNode, s = Dt(a), a = a.previousSibling;
            if (a)
              n = a, o = zr(n);
            else {
              if (n = n.parentNode, n == t2.dom)
                break;
              o = 0;
            }
          }
        }
      r ? Zl(t2, n, o) : i && Zl(t2, i, s);
    }
    function Xv(t2) {
      let e = t2.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
      if (!n)
        return;
      let i = zr(n), s, r;
      for (; ; )
        if (o < i) {
          if (n.nodeType != 1)
            break;
          let a = n.childNodes[o];
          if (cs(a, 1))
            s = n, r = ++o;
          else
            break;
        } else {
          if (df(n))
            break;
          {
            let a = n.nextSibling;
            for (; a && cs(a, 1); )
              s = a.parentNode, r = Dt(a) + 1, a = a.nextSibling;
            if (a)
              n = a, o = 0, i = zr(n);
            else {
              if (n = n.parentNode, n == t2.dom)
                break;
              o = i = 0;
            }
          }
        }
      s && Zl(t2, s, r);
    }
    function df(t2) {
      let e = t2.pmViewDesc;
      return e && e.node && e.node.isBlock;
    }
    function Zv(t2, e) {
      for (; t2 && e == t2.childNodes.length && !Fs(t2); )
        e = Dt(t2) + 1, t2 = t2.parentNode;
      for (; t2 && e < t2.childNodes.length; ) {
        let n = t2.childNodes[e];
        if (n.nodeType == 3)
          return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
          break;
        t2 = n, e = 0;
      }
    }
    function Qv(t2, e) {
      for (; t2 && !e && !Fs(t2); )
        e = Dt(t2), t2 = t2.parentNode;
      for (; t2 && e; ) {
        let n = t2.childNodes[e - 1];
        if (n.nodeType == 3)
          return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
          break;
        t2 = n, e = t2.childNodes.length;
      }
    }
    function Zl(t2, e, n) {
      if (e.nodeType != 3) {
        let s, r;
        (r = Zv(e, n)) ? (e = r, n = 0) : (s = Qv(e, n)) && (e = s, n = s.nodeValue.length);
      }
      let o = t2.domSelection();
      if (!o)
        return;
      if (Ma(o)) {
        let s = document.createRange();
        s.setEnd(e, n), s.setStart(e, n), o.removeAllRanges(), o.addRange(s);
      } else o.extend && o.extend(e, n);
      t2.domObserver.setCurSelection();
      let { state: i } = t2;
      setTimeout(() => {
        t2.state == i && po(t2);
      }, 50);
    }
    function Sd(t2, e) {
      let n = t2.state.doc.resolve(e);
      if (!(zt || yv) && n.parent.inlineContent) {
        let i = t2.coordsAtPos(e);
        if (e > n.start()) {
          let s = t2.coordsAtPos(e - 1), r = (s.top + s.bottom) / 2;
          if (r > i.top && r < i.bottom && Math.abs(s.left - i.left) > 1)
            return s.left < i.left ? "ltr" : "rtl";
        }
        if (e < n.end()) {
          let s = t2.coordsAtPos(e + 1), r = (s.top + s.bottom) / 2;
          if (r > i.top && r < i.bottom && Math.abs(s.left - i.left) > 1)
            return s.left > i.left ? "ltr" : "rtl";
        }
      }
      return getComputedStyle(t2.dom).direction == "rtl" ? "rtl" : "ltr";
    }
    function Cd(t2, e, n) {
      let o = t2.state.selection;
      if (o instanceof re && !o.empty || n.indexOf("s") > -1 || vn && n.indexOf("m") > -1)
        return false;
      let { $from: i, $to: s } = o;
      if (!i.parent.inlineContent || t2.endOfTextblock(e < 0 ? "up" : "down")) {
        let r = Xl(t2.state, e);
        if (r && r instanceof ie)
          return wo(t2, r);
      }
      if (!i.parent.inlineContent) {
        let r = e < 0 ? i : s, a = o instanceof pn ? de.near(r, e) : de.findFrom(r, e);
        return a ? wo(t2, a) : false;
      }
      return false;
    }
    function xd(t2, e) {
      if (!(t2.state.selection instanceof re))
        return true;
      let { $head: n, $anchor: o, empty: i } = t2.state.selection;
      if (!n.sameParent(o))
        return true;
      if (!i)
        return false;
      if (t2.endOfTextblock(e > 0 ? "forward" : "backward"))
        return true;
      let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
      if (s && !s.isText) {
        let r = t2.state.tr;
        return e < 0 ? r.delete(n.pos - s.nodeSize, n.pos) : r.delete(n.pos, n.pos + s.nodeSize), t2.dispatch(r), true;
      }
      return false;
    }
    function Td(t2, e, n) {
      t2.domObserver.stop(), e.contentEditable = n, t2.domObserver.start();
    }
    function e0(t2) {
      if (!Gt || t2.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode: e, focusOffset: n } = t2.domSelectionRange();
      if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let o = e.firstChild;
        Td(t2, o, "true"), setTimeout(() => Td(t2, o, "false"), 20);
      }
      return false;
    }
    function t0(t2) {
      let e = "";
      return t2.ctrlKey && (e += "c"), t2.metaKey && (e += "m"), t2.altKey && (e += "a"), t2.shiftKey && (e += "s"), e;
    }
    function n0(t2, e) {
      let n = e.keyCode, o = t0(e);
      if (n == 8 || vn && n == 72 && o == "c")
        return xd(t2, -1) || hi(t2, -1);
      if (n == 46 && !e.shiftKey || vn && n == 68 && o == "c")
        return xd(t2, 1) || hi(t2, 1);
      if (n == 13 || n == 27)
        return true;
      if (n == 37 || vn && n == 66 && o == "c") {
        let i = n == 37 ? Sd(t2, t2.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return Ed(t2, i, o) || hi(t2, i);
      } else if (n == 39 || vn && n == 70 && o == "c") {
        let i = n == 39 ? Sd(t2, t2.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return Ed(t2, i, o) || hi(t2, i);
      } else {
        if (n == 38 || vn && n == 80 && o == "c")
          return Cd(t2, -1, o) || hi(t2, -1);
        if (n == 40 || vn && n == 78 && o == "c")
          return e0(t2) || Cd(t2, 1, o) || hi(t2, 1);
        if (o == (vn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
          return true;
      }
      return false;
    }
    function Ic(t2, e) {
      t2.someProp("transformCopied", (m) => {
        e = m(e, t2);
      });
      let n = [], { content: o, openStart: i, openEnd: s } = e;
      for (; i > 1 && s > 1 && o.childCount == 1 && o.firstChild.childCount == 1; ) {
        i--, s--;
        let m = o.firstChild;
        n.push(m.type.name, m.attrs != m.type.defaultAttrs ? m.attrs : null), o = m.content;
      }
      let r = t2.someProp("clipboardSerializer") || mi.fromSchema(t2.state.schema), a = gf(), l = a.createElement("div");
      l.appendChild(r.serializeFragment(o, { document: a }));
      let c2 = l.firstChild, u, d = 0;
      for (; c2 && c2.nodeType == 1 && (u = hf[c2.nodeName.toLowerCase()]); ) {
        for (let m = u.length - 1; m >= 0; m--) {
          let f = a.createElement(u[m]);
          for (; l.firstChild; )
            f.appendChild(l.firstChild);
          l.appendChild(f), d++;
        }
        c2 = l.firstChild;
      }
      c2 && c2.nodeType == 1 && c2.setAttribute("data-pm-slice", `${i} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
      let p2 = t2.someProp("clipboardTextSerializer", (m) => m(e, t2)) || e.content.textBetween(0, e.content.size, `

`);
      return { dom: l, text: p2, slice: e };
    }
    function pf(t2, e, n, o, i) {
      let s = i.parent.type.spec.code, r, a;
      if (!n && !e)
        return null;
      let l = e && (o || s || !n);
      if (l) {
        if (t2.someProp("transformPastedText", (p2) => {
          e = p2(e, s || o, t2);
        }), s)
          return e ? new K(D.from(t2.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : K.empty;
        let d = t2.someProp("clipboardTextParser", (p2) => p2(e, i, o, t2));
        if (d)
          a = d;
        else {
          let p2 = i.marks(), { schema: m } = t2.state, f = mi.fromSchema(m);
          r = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((_) => {
            let h2 = r.appendChild(document.createElement("p"));
            _ && h2.appendChild(f.serializeNode(m.text(_, p2)));
          });
        }
      } else
        t2.someProp("transformPastedHTML", (d) => {
          n = d(n, t2);
        }), r = r0(n), Hs && a0(r);
      let c2 = r && r.querySelector("[data-pm-slice]"), u = c2 && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c2.getAttribute("data-pm-slice") || "");
      if (u && u[3])
        for (let d = +u[3]; d > 0; d--) {
          let p2 = r.firstChild;
          for (; p2 && p2.nodeType != 1; )
            p2 = p2.nextSibling;
          if (!p2)
            break;
          r = p2;
        }
      if (a || (a = (t2.someProp("clipboardParser") || t2.someProp("domParser") || as.fromSchema(t2.state.schema)).parseSlice(r, {
        preserveWhitespace: !!(l || u),
        context: i,
        ruleFromNode(p2) {
          return p2.nodeName == "BR" && !p2.nextSibling && p2.parentNode && !o0.test(p2.parentNode.nodeName) ? { ignore: true } : null;
        }
      })), u)
        a = l0(Od(a, +u[1], +u[2]), u[4]);
      else if (a = K.maxOpen(i0(a.content, i), true), a.openStart || a.openEnd) {
        let d = 0, p2 = 0;
        for (let m = a.content.firstChild; d < a.openStart && !m.type.spec.isolating; d++, m = m.firstChild)
          ;
        for (let m = a.content.lastChild; p2 < a.openEnd && !m.type.spec.isolating; p2++, m = m.lastChild)
          ;
        a = Od(a, d, p2);
      }
      return t2.someProp("transformPasted", (d) => {
        a = d(a, t2);
      }), a;
    }
    const o0 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function i0(t2, e) {
      if (t2.childCount < 2)
        return t2;
      for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.index(n)), s, r = [];
        if (t2.forEach((a) => {
          if (!r)
            return;
          let l = i.findWrapping(a.type), c2;
          if (!l)
            return r = null;
          if (c2 = r.length && s.length && ff(l, s, a, r[r.length - 1], 0))
            r[r.length - 1] = c2;
          else {
            r.length && (r[r.length - 1] = _f(r[r.length - 1], s.length));
            let u = mf(a, l);
            r.push(u), i = i.matchType(u.type), s = l;
          }
        }), r)
          return D.from(r);
      }
      return t2;
    }
    function mf(t2, e, n = 0) {
      for (let o = e.length - 1; o >= n; o--)
        t2 = e[o].create(null, D.from(t2));
      return t2;
    }
    function ff(t2, e, n, o, i) {
      if (i < t2.length && i < e.length && t2[i] == e[i]) {
        let s = ff(t2, e, n, o.lastChild, i + 1);
        if (s)
          return o.copy(o.content.replaceChild(o.childCount - 1, s));
        if (o.contentMatchAt(o.childCount).matchType(i == t2.length - 1 ? n.type : t2[i + 1]))
          return o.copy(o.content.append(D.from(mf(n, t2, i + 1))));
      }
    }
    function _f(t2, e) {
      if (e == 0)
        return t2;
      let n = t2.content.replaceChild(t2.childCount - 1, _f(t2.lastChild, e - 1)), o = t2.contentMatchAt(t2.childCount).fillBefore(D.empty, true);
      return t2.copy(n.append(o));
    }
    function Ql(t2, e, n, o, i, s) {
      let r = e < 0 ? t2.firstChild : t2.lastChild, a = r.content;
      return t2.childCount > 1 && (s = 0), i < o - 1 && (a = Ql(a, e, n, o, i + 1, s)), i >= n && (a = e < 0 ? r.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(r.contentMatchAt(r.childCount).fillBefore(D.empty, true))), t2.replaceChild(e < 0 ? 0 : t2.childCount - 1, r.copy(a));
    }
    function Od(t2, e, n) {
      return e < t2.openStart && (t2 = new K(Ql(t2.content, -1, e, t2.openStart, 0, t2.openEnd), e, t2.openEnd)), n < t2.openEnd && (t2 = new K(Ql(t2.content, 1, n, t2.openEnd, 0, 0), t2.openStart, n)), t2;
    }
    const hf = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    let Nd = null;
    function gf() {
      return Nd || (Nd = document.implementation.createHTMLDocument("title"));
    }
    let dl = null;
    function s0(t2) {
      let e = window.trustedTypes;
      return e ? (dl || (dl = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), dl.createHTML(t2)) : t2;
    }
    function r0(t2) {
      let e = /^(\s*<meta [^>]*>)*/.exec(t2);
      e && (t2 = t2.slice(e[0].length));
      let n = gf().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(t2), i;
      if ((i = o && hf[o[1].toLowerCase()]) && (t2 = i.map((s) => "<" + s + ">").join("") + t2 + i.map((s) => "</" + s + ">").reverse().join("")), n.innerHTML = s0(t2), i)
        for (let s = 0; s < i.length; s++)
          n = n.querySelector(i[s]) || n;
      return n;
    }
    function a0(t2) {
      let e = t2.querySelectorAll(zt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let n = 0; n < e.length; n++) {
        let o = e[n];
        o.childNodes.length == 1 && o.textContent == " " && o.parentNode && o.parentNode.replaceChild(t2.ownerDocument.createTextNode(" "), o);
      }
    }
    function l0(t2, e) {
      if (!t2.size)
        return t2;
      let n = t2.content.firstChild.type.schema, o;
      try {
        o = JSON.parse(e);
      } catch {
        return t2;
      }
      let { content: i, openStart: s, openEnd: r } = t2;
      for (let a = o.length - 2; a >= 0; a -= 2) {
        let l = n.nodes[o[a]];
        if (!l || l.hasRequiredAttrs())
          break;
        i = D.from(l.create(o[a + 1], i)), s++, r++;
      }
      return new K(i, s, r);
    }
    const Jt = {}, Yt = {}, c0 = { touchstart: true, touchmove: true };
    class u0 {
      constructor() {
        this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
      }
    }
    function d0(t2) {
      for (let e in Jt) {
        let n = Jt[e];
        t2.dom.addEventListener(e, t2.input.eventHandlers[e] = (o) => {
          m0(t2, o) && !Dc(t2, o) && (t2.editable || !(o.type in Yt)) && n(t2, o);
        }, c0[e] ? { passive: true } : void 0);
      }
      Gt && t2.dom.addEventListener("input", () => null), ec(t2);
    }
    function No(t2, e) {
      t2.input.lastSelectionOrigin = e, t2.input.lastSelectionTime = Date.now();
    }
    function p0(t2) {
      t2.domObserver.stop();
      for (let e in t2.input.eventHandlers)
        t2.dom.removeEventListener(e, t2.input.eventHandlers[e]);
      clearTimeout(t2.input.composingTimeout), clearTimeout(t2.input.lastIOSEnterFallbackTimeout);
    }
    function ec(t2) {
      t2.someProp("handleDOMEvents", (e) => {
        for (let n in e)
          t2.input.eventHandlers[n] || t2.dom.addEventListener(n, t2.input.eventHandlers[n] = (o) => Dc(t2, o));
      });
    }
    function Dc(t2, e) {
      return t2.someProp("handleDOMEvents", (n) => {
        let o = n[e.type];
        return o ? o(t2, e) || e.defaultPrevented : false;
      });
    }
    function m0(t2, e) {
      if (!e.bubbles)
        return true;
      if (e.defaultPrevented)
        return false;
      for (let n = e.target; n != t2.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
          return false;
      return true;
    }
    function f0(t2, e) {
      !Dc(t2, e) && Jt[e.type] && (t2.editable || !(e.type in Yt)) && Jt[e.type](t2, e);
    }
    Yt.keydown = (t2, e) => {
      let n = e;
      if (t2.input.shiftKey = n.keyCode == 16 || n.shiftKey, !bf(t2, n) && (t2.input.lastKeyCode = n.keyCode, t2.input.lastKeyCodeTime = Date.now(), !(lo && zt && n.keyCode == 13)))
        if (n.keyCode != 229 && t2.domObserver.forceFlush(), Ri && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
          let o = Date.now();
          t2.input.lastIOSEnter = o, t2.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            t2.input.lastIOSEnter == o && (t2.someProp("handleKeyDown", (i) => i(t2, Wo(13, "Enter"))), t2.input.lastIOSEnter = 0);
          }, 200);
        } else t2.someProp("handleKeyDown", (o) => o(t2, n)) || n0(t2, n) ? n.preventDefault() : No(t2, "key");
    };
    Yt.keyup = (t2, e) => {
      e.keyCode == 16 && (t2.input.shiftKey = false);
    };
    Yt.keypress = (t2, e) => {
      let n = e;
      if (bf(t2, n) || !n.charCode || n.ctrlKey && !n.altKey || vn && n.metaKey)
        return;
      if (t2.someProp("handleKeyPress", (i) => i(t2, n))) {
        n.preventDefault();
        return;
      }
      let o = t2.state.selection;
      if (!(o instanceof re) || !o.$from.sameParent(o.$to)) {
        let i = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(i) && !t2.someProp("handleTextInput", (s) => s(t2, o.$from.pos, o.$to.pos, i)) && t2.dispatch(t2.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
      }
    };
    function Ia(t2) {
      return { left: t2.clientX, top: t2.clientY };
    }
    function _0(t2, e) {
      let n = e.x - t2.clientX, o = e.y - t2.clientY;
      return n * n + o * o < 100;
    }
    function Lc(t2, e, n, o, i) {
      if (o == -1)
        return false;
      let s = t2.state.doc.resolve(o);
      for (let r = s.depth + 1; r > 0; r--)
        if (t2.someProp(e, (a) => r > s.depth ? a(t2, n, s.nodeAfter, s.before(r), i, true) : a(t2, n, s.node(r), s.before(r), i, false)))
          return true;
      return false;
    }
    function Ni(t2, e, n) {
      if (t2.focused || t2.focus(), t2.state.selection.eq(e))
        return;
      let o = t2.state.tr.setSelection(e);
      o.setMeta("pointer", true), t2.dispatch(o);
    }
    function h0(t2, e) {
      if (e == -1)
        return false;
      let n = t2.state.doc.resolve(e), o = n.nodeAfter;
      return o && o.isAtom && ie.isSelectable(o) ? (Ni(t2, new ie(n)), true) : false;
    }
    function g0(t2, e) {
      if (e == -1)
        return false;
      let n = t2.state.selection, o, i;
      n instanceof ie && (o = n.node);
      let s = t2.state.doc.resolve(e);
      for (let r = s.depth + 1; r > 0; r--) {
        let a = r > s.depth ? s.nodeAfter : s.node(r);
        if (ie.isSelectable(a)) {
          o && n.$from.depth > 0 && r >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(r);
          break;
        }
      }
      return i != null ? (Ni(t2, ie.create(t2.state.doc, i)), true) : false;
    }
    function v0(t2, e, n, o, i) {
      return Lc(t2, "handleClickOn", e, n, o) || t2.someProp("handleClick", (s) => s(t2, e, o)) || (i ? g0(t2, n) : h0(t2, n));
    }
    function b0(t2, e, n, o) {
      return Lc(t2, "handleDoubleClickOn", e, n, o) || t2.someProp("handleDoubleClick", (i) => i(t2, e, o));
    }
    function k0(t2, e, n, o) {
      return Lc(t2, "handleTripleClickOn", e, n, o) || t2.someProp("handleTripleClick", (i) => i(t2, e, o)) || y0(t2, n, o);
    }
    function y0(t2, e, n) {
      if (n.button != 0)
        return false;
      let o = t2.state.doc;
      if (e == -1)
        return o.inlineContent ? (Ni(t2, re.create(o, 0, o.content.size)), true) : false;
      let i = o.resolve(e);
      for (let s = i.depth + 1; s > 0; s--) {
        let r = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
        if (r.inlineContent)
          Ni(t2, re.create(o, a + 1, a + 1 + r.content.size));
        else if (ie.isSelectable(r))
          Ni(t2, ie.create(o, a));
        else
          continue;
        return true;
      }
    }
    function Pc(t2) {
      return Fr(t2);
    }
    const vf = vn ? "metaKey" : "ctrlKey";
    Jt.mousedown = (t2, e) => {
      let n = e;
      t2.input.shiftKey = n.shiftKey;
      let o = Pc(t2), i = Date.now(), s = "singleClick";
      i - t2.input.lastClick.time < 500 && _0(n, t2.input.lastClick) && !n[vf] && (t2.input.lastClick.type == "singleClick" ? s = "doubleClick" : t2.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t2.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s };
      let r = t2.posAtCoords(Ia(n));
      r && (s == "singleClick" ? (t2.input.mouseDown && t2.input.mouseDown.done(), t2.input.mouseDown = new w0(t2, r, n, !!o)) : (s == "doubleClick" ? b0 : k0)(t2, r.pos, r.inside, n) ? n.preventDefault() : No(t2, "pointer"));
    };
    class w0 {
      constructor(e, n, o, i) {
        this.view = e, this.pos = n, this.event = o, this.flushed = i, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!o[vf], this.allowDefault = o.shiftKey;
        let s, r;
        if (n.inside > -1)
          s = e.state.doc.nodeAt(n.inside), r = n.inside;
        else {
          let u = e.state.doc.resolve(n.pos);
          s = u.parent, r = u.depth ? u.before() : 0;
        }
        const a = i ? null : o.target, l = a ? e.docView.nearestDesc(a, true) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let { selection: c2 } = e.state;
        (o.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== false || c2 instanceof ie && c2.from <= r && c2.to > r) && (this.mightDrag = {
          node: s,
          pos: r,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && Dn && !this.target.hasAttribute("contentEditable"))
        }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
          this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
        }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), No(e, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => po(this.view)), this.view.input.mouseDown = null;
      }
      up(e) {
        if (this.done(), !this.view.dom.contains(e.target))
          return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Ia(e))), this.updateAllowDefault(e), this.allowDefault || !n ? No(this.view, "pointer") : v0(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        Gt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        zt && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Ni(this.view, de.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : No(this.view, "pointer");
      }
      move(e) {
        this.updateAllowDefault(e), No(this.view, "pointer"), e.buttons == 0 && this.done();
      }
      updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
      }
    }
    Jt.touchstart = (t2) => {
      t2.input.lastTouch = Date.now(), Pc(t2), No(t2, "pointer");
    };
    Jt.touchmove = (t2) => {
      t2.input.lastTouch = Date.now(), No(t2, "pointer");
    };
    Jt.contextmenu = (t2) => Pc(t2);
    function bf(t2, e) {
      return t2.composing ? true : Gt && Math.abs(e.timeStamp - t2.input.compositionEndedAt) < 500 ? (t2.input.compositionEndedAt = -2e8, true) : false;
    }
    const j0 = lo ? 5e3 : -1;
    Yt.compositionstart = Yt.compositionupdate = (t2) => {
      if (!t2.composing) {
        t2.domObserver.flush();
        let { state: e } = t2, n = e.selection.$to;
        if (e.selection instanceof re && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((o) => o.type.spec.inclusive === false)))
          t2.markCursor = t2.state.storedMarks || n.marks(), Fr(t2, true), t2.markCursor = null;
        else if (Fr(t2, !e.selection.empty), Dn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
          let o = t2.domSelectionRange();
          for (let i = o.focusNode, s = o.focusOffset; i && i.nodeType == 1 && s != 0; ) {
            let r = s < 0 ? i.lastChild : i.childNodes[s - 1];
            if (!r)
              break;
            if (r.nodeType == 3) {
              let a = t2.domSelection();
              a && a.collapse(r, r.nodeValue.length);
              break;
            } else
              i = r, s = -1;
          }
        }
        t2.input.composing = true;
      }
      kf(t2, j0);
    };
    Yt.compositionend = (t2, e) => {
      t2.composing && (t2.input.composing = false, t2.input.compositionEndedAt = e.timeStamp, t2.input.compositionPendingChanges = t2.domObserver.pendingRecords().length ? t2.input.compositionID : 0, t2.input.compositionNode = null, t2.input.compositionPendingChanges && Promise.resolve().then(() => t2.domObserver.flush()), t2.input.compositionID++, kf(t2, 20));
    };
    function kf(t2, e) {
      clearTimeout(t2.input.composingTimeout), e > -1 && (t2.input.composingTimeout = setTimeout(() => Fr(t2), e));
    }
    function yf(t2) {
      for (t2.composing && (t2.input.composing = false, t2.input.compositionEndedAt = S0()); t2.input.compositionNodes.length > 0; )
        t2.input.compositionNodes.pop().markParentsDirty();
    }
    function E0(t2) {
      let e = t2.domSelectionRange();
      if (!e.focusNode)
        return null;
      let n = hv(e.focusNode, e.focusOffset), o = gv(e.focusNode, e.focusOffset);
      if (n && o && n != o) {
        let i = o.pmViewDesc, s = t2.domObserver.lastChangedTextNode;
        if (n == s || o == s)
          return s;
        if (!i || !i.isText(o.nodeValue))
          return o;
        if (t2.input.compositionNode == o) {
          let r = n.pmViewDesc;
          if (!(!r || !r.isText(n.nodeValue)))
            return o;
        }
      }
      return n || o;
    }
    function S0() {
      let t2 = document.createEvent("Event");
      return t2.initEvent("event", true, true), t2.timeStamp;
    }
    function Fr(t2, e = false) {
      if (!(lo && t2.domObserver.flushingSoon >= 0)) {
        if (t2.domObserver.forceFlush(), yf(t2), e || t2.docView && t2.docView.dirty) {
          let n = Mc(t2);
          return n && !n.eq(t2.state.selection) ? t2.dispatch(t2.state.tr.setSelection(n)) : (t2.markCursor || e) && !t2.state.selection.empty ? t2.dispatch(t2.state.tr.deleteSelection()) : t2.updateState(t2.state), true;
        }
        return false;
      }
    }
    function C0(t2, e) {
      if (!t2.dom.parentNode)
        return;
      let n = t2.dom.parentNode.appendChild(document.createElement("div"));
      n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let o = getSelection(), i = document.createRange();
      i.selectNodeContents(e), t2.dom.blur(), o.removeAllRanges(), o.addRange(i), setTimeout(() => {
        n.parentNode && n.parentNode.removeChild(n), t2.focus();
      }, 50);
    }
    const Es = en && Ro < 15 || Ri && wv < 604;
    Jt.copy = Yt.cut = (t2, e) => {
      let n = e, o = t2.state.selection, i = n.type == "cut";
      if (o.empty)
        return;
      let s = Es ? null : n.clipboardData, r = o.content(), { dom: a, text: l } = Ic(t2, r);
      s ? (n.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : C0(t2, a), i && t2.dispatch(t2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function x0(t2) {
      return t2.openStart == 0 && t2.openEnd == 0 && t2.content.childCount == 1 ? t2.content.firstChild : null;
    }
    function T0(t2, e) {
      if (!t2.dom.parentNode)
        return;
      let n = t2.input.shiftKey || t2.state.selection.$from.parent.type.spec.code, o = t2.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
      n || (o.contentEditable = "true"), o.style.cssText = "position: fixed; left: -10000px; top: 10px", o.focus();
      let i = t2.input.shiftKey && t2.input.lastKeyCode != 45;
      setTimeout(() => {
        t2.focus(), o.parentNode && o.parentNode.removeChild(o), n ? Ss(t2, o.value, null, i, e) : Ss(t2, o.textContent, o.innerHTML, i, e);
      }, 50);
    }
    function Ss(t2, e, n, o, i) {
      let s = pf(t2, e, n, o, t2.state.selection.$from);
      if (t2.someProp("handlePaste", (l) => l(t2, i, s || K.empty)))
        return true;
      if (!s)
        return false;
      let r = x0(s), a = r ? t2.state.tr.replaceSelectionWith(r, o) : t2.state.tr.replaceSelection(s);
      return t2.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
    }
    function wf(t2) {
      let e = t2.getData("text/plain") || t2.getData("Text");
      if (e)
        return e;
      let n = t2.getData("text/uri-list");
      return n ? n.replace(/\r?\n/g, " ") : "";
    }
    Yt.paste = (t2, e) => {
      let n = e;
      if (t2.composing && !lo)
        return;
      let o = Es ? null : n.clipboardData, i = t2.input.shiftKey && t2.input.lastKeyCode != 45;
      o && Ss(t2, wf(o), o.getData("text/html"), i, n) ? n.preventDefault() : T0(t2, n);
    };
    class jf {
      constructor(e, n, o) {
        this.slice = e, this.move = n, this.node = o;
      }
    }
    const Ef = vn ? "altKey" : "ctrlKey";
    Jt.dragstart = (t2, e) => {
      let n = e, o = t2.input.mouseDown;
      if (o && o.done(), !n.dataTransfer)
        return;
      let i = t2.state.selection, s = i.empty ? null : t2.posAtCoords(Ia(n)), r;
      if (!(s && s.pos >= i.from && s.pos <= (i instanceof ie ? i.to - 1 : i.to))) {
        if (o && o.mightDrag)
          r = ie.create(t2.state.doc, o.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
          let d = t2.docView.nearestDesc(n.target, true);
          d && d.node.type.spec.draggable && d != t2.docView && (r = ie.create(t2.state.doc, d.posBefore));
        }
      }
      let a = (r || t2.state.selection).content(), { dom: l, text: c2, slice: u } = Ic(t2, a);
      (!n.dataTransfer.files.length || !zt || Jm > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Es ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Es || n.dataTransfer.setData("text/plain", c2), t2.dragging = new jf(u, !n[Ef], r);
    };
    Jt.dragend = (t2) => {
      let e = t2.dragging;
      window.setTimeout(() => {
        t2.dragging == e && (t2.dragging = null);
      }, 50);
    };
    Yt.dragover = Yt.dragenter = (t2, e) => e.preventDefault();
    Yt.drop = (t2, e) => {
      let n = e, o = t2.dragging;
      if (t2.dragging = null, !n.dataTransfer)
        return;
      let i = t2.posAtCoords(Ia(n));
      if (!i)
        return;
      let s = t2.state.doc.resolve(i.pos), r = o && o.slice;
      r ? t2.someProp("transformPasted", (f) => {
        r = f(r, t2);
      }) : r = pf(t2, wf(n.dataTransfer), Es ? null : n.dataTransfer.getData("text/html"), false, s);
      let a = !!(o && !n[Ef]);
      if (t2.someProp("handleDrop", (f) => f(t2, n, r || K.empty, a))) {
        n.preventDefault();
        return;
      }
      if (!r)
        return;
      n.preventDefault();
      let l = r ? zm(t2.state.doc, s.pos, r) : s.pos;
      l == null && (l = s.pos);
      let c2 = t2.state.tr;
      if (a) {
        let { node: f } = o;
        f ? f.replace(c2) : c2.deleteSelection();
      }
      let u = c2.mapping.map(l), d = r.openStart == 0 && r.openEnd == 0 && r.content.childCount == 1, p2 = c2.doc;
      if (d ? c2.replaceRangeWith(u, u, r.content.firstChild) : c2.replaceRange(u, u, r), c2.doc.eq(p2))
        return;
      let m = c2.doc.resolve(u);
      if (d && ie.isSelectable(r.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(r.content.firstChild))
        c2.setSelection(new ie(m));
      else {
        let f = c2.mapping.map(l);
        c2.mapping.maps[c2.mapping.maps.length - 1].forEach((_, h2, g, k) => f = k), c2.setSelection(Rc(t2, m, c2.doc.resolve(f)));
      }
      t2.focus(), t2.dispatch(c2.setMeta("uiEvent", "drop"));
    };
    Jt.focus = (t2) => {
      t2.input.lastFocus = Date.now(), t2.focused || (t2.domObserver.stop(), t2.dom.classList.add("ProseMirror-focused"), t2.domObserver.start(), t2.focused = true, setTimeout(() => {
        t2.docView && t2.hasFocus() && !t2.domObserver.currentSelection.eq(t2.domSelectionRange()) && po(t2);
      }, 20));
    };
    Jt.blur = (t2, e) => {
      let n = e;
      t2.focused && (t2.domObserver.stop(), t2.dom.classList.remove("ProseMirror-focused"), t2.domObserver.start(), n.relatedTarget && t2.dom.contains(n.relatedTarget) && t2.domObserver.currentSelection.clear(), t2.focused = false);
    };
    Jt.beforeinput = (t2, e) => {
      if (zt && lo && e.inputType == "deleteContentBackward") {
        t2.domObserver.flushSoon();
        let { domChangeCount: o } = t2.input;
        setTimeout(() => {
          if (t2.input.domChangeCount != o || (t2.dom.blur(), t2.focus(), t2.someProp("handleKeyDown", (s) => s(t2, Wo(8, "Backspace")))))
            return;
          let { $cursor: i } = t2.state.selection;
          i && i.pos > 0 && t2.dispatch(t2.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let t2 in Yt)
      Jt[t2] = Yt[t2];
    function Cs(t2, e) {
      if (t2 == e)
        return true;
      for (let n in t2)
        if (t2[n] !== e[n])
          return false;
      for (let n in e)
        if (!(n in t2))
          return false;
      return true;
    }
    class Hr {
      constructor(e, n) {
        this.toDOM = e, this.spec = n || ei, this.side = this.spec.side || 0;
      }
      map(e, n, o, i) {
        let { pos: s, deleted: r } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
        return r ? null : new _t(s - o, s - o, this);
      }
      valid() {
        return true;
      }
      eq(e) {
        return this == e || e instanceof Hr && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Cs(this.spec, e.spec));
      }
      destroy(e) {
        this.spec.destroy && this.spec.destroy(e);
      }
    }
    class Do {
      constructor(e, n) {
        this.attrs = e, this.spec = n || ei;
      }
      map(e, n, o, i) {
        let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - o, r = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - o;
        return s >= r ? null : new _t(s, r, this);
      }
      valid(e, n) {
        return n.from < n.to;
      }
      eq(e) {
        return this == e || e instanceof Do && Cs(this.attrs, e.attrs) && Cs(this.spec, e.spec);
      }
      static is(e) {
        return e.type instanceof Do;
      }
      destroy() {
      }
    }
    class Bc {
      constructor(e, n) {
        this.attrs = e, this.spec = n || ei;
      }
      map(e, n, o, i) {
        let s = e.mapResult(n.from + i, 1);
        if (s.deleted)
          return null;
        let r = e.mapResult(n.to + i, -1);
        return r.deleted || r.pos <= s.pos ? null : new _t(s.pos - o, r.pos - o, this);
      }
      valid(e, n) {
        let { index: o, offset: i } = e.content.findIndex(n.from), s;
        return i == n.from && !(s = e.child(o)).isText && i + s.nodeSize == n.to;
      }
      eq(e) {
        return this == e || e instanceof Bc && Cs(this.attrs, e.attrs) && Cs(this.spec, e.spec);
      }
      destroy() {
      }
    }
    class _t {
      /**
      @internal
      */
      constructor(e, n, o) {
        this.from = e, this.to = n, this.type = o;
      }
      /**
      @internal
      */
      copy(e, n) {
        return new _t(e, n, this.type);
      }
      /**
      @internal
      */
      eq(e, n = 0) {
        return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
      }
      /**
      @internal
      */
      map(e, n, o) {
        return this.type.map(e, this, n, o);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(e, n, o) {
        return new _t(e, e, new Hr(n, o));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(e, n, o, i) {
        return new _t(e, n, new Do(o, i));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(e, n, o, i) {
        return new _t(e, n, new Bc(o, i));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof Do;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof Hr;
      }
    }
    const ki = [], ei = {};
    class qe {
      /**
      @internal
      */
      constructor(e, n) {
        this.local = e.length ? e : ki, this.children = n.length ? n : ki;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(e, n) {
        return n.length ? Ur(n, e, 0, ei) : $t;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(e, n, o) {
        let i = [];
        return this.findInner(e ?? 0, n ?? 1e9, i, 0, o), i;
      }
      findInner(e, n, o, i, s) {
        for (let r = 0; r < this.local.length; r++) {
          let a = this.local[r];
          a.from <= n && a.to >= e && (!s || s(a.spec)) && o.push(a.copy(a.from + i, a.to + i));
        }
        for (let r = 0; r < this.children.length; r += 3)
          if (this.children[r] < n && this.children[r + 1] > e) {
            let a = this.children[r] + 1;
            this.children[r + 2].findInner(e - a, n - a, o, i + a, s);
          }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(e, n, o) {
        return this == $t || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, o || ei);
      }
      /**
      @internal
      */
      mapInner(e, n, o, i, s) {
        let r;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a].map(e, o, i);
          l && l.type.valid(n, l) ? (r || (r = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
        }
        return this.children.length ? O0(this.children, r || [], e, n, o, i, s) : r ? new qe(r.sort(ti), ki) : $t;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(e, n) {
        return n.length ? this == $t ? qe.create(e, n) : this.addInner(e, n, 0) : this;
      }
      addInner(e, n, o) {
        let i, s = 0;
        e.forEach((a, l) => {
          let c2 = l + o, u;
          if (u = Cf(n, a, c2)) {
            for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
              s += 3;
            i[s] == l ? i[s + 2] = i[s + 2].addInner(a, u, c2 + 1) : i.splice(s, 0, l, l + a.nodeSize, Ur(u, a, c2 + 1, ei)), s += 3;
          }
        });
        let r = Sf(s ? xf(n) : n, -o);
        for (let a = 0; a < r.length; a++)
          r[a].type.valid(e, r[a]) || r.splice(a--, 1);
        return new qe(r.length ? this.local.concat(r).sort(ti) : this.local, i || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(e) {
        return e.length == 0 || this == $t ? this : this.removeInner(e, 0);
      }
      removeInner(e, n) {
        let o = this.children, i = this.local;
        for (let s = 0; s < o.length; s += 3) {
          let r, a = o[s] + n, l = o[s + 1] + n;
          for (let u = 0, d; u < e.length; u++)
            (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (r || (r = [])).push(d));
          if (!r)
            continue;
          o == this.children && (o = this.children.slice());
          let c2 = o[s + 2].removeInner(r, a + 1);
          c2 != $t ? o[s + 2] = c2 : (o.splice(s, 3), s -= 3);
        }
        if (i.length) {
          for (let s = 0, r; s < e.length; s++)
            if (r = e[s])
              for (let a = 0; a < i.length; a++)
                i[a].eq(r, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
        }
        return o == this.children && i == this.local ? this : i.length || o.length ? new qe(i, o) : $t;
      }
      forChild(e, n) {
        if (this == $t)
          return this;
        if (n.isLeaf)
          return qe.empty;
        let o, i;
        for (let a = 0; a < this.children.length; a += 3)
          if (this.children[a] >= e) {
            this.children[a] == e && (o = this.children[a + 2]);
            break;
          }
        let s = e + 1, r = s + n.content.size;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a];
          if (l.from < r && l.to > s && l.type instanceof Do) {
            let c2 = Math.max(s, l.from) - s, u = Math.min(r, l.to) - s;
            c2 < u && (i || (i = [])).push(l.copy(c2, u));
          }
        }
        if (i) {
          let a = new qe(i.sort(ti), ki);
          return o ? new So([a, o]) : a;
        }
        return o || $t;
      }
      /**
      @internal
      */
      eq(e) {
        if (this == e)
          return true;
        if (!(e instanceof qe) || this.local.length != e.local.length || this.children.length != e.children.length)
          return false;
        for (let n = 0; n < this.local.length; n++)
          if (!this.local[n].eq(e.local[n]))
            return false;
        for (let n = 0; n < this.children.length; n += 3)
          if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(e) {
        return $c(this.localsInner(e));
      }
      /**
      @internal
      */
      localsInner(e) {
        if (this == $t)
          return ki;
        if (e.inlineContent || !this.local.some(Do.is))
          return this.local;
        let n = [];
        for (let o = 0; o < this.local.length; o++)
          this.local[o].type instanceof Do || n.push(this.local[o]);
        return n;
      }
      forEachSet(e) {
        e(this);
      }
    }
    qe.empty = new qe([], []);
    qe.removeOverlap = $c;
    const $t = qe.empty;
    class So {
      constructor(e) {
        this.members = e;
      }
      map(e, n) {
        const o = this.members.map((i) => i.map(e, n, ei));
        return So.from(o);
      }
      forChild(e, n) {
        if (n.isLeaf)
          return qe.empty;
        let o = [];
        for (let i = 0; i < this.members.length; i++) {
          let s = this.members[i].forChild(e, n);
          s != $t && (s instanceof So ? o = o.concat(s.members) : o.push(s));
        }
        return So.from(o);
      }
      eq(e) {
        if (!(e instanceof So) || e.members.length != this.members.length)
          return false;
        for (let n = 0; n < this.members.length; n++)
          if (!this.members[n].eq(e.members[n]))
            return false;
        return true;
      }
      locals(e) {
        let n, o = true;
        for (let i = 0; i < this.members.length; i++) {
          let s = this.members[i].localsInner(e);
          if (s.length)
            if (!n)
              n = s;
            else {
              o && (n = n.slice(), o = false);
              for (let r = 0; r < s.length; r++)
                n.push(s[r]);
            }
        }
        return n ? $c(o ? n : n.sort(ti)) : ki;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(e) {
        switch (e.length) {
          case 0:
            return $t;
          case 1:
            return e[0];
          default:
            return new So(e.every((n) => n instanceof qe) ? e : e.reduce((n, o) => n.concat(o instanceof qe ? o : o.members), []));
        }
      }
      forEachSet(e) {
        for (let n = 0; n < this.members.length; n++)
          this.members[n].forEachSet(e);
      }
    }
    function O0(t2, e, n, o, i, s, r) {
      let a = t2.slice();
      for (let c2 = 0, u = s; c2 < n.maps.length; c2++) {
        let d = 0;
        n.maps[c2].forEach((p2, m, f, _) => {
          let h2 = _ - f - (m - p2);
          for (let g = 0; g < a.length; g += 3) {
            let k = a[g + 1];
            if (k < 0 || p2 > k + u - d)
              continue;
            let j = a[g] + u - d;
            m >= j ? a[g + 1] = p2 <= j ? -2 : -1 : p2 >= u && h2 && (a[g] += h2, a[g + 1] += h2);
          }
          d += h2;
        }), u = n.maps[c2].map(u, -1);
      }
      let l = false;
      for (let c2 = 0; c2 < a.length; c2 += 3)
        if (a[c2 + 1] < 0) {
          if (a[c2 + 1] == -2) {
            l = true, a[c2 + 1] = -1;
            continue;
          }
          let u = n.map(t2[c2] + s), d = u - i;
          if (d < 0 || d >= o.content.size) {
            l = true;
            continue;
          }
          let p2 = n.map(t2[c2 + 1] + s, -1), m = p2 - i, { index: f, offset: _ } = o.content.findIndex(d), h2 = o.maybeChild(f);
          if (h2 && _ == d && _ + h2.nodeSize == m) {
            let g = a[c2 + 2].mapInner(n, h2, u + 1, t2[c2] + s + 1, r);
            g != $t ? (a[c2] = d, a[c2 + 1] = m, a[c2 + 2] = g) : (a[c2 + 1] = -2, l = true);
          } else
            l = true;
        }
      if (l) {
        let c2 = N0(a, t2, e, n, i, s, r), u = Ur(c2, o, 0, r);
        e = u.local;
        for (let d = 0; d < a.length; d += 3)
          a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
        for (let d = 0, p2 = 0; d < u.children.length; d += 3) {
          let m = u.children[d];
          for (; p2 < a.length && a[p2] < m; )
            p2 += 3;
          a.splice(p2, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
        }
      }
      return new qe(e.sort(ti), a);
    }
    function Sf(t2, e) {
      if (!e || !t2.length)
        return t2;
      let n = [];
      for (let o = 0; o < t2.length; o++) {
        let i = t2[o];
        n.push(new _t(i.from + e, i.to + e, i.type));
      }
      return n;
    }
    function N0(t2, e, n, o, i, s, r) {
      function a(l, c2) {
        for (let u = 0; u < l.local.length; u++) {
          let d = l.local[u].map(o, i, c2);
          d ? n.push(d) : r.onRemove && r.onRemove(l.local[u].spec);
        }
        for (let u = 0; u < l.children.length; u += 3)
          a(l.children[u + 2], l.children[u] + c2 + 1);
      }
      for (let l = 0; l < t2.length; l += 3)
        t2[l + 1] == -1 && a(t2[l + 2], e[l] + s + 1);
      return n;
    }
    function Cf(t2, e, n) {
      if (e.isLeaf)
        return null;
      let o = n + e.nodeSize, i = null;
      for (let s = 0, r; s < t2.length; s++)
        (r = t2[s]) && r.from > n && r.to < o && ((i || (i = [])).push(r), t2[s] = null);
      return i;
    }
    function xf(t2) {
      let e = [];
      for (let n = 0; n < t2.length; n++)
        t2[n] != null && e.push(t2[n]);
      return e;
    }
    function Ur(t2, e, n, o) {
      let i = [], s = false;
      e.forEach((a, l) => {
        let c2 = Cf(t2, a, l + n);
        if (c2) {
          s = true;
          let u = Ur(c2, a, n + l + 1, o);
          u != $t && i.push(l, l + a.nodeSize, u);
        }
      });
      let r = Sf(s ? xf(t2) : t2, -n).sort(ti);
      for (let a = 0; a < r.length; a++)
        r[a].type.valid(e, r[a]) || (o.onRemove && o.onRemove(r[a].spec), r.splice(a--, 1));
      return r.length || i.length ? new qe(r, i) : $t;
    }
    function ti(t2, e) {
      return t2.from - e.from || t2.to - e.to;
    }
    function $c(t2) {
      let e = t2;
      for (let n = 0; n < e.length - 1; n++) {
        let o = e[n];
        if (o.from != o.to)
          for (let i = n + 1; i < e.length; i++) {
            let s = e[i];
            if (s.from == o.from) {
              s.to != o.to && (e == t2 && (e = t2.slice()), e[i] = s.copy(s.from, o.to), Ad(e, i + 1, s.copy(o.to, s.to)));
              continue;
            } else {
              s.from < o.to && (e == t2 && (e = t2.slice()), e[n] = o.copy(o.from, s.from), Ad(e, i, o.copy(s.from, o.to)));
              break;
            }
          }
      }
      return e;
    }
    function Ad(t2, e, n) {
      for (; e < t2.length && ti(n, t2[e]) > 0; )
        e++;
      t2.splice(e, 0, n);
    }
    function pl(t2) {
      let e = [];
      return t2.someProp("decorations", (n) => {
        let o = n(t2.state);
        o && o != $t && e.push(o);
      }), t2.cursorWrapper && e.push(qe.create(t2.state.doc, [t2.cursorWrapper.deco])), So.from(e);
    }
    const A0 = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    }, M0 = en && Ro <= 11;
    class R0 {
      constructor() {
        this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
      }
      set(e) {
        this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
      }
    }
    class I0 {
      constructor(e, n) {
        this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new R0(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((o) => {
          for (let i = 0; i < o.length; i++)
            this.queue.push(o[i]);
          en && Ro <= 11 && o.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
        }), M0 && (this.onCharData = (o) => {
          this.queue.push({ target: o.target, type: "characterData", oldValue: o.prevValue }), this.flushSoon();
        }), this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1, this.flush();
        }, 20));
      }
      forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
      start() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, A0)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let e = this.observer.takeRecords();
          if (e.length) {
            for (let n = 0; n < e.length; n++)
              this.queue.push(e[n]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (jd(this.view)) {
          if (this.suppressingSelectionUpdates)
            return po(this.view);
          if (en && Ro <= 11 && !this.view.state.selection.empty) {
            let e = this.view.domSelectionRange();
            if (e.focusNode && ai(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(e) {
        if (!e.focusNode)
          return true;
        let n = /* @__PURE__ */ new Set(), o;
        for (let s = e.focusNode; s; s = js(s))
          n.add(s);
        for (let s = e.anchorNode; s; s = js(s))
          if (n.has(s)) {
            o = s;
            break;
          }
        let i = o && this.view.docView.nearestDesc(o);
        if (i && i.ignoreMutation({
          type: "selection",
          target: o.nodeType == 3 ? o.parentNode : o
        }))
          return this.setCurSelection(), true;
      }
      pendingRecords() {
        if (this.observer)
          for (let e of this.observer.takeRecords())
            this.queue.push(e);
        return this.queue;
      }
      flush() {
        let { view: e } = this;
        if (!e.docView || this.flushingSoon > -1)
          return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let o = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(o) && jd(e) && !this.ignoreSelectionChange(o), s = -1, r = -1, a = false, l = [];
        if (e.editable)
          for (let u = 0; u < n.length; u++) {
            let d = this.registerMutation(n[u], l);
            d && (s = s < 0 ? d.from : Math.min(d.from, s), r = r < 0 ? d.to : Math.max(d.to, r), d.typeOver && (a = true));
          }
        if (Dn && l.length) {
          let u = l.filter((d) => d.nodeName == "BR");
          if (u.length == 2) {
            let [d, p2] = u;
            d.parentNode && d.parentNode.parentNode == p2.parentNode ? p2.remove() : d.remove();
          } else {
            let { focusNode: d } = this.currentSelection;
            for (let p2 of u) {
              let m = p2.parentNode;
              m && m.nodeName == "LI" && (!d || P0(e, d) != m) && p2.remove();
            }
          }
        }
        let c2 = null;
        s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ma(o) && (c2 = Mc(e)) && c2.eq(de.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, po(e), this.currentSelection.set(o)) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, r), D0(e)), this.handleDOMChange(s, r, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(o) || po(e), this.currentSelection.set(o));
      }
      registerMutation(e, n) {
        if (n.indexOf(e.target) > -1)
          return null;
        let o = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (o == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !o || o.ignoreMutation(e))
          return null;
        if (e.type == "childList") {
          for (let u = 0; u < e.addedNodes.length; u++) {
            let d = e.addedNodes[u];
            n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
          }
          if (o.contentDOM && o.contentDOM != o.dom && !o.contentDOM.contains(e.target))
            return { from: o.posBefore, to: o.posAfter };
          let i = e.previousSibling, s = e.nextSibling;
          if (en && Ro <= 11 && e.addedNodes.length)
            for (let u = 0; u < e.addedNodes.length; u++) {
              let { previousSibling: d, nextSibling: p2 } = e.addedNodes[u];
              (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!p2 || Array.prototype.indexOf.call(e.addedNodes, p2) < 0) && (s = p2);
            }
          let r = i && i.parentNode == e.target ? Dt(i) + 1 : 0, a = o.localPosFromDOM(e.target, r, -1), l = s && s.parentNode == e.target ? Dt(s) : e.target.childNodes.length, c2 = o.localPosFromDOM(e.target, l, 1);
          return { from: a, to: c2 };
        } else return e.type == "attributes" ? { from: o.posAtStart - o.border, to: o.posAtEnd + o.border } : (this.lastChangedTextNode = e.target, {
          from: o.posAtStart,
          to: o.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: e.target.nodeValue == e.oldValue
        });
      }
    }
    let Md = /* @__PURE__ */ new WeakMap(), Rd = false;
    function D0(t2) {
      if (!Md.has(t2) && (Md.set(t2, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t2.dom).whiteSpace) !== -1)) {
        if (t2.requiresGeckoHackNode = Dn, Rd)
          return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Rd = true;
      }
    }
    function Id(t2, e) {
      let n = e.startContainer, o = e.startOffset, i = e.endContainer, s = e.endOffset, r = t2.domAtPos(t2.state.selection.anchor);
      return ai(r.node, r.offset, i, s) && ([n, o, i, s] = [i, s, n, o]), { anchorNode: n, anchorOffset: o, focusNode: i, focusOffset: s };
    }
    function L0(t2, e) {
      if (e.getComposedRanges) {
        let i = e.getComposedRanges(t2.root)[0];
        if (i)
          return Id(t2, i);
      }
      let n;
      function o(i) {
        i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
      }
      return t2.dom.addEventListener("beforeinput", o, true), document.execCommand("indent"), t2.dom.removeEventListener("beforeinput", o, true), n ? Id(t2, n) : null;
    }
    function P0(t2, e) {
      for (let n = e.parentNode; n && n != t2.dom; n = n.parentNode) {
        let o = t2.docView.nearestDesc(n, true);
        if (o && o.node.isBlock)
          return n;
      }
      return null;
    }
    function B0(t2, e, n) {
      let { node: o, fromOffset: i, toOffset: s, from: r, to: a } = t2.docView.parseRange(e, n), l = t2.domSelectionRange(), c2, u = l.anchorNode;
      if (u && t2.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c2 = [{ node: u, offset: l.anchorOffset }], Ma(l) || c2.push({ node: l.focusNode, offset: l.focusOffset })), zt && t2.input.lastKeyCode === 8)
        for (let h2 = s; h2 > i; h2--) {
          let g = o.childNodes[h2 - 1], k = g.pmViewDesc;
          if (g.nodeName == "BR" && !k) {
            s = h2;
            break;
          }
          if (!k || k.size)
            break;
        }
      let d = t2.state.doc, p2 = t2.someProp("domParser") || as.fromSchema(t2.state.schema), m = d.resolve(r), f = null, _ = p2.parse(o, {
        topNode: m.parent,
        topMatch: m.parent.contentMatchAt(m.index()),
        topOpen: true,
        from: i,
        to: s,
        preserveWhitespace: m.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: c2,
        ruleFromNode: $0,
        context: m
      });
      if (c2 && c2[0].pos != null) {
        let h2 = c2[0].pos, g = c2[1] && c2[1].pos;
        g == null && (g = h2), f = { anchor: h2 + r, head: g + r };
      }
      return { doc: _, sel: f, from: r, to: a };
    }
    function $0(t2) {
      let e = t2.pmViewDesc;
      if (e)
        return e.parseRule();
      if (t2.nodeName == "BR" && t2.parentNode) {
        if (Gt && /^(ul|ol)$/i.test(t2.parentNode.nodeName)) {
          let n = document.createElement("div");
          return n.appendChild(document.createElement("li")), { skip: n };
        } else if (t2.parentNode.lastChild == t2 || Gt && /^(tr|table)$/i.test(t2.parentNode.nodeName))
          return { ignore: true };
      } else if (t2.nodeName == "IMG" && t2.getAttribute("mark-placeholder"))
        return { ignore: true };
      return null;
    }
    const z0 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function F0(t2, e, n, o, i) {
      let s = t2.input.compositionPendingChanges || (t2.composing ? t2.input.compositionID : 0);
      if (t2.input.compositionPendingChanges = 0, e < 0) {
        let P = t2.input.lastSelectionTime > Date.now() - 50 ? t2.input.lastSelectionOrigin : null, V = Mc(t2, P);
        if (V && !t2.state.selection.eq(V)) {
          if (zt && lo && t2.input.lastKeyCode === 13 && Date.now() - 100 < t2.input.lastKeyCodeTime && t2.someProp("handleKeyDown", (pe) => pe(t2, Wo(13, "Enter"))))
            return;
          let ne = t2.state.tr.setSelection(V);
          P == "pointer" ? ne.setMeta("pointer", true) : P == "key" && ne.scrollIntoView(), s && ne.setMeta("composition", s), t2.dispatch(ne);
        }
        return;
      }
      let r = t2.state.doc.resolve(e), a = r.sharedDepth(n);
      e = r.before(a + 1), n = t2.state.doc.resolve(n).after(a + 1);
      let l = t2.state.selection, c2 = B0(t2, e, n), u = t2.state.doc, d = u.slice(c2.from, c2.to), p2, m;
      t2.input.lastKeyCode === 8 && Date.now() - 100 < t2.input.lastKeyCodeTime ? (p2 = t2.state.selection.to, m = "end") : (p2 = t2.state.selection.from, m = "start"), t2.input.lastKeyCode = null;
      let f = V0(d.content, c2.doc.content, c2.from, p2, m);
      if (f && t2.input.domChangeCount++, (Ri && t2.input.lastIOSEnter > Date.now() - 225 || lo) && i.some((P) => P.nodeType == 1 && !z0.test(P.nodeName)) && (!f || f.endA >= f.endB) && t2.someProp("handleKeyDown", (P) => P(t2, Wo(13, "Enter")))) {
        t2.input.lastIOSEnter = 0;
        return;
      }
      if (!f)
        if (o && l instanceof re && !l.empty && l.$head.sameParent(l.$anchor) && !t2.composing && !(c2.sel && c2.sel.anchor != c2.sel.head))
          f = { start: l.from, endA: l.to, endB: l.to };
        else {
          if (c2.sel) {
            let P = Dd(t2, t2.state.doc, c2.sel);
            if (P && !P.eq(t2.state.selection)) {
              let V = t2.state.tr.setSelection(P);
              s && V.setMeta("composition", s), t2.dispatch(V);
            }
          }
          return;
        }
      t2.state.selection.from < t2.state.selection.to && f.start == f.endB && t2.state.selection instanceof re && (f.start > t2.state.selection.from && f.start <= t2.state.selection.from + 2 && t2.state.selection.from >= c2.from ? f.start = t2.state.selection.from : f.endA < t2.state.selection.to && f.endA >= t2.state.selection.to - 2 && t2.state.selection.to <= c2.to && (f.endB += t2.state.selection.to - f.endA, f.endA = t2.state.selection.to)), en && Ro <= 11 && f.endB == f.start + 1 && f.endA == f.start && f.start > c2.from && c2.doc.textBetween(f.start - c2.from - 1, f.start - c2.from + 1) == "  " && (f.start--, f.endA--, f.endB--);
      let _ = c2.doc.resolveNoCache(f.start - c2.from), h2 = c2.doc.resolveNoCache(f.endB - c2.from), g = u.resolve(f.start), k = _.sameParent(h2) && _.parent.inlineContent && g.end() >= f.endA, j;
      if ((Ri && t2.input.lastIOSEnter > Date.now() - 225 && (!k || i.some((P) => P.nodeName == "DIV" || P.nodeName == "P")) || !k && _.pos < c2.doc.content.size && !_.sameParent(h2) && (j = de.findFrom(c2.doc.resolve(_.pos + 1), 1, true)) && j.head == h2.pos) && t2.someProp("handleKeyDown", (P) => P(t2, Wo(13, "Enter")))) {
        t2.input.lastIOSEnter = 0;
        return;
      }
      if (t2.state.selection.anchor > f.start && U0(u, f.start, f.endA, _, h2) && t2.someProp("handleKeyDown", (P) => P(t2, Wo(8, "Backspace")))) {
        lo && zt && t2.domObserver.suppressSelectionUpdates();
        return;
      }
      zt && f.endB == f.start && (t2.input.lastChromeDelete = Date.now()), lo && !k && _.start() != h2.start() && h2.parentOffset == 0 && _.depth == h2.depth && c2.sel && c2.sel.anchor == c2.sel.head && c2.sel.head == f.endA && (f.endB -= 2, h2 = c2.doc.resolveNoCache(f.endB - c2.from), setTimeout(() => {
        t2.someProp("handleKeyDown", function(P) {
          return P(t2, Wo(13, "Enter"));
        });
      }, 20));
      let v = f.start, C = f.endA, E, B, U;
      if (k) {
        if (_.pos == h2.pos)
          en && Ro <= 11 && _.parentOffset == 0 && (t2.domObserver.suppressSelectionUpdates(), setTimeout(() => po(t2), 20)), E = t2.state.tr.delete(v, C), B = u.resolve(f.start).marksAcross(u.resolve(f.endA));
        else if (
          // Adding or removing a mark
          f.endA == f.endB && (U = H0(_.parent.content.cut(_.parentOffset, h2.parentOffset), g.parent.content.cut(g.parentOffset, f.endA - g.start())))
        )
          E = t2.state.tr, U.type == "add" ? E.addMark(v, C, U.mark) : E.removeMark(v, C, U.mark);
        else if (_.parent.child(_.index()).isText && _.index() == h2.index() - (h2.textOffset ? 0 : 1)) {
          let P = _.parent.textBetween(_.parentOffset, h2.parentOffset);
          if (t2.someProp("handleTextInput", (V) => V(t2, v, C, P)))
            return;
          E = t2.state.tr.insertText(P, v, C);
        }
      }
      if (E || (E = t2.state.tr.replace(v, C, c2.doc.slice(f.start - c2.from, f.endB - c2.from))), c2.sel) {
        let P = Dd(t2, E.doc, c2.sel);
        P && !(zt && t2.composing && P.empty && (f.start != f.endB || t2.input.lastChromeDelete < Date.now() - 100) && (P.head == v || P.head == E.mapping.map(C) - 1) || en && P.empty && P.head == v) && E.setSelection(P);
      }
      B && E.ensureMarks(B), s && E.setMeta("composition", s), t2.dispatch(E.scrollIntoView());
    }
    function Dd(t2, e, n) {
      return Math.max(n.anchor, n.head) > e.content.size ? null : Rc(t2, e.resolve(n.anchor), e.resolve(n.head));
    }
    function H0(t2, e) {
      let n = t2.firstChild.marks, o = e.firstChild.marks, i = n, s = o, r, a, l;
      for (let u = 0; u < o.length; u++)
        i = o[u].removeFromSet(i);
      for (let u = 0; u < n.length; u++)
        s = n[u].removeFromSet(s);
      if (i.length == 1 && s.length == 0)
        a = i[0], r = "add", l = (u) => u.mark(a.addToSet(u.marks));
      else if (i.length == 0 && s.length == 1)
        a = s[0], r = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
      else
        return null;
      let c2 = [];
      for (let u = 0; u < e.childCount; u++)
        c2.push(l(e.child(u)));
      if (D.from(c2).eq(t2))
        return { mark: a, type: r };
    }
    function U0(t2, e, n, o, i) {
      if (
        // The content must have shrunk
        n - e <= i.pos - o.pos || // newEnd must point directly at or after the end of the block that newStart points into
        ml(o, true, false) < i.pos
      )
        return false;
      let s = t2.resolve(e);
      if (!o.parent.isTextblock) {
        let a = s.nodeAfter;
        return a != null && n == e + a.nodeSize;
      }
      if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
        return false;
      let r = t2.resolve(ml(s, true, true));
      return !r.parent.isTextblock || r.pos > n || ml(r, true, false) < n ? false : o.parent.content.cut(o.parentOffset).eq(r.parent.content);
    }
    function ml(t2, e, n) {
      let o = t2.depth, i = e ? t2.end() : t2.pos;
      for (; o > 0 && (e || t2.indexAfter(o) == t2.node(o).childCount); )
        o--, i++, e = false;
      if (n) {
        let s = t2.node(o).maybeChild(t2.indexAfter(o));
        for (; s && !s.isLeaf; )
          s = s.firstChild, i++;
      }
      return i;
    }
    function V0(t2, e, n, o, i) {
      let s = t2.findDiffStart(e, n);
      if (s == null)
        return null;
      let { a: r, b: a } = t2.findDiffEnd(e, n + t2.size, n + e.size);
      if (i == "end") {
        let l = Math.max(0, s - Math.min(r, a));
        o -= r + l - s;
      }
      if (r < s && t2.size < e.size) {
        let l = o <= s && o >= r ? s - o : 0;
        s -= l, s && s < e.size && Ld(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), a = s + (a - r), r = s;
      } else if (a < s) {
        let l = o <= s && o >= a ? s - o : 0;
        s -= l, s && s < t2.size && Ld(t2.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), r = s + (r - a), a = s;
      }
      return { start: s, endA: r, endB: a };
    }
    function Ld(t2) {
      if (t2.length != 2)
        return false;
      let e = t2.charCodeAt(0), n = t2.charCodeAt(1);
      return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
    }
    class q0 {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(e, n) {
        this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new u0(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Fd), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = $d(this), Bd(this), this.nodeViews = zd(this), this.docView = gd(this.state.doc, Pd(this), pl(this), this.dom, this), this.domObserver = new I0(this, (o, i, s, r) => F0(this, o, i, s, r)), this.domObserver.start(), d0(this), this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let e = this._props;
          this._props = {};
          for (let n in e)
            this._props[n] = e[n];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && ec(this);
        let n = this._props;
        this._props = e, e.plugins && (e.plugins.forEach(Fd), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(e) {
        let n = {};
        for (let o in this._props)
          n[o] = this._props[o];
        n.state = this.state;
        for (let o in e)
          n[o] = e[o];
        this.update(n);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(e) {
        this.updateStateInner(e, this._props);
      }
      updateStateInner(e, n) {
        var o;
        let i = this.state, s = false, r = false;
        e.storedMarks && this.composing && (yf(this), r = true), this.state = e;
        let a = i.plugins != e.plugins || this._props.plugins != n.plugins;
        if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
          let m = zd(this);
          W0(m, this.nodeViews) && (this.nodeViews = m, s = true);
        }
        (a || n.handleDOMEvents != this._props.handleDOMEvents) && ec(this), this.editable = $d(this), Bd(this);
        let l = pl(this), c2 = Pd(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = s || !this.docView.matchesNode(e.doc, c2, l);
        (d || !e.selection.eq(i.selection)) && (r = true);
        let p2 = u == "preserve" && r && this.dom.style.overflowAnchor == null && Sv(this);
        if (r) {
          this.domObserver.stop();
          let m = d && (en || zt) && !this.composing && !i.selection.empty && !e.selection.empty && K0(i.selection, e.selection);
          if (d) {
            let f = zt ? this.trackWrites = this.domSelectionRange().focusNode : null;
            this.composing && (this.input.compositionNode = E0(this)), (s || !this.docView.update(e.doc, c2, l, this)) && (this.docView.updateOuterDeco(c2), this.docView.destroy(), this.docView = gd(e.doc, c2, l, this.dom, this)), f && !this.trackWrites && (m = true);
          }
          m || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Jv(this)) ? po(this, m) : (cf(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(i), !((o = this.dragging) === null || o === void 0) && o.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : p2 && Cv(p2);
      }
      /**
      @internal
      */
      scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
          if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ie) {
            let n = this.docView.domAfterPos(this.state.selection.from);
            n.nodeType == 1 && dd(this, n.getBoundingClientRect(), e);
          } else
            dd(this, this.coordsAtPos(this.state.selection.head, 1), e);
        }
      }
      destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop(); )
          e.destroy && e.destroy();
      }
      updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (let n = 0; n < this.directPlugins.length; n++) {
            let o = this.directPlugins[n];
            o.spec.view && this.pluginViews.push(o.spec.view(this));
          }
          for (let n = 0; n < this.state.plugins.length; n++) {
            let o = this.state.plugins[n];
            o.spec.view && this.pluginViews.push(o.spec.view(this));
          }
        } else
          for (let n = 0; n < this.pluginViews.length; n++) {
            let o = this.pluginViews[n];
            o.update && o.update(this, e);
          }
      }
      updateDraggedNode(e, n) {
        let o = e.node, i = -1;
        if (this.state.doc.nodeAt(o.from) == o.node)
          i = o.from;
        else {
          let s = o.from + (this.state.doc.content.size - n.doc.content.size);
          (s > 0 && this.state.doc.nodeAt(s)) == o.node && (i = s);
        }
        this.dragging = new jf(e.slice, e.move, i < 0 ? void 0 : ie.create(this.state.doc, i));
      }
      someProp(e, n) {
        let o = this._props && this._props[e], i;
        if (o != null && (i = n ? n(o) : o))
          return i;
        for (let r = 0; r < this.directPlugins.length; r++) {
          let a = this.directPlugins[r].props[e];
          if (a != null && (i = n ? n(a) : a))
            return i;
        }
        let s = this.state.plugins;
        if (s)
          for (let r = 0; r < s.length; r++) {
            let a = s[r].props[e];
            if (a != null && (i = n ? n(a) : a))
              return i;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (en) {
          let e = this.root.activeElement;
          if (e == this.dom)
            return true;
          if (!e || !this.dom.contains(e))
            return false;
          for (; e && this.dom != e && this.dom.contains(e); ) {
            if (e.contentEditable == "false")
              return false;
            e = e.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop(), this.editable && xv(this.dom), po(this), this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let e = this._root;
        if (e == null) {
          for (let n = this.dom.parentNode; n; n = n.parentNode)
            if (n.nodeType == 9 || n.nodeType == 11 && n.host)
              return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
        }
        return e || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(e) {
        return Mv(this, e);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(e, n = 1) {
        return ef(this, e, n);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(e, n = 0) {
        return this.docView.domFromPos(e, n);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimes—for example when interpreting an event
      target—you don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(e, n, o = -1) {
        let i = this.docView.posFromDOM(e, n, o);
        if (i == null)
          throw new RangeError("DOM position not inside the editor");
        return i;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(e, n) {
        return Pv(this, n || this.state, e);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(e, n) {
        return Ss(this, "", e, false, n || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(e, n) {
        return Ss(this, e, null, true, n || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(e) {
        return Ic(this, e);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        this.docView && (p0(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], pl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, fv());
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(e) {
        return f0(this, e);
      }
      /**
      Dispatch a transaction. Will call
      [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
      when given, and otherwise defaults to applying the transaction to
      the current state and calling
      [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
      This method is bound to the view instance, so that it can be
      easily passed around.
      */
      dispatch(e) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, e) : this.updateState(this.state.apply(e));
      }
      /**
      @internal
      */
      domSelectionRange() {
        let e = this.domSelection();
        return e ? Gt && this.root.nodeType === 11 && bv(this.dom.ownerDocument) == this.dom && L0(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    }
    function Pd(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      return e.class = "ProseMirror", e.contenteditable = String(t2.editable), t2.someProp("attributes", (n) => {
        if (typeof n == "function" && (n = n(t2.state)), n)
          for (let o in n)
            o == "class" ? e.class += " " + n[o] : o == "style" ? e.style = (e.style ? e.style + ";" : "") + n[o] : !e[o] && o != "contenteditable" && o != "nodeName" && (e[o] = String(n[o]));
      }), e.translate || (e.translate = "no"), [_t.node(0, t2.state.doc.content.size, e)];
    }
    function Bd(t2) {
      if (t2.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t2.cursorWrapper = { dom: e, deco: _t.widget(t2.state.selection.from, e, { raw: true, marks: t2.markCursor }) };
      } else
        t2.cursorWrapper = null;
    }
    function $d(t2) {
      return !t2.someProp("editable", (e) => e(t2.state) === false);
    }
    function K0(t2, e) {
      let n = Math.min(t2.$anchor.sharedDepth(t2.head), e.$anchor.sharedDepth(e.head));
      return t2.$anchor.start(n) != e.$anchor.start(n);
    }
    function zd(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      function n(o) {
        for (let i in o)
          Object.prototype.hasOwnProperty.call(e, i) || (e[i] = o[i]);
      }
      return t2.someProp("nodeViews", n), t2.someProp("markViews", n), e;
    }
    function W0(t2, e) {
      let n = 0, o = 0;
      for (let i in t2) {
        if (t2[i] != e[i])
          return true;
        n++;
      }
      for (let i in e)
        o++;
      return n != o;
    }
    function Fd(t2) {
      if (t2.spec.state || t2.spec.filterTransaction || t2.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    var Po = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    }, Vr = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    }, G0 = typeof navigator < "u" && /Mac/.test(navigator.platform), J0 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var Lt = 0; Lt < 10; Lt++) Po[48 + Lt] = Po[96 + Lt] = String(Lt);
    for (var Lt = 1; Lt <= 24; Lt++) Po[Lt + 111] = "F" + Lt;
    for (var Lt = 65; Lt <= 90; Lt++)
      Po[Lt] = String.fromCharCode(Lt + 32), Vr[Lt] = String.fromCharCode(Lt);
    for (var fl in Po) Vr.hasOwnProperty(fl) || (Vr[fl] = Po[fl]);
    function Y0(t2) {
      var e = G0 && t2.metaKey && t2.shiftKey && !t2.ctrlKey && !t2.altKey || J0 && t2.shiftKey && t2.key && t2.key.length == 1 || t2.key == "Unidentified", n = !e && t2.key || (t2.shiftKey ? Vr : Po)[t2.keyCode] || t2.key || "Unidentified";
      return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
    }
    const X0 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function Z0(t2) {
      let e = t2.split(/-(?!$)/), n = e[e.length - 1];
      n == "Space" && (n = " ");
      let o, i, s, r;
      for (let a = 0; a < e.length - 1; a++) {
        let l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          r = true;
        else if (/^a(lt)?$/i.test(l))
          o = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          i = true;
        else if (/^s(hift)?$/i.test(l))
          s = true;
        else if (/^mod$/i.test(l))
          X0 ? r = true : i = true;
        else
          throw new Error("Unrecognized modifier name: " + l);
      }
      return o && (n = "Alt-" + n), i && (n = "Ctrl-" + n), r && (n = "Meta-" + n), s && (n = "Shift-" + n), n;
    }
    function Q0(t2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let n in t2)
        e[Z0(n)] = t2[n];
      return e;
    }
    function _l(t2, e, n = true) {
      return e.altKey && (t2 = "Alt-" + t2), e.ctrlKey && (t2 = "Ctrl-" + t2), e.metaKey && (t2 = "Meta-" + t2), n && e.shiftKey && (t2 = "Shift-" + t2), t2;
    }
    function eb(t2) {
      return new ze({ props: { handleKeyDown: zc(t2) } });
    }
    function zc(t2) {
      let e = Q0(t2);
      return function(n, o) {
        let i = Y0(o), s, r = e[_l(i, o)];
        if (r && r(n.state, n.dispatch, n))
          return true;
        if (i.length == 1 && i != " ") {
          if (o.shiftKey) {
            let a = e[_l(i, o, false)];
            if (a && a(n.state, n.dispatch, n))
              return true;
          }
          if ((o.shiftKey || o.altKey || o.metaKey || i.charCodeAt(0) > 127) && (s = Po[o.keyCode]) && s != i) {
            let a = e[_l(s, o)];
            if (a && a(n.state, n.dispatch, n))
              return true;
          }
        }
        return false;
      };
    }
    const Fc = (t2, e) => t2.selection.empty ? false : (e && e(t2.tr.deleteSelection().scrollIntoView()), true);
    function Tf(t2, e) {
      let { $cursor: n } = t2.selection;
      return !n || (e ? !e.endOfTextblock("backward", t2) : n.parentOffset > 0) ? null : n;
    }
    const Of = (t2, e, n) => {
      let o = Tf(t2, n);
      if (!o)
        return false;
      let i = Hc(o);
      if (!i) {
        let r = o.blockRange(), a = r && Hi(r);
        return a == null ? false : (e && e(t2.tr.lift(r, a).scrollIntoView()), true);
      }
      let s = i.nodeBefore;
      if (Bf(t2, i, e, -1))
        return true;
      if (o.parent.content.size == 0 && (Ii(s, "end") || ie.isSelectable(s)))
        for (let r = o.depth; ; r--) {
          let a = Na(t2.doc, o.before(r), o.after(r), K.empty);
          if (a && a.slice.size < a.to - a.from) {
            if (e) {
              let l = t2.tr.step(a);
              l.setSelection(Ii(s, "end") ? de.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : ie.create(l.doc, i.pos - s.nodeSize)), e(l.scrollIntoView());
            }
            return true;
          }
          if (r == 1 || o.node(r - 1).childCount > 1)
            break;
        }
      return s.isAtom && i.depth == o.depth - 1 ? (e && e(t2.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), true) : false;
    }, tb = (t2, e, n) => {
      let o = Tf(t2, n);
      if (!o)
        return false;
      let i = Hc(o);
      return i ? Nf(t2, i, e) : false;
    }, nb = (t2, e, n) => {
      let o = Mf(t2, n);
      if (!o)
        return false;
      let i = Uc(o);
      return i ? Nf(t2, i, e) : false;
    };
    function Nf(t2, e, n) {
      let o = e.nodeBefore, i = o, s = e.pos - 1;
      for (; !i.isTextblock; s--) {
        if (i.type.spec.isolating)
          return false;
        let u = i.lastChild;
        if (!u)
          return false;
        i = u;
      }
      let r = e.nodeAfter, a = r, l = e.pos + 1;
      for (; !a.isTextblock; l++) {
        if (a.type.spec.isolating)
          return false;
        let u = a.firstChild;
        if (!u)
          return false;
        a = u;
      }
      let c2 = Na(t2.doc, s, l, K.empty);
      if (!c2 || c2.from != s || c2 instanceof Et && c2.slice.size >= l - s)
        return false;
      if (n) {
        let u = t2.tr.step(c2);
        u.setSelection(re.create(u.doc, s)), n(u.scrollIntoView());
      }
      return true;
    }
    function Ii(t2, e, n = false) {
      for (let o = t2; o; o = e == "start" ? o.firstChild : o.lastChild) {
        if (o.isTextblock)
          return true;
        if (n && o.childCount != 1)
          return false;
      }
      return false;
    }
    const Af = (t2, e, n) => {
      let { $head: o, empty: i } = t2.selection, s = o;
      if (!i)
        return false;
      if (o.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", t2) : o.parentOffset > 0)
          return false;
        s = Hc(o);
      }
      let r = s && s.nodeBefore;
      return !r || !ie.isSelectable(r) ? false : (e && e(t2.tr.setSelection(ie.create(t2.doc, s.pos - r.nodeSize)).scrollIntoView()), true);
    };
    function Hc(t2) {
      if (!t2.parent.type.spec.isolating)
        for (let e = t2.depth - 1; e >= 0; e--) {
          if (t2.index(e) > 0)
            return t2.doc.resolve(t2.before(e + 1));
          if (t2.node(e).type.spec.isolating)
            break;
        }
      return null;
    }
    function Mf(t2, e) {
      let { $cursor: n } = t2.selection;
      return !n || (e ? !e.endOfTextblock("forward", t2) : n.parentOffset < n.parent.content.size) ? null : n;
    }
    const Rf = (t2, e, n) => {
      let o = Mf(t2, n);
      if (!o)
        return false;
      let i = Uc(o);
      if (!i)
        return false;
      let s = i.nodeAfter;
      if (Bf(t2, i, e, 1))
        return true;
      if (o.parent.content.size == 0 && (Ii(s, "start") || ie.isSelectable(s))) {
        let r = Na(t2.doc, o.before(), o.after(), K.empty);
        if (r && r.slice.size < r.to - r.from) {
          if (e) {
            let a = t2.tr.step(r);
            a.setSelection(Ii(s, "start") ? de.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ie.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
          }
          return true;
        }
      }
      return s.isAtom && i.depth == o.depth - 1 ? (e && e(t2.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), true) : false;
    }, If = (t2, e, n) => {
      let { $head: o, empty: i } = t2.selection, s = o;
      if (!i)
        return false;
      if (o.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", t2) : o.parentOffset < o.parent.content.size)
          return false;
        s = Uc(o);
      }
      let r = s && s.nodeAfter;
      return !r || !ie.isSelectable(r) ? false : (e && e(t2.tr.setSelection(ie.create(t2.doc, s.pos)).scrollIntoView()), true);
    };
    function Uc(t2) {
      if (!t2.parent.type.spec.isolating)
        for (let e = t2.depth - 1; e >= 0; e--) {
          let n = t2.node(e);
          if (t2.index(e) + 1 < n.childCount)
            return t2.doc.resolve(t2.after(e + 1));
          if (n.type.spec.isolating)
            break;
        }
      return null;
    }
    const ob = (t2, e) => {
      let n = t2.selection, o = n instanceof ie, i;
      if (o) {
        if (n.node.isTextblock || !$o(t2.doc, n.from))
          return false;
        i = n.from;
      } else if (i = Oa(t2.doc, n.from, -1), i == null)
        return false;
      if (e) {
        let s = t2.tr.join(i);
        o && s.setSelection(ie.create(s.doc, i - t2.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView());
      }
      return true;
    }, ib = (t2, e) => {
      let n = t2.selection, o;
      if (n instanceof ie) {
        if (n.node.isTextblock || !$o(t2.doc, n.to))
          return false;
        o = n.to;
      } else if (o = Oa(t2.doc, n.to, 1), o == null)
        return false;
      return e && e(t2.tr.join(o).scrollIntoView()), true;
    }, sb = (t2, e) => {
      let { $from: n, $to: o } = t2.selection, i = n.blockRange(o), s = i && Hi(i);
      return s == null ? false : (e && e(t2.tr.lift(i, s).scrollIntoView()), true);
    }, Df = (t2, e) => {
      let { $head: n, $anchor: o } = t2.selection;
      return !n.parent.type.spec.code || !n.sameParent(o) ? false : (e && e(t2.tr.insertText(`
`).scrollIntoView()), true);
    };
    function Vc(t2) {
      for (let e = 0; e < t2.edgeCount; e++) {
        let { type: n } = t2.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
          return n;
      }
      return null;
    }
    const rb = (t2, e) => {
      let { $head: n, $anchor: o } = t2.selection;
      if (!n.parent.type.spec.code || !n.sameParent(o))
        return false;
      let i = n.node(-1), s = n.indexAfter(-1), r = Vc(i.contentMatchAt(s));
      if (!r || !i.canReplaceWith(s, s, r))
        return false;
      if (e) {
        let a = n.after(), l = t2.tr.replaceWith(a, a, r.createAndFill());
        l.setSelection(de.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
      }
      return true;
    }, Lf = (t2, e) => {
      let n = t2.selection, { $from: o, $to: i } = n;
      if (n instanceof pn || o.parent.inlineContent || i.parent.inlineContent)
        return false;
      let s = Vc(i.parent.contentMatchAt(i.indexAfter()));
      if (!s || !s.isTextblock)
        return false;
      if (e) {
        let r = (!o.parentOffset && i.index() < i.parent.childCount ? o : i).pos, a = t2.tr.insert(r, s.createAndFill());
        a.setSelection(re.create(a.doc, r + 1)), e(a.scrollIntoView());
      }
      return true;
    }, Pf = (t2, e) => {
      let { $cursor: n } = t2.selection;
      if (!n || n.parent.content.size)
        return false;
      if (n.depth > 1 && n.after() != n.end(-1)) {
        let s = n.before();
        if (uo(t2.doc, s))
          return e && e(t2.tr.split(s).scrollIntoView()), true;
      }
      let o = n.blockRange(), i = o && Hi(o);
      return i == null ? false : (e && e(t2.tr.lift(o, i).scrollIntoView()), true);
    };
    function ab(t2) {
      return (e, n) => {
        let { $from: o, $to: i } = e.selection;
        if (e.selection instanceof ie && e.selection.node.isBlock)
          return !o.parentOffset || !uo(e.doc, o.pos) ? false : (n && n(e.tr.split(o.pos).scrollIntoView()), true);
        if (!o.depth)
          return false;
        let s = [], r, a, l = false, c2 = false;
        for (let m = o.depth; ; m--)
          if (o.node(m).isBlock) {
            l = o.end(m) == o.pos + (o.depth - m), c2 = o.start(m) == o.pos - (o.depth - m), a = Vc(o.node(m - 1).contentMatchAt(o.indexAfter(m - 1))), s.unshift(l && a ? { type: a } : null), r = m;
            break;
          } else {
            if (m == 1)
              return false;
            s.unshift(null);
          }
        let u = e.tr;
        (e.selection instanceof re || e.selection instanceof pn) && u.deleteSelection();
        let d = u.mapping.map(o.pos), p2 = uo(u.doc, d, s.length, s);
        if (p2 || (s[0] = a ? { type: a } : null, p2 = uo(u.doc, d, s.length, s)), u.split(d, s.length, s), !l && c2 && o.node(r).type != a) {
          let m = u.mapping.map(o.before(r)), f = u.doc.resolve(m);
          a && o.node(r - 1).canReplaceWith(f.index(), f.index() + 1, a) && u.setNodeMarkup(u.mapping.map(o.before(r)), a);
        }
        return n && n(u.scrollIntoView()), true;
      };
    }
    const lb = ab(), cb = (t2, e) => {
      let { $from: n, to: o } = t2.selection, i, s = n.sharedDepth(o);
      return s == 0 ? false : (i = n.before(s), e && e(t2.tr.setSelection(ie.create(t2.doc, i))), true);
    };
    function ub(t2, e, n) {
      let o = e.nodeBefore, i = e.nodeAfter, s = e.index();
      return !o || !i || !o.type.compatibleContent(i.type) ? false : !o.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t2.tr.delete(e.pos - o.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || $o(t2.doc, e.pos)) ? false : (n && n(t2.tr.join(e.pos).scrollIntoView()), true);
    }
    function Bf(t2, e, n, o) {
      let i = e.nodeBefore, s = e.nodeAfter, r, a, l = i.type.spec.isolating || s.type.spec.isolating;
      if (!l && ub(t2, e, n))
        return true;
      let c2 = !l && e.parent.canReplace(e.index(), e.index() + 1);
      if (c2 && (r = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && a.matchType(r[0] || s.type).validEnd) {
        if (n) {
          let m = e.pos + s.nodeSize, f = D.empty;
          for (let g = r.length - 1; g >= 0; g--)
            f = D.from(r[g].create(null, f));
          f = D.from(i.copy(f));
          let _ = t2.tr.step(new Ct(e.pos - 1, m, e.pos, m, new K(f, 1, 0), r.length, true)), h2 = _.doc.resolve(m + 2 * r.length);
          h2.nodeAfter && h2.nodeAfter.type == i.type && $o(_.doc, h2.pos) && _.join(h2.pos), n(_.scrollIntoView());
        }
        return true;
      }
      let u = s.type.spec.isolating || o > 0 && l ? null : de.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), p2 = d && Hi(d);
      if (p2 != null && p2 >= e.depth)
        return n && n(t2.tr.lift(d, p2).scrollIntoView()), true;
      if (c2 && Ii(s, "start", true) && Ii(i, "end")) {
        let m = i, f = [];
        for (; f.push(m), !m.isTextblock; )
          m = m.lastChild;
        let _ = s, h2 = 1;
        for (; !_.isTextblock; _ = _.firstChild)
          h2++;
        if (m.canReplace(m.childCount, m.childCount, _.content)) {
          if (n) {
            let g = D.empty;
            for (let j = f.length - 1; j >= 0; j--)
              g = D.from(f[j].copy(g));
            let k = t2.tr.step(new Ct(e.pos - f.length, e.pos + s.nodeSize, e.pos + h2, e.pos + s.nodeSize - h2, new K(g, f.length, 0), 0, true));
            n(k.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function $f(t2) {
      return function(e, n) {
        let o = e.selection, i = t2 < 0 ? o.$from : o.$to, s = i.depth;
        for (; i.node(s).isInline; ) {
          if (!s)
            return false;
          s--;
        }
        return i.node(s).isTextblock ? (n && n(e.tr.setSelection(re.create(e.doc, t2 < 0 ? i.start(s) : i.end(s)))), true) : false;
      };
    }
    const db = $f(-1), pb = $f(1);
    function mb(t2, e = null) {
      return function(n, o) {
        let { $from: i, $to: s } = n.selection, r = i.blockRange(s), a = r && Tc(r, t2, e);
        return a ? (o && o(n.tr.wrap(r, a).scrollIntoView()), true) : false;
      };
    }
    function Hd(t2, e = null) {
      return function(n, o) {
        let i = false;
        for (let s = 0; s < n.selection.ranges.length && !i; s++) {
          let { $from: { pos: r }, $to: { pos: a } } = n.selection.ranges[s];
          n.doc.nodesBetween(r, a, (l, c2) => {
            if (i)
              return false;
            if (!(!l.isTextblock || l.hasMarkup(t2, e)))
              if (l.type == t2)
                i = true;
              else {
                let u = n.doc.resolve(c2), d = u.index();
                i = u.parent.canReplaceWith(d, d + 1, t2);
              }
          });
        }
        if (!i)
          return false;
        if (o) {
          let s = n.tr;
          for (let r = 0; r < n.selection.ranges.length; r++) {
            let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[r];
            s.setBlockType(a, l, t2, e);
          }
          o(s.scrollIntoView());
        }
        return true;
      };
    }
    function qc(...t2) {
      return function(e, n, o) {
        for (let i = 0; i < t2.length; i++)
          if (t2[i](e, n, o))
            return true;
        return false;
      };
    }
    qc(Fc, Of, Af);
    qc(Fc, Rf, If);
    qc(Df, Lf, Pf, lb);
    typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
    function fb(t2, e = null) {
      return function(n, o) {
        let { $from: i, $to: s } = n.selection, r = i.blockRange(s);
        if (!r)
          return false;
        let a = o ? n.tr : null;
        return _b(a, r, t2, e) ? (o && o(a.scrollIntoView()), true) : false;
      };
    }
    function _b(t2, e, n, o = null) {
      let i = false, s = e, r = e.$from.doc;
      if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
        if (e.$from.index(e.depth - 1) == 0)
          return false;
        let l = r.resolve(e.start - 2);
        s = new Pr(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Pr(e.$from, r.resolve(e.$to.end(e.depth)), e.depth)), i = true;
      }
      let a = Tc(s, n, o, e);
      return a ? (t2 && hb(t2, e, a, i, n), true) : false;
    }
    function hb(t2, e, n, o, i) {
      let s = D.empty;
      for (let u = n.length - 1; u >= 0; u--)
        s = D.from(n[u].type.create(n[u].attrs, s));
      t2.step(new Ct(e.start - (o ? 2 : 0), e.end, e.start, e.end, new K(s, 0, 0), n.length, true));
      let r = 0;
      for (let u = 0; u < n.length; u++)
        n[u].type == i && (r = u + 1);
      let a = n.length - r, l = e.start + n.length - (o ? 2 : 0), c2 = e.parent;
      for (let u = e.startIndex, d = e.endIndex, p2 = true; u < d; u++, p2 = false)
        !p2 && uo(t2.doc, l, a) && (t2.split(l, a), l += 2 * a), l += c2.child(u).nodeSize;
      return t2;
    }
    function gb(t2) {
      return function(e, n) {
        let { $from: o, $to: i } = e.selection, s = o.blockRange(i, (r) => r.childCount > 0 && r.firstChild.type == t2);
        return s ? n ? o.node(s.depth - 1).type == t2 ? vb(e, n, t2, s) : bb(e, n, s) : true : false;
      };
    }
    function vb(t2, e, n, o) {
      let i = t2.tr, s = o.end, r = o.$to.end(o.depth);
      s < r && (i.step(new Ct(s - 1, r, s, r, new K(D.from(n.create(null, o.parent.copy())), 1, 0), 1, true)), o = new Pr(i.doc.resolve(o.$from.pos), i.doc.resolve(r), o.depth));
      const a = Hi(o);
      if (a == null)
        return false;
      i.lift(o, a);
      let l = i.doc.resolve(i.mapping.map(s, -1) - 1);
      return $o(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos), e(i.scrollIntoView()), true;
    }
    function bb(t2, e, n) {
      let o = t2.tr, i = n.parent;
      for (let m = n.end, f = n.endIndex - 1, _ = n.startIndex; f > _; f--)
        m -= i.child(f).nodeSize, o.delete(m - 1, m + 1);
      let s = o.doc.resolve(n.start), r = s.nodeAfter;
      if (o.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
        return false;
      let a = n.startIndex == 0, l = n.endIndex == i.childCount, c2 = s.node(-1), u = s.index(-1);
      if (!c2.canReplace(u + (a ? 0 : 1), u + 1, r.content.append(l ? D.empty : D.from(i))))
        return false;
      let d = s.pos, p2 = d + r.nodeSize;
      return o.step(new Ct(d - (a ? 1 : 0), p2 + (l ? 1 : 0), d + 1, p2 - 1, new K((a ? D.empty : D.from(i.copy(D.empty))).append(l ? D.empty : D.from(i.copy(D.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(o.scrollIntoView()), true;
    }
    function kb(t2) {
      return function(e, n) {
        let { $from: o, $to: i } = e.selection, s = o.blockRange(i, (c2) => c2.childCount > 0 && c2.firstChild.type == t2);
        if (!s)
          return false;
        let r = s.startIndex;
        if (r == 0)
          return false;
        let a = s.parent, l = a.child(r - 1);
        if (l.type != t2)
          return false;
        if (n) {
          let c2 = l.lastChild && l.lastChild.type == a.type, u = D.from(c2 ? t2.create() : null), d = new K(D.from(t2.create(null, D.from(a.type.create(null, u)))), c2 ? 3 : 1, 0), p2 = s.start, m = s.end;
          n(e.tr.step(new Ct(p2 - (c2 ? 3 : 1), m, p2, m, d, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    function Da(t2) {
      const { state: e, transaction: n } = t2;
      let { selection: o } = n, { doc: i } = n, { storedMarks: s } = n;
      return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
          return s;
        },
        get selection() {
          return o;
        },
        get doc() {
          return i;
        },
        get tr() {
          return o = n.selection, i = n.doc, s = n.storedMarks, n;
        }
      };
    }
    class La {
      constructor(e) {
        this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands: e, editor: n, state: o } = this, { view: i } = n, { tr: s } = o, r = this.buildProps(s);
        return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
          const d = l(...u)(r);
          return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), d;
        }]));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(e, n = true) {
        const { rawCommands: o, editor: i, state: s } = this, { view: r } = i, a = [], l = !!e, c2 = e || s.tr, u = () => (!l && n && !c2.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(c2), a.every((p2) => p2 === true)), d = {
          ...Object.fromEntries(Object.entries(o).map(([p2, m]) => [p2, (..._) => {
            const h2 = this.buildProps(c2, n), g = m(..._)(h2);
            return a.push(g), d;
          }])),
          run: u
        };
        return d;
      }
      createCan(e) {
        const { rawCommands: n, state: o } = this, i = false, s = e || o.tr, r = this.buildProps(s, i);
        return {
          ...Object.fromEntries(Object.entries(n).map(([l, c2]) => [l, (...u) => c2(...u)({ ...r, dispatch: void 0 })])),
          chain: () => this.createChain(s, i)
        };
      }
      buildProps(e, n = true) {
        const { rawCommands: o, editor: i, state: s } = this, { view: r } = i, a = {
          tr: e,
          editor: i,
          view: r,
          state: Da({
            state: s,
            transaction: e
          }),
          dispatch: n ? () => {
          } : void 0,
          chain: () => this.createChain(e, n),
          can: () => this.createCan(e),
          get commands() {
            return Object.fromEntries(Object.entries(o).map(([l, c2]) => [l, (...u) => c2(...u)(a)]));
          }
        };
        return a;
      }
    }
    class yb {
      constructor() {
        this.callbacks = {};
      }
      on(e, n) {
        return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
      }
      emit(e, ...n) {
        const o = this.callbacks[e];
        return o && o.forEach((i) => i.apply(this, n)), this;
      }
      off(e, n) {
        const o = this.callbacks[e];
        return o && (n ? this.callbacks[e] = o.filter((i) => i !== n) : delete this.callbacks[e]), this;
      }
      once(e, n) {
        const o = (...i) => {
          this.off(e, o), n.apply(this, i);
        };
        return this.on(e, o);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    }
    function Z(t2, e, n) {
      return t2.config[e] === void 0 && t2.parent ? Z(t2.parent, e, n) : typeof t2.config[e] == "function" ? t2.config[e].bind({
        ...n,
        parent: t2.parent ? Z(t2.parent, e, n) : null
      }) : t2.config[e];
    }
    function Pa(t2) {
      const e = t2.filter((i) => i.type === "extension"), n = t2.filter((i) => i.type === "node"), o = t2.filter((i) => i.type === "mark");
      return {
        baseExtensions: e,
        nodeExtensions: n,
        markExtensions: o
      };
    }
    function zf(t2) {
      const e = [], { nodeExtensions: n, markExtensions: o } = Pa(t2), i = [...n, ...o], s = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      return t2.forEach((r) => {
        const a = {
          name: r.name,
          options: r.options,
          storage: r.storage,
          extensions: i
        }, l = Z(r, "addGlobalAttributes", a);
        if (!l)
          return;
        l().forEach((u) => {
          u.types.forEach((d) => {
            Object.entries(u.attributes).forEach(([p2, m]) => {
              e.push({
                type: d,
                name: p2,
                attribute: {
                  ...s,
                  ...m
                }
              });
            });
          });
        });
      }), i.forEach((r) => {
        const a = {
          name: r.name,
          options: r.options,
          storage: r.storage
        }, l = Z(r, "addAttributes", a);
        if (!l)
          return;
        const c2 = l();
        Object.entries(c2).forEach(([u, d]) => {
          const p2 = {
            ...s,
            ...d
          };
          typeof (p2 == null ? void 0 : p2.default) == "function" && (p2.default = p2.default()), p2 != null && p2.isRequired && (p2 == null ? void 0 : p2.default) === void 0 && delete p2.default, e.push({
            type: r.name,
            name: u,
            attribute: p2
          });
        });
      }), e;
    }
    function Tt(t2, e) {
      if (typeof t2 == "string") {
        if (!e.nodes[t2])
          throw Error(`There is no node type named '${t2}'. Maybe you forgot to add the extension?`);
        return e.nodes[t2];
      }
      return t2;
    }
    function Pe(...t2) {
      return t2.filter((e) => !!e).reduce((e, n) => {
        const o = { ...e };
        return Object.entries(n).forEach(([i, s]) => {
          if (!o[i]) {
            o[i] = s;
            return;
          }
          if (i === "class") {
            const a = s ? String(s).split(" ") : [], l = o[i] ? o[i].split(" ") : [], c2 = a.filter((u) => !l.includes(u));
            o[i] = [...l, ...c2].join(" ");
          } else if (i === "style") {
            const a = s ? s.split(";").map((u) => u.trim()).filter(Boolean) : [], l = o[i] ? o[i].split(";").map((u) => u.trim()).filter(Boolean) : [], c2 = /* @__PURE__ */ new Map();
            l.forEach((u) => {
              const [d, p2] = u.split(":").map((m) => m.trim());
              c2.set(d, p2);
            }), a.forEach((u) => {
              const [d, p2] = u.split(":").map((m) => m.trim());
              c2.set(d, p2);
            }), o[i] = Array.from(c2.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
          } else
            o[i] = s;
        }), o;
      }, {});
    }
    function tc(t2, e) {
      return e.filter((n) => n.type === t2.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t2.attrs) || {} : {
        [n.name]: t2.attrs[n.name]
      }).reduce((n, o) => Pe(n, o), {});
    }
    function Ff(t2) {
      return typeof t2 == "function";
    }
    function Te(t2, e = void 0, ...n) {
      return Ff(t2) ? e ? t2.bind(e)(...n) : t2(...n) : t2;
    }
    function wb(t2 = {}) {
      return Object.keys(t2).length === 0 && t2.constructor === Object;
    }
    function jb(t2) {
      return typeof t2 != "string" ? t2 : t2.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t2) : t2 === "true" ? true : t2 === "false" ? false : t2;
    }
    function Ud(t2, e) {
      return "style" in t2 ? t2 : {
        ...t2,
        getAttrs: (n) => {
          const o = t2.getAttrs ? t2.getAttrs(n) : t2.attrs;
          if (o === false)
            return false;
          const i = e.reduce((s, r) => {
            const a = r.attribute.parseHTML ? r.attribute.parseHTML(n) : jb(n.getAttribute(r.name));
            return a == null ? s : {
              ...s,
              [r.name]: a
            };
          }, {});
          return { ...o, ...i };
        }
      };
    }
    function Vd(t2) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(t2).filter(([e, n]) => e === "attrs" && wb(n) ? false : n != null)
      );
    }
    function Eb(t2, e) {
      var n;
      const o = zf(t2), { nodeExtensions: i, markExtensions: s } = Pa(t2), r = (n = i.find((c2) => Z(c2, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(i.map((c2) => {
        const u = o.filter((g) => g.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = t2.reduce((g, k) => {
          const j = Z(k, "extendNodeSchema", d);
          return {
            ...g,
            ...j ? j(c2) : {}
          };
        }, {}), m = Vd({
          ...p2,
          content: Te(Z(c2, "content", d)),
          marks: Te(Z(c2, "marks", d)),
          group: Te(Z(c2, "group", d)),
          inline: Te(Z(c2, "inline", d)),
          atom: Te(Z(c2, "atom", d)),
          selectable: Te(Z(c2, "selectable", d)),
          draggable: Te(Z(c2, "draggable", d)),
          code: Te(Z(c2, "code", d)),
          whitespace: Te(Z(c2, "whitespace", d)),
          linebreakReplacement: Te(Z(c2, "linebreakReplacement", d)),
          defining: Te(Z(c2, "defining", d)),
          isolating: Te(Z(c2, "isolating", d)),
          attrs: Object.fromEntries(u.map((g) => {
            var k;
            return [g.name, { default: (k = g == null ? void 0 : g.attribute) === null || k === void 0 ? void 0 : k.default }];
          }))
        }), f = Te(Z(c2, "parseHTML", d));
        f && (m.parseDOM = f.map((g) => Ud(g, u)));
        const _ = Z(c2, "renderHTML", d);
        _ && (m.toDOM = (g) => _({
          node: g,
          HTMLAttributes: tc(g, u)
        }));
        const h2 = Z(c2, "renderText", d);
        return h2 && (m.toText = h2), [c2.name, m];
      })), l = Object.fromEntries(s.map((c2) => {
        const u = o.filter((h2) => h2.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = t2.reduce((h2, g) => {
          const k = Z(g, "extendMarkSchema", d);
          return {
            ...h2,
            ...k ? k(c2) : {}
          };
        }, {}), m = Vd({
          ...p2,
          inclusive: Te(Z(c2, "inclusive", d)),
          excludes: Te(Z(c2, "excludes", d)),
          group: Te(Z(c2, "group", d)),
          spanning: Te(Z(c2, "spanning", d)),
          code: Te(Z(c2, "code", d)),
          attrs: Object.fromEntries(u.map((h2) => {
            var g;
            return [h2.name, { default: (g = h2 == null ? void 0 : h2.attribute) === null || g === void 0 ? void 0 : g.default }];
          }))
        }), f = Te(Z(c2, "parseHTML", d));
        f && (m.parseDOM = f.map((h2) => Ud(h2, u)));
        const _ = Z(c2, "renderHTML", d);
        return _ && (m.toDOM = (h2) => _({
          mark: h2,
          HTMLAttributes: tc(h2, u)
        })), [c2.name, m];
      }));
      return new Om({
        topNode: r,
        nodes: a,
        marks: l
      });
    }
    function hl(t2, e) {
      return e.nodes[t2] || e.marks[t2] || null;
    }
    function qd(t2, e) {
      return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t2.name) : e;
    }
    function Kc(t2, e) {
      const n = mi.fromSchema(e).serializeFragment(t2), i = document.implementation.createHTMLDocument().createElement("div");
      return i.appendChild(n), i.innerHTML;
    }
    const Sb = (t2, e = 500) => {
      let n = "";
      const o = t2.parentOffset;
      return t2.parent.nodesBetween(Math.max(0, o - e), o, (i, s, r, a) => {
        var l, c2;
        const u = ((c2 = (l = i.type.spec).toText) === null || c2 === void 0 ? void 0 : c2.call(l, {
          node: i,
          pos: s,
          parent: r,
          index: a
        })) || i.textContent || "%leaf%";
        n += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, o - s));
      }), n;
    };
    function Wc(t2) {
      return Object.prototype.toString.call(t2) === "[object RegExp]";
    }
    class Vs {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const Cb = (t2, e) => {
      if (Wc(e))
        return e.exec(t2);
      const n = e(t2);
      if (!n)
        return null;
      const o = [n.text];
      return o.index = n.index, o.input = t2, o.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), o.push(n.replaceWith)), o;
    };
    function tr(t2) {
      var e;
      const { editor: n, from: o, to: i, text: s, rules: r, plugin: a } = t2, { view: l } = n;
      if (l.composing)
        return false;
      const c2 = l.state.doc.resolve(o);
      if (
        // check for code node
        c2.parent.type.spec.code || !((e = c2.nodeBefore || c2.nodeAfter) === null || e === void 0) && e.marks.find((p2) => p2.type.spec.code)
      )
        return false;
      let u = false;
      const d = Sb(c2) + s;
      return r.forEach((p2) => {
        if (u)
          return;
        const m = Cb(d, p2.find);
        if (!m)
          return;
        const f = l.state.tr, _ = Da({
          state: l.state,
          transaction: f
        }), h2 = {
          from: o - (m[0].length - s.length),
          to: i
        }, { commands: g, chain: k, can: j } = new La({
          editor: n,
          state: _
        });
        p2.handler({
          state: _,
          range: h2,
          match: m,
          commands: g,
          chain: k,
          can: j
        }) === null || !f.steps.length || (f.setMeta(a, {
          transform: f,
          from: o,
          to: i,
          text: s
        }), l.dispatch(f), u = true);
      }), u;
    }
    function xb(t2) {
      const { editor: e, rules: n } = t2, o = new ze({
        state: {
          init() {
            return null;
          },
          apply(i, s, r) {
            const a = i.getMeta(o);
            if (a)
              return a;
            const l = i.getMeta("applyInputRules");
            return !!l && setTimeout(() => {
              let { text: u } = l;
              typeof u == "string" ? u = u : u = Kc(D.from(u), r.schema);
              const { from: d } = l, p2 = d + u.length;
              tr({
                editor: e,
                from: d,
                to: p2,
                text: u,
                rules: n,
                plugin: o
              });
            }), i.selectionSet || i.docChanged ? null : s;
          }
        },
        props: {
          handleTextInput(i, s, r, a) {
            return tr({
              editor: e,
              from: s,
              to: r,
              text: a,
              rules: n,
              plugin: o
            });
          },
          handleDOMEvents: {
            compositionend: (i) => (setTimeout(() => {
              const { $cursor: s } = i.state.selection;
              s && tr({
                editor: e,
                from: s.pos,
                to: s.pos,
                text: "",
                rules: n,
                plugin: o
              });
            }), false)
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(i, s) {
            if (s.key !== "Enter")
              return false;
            const { $cursor: r } = i.state.selection;
            return r ? tr({
              editor: e,
              from: r.pos,
              to: r.pos,
              text: `
`,
              rules: n,
              plugin: o
            }) : false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return o;
    }
    function Tb(t2) {
      return Object.prototype.toString.call(t2).slice(8, -1);
    }
    function nr(t2) {
      return Tb(t2) !== "Object" ? false : t2.constructor === Object && Object.getPrototypeOf(t2) === Object.prototype;
    }
    function Ba(t2, e) {
      const n = { ...t2 };
      return nr(t2) && nr(e) && Object.keys(e).forEach((o) => {
        nr(e[o]) && nr(t2[o]) ? n[o] = Ba(t2[o], e[o]) : n[o] = e[o];
      }), n;
    }
    class jn {
      constructor(e = {}) {
        this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new jn(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new jn(e);
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
      static handleExit({ editor: e, mark: n }) {
        const { tr: o } = e.state, i = e.state.selection.$from;
        if (i.pos === i.end()) {
          const r = i.marks();
          if (!!!r.find((c2) => (c2 == null ? void 0 : c2.type.name) === n.name))
            return false;
          const l = r.find((c2) => (c2 == null ? void 0 : c2.type.name) === n.name);
          return l && o.removeStoredMark(l), o.insertText(" ", i.pos), e.view.dispatch(o), true;
        }
        return false;
      }
    }
    function Ob(t2) {
      return typeof t2 == "number";
    }
    class Nb {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const Ab = (t2, e, n) => {
      if (Wc(e))
        return [...t2.matchAll(e)];
      const o = e(t2, n);
      return o ? o.map((i) => {
        const s = [i.text];
        return s.index = i.index, s.input = t2, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s;
      }) : [];
    };
    function Mb(t2) {
      const { editor: e, state: n, from: o, to: i, rule: s, pasteEvent: r, dropEvent: a } = t2, { commands: l, chain: c2, can: u } = new La({
        editor: e,
        state: n
      }), d = [];
      return n.doc.nodesBetween(o, i, (m, f) => {
        if (!m.isTextblock || m.type.spec.code)
          return;
        const _ = Math.max(o, f), h2 = Math.min(i, f + m.content.size), g = m.textBetween(_ - f, h2 - f, void 0, "￼");
        Ab(g, s.find, r).forEach((j) => {
          if (j.index === void 0)
            return;
          const v = _ + j.index + 1, C = v + j[0].length, E = {
            from: n.tr.mapping.map(v),
            to: n.tr.mapping.map(C)
          }, B = s.handler({
            state: n,
            range: E,
            match: j,
            commands: l,
            chain: c2,
            can: u,
            pasteEvent: r,
            dropEvent: a
          });
          d.push(B);
        });
      }), d.every((m) => m !== null);
    }
    let or = null;
    const Rb = (t2) => {
      var e;
      const n = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t2), n;
    };
    function Ib(t2) {
      const { editor: e, rules: n } = t2;
      let o = null, i = false, s = false, r = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      const l = ({ state: u, from: d, to: p2, rule: m, pasteEvt: f }) => {
        const _ = u.tr, h2 = Da({
          state: u,
          transaction: _
        });
        if (!(!Mb({
          editor: e,
          state: h2,
          from: Math.max(d - 1, 0),
          to: p2.b - 1,
          rule: m,
          pasteEvent: f,
          dropEvent: a
        }) || !_.steps.length)) {
          try {
            a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
          } catch {
            a = null;
          }
          return r = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, _;
        }
      };
      return n.map((u) => new ze({
        // we register a global drag handler to track the current drag source element
        view(d) {
          const p2 = (f) => {
            var _;
            o = !((_ = d.dom.parentElement) === null || _ === void 0) && _.contains(f.target) ? d.dom.parentElement : null, o && (or = e);
          }, m = () => {
            or && (or = null);
          };
          return window.addEventListener("dragstart", p2), window.addEventListener("dragend", m), {
            destroy() {
              window.removeEventListener("dragstart", p2), window.removeEventListener("dragend", m);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (d, p2) => {
              if (s = o === d.dom.parentElement, a = p2, !s) {
                const m = or;
                m && setTimeout(() => {
                  const f = m.state.selection;
                  f && m.commands.deleteRange({ from: f.from, to: f.to });
                }, 10);
              }
              return false;
            },
            paste: (d, p2) => {
              var m;
              const f = (m = p2.clipboardData) === null || m === void 0 ? void 0 : m.getData("text/html");
              return r = p2, i = !!(f != null && f.includes("data-pm-slice")), false;
            }
          }
        },
        appendTransaction: (d, p2, m) => {
          const f = d[0], _ = f.getMeta("uiEvent") === "paste" && !i, h2 = f.getMeta("uiEvent") === "drop" && !s, g = f.getMeta("applyPasteRules"), k = !!g;
          if (!_ && !h2 && !k)
            return;
          if (k) {
            let { text: C } = g;
            typeof C == "string" ? C = C : C = Kc(D.from(C), m.schema);
            const { from: E } = g, B = E + C.length, U = Rb(C);
            return l({
              rule: u,
              state: m,
              from: E,
              to: { b: B },
              pasteEvt: U
            });
          }
          const j = p2.doc.content.findDiffStart(m.doc.content), v = p2.doc.content.findDiffEnd(m.doc.content);
          if (!(!Ob(j) || !v || j === v.b))
            return l({
              rule: u,
              state: m,
              from: j,
              to: v,
              pasteEvt: r
            });
        }
      }));
    }
    function Db(t2) {
      const e = t2.filter((n, o) => t2.indexOf(n) !== o);
      return Array.from(new Set(e));
    }
    class xi {
      constructor(e, n) {
        this.splittableMarks = [], this.editor = n, this.extensions = xi.resolve(e), this.schema = Eb(this.extensions, n), this.setupExtensions();
      }
      /**
       * Returns a flattened and sorted extension list while
       * also checking for duplicated extensions and warns the user.
       * @param extensions An array of Tiptap extensions
       * @returns An flattened and sorted array of Tiptap extensions
       */
      static resolve(e) {
        const n = xi.sort(xi.flatten(e)), o = Db(n.map((i) => i.name));
        return o.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${o.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
      }
      /**
       * Create a flattened array of extensions by traversing the `addExtensions` field.
       * @param extensions An array of Tiptap extensions
       * @returns A flattened array of Tiptap extensions
       */
      static flatten(e) {
        return e.map((n) => {
          const o = {
            name: n.name,
            options: n.options,
            storage: n.storage
          }, i = Z(n, "addExtensions", o);
          return i ? [n, ...this.flatten(i())] : n;
        }).flat(10);
      }
      /**
       * Sort extensions by priority.
       * @param extensions An array of Tiptap extensions
       * @returns A sorted array of Tiptap extensions by priority
       */
      static sort(e) {
        return e.sort((o, i) => {
          const s = Z(o, "priority") || 100, r = Z(i, "priority") || 100;
          return s > r ? -1 : s < r ? 1 : 0;
        });
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((e, n) => {
          const o = {
            name: n.name,
            options: n.options,
            storage: n.storage,
            editor: this.editor,
            type: hl(n.name, this.schema)
          }, i = Z(n, "addCommands", o);
          return i ? {
            ...e,
            ...i()
          } : e;
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor: e } = this, n = xi.sort([...this.extensions].reverse()), o = [], i = [], s = n.map((r) => {
          const a = {
            name: r.name,
            options: r.options,
            storage: r.storage,
            editor: e,
            type: hl(r.name, this.schema)
          }, l = [], c2 = Z(r, "addKeyboardShortcuts", a);
          let u = {};
          if (r.type === "mark" && Z(r, "exitable", a) && (u.ArrowRight = () => jn.handleExit({ editor: e, mark: r })), c2) {
            const _ = Object.fromEntries(Object.entries(c2()).map(([h2, g]) => [h2, () => g({ editor: e })]));
            u = { ...u, ..._ };
          }
          const d = eb(u);
          l.push(d);
          const p2 = Z(r, "addInputRules", a);
          qd(r, e.options.enableInputRules) && p2 && o.push(...p2());
          const m = Z(r, "addPasteRules", a);
          qd(r, e.options.enablePasteRules) && m && i.push(...m());
          const f = Z(r, "addProseMirrorPlugins", a);
          if (f) {
            const _ = f();
            l.push(..._);
          }
          return l;
        }).flat();
        return [
          xb({
            editor: e,
            rules: o
          }),
          ...Ib({
            editor: e,
            rules: i
          }),
          ...s
        ];
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return zf(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor: e } = this, { nodeExtensions: n } = Pa(this.extensions);
        return Object.fromEntries(n.filter((o) => !!Z(o, "addNodeView")).map((o) => {
          const i = this.attributes.filter((l) => l.type === o.name), s = {
            name: o.name,
            options: o.options,
            storage: o.storage,
            editor: e,
            type: Tt(o.name, this.schema)
          }, r = Z(o, "addNodeView", s);
          if (!r)
            return [];
          const a = (l, c2, u, d, p2) => {
            const m = tc(l, i);
            return r()({
              // pass-through
              node: l,
              view: c2,
              getPos: u,
              decorations: d,
              innerDecorations: p2,
              // tiptap-specific
              editor: e,
              extension: o,
              HTMLAttributes: m
            });
          };
          return [o.name, a];
        }));
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        this.extensions.forEach((e) => {
          var n;
          this.editor.extensionStorage[e.name] = e.storage;
          const o = {
            name: e.name,
            options: e.options,
            storage: e.storage,
            editor: this.editor,
            type: hl(e.name, this.schema)
          };
          e.type === "mark" && (!((n = Te(Z(e, "keepOnSplit", o))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
          const i = Z(e, "onBeforeCreate", o), s = Z(e, "onCreate", o), r = Z(e, "onUpdate", o), a = Z(e, "onSelectionUpdate", o), l = Z(e, "onTransaction", o), c2 = Z(e, "onFocus", o), u = Z(e, "onBlur", o), d = Z(e, "onDestroy", o);
          i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), r && this.editor.on("update", r), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c2 && this.editor.on("focus", c2), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
        });
      }
    }
    class We {
      constructor(e = {}) {
        this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new We(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new We({ ...this.config, ...e });
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
    }
    function Hf(t2, e, n) {
      const { from: o, to: i } = e, { blockSeparator: s = `

`, textSerializers: r = {} } = n || {};
      let a = "";
      return t2.nodesBetween(o, i, (l, c2, u, d) => {
        var p2;
        l.isBlock && c2 > o && (a += s);
        const m = r == null ? void 0 : r[l.type.name];
        if (m)
          return u && (a += m({
            node: l,
            pos: c2,
            parent: u,
            index: d,
            range: e
          })), false;
        l.isText && (a += (p2 = l == null ? void 0 : l.text) === null || p2 === void 0 ? void 0 : p2.slice(Math.max(o, c2) - c2, i - c2));
      }), a;
    }
    function Gc(t2) {
      return Object.fromEntries(Object.entries(t2.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
    }
    const Lb = We.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor: t2 } = this, { state: e, schema: n } = t2, { doc: o, selection: i } = e, { ranges: s } = i, r = Math.min(...s.map((u) => u.$from.pos)), a = Math.max(...s.map((u) => u.$to.pos)), l = Gc(n);
                return Hf(o, { from: r, to: a }, {
                  ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                  textSerializers: l
                });
              }
            }
          })
        ];
      }
    }), Pb = () => ({ editor: t2, view: e }) => (requestAnimationFrame(() => {
      var n;
      t2.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
    }), true), Bb = (t2 = false) => ({ commands: e }) => e.setContent("", t2), $b = () => ({ state: t2, tr: e, dispatch: n }) => {
      const { selection: o } = e, { ranges: i } = o;
      return n && i.forEach(({ $from: s, $to: r }) => {
        t2.doc.nodesBetween(s.pos, r.pos, (a, l) => {
          if (a.type.isText)
            return;
          const { doc: c2, mapping: u } = e, d = c2.resolve(u.map(l)), p2 = c2.resolve(u.map(l + a.nodeSize)), m = d.blockRange(p2);
          if (!m)
            return;
          const f = Hi(m);
          if (a.type.isTextblock) {
            const { defaultType: _ } = d.parent.contentMatchAt(d.index());
            e.setNodeMarkup(m.start, _);
          }
          (f || f === 0) && e.lift(m, f);
        });
      }), true;
    }, zb = (t2) => (e) => t2(e), Fb = () => ({ state: t2, dispatch: e }) => Lf(t2, e), Hb = (t2, e) => ({ editor: n, tr: o }) => {
      const { state: i } = n, s = i.doc.slice(t2.from, t2.to);
      o.deleteRange(t2.from, t2.to);
      const r = o.mapping.map(e);
      return o.insert(r, s.content), o.setSelection(new re(o.doc.resolve(r - 1))), true;
    }, Ub = () => ({ tr: t2, dispatch: e }) => {
      const { selection: n } = t2, o = n.$anchor.node();
      if (o.content.size > 0)
        return false;
      const i = t2.selection.$anchor;
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o.type) {
          if (e) {
            const a = i.before(s), l = i.after(s);
            t2.delete(a, l).scrollIntoView();
          }
          return true;
        }
      return false;
    }, Vb = (t2) => ({ tr: e, state: n, dispatch: o }) => {
      const i = Tt(t2, n.schema), s = e.selection.$anchor;
      for (let r = s.depth; r > 0; r -= 1)
        if (s.node(r).type === i) {
          if (o) {
            const l = s.before(r), c2 = s.after(r);
            e.delete(l, c2).scrollIntoView();
          }
          return true;
        }
      return false;
    }, qb = (t2) => ({ tr: e, dispatch: n }) => {
      const { from: o, to: i } = t2;
      return n && e.delete(o, i), true;
    }, Kb = () => ({ state: t2, dispatch: e }) => Fc(t2, e), Wb = () => ({ commands: t2 }) => t2.keyboardShortcut("Enter"), Gb = () => ({ state: t2, dispatch: e }) => rb(t2, e);
    function qr(t2, e, n = { strict: true }) {
      const o = Object.keys(e);
      return o.length ? o.every((i) => n.strict ? e[i] === t2[i] : Wc(e[i]) ? e[i].test(t2[i]) : e[i] === t2[i]) : true;
    }
    function Uf(t2, e, n = {}) {
      return t2.find((o) => o.type === e && qr(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(n).map((i) => [i, o.attrs[i]])),
        n
      ));
    }
    function Kd(t2, e, n = {}) {
      return !!Uf(t2, e, n);
    }
    function Ui(t2, e, n) {
      var o;
      if (!t2 || !e)
        return;
      let i = t2.parent.childAfter(t2.parentOffset);
      if ((!i.node || !i.node.marks.some((u) => u.type === e)) && (i = t2.parent.childBefore(t2.parentOffset)), !i.node || !i.node.marks.some((u) => u.type === e) || (n = n || ((o = i.node.marks[0]) === null || o === void 0 ? void 0 : o.attrs), !Uf([...i.node.marks], e, n)))
        return;
      let r = i.index, a = t2.start() + i.offset, l = r + 1, c2 = a + i.node.nodeSize;
      for (; r > 0 && Kd([...t2.parent.child(r - 1).marks], e, n); )
        r -= 1, a -= t2.parent.child(r).nodeSize;
      for (; l < t2.parent.childCount && Kd([...t2.parent.child(l).marks], e, n); )
        c2 += t2.parent.child(l).nodeSize, l += 1;
      return {
        from: a,
        to: c2
      };
    }
    function Fo(t2, e) {
      if (typeof t2 == "string") {
        if (!e.marks[t2])
          throw Error(`There is no mark type named '${t2}'. Maybe you forgot to add the extension?`);
        return e.marks[t2];
      }
      return t2;
    }
    const Jb = (t2, e = {}) => ({ tr: n, state: o, dispatch: i }) => {
      const s = Fo(t2, o.schema), { doc: r, selection: a } = n, { $from: l, from: c2, to: u } = a;
      if (i) {
        const d = Ui(l, s, e);
        if (d && d.from <= c2 && d.to >= u) {
          const p2 = re.create(r, d.from, d.to);
          n.setSelection(p2);
        }
      }
      return true;
    }, Yb = (t2) => (e) => {
      const n = typeof t2 == "function" ? t2(e) : t2;
      for (let o = 0; o < n.length; o += 1)
        if (n[o](e))
          return true;
      return false;
    };
    function $a(t2) {
      return t2 instanceof re;
    }
    function co(t2 = 0, e = 0, n = 0) {
      return Math.min(Math.max(t2, e), n);
    }
    function Vf(t2, e = null) {
      if (!e)
        return null;
      const n = de.atStart(t2), o = de.atEnd(t2);
      if (e === "start" || e === true)
        return n;
      if (e === "end")
        return o;
      const i = n.from, s = o.to;
      return e === "all" ? re.create(t2, co(0, i, s), co(t2.content.size, i, s)) : re.create(t2, co(e, i, s), co(e, i, s));
    }
    function qf() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function za() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    const Xb = (t2 = null, e = {}) => ({ editor: n, view: o, tr: i, dispatch: s }) => {
      e = {
        scrollIntoView: true,
        ...e
      };
      const r = () => {
        (za() || qf()) && o.dom.focus(), requestAnimationFrame(() => {
          n.isDestroyed || (o.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
        });
      };
      if (o.hasFocus() && t2 === null || t2 === false)
        return true;
      if (s && t2 === null && !$a(n.state.selection))
        return r(), true;
      const a = Vf(i.doc, t2) || n.state.selection, l = n.state.selection.eq(a);
      return s && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), r()), true;
    }, Zb = (t2, e) => (n) => t2.every((o, i) => e(o, { ...n, index: i })), Qb = (t2, e) => ({ tr: n, commands: o }) => o.insertContentAt({ from: n.selection.from, to: n.selection.to }, t2, e), Kf = (t2) => {
      const e = t2.childNodes;
      for (let n = e.length - 1; n >= 0; n -= 1) {
        const o = e[n];
        o.nodeType === 3 && o.nodeValue && /^(\n\s\s|\n)$/.test(o.nodeValue) ? t2.removeChild(o) : o.nodeType === 1 && Kf(o);
      }
      return t2;
    };
    function ir(t2) {
      const e = `<body>${t2}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
      return Kf(n);
    }
    function Kr(t2, e, n) {
      if (t2 instanceof Mo || t2 instanceof D)
        return t2;
      n = {
        slice: true,
        parseOptions: {},
        ...n
      };
      const o = typeof t2 == "object" && t2 !== null, i = typeof t2 == "string";
      if (o)
        try {
          if (Array.isArray(t2) && t2.length > 0)
            return D.fromArray(t2.map((a) => e.nodeFromJSON(a)));
          const r = e.nodeFromJSON(t2);
          return n.errorOnInvalidContent && r.check(), r;
        } catch (s) {
          if (n.errorOnInvalidContent)
            throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
          return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t2, "Error:", s), Kr("", e, n);
        }
      if (i) {
        if (n.errorOnInvalidContent) {
          let r = false, a = "";
          const l = new Om({
            topNode: e.spec.topNode,
            marks: e.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: e.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (c2) => (r = true, a = typeof c2 == "string" ? c2 : c2.outerHTML, null)
                  }
                ]
              }
            })
          });
          if (n.slice ? as.fromSchema(l).parseSlice(ir(t2), n.parseOptions) : as.fromSchema(l).parse(ir(t2), n.parseOptions), n.errorOnInvalidContent && r)
            throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
        }
        const s = as.fromSchema(e);
        return n.slice ? s.parseSlice(ir(t2), n.parseOptions).content : s.parse(ir(t2), n.parseOptions);
      }
      return Kr("", e, n);
    }
    function ek(t2, e, n) {
      const o = t2.steps.length - 1;
      if (o < e)
        return;
      const i = t2.steps[o];
      if (!(i instanceof Et || i instanceof Ct))
        return;
      const s = t2.mapping.maps[o];
      let r = 0;
      s.forEach((a, l, c2, u) => {
        r === 0 && (r = u);
      }), t2.setSelection(de.near(t2.doc.resolve(r), n));
    }
    const tk = (t2) => !("type" in t2), nk = (t2, e, n) => ({ tr: o, dispatch: i, editor: s }) => {
      var r;
      if (i) {
        n = {
          parseOptions: s.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false,
          ...n
        };
        let a;
        try {
          a = Kr(e, s.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...n.parseOptions
            },
            errorOnInvalidContent: (r = n.errorOnInvalidContent) !== null && r !== void 0 ? r : s.options.enableContentCheck
          });
        } catch (f) {
          return s.emit("contentError", {
            editor: s,
            error: f,
            disableCollaboration: () => {
              s.storage.collaboration && (s.storage.collaboration.isDisabled = true);
            }
          }), false;
        }
        let { from: l, to: c2 } = typeof t2 == "number" ? { from: t2, to: t2 } : { from: t2.from, to: t2.to }, u = true, d = true;
        if ((tk(a) ? a : [a]).forEach((f) => {
          f.check(), u = u ? f.isText && f.marks.length === 0 : false, d = d ? f.isBlock : false;
        }), l === c2 && d) {
          const { parent: f } = o.doc.resolve(l);
          f.isTextblock && !f.type.spec.code && !f.childCount && (l -= 1, c2 += 1);
        }
        let m;
        if (u) {
          if (Array.isArray(e))
            m = e.map((f) => f.text || "").join("");
          else if (e instanceof D) {
            let f = "";
            e.forEach((_) => {
              _.text && (f += _.text);
            }), m = f;
          } else typeof e == "object" && e && e.text ? m = e.text : m = e;
          o.insertText(m, l, c2);
        } else
          m = a, o.replaceWith(l, c2, m);
        n.updateSelection && ek(o, o.steps.length - 1, -1), n.applyInputRules && o.setMeta("applyInputRules", { from: l, text: m }), n.applyPasteRules && o.setMeta("applyPasteRules", { from: l, text: m });
      }
      return true;
    }, ok = () => ({ state: t2, dispatch: e }) => ob(t2, e), ik = () => ({ state: t2, dispatch: e }) => ib(t2, e), sk = () => ({ state: t2, dispatch: e }) => Of(t2, e), rk = () => ({ state: t2, dispatch: e }) => Rf(t2, e), ak = () => ({ state: t2, dispatch: e, tr: n }) => {
      try {
        const o = Oa(t2.doc, t2.selection.$from.pos, -1);
        return o == null ? false : (n.join(o, 2), e && e(n), true);
      } catch {
        return false;
      }
    }, lk = () => ({ state: t2, dispatch: e, tr: n }) => {
      try {
        const o = Oa(t2.doc, t2.selection.$from.pos, 1);
        return o == null ? false : (n.join(o, 2), e && e(n), true);
      } catch {
        return false;
      }
    }, ck = () => ({ state: t2, dispatch: e }) => tb(t2, e), uk = () => ({ state: t2, dispatch: e }) => nb(t2, e);
    function Wf() {
      return typeof navigator < "u" ? /Mac/.test(navigator.platform) : false;
    }
    function dk(t2) {
      const e = t2.split(/-(?!$)/);
      let n = e[e.length - 1];
      n === "Space" && (n = " ");
      let o, i, s, r;
      for (let a = 0; a < e.length - 1; a += 1) {
        const l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          r = true;
        else if (/^a(lt)?$/i.test(l))
          o = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          i = true;
        else if (/^s(hift)?$/i.test(l))
          s = true;
        else if (/^mod$/i.test(l))
          za() || Wf() ? r = true : i = true;
        else
          throw new Error(`Unrecognized modifier name: ${l}`);
      }
      return o && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), r && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n;
    }
    const pk = (t2) => ({ editor: e, view: n, tr: o, dispatch: i }) => {
      const s = dk(t2).split(/-(?!$)/), r = s.find((c2) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c2)), a = new KeyboardEvent("keydown", {
        key: r === "Space" ? " " : r,
        altKey: s.includes("Alt"),
        ctrlKey: s.includes("Ctrl"),
        metaKey: s.includes("Meta"),
        shiftKey: s.includes("Shift"),
        bubbles: true,
        cancelable: true
      }), l = e.captureTransaction(() => {
        n.someProp("handleKeyDown", (c2) => c2(n, a));
      });
      return l == null || l.steps.forEach((c2) => {
        const u = c2.map(o.mapping);
        u && i && o.maybeStep(u);
      }), true;
    };
    function xs(t2, e, n = {}) {
      const { from: o, to: i, empty: s } = t2.selection, r = e ? Tt(e, t2.schema) : null, a = [];
      t2.doc.nodesBetween(o, i, (d, p2) => {
        if (d.isText)
          return;
        const m = Math.max(o, p2), f = Math.min(i, p2 + d.nodeSize);
        a.push({
          node: d,
          from: m,
          to: f
        });
      });
      const l = i - o, c2 = a.filter((d) => r ? r.name === d.node.type.name : true).filter((d) => qr(d.node.attrs, n, { strict: false }));
      return s ? !!c2.length : c2.reduce((d, p2) => d + p2.to - p2.from, 0) >= l;
    }
    const mk = (t2, e = {}) => ({ state: n, dispatch: o }) => {
      const i = Tt(t2, n.schema);
      return xs(n, i, e) ? sb(n, o) : false;
    }, fk = () => ({ state: t2, dispatch: e }) => Pf(t2, e), _k = (t2) => ({ state: e, dispatch: n }) => {
      const o = Tt(t2, e.schema);
      return gb(o)(e, n);
    }, hk = () => ({ state: t2, dispatch: e }) => Df(t2, e);
    function Fa(t2, e) {
      return e.nodes[t2] ? "node" : e.marks[t2] ? "mark" : null;
    }
    function Wd(t2, e) {
      const n = typeof e == "string" ? [e] : e;
      return Object.keys(t2).reduce((o, i) => (n.includes(i) || (o[i] = t2[i]), o), {});
    }
    const gk = (t2, e) => ({ tr: n, state: o, dispatch: i }) => {
      let s = null, r = null;
      const a = Fa(typeof t2 == "string" ? t2 : t2.name, o.schema);
      return a ? (a === "node" && (s = Tt(t2, o.schema)), a === "mark" && (r = Fo(t2, o.schema)), i && n.selection.ranges.forEach((l) => {
        o.doc.nodesBetween(l.$from.pos, l.$to.pos, (c2, u) => {
          s && s === c2.type && n.setNodeMarkup(u, void 0, Wd(c2.attrs, e)), r && c2.marks.length && c2.marks.forEach((d) => {
            r === d.type && n.addMark(u, u + c2.nodeSize, r.create(Wd(d.attrs, e)));
          });
        });
      }), true) : false;
    }, vk = () => ({ tr: t2, dispatch: e }) => (e && t2.scrollIntoView(), true), bk = () => ({ tr: t2, dispatch: e }) => {
      if (e) {
        const n = new pn(t2.doc);
        t2.setSelection(n);
      }
      return true;
    }, kk = () => ({ state: t2, dispatch: e }) => Af(t2, e), yk = () => ({ state: t2, dispatch: e }) => If(t2, e), wk = () => ({ state: t2, dispatch: e }) => cb(t2, e), jk = () => ({ state: t2, dispatch: e }) => pb(t2, e), Ek = () => ({ state: t2, dispatch: e }) => db(t2, e);
    function nc(t2, e, n = {}, o = {}) {
      return Kr(t2, e, {
        slice: false,
        parseOptions: n,
        errorOnInvalidContent: o.errorOnInvalidContent
      });
    }
    const Sk = (t2, e = false, n = {}, o = {}) => ({ editor: i, tr: s, dispatch: r, commands: a }) => {
      var l, c2;
      const { doc: u } = s;
      if (n.preserveWhitespace !== "full") {
        const d = nc(t2, i.schema, n, {
          errorOnInvalidContent: (l = o.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
        });
        return r && s.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), true;
      }
      return r && s.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t2, {
        parseOptions: n,
        errorOnInvalidContent: (c2 = o.errorOnInvalidContent) !== null && c2 !== void 0 ? c2 : i.options.enableContentCheck
      });
    };
    function Gf(t2, e) {
      const n = Fo(e, t2.schema), { from: o, to: i, empty: s } = t2.selection, r = [];
      s ? (t2.storedMarks && r.push(...t2.storedMarks), r.push(...t2.selection.$head.marks())) : t2.doc.nodesBetween(o, i, (l) => {
        r.push(...l.marks);
      });
      const a = r.find((l) => l.type.name === n.name);
      return a ? { ...a.attrs } : {};
    }
    function Ck(t2, e) {
      const n = new Oc(t2);
      return e.forEach((o) => {
        o.steps.forEach((i) => {
          n.step(i);
        });
      }), n;
    }
    function xk(t2) {
      for (let e = 0; e < t2.edgeCount; e += 1) {
        const { type: n } = t2.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
          return n;
      }
      return null;
    }
    function oc(t2, e) {
      const n = [];
      return t2.descendants((o, i) => {
        e(o) && n.push({
          node: o,
          pos: i
        });
      }), n;
    }
    function Tk(t2, e, n) {
      const o = [];
      return t2.nodesBetween(e.from, e.to, (i, s) => {
        n(i) && o.push({
          node: i,
          pos: s
        });
      }), o;
    }
    function Jf(t2, e) {
      for (let n = t2.depth; n > 0; n -= 1) {
        const o = t2.node(n);
        if (e(o))
          return {
            pos: n > 0 ? t2.before(n) : 0,
            start: t2.start(n),
            depth: n,
            node: o
          };
      }
    }
    function Jc(t2) {
      return (e) => Jf(e.$from, t2);
    }
    function Yf(t2, e) {
      const n = {
        from: 0,
        to: t2.content.size
      };
      return Hf(t2, n, e);
    }
    function Ok(t2, e) {
      const n = Tt(e, t2.schema), { from: o, to: i } = t2.selection, s = [];
      t2.doc.nodesBetween(o, i, (a) => {
        s.push(a);
      });
      const r = s.reverse().find((a) => a.type.name === n.name);
      return r ? { ...r.attrs } : {};
    }
    function Xf(t2, e) {
      const n = Fa(typeof e == "string" ? e : e.name, t2.schema);
      return n === "node" ? Ok(t2, e) : n === "mark" ? Gf(t2, e) : {};
    }
    function Nk(t2, e = JSON.stringify) {
      const n = {};
      return t2.filter((o) => {
        const i = e(o);
        return Object.prototype.hasOwnProperty.call(n, i) ? false : n[i] = true;
      });
    }
    function Ak(t2) {
      const e = Nk(t2);
      return e.length === 1 ? e : e.filter((n, o) => !e.filter((s, r) => r !== o).some((s) => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to));
    }
    function Mk(t2) {
      const { mapping: e, steps: n } = t2, o = [];
      return e.maps.forEach((i, s) => {
        const r = [];
        if (i.ranges.length)
          i.forEach((a, l) => {
            r.push({ from: a, to: l });
          });
        else {
          const { from: a, to: l } = n[s];
          if (a === void 0 || l === void 0)
            return;
          r.push({ from: a, to: l });
        }
        r.forEach(({ from: a, to: l }) => {
          const c2 = e.slice(s).map(a, -1), u = e.slice(s).map(l), d = e.invert().map(c2, -1), p2 = e.invert().map(u);
          o.push({
            oldRange: {
              from: d,
              to: p2
            },
            newRange: {
              from: c2,
              to: u
            }
          });
        });
      }), Ak(o);
    }
    function Yc(t2, e, n) {
      const o = [];
      return t2 === e ? n.resolve(t2).marks().forEach((i) => {
        const s = n.resolve(t2), r = Ui(s, i.type);
        r && o.push({
          mark: i,
          ...r
        });
      }) : n.nodesBetween(t2, e, (i, s) => {
        !i || (i == null ? void 0 : i.nodeSize) === void 0 || o.push(...i.marks.map((r) => ({
          from: s,
          to: s + i.nodeSize,
          mark: r
        })));
      }), o;
    }
    function Cr(t2, e, n) {
      return Object.fromEntries(Object.entries(n).filter(([o]) => {
        const i = t2.find((s) => s.type === e && s.name === o);
        return i ? i.attribute.keepOnSplit : false;
      }));
    }
    function ic(t2, e, n = {}) {
      const { empty: o, ranges: i } = t2.selection, s = e ? Fo(e, t2.schema) : null;
      if (o)
        return !!(t2.storedMarks || t2.selection.$from.marks()).filter((d) => s ? s.name === d.type.name : true).find((d) => qr(d.attrs, n, { strict: false }));
      let r = 0;
      const a = [];
      if (i.forEach(({ $from: d, $to: p2 }) => {
        const m = d.pos, f = p2.pos;
        t2.doc.nodesBetween(m, f, (_, h2) => {
          if (!_.isText && !_.marks.length)
            return;
          const g = Math.max(m, h2), k = Math.min(f, h2 + _.nodeSize), j = k - g;
          r += j, a.push(..._.marks.map((v) => ({
            mark: v,
            from: g,
            to: k
          })));
        });
      }), r === 0)
        return false;
      const l = a.filter((d) => s ? s.name === d.mark.type.name : true).filter((d) => qr(d.mark.attrs, n, { strict: false })).reduce((d, p2) => d + p2.to - p2.from, 0), c2 = a.filter((d) => s ? d.mark.type !== s && d.mark.type.excludes(s) : true).reduce((d, p2) => d + p2.to - p2.from, 0);
      return (l > 0 ? l + c2 : l) >= r;
    }
    function Rk(t2, e, n = {}) {
      if (!e)
        return xs(t2, null, n) || ic(t2, null, n);
      const o = Fa(e, t2.schema);
      return o === "node" ? xs(t2, e, n) : o === "mark" ? ic(t2, e, n) : false;
    }
    function Gd(t2, e) {
      const { nodeExtensions: n } = Pa(e), o = n.find((r) => r.name === t2);
      if (!o)
        return false;
      const i = {
        name: o.name,
        options: o.options,
        storage: o.storage
      }, s = Te(Z(o, "group", i));
      return typeof s != "string" ? false : s.split(" ").includes("list");
    }
    function Xc(t2, { checkChildren: e = true, ignoreWhitespace: n = false } = {}) {
      var o;
      if (n) {
        if (t2.type.name === "hardBreak")
          return true;
        if (t2.isText)
          return /^\s*$/m.test((o = t2.text) !== null && o !== void 0 ? o : "");
      }
      if (t2.isText)
        return !t2.text;
      if (t2.isAtom || t2.isLeaf)
        return false;
      if (t2.content.childCount === 0)
        return true;
      if (e) {
        let i = true;
        return t2.content.forEach((s) => {
          i !== false && (Xc(s, { ignoreWhitespace: n, checkChildren: e }) || (i = false));
        }), i;
      }
      return false;
    }
    function Zf(t2) {
      return t2 instanceof ie;
    }
    function Qf(t2, e, n) {
      const i = t2.state.doc.content.size, s = co(e, 0, i), r = co(n, 0, i), a = t2.coordsAtPos(s), l = t2.coordsAtPos(r, -1), c2 = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), p2 = Math.max(a.right, l.right), m = p2 - d, f = u - c2, g = {
        top: c2,
        bottom: u,
        left: d,
        right: p2,
        width: m,
        height: f,
        x: d,
        y: c2
      };
      return {
        ...g,
        toJSON: () => g
      };
    }
    function Ik(t2, e, n) {
      var o;
      const { selection: i } = e;
      let s = null;
      if ($a(i) && (s = i.$cursor), s) {
        const a = (o = t2.storedMarks) !== null && o !== void 0 ? o : s.marks();
        return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
      }
      const { ranges: r } = i;
      return r.some(({ $from: a, $to: l }) => {
        let c2 = a.depth === 0 ? t2.doc.inlineContent && t2.doc.type.allowsMarkType(n) : false;
        return t2.doc.nodesBetween(a.pos, l.pos, (u, d, p2) => {
          if (c2)
            return false;
          if (u.isInline) {
            const m = !p2 || p2.type.allowsMarkType(n), f = !!n.isInSet(u.marks) || !u.marks.some((_) => _.type.excludes(n));
            c2 = m && f;
          }
          return !c2;
        }), c2;
      });
    }
    const Dk = (t2, e = {}) => ({ tr: n, state: o, dispatch: i }) => {
      const { selection: s } = n, { empty: r, ranges: a } = s, l = Fo(t2, o.schema);
      if (i)
        if (r) {
          const c2 = Gf(o, l);
          n.addStoredMark(l.create({
            ...c2,
            ...e
          }));
        } else
          a.forEach((c2) => {
            const u = c2.$from.pos, d = c2.$to.pos;
            o.doc.nodesBetween(u, d, (p2, m) => {
              const f = Math.max(m, u), _ = Math.min(m + p2.nodeSize, d);
              p2.marks.find((g) => g.type === l) ? p2.marks.forEach((g) => {
                l === g.type && n.addMark(f, _, l.create({
                  ...g.attrs,
                  ...e
                }));
              }) : n.addMark(f, _, l.create(e));
            });
          });
      return Ik(o, n, l);
    }, Lk = (t2, e) => ({ tr: n }) => (n.setMeta(t2, e), true), Pk = (t2, e = {}) => ({ state: n, dispatch: o, chain: i }) => {
      const s = Tt(t2, n.schema);
      let r;
      return n.selection.$anchor.sameParent(n.selection.$head) && (r = n.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: a }) => Hd(s, { ...r, ...e })(n) ? true : a.clearNodes()).command(({ state: a }) => Hd(s, { ...r, ...e })(a, o)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), false);
    }, Bk = (t2) => ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: o } = e, i = co(t2, 0, o.content.size), s = ie.create(o, i);
        e.setSelection(s);
      }
      return true;
    }, $k = (t2) => ({ tr: e, dispatch: n }) => {
      if (n) {
        const { doc: o } = e, { from: i, to: s } = typeof t2 == "number" ? { from: t2, to: t2 } : t2, r = re.atStart(o).from, a = re.atEnd(o).to, l = co(i, r, a), c2 = co(s, r, a), u = re.create(o, l, c2);
        e.setSelection(u);
      }
      return true;
    }, zk = (t2) => ({ state: e, dispatch: n }) => {
      const o = Tt(t2, e.schema);
      return kb(o)(e, n);
    };
    function Jd(t2, e) {
      const n = t2.storedMarks || t2.selection.$to.parentOffset && t2.selection.$from.marks();
      if (n) {
        const o = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
        t2.tr.ensureMarks(o);
      }
    }
    const Fk = ({ keepMarks: t2 = true } = {}) => ({ tr: e, state: n, dispatch: o, editor: i }) => {
      const { selection: s, doc: r } = e, { $from: a, $to: l } = s, c2 = i.extensionManager.attributes, u = Cr(c2, a.node().type.name, a.node().attrs);
      if (s instanceof ie && s.node.isBlock)
        return !a.parentOffset || !uo(r, a.pos) ? false : (o && (t2 && Jd(n, i.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), true);
      if (!a.parent.isBlock)
        return false;
      const d = l.parentOffset === l.parent.content.size, p2 = a.depth === 0 ? void 0 : xk(a.node(-1).contentMatchAt(a.indexAfter(-1)));
      let m = d && p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0, f = uo(e.doc, e.mapping.map(a.pos), 1, m);
      if (!m && !f && uo(e.doc, e.mapping.map(a.pos), 1, p2 ? [{ type: p2 }] : void 0) && (f = true, m = p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0), o) {
        if (f && (s instanceof re && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, m), p2 && !d && !a.parentOffset && a.parent.type !== p2)) {
          const _ = e.mapping.map(a.before()), h2 = e.doc.resolve(_);
          a.node(-1).canReplaceWith(h2.index(), h2.index() + 1, p2) && e.setNodeMarkup(e.mapping.map(a.before()), p2);
        }
        t2 && Jd(n, i.extensionManager.splittableMarks), e.scrollIntoView();
      }
      return f;
    }, Hk = (t2, e = {}) => ({ tr: n, state: o, dispatch: i, editor: s }) => {
      var r;
      const a = Tt(t2, o.schema), { $from: l, $to: c2 } = o.selection, u = o.selection.node;
      if (u && u.isBlock || l.depth < 2 || !l.sameParent(c2))
        return false;
      const d = l.node(-1);
      if (d.type !== a)
        return false;
      const p2 = s.extensionManager.attributes;
      if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
        if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
          return false;
        if (i) {
          let g = D.empty;
          const k = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
          for (let U = l.depth - k; U >= l.depth - 3; U -= 1)
            g = D.from(l.node(U).copy(g));
          const j = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
            ...Cr(p2, l.node().type.name, l.node().attrs),
            ...e
          }, C = ((r = a.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.createAndFill(v)) || void 0;
          g = g.append(D.from(a.createAndFill(null, C) || void 0));
          const E = l.before(l.depth - (k - 1));
          n.replace(E, l.after(-j), new K(g, 4 - k, 0));
          let B = -1;
          n.doc.nodesBetween(E, n.doc.content.size, (U, P) => {
            if (B > -1)
              return false;
            U.isTextblock && U.content.size === 0 && (B = P + 1);
          }), B > -1 && n.setSelection(re.near(n.doc.resolve(B))), n.scrollIntoView();
        }
        return true;
      }
      const m = c2.pos === l.end() ? d.contentMatchAt(0).defaultType : null, f = {
        ...Cr(p2, d.type.name, d.attrs),
        ...e
      }, _ = {
        ...Cr(p2, l.node().type.name, l.node().attrs),
        ...e
      };
      n.delete(l.pos, c2.pos);
      const h2 = m ? [
        { type: a, attrs: f },
        { type: m, attrs: _ }
      ] : [{ type: a, attrs: f }];
      if (!uo(n.doc, l.pos, 2))
        return false;
      if (i) {
        const { selection: g, storedMarks: k } = o, { splittableMarks: j } = s.extensionManager, v = k || g.$to.parentOffset && g.$from.marks();
        if (n.split(l.pos, 2, h2).scrollIntoView(), !v || !i)
          return true;
        const C = v.filter((E) => j.includes(E.type.name));
        n.ensureMarks(C);
      }
      return true;
    }, gl = (t2, e) => {
      const n = Jc((r) => r.type === e)(t2.selection);
      if (!n)
        return true;
      const o = t2.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
      if (o === void 0)
        return true;
      const i = t2.doc.nodeAt(o);
      return n.node.type === (i == null ? void 0 : i.type) && $o(t2.doc, n.pos) && t2.join(n.pos), true;
    }, vl = (t2, e) => {
      const n = Jc((r) => r.type === e)(t2.selection);
      if (!n)
        return true;
      const o = t2.doc.resolve(n.start).after(n.depth);
      if (o === void 0)
        return true;
      const i = t2.doc.nodeAt(o);
      return n.node.type === (i == null ? void 0 : i.type) && $o(t2.doc, o) && t2.join(o), true;
    }, Uk = (t2, e, n, o = {}) => ({ editor: i, tr: s, state: r, dispatch: a, chain: l, commands: c2, can: u }) => {
      const { extensions: d, splittableMarks: p2 } = i.extensionManager, m = Tt(t2, r.schema), f = Tt(e, r.schema), { selection: _, storedMarks: h2 } = r, { $from: g, $to: k } = _, j = g.blockRange(k), v = h2 || _.$to.parentOffset && _.$from.marks();
      if (!j)
        return false;
      const C = Jc((E) => Gd(E.type.name, d))(_);
      if (j.depth >= 1 && C && j.depth - C.depth <= 1) {
        if (C.node.type === m)
          return c2.liftListItem(f);
        if (Gd(C.node.type.name, d) && m.validContent(C.node.content) && a)
          return l().command(() => (s.setNodeMarkup(C.pos, m), true)).command(() => gl(s, m)).command(() => vl(s, m)).run();
      }
      return !n || !v || !a ? l().command(() => u().wrapInList(m, o) ? true : c2.clearNodes()).wrapInList(m, o).command(() => gl(s, m)).command(() => vl(s, m)).run() : l().command(() => {
        const E = u().wrapInList(m, o), B = v.filter((U) => p2.includes(U.type.name));
        return s.ensureMarks(B), E ? true : c2.clearNodes();
      }).wrapInList(m, o).command(() => gl(s, m)).command(() => vl(s, m)).run();
    }, Vk = (t2, e = {}, n = {}) => ({ state: o, commands: i }) => {
      const { extendEmptyMarkRange: s = false } = n, r = Fo(t2, o.schema);
      return ic(o, r, e) ? i.unsetMark(r, { extendEmptyMarkRange: s }) : i.setMark(r, e);
    }, qk = (t2, e, n = {}) => ({ state: o, commands: i }) => {
      const s = Tt(t2, o.schema), r = Tt(e, o.schema), a = xs(o, s, n);
      let l;
      return o.selection.$anchor.sameParent(o.selection.$head) && (l = o.selection.$anchor.parent.attrs), a ? i.setNode(r, l) : i.setNode(s, { ...l, ...n });
    }, Kk = (t2, e = {}) => ({ state: n, commands: o }) => {
      const i = Tt(t2, n.schema);
      return xs(n, i, e) ? o.lift(i) : o.wrapIn(i, e);
    }, Wk = () => ({ state: t2, dispatch: e }) => {
      const n = t2.plugins;
      for (let o = 0; o < n.length; o += 1) {
        const i = n[o];
        let s;
        if (i.spec.isInputRules && (s = i.getState(t2))) {
          if (e) {
            const r = t2.tr, a = s.transform;
            for (let l = a.steps.length - 1; l >= 0; l -= 1)
              r.step(a.steps[l].invert(a.docs[l]));
            if (s.text) {
              const l = r.doc.resolve(s.from).marks();
              r.replaceWith(s.from, s.to, t2.schema.text(s.text, l));
            } else
              r.delete(s.from, s.to);
          }
          return true;
        }
      }
      return false;
    }, Gk = () => ({ tr: t2, dispatch: e }) => {
      const { selection: n } = t2, { empty: o, ranges: i } = n;
      return o || e && i.forEach((s) => {
        t2.removeMark(s.$from.pos, s.$to.pos);
      }), true;
    }, Jk = (t2, e = {}) => ({ tr: n, state: o, dispatch: i }) => {
      var s;
      const { extendEmptyMarkRange: r = false } = e, { selection: a } = n, l = Fo(t2, o.schema), { $from: c2, empty: u, ranges: d } = a;
      if (!i)
        return true;
      if (u && r) {
        let { from: p2, to: m } = a;
        const f = (s = c2.marks().find((h2) => h2.type === l)) === null || s === void 0 ? void 0 : s.attrs, _ = Ui(c2, l, f);
        _ && (p2 = _.from, m = _.to), n.removeMark(p2, m, l);
      } else
        d.forEach((p2) => {
          n.removeMark(p2.$from.pos, p2.$to.pos, l);
        });
      return n.removeStoredMark(l), true;
    }, Yk = (t2, e = {}) => ({ tr: n, state: o, dispatch: i }) => {
      let s = null, r = null;
      const a = Fa(typeof t2 == "string" ? t2 : t2.name, o.schema);
      return a ? (a === "node" && (s = Tt(t2, o.schema)), a === "mark" && (r = Fo(t2, o.schema)), i && n.selection.ranges.forEach((l) => {
        const c2 = l.$from.pos, u = l.$to.pos;
        let d, p2, m, f;
        n.selection.empty ? o.doc.nodesBetween(c2, u, (_, h2) => {
          s && s === _.type && (m = Math.max(h2, c2), f = Math.min(h2 + _.nodeSize, u), d = h2, p2 = _);
        }) : o.doc.nodesBetween(c2, u, (_, h2) => {
          h2 < c2 && s && s === _.type && (m = Math.max(h2, c2), f = Math.min(h2 + _.nodeSize, u), d = h2, p2 = _), h2 >= c2 && h2 <= u && (s && s === _.type && n.setNodeMarkup(h2, void 0, {
            ..._.attrs,
            ...e
          }), r && _.marks.length && _.marks.forEach((g) => {
            if (r === g.type) {
              const k = Math.max(h2, c2), j = Math.min(h2 + _.nodeSize, u);
              n.addMark(k, j, r.create({
                ...g.attrs,
                ...e
              }));
            }
          }));
        }), p2 && (d !== void 0 && n.setNodeMarkup(d, void 0, {
          ...p2.attrs,
          ...e
        }), r && p2.marks.length && p2.marks.forEach((_) => {
          r === _.type && n.addMark(m, f, r.create({
            ..._.attrs,
            ...e
          }));
        }));
      }), true) : false;
    }, Xk = (t2, e = {}) => ({ state: n, dispatch: o }) => {
      const i = Tt(t2, n.schema);
      return mb(i, e)(n, o);
    }, Zk = (t2, e = {}) => ({ state: n, dispatch: o }) => {
      const i = Tt(t2, n.schema);
      return fb(i, e)(n, o);
    };
    var Qk = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur: Pb,
      clearContent: Bb,
      clearNodes: $b,
      command: zb,
      createParagraphNear: Fb,
      cut: Hb,
      deleteCurrentNode: Ub,
      deleteNode: Vb,
      deleteRange: qb,
      deleteSelection: Kb,
      enter: Wb,
      exitCode: Gb,
      extendMarkRange: Jb,
      first: Yb,
      focus: Xb,
      forEach: Zb,
      insertContent: Qb,
      insertContentAt: nk,
      joinBackward: sk,
      joinDown: ik,
      joinForward: rk,
      joinItemBackward: ak,
      joinItemForward: lk,
      joinTextblockBackward: ck,
      joinTextblockForward: uk,
      joinUp: ok,
      keyboardShortcut: pk,
      lift: mk,
      liftEmptyBlock: fk,
      liftListItem: _k,
      newlineInCode: hk,
      resetAttributes: gk,
      scrollIntoView: vk,
      selectAll: bk,
      selectNodeBackward: kk,
      selectNodeForward: yk,
      selectParentNode: wk,
      selectTextblockEnd: jk,
      selectTextblockStart: Ek,
      setContent: Sk,
      setMark: Dk,
      setMeta: Lk,
      setNode: Pk,
      setNodeSelection: Bk,
      setTextSelection: $k,
      sinkListItem: zk,
      splitBlock: Fk,
      splitListItem: Hk,
      toggleList: Uk,
      toggleMark: Vk,
      toggleNode: qk,
      toggleWrap: Kk,
      undoInputRule: Wk,
      unsetAllMarks: Gk,
      unsetMark: Jk,
      updateAttributes: Yk,
      wrapIn: Xk,
      wrapInList: Zk
    });
    const ey = We.create({
      name: "commands",
      addCommands() {
        return {
          ...Qk
        };
      }
    }), ty = We.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("tiptapDrop"),
            props: {
              handleDrop: (t2, e, n, o) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice: n,
                  moved: o
                });
              }
            }
          })
        ];
      }
    }), ny = We.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    }), oy = We.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor: t2 } = this;
        return [
          new ze({
            key: new Fe("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (e, n) => {
                  t2.isFocused = true;
                  const o = t2.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", false);
                  return e.dispatch(o), false;
                },
                blur: (e, n) => {
                  t2.isFocused = false;
                  const o = t2.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", false);
                  return e.dispatch(o), false;
                }
              }
            }
          })
        ];
      }
    }), iy = We.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const t2 = () => this.editor.commands.first(({ commands: r }) => [
          () => r.undoInputRule(),
          // maybe convert first text block node to default node
          () => r.command(({ tr: a }) => {
            const { selection: l, doc: c2 } = a, { empty: u, $anchor: d } = l, { pos: p2, parent: m } = d, f = d.parent.isTextblock && p2 > 0 ? a.doc.resolve(p2 - 1) : d, _ = f.parent.type.spec.isolating, h2 = d.pos - d.parentOffset, g = _ && f.parent.childCount === 1 ? h2 === d.pos : de.atStart(c2).from === p2;
            return !u || !m.type.isTextblock || m.textContent.length || !g || g && d.parent.type.name === "paragraph" ? false : r.clearNodes();
          }),
          () => r.deleteSelection(),
          () => r.joinBackward(),
          () => r.selectNodeBackward()
        ]), e = () => this.editor.commands.first(({ commands: r }) => [
          () => r.deleteSelection(),
          () => r.deleteCurrentNode(),
          () => r.joinForward(),
          () => r.selectNodeForward()
        ]), o = {
          Enter: () => this.editor.commands.first(({ commands: r }) => [
            () => r.newlineInCode(),
            () => r.createParagraphNear(),
            () => r.liftEmptyBlock(),
            () => r.splitBlock()
          ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: t2,
          "Mod-Backspace": t2,
          "Shift-Backspace": t2,
          Delete: e,
          "Mod-Delete": e,
          "Mod-a": () => this.editor.commands.selectAll()
        }, i = {
          ...o
        }, s = {
          ...o,
          "Ctrl-h": t2,
          "Alt-Backspace": t2,
          "Ctrl-d": e,
          "Ctrl-Alt-Backspace": e,
          "Alt-Delete": e,
          "Alt-d": e,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return za() || Wf() ? s : i;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
          // with many other commands.
          new ze({
            key: new Fe("clearDocument"),
            appendTransaction: (t2, e, n) => {
              if (t2.some((_) => _.getMeta("composition")))
                return;
              const o = t2.some((_) => _.docChanged) && !e.doc.eq(n.doc), i = t2.some((_) => _.getMeta("preventClearDocument"));
              if (!o || i)
                return;
              const { empty: s, from: r, to: a } = e.selection, l = de.atStart(e.doc).from, c2 = de.atEnd(e.doc).to;
              if (s || !(r === l && a === c2) || !Xc(n.doc))
                return;
              const p2 = n.tr, m = Da({
                state: n,
                transaction: p2
              }), { commands: f } = new La({
                editor: this.editor,
                state: m
              });
              if (f.clearNodes(), !!p2.steps.length)
                return p2;
            }
          })
        ];
      }
    }), sy = We.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("tiptapPaste"),
            props: {
              handlePaste: (t2, e, n) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice: n
                });
              }
            }
          })
        ];
      }
    }), ry = We.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    class Go {
      get name() {
        return this.node.type.name;
      }
      constructor(e, n, o = false, i = null) {
        this.currentNode = null, this.actualDepth = null, this.isBlock = o, this.resolvedPos = e, this.editor = n, this.currentNode = i;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var e;
        return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(e) {
        let n = this.from, o = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          n = this.from + 1, o = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from: n, to: o }, e);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0)
          return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
        return new Go(n, this.editor);
      }
      get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Go(e, this.editor);
      }
      get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Go(e, this.editor);
      }
      get children() {
        const e = [];
        return this.node.content.forEach((n, o) => {
          const i = n.isBlock && !n.isTextblock, s = n.isAtom && !n.isText, r = this.pos + o + (s ? 0 : 1), a = this.resolvedPos.doc.resolve(r);
          if (!i && a.depth <= this.depth)
            return;
          const l = new Go(a, this.editor, i, i ? n : null);
          i && (l.actualDepth = this.depth + 1), e.push(new Go(a, this.editor, i, i ? n : null));
        }), e;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null;
      }
      closest(e, n = {}) {
        let o = null, i = this.parent;
        for (; i && !o; ) {
          if (i.node.type.name === e)
            if (Object.keys(n).length > 0) {
              const s = i.node.attrs, r = Object.keys(n);
              for (let a = 0; a < r.length; a += 1) {
                const l = r[a];
                if (s[l] !== n[l])
                  break;
              }
            } else
              o = i;
          i = i.parent;
        }
        return o;
      }
      querySelector(e, n = {}) {
        return this.querySelectorAll(e, n, true)[0] || null;
      }
      querySelectorAll(e, n = {}, o = false) {
        let i = [];
        if (!this.children || this.children.length === 0)
          return i;
        const s = Object.keys(n);
        return this.children.forEach((r) => {
          o && i.length > 0 || (r.node.type.name === e && s.every((l) => n[l] === r.node.attrs[l]) && i.push(r), !(o && i.length > 0) && (i = i.concat(r.querySelectorAll(e, n, o))));
        }), i;
      }
      setAttribute(e) {
        const { tr: n } = this.editor.state;
        n.setNodeMarkup(this.from, void 0, {
          ...this.node.attrs,
          ...e
        }), this.editor.view.dispatch(n);
      }
    }
    const ay = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    function ly(t2, e, n) {
      const o = document.querySelector("style[data-tiptap-style]");
      if (o !== null)
        return o;
      const i = document.createElement("style");
      return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = t2, document.getElementsByTagName("head")[0].appendChild(i), i;
    }
    let Tn = class extends yb {
      constructor(e = {}) {
        super(), this.isFocused = false, this.isInitialized = false, this.extensionStorage = {}, this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error: n }) => {
            throw n;
          },
          onPaste: () => null,
          onDrop: () => null
        }, this.isCapturingTransaction = false, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: o, moved: i }) => this.options.onDrop(n, o, i)), this.on("paste", ({ event: n, slice: o }) => this.options.onPaste(n, o)), window.setTimeout(() => {
          this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = true);
        }, 0);
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        this.options.injectCSS && document && (this.css = ly(ay, this.options.injectNonce));
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(e = {}) {
        this.options = {
          ...this.options,
          ...e
        }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(e, n = true) {
        this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
        return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(e, n) {
        const o = Ff(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: o });
        return this.view.updateState(i), i;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(e) {
        if (this.isDestroyed)
          return;
        const n = this.state.plugins;
        let o = n;
        if ([].concat(e).forEach((s) => {
          const r = typeof s == "string" ? `${s}$` : s.key;
          o = n.filter((a) => !a.key.startsWith(r));
        }), n.length === o.length)
          return;
        const i = this.state.reconfigure({
          plugins: o
        });
        return this.view.updateState(i), i;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var e, n;
        const i = [...this.options.enableCoreExtensions ? [
          ny,
          Lb.configure({
            blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
          }),
          ey,
          oy,
          iy,
          ry,
          ty,
          sy
        ].filter((s) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== false : true) : [], ...this.options.extensions].filter((s) => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
        this.extensionManager = new xi(i, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new La({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
        var e;
        let n;
        try {
          n = nc(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
        } catch (r) {
          if (!(r instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(r.message))
            throw r;
          this.emit("contentError", {
            editor: this,
            error: r,
            disableCollaboration: () => {
              this.storage.collaboration && (this.storage.collaboration.isDisabled = true), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
            }
          }), n = nc(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
        }
        const o = Vf(n, this.options.autofocus);
        this.view = new q0(this.options.element, {
          ...this.options.editorProps,
          attributes: {
            // add `role="textbox"` to the editor element
            role: "textbox",
            ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
          },
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: Ci.create({
            doc: n,
            selection: o || void 0
          })
        });
        const i = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(i), this.createNodeViews(), this.prependClass();
        const s = this.view.dom;
        s.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
        this.view.isDestroyed || this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
      }
      captureTransaction(e) {
        this.isCapturingTransaction = true, e(), this.isCapturingTransaction = false;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null, n;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(e) {
        if (this.view.isDestroyed)
          return;
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = e;
            return;
          }
          e.steps.forEach((r) => {
            var a;
            return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(r);
          });
          return;
        }
        const n = this.state.apply(e), o = !this.state.selection.eq(n.selection);
        this.emit("beforeTransaction", {
          editor: this,
          transaction: e,
          nextState: n
        }), this.view.updateState(n), this.emit("transaction", {
          editor: this,
          transaction: e
        }), o && this.emit("selectionUpdate", {
          editor: this,
          transaction: e
        });
        const i = e.getMeta("focus"), s = e.getMeta("blur");
        i && this.emit("focus", {
          editor: this,
          event: i.event,
          transaction: e
        }), s && this.emit("blur", {
          editor: this,
          event: s.event,
          transaction: e
        }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
          editor: this,
          transaction: e
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(e) {
        return Xf(this.state, e);
      }
      isActive(e, n) {
        const o = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
        return Rk(this.state, o, i);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return Kc(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(e) {
        const { blockSeparator: n = `

`, textSerializers: o = {} } = e || {};
        return Yf(this.state.doc, {
          blockSeparator: n,
          textSerializers: {
            ...Gc(this.schema),
            ...o
          }
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return Xc(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       *
       * @deprecated
       */
      getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        if (this.emit("destroy"), this.view) {
          const e = this.view.dom;
          e && e.editor && delete e.editor, this.view.destroy();
        }
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView);
      }
      $node(e, n) {
        var o;
        return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelector(e, n)) || null;
      }
      $nodes(e, n) {
        var o;
        return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelectorAll(e, n)) || null;
      }
      $pos(e) {
        const n = this.state.doc.resolve(e);
        return new Go(n, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    };
    function ci(t2) {
      return new Vs({
        find: t2.find,
        handler: ({ state: e, range: n, match: o }) => {
          const i = Te(t2.getAttributes, void 0, o);
          if (i === false || i === null)
            return null;
          const { tr: s } = e, r = o[o.length - 1], a = o[0];
          if (r) {
            const l = a.search(/\S/), c2 = n.from + a.indexOf(r), u = c2 + r.length;
            if (Yc(n.from, n.to, e.doc).filter((m) => m.mark.type.excluded.find((_) => _ === t2.type && _ !== m.mark.type)).filter((m) => m.to > c2).length)
              return null;
            u < n.to && s.delete(u, n.to), c2 > n.from && s.delete(n.from + l, c2);
            const p2 = n.from + l + r.length;
            s.addMark(n.from + l, p2, t2.type.create(i || {})), s.removeStoredMark(t2.type);
          }
        }
      });
    }
    function Ha(t2) {
      return new Vs({
        find: t2.find,
        handler: ({ state: e, range: n, match: o }) => {
          const i = Te(t2.getAttributes, void 0, o) || {}, { tr: s } = e, r = n.from;
          let a = n.to;
          const l = t2.type.create(i);
          if (o[1]) {
            const c2 = o[0].lastIndexOf(o[1]);
            let u = r + c2;
            u > a ? u = a : a = u + o[1].length;
            const d = o[0][o[0].length - 1];
            s.insertText(d, r + o[0].length - 1), s.replaceWith(u, a, l);
          } else if (o[0]) {
            const c2 = t2.type.isInline ? r : r - 1;
            s.insert(c2, t2.type.create(i)).delete(s.mapping.map(r), s.mapping.map(a));
          }
          s.scrollIntoView();
        }
      });
    }
    function sc(t2) {
      return new Vs({
        find: t2.find,
        handler: ({ state: e, range: n, match: o }) => {
          const i = e.doc.resolve(n.from), s = Te(t2.getAttributes, void 0, o) || {};
          if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t2.type))
            return null;
          e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t2.type, s);
        }
      });
    }
    function pt(t2) {
      return new Vs({
        find: t2.find,
        handler: ({ state: e, range: n, match: o }) => {
          let i = t2.replace, s = n.from;
          const r = n.to;
          if (o[1]) {
            const a = o[0].lastIndexOf(o[1]);
            i += o[0].slice(a + o[1].length), s += a;
            const l = s - r;
            l > 0 && (i = o[0].slice(a - l, a) + i, s = r);
          }
          e.tr.insertText(i, s, r);
        }
      });
    }
    function Di(t2) {
      return new Vs({
        find: t2.find,
        handler: ({ state: e, range: n, match: o, chain: i }) => {
          const s = Te(t2.getAttributes, void 0, o) || {}, r = e.tr.delete(n.from, n.to), l = r.doc.resolve(n.from).blockRange(), c2 = l && Tc(l, t2.type, s);
          if (!c2)
            return null;
          if (r.wrap(l, c2), t2.keepMarks && t2.editor) {
            const { selection: d, storedMarks: p2 } = e, { splittableMarks: m } = t2.editor.extensionManager, f = p2 || d.$to.parentOffset && d.$from.marks();
            if (f) {
              const _ = f.filter((h2) => m.includes(h2.type.name));
              r.ensureMarks(_);
            }
          }
          if (t2.keepAttributes) {
            const d = t2.type.name === "bulletList" || t2.type.name === "orderedList" ? "listItem" : "taskList";
            i().updateAttributes(d, s).run();
          }
          const u = r.doc.resolve(n.from - 1).nodeBefore;
          u && u.type === t2.type && $o(r.doc, n.from - 1) && (!t2.joinPredicate || t2.joinPredicate(o, u)) && r.join(n.from - 1);
        }
      });
    }
    class it {
      constructor(e = {}) {
        this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new it(e);
      }
      configure(e = {}) {
        const n = this.extend({
          ...this.config,
          addOptions: () => Ba(this.options, e)
        });
        return n.name = this.name, n.parent = this.parent, n;
      }
      extend(e = {}) {
        const n = new it(e);
        return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Te(Z(n, "addOptions", {
          name: n.name
        })), n.storage = Te(Z(n, "addStorage", {
          name: n.name,
          options: n.options
        })), n;
      }
    }
    class cy {
      constructor(e, n, o) {
        this.isDragging = false, this.component = e, this.editor = n.editor, this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...o
        }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
      }
      mount() {
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(e) {
        var n, o, i, s, r, a, l;
        const { view: c2 } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
        if (!this.dom || !((o = this.contentDOM) === null || o === void 0) && o.contains(u) || !d)
          return;
        let p2 = 0, m = 0;
        if (this.dom !== d) {
          const g = this.dom.getBoundingClientRect(), k = d.getBoundingClientRect(), j = (i = e.offsetX) !== null && i !== void 0 ? i : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetX, v = (r = e.offsetY) !== null && r !== void 0 ? r : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
          p2 = k.x - g.x + j, m = k.y - g.y + v;
        }
        (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, p2, m);
        const f = this.getPos();
        if (typeof f != "number")
          return;
        const _ = ie.create(c2.state.doc, f), h2 = c2.state.tr.setSelection(_);
        c2.dispatch(h2);
      }
      stopEvent(e) {
        var n;
        if (!this.dom)
          return false;
        if (typeof this.options.stopEvent == "function")
          return this.options.stopEvent({ event: e });
        const o = e.target;
        if (!(this.dom.contains(o) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(o))))
          return false;
        const s = e.type.startsWith("drag"), r = e.type === "drop";
        if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(o.tagName) || o.isContentEditable) && !r && !s)
          return true;
        const { isEditable: l } = this.editor, { isDragging: c2 } = this, u = !!this.node.type.spec.draggable, d = ie.isSelectable(this.node), p2 = e.type === "copy", m = e.type === "paste", f = e.type === "cut", _ = e.type === "mousedown";
        if (!u && d && s && e.target === this.dom && e.preventDefault(), u && s && !c2 && e.target === this.dom)
          return e.preventDefault(), false;
        if (u && l && !c2 && _) {
          const h2 = o.closest("[data-drag-handle]");
          h2 && (this.dom === h2 || this.dom.contains(h2)) && (this.isDragging = true, document.addEventListener("dragend", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("drop", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("mouseup", () => {
            this.isDragging = false;
          }, { once: true }));
        }
        return !(c2 || r || p2 || m || f || _ && d);
      }
      /**
       * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
       * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
       * @return `true` if it can safely be ignored.
       */
      ignoreMutation(e) {
        return !this.dom || !this.contentDOM ? true : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? true : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (za() || qf()) && this.editor.isFocused && [
          ...Array.from(e.addedNodes),
          ...Array.from(e.removedNodes)
        ].every((o) => o.isContentEditable) ? false : this.contentDOM === e.target && e.type === "attributes" ? true : !this.contentDOM.contains(e.target);
      }
      /**
       * Update the attributes of the prosemirror node.
       */
      updateAttributes(e) {
        this.editor.commands.command(({ tr: n }) => {
          const o = this.getPos();
          return typeof o != "number" ? false : (n.setNodeMarkup(o, void 0, {
            ...this.node.attrs,
            ...e
          }), true);
        });
      }
      /**
       * Delete the node.
       */
      deleteNode() {
        const e = this.getPos();
        if (typeof e != "number")
          return;
        const n = e + this.node.nodeSize;
        this.editor.commands.deleteRange({ from: e, to: n });
      }
    }
    function Bo(t2) {
      return new Nb({
        find: t2.find,
        handler: ({ state: e, range: n, match: o, pasteEvent: i }) => {
          const s = Te(t2.getAttributes, void 0, o, i);
          if (s === false || s === null)
            return null;
          const { tr: r } = e, a = o[o.length - 1], l = o[0];
          let c2 = n.to;
          if (a) {
            const u = l.search(/\S/), d = n.from + l.indexOf(a), p2 = d + a.length;
            if (Yc(n.from, n.to, e.doc).filter((f) => f.mark.type.excluded.find((h2) => h2 === t2.type && h2 !== f.mark.type)).filter((f) => f.to > d).length)
              return null;
            p2 < n.to && r.delete(p2, n.to), d > n.from && r.delete(n.from + u, d), c2 = n.from + u + a.length, r.addMark(n.from + u, c2, t2.type.create(s || {})), r.removeStoredMark(t2.type);
          }
        }
      });
    }
    function uy(t2) {
      return t2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tn = "top", En = "bottom", Sn = "right", nn = "left", Zc = "auto", qs = [tn, En, Sn, nn], Li = "start", Ts = "end", dy = "clippingParents", e_ = "viewport", Xi = "popper", py = "reference", Yd = /* @__PURE__ */ qs.reduce(function(t2, e) {
      return t2.concat([e + "-" + Li, e + "-" + Ts]);
    }, []), t_ = /* @__PURE__ */ [].concat(qs, [Zc]).reduce(function(t2, e) {
      return t2.concat([e, e + "-" + Li, e + "-" + Ts]);
    }, []), my = "beforeRead", fy = "read", _y = "afterRead", hy = "beforeMain", gy = "main", vy = "afterMain", by = "beforeWrite", ky = "write", yy = "afterWrite", wy = [my, fy, _y, hy, gy, vy, by, ky, yy];
    function Zn(t2) {
      return t2 ? (t2.nodeName || "").toLowerCase() : null;
    }
    function mn(t2) {
      if (t2 == null)
        return window;
      if (t2.toString() !== "[object Window]") {
        var e = t2.ownerDocument;
        return e && e.defaultView || window;
      }
      return t2;
    }
    function ui(t2) {
      var e = mn(t2).Element;
      return t2 instanceof e || t2 instanceof Element;
    }
    function wn(t2) {
      var e = mn(t2).HTMLElement;
      return t2 instanceof e || t2 instanceof HTMLElement;
    }
    function Qc(t2) {
      if (typeof ShadowRoot > "u")
        return false;
      var e = mn(t2).ShadowRoot;
      return t2 instanceof e || t2 instanceof ShadowRoot;
    }
    function jy(t2) {
      var e = t2.state;
      Object.keys(e.elements).forEach(function(n) {
        var o = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
        !wn(s) || !Zn(s) || (Object.assign(s.style, o), Object.keys(i).forEach(function(r) {
          var a = i[r];
          a === false ? s.removeAttribute(r) : s.setAttribute(r, a === true ? "" : a);
        }));
      });
    }
    function Ey(t2) {
      var e = t2.state, n = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(o) {
          var i = e.elements[o], s = e.attributes[o] || {}, r = Object.keys(e.styles.hasOwnProperty(o) ? e.styles[o] : n[o]), a = r.reduce(function(l, c2) {
            return l[c2] = "", l;
          }, {});
          !wn(i) || !Zn(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
            i.removeAttribute(l);
          }));
        });
      };
    }
    const n_ = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: jy,
      effect: Ey,
      requires: ["computeStyles"]
    };
    function Jn(t2) {
      return t2.split("-")[0];
    }
    var ni = Math.max, Wr = Math.min, Pi = Math.round;
    function rc() {
      var t2 = navigator.userAgentData;
      return t2 != null && t2.brands && Array.isArray(t2.brands) ? t2.brands.map(function(e) {
        return e.brand + "/" + e.version;
      }).join(" ") : navigator.userAgent;
    }
    function o_() {
      return !/^((?!chrome|android).)*safari/i.test(rc());
    }
    function Bi(t2, e, n) {
      e === void 0 && (e = false), n === void 0 && (n = false);
      var o = t2.getBoundingClientRect(), i = 1, s = 1;
      e && wn(t2) && (i = t2.offsetWidth > 0 && Pi(o.width) / t2.offsetWidth || 1, s = t2.offsetHeight > 0 && Pi(o.height) / t2.offsetHeight || 1);
      var r = ui(t2) ? mn(t2) : window, a = r.visualViewport, l = !o_() && n, c2 = (o.left + (l && a ? a.offsetLeft : 0)) / i, u = (o.top + (l && a ? a.offsetTop : 0)) / s, d = o.width / i, p2 = o.height / s;
      return {
        width: d,
        height: p2,
        top: u,
        right: c2 + d,
        bottom: u + p2,
        left: c2,
        x: c2,
        y: u
      };
    }
    function eu(t2) {
      var e = Bi(t2), n = t2.offsetWidth, o = t2.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), {
        x: t2.offsetLeft,
        y: t2.offsetTop,
        width: n,
        height: o
      };
    }
    function i_(t2, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t2.contains(e))
        return true;
      if (n && Qc(n)) {
        var o = e;
        do {
          if (o && t2.isSameNode(o))
            return true;
          o = o.parentNode || o.host;
        } while (o);
      }
      return false;
    }
    function fo(t2) {
      return mn(t2).getComputedStyle(t2);
    }
    function Sy(t2) {
      return ["table", "td", "th"].indexOf(Zn(t2)) >= 0;
    }
    function Ho(t2) {
      return ((ui(t2) ? t2.ownerDocument : (
        // $FlowFixMe[prop-missing]
        t2.document
      )) || window.document).documentElement;
    }
    function Ua(t2) {
      return Zn(t2) === "html" ? t2 : (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        t2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        t2.parentNode || // DOM Element detected
        (Qc(t2) ? t2.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        Ho(t2)
      );
    }
    function Xd(t2) {
      return !wn(t2) || // https://github.com/popperjs/popper-core/issues/837
      fo(t2).position === "fixed" ? null : t2.offsetParent;
    }
    function Cy(t2) {
      var e = /firefox/i.test(rc()), n = /Trident/i.test(rc());
      if (n && wn(t2)) {
        var o = fo(t2);
        if (o.position === "fixed")
          return null;
      }
      var i = Ua(t2);
      for (Qc(i) && (i = i.host); wn(i) && ["html", "body"].indexOf(Zn(i)) < 0; ) {
        var s = fo(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
          return i;
        i = i.parentNode;
      }
      return null;
    }
    function Ks(t2) {
      for (var e = mn(t2), n = Xd(t2); n && Sy(n) && fo(n).position === "static"; )
        n = Xd(n);
      return n && (Zn(n) === "html" || Zn(n) === "body" && fo(n).position === "static") ? e : n || Cy(t2) || e;
    }
    function tu(t2) {
      return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
    }
    function us(t2, e, n) {
      return ni(t2, Wr(e, n));
    }
    function xy(t2, e, n) {
      var o = us(t2, e, n);
      return o > n ? n : o;
    }
    function s_() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function r_(t2) {
      return Object.assign({}, s_(), t2);
    }
    function a_(t2, e) {
      return e.reduce(function(n, o) {
        return n[o] = t2, n;
      }, {});
    }
    var Ty = function(e, n) {
      return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
        placement: n.placement
      })) : e, r_(typeof e != "number" ? e : a_(e, qs));
    };
    function Oy(t2) {
      var e, n = t2.state, o = t2.name, i = t2.options, s = n.elements.arrow, r = n.modifiersData.popperOffsets, a = Jn(n.placement), l = tu(a), c2 = [nn, Sn].indexOf(a) >= 0, u = c2 ? "height" : "width";
      if (!(!s || !r)) {
        var d = Ty(i.padding, n), p2 = eu(s), m = l === "y" ? tn : nn, f = l === "y" ? En : Sn, _ = n.rects.reference[u] + n.rects.reference[l] - r[l] - n.rects.popper[u], h2 = r[l] - n.rects.reference[l], g = Ks(s), k = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, j = _ / 2 - h2 / 2, v = d[m], C = k - p2[u] - d[f], E = k / 2 - p2[u] / 2 + j, B = us(v, E, C), U = l;
        n.modifiersData[o] = (e = {}, e[U] = B, e.centerOffset = B - E, e);
      }
    }
    function Ny(t2) {
      var e = t2.state, n = t2.options, o = n.element, i = o === void 0 ? "[data-popper-arrow]" : o;
      i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || i_(e.elements.popper, i) && (e.elements.arrow = i));
    }
    const Ay = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: Oy,
      effect: Ny,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function $i(t2) {
      return t2.split("-")[1];
    }
    var My = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function Ry(t2, e) {
      var n = t2.x, o = t2.y, i = e.devicePixelRatio || 1;
      return {
        x: Pi(n * i) / i || 0,
        y: Pi(o * i) / i || 0
      };
    }
    function Zd(t2) {
      var e, n = t2.popper, o = t2.popperRect, i = t2.placement, s = t2.variation, r = t2.offsets, a = t2.position, l = t2.gpuAcceleration, c2 = t2.adaptive, u = t2.roundOffsets, d = t2.isFixed, p2 = r.x, m = p2 === void 0 ? 0 : p2, f = r.y, _ = f === void 0 ? 0 : f, h2 = typeof u == "function" ? u({
        x: m,
        y: _
      }) : {
        x: m,
        y: _
      };
      m = h2.x, _ = h2.y;
      var g = r.hasOwnProperty("x"), k = r.hasOwnProperty("y"), j = nn, v = tn, C = window;
      if (c2) {
        var E = Ks(n), B = "clientHeight", U = "clientWidth";
        if (E === mn(n) && (E = Ho(n), fo(E).position !== "static" && a === "absolute" && (B = "scrollHeight", U = "scrollWidth")), E = E, i === tn || (i === nn || i === Sn) && s === Ts) {
          v = En;
          var P = d && E === C && C.visualViewport ? C.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            E[B]
          );
          _ -= P - o.height, _ *= l ? 1 : -1;
        }
        if (i === nn || (i === tn || i === En) && s === Ts) {
          j = Sn;
          var V = d && E === C && C.visualViewport ? C.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            E[U]
          );
          m -= V - o.width, m *= l ? 1 : -1;
        }
      }
      var ne = Object.assign({
        position: a
      }, c2 && My), pe = u === true ? Ry({
        x: m,
        y: _
      }, mn(n)) : {
        x: m,
        y: _
      };
      if (m = pe.x, _ = pe.y, l) {
        var we;
        return Object.assign({}, ne, (we = {}, we[v] = k ? "0" : "", we[j] = g ? "0" : "", we.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + _ + "px)" : "translate3d(" + m + "px, " + _ + "px, 0)", we));
      }
      return Object.assign({}, ne, (e = {}, e[v] = k ? _ + "px" : "", e[j] = g ? m + "px" : "", e.transform = "", e));
    }
    function Iy(t2) {
      var e = t2.state, n = t2.options, o = n.gpuAcceleration, i = o === void 0 ? true : o, s = n.adaptive, r = s === void 0 ? true : s, a = n.roundOffsets, l = a === void 0 ? true : a, c2 = {
        placement: Jn(e.placement),
        variation: $i(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: i,
        isFixed: e.options.strategy === "fixed"
      };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Zd(Object.assign({}, c2, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: r,
        roundOffsets: l
      })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Zd(Object.assign({}, c2, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    }
    const Dy = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: Iy,
      data: {}
    };
    var sr = {
      passive: true
    };
    function Ly(t2) {
      var e = t2.state, n = t2.instance, o = t2.options, i = o.scroll, s = i === void 0 ? true : i, r = o.resize, a = r === void 0 ? true : r, l = mn(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return s && c2.forEach(function(u) {
        u.addEventListener("scroll", n.update, sr);
      }), a && l.addEventListener("resize", n.update, sr), function() {
        s && c2.forEach(function(u) {
          u.removeEventListener("scroll", n.update, sr);
        }), a && l.removeEventListener("resize", n.update, sr);
      };
    }
    const Py = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function() {
      },
      effect: Ly,
      data: {}
    };
    var By = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function xr(t2) {
      return t2.replace(/left|right|bottom|top/g, function(e) {
        return By[e];
      });
    }
    var $y = {
      start: "end",
      end: "start"
    };
    function Qd(t2) {
      return t2.replace(/start|end/g, function(e) {
        return $y[e];
      });
    }
    function nu(t2) {
      var e = mn(t2), n = e.pageXOffset, o = e.pageYOffset;
      return {
        scrollLeft: n,
        scrollTop: o
      };
    }
    function ou(t2) {
      return Bi(Ho(t2)).left + nu(t2).scrollLeft;
    }
    function zy(t2, e) {
      var n = mn(t2), o = Ho(t2), i = n.visualViewport, s = o.clientWidth, r = o.clientHeight, a = 0, l = 0;
      if (i) {
        s = i.width, r = i.height;
        var c2 = o_();
        (c2 || !c2 && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
      }
      return {
        width: s,
        height: r,
        x: a + ou(t2),
        y: l
      };
    }
    function Fy(t2) {
      var e, n = Ho(t2), o = nu(t2), i = (e = t2.ownerDocument) == null ? void 0 : e.body, s = ni(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), r = ni(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -o.scrollLeft + ou(t2), l = -o.scrollTop;
      return fo(i || n).direction === "rtl" && (a += ni(n.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: r,
        x: a,
        y: l
      };
    }
    function iu(t2) {
      var e = fo(t2), n = e.overflow, o = e.overflowX, i = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + i + o);
    }
    function l_(t2) {
      return ["html", "body", "#document"].indexOf(Zn(t2)) >= 0 ? t2.ownerDocument.body : wn(t2) && iu(t2) ? t2 : l_(Ua(t2));
    }
    function ds(t2, e) {
      var n;
      e === void 0 && (e = []);
      var o = l_(t2), i = o === ((n = t2.ownerDocument) == null ? void 0 : n.body), s = mn(o), r = i ? [s].concat(s.visualViewport || [], iu(o) ? o : []) : o, a = e.concat(r);
      return i ? a : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        a.concat(ds(Ua(r)))
      );
    }
    function ac(t2) {
      return Object.assign({}, t2, {
        left: t2.x,
        top: t2.y,
        right: t2.x + t2.width,
        bottom: t2.y + t2.height
      });
    }
    function Hy(t2, e) {
      var n = Bi(t2, false, e === "fixed");
      return n.top = n.top + t2.clientTop, n.left = n.left + t2.clientLeft, n.bottom = n.top + t2.clientHeight, n.right = n.left + t2.clientWidth, n.width = t2.clientWidth, n.height = t2.clientHeight, n.x = n.left, n.y = n.top, n;
    }
    function ep(t2, e, n) {
      return e === e_ ? ac(zy(t2, n)) : ui(e) ? Hy(e, n) : ac(Fy(Ho(t2)));
    }
    function Uy(t2) {
      var e = ds(Ua(t2)), n = ["absolute", "fixed"].indexOf(fo(t2).position) >= 0, o = n && wn(t2) ? Ks(t2) : t2;
      return ui(o) ? e.filter(function(i) {
        return ui(i) && i_(i, o) && Zn(i) !== "body";
      }) : [];
    }
    function Vy(t2, e, n, o) {
      var i = e === "clippingParents" ? Uy(t2) : [].concat(e), s = [].concat(i, [n]), r = s[0], a = s.reduce(function(l, c2) {
        var u = ep(t2, c2, o);
        return l.top = ni(u.top, l.top), l.right = Wr(u.right, l.right), l.bottom = Wr(u.bottom, l.bottom), l.left = ni(u.left, l.left), l;
      }, ep(t2, r, o));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function c_(t2) {
      var e = t2.reference, n = t2.element, o = t2.placement, i = o ? Jn(o) : null, s = o ? $i(o) : null, r = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
      switch (i) {
        case tn:
          l = {
            x: r,
            y: e.y - n.height
          };
          break;
        case En:
          l = {
            x: r,
            y: e.y + e.height
          };
          break;
        case Sn:
          l = {
            x: e.x + e.width,
            y: a
          };
          break;
        case nn:
          l = {
            x: e.x - n.width,
            y: a
          };
          break;
        default:
          l = {
            x: e.x,
            y: e.y
          };
      }
      var c2 = i ? tu(i) : null;
      if (c2 != null) {
        var u = c2 === "y" ? "height" : "width";
        switch (s) {
          case Li:
            l[c2] = l[c2] - (e[u] / 2 - n[u] / 2);
            break;
          case Ts:
            l[c2] = l[c2] + (e[u] / 2 - n[u] / 2);
            break;
        }
      }
      return l;
    }
    function Os(t2, e) {
      e === void 0 && (e = {});
      var n = e, o = n.placement, i = o === void 0 ? t2.placement : o, s = n.strategy, r = s === void 0 ? t2.strategy : s, a = n.boundary, l = a === void 0 ? dy : a, c2 = n.rootBoundary, u = c2 === void 0 ? e_ : c2, d = n.elementContext, p2 = d === void 0 ? Xi : d, m = n.altBoundary, f = m === void 0 ? false : m, _ = n.padding, h2 = _ === void 0 ? 0 : _, g = r_(typeof h2 != "number" ? h2 : a_(h2, qs)), k = p2 === Xi ? py : Xi, j = t2.rects.popper, v = t2.elements[f ? k : p2], C = Vy(ui(v) ? v : v.contextElement || Ho(t2.elements.popper), l, u, r), E = Bi(t2.elements.reference), B = c_({
        reference: E,
        element: j,
        placement: i
      }), U = ac(Object.assign({}, j, B)), P = p2 === Xi ? U : E, V = {
        top: C.top - P.top + g.top,
        bottom: P.bottom - C.bottom + g.bottom,
        left: C.left - P.left + g.left,
        right: P.right - C.right + g.right
      }, ne = t2.modifiersData.offset;
      if (p2 === Xi && ne) {
        var pe = ne[i];
        Object.keys(V).forEach(function(we) {
          var ye = [Sn, En].indexOf(we) >= 0 ? 1 : -1, _e = [tn, En].indexOf(we) >= 0 ? "y" : "x";
          V[we] += pe[_e] * ye;
        });
      }
      return V;
    }
    function qy(t2, e) {
      e === void 0 && (e = {});
      var n = e, o = n.placement, i = n.boundary, s = n.rootBoundary, r = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c2 = l === void 0 ? t_ : l, u = $i(o), d = u ? a ? Yd : Yd.filter(function(f) {
        return $i(f) === u;
      }) : qs, p2 = d.filter(function(f) {
        return c2.indexOf(f) >= 0;
      });
      p2.length === 0 && (p2 = d);
      var m = p2.reduce(function(f, _) {
        return f[_] = Os(t2, {
          placement: _,
          boundary: i,
          rootBoundary: s,
          padding: r
        })[Jn(_)], f;
      }, {});
      return Object.keys(m).sort(function(f, _) {
        return m[f] - m[_];
      });
    }
    function Ky(t2) {
      if (Jn(t2) === Zc)
        return [];
      var e = xr(t2);
      return [Qd(t2), e, Qd(e)];
    }
    function Wy(t2) {
      var e = t2.state, n = t2.options, o = t2.name;
      if (!e.modifiersData[o]._skip) {
        for (var i = n.mainAxis, s = i === void 0 ? true : i, r = n.altAxis, a = r === void 0 ? true : r, l = n.fallbackPlacements, c2 = n.padding, u = n.boundary, d = n.rootBoundary, p2 = n.altBoundary, m = n.flipVariations, f = m === void 0 ? true : m, _ = n.allowedAutoPlacements, h2 = e.options.placement, g = Jn(h2), k = g === h2, j = l || (k || !f ? [xr(h2)] : Ky(h2)), v = [h2].concat(j).reduce(function(yt, Ue) {
          return yt.concat(Jn(Ue) === Zc ? qy(e, {
            placement: Ue,
            boundary: u,
            rootBoundary: d,
            padding: c2,
            flipVariations: f,
            allowedAutoPlacements: _
          }) : Ue);
        }, []), C = e.rects.reference, E = e.rects.popper, B = /* @__PURE__ */ new Map(), U = true, P = v[0], V = 0; V < v.length; V++) {
          var ne = v[V], pe = Jn(ne), we = $i(ne) === Li, ye = [tn, En].indexOf(pe) >= 0, _e = ye ? "width" : "height", he = Os(e, {
            placement: ne,
            boundary: u,
            rootBoundary: d,
            altBoundary: p2,
            padding: c2
          }), N = ye ? we ? Sn : nn : we ? En : tn;
          C[_e] > E[_e] && (N = xr(N));
          var L = xr(N), J = [];
          if (s && J.push(he[pe] <= 0), a && J.push(he[N] <= 0, he[L] <= 0), J.every(function(yt) {
            return yt;
          })) {
            P = ne, U = false;
            break;
          }
          B.set(ne, J);
        }
        if (U)
          for (var se = f ? 3 : 1, ue = function(Ue) {
            var et = v.find(function(sn) {
              var Nt = B.get(sn);
              if (Nt)
                return Nt.slice(0, Ue).every(function(fn) {
                  return fn;
                });
            });
            if (et)
              return P = et, "break";
          }, Se = se; Se > 0; Se--) {
            var He = ue(Se);
            if (He === "break") break;
          }
        e.placement !== P && (e.modifiersData[o]._skip = true, e.placement = P, e.reset = true);
      }
    }
    const Gy = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: Wy,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function tp(t2, e, n) {
      return n === void 0 && (n = {
        x: 0,
        y: 0
      }), {
        top: t2.top - e.height - n.y,
        right: t2.right - e.width + n.x,
        bottom: t2.bottom - e.height + n.y,
        left: t2.left - e.width - n.x
      };
    }
    function np(t2) {
      return [tn, Sn, En, nn].some(function(e) {
        return t2[e] >= 0;
      });
    }
    function Jy(t2) {
      var e = t2.state, n = t2.name, o = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, r = Os(e, {
        elementContext: "reference"
      }), a = Os(e, {
        altBoundary: true
      }), l = tp(r, o), c2 = tp(a, i, s), u = np(l), d = np(c2);
      e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c2,
        isReferenceHidden: u,
        hasPopperEscaped: d
      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d
      });
    }
    const Yy = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: Jy
    };
    function Xy(t2, e, n) {
      var o = Jn(t2), i = [nn, tn].indexOf(o) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
        placement: t2
      })) : n, r = s[0], a = s[1];
      return r = r || 0, a = (a || 0) * i, [nn, Sn].indexOf(o) >= 0 ? {
        x: a,
        y: r
      } : {
        x: r,
        y: a
      };
    }
    function Zy(t2) {
      var e = t2.state, n = t2.options, o = t2.name, i = n.offset, s = i === void 0 ? [0, 0] : i, r = t_.reduce(function(u, d) {
        return u[d] = Xy(d, e.rects, s), u;
      }, {}), a = r[e.placement], l = a.x, c2 = a.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c2), e.modifiersData[o] = r;
    }
    const Qy = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: Zy
    };
    function ew(t2) {
      var e = t2.state, n = t2.name;
      e.modifiersData[n] = c_({
        reference: e.rects.reference,
        element: e.rects.popper,
        placement: e.placement
      });
    }
    const tw = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: ew,
      data: {}
    };
    function nw(t2) {
      return t2 === "x" ? "y" : "x";
    }
    function ow(t2) {
      var e = t2.state, n = t2.options, o = t2.name, i = n.mainAxis, s = i === void 0 ? true : i, r = n.altAxis, a = r === void 0 ? false : r, l = n.boundary, c2 = n.rootBoundary, u = n.altBoundary, d = n.padding, p2 = n.tether, m = p2 === void 0 ? true : p2, f = n.tetherOffset, _ = f === void 0 ? 0 : f, h2 = Os(e, {
        boundary: l,
        rootBoundary: c2,
        padding: d,
        altBoundary: u
      }), g = Jn(e.placement), k = $i(e.placement), j = !k, v = tu(g), C = nw(v), E = e.modifiersData.popperOffsets, B = e.rects.reference, U = e.rects.popper, P = typeof _ == "function" ? _(Object.assign({}, e.rects, {
        placement: e.placement
      })) : _, V = typeof P == "number" ? {
        mainAxis: P,
        altAxis: P
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, P), ne = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, pe = {
        x: 0,
        y: 0
      };
      if (E) {
        if (s) {
          var we, ye = v === "y" ? tn : nn, _e = v === "y" ? En : Sn, he = v === "y" ? "height" : "width", N = E[v], L = N + h2[ye], J = N - h2[_e], se = m ? -U[he] / 2 : 0, ue = k === Li ? B[he] : U[he], Se = k === Li ? -U[he] : -B[he], He = e.elements.arrow, yt = m && He ? eu(He) : {
            width: 0,
            height: 0
          }, Ue = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : s_(), et = Ue[ye], sn = Ue[_e], Nt = us(0, B[he], yt[he]), fn = j ? B[he] / 2 - se - Nt - et - V.mainAxis : ue - Nt - et - V.mainAxis, At = j ? -B[he] / 2 + se + Nt + sn + V.mainAxis : Se + Nt + sn + V.mainAxis, _n = e.elements.arrow && Ks(e.elements.arrow), zn = _n ? v === "y" ? _n.clientTop || 0 : _n.clientLeft || 0 : 0, On = (we = ne == null ? void 0 : ne[v]) != null ? we : 0, rn = N + fn - On - zn, Nn = N + At - On, ke = us(m ? Wr(L, rn) : L, N, m ? ni(J, Nn) : J);
          E[v] = ke, pe[v] = ke - N;
        }
        if (a) {
          var Xt, Pt = v === "x" ? tn : nn, le = v === "x" ? En : Sn, Ut = E[C], Ge = C === "y" ? "height" : "width", Ie = Ut + h2[Pt], Vt = Ut - h2[le], mt = [tn, nn].indexOf(g) !== -1, An = (Xt = ne == null ? void 0 : ne[C]) != null ? Xt : 0, qt = mt ? Ie : Ut - B[Ge] - U[Ge] - An + V.altAxis, F = mt ? Ut + B[Ge] + U[Ge] - An - V.altAxis : Vt, Y = m && mt ? xy(qt, Ut, F) : us(m ? qt : Ie, Ut, m ? F : Vt);
          E[C] = Y, pe[C] = Y - Ut;
        }
        e.modifiersData[o] = pe;
      }
    }
    const iw = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: ow,
      requiresIfExists: ["offset"]
    };
    function sw(t2) {
      return {
        scrollLeft: t2.scrollLeft,
        scrollTop: t2.scrollTop
      };
    }
    function rw(t2) {
      return t2 === mn(t2) || !wn(t2) ? nu(t2) : sw(t2);
    }
    function aw(t2) {
      var e = t2.getBoundingClientRect(), n = Pi(e.width) / t2.offsetWidth || 1, o = Pi(e.height) / t2.offsetHeight || 1;
      return n !== 1 || o !== 1;
    }
    function lw(t2, e, n) {
      n === void 0 && (n = false);
      var o = wn(e), i = wn(e) && aw(e), s = Ho(e), r = Bi(t2, i, n), a = {
        scrollLeft: 0,
        scrollTop: 0
      }, l = {
        x: 0,
        y: 0
      };
      return (o || !o && !n) && ((Zn(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      iu(s)) && (a = rw(e)), wn(e) ? (l = Bi(e, true), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = ou(s))), {
        x: r.left + a.scrollLeft - l.x,
        y: r.top + a.scrollTop - l.y,
        width: r.width,
        height: r.height
      };
    }
    function cw(t2) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
      t2.forEach(function(s) {
        e.set(s.name, s);
      });
      function i(s) {
        n.add(s.name);
        var r = [].concat(s.requires || [], s.requiresIfExists || []);
        r.forEach(function(a) {
          if (!n.has(a)) {
            var l = e.get(a);
            l && i(l);
          }
        }), o.push(s);
      }
      return t2.forEach(function(s) {
        n.has(s.name) || i(s);
      }), o;
    }
    function uw(t2) {
      var e = cw(t2);
      return wy.reduce(function(n, o) {
        return n.concat(e.filter(function(i) {
          return i.phase === o;
        }));
      }, []);
    }
    function dw(t2) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t2());
          });
        })), e;
      };
    }
    function pw(t2) {
      var e = t2.reduce(function(n, o) {
        var i = n[o.name];
        return n[o.name] = i ? Object.assign({}, i, o, {
          options: Object.assign({}, i.options, o.options),
          data: Object.assign({}, i.data, o.data)
        }) : o, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var op = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function ip() {
      for (var t2 = arguments.length, e = new Array(t2), n = 0; n < t2; n++)
        e[n] = arguments[n];
      return !e.some(function(o) {
        return !(o && typeof o.getBoundingClientRect == "function");
      });
    }
    function mw(t2) {
      t2 === void 0 && (t2 = {});
      var e = t2, n = e.defaultModifiers, o = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? op : i;
      return function(a, l, c2) {
        c2 === void 0 && (c2 = s);
        var u = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, op, s),
          modifiersData: {},
          elements: {
            reference: a,
            popper: l
          },
          attributes: {},
          styles: {}
        }, d = [], p2 = false, m = {
          state: u,
          setOptions: function(g) {
            var k = typeof g == "function" ? g(u.options) : g;
            _(), u.options = Object.assign({}, s, u.options, k), u.scrollParents = {
              reference: ui(a) ? ds(a) : a.contextElement ? ds(a.contextElement) : [],
              popper: ds(l)
            };
            var j = uw(pw([].concat(o, u.options.modifiers)));
            return u.orderedModifiers = j.filter(function(v) {
              return v.enabled;
            }), f(), m.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function() {
            if (!p2) {
              var g = u.elements, k = g.reference, j = g.popper;
              if (ip(k, j)) {
                u.rects = {
                  reference: lw(k, Ks(j), u.options.strategy === "fixed"),
                  popper: eu(j)
                }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(V) {
                  return u.modifiersData[V.name] = Object.assign({}, V.data);
                });
                for (var v = 0; v < u.orderedModifiers.length; v++) {
                  if (u.reset === true) {
                    u.reset = false, v = -1;
                    continue;
                  }
                  var C = u.orderedModifiers[v], E = C.fn, B = C.options, U = B === void 0 ? {} : B, P = C.name;
                  typeof E == "function" && (u = E({
                    state: u,
                    options: U,
                    name: P,
                    instance: m
                  }) || u);
                }
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: dw(function() {
            return new Promise(function(h2) {
              m.forceUpdate(), h2(u);
            });
          }),
          destroy: function() {
            _(), p2 = true;
          }
        };
        if (!ip(a, l))
          return m;
        m.setOptions(c2).then(function(h2) {
          !p2 && c2.onFirstUpdate && c2.onFirstUpdate(h2);
        });
        function f() {
          u.orderedModifiers.forEach(function(h2) {
            var g = h2.name, k = h2.options, j = k === void 0 ? {} : k, v = h2.effect;
            if (typeof v == "function") {
              var C = v({
                state: u,
                name: g,
                instance: m,
                options: j
              }), E = function() {
              };
              d.push(C || E);
            }
          });
        }
        function _() {
          d.forEach(function(h2) {
            return h2();
          }), d = [];
        }
        return m;
      };
    }
    var fw = [Py, tw, Dy, n_, Qy, Gy, iw, Ay, Yy], _w = /* @__PURE__ */ mw({
      defaultModifiers: fw
    }), hw = "tippy-box", u_ = "tippy-content", gw = "tippy-backdrop", d_ = "tippy-arrow", p_ = "tippy-svg-arrow", Ko = {
      passive: true,
      capture: true
    }, m_ = function() {
      return document.body;
    };
    function bl(t2, e, n) {
      if (Array.isArray(t2)) {
        var o = t2[e];
        return o ?? (Array.isArray(n) ? n[e] : n);
      }
      return t2;
    }
    function su(t2, e) {
      var n = {}.toString.call(t2);
      return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
    }
    function f_(t2, e) {
      return typeof t2 == "function" ? t2.apply(void 0, e) : t2;
    }
    function sp(t2, e) {
      if (e === 0)
        return t2;
      var n;
      return function(o) {
        clearTimeout(n), n = setTimeout(function() {
          t2(o);
        }, e);
      };
    }
    function kw(t2) {
      return t2.split(/\s+/).filter(Boolean);
    }
    function yi(t2) {
      return [].concat(t2);
    }
    function rp(t2, e) {
      t2.indexOf(e) === -1 && t2.push(e);
    }
    function yw(t2) {
      return t2.filter(function(e, n) {
        return t2.indexOf(e) === n;
      });
    }
    function ww(t2) {
      return t2.split("-")[0];
    }
    function Gr(t2) {
      return [].slice.call(t2);
    }
    function ap(t2) {
      return Object.keys(t2).reduce(function(e, n) {
        return t2[n] !== void 0 && (e[n] = t2[n]), e;
      }, {});
    }
    function ps() {
      return document.createElement("div");
    }
    function Ns(t2) {
      return ["Element", "Fragment"].some(function(e) {
        return su(t2, e);
      });
    }
    function jw(t2) {
      return su(t2, "NodeList");
    }
    function Ew(t2) {
      return su(t2, "MouseEvent");
    }
    function Sw(t2) {
      return !!(t2 && t2._tippy && t2._tippy.reference === t2);
    }
    function Cw(t2) {
      return Ns(t2) ? [t2] : jw(t2) ? Gr(t2) : Array.isArray(t2) ? t2 : Gr(document.querySelectorAll(t2));
    }
    function kl(t2, e) {
      t2.forEach(function(n) {
        n && (n.style.transitionDuration = e + "ms");
      });
    }
    function lp(t2, e) {
      t2.forEach(function(n) {
        n && n.setAttribute("data-state", e);
      });
    }
    function xw(t2) {
      var e, n = yi(t2), o = n[0];
      return o != null && (e = o.ownerDocument) != null && e.body ? o.ownerDocument : document;
    }
    function Tw(t2, e) {
      var n = e.clientX, o = e.clientY;
      return t2.every(function(i) {
        var s = i.popperRect, r = i.popperState, a = i.props, l = a.interactiveBorder, c2 = ww(r.placement), u = r.modifiersData.offset;
        if (!u)
          return true;
        var d = c2 === "bottom" ? u.top.y : 0, p2 = c2 === "top" ? u.bottom.y : 0, m = c2 === "right" ? u.left.x : 0, f = c2 === "left" ? u.right.x : 0, _ = s.top - o + d > l, h2 = o - s.bottom - p2 > l, g = s.left - n + m > l, k = n - s.right - f > l;
        return _ || h2 || g || k;
      });
    }
    function yl(t2, e, n) {
      var o = e + "EventListener";
      ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
        t2[o](i, n);
      });
    }
    function cp(t2, e) {
      for (var n = e; n; ) {
        var o;
        if (t2.contains(n))
          return true;
        n = n.getRootNode == null || (o = n.getRootNode()) == null ? void 0 : o.host;
      }
      return false;
    }
    var Wn = {
      isTouch: false
    }, up = 0;
    function Ow() {
      Wn.isTouch || (Wn.isTouch = true, window.performance && document.addEventListener("mousemove", __));
    }
    function __() {
      var t2 = performance.now();
      t2 - up < 20 && (Wn.isTouch = false, document.removeEventListener("mousemove", __)), up = t2;
    }
    function Nw() {
      var t2 = document.activeElement;
      if (Sw(t2)) {
        var e = t2._tippy;
        t2.blur && !e.state.isVisible && t2.blur();
      }
    }
    function Aw() {
      document.addEventListener("touchstart", Ow, Ko), window.addEventListener("blur", Nw);
    }
    var Mw = typeof window < "u" && typeof document < "u", Rw = Mw ? (
      // @ts-ignore
      !!window.msCrypto
    ) : false;
    var g_ = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    }, Pw = {
      allowHTML: false,
      animation: "fade",
      arrow: true,
      content: "",
      inertia: false,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999
    }, un = Object.assign({
      appendTo: m_,
      aria: {
        content: "auto",
        expanded: "auto"
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function() {
      },
      onBeforeUpdate: function() {
      },
      onCreate: function() {
      },
      onDestroy: function() {
      },
      onHidden: function() {
      },
      onHide: function() {
      },
      onMount: function() {
      },
      onShow: function() {
      },
      onShown: function() {
      },
      onTrigger: function() {
      },
      onUntrigger: function() {
      },
      onClickOutside: function() {
      },
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: "mouseenter focus",
      triggerTarget: null
    }, g_, Pw), Bw = Object.keys(un), $w = function(e) {
      var n = Object.keys(e);
      n.forEach(function(o) {
        un[o] = e[o];
      });
    };
    function v_(t2) {
      var e = t2.plugins || [], n = e.reduce(function(o, i) {
        var s = i.name, r = i.defaultValue;
        if (s) {
          var a;
          o[s] = t2[s] !== void 0 ? t2[s] : (a = un[s]) != null ? a : r;
        }
        return o;
      }, {});
      return Object.assign({}, t2, n);
    }
    function zw(t2, e) {
      var n = e ? Object.keys(v_(Object.assign({}, un, {
        plugins: e
      }))) : Bw, o = n.reduce(function(i, s) {
        var r = (t2.getAttribute("data-tippy-" + s) || "").trim();
        if (!r)
          return i;
        if (s === "content")
          i[s] = r;
        else
          try {
            i[s] = JSON.parse(r);
          } catch {
            i[s] = r;
          }
        return i;
      }, {});
      return o;
    }
    function pp(t2, e) {
      var n = Object.assign({}, e, {
        content: f_(e.content, [t2])
      }, e.ignoreAttributes ? {} : zw(t2, e.plugins));
      return n.aria = Object.assign({}, un.aria, n.aria), n.aria = {
        expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
        content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
      }, n;
    }
    var Fw = function() {
      return "innerHTML";
    };
    function cc(t2, e) {
      t2[Fw()] = e;
    }
    function mp(t2) {
      var e = ps();
      return t2 === true ? e.className = d_ : (e.className = p_, Ns(t2) ? e.appendChild(t2) : cc(e, t2)), e;
    }
    function fp(t2, e) {
      Ns(e.content) ? (cc(t2, ""), t2.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? cc(t2, e.content) : t2.textContent = e.content);
    }
    function uc(t2) {
      var e = t2.firstElementChild, n = Gr(e.children);
      return {
        box: e,
        content: n.find(function(o) {
          return o.classList.contains(u_);
        }),
        arrow: n.find(function(o) {
          return o.classList.contains(d_) || o.classList.contains(p_);
        }),
        backdrop: n.find(function(o) {
          return o.classList.contains(gw);
        })
      };
    }
    function k_(t2) {
      var e = ps(), n = ps();
      n.className = hw, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
      var o = ps();
      o.className = u_, o.setAttribute("data-state", "hidden"), fp(o, t2.props), e.appendChild(n), n.appendChild(o), i(t2.props, t2.props);
      function i(s, r) {
        var a = uc(e), l = a.box, c2 = a.content, u = a.arrow;
        r.theme ? l.setAttribute("data-theme", r.theme) : l.removeAttribute("data-theme"), typeof r.animation == "string" ? l.setAttribute("data-animation", r.animation) : l.removeAttribute("data-animation"), r.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof r.maxWidth == "number" ? r.maxWidth + "px" : r.maxWidth, r.role ? l.setAttribute("role", r.role) : l.removeAttribute("role"), (s.content !== r.content || s.allowHTML !== r.allowHTML) && fp(c2, t2.props), r.arrow ? u ? s.arrow !== r.arrow && (l.removeChild(u), l.appendChild(mp(r.arrow))) : l.appendChild(mp(r.arrow)) : u && l.removeChild(u);
      }
      return {
        popper: e,
        onUpdate: i
      };
    }
    k_.$$tippy = true;
    var Hw = 1, rr = [], wl = [];
    function Uw(t2, e) {
      var n = pp(t2, Object.assign({}, un, v_(ap(e)))), o, i, s, r = false, a = false, l = false, c2 = false, u, d, p2, m = [], f = sp(rn, n.interactiveDebounce), _, h2 = Hw++, g = null, k = yw(n.plugins), j = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      }, v = {
        // properties
        id: h2,
        reference: t2,
        popper: ps(),
        popperInstance: g,
        props: n,
        state: j,
        plugins: k,
        // methods
        clearDelayTimeouts: qt,
        setProps: F,
        setContent: Y,
        show: je,
        hide: De,
        hideWithInteractivity: ht,
        enable: mt,
        disable: An,
        unmount: an,
        destroy: Wi
      };
      if (!n.render)
        return v;
      var C = n.render(v), E = C.popper, B = C.onUpdate;
      E.setAttribute("data-tippy-root", ""), E.id = "tippy-" + v.id, v.popper = E, t2._tippy = v, E._tippy = v;
      var U = k.map(function(O) {
        return O.fn(v);
      }), P = t2.hasAttribute("aria-expanded");
      return _n(), se(), N(), L("onCreate", [v]), n.showOnCreate && Ie(), E.addEventListener("mouseenter", function() {
        v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
      }), E.addEventListener("mouseleave", function() {
        v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && ye().addEventListener("mousemove", f);
      }), v;
      function V() {
        var O = v.props.touch;
        return Array.isArray(O) ? O : [O, 0];
      }
      function ne() {
        return V()[0] === "hold";
      }
      function pe() {
        var O;
        return !!((O = v.props.render) != null && O.$$tippy);
      }
      function we() {
        return _ || t2;
      }
      function ye() {
        var O = we().parentNode;
        return O ? xw(O) : document;
      }
      function _e() {
        return uc(E);
      }
      function he(O) {
        return v.state.isMounted && !v.state.isVisible || Wn.isTouch || u && u.type === "focus" ? 0 : bl(v.props.delay, O ? 0 : 1, un.delay);
      }
      function N(O) {
        O === void 0 && (O = false), E.style.pointerEvents = v.props.interactive && !O ? "" : "none", E.style.zIndex = "" + v.props.zIndex;
      }
      function L(O, Q, me) {
        if (me === void 0 && (me = true), U.forEach(function(Ne) {
          Ne[O] && Ne[O].apply(Ne, Q);
        }), me) {
          var $e;
          ($e = v.props)[O].apply($e, Q);
        }
      }
      function J() {
        var O = v.props.aria;
        if (O.content) {
          var Q = "aria-" + O.content, me = E.id, $e = yi(v.props.triggerTarget || t2);
          $e.forEach(function(Ne) {
            var wt = Ne.getAttribute(Q);
            if (v.state.isVisible)
              Ne.setAttribute(Q, wt ? wt + " " + me : me);
            else {
              var Kt = wt && wt.replace(me, "").trim();
              Kt ? Ne.setAttribute(Q, Kt) : Ne.removeAttribute(Q);
            }
          });
        }
      }
      function se() {
        if (!(P || !v.props.aria.expanded)) {
          var O = yi(v.props.triggerTarget || t2);
          O.forEach(function(Q) {
            v.props.interactive ? Q.setAttribute("aria-expanded", v.state.isVisible && Q === we() ? "true" : "false") : Q.removeAttribute("aria-expanded");
          });
        }
      }
      function ue() {
        ye().removeEventListener("mousemove", f), rr = rr.filter(function(O) {
          return O !== f;
        });
      }
      function Se(O) {
        if (!(Wn.isTouch && (l || O.type === "mousedown"))) {
          var Q = O.composedPath && O.composedPath()[0] || O.target;
          if (!(v.props.interactive && cp(E, Q))) {
            if (yi(v.props.triggerTarget || t2).some(function(me) {
              return cp(me, Q);
            })) {
              if (Wn.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
                return;
            } else
              L("onClickOutside", [v, O]);
            v.props.hideOnClick === true && (v.clearDelayTimeouts(), v.hide(), a = true, setTimeout(function() {
              a = false;
            }), v.state.isMounted || et());
          }
        }
      }
      function He() {
        l = true;
      }
      function yt() {
        l = false;
      }
      function Ue() {
        var O = ye();
        O.addEventListener("mousedown", Se, true), O.addEventListener("touchend", Se, Ko), O.addEventListener("touchstart", yt, Ko), O.addEventListener("touchmove", He, Ko);
      }
      function et() {
        var O = ye();
        O.removeEventListener("mousedown", Se, true), O.removeEventListener("touchend", Se, Ko), O.removeEventListener("touchstart", yt, Ko), O.removeEventListener("touchmove", He, Ko);
      }
      function sn(O, Q) {
        fn(O, function() {
          !v.state.isVisible && E.parentNode && E.parentNode.contains(E) && Q();
        });
      }
      function Nt(O, Q) {
        fn(O, Q);
      }
      function fn(O, Q) {
        var me = _e().box;
        function $e(Ne) {
          Ne.target === me && (yl(me, "remove", $e), Q());
        }
        if (O === 0)
          return Q();
        yl(me, "remove", d), yl(me, "add", $e), d = $e;
      }
      function At(O, Q, me) {
        me === void 0 && (me = false);
        var $e = yi(v.props.triggerTarget || t2);
        $e.forEach(function(Ne) {
          Ne.addEventListener(O, Q, me), m.push({
            node: Ne,
            eventType: O,
            handler: Q,
            options: me
          });
        });
      }
      function _n() {
        ne() && (At("touchstart", On, {
          passive: true
        }), At("touchend", Nn, {
          passive: true
        })), kw(v.props.trigger).forEach(function(O) {
          if (O !== "manual")
            switch (At(O, On), O) {
              case "mouseenter":
                At("mouseleave", Nn);
                break;
              case "focus":
                At(Rw ? "focusout" : "blur", ke);
                break;
              case "focusin":
                At("focusout", ke);
                break;
            }
        });
      }
      function zn() {
        m.forEach(function(O) {
          var Q = O.node, me = O.eventType, $e = O.handler, Ne = O.options;
          Q.removeEventListener(me, $e, Ne);
        }), m = [];
      }
      function On(O) {
        var Q, me = false;
        if (!(!v.state.isEnabled || Xt(O) || a)) {
          var $e = ((Q = u) == null ? void 0 : Q.type) === "focus";
          u = O, _ = O.currentTarget, se(), !v.state.isVisible && Ew(O) && rr.forEach(function(Ne) {
            return Ne(O);
          }), O.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || r) && v.props.hideOnClick !== false && v.state.isVisible ? me = true : Ie(O), O.type === "click" && (r = !me), me && !$e && Vt(O);
        }
      }
      function rn(O) {
        var Q = O.target, me = we().contains(Q) || E.contains(Q);
        if (!(O.type === "mousemove" && me)) {
          var $e = Ge().concat(E).map(function(Ne) {
            var wt, Kt = Ne._tippy, go = (wt = Kt.popperInstance) == null ? void 0 : wt.state;
            return go ? {
              popperRect: Ne.getBoundingClientRect(),
              popperState: go,
              props: n
            } : null;
          }).filter(Boolean);
          Tw($e, O) && (ue(), Vt(O));
        }
      }
      function Nn(O) {
        var Q = Xt(O) || v.props.trigger.indexOf("click") >= 0 && r;
        if (!Q) {
          if (v.props.interactive) {
            v.hideWithInteractivity(O);
            return;
          }
          Vt(O);
        }
      }
      function ke(O) {
        v.props.trigger.indexOf("focusin") < 0 && O.target !== we() || v.props.interactive && O.relatedTarget && E.contains(O.relatedTarget) || Vt(O);
      }
      function Xt(O) {
        return Wn.isTouch ? ne() !== O.type.indexOf("touch") >= 0 : false;
      }
      function Pt() {
        le();
        var O = v.props, Q = O.popperOptions, me = O.placement, $e = O.offset, Ne = O.getReferenceClientRect, wt = O.moveTransition, Kt = pe() ? uc(E).arrow : null, go = Ne ? {
          getBoundingClientRect: Ne,
          contextElement: Ne.contextElement || we()
        } : t2, Gi = {
          name: "$$tippy",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function(M) {
            var H = M.state;
            if (pe()) {
              var ge = _e(), st = ge.box;
              ["placement", "reference-hidden", "escaped"].forEach(function(tt2) {
                tt2 === "placement" ? st.setAttribute("data-placement", H.placement) : H.attributes.popper["data-popper-" + tt2] ? st.setAttribute("data-" + tt2, "") : st.removeAttribute("data-" + tt2);
              }), H.attributes.popper = {};
            }
          }
        }, Zt = [{
          name: "offset",
          options: {
            offset: $e
          }
        }, {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: "flip",
          options: {
            padding: 5
          }
        }, {
          name: "computeStyles",
          options: {
            adaptive: !wt
          }
        }, Gi];
        pe() && Kt && Zt.push({
          name: "arrow",
          options: {
            element: Kt,
            padding: 3
          }
        }), Zt.push.apply(Zt, (Q == null ? void 0 : Q.modifiers) || []), v.popperInstance = _w(go, E, Object.assign({}, Q, {
          placement: me,
          onFirstUpdate: p2,
          modifiers: Zt
        }));
      }
      function le() {
        v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
      }
      function Ut() {
        var O = v.props.appendTo, Q, me = we();
        v.props.interactive && O === m_ || O === "parent" ? Q = me.parentNode : Q = f_(O, [me]), Q.contains(E) || Q.appendChild(E), v.state.isMounted = true, Pt();
      }
      function Ge() {
        return Gr(E.querySelectorAll("[data-tippy-root]"));
      }
      function Ie(O) {
        v.clearDelayTimeouts(), O && L("onTrigger", [v, O]), Ue();
        var Q = he(true), me = V(), $e = me[0], Ne = me[1];
        Wn.isTouch && $e === "hold" && Ne && (Q = Ne), Q ? o = setTimeout(function() {
          v.show();
        }, Q) : v.show();
      }
      function Vt(O) {
        if (v.clearDelayTimeouts(), L("onUntrigger", [v, O]), !v.state.isVisible) {
          et();
          return;
        }
        if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(O.type) >= 0 && r)) {
          var Q = he(false);
          Q ? i = setTimeout(function() {
            v.state.isVisible && v.hide();
          }, Q) : s = requestAnimationFrame(function() {
            v.hide();
          });
        }
      }
      function mt() {
        v.state.isEnabled = true;
      }
      function An() {
        v.hide(), v.state.isEnabled = false;
      }
      function qt() {
        clearTimeout(o), clearTimeout(i), cancelAnimationFrame(s);
      }
      function F(O) {
        if (!v.state.isDestroyed) {
          L("onBeforeUpdate", [v, O]), zn();
          var Q = v.props, me = pp(t2, Object.assign({}, Q, ap(O), {
            ignoreAttributes: true
          }));
          v.props = me, _n(), Q.interactiveDebounce !== me.interactiveDebounce && (ue(), f = sp(rn, me.interactiveDebounce)), Q.triggerTarget && !me.triggerTarget ? yi(Q.triggerTarget).forEach(function($e) {
            $e.removeAttribute("aria-expanded");
          }) : me.triggerTarget && t2.removeAttribute("aria-expanded"), se(), N(), B && B(Q, me), v.popperInstance && (Pt(), Ge().forEach(function($e) {
            requestAnimationFrame($e._tippy.popperInstance.forceUpdate);
          })), L("onAfterUpdate", [v, O]);
        }
      }
      function Y(O) {
        v.setProps({
          content: O
        });
      }
      function je() {
        var O = v.state.isVisible, Q = v.state.isDestroyed, me = !v.state.isEnabled, $e = Wn.isTouch && !v.props.touch, Ne = bl(v.props.duration, 0, un.duration);
        if (!(O || Q || me || $e) && !we().hasAttribute("disabled") && (L("onShow", [v], false), v.props.onShow(v) !== false)) {
          if (v.state.isVisible = true, pe() && (E.style.visibility = "visible"), N(), Ue(), v.state.isMounted || (E.style.transition = "none"), pe()) {
            var wt = _e(), Kt = wt.box, go = wt.content;
            kl([Kt, go], 0);
          }
          p2 = function() {
            var Zt;
            if (!(!v.state.isVisible || c2)) {
              if (c2 = true, E.offsetHeight, E.style.transition = v.props.moveTransition, pe() && v.props.animation) {
                var w = _e(), M = w.box, H = w.content;
                kl([M, H], Ne), lp([M, H], "visible");
              }
              J(), se(), rp(wl, v), (Zt = v.popperInstance) == null || Zt.forceUpdate(), L("onMount", [v]), v.props.animation && pe() && Nt(Ne, function() {
                v.state.isShown = true, L("onShown", [v]);
              });
            }
          }, Ut();
        }
      }
      function De() {
        var O = !v.state.isVisible, Q = v.state.isDestroyed, me = !v.state.isEnabled, $e = bl(v.props.duration, 1, un.duration);
        if (!(O || Q || me) && (L("onHide", [v], false), v.props.onHide(v) !== false)) {
          if (v.state.isVisible = false, v.state.isShown = false, c2 = false, r = false, pe() && (E.style.visibility = "hidden"), ue(), et(), N(true), pe()) {
            var Ne = _e(), wt = Ne.box, Kt = Ne.content;
            v.props.animation && (kl([wt, Kt], $e), lp([wt, Kt], "hidden"));
          }
          J(), se(), v.props.animation ? pe() && sn($e, v.unmount) : v.unmount();
        }
      }
      function ht(O) {
        ye().addEventListener("mousemove", f), rp(rr, f), f(O);
      }
      function an() {
        v.state.isVisible && v.hide(), v.state.isMounted && (le(), Ge().forEach(function(O) {
          O._tippy.unmount();
        }), E.parentNode && E.parentNode.removeChild(E), wl = wl.filter(function(O) {
          return O !== v;
        }), v.state.isMounted = false, L("onHidden", [v]));
      }
      function Wi() {
        !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), zn(), delete t2._tippy, v.state.isDestroyed = true, L("onDestroy", [v]));
      }
    }
    function Ln(t2, e) {
      e === void 0 && (e = {});
      var n = un.plugins.concat(e.plugins || []);
      Aw();
      var o = Object.assign({}, e, {
        plugins: n
      }), i = Cw(t2);
      var a = i.reduce(function(l, c2) {
        var u = c2 && Uw(c2, o);
        return u && l.push(u), l;
      }, []);
      return Ns(t2) ? a[0] : a;
    }
    Ln.defaultProps = un;
    Ln.setDefaultProps = $w;
    Ln.currentInput = Wn;
    Object.assign({}, n_, {
      effect: function(e) {
        var n = e.state, o = {
          popper: {
            position: n.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(n.elements.popper.style, o.popper), n.styles = o, n.elements.arrow && Object.assign(n.elements.arrow.style, o.arrow);
      }
    });
    Ln.setDefaultProps({
      render: k_
    });
    class Vw {
      constructor({ editor: e, element: n, view: o, tippyOptions: i = {}, updateDelay: s = 250, shouldShow: r }) {
        this.preventHide = false, this.shouldShow = ({ view: a, state: l, from: c2, to: u }) => {
          const { doc: d, selection: p2 } = l, { empty: m } = p2, f = !d.textBetween(c2, u).length && $a(l.selection), _ = this.element.contains(document.activeElement);
          return !(!(a.hasFocus() || _) || m || f || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.dragstartHandler = () => {
          this.hide();
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: a }) => {
          var l;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (a) => {
          this.blurHandler({ event: a });
        }, this.handleDebouncedUpdate = (a, l) => {
          const c2 = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
          !c2 && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, c2, u, l);
          }, this.updateDelay));
        }, this.updateHandler = (a, l, c2, u) => {
          var d, p2, m;
          const { state: f, composing: _ } = a, { selection: h2 } = f;
          if (_ || !l && !c2)
            return;
          this.createTooltip();
          const { ranges: k } = h2, j = Math.min(...k.map((E) => E.$from.pos)), v = Math.max(...k.map((E) => E.$to.pos));
          if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
            editor: this.editor,
            element: this.element,
            view: a,
            state: f,
            oldState: u,
            from: j,
            to: v
          }))) {
            this.hide();
            return;
          }
          (p2 = this.tippy) === null || p2 === void 0 || p2.setProps({
            getReferenceClientRect: ((m = this.tippyOptions) === null || m === void 0 ? void 0 : m.getReferenceClientRect) || (() => {
              if (Zf(f.selection)) {
                let E = a.nodeDOM(j);
                if (E) {
                  const B = E.dataset.nodeViewWrapper ? E : E.querySelector("[data-node-view-wrapper]");
                  if (B && (E = B.firstChild), E)
                    return E.getBoundingClientRect();
                }
              }
              return Qf(a, j, v);
            })
          }), this.show();
        }, this.editor = e, this.element = n, this.view = o, this.updateDelay = s, r && (this.shouldShow = r), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Ln(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "top",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, n) {
        const { state: o } = e, i = o.selection.from !== o.selection.to;
        if (this.updateDelay > 0 && i) {
          this.handleDebouncedUpdate(e, n);
          return;
        }
        const s = !(n != null && n.selection.eq(e.state.selection)), r = !(n != null && n.doc.eq(e.state.doc));
        this.updateHandler(e, s, r, n);
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, n;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const y_ = (t2) => new ze({
      key: typeof t2.pluginKey == "string" ? new Fe(t2.pluginKey) : t2.pluginKey,
      view: (e) => new Vw({ view: e, ...t2 })
    });
    We.create({
      name: "bubbleMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "bubbleMenu",
          updateDelay: void 0,
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          y_({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    class qw {
      getTextContent(e) {
        return Yf(e, { textSerializers: Gc(this.editor.schema) });
      }
      constructor({ editor: e, element: n, view: o, tippyOptions: i = {}, shouldShow: s }) {
        this.preventHide = false, this.shouldShow = ({ view: r, state: a }) => {
          const { selection: l } = a, { $anchor: c2, empty: u } = l, d = c2.depth === 1, p2 = c2.parent.isTextblock && !c2.parent.type.spec.code && !c2.parent.textContent && c2.parent.childCount === 0 && !this.getTextContent(c2.parent);
          return !(!r.hasFocus() || !u || !d || !p2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: r }) => {
          var a;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          r != null && r.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(r.relatedTarget)) || (r == null ? void 0 : r.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (r) => {
          this.blurHandler({ event: r });
        }, this.editor = e, this.element = n, this.view = o, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Ln(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "right",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, n) {
        var o, i, s;
        const { state: r } = e, { doc: a, selection: l } = r, { from: c2, to: u } = l;
        if (n && n.doc.eq(a) && n.selection.eq(l))
          return;
        if (this.createTooltip(), !((o = this.shouldShow) === null || o === void 0 ? void 0 : o.call(this, {
          editor: this.editor,
          view: e,
          state: r,
          oldState: n
        }))) {
          this.hide();
          return;
        }
        (i = this.tippy) === null || i === void 0 || i.setProps({
          getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => Qf(e, c2, u))
        }), this.show();
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, n;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const w_ = (t2) => new ze({
      key: typeof t2.pluginKey == "string" ? new Fe(t2.pluginKey) : t2.pluginKey,
      view: (e) => new qw({ view: e, ...t2 })
    });
    We.create({
      name: "floatingMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "floatingMenu",
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          w_({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    const Kw = /* @__PURE__ */ defineComponent({
      name: "BubbleMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "bubbleMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(t2, { slots: e }) {
        const n = ref(null);
        return onMounted(() => {
          const { updateDelay: o, editor: i, pluginKey: s, shouldShow: r, tippyOptions: a } = t2;
          i.registerPlugin(y_({
            updateDelay: o,
            editor: i,
            element: n.value,
            pluginKey: s,
            shouldShow: r,
            tippyOptions: a
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: o, editor: i } = t2;
          i.unregisterPlugin(o);
        }), () => {
          var o;
          return h("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
        };
      }
    });
    function _p(t2) {
      return customRef((e, n) => ({
        get() {
          return e(), t2;
        },
        set(o) {
          t2 = o, requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              n();
            });
          });
        }
      }));
    }
    class j_ extends Tn {
      constructor(e = {}) {
        return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = _p(this.view.state), this.reactiveExtensionStorage = _p(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
          this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
        }), markRaw(this);
      }
      get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state;
      }
      get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
      }
      /**
       * Register a ProseMirror plugin.
       */
      registerPlugin(e, n) {
        const o = super.registerPlugin(e, n);
        return this.reactiveState && (this.reactiveState.value = o), o;
      }
      /**
       * Unregister a ProseMirror plugin.
       */
      unregisterPlugin(e) {
        const n = super.unregisterPlugin(e);
        return this.reactiveState && n && (this.reactiveState.value = n), n;
      }
    }
    const Ww = /* @__PURE__ */ defineComponent({
      name: "EditorContent",
      props: {
        editor: {
          default: null,
          type: Object
        }
      },
      setup(t2) {
        const e = ref(), n = getCurrentInstance();
        return watchEffect(() => {
          const o = t2.editor;
          o && o.options.element && e.value && nextTick(() => {
            if (!e.value || !o.options.element.firstChild)
              return;
            const i = unref(e.value);
            e.value.append(...o.options.element.childNodes), o.contentComponent = n.ctx._, n && (o.appContext = {
              ...n.appContext,
              // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
              // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
              // @ts-expect-error forward instance's 'provides' into appContext
              provides: n.provides
            }), o.setOptions({
              element: i
            }), o.createNodeViews();
          });
        }), onBeforeUnmount(() => {
          const o = t2.editor;
          o && (o.contentComponent = null, o.appContext = null);
        }), { rootEl: e };
      },
      render() {
        return h("div", {
          ref: (t2) => {
            this.rootEl = t2;
          }
        });
      }
    }), Gw = /* @__PURE__ */ defineComponent({
      name: "FloatingMenu",
      props: {
        pluginKey: {
          // TODO: TypeScript breaks :(
          // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
          type: null,
          default: "floatingMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(t2, { slots: e }) {
        const n = ref(null);
        return onMounted(() => {
          const { pluginKey: o, editor: i, tippyOptions: s, shouldShow: r } = t2;
          i.registerPlugin(w_({
            pluginKey: o,
            editor: i,
            element: n.value,
            tippyOptions: s,
            shouldShow: r
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: o, editor: i } = t2;
          i.unregisterPlugin(o);
        }), () => {
          var o;
          return h("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
        };
      }
    }), _o = /* @__PURE__ */ defineComponent({
      name: "NodeViewContent",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      render() {
        return h(this.as, {
          style: {
            whiteSpace: "pre-wrap"
          },
          "data-node-view-content": ""
        });
      }
    }), ru = /* @__PURE__ */ defineComponent({
      name: "NodeViewWrapper",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      inject: ["onDragStart", "decorationClasses"],
      render() {
        var t2, e;
        return h(this.as, {
          // @ts-ignore
          class: this.decorationClasses,
          style: {
            whiteSpace: "normal"
          },
          "data-node-view-wrapper": "",
          // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
          onDragstart: this.onDragStart
        }, (e = (t2 = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t2));
      }
    }), Jw = (t2 = {}) => {
      const e = shallowRef();
      return onMounted(() => {
        e.value = new j_(t2);
      }), onBeforeUnmount(() => {
        var n, o, i;
        const s = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, r = s == null ? void 0 : s.cloneNode(true);
        (o = s == null ? void 0 : s.parentNode) === null || o === void 0 || o.replaceChild(r, s), (i = e.value) === null || i === void 0 || i.destroy();
      }), e;
    };
    class au {
      constructor(e, { props: n = {}, editor: o }) {
        this.editor = o, this.component = markRaw(e), this.el = document.createElement("div"), this.props = reactive(n), this.renderedComponent = this.renderComponent();
      }
      get element() {
        return this.renderedComponent.el;
      }
      get ref() {
        var e, n, o, i;
        return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (i = (o = this.renderedComponent.vNode) === null || o === void 0 ? void 0 : o.component) === null || i === void 0 ? void 0 : i.proxy;
      }
      renderComponent() {
        let e = h(this.component, this.props);
        return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && render$1(e, this.el), { vNode: e, destroy: () => {
          this.el && render$1(null, this.el), this.el = null, e = null;
        }, el: this.el ? this.el.firstElementChild : null };
      }
      updateProps(e = {}) {
        Object.entries(e).forEach(([n, o]) => {
          this.props[n] = o;
        }), this.renderComponent();
      }
      destroy() {
        this.renderedComponent.destroy();
      }
    }
    const Ot = {
      editor: {
        type: Object,
        required: true
      },
      node: {
        type: Object,
        required: true
      },
      decorations: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        required: true
      },
      extension: {
        type: Object,
        required: true
      },
      getPos: {
        type: Function,
        required: true
      },
      updateAttributes: {
        type: Function,
        required: true
      },
      deleteNode: {
        type: Function,
        required: true
      },
      view: {
        type: Object,
        required: true
      },
      innerDecorations: {
        type: Object,
        required: true
      },
      HTMLAttributes: {
        type: Object,
        required: true
      }
    };
    class Yw extends cy {
      mount() {
        const e = {
          editor: this.editor,
          node: this.node,
          decorations: this.decorations,
          innerDecorations: this.innerDecorations,
          view: this.view,
          selected: false,
          extension: this.extension,
          HTMLAttributes: this.HTMLAttributes,
          getPos: () => this.getPos(),
          updateAttributes: (i = {}) => this.updateAttributes(i),
          deleteNode: () => this.deleteNode()
        }, n = this.onDragStart.bind(this);
        this.decorationClasses = ref(this.getDecorationClasses());
        const o = /* @__PURE__ */ defineComponent({
          extends: { ...this.component },
          props: Object.keys(e),
          template: this.component.template,
          setup: (i) => {
            var s, r;
            return provide("onDragStart", n), provide("decorationClasses", this.decorationClasses), (r = (s = this.component).setup) === null || r === void 0 ? void 0 : r.call(s, i, {
              expose: () => {
              }
            });
          },
          // add support for scoped styles
          // @ts-ignore
          // eslint-disable-next-line
          __scopeId: this.component.__scopeId,
          // add support for CSS Modules
          // @ts-ignore
          // eslint-disable-next-line
          __cssModules: this.component.__cssModules,
          // add support for vue devtools
          // @ts-ignore
          // eslint-disable-next-line
          __name: this.component.__name,
          // @ts-ignore
          // eslint-disable-next-line
          __file: this.component.__file
        });
        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new au(o, {
          editor: this.editor,
          props: e
        });
      }
      /**
       * Return the DOM element.
       * This is the element that will be used to display the node view.
       */
      get dom() {
        if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
          throw Error("Please use the NodeViewWrapper component for your node view.");
        return this.renderer.element;
      }
      /**
       * Return the content DOM element.
       * This is the element that will be used to display the rich-text content of the node.
       */
      get contentDOM() {
        return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
      }
      /**
       * On editor selection update, check if the node is selected.
       * If it is, call `selectNode`, otherwise call `deselectNode`.
       */
      handleSelectionUpdate() {
        const { from: e, to: n } = this.editor.state.selection, o = this.getPos();
        if (typeof o == "number")
          if (e <= o && n >= o + this.node.nodeSize) {
            if (this.renderer.props.selected)
              return;
            this.selectNode();
          } else {
            if (!this.renderer.props.selected)
              return;
            this.deselectNode();
          }
      }
      /**
       * On update, update the React component.
       * To prevent unnecessary updates, the `update` option can be used.
       */
      update(e, n, o) {
        const i = (s) => {
          this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(s);
        };
        if (typeof this.options.update == "function") {
          const s = this.node, r = this.decorations, a = this.innerDecorations;
          return this.node = e, this.decorations = n, this.innerDecorations = o, this.options.update({
            oldNode: s,
            oldDecorations: r,
            newNode: e,
            newDecorations: n,
            oldInnerDecorations: a,
            innerDecorations: o,
            updateProps: () => i({ node: e, decorations: n, innerDecorations: o })
          });
        }
        return e.type !== this.node.type ? false : (e === this.node && this.decorations === n && this.innerDecorations === o || (this.node = e, this.decorations = n, this.innerDecorations = o, i({ node: e, decorations: n, innerDecorations: o })), true);
      }
      /**
       * Select the node.
       * Add the `selected` prop and the `ProseMirror-selectednode` class.
       */
      selectNode() {
        this.renderer.updateProps({
          selected: true
        }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
      }
      /**
       * Deselect the node.
       * Remove the `selected` prop and the `ProseMirror-selectednode` class.
       */
      deselectNode() {
        this.renderer.updateProps({
          selected: false
        }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
      }
      getDecorationClasses() {
        return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
      }
      destroy() {
        this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
      }
    }
    function Pn(t2, e) {
      return (n) => {
        if (!n.editor.contentComponent)
          return {};
        const o = typeof t2 == "function" && "__vccOpts" in t2 ? t2.__vccOpts : t2;
        return new Yw(o, n, e);
      };
    }
    const Xw = /^\s*>\s$/, E_ = it.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["blockquote", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: t2 }) => t2.wrapIn(this.name),
          toggleBlockquote: () => ({ commands: t2 }) => t2.toggleWrap(this.name),
          unsetBlockquote: () => ({ commands: t2 }) => t2.lift(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          Di({
            find: Xw,
            type: this.type
          })
        ];
      }
    }), Zw = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, Qw = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, ej = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, tj = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, nj = jn.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (t2) => t2.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (t2) => t2.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (t2) => /^(bold(er)?|[5-9]\d{2,})$/.test(t2) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["strong", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleBold: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetBold: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          ci({
            find: Zw,
            type: this.type
          }),
          ci({
            find: ej,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Bo({
            find: Qw,
            type: this.type
          }),
          Bo({
            find: tj,
            type: this.type
          })
        ];
      }
    }), oj = "listItem", hp = "textStyle", gp = /^\s*([-+*])\s$/, ij = it.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["ul", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: t2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(oj, this.editor.getAttributes(hp)).run() : t2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let t2 = Di({
          find: gp,
          type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t2 = Di({
          find: gp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => this.editor.getAttributes(hp),
          editor: this.editor
        })), [
          t2
        ];
      }
    }), sj = /(^|[^`])`([^`]+)`(?!`)/, rj = /(^|[^`])`([^`]+)`(?!`)/g, aj = jn.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["code", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleCode: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetCode: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          ci({
            find: sj,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Bo({
            find: rj,
            type: this.type
          })
        ];
      }
    }), lj = /^```([a-z]+)?[\s\n]$/, cj = /^~~~([a-z]+)?[\s\n]$/, S_ = it.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (t2) => {
              var e;
              const { languageClassPrefix: n } = this.options, s = [...((e = t2.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((r) => r.startsWith(n)).map((r) => r.replace(n, ""))[0];
              return s || null;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "pre",
          Pe(this.options.HTMLAttributes, e),
          [
            "code",
            {
              class: t2.attrs.language ? this.options.languageClassPrefix + t2.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (t2) => ({ commands: e }) => e.setNode(this.name, t2),
          toggleCodeBlock: (t2) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t2)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: t2, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
            return !t2 || e.parent.type.name !== this.name ? false : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
          },
          // exit node on triple enter
          Enter: ({ editor: t2 }) => {
            if (!this.options.exitOnTripleEnter)
              return false;
            const { state: e } = t2, { selection: n } = e, { $from: o, empty: i } = n;
            if (!i || o.parent.type !== this.type)
              return false;
            const s = o.parentOffset === o.parent.nodeSize - 2, r = o.parent.textContent.endsWith(`

`);
            return !s || !r ? false : t2.chain().command(({ tr: a }) => (a.delete(o.pos - 2, o.pos), true)).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor: t2 }) => {
            if (!this.options.exitOnArrowDown)
              return false;
            const { state: e } = t2, { selection: n, doc: o } = e, { $from: i, empty: s } = n;
            if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
              return false;
            const a = i.after();
            return a === void 0 ? false : o.nodeAt(a) ? t2.commands.command(({ tr: c2 }) => (c2.setSelection(de.near(o.resolve(a))), true)) : t2.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          sc({
            find: lj,
            type: this.type,
            getAttributes: (t2) => ({
              language: t2[1]
            })
          }),
          sc({
            find: cj,
            type: this.type,
            getAttributes: (t2) => ({
              language: t2[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new ze({
            key: new Fe("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (t2, e) => {
                if (!e.clipboardData || this.editor.isActive(this.type.name))
                  return false;
                const n = e.clipboardData.getData("text/plain"), o = e.clipboardData.getData("vscode-editor-data"), i = o ? JSON.parse(o) : void 0, s = i == null ? void 0 : i.mode;
                if (!n || !s)
                  return false;
                const { tr: r, schema: a } = t2.state, l = a.text(n.replace(/\r\n?/g, `
`));
                return r.replaceSelectionWith(this.type.create({ language: s }, l)), r.selection.$from.parent.type !== this.type && r.setSelection(re.near(r.doc.resolve(Math.max(0, r.selection.from - 2)))), r.setMeta("paste", true), t2.dispatch(r), true;
              }
            }
          })
        ];
      }
    }), C_ = it.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    function uj(t2 = {}) {
      return new ze({
        view(e) {
          return new dj(e, t2);
        }
      });
    }
    class dj {
      constructor(e, n) {
        var o;
        this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (o = n.width) !== null && o !== void 0 ? o : 1, this.color = n.color === false ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
          let s = (r) => {
            this[i](r);
          };
          return e.dom.addEventListener(i, s), { name: i, handler: s };
        });
      }
      destroy() {
        this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
      }
      update(e, n) {
        this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
      }
      setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
      }
      updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, o;
        if (n) {
          let a = e.nodeBefore, l = e.nodeAfter;
          if (a || l) {
            let c2 = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
            if (c2) {
              let u = c2.getBoundingClientRect(), d = a ? u.bottom : u.top;
              a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), o = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
            }
          }
        }
        if (!o) {
          let a = this.editorView.coordsAtPos(this.cursorPos);
          o = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
        }
        let i = this.editorView.dom.offsetParent;
        this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let s, r;
        if (!i || i == document.body && getComputedStyle(i).position == "static")
          s = -pageXOffset, r = -pageYOffset;
        else {
          let a = i.getBoundingClientRect();
          s = a.left - i.scrollLeft, r = a.top - i.scrollTop;
        }
        this.element.style.left = o.left - s + "px", this.element.style.top = o.top - r + "px", this.element.style.width = o.right - o.left + "px", this.element.style.height = o.bottom - o.top + "px";
      }
      scheduleRemoval(e) {
        clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
      }
      dragover(e) {
        if (!this.editorView.editable)
          return;
        let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), o = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = o && o.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, n, e) : i;
        if (n && !s) {
          let r = n.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let a = zm(this.editorView.state.doc, r, this.editorView.dragging.slice);
            a != null && (r = a);
          }
          this.setCursor(r), this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
      }
    }
    const pj = We.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          uj(this.options)
        ];
      }
    });
    class ct extends de {
      /**
      Create a gap cursor.
      */
      constructor(e) {
        super(e, e);
      }
      map(e, n) {
        let o = e.resolve(n.map(this.head));
        return ct.valid(o) ? new ct(o) : de.near(o);
      }
      content() {
        return K.empty;
      }
      eq(e) {
        return e instanceof ct && e.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, n) {
        if (typeof n.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new ct(e.resolve(n.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new lu(this.anchor);
      }
      /**
      @internal
      */
      static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !mj(e) || !fj(e))
          return false;
        let o = n.type.spec.allowGapCursor;
        if (o != null)
          return o;
        let i = n.contentMatchAt(e.index()).defaultType;
        return i && i.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom(e, n, o = false) {
        e: for (; ; ) {
          if (!o && ct.valid(e))
            return e;
          let i = e.pos, s = null;
          for (let r = e.depth; ; r--) {
            let a = e.node(r);
            if (n > 0 ? e.indexAfter(r) < a.childCount : e.index(r) > 0) {
              s = a.child(n > 0 ? e.indexAfter(r) : e.index(r) - 1);
              break;
            } else if (r == 0)
              return null;
            i += n;
            let l = e.doc.resolve(i);
            if (ct.valid(l))
              return l;
          }
          for (; ; ) {
            let r = n > 0 ? s.firstChild : s.lastChild;
            if (!r) {
              if (s.isAtom && !s.isText && !ie.isSelectable(s)) {
                e = e.doc.resolve(i + s.nodeSize * n), o = false;
                continue e;
              }
              break;
            }
            s = r, i += n;
            let a = e.doc.resolve(i);
            if (ct.valid(a))
              return a;
          }
          return null;
        }
      }
    }
    ct.prototype.visible = false;
    ct.findFrom = ct.findGapCursorFrom;
    de.jsonID("gapcursor", ct);
    class lu {
      constructor(e) {
        this.pos = e;
      }
      map(e) {
        return new lu(e.map(this.pos));
      }
      resolve(e) {
        let n = e.resolve(this.pos);
        return ct.valid(n) ? new ct(n) : de.near(n);
      }
    }
    function mj(t2) {
      for (let e = t2.depth; e >= 0; e--) {
        let n = t2.index(e), o = t2.node(e);
        if (n == 0) {
          if (o.type.spec.isolating)
            return true;
          continue;
        }
        for (let i = o.child(n - 1); ; i = i.lastChild) {
          if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
            return true;
          if (i.inlineContent)
            return false;
        }
      }
      return true;
    }
    function fj(t2) {
      for (let e = t2.depth; e >= 0; e--) {
        let n = t2.indexAfter(e), o = t2.node(e);
        if (n == o.childCount) {
          if (o.type.spec.isolating)
            return true;
          continue;
        }
        for (let i = o.child(n); ; i = i.firstChild) {
          if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
            return true;
          if (i.inlineContent)
            return false;
        }
      }
      return true;
    }
    function _j() {
      return new ze({
        props: {
          decorations: bj,
          createSelectionBetween(t2, e, n) {
            return e.pos == n.pos && ct.valid(n) ? new ct(n) : null;
          },
          handleClick: gj,
          handleKeyDown: hj,
          handleDOMEvents: { beforeinput: vj }
        }
      });
    }
    const hj = zc({
      ArrowLeft: ar("horiz", -1),
      ArrowRight: ar("horiz", 1),
      ArrowUp: ar("vert", -1),
      ArrowDown: ar("vert", 1)
    });
    function ar(t2, e) {
      const n = t2 == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
      return function(o, i, s) {
        let r = o.selection, a = e > 0 ? r.$to : r.$from, l = r.empty;
        if (r instanceof re) {
          if (!s.endOfTextblock(n) || a.depth == 0)
            return false;
          l = false, a = o.doc.resolve(e > 0 ? a.after() : a.before());
        }
        let c2 = ct.findGapCursorFrom(a, e, l);
        return c2 ? (i && i(o.tr.setSelection(new ct(c2))), true) : false;
      };
    }
    function gj(t2, e, n) {
      if (!t2 || !t2.editable)
        return false;
      let o = t2.state.doc.resolve(e);
      if (!ct.valid(o))
        return false;
      let i = t2.posAtCoords({ left: n.clientX, top: n.clientY });
      return i && i.inside > -1 && ie.isSelectable(t2.state.doc.nodeAt(i.inside)) ? false : (t2.dispatch(t2.state.tr.setSelection(new ct(o))), true);
    }
    function vj(t2, e) {
      if (e.inputType != "insertCompositionText" || !(t2.state.selection instanceof ct))
        return false;
      let { $from: n } = t2.state.selection, o = n.parent.contentMatchAt(n.index()).findWrapping(t2.state.schema.nodes.text);
      if (!o)
        return false;
      let i = D.empty;
      for (let r = o.length - 1; r >= 0; r--)
        i = D.from(o[r].createAndFill(null, i));
      let s = t2.state.tr.replace(n.pos, n.pos, new K(i, 0, 0));
      return s.setSelection(re.near(s.doc.resolve(n.pos + 1))), t2.dispatch(s), false;
    }
    function bj(t2) {
      if (!(t2.selection instanceof ct))
        return null;
      let e = document.createElement("div");
      return e.className = "ProseMirror-gapcursor", qe.create(t2.doc, [_t.widget(t2.selection.head, e, { key: "gapcursor" })]);
    }
    const kj = We.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          _j()
        ];
      },
      extendNodeSchema(t2) {
        var e;
        const n = {
          name: t2.name,
          options: t2.options,
          storage: t2.storage
        };
        return {
          allowGapCursor: (e = Te(Z(t2, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
        };
      }
    }), yj = it.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["br", Pe(this.options.HTMLAttributes, t2)];
      },
      renderText() {
        return `
`;
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: t2, chain: e, state: n, editor: o }) => t2.first([
            () => t2.exitCode(),
            () => t2.command(() => {
              const { selection: i, storedMarks: s } = n;
              if (i.$from.parent.type.spec.isolating)
                return false;
              const { keepMarks: r } = this.options, { splittableMarks: a } = o.extensionManager, l = s || i.$to.parentOffset && i.$from.marks();
              return e().insertContent({ type: this.name }).command(({ tr: c2, dispatch: u }) => {
                if (u && l && r) {
                  const d = l.filter((p2) => a.includes(p2.type.name));
                  c2.ensureMarks(d);
                }
                return true;
              }).run();
            })
          ])
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    }), x_ = it.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((t2) => ({
          tag: `h${t2}`,
          attrs: { level: t2 }
        }));
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [`h${this.options.levels.includes(t2.attrs.level) ? t2.attrs.level : this.options.levels[0]}`, Pe(this.options.HTMLAttributes, e), 0];
      },
      addCommands() {
        return {
          setHeading: (t2) => ({ commands: e }) => this.options.levels.includes(t2.level) ? e.setNode(this.name, t2) : false,
          toggleHeading: (t2) => ({ commands: e }) => this.options.levels.includes(t2.level) ? e.toggleNode(this.name, "paragraph", t2) : false
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((t2, e) => ({
          ...t2,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((t2) => sc({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t2}})\\s$`),
          type: this.type,
          getAttributes: {
            level: t2
          }
        }));
      }
    });
    var Jr = 200, xt = function() {
    };
    xt.prototype.append = function(e) {
      return e.length ? (e = xt.from(e), !this.length && e || e.length < Jr && this.leafAppend(e) || this.length < Jr && e.leafPrepend(this) || this.appendInner(e)) : this;
    };
    xt.prototype.prepend = function(e) {
      return e.length ? xt.from(e).append(this) : this;
    };
    xt.prototype.appendInner = function(e) {
      return new wj(this, e);
    };
    xt.prototype.slice = function(e, n) {
      return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? xt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
    };
    xt.prototype.get = function(e) {
      if (!(e < 0 || e >= this.length))
        return this.getInner(e);
    };
    xt.prototype.forEach = function(e, n, o) {
      n === void 0 && (n = 0), o === void 0 && (o = this.length), n <= o ? this.forEachInner(e, n, o, 0) : this.forEachInvertedInner(e, n, o, 0);
    };
    xt.prototype.map = function(e, n, o) {
      n === void 0 && (n = 0), o === void 0 && (o = this.length);
      var i = [];
      return this.forEach(function(s, r) {
        return i.push(e(s, r));
      }, n, o), i;
    };
    xt.from = function(e) {
      return e instanceof xt ? e : e && e.length ? new T_(e) : xt.empty;
    };
    var T_ = /* @__PURE__ */ function(t2) {
      function e(o) {
        t2.call(this), this.values = o;
      }
      t2 && (e.__proto__ = t2), e.prototype = Object.create(t2 && t2.prototype), e.prototype.constructor = e;
      var n = { length: { configurable: true }, depth: { configurable: true } };
      return e.prototype.flatten = function() {
        return this.values;
      }, e.prototype.sliceInner = function(i, s) {
        return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
      }, e.prototype.getInner = function(i) {
        return this.values[i];
      }, e.prototype.forEachInner = function(i, s, r, a) {
        for (var l = s; l < r; l++)
          if (i(this.values[l], a + l) === false)
            return false;
      }, e.prototype.forEachInvertedInner = function(i, s, r, a) {
        for (var l = s - 1; l >= r; l--)
          if (i(this.values[l], a + l) === false)
            return false;
      }, e.prototype.leafAppend = function(i) {
        if (this.length + i.length <= Jr)
          return new e(this.values.concat(i.flatten()));
      }, e.prototype.leafPrepend = function(i) {
        if (this.length + i.length <= Jr)
          return new e(i.flatten().concat(this.values));
      }, n.length.get = function() {
        return this.values.length;
      }, n.depth.get = function() {
        return 0;
      }, Object.defineProperties(e.prototype, n), e;
    }(xt);
    xt.empty = new T_([]);
    var wj = /* @__PURE__ */ function(t2) {
      function e(n, o) {
        t2.call(this), this.left = n, this.right = o, this.length = n.length + o.length, this.depth = Math.max(n.depth, o.depth) + 1;
      }
      return t2 && (e.__proto__ = t2), e.prototype = Object.create(t2 && t2.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten());
      }, e.prototype.getInner = function(o) {
        return o < this.left.length ? this.left.get(o) : this.right.get(o - this.left.length);
      }, e.prototype.forEachInner = function(o, i, s, r) {
        var a = this.left.length;
        if (i < a && this.left.forEachInner(o, i, Math.min(s, a), r) === false || s > a && this.right.forEachInner(o, Math.max(i - a, 0), Math.min(this.length, s) - a, r + a) === false)
          return false;
      }, e.prototype.forEachInvertedInner = function(o, i, s, r) {
        var a = this.left.length;
        if (i > a && this.right.forEachInvertedInner(o, i - a, Math.max(s, a) - a, r + a) === false || s < a && this.left.forEachInvertedInner(o, Math.min(i, a), s, r) === false)
          return false;
      }, e.prototype.sliceInner = function(o, i) {
        if (o == 0 && i == this.length)
          return this;
        var s = this.left.length;
        return i <= s ? this.left.slice(o, i) : o >= s ? this.right.slice(o - s, i - s) : this.left.slice(o, s).append(this.right.slice(0, i - s));
      }, e.prototype.leafAppend = function(o) {
        var i = this.right.leafAppend(o);
        if (i)
          return new e(this.left, i);
      }, e.prototype.leafPrepend = function(o) {
        var i = this.left.leafPrepend(o);
        if (i)
          return new e(i, this.right);
      }, e.prototype.appendInner = function(o) {
        return this.left.depth >= Math.max(this.right.depth, o.depth) + 1 ? new e(this.left, new e(this.right, o)) : new e(this, o);
      }, e;
    }(xt);
    const jj = 500;
    class Rn {
      constructor(e, n) {
        this.items = e, this.eventCount = n;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(e, n) {
        if (this.eventCount == 0)
          return null;
        let o = this.items.length;
        for (; ; o--)
          if (this.items.get(o - 1).selection) {
            --o;
            break;
          }
        let i, s;
        n && (i = this.remapping(o, this.items.length), s = i.maps.length);
        let r = e.tr, a, l, c2 = [], u = [];
        return this.items.forEach((d, p2) => {
          if (!d.step) {
            i || (i = this.remapping(o, p2 + 1), s = i.maps.length), s--, u.push(d);
            return;
          }
          if (i) {
            u.push(new Vn(d.map));
            let m = d.step.map(i.slice(s)), f;
            m && r.maybeStep(m).doc && (f = r.mapping.maps[r.mapping.maps.length - 1], c2.push(new Vn(f, void 0, void 0, c2.length + u.length))), s--, f && i.appendMap(f, s);
          } else
            r.maybeStep(d.step);
          if (d.selection)
            return a = i ? d.selection.map(i.slice(s)) : d.selection, l = new Rn(this.items.slice(0, o).append(u.reverse().concat(c2)), this.eventCount - 1), false;
        }, this.items.length, 0), { remaining: l, transform: r, selection: a };
      }
      // Create a new branch with the given transform added.
      addTransform(e, n, o, i) {
        let s = [], r = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
        for (let u = 0; u < e.steps.length; u++) {
          let d = e.steps[u].invert(e.docs[u]), p2 = new Vn(e.mapping.maps[u], d, n), m;
          (m = l && l.merge(p2)) && (p2 = m, u ? s.pop() : a = a.slice(0, a.length - 1)), s.push(p2), n && (r++, n = void 0), i || (l = p2);
        }
        let c2 = r - o.depth;
        return c2 > Sj && (a = Ej(a, c2), r -= c2), new Rn(a.append(s), r);
      }
      remapping(e, n) {
        let o = new ys();
        return this.items.forEach((i, s) => {
          let r = i.mirrorOffset != null && s - i.mirrorOffset >= e ? o.maps.length - i.mirrorOffset : void 0;
          o.appendMap(i.map, r);
        }, e, n), o;
      }
      addMaps(e) {
        return this.eventCount == 0 ? this : new Rn(this.items.append(e.map((n) => new Vn(n))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(e, n) {
        if (!this.eventCount)
          return this;
        let o = [], i = Math.max(0, this.items.length - n), s = e.mapping, r = e.steps.length, a = this.eventCount;
        this.items.forEach((p2) => {
          p2.selection && a--;
        }, i);
        let l = n;
        this.items.forEach((p2) => {
          let m = s.getMirror(--l);
          if (m == null)
            return;
          r = Math.min(r, m);
          let f = s.maps[m];
          if (p2.step) {
            let _ = e.steps[m].invert(e.docs[m]), h2 = p2.selection && p2.selection.map(s.slice(l + 1, m));
            h2 && a++, o.push(new Vn(f, _, h2));
          } else
            o.push(new Vn(f));
        }, i);
        let c2 = [];
        for (let p2 = n; p2 < r; p2++)
          c2.push(new Vn(s.maps[p2]));
        let u = this.items.slice(0, i).append(c2).append(o), d = new Rn(u, a);
        return d.emptyItemCount() > jj && (d = d.compress(this.items.length - o.length)), d;
      }
      emptyItemCount() {
        let e = 0;
        return this.items.forEach((n) => {
          n.step || e++;
        }), e;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(e = this.items.length) {
        let n = this.remapping(0, e), o = n.maps.length, i = [], s = 0;
        return this.items.forEach((r, a) => {
          if (a >= e)
            i.push(r), r.selection && s++;
          else if (r.step) {
            let l = r.step.map(n.slice(o)), c2 = l && l.getMap();
            if (o--, c2 && n.appendMap(c2, o), l) {
              let u = r.selection && r.selection.map(n.slice(o));
              u && s++;
              let d = new Vn(c2.invert(), l, u), p2, m = i.length - 1;
              (p2 = i.length && i[m].merge(d)) ? i[m] = p2 : i.push(d);
            }
          } else r.map && o--;
        }, this.items.length, 0), new Rn(xt.from(i.reverse()), s);
      }
    }
    Rn.empty = new Rn(xt.empty, 0);
    function Ej(t2, e) {
      let n;
      return t2.forEach((o, i) => {
        if (o.selection && e-- == 0)
          return n = i, false;
      }), t2.slice(n);
    }
    class Vn {
      constructor(e, n, o, i) {
        this.map = e, this.step = n, this.selection = o, this.mirrorOffset = i;
      }
      merge(e) {
        if (this.step && e.step && !e.selection) {
          let n = e.step.merge(this.step);
          if (n)
            return new Vn(n.getMap().invert(), n, this.selection);
        }
      }
    }
    class jo {
      constructor(e, n, o, i, s) {
        this.done = e, this.undone = n, this.prevRanges = o, this.prevTime = i, this.prevComposition = s;
      }
    }
    const Sj = 20;
    function Cj(t2, e, n, o) {
      let i = n.getMeta(oi), s;
      if (i)
        return i.historyState;
      n.getMeta(Oj) && (t2 = new jo(t2.done, t2.undone, null, 0, -1));
      let r = n.getMeta("appendedTransaction");
      if (n.steps.length == 0)
        return t2;
      if (r && r.getMeta(oi))
        return r.getMeta(oi).redo ? new jo(t2.done.addTransform(n, void 0, o, Tr(e)), t2.undone, vp(n.mapping.maps), t2.prevTime, t2.prevComposition) : new jo(t2.done, t2.undone.addTransform(n, void 0, o, Tr(e)), null, t2.prevTime, t2.prevComposition);
      if (n.getMeta("addToHistory") !== false && !(r && r.getMeta("addToHistory") === false)) {
        let a = n.getMeta("composition"), l = t2.prevTime == 0 || !r && t2.prevComposition != a && (t2.prevTime < (n.time || 0) - o.newGroupDelay || !xj(n, t2.prevRanges)), c2 = r ? jl(t2.prevRanges, n.mapping) : vp(n.mapping.maps);
        return new jo(t2.done.addTransform(n, l ? e.selection.getBookmark() : void 0, o, Tr(e)), Rn.empty, c2, n.time, a ?? t2.prevComposition);
      } else return (s = n.getMeta("rebased")) ? new jo(t2.done.rebased(n, s), t2.undone.rebased(n, s), jl(t2.prevRanges, n.mapping), t2.prevTime, t2.prevComposition) : new jo(t2.done.addMaps(n.mapping.maps), t2.undone.addMaps(n.mapping.maps), jl(t2.prevRanges, n.mapping), t2.prevTime, t2.prevComposition);
    }
    function xj(t2, e) {
      if (!e)
        return false;
      if (!t2.docChanged)
        return true;
      let n = false;
      return t2.mapping.maps[0].forEach((o, i) => {
        for (let s = 0; s < e.length; s += 2)
          o <= e[s + 1] && i >= e[s] && (n = true);
      }), n;
    }
    function vp(t2) {
      let e = [];
      for (let n = t2.length - 1; n >= 0 && e.length == 0; n--)
        t2[n].forEach((o, i, s, r) => e.push(s, r));
      return e;
    }
    function jl(t2, e) {
      if (!t2)
        return null;
      let n = [];
      for (let o = 0; o < t2.length; o += 2) {
        let i = e.map(t2[o], 1), s = e.map(t2[o + 1], -1);
        i <= s && n.push(i, s);
      }
      return n;
    }
    function Tj(t2, e, n) {
      let o = Tr(e), i = oi.get(e).spec.config, s = (n ? t2.undone : t2.done).popEvent(e, o);
      if (!s)
        return null;
      let r = s.selection.resolve(s.transform.doc), a = (n ? t2.done : t2.undone).addTransform(s.transform, e.selection.getBookmark(), i, o), l = new jo(n ? a : s.remaining, n ? s.remaining : a, null, 0, -1);
      return s.transform.setSelection(r).setMeta(oi, { redo: n, historyState: l });
    }
    let El = false, bp = null;
    function Tr(t2) {
      let e = t2.plugins;
      if (bp != e) {
        El = false, bp = e;
        for (let n = 0; n < e.length; n++)
          if (e[n].spec.historyPreserveItems) {
            El = true;
            break;
          }
      }
      return El;
    }
    const oi = new Fe("history"), Oj = new Fe("closeHistory");
    function Nj(t2 = {}) {
      return t2 = {
        depth: t2.depth || 100,
        newGroupDelay: t2.newGroupDelay || 500
      }, new ze({
        key: oi,
        state: {
          init() {
            return new jo(Rn.empty, Rn.empty, null, 0, -1);
          },
          apply(e, n, o) {
            return Cj(n, o, e, t2);
          }
        },
        config: t2,
        props: {
          handleDOMEvents: {
            beforeinput(e, n) {
              let o = n.inputType, i = o == "historyUndo" ? N_ : o == "historyRedo" ? A_ : null;
              return i ? (n.preventDefault(), i(e.state, e.dispatch)) : false;
            }
          }
        }
      });
    }
    function O_(t2, e) {
      return (n, o) => {
        let i = oi.getState(n);
        if (!i || (t2 ? i.undone : i.done).eventCount == 0)
          return false;
        if (o) {
          let s = Tj(i, n, t2);
          s && o(s.scrollIntoView());
        }
        return true;
      };
    }
    const N_ = O_(false), A_ = O_(true), Aj = We.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state: t2, dispatch: e }) => N_(t2, e),
          redo: () => ({ state: t2, dispatch: e }) => A_(t2, e)
        };
      },
      addProseMirrorPlugins() {
        return [
          Nj(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-я": () => this.editor.commands.undo(),
          "Shift-Mod-я": () => this.editor.commands.redo()
        };
      }
    }), M_ = it.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["hr", Pe(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain: t2, state: e }) => {
            const { selection: n } = e, { $from: o, $to: i } = n, s = t2();
            return o.parentOffset === 0 ? s.insertContentAt({
              from: Math.max(o.pos - 1, 0),
              to: i.pos
            }, {
              type: this.name
            }) : Zf(n) ? s.insertContentAt(i.pos, {
              type: this.name
            }) : s.insertContent({ type: this.name }), s.command(({ tr: r, dispatch: a }) => {
              var l;
              if (a) {
                const { $to: c2 } = r.selection, u = c2.end();
                if (c2.nodeAfter)
                  c2.nodeAfter.isTextblock ? r.setSelection(re.create(r.doc, c2.pos + 1)) : c2.nodeAfter.isBlock ? r.setSelection(ie.create(r.doc, c2.pos)) : r.setSelection(re.create(r.doc, c2.pos));
                else {
                  const d = (l = c2.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                  d && (r.insert(u, d), r.setSelection(re.create(r.doc, u + 1)));
                }
                r.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          Ha({
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    }), Mj = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Rj = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Ij = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Dj = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, Lj = jn.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (t2) => t2.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (t2) => t2.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["em", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleItalic: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetItalic: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          ci({
            find: Mj,
            type: this.type
          }),
          ci({
            find: Ij,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Bo({
            find: Rj,
            type: this.type
          }),
          Bo({
            find: Dj,
            type: this.type
          })
        ];
      }
    }), Pj = it.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["li", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    }), Bj = "listItem", kp = "textStyle", yp = /^(\d+)\.\s$/, $j = it.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (t2) => t2.hasAttribute("start") ? parseInt(t2.getAttribute("start") || "", 10) : 1
          },
          type: {
            default: void 0,
            parseHTML: (t2) => t2.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        const { start: e, ...n } = t2;
        return e === 1 ? ["ol", Pe(this.options.HTMLAttributes, n), 0] : ["ol", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: t2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Bj, this.editor.getAttributes(kp)).run() : t2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let t2 = Di({
          find: yp,
          type: this.type,
          getAttributes: (e) => ({ start: +e[1] }),
          joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t2 = Di({
          find: yp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(kp) }),
          joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
          editor: this.editor
        })), [
          t2
        ];
      }
    }), R_ = it.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["p", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: t2 }) => t2.setNode(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    }), zj = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Fj = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Hj = jn.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (t2) => t2.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["s", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleStrike: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetStrike: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          ci({
            find: zj,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Bo({
            find: Fj,
            type: this.type
          })
        ];
      }
    }), Uj = it.create({
      name: "text",
      group: "inline"
    }), Vj = We.create({
      name: "starterKit",
      addExtensions() {
        var t2, e, n, o, i, s, r, a, l, c2, u, d, p2, m, f, _, h2, g;
        const k = [];
        return this.options.bold !== false && k.push(nj.configure((t2 = this.options) === null || t2 === void 0 ? void 0 : t2.bold)), this.options.blockquote !== false && k.push(E_.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && k.push(ij.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)), this.options.code !== false && k.push(aj.configure((o = this.options) === null || o === void 0 ? void 0 : o.code)), this.options.codeBlock !== false && k.push(S_.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)), this.options.document !== false && k.push(C_.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)), this.options.dropcursor !== false && k.push(pj.configure((r = this.options) === null || r === void 0 ? void 0 : r.dropcursor)), this.options.gapcursor !== false && k.push(kj.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && k.push(yj.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== false && k.push(x_.configure((c2 = this.options) === null || c2 === void 0 ? void 0 : c2.heading)), this.options.history !== false && k.push(Aj.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== false && k.push(M_.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== false && k.push(Lj.configure((p2 = this.options) === null || p2 === void 0 ? void 0 : p2.italic)), this.options.listItem !== false && k.push(Pj.configure((m = this.options) === null || m === void 0 ? void 0 : m.listItem)), this.options.orderedList !== false && k.push($j.configure((f = this.options) === null || f === void 0 ? void 0 : f.orderedList)), this.options.paragraph !== false && k.push(R_.configure((_ = this.options) === null || _ === void 0 ? void 0 : _.paragraph)), this.options.strike !== false && k.push(Hj.configure((h2 = this.options) === null || h2 === void 0 ? void 0 : h2.strike)), this.options.text !== false && k.push(Uj.configure((g = this.options) === null || g === void 0 ? void 0 : g.text)), k;
      }
    }), qj = (t2) => {
      if (!t2.children.length)
        return;
      const e = t2.querySelectorAll("span");
      e && e.forEach((n) => {
        var o, i;
        const s = n.getAttribute("style"), r = (i = (o = n.parentElement) === null || o === void 0 ? void 0 : o.closest("span")) === null || i === void 0 ? void 0 : i.getAttribute("style");
        n.setAttribute("style", `${r};${s}`);
      });
    }, Kj = jn.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return {
          HTMLAttributes: {},
          mergeNestedSpanStyles: false
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (t2) => t2.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && qj(t2), {}) : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["span", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle: () => ({ tr: t2 }) => {
            const { selection: e } = t2;
            return t2.doc.nodesBetween(e.from, e.to, (n, o) => {
              if (n.isTextblock)
                return true;
              n.marks.filter((i) => i.type === this.type).some((i) => Object.values(i.attrs).some((s) => !!s)) || t2.removeMark(o, o + n.nodeSize, this.type);
            }), true;
          }
        };
      }
    }), fe = /* @__PURE__ */ defineComponent({
      __name: "OIcon",
      props: {
        name: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        small: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("span", {
          class: normalizeClass(["o-icon", { small: t2.small }]),
          style: normalizeStyle({ color: t2.color })
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["yiitip-icon", `icon-${t2.name}`])
          }, null, 2)
        ], 6));
      }
    }), wp = {
      isoName: "en-us",
      nativeName: "English (US)",
      diagram: {
        name: "Text Diagram",
        flow: "Flow Diagram",
        sequence: "Sequence Diagram",
        class: "Class Diagram",
        state: "State Diagram",
        gantt: "Gantt Diagram",
        tips: "Generation of diagram and chart from text in a similar manner as markdown"
      },
      editor: {
        add: "Add",
        addMore: "Add More",
        url: "URL",
        bold: "Bold",
        italic: "Italic",
        strikethrough: "Strikethrough",
        underline: "Underline",
        textFormat: "More text format",
        list: "List",
        unorderedList: "Unordered List",
        orderedList: "Ordered List",
        todoList: "Todo List",
        subscript: "Subscript",
        superscript: "Superscript",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Toggle Fullscreen",
        quote: "Quote",
        left: "Left align",
        center: "Center align",
        right: "Right align",
        justify: "Justify align",
        print: "Print",
        outdent: "Decrease indentation",
        indent: "Increase indentation",
        indentDropdown: "Indent",
        removeFormat: "Remove formatting",
        formatting: "Formatting",
        fontFamily: "Font Family",
        defaultFont: "Default Font",
        fontSize: "Font Size",
        align: "Align",
        hr: "Insert Horizontal Rule",
        undo: "Undo",
        redo: "Redo",
        heading: "Heading & Paragraph",
        heading1: "Heading 1",
        heading2: "Heading 2",
        heading3: "Heading 3",
        heading4: "Heading 4",
        heading5: "Heading 5",
        headings: "Headings",
        paragraph: "Paragraph",
        code: "Code",
        codeBlock: "Code Block",
        size1: "Very small",
        size2: "A bit small",
        size3: "Normal",
        size4: "Medium-large",
        size5: "Big",
        size6: "Very big",
        size7: "Maximum",
        viewSource: "View Source",
        textColor: "Text Color",
        highlightColor: "Highlight Color",
        default: "Default",
        lineHeight: "Line Height",
        blockquote: "Blockquote",
        table: "Table",
        photo: "Insert Photo",
        video: "Insert Video",
        formula: "Formula",
        inlineFormula: "Inline",
        blockFormula: "Block",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancel",
        color: "Color",
        edit: "Edit",
        link: "Link",
        linkAddress: "Link Address",
        ok: "Ok",
        preview: "Preview",
        template: "Template",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        replace: "Replace",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        more: "More",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Image Preferences",
        ratio: "Ratio",
        size: "Size",
        width: "Width",
        height: "Height",
        src: "Image Source",
        caption: "Caption",
        link: "Link",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, Wj = {
      isoName: "pl",
      nativeName: "Polski",
      diagram: {
        name: "Schemat tekstowy",
        flow: "Schemat przepływu",
        sequence: "Schemat sekwencji",
        class: "Schemat klas",
        state: "Diagram stanu",
        gantt: "Diagram Gantta",
        tips: "Generowanie diagramu i wykresu z tekstu w podobny sposób jak markdown"
      },
      editor: {
        add: "Dodaj",
        addMore: "Dodaj więcej",
        url: "URL",
        bold: "Pogrubienie",
        italic: "Kursywa",
        strikethrough: "Przekreślenie",
        underline: "Podkreślenie",
        textFormat: "More text format",
        unorderedList: "Lista wypunktowana",
        orderedList: "Lista numerowana",
        list: "List",
        todoList: "Lista rzeczy do zrobienia",
        subscript: "Indeks dolny",
        superscript: "Indeks górny",
        hyperlink: "Hiperłącze",
        toggleFullscreen: "Przełącz na tryb pełnoekranowy",
        quote: "Zacytuj",
        left: "Wyrównaj do lewej",
        center: "Wyrównaj do środka",
        right: "Wyrównaj do prawej",
        justify: "Wyjustuj",
        print: "Drukuj",
        outdent: "Zmniejsz wcięcie",
        indent: "Zwiększ wcięcie",
        indentDropdown: "Wcięcie",
        removeFormat: "Usuń formatowanie",
        formatting: "Formatowanie",
        fontFamily: "Nazwa czcionki",
        defaultFont: "Domyślna czcionka",
        fontSize: "Rozmiar czcionki",
        align: "Wyrównanie",
        hr: "Wstaw poziomą linię",
        undo: "Cofnij",
        redo: "Przywróć",
        heading: "Heading & Paragraph",
        heading1: "Nagłówek 1",
        heading2: "Nagłówek 2",
        heading3: "Nagłówek 3",
        heading4: "Nagłówek 4",
        heading5: "Nagłówek 5",
        headings: "Nagłówki",
        paragraph: "Paragraf",
        code: "Kod",
        codeBlock: "Blok kodu",
        size1: "Bardzo mała",
        size2: "Mała",
        size3: "Normalna",
        size4: "Średnio-duża",
        size5: "Duża",
        size6: "Bardzo duża",
        size7: "Maksymalna",
        viewSource: "Pokaż źródło",
        textColor: "Kolor czcionki",
        highlightColor: "Kolor wyróżnienia",
        default: "Dymyślny",
        lineHeight: "Wysokość linii",
        blockquote: "Cytat",
        table: "Tabela",
        photo: "Wstaw obraz",
        video: "Insert Video",
        formula: "Formuła",
        inlineFormula: "Formuła w treści",
        blockFormula: "Blokowa formuła",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Anuluj",
        edit: "Edycja",
        link: "Łącze",
        linkAddress: "Adres łącza",
        ok: "Ok",
        preview: "Podgląd",
        template: "Szablon",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferencje obrazu",
        ratio: "Ratio",
        size: "Rozmiar",
        width: "Szerokość",
        height: "Wysokość",
        src: "Źródło obrazu",
        caption: "Nagłówek",
        link: "Łącze",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, Gj = {
      isoName: "pt-br",
      nativeName: "Português (BR)",
      diagram: {
        name: "Diagrama de Texto",
        flow: "Diagrama de Fluxo",
        sequence: "Diagrama de sequência",
        class: "Diagrama de Classe",
        state: "Diagrama de Estado",
        gantt: "Diagrama de Gantt",
        tips: "Geração de diagrama ou gráfico a partir de texto semelhante a markdown"
      },
      editor: {
        add: "Adicionar",
        addMore: "Adicione Mais",
        url: "URL",
        bold: "Negrito",
        italic: "Itálico",
        strikethrough: "Tachar",
        underline: "Sublinhado",
        textFormat: "Mais formatos de textos",
        list: "Lista",
        unorderedList: "Lista com Marcadores",
        orderedList: "Lista Numerada",
        todoList: "Lista de afazer",
        subscript: "Subscrito",
        superscript: "Sobrescrito",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Alternar tela-cheia",
        quote: "Citação",
        left: "Alinhar à esquerda",
        center: "Alinhar ao centro",
        right: "Alinhar à direita",
        justify: "Justificar",
        print: "Imprimir",
        outdent: "Diminuir recuo",
        indent: "Aumentar recuo",
        indentDropdown: "Recuo",
        removeFormat: "Limpar formatação",
        formatting: "Formatação",
        fontFamily: "Fonte",
        defaultFont: "Fonte Padrão",
        fontSize: "Tamanho da fontee",
        align: "Alinhamento",
        hr: "Linha Horizontal",
        undo: "Desfazer",
        redo: "Refazer",
        heading: "Heading & Paragraph",
        heading1: "Título 1",
        heading2: "Título 2",
        heading3: "Título 3",
        heading4: "Título 4",
        heading5: "Título 5",
        headings: "Estilos de Parágrafo",
        paragraph: "Parágrafo",
        code: "Código",
        codeBlock: "Bloco de Código",
        size1: "Muito Pequeno",
        size2: "Pequeno",
        size3: "Normal",
        size4: "Médio",
        size5: "Grande",
        size6: "Enorme",
        size7: "Máximo",
        viewSource: "Código Fonte",
        textColor: "Cor do texto",
        highlightColor: "Cor do fundo",
        default: "Padrão",
        lineHeight: "Espaço entre linhas",
        blockquote: "Bloco de citação",
        table: "Tabela",
        photo: "Inserir Foto",
        video: "Insert Video",
        formula: "Fórmula",
        inlineFormula: "Linha",
        blockFormula: "Bloco",
        thirdPartyService: "Serviços de terceiros",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancelar",
        edit: "Editar",
        link: "Link",
        linkAddress: "Endereço do Link",
        ok: "Ok",
        preview: "Pré Visualização",
        template: "Modelo",
        example: "Exemplo",
        submit: "Enviar",
        settings: "Configurações",
        remove: "Excluir",
        help: "Ajuda",
        back: "Voltar",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferências da Imagem",
        ratio: "Ratio",
        size: "Tamanho",
        width: "Largura",
        height: "Altura",
        src: "Origem da imagem",
        caption: "Legenda",
        link: "Link",
        lockAspectRatio: "Bloquear proporção",
        unlockAspectRatio: "Desbloquear proporção",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Vídeo",
        map: "Mapa",
        design: "Design",
        develop: "Desenvolvimento",
        data: "Dados",
        others: "Outros",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, jp = {
      isoName: "zh-hans",
      nativeName: "简体中文",
      diagram: {
        name: "文本绘图",
        flow: "流程图",
        sequence: "时序图",
        class: "类图",
        state: "状态图",
        gantt: "甘特图",
        tips: "使用Markdown风格文本生成流程图、顺序图、类图、状态图和甘特图"
      },
      editor: {
        add: "添加",
        addMore: "添加更多",
        url: "URL",
        bold: "粗体",
        italic: "斜体",
        strikethrough: "删除线",
        underline: "下划线",
        textFormat: "更多格式",
        list: "列表",
        unorderedList: "无序列表",
        orderedList: "有序列表",
        todoList: "任务列表",
        subscript: "下标",
        superscript: "上标",
        hyperlink: "超链接",
        toggleFullscreen: "全屏切换",
        quote: "引号",
        left: "左对齐",
        center: "居中对齐",
        right: "右对齐",
        justify: "两端对齐",
        print: "打印",
        outdent: "减少缩进",
        indent: "增加缩进",
        indentDropdown: "缩进",
        removeFormat: "清除格式",
        formatting: "格式化",
        fontFamily: "字体",
        defaultFont: "默认字体",
        fontSize: "字体大小",
        align: "对齐方式",
        hr: "插入分割线",
        undo: "撤消",
        redo: "重做",
        heading: "标题与段落",
        heading1: "标题一",
        heading2: "标题二",
        heading3: "标题三",
        heading4: "标题四",
        heading5: "标题五",
        headings: "标题",
        paragraph: "正文",
        code: "代码",
        codeBlock: "代码块",
        size1: "非常小",
        size2: "比较小",
        size3: "正常",
        size4: "中等偏大",
        size5: "大",
        size6: "非常大",
        size7: "超级大",
        viewSource: "查看资料",
        textColor: "文字颜色",
        highlightColor: "背景颜色",
        default: "默认",
        lineHeight: "行高",
        blockquote: "引用",
        table: "表格",
        photo: "图片",
        video: "视频",
        formula: "数学公式",
        inlineFormula: "行内公式",
        blockFormula: "块级公式",
        thirdPartyService: "第三方服务",
        horizontal: "水平线",
        callout: "高亮块",
        emoji: "表情",
        defaultColor: "默认颜色",
        noColor: "无色",
        delete: "删除",
        duplicate: "创建副本"
      },
      label: {
        ai: "AI",
        cancel: "取消",
        color: "颜色",
        edit: "编辑",
        link: "链接",
        linkAddress: "链接地址",
        ok: "确定",
        preview: "预览",
        template: "模板",
        example: "示例",
        submit: "确定",
        settings: "设置",
        remove: "删除",
        replace: "替换",
        help: "帮助",
        back: "返回",
        styles: "样式",
        basic: "基础",
        basicBlocks: "基础块",
        common: "常用",
        media: "多媒体",
        image: "图片",
        video: "视频",
        model: "模型",
        modelViewer: "模型",
        more: "更多",
        toc: "目录",
        untitled: "未命名",
        typeForCommands: "输入 '/' 显示命令",
        empty: "空白页面",
        emptyTips: "按回车开始编辑，或从下方选择",
        copy: "复制",
        cut: "剪切",
        search: "搜索"
      },
      table: {
        cellBackground: "单元格背景色",
        insert: "插入表格",
        remove: "删除表格",
        addColumn: "添加列",
        removeColumn: "删除列",
        addRow: "添加行",
        removeRow: "删除行",
        merge: "合并/拆分 单元格"
      },
      image: {
        preferences: "图片设置",
        ratio: "比例",
        size: "尺寸",
        width: "宽度",
        height: "高度",
        src: "图片地址",
        caption: "图片说明",
        link: "链接",
        lockAspectRatio: "锁定长宽比",
        unlockAspectRatio: "解锁长宽比",
        original: "原始",
        small: "小",
        medium: "中",
        large: "大"
      },
      embed: {
        video: "视频",
        map: "地图",
        design: "设计",
        develop: "开发",
        data: "数据",
        others: "其它",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "优酷",
        iqiyi: "爱奇艺",
        bilibili: "Bilibili",
        qqvideo: "腾讯视频",
        google_map: "谷歌地图",
        amap: "高德地图",
        baidu_map: "百度",
        modao: "墨刀",
        lanhu: "蓝湖",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "金数据",
        iframe: "IFrame",
        linkTips: "链接或代码",
        linkWarning: "无效的链接"
      },
      link: {
        back: "返回主菜单",
        edit: "编辑链接",
        off: "取消链接",
        open: "打开链接",
        open_in_new_tab: "在新标签页打开"
      }
    }, Jj = {
      isoName: "zh-hant",
      nativeName: "繁體中文",
      diagram: {
        name: "文本繪圖",
        flow: "流程圖",
        sequence: "時序圖",
        class: "類圖",
        state: "狀態圖",
        gantt: "甘特圖",
        tips: "使用Markdown風格文本生成流程圖、順序圖、類圖、狀態圖和甘特圖"
      },
      editor: {
        add: "添加",
        addMore: "添加更多",
        url: "URL",
        bold: "粗體",
        italic: "斜體",
        strikethrough: "刪除線",
        underline: "下劃線",
        textFormat: "更多格式",
        list: "列表",
        unorderedList: "無序列表",
        orderedList: "有序列表",
        todoList: "任務列表",
        subscript: "下標",
        superscript: "上標",
        hyperlink: "超鏈接",
        toggleFullscreen: "全屏切換",
        quote: "引號",
        left: "左對齊",
        center: "居中對齊",
        right: "右對齊",
        justify: "兩端對齊",
        print: "打印",
        outdent: "減少縮進",
        indent: "增加縮進",
        indentDropdown: "縮進",
        removeFormat: "清除格式",
        formatting: "格式化",
        fontFamily: "字體",
        defaultFont: "默認字體",
        fontSize: "字體大小",
        align: "對齊方式",
        hr: "插入分割線",
        undo: "撤消",
        redo: "重做",
        heading: "標題與段落",
        heading1: "標題一",
        heading2: "標題二",
        heading3: "標題三",
        heading4: "標題四",
        heading5: "標題五",
        headings: "標題",
        paragraph: "正文",
        code: "代碼",
        codeBlock: "代碼塊",
        size1: "非常小",
        size2: "比較小",
        size3: "正常",
        size4: "中等偏大",
        size5: "大",
        size6: "非常大",
        size7: "超級大",
        viewSource: "查看資料",
        textColor: "文字顏色",
        highlightColor: "背景顏色",
        default: "默認",
        lineHeight: "行高",
        blockquote: "引用",
        table: "表格",
        photo: "圖片",
        video: "視頻",
        formula: "數學公式",
        inlineFormula: "行內公式",
        blockFormula: "塊級公式",
        thirdPartyService: "第三方服務",
        horizontal: "水平線",
        callout: "高亮塊",
        emoji: "表情",
        defaultColor: "默認顏色",
        noColor: "無色",
        delete: "刪除",
        duplicate: "創建副本"
      },
      label: {
        ai: "AI",
        cancel: "取消",
        edit: "編輯",
        link: "鏈接",
        linkAddress: "鏈接地址",
        ok: "確定",
        preview: "預覽",
        template: "模板",
        example: "示例",
        submit: "確定",
        settings: "設置",
        remove: "刪除",
        help: "幫助",
        back: "返回",
        styles: "樣式",
        basic: "基础",
        basicBlocks: "基础块",
        common: "常用",
        media: "多媒體",
        image: "圖片",
        video: "視頻",
        model: "模型",
        modelViewer: "模型",
        toc: "目錄",
        untitled: "未命名",
        typeForCommands: "輸入 '/' 顯示命令",
        empty: "空白页面",
        emptyTips: "按回车开始编辑，或从下方选择",
        copy: "複製",
        cut: "剪切",
        search: "搜索"
      },
      table: {
        cellBackground: "單元格背景色",
        insert: "插入表格",
        remove: "刪除表格",
        addColumn: "添加列",
        removeColumn: "刪除列",
        addRow: "添加行",
        removeRow: "刪除行",
        merge: "合併/拆分 單元格"
      },
      image: {
        preferences: "圖片設置",
        ratio: "比例",
        size: "尺寸",
        width: "寬度",
        height: "高度",
        src: "圖片地址",
        caption: "圖片說明",
        link: "鏈接",
        lockAspectRatio: "鎖定長寬比",
        unlockAspectRatio: "解鎖長寬比",
        original: "原始",
        small: "小",
        medium: "中",
        large: "大"
      },
      embed: {
        video: "視頻",
        map: "地圖",
        design: "設計",
        develop: "開發",
        data: "數據",
        others: "其它",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "優酷",
        iqiyi: "愛奇藝",
        bilibili: "Bilibili",
        qqvideo: "騰訊視頻",
        google_map: "谷歌地圖",
        amap: "高德地圖",
        baidu_map: "百度",
        modao: "墨刀",
        lanhu: "藍湖",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "金數據",
        iframe: "IFrame",
        linkTips: "鏈接或代碼",
        linkWarning: "無效的鏈接"
      },
      link: {
        back: "返回主菜單",
        edit: "編輯鏈接",
        off: "取消鏈接",
        open: "打開鏈接",
        open_in_new_tab: "在新標籤頁打開"
      }
    }, I_ = {
      en: wp,
      "en-us": wp,
      pl: Wj,
      "pt-br": Gj,
      zh: jp,
      "zh-hans": jp,
      "zh-hant": Jj
    }, Yj = "en", Xj = I_[Yj], Zj = (t2) => I_[t2] || Xj;
    function Ae() {
      const t2 = inject("locale", { value: "en" }), e = computed(() => Zj(t2.value));
      function n(o) {
        return o.split(".").reduce((i, s) => {
          if (i) return i[s];
        }, e.value);
      }
      return {
        locale: t2,
        message: e,
        tr: n
      };
    }
    function Va() {
      const t2 = inject("darkMode", { value: false }), e = computed(() => t2.value ? "dark" : "light");
      return {
        darkMode: t2,
        theme: e
      };
    }
    function Be() {
      const t2 = inject("isEditable", { value: true });
      function e(o, i, s = {}) {
        if (!o.isEditable) return;
        const r = o == null ? void 0 : o.chain().focus(), a = o == null ? void 0 : o.commands;
        n(a, r, i, s);
      }
      function n(o, i, s, r = {}) {
        switch (console.log("command", s, r), s) {
          // case 'aiViewer':
          // 	focus.setAiViewer({
          // 		content: 'init',
          // 	}).run()
          // 	break
          case "backColor":
            r.color ? o.setHighlight({ color: r.color }) : o.unsetHighlight();
            break;
          case "blockquote":
            i.toggleBlockquote().run();
            break;
          case "bold":
            i.toggleBold().run();
            break;
          case "bulletList":
            i.toggleBulletList().run();
            break;
          case "callout":
            i.toggleCallout().run();
            break;
          case "clearFormat":
            i.unsetAllMarks().run();
            break;
          case "code":
            i.toggleCode().run();
            break;
          case "codeBlock":
            o.toggleCodeBlock({ language: "bash" });
            break;
          // case 'columns':
          // 	commands.setColumns(2)
          // 	break
          case "content":
            o.insertContent(r.content);
            break;
          case "fontFamily":
            o.setFontFamily(r.fontFamily);
            break;
          case "foreColor":
            o.setColor(r.color);
            break;
          case "heading":
            i.toggleHeading(r).run();
            break;
          case "horizontalRule":
            i.setHorizontalRule().run();
            break;
          case "image":
            i.setImage({
              src: "init"
            }).run();
            break;
          case "imageUpdate":
            i.setImage(
              r
            ).run();
            break;
          case "italic":
            i.toggleItalic().run();
            break;
          case "linkSet":
            i.extendMarkRange("link").setLink(
              r
            ).run();
            break;
          case "linkUnset":
            i.extendMarkRange("link").unsetLink().run();
            break;
          // case 'modelViewer':
          // 	focus.setModelViewer({
          // 		src: 'init',
          // 	}).run()
          // 	break
          // case 'modelViewerUpdate':
          // 	focus.setModelViewer(options).run()
          // 	break
          case "orderedList":
            i.toggleOrderedList().run();
            break;
          case "paragraph":
            i.setParagraph().run();
            break;
          case "strike":
            i.toggleStrike().run();
            break;
          case "table":
            i.insertTable({
              rows: 3,
              cols: 3,
              withHeaderRow: true
            }).run();
            break;
          case "tableAddColumn":
            i.addColumnAfter().run();
            break;
          case "tableAddRow":
            i.addRowAfter().run();
            break;
          case "tableCellAttribute":
            i.setCellAttribute(r.name, r.value).run();
            break;
          case "tableDeleteColumn":
            i.deleteColumn().run();
            break;
          case "tableDeleteRow":
            i.deleteRow().run();
            break;
          case "tableDelete":
            i.deleteTable().run();
            break;
          case "tableInsert":
            i.insertTable(r).run();
            break;
          case "tableMergeCells":
            i.mergeCells().run();
            break;
          case "tableSelectColumn":
            i.selectColumn(r.pos).run();
            break;
          case "tableSelectRow":
            i.selectRow(r.pos).run();
            break;
          case "tableSplitCell":
            i.splitCell().run();
            break;
          case "taskList":
            o.toggleTaskList();
            break;
          case "textAlign":
            i.setTextAlign(r.textAlign).run();
            break;
          case "underline":
            i.toggleUnderline().run();
            break;
          case "video":
            i.setVideo({
              src: "init"
            }).run();
        }
      }
      return {
        isEditable: t2,
        run: e,
        onCommand: n
      };
    }
    const Uo = /* @__PURE__ */ defineComponent({
      __name: "OTooltip",
      props: {
        placement: {
          type: String,
          default: "top"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
          // default: 'click'
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 100
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        }
      },
      setup(t2) {
        const e = t2, { theme: n } = Va(), o = ref(), i = ref(), s = ref();
        function r() {
          s.value = Ln(o.value, {
            appendTo: () => document.body,
            animation: "perspective",
            // scale, shift-away
            content: i.value,
            duration: e.duration,
            delay: e.delay,
            interactive: true,
            offset: e.offset,
            placement: e.placement,
            trigger: e.trigger
          });
        }
        function a() {
          s.value.setProps({
            theme: n.value
          });
        }
        return watch(n, (l) => {
          a();
        }), onMounted(() => {
          r();
        }), (l, c2) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: o,
          "data-tippy-role": "tooltip"
        }, [
          renderSlot(l.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: i,
            class: "tooltip-content"
          }, [
            renderSlot(l.$slots, "default")
          ], 512)
        ], 512));
      }
    }), Ye = /* @__PURE__ */ defineComponent({
      __name: "OMenubarBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (o, i) => (openBlock(), createBlock(Uo, {
          class: "o-tooltip",
          placement: t2.placement
        }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: i[0] || (i[0] = (s) => n("click", s))
            }, [
              createVNode(fe, {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"])
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 1
        }, 8, ["placement"]));
      }
    }), Qj = /* @__PURE__ */ defineComponent({
      __name: "OSimpleCommandBtn",
      props: {
        name: {
          type: String,
          default: ""
        },
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { run: n } = Be(), { tr: o } = Ae(), i = computed(() => ({
          aiViewer: { icon: "auto_awesome", tooltip: o("label.ai") },
          blockquote: { icon: "format_quote_open", tooltip: o("editor.blockquote") },
          bold: { icon: "format_bold", tooltip: o("editor.bold") },
          callout: { icon: "card_text", tooltip: o("editor.callout") },
          clearFormat: { icon: "format_clear", tooltip: o("editor.removeFormat") },
          code: { icon: "code", tooltip: o("editor.code") },
          codeBlock: { icon: "code_braces", tooltip: o("editor.codeBlock") },
          columns: {
            icon: "splitscreen_vertical_add",
            tooltip: "Column",
            rotate: true
          },
          horizontalRule: { icon: "horizontal_rule", tooltip: o("editor.hr") },
          italic: { icon: "format_italic", tooltip: o("editor.italic") },
          image: { icon: "image", tooltip: o("editor.photo") },
          linkUnset: { icon: "link_off", tooltip: o("link.off") },
          modelViewer: { icon: "3d_rotation", tooltip: o("label.modelViewer") },
          strike: {
            icon: "format_strikethrough",
            tooltip: o("editor.strikethrough")
          },
          underline: { icon: "format_underlined", tooltip: o("editor.underline") },
          video: { icon: "videocam", tooltip: o("editor.video") }
        })), s = computed(() => i.value[e.name] || {
          icon: "",
          isActive: false,
          command: () => {
          }
        });
        function r() {
          n(e.editor, e.name);
        }
        return (a, l) => {
          var c2;
          return openBlock(), createBlock(Ye, {
            class: "o-simple-command-btn",
            icon: s.value.icon,
            tooltip: s.value.tooltip,
            "content-class": {
              "is-active": (c2 = t2.editor) == null ? void 0 : c2.isActive(t2.name),
              "rotate-90": s.value.rotate
            },
            onClick: r
          }, null, 8, ["icon", "tooltip", "content-class"]);
        };
      }
    }), e1 = { class: "o-block-placeholder" }, t1 = { class: "icon" }, n1 = { class: "placeholder" }, D_ = /* @__PURE__ */ defineComponent({
      __name: "OBlockPlaceholder",
      props: {
        icon: {
          type: String,
          default: "image"
        },
        placeholder: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("section", e1, [
          createBaseVNode("div", t1, [
            createVNode(unref(fe), { name: t2.icon }, null, 8, ["name"])
          ]),
          createBaseVNode("div", n1, toDisplayString(t2.placeholder), 1)
        ]));
      }
    }), Ve = {
      amber: "#ffc107",
      blue: "#2172e0",
      brown: "#795548",
      cyan: "#00bcd4",
      deepOrange: "#ff5722",
      deepPurple: "#673ab7",
      green: "#4caf50",
      indigo: "#3f51b5",
      lightBlue: "#03a9f4",
      lightGreen: "#8bc34a",
      lime: "#cddc39",
      orange: "#ff9800",
      purple: "#9c27b0",
      pink: "#e91e63",
      red: "#f44336",
      teal: "#009688",
      yellow: "#ffeb3b"
    }, Ws = [
      {
        label: "editor.paragraph",
        value: "paragraph",
        icon: "title",
        // title, format_paragraph, local_parking
        color: "",
        style: true,
        group: "label.basic"
      },
      {
        label: "editor.heading1",
        value: "heading",
        icon: "format_h1",
        color: Ve.blue,
        style: true,
        options: { level: 1 }
      },
      {
        label: "editor.heading2",
        value: "heading",
        icon: "format_h2",
        color: Ve.blue,
        style: true,
        options: { level: 2 }
      },
      {
        label: "editor.heading3",
        value: "heading",
        icon: "format_h3",
        color: Ve.blue,
        style: true,
        options: { level: 3 }
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        color: Ve.indigo,
        style: true
      },
      {
        label: "editor.unorderedList",
        value: "bulletList",
        icon: "format_list_bulleted",
        color: Ve.indigo,
        style: true
      },
      {
        label: "editor.orderedList",
        value: "orderedList",
        icon: "format_list_numbered",
        color: Ve.indigo,
        style: true
      },
      {
        label: "editor.blockquote",
        value: "blockquote",
        icon: "format_quote_open",
        color: Ve.brown,
        style: true
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        color: Ve.lightBlue,
        style: true
      },
      {
        label: "editor.horizontal",
        value: "horizontalRule",
        icon: "horizontal_rule",
        color: Ve.blue
      },
      {
        label: "editor.callout",
        value: "callout",
        color: Ve.deepOrange,
        icon: "card_text",
        style: false
      },
      {
        label: "editor.emoji",
        value: "emoji",
        icon: "emoji_emotions",
        color: Ve.blue
      }
    ], Yr = Ws.filter((t2) => t2.style), Ms = [
      {
        label: "label.ai",
        value: "aiViewer",
        icon: "auto_awesome",
        color: Ve.purple,
        tips: "ai",
        group: "label.ai"
      },
      {
        label: "editor.callout",
        value: "callout",
        icon: "card_text",
        color: Ve.deepOrange,
        tips: "callout",
        group: "label.common"
      },
      {
        label: "editor.table",
        value: "table",
        icon: "window",
        tips: "table",
        color: Ve.cyan
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        tips: "code",
        color: Ve.blue
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        tips: "task",
        color: Ve.indigo
      },
      {
        label: "label.image",
        value: "image",
        icon: "image",
        color: Ve.amber,
        tips: "image",
        group: "label.media"
      },
      {
        label: "label.video",
        value: "video",
        icon: "videocam",
        tips: "video",
        color: Ve.purple
      },
      {
        label: "label.model",
        value: "modelViewer",
        icon: "3d_rotation",
        tips: "model",
        color: Ve.purple
      }
    ], cu = [...Ws, ...Ms], Ep = [
      {
        label: "editor.duplicate",
        value: "duplicate",
        icon: "content_copy",
        color: Ve.blue,
        tips: "Ctrl+D",
        group: "label.common",
        filter: "common"
      },
      {
        label: "editor.delete",
        value: "delete",
        icon: "delete",
        tips: "Ctrl+D",
        color: Ve.deepOrange,
        filter: "common"
      },
      {
        label: "label.replace",
        value: "replace",
        icon: "cached",
        tips: "Ctrl+R",
        color: Ve.blue,
        filter: "image,video,model"
      },
      {
        label: "label.color",
        value: "palette",
        icon: "palette",
        color: Ve.purple,
        filter: "callout",
        component: "OCalloutColorBoard"
      }
    ], o1 = {
      key: 1,
      class: "group o-tips"
    }, i1 = { class: "suffix o-tips" }, s1 = {
      key: 1,
      class: "item"
    }, Vi = /* @__PURE__ */ defineComponent({
      __name: "OBlockMenu",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        },
        colorful: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: Boolean,
          default: false
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: i } = Ae(), s = ref([]), r = computed(() => {
          var m;
          return (m = n.node) == null ? void 0 : m.type.name;
        }), a = computed(() => {
          const m = Ep.filter(
            (_) => {
              var h2;
              return ((h2 = _.filter) == null ? void 0 : h2.indexOf("common")) >= 0;
            }
          ), f = Ep.filter(
            (_) => {
              var h2;
              return ((h2 = _.filter) == null ? void 0 : h2.indexOf(r.value)) >= 0;
            }
          );
          if (f.length > 0) {
            const _ = f[0];
            _.group = `editor.${r.value}`;
          }
          return [...m, ...f];
        });
        function l(m) {
          switch (m.component) {
            case "OCalloutColorBoard":
              return P_;
            default:
              return null;
          }
        }
        function c2(m) {
          o("action", m), setTimeout(() => {
            u(m);
          }, 0);
        }
        function u(m) {
          switch (m.value) {
            case "delete":
              n.deleteNode();
              break;
            case "duplicate":
              d();
              break;
          }
        }
        function d() {
          var g, k, j;
          const m = n.node.nodeSize, f = n.getPos() + m, _ = JSON.parse(JSON.stringify(n.node));
          (g = n.editor) == null || g.commands.insertContentAt(f, {
            type: "paragraph"
          }), (k = n.editor) == null || k.commands.insertContentAt(f, _);
          const h2 = f + m + 1;
          (j = n.editor) == null || j.commands.focus(h2);
        }
        function p2(m, f) {
          switch (console.log("select", m, f), f.name) {
            case "backColor":
              n.updateAttributes({ backColor: f.value });
              break;
            case "foreColor":
              n.updateAttributes({ borderColor: f.value });
              break;
          }
        }
        return (m, f) => (openBlock(), createBlock(unref(Bn), {
          class: "o-block-menu",
          hoverable: "",
          clickable: ""
        }, {
          default: withCtx(() => [
            a.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(a.value, (_, h2) => (openBlock(), createElementBlock(Fragment, { key: h2 }, [
              _.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                h2 > 0 ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                t2.showGroup ? (openBlock(), createElementBlock("div", o1, toDisplayString(unref(i)(_.group)), 1)) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true),
              l(_) ? (openBlock(), createBlock(unref(Qe), {
                key: 1,
                ref_for: true,
                ref: s.value[_.value],
                offset: [0, 16],
                placement: "right"
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(xn), {
                    class: "item",
                    clickable: ""
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: _.icon,
                        color: t2.colorful ? _.color : ""
                      }, null, 8, ["name", "color"])
                    ]),
                    suffix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: "navigate_next",
                        class: "o-tips"
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i)(_.label)), 1)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(l(_)), {
                    onSelect: (g) => p2(_, g)
                  }, null, 40, ["onSelect"]))
                ]),
                _: 2
              }, 1536)) : (openBlock(), createBlock(unref(xn), {
                key: 2,
                class: "item",
                clickable: "",
                onClick: (g) => c2(_)
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(fe), {
                    name: _.icon,
                    color: t2.colorful ? _.color : ""
                  }, null, 8, ["name", "color"])
                ]),
                suffix: withCtx(() => [
                  createBaseVNode("div", i1, toDisplayString(_.tips), 1)
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString(unref(i)(_.label)), 1)
                ]),
                _: 2
              }, 1032, ["onClick"]))
            ], 64))), 128)) : (openBlock(), createElementBlock("div", s1, "No result"))
          ]),
          _: 1
        }));
      }
    }), Rs = /* @__PURE__ */ defineComponent({
      __name: "OBlockPopover",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        placement: {
          type: String,
          default: "bottom-center"
        },
        showArrow: {
          type: Boolean,
          default: false
        },
        hideClickOutside: {
          type: Boolean,
          default: false
        },
        tippyClass: {
          type: String,
          default: ""
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        }
      },
      emits: ["update:modelValue", "show", "hide"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = ref();
        function s(a) {
          o("update:modelValue", a);
        }
        function r() {
          n.hideClickOutside && o("update:modelValue", false);
        }
        return watch(
          () => n.modelValue,
          (a) => {
            var l, c2;
            console.log("modelValue", a), a ? (l = i.value) == null || l.setShow(true) : (c2 = i.value) == null || c2.setShow(false);
          }
        ), onMounted(() => {
          var a;
          n.modelValue && ((a = i.value) == null || a.setShow(true));
        }), (a, l) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          placement: t2.placement,
          "tippy-class": t2.tippyClass,
          trigger: "manual",
          arrow: t2.showArrow,
          offset: t2.offset,
          show: t2.modelValue,
          "onUpdate:show": s,
          onClickoutside: r
        }, {
          trigger: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          default: withCtx(() => [
            renderSlot(a.$slots, "popover-content")
          ]),
          _: 3
        }, 8, ["placement", "tippy-class", "arrow", "offset", "show"]));
      }
    }), r1 = { class: "o-block-toolbar editable-only" }, a1 = { class: "button-group" }, L_ = /* @__PURE__ */ defineComponent({
      __name: "OBlockToolbar",
      props: {
        ...Ot,
        type: {
          type: String,
          default: "link"
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: s } = Ae(), r = ref();
        function a(l) {
          var c2;
          o("action", l), (c2 = r.value) == null || c2.setShow(false);
        }
        return (l, c2) => (openBlock(), createElementBlock("div", r1, [
          createBaseVNode("section", a1, [
            renderSlot(l.$slots, "default"),
            createVNode(unref(Qe), {
              ref_key: "popover",
              ref: r,
              placement: "bottom-end",
              size: "medium",
              trigger: "click",
              "show-arrow": false
            }, {
              trigger: withCtx(() => [
                createVNode(unref(St), {
                  icon: "more_horiz",
                  tooltip: unref(s)("label.more")
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createVNode(unref(Vi), mergeProps(n, { onAction: a }), null, 16)
              ]),
              _: 1
            }, 512)
          ])
        ]));
      }
    }), l1 = { class: "o-callout-color-board" }, c1 = { class: "fore-colors" }, u1 = { class: "color-row" }, d1 = { class: "color-row" }, p1 = { class: "back-colors" }, m1 = { class: "color-row" }, f1 = { class: "color-row" }, P_ = /* @__PURE__ */ defineComponent({
      __name: "OCalloutColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e;
        function o(r, a) {
          n("select", {
            name: r,
            value: a.value
          });
        }
        const i = computed(() => [
          { label: "Grey", value: "#e9e9e9" },
          { label: "Brown", value: "#ffd591" },
          { label: "Orange", value: "#ffbb96" },
          { label: "Yellow", value: "#fff08f" },
          { label: "Green", value: "#b7eb8f" },
          { label: "Blue", value: "#91d5ff" },
          { label: "Purple", value: "#d3adf7" },
          { label: "Pink", value: "#ffadd2" },
          { label: "Red", value: "#ffa39e" }
        ]), s = computed(() => [
          { label: "Grey", value: "#F5F5F5" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (r, a) => (openBlock(), createElementBlock("section", l1, [
          createBaseVNode("section", c1, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Border color", -1)),
            createBaseVNode("div", u1, [
              createVNode(unref(Ye), {
                icon: "slash_forward",
                tooltip: "No color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => o("foreColor", { value: "" }))
              }),
              t2.foreColor ? (openBlock(), createBlock(unref(Ye), {
                key: 0,
                tooltip: "Last used",
                "content-style": { borderColor: t2.foreColor },
                onClick: a[1] || (a[1] = (l) => o("foreColor", { value: t2.foreColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", d1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(Ye), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { borderColor: l.value },
                onClick: (u) => o("foreColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", p1, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", m1, [
              createVNode(unref(Ye), {
                icon: "slash_forward",
                tooltip: "Default Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => o("backColor", { value: "#F5F5F5" }))
              }),
              t2.backColor ? (openBlock(), createBlock(unref(Ye), {
                key: 0,
                "content-style": { backgroundColor: t2.backColor },
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[3] || (a[3] = (l) => o("backColor", { value: t2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", f1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (l, c2) => (openBlock(), createBlock(unref(Ye), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => o("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), uu = /* @__PURE__ */ defineComponent({
      __name: "OContextMenu",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        clientX: {
          type: Number,
          default: 0
        },
        clientY: {
          type: Number,
          default: 0
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:modelValue"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = ref();
        computed(() => {
          var a;
          return n.clientX || ((a = n.event) == null ? void 0 : a.clientX) || 0;
        }), computed(() => {
          var a;
          return n.clientY || ((a = n.event) == null ? void 0 : a.clientY) || 0;
        });
        function s(a) {
          o("update:modelValue", a);
        }
        function r() {
          o("update:modelValue", false);
        }
        return watch(
          () => n.modelValue,
          (a) => {
            var l;
            a ? setTimeout(() => {
              var c2;
              (c2 = i.value) == null || c2.setShow(a);
            }, 0) : (l = i.value) == null || l.setShow(a);
          }
        ), (a, l) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          placement: "bottom-start",
          trigger: "manual",
          show: t2.modelValue,
          "show-arrow": false,
          event: t2.event,
          "onUpdate:show": s,
          onClickoutside: r
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["show", "event"]));
      }
    }), _1 = { class: "o-color-board" }, h1 = { class: "cell-container" }, g1 = { class: "label" }, v1 = ["onClick"], du = /* @__PURE__ */ defineComponent({
      __name: "OColorBoard",
      props: {
        defaultColor: {
          type: String,
          default: ""
        },
        defaultLabel: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = t2, o = e;
        function i(l) {
          o("select", l.hex);
        }
        function s(l) {
          return n.activeColor === l;
        }
        function r(l) {
          return "abc";
        }
        const a = computed(() => [
          [
            { label: "color", rgb: "rgb(0, 0, 0)", hex: "#000000" },
            { label: "color", rgb: "rgb(38, 38, 38)", hex: "#262626" },
            { label: "color", rgb: "rgb(89, 89, 89)", hex: "#595959" },
            { label: "color", rgb: "rgb(140, 140, 140)", hex: "#8c8c8c" },
            { label: "color", rgb: "rgb(191, 191, 191)", hex: "#bfbfbf" },
            { label: "color", rgb: "rgb(217, 217, 217)", hex: "#d9d9d9" },
            { label: "color", rgb: "rgb(233, 233, 233)", hex: "#e9e9e9" },
            { label: "color", rgb: "rgb(245, 245, 245)", hex: "#f5f5f5" },
            {
              label: "color",
              rgb: "rgb(250, 250, 250)",
              hex: "#fafafa",
              border: true
            },
            {
              label: "color",
              rgb: "rgb(255, 255, 255)",
              hex: "#ffffff",
              border: true
            }
          ],
          [
            { label: "color", rgb: "rgb(245, 34, 45)", hex: "#f5222d" },
            { label: "color", rgb: "rgb(250, 84, 28)", hex: "#fa541c" },
            { label: "color", rgb: "rgb(250, 140, 22)", hex: "#fa8c16" },
            { label: "color", rgb: "rgb(250, 219, 20)", hex: "#fadb14" },
            { label: "color", rgb: "rgb(82, 196, 26)", hex: "#52c41a" },
            { label: "color", rgb: "rgb(19, 194, 194)", hex: "#13c2c2" },
            { label: "color", rgb: "rgb(24, 144, 255)", hex: "#1890ff" },
            { label: "color", rgb: "rgb(47, 84, 235)", hex: "#2f54eb" },
            { label: "color", rgb: "rgb(114, 46, 209)", hex: "#722ed1" },
            { label: "color", rgb: "rgb(235, 47, 150)", hex: "#eb2f96" }
          ],
          [
            { label: "color", rgb: "rgb(255, 232, 230)", hex: "#ffe8e6" },
            { label: "color", rgb: "rgb(255, 236, 224)", hex: "#ffece0" },
            { label: "color", rgb: "rgb(255, 239, 209)", hex: "#ffefd1" },
            { label: "color", rgb: "rgb(255, 248, 189)", hex: "#fff8bd" },
            { label: "color", rgb: "rgb(228, 247, 210)", hex: "#e4f7d2" },
            { label: "color", rgb: "rgb(211, 245, 240)", hex: "#d3f5f0" },
            { label: "color", rgb: "rgb(212, 238, 252)", hex: "#d4eefc" },
            { label: "color", rgb: "rgb(222, 232, 252)", hex: "#dee8fc" },
            { label: "color", rgb: "rgb(239, 225, 250)", hex: "#efe1fa" },
            { label: "color", rgb: "rgb(250, 225, 235)", hex: "#fae1eb" }
          ],
          [
            { label: "color", rgb: "rgb(255, 163, 158)", hex: "#ffa39e" },
            { label: "color", rgb: "rgb(255, 187, 150)", hex: "#ffbb96" },
            { label: "color", rgb: "rgb(255, 213, 145)", hex: "#ffd591" },
            { label: "color", rgb: "rgb(255, 240, 143)", hex: "#fff08f" },
            { label: "color", rgb: "rgb(183, 235, 143)", hex: "#b7eb8f" },
            { label: "color", rgb: "rgb(135, 232, 222)", hex: "#87e8de" },
            { label: "color", rgb: "rgb(145, 213, 255)", hex: "#91d5ff" },
            { label: "color", rgb: "rgb(173, 198, 255)", hex: "#adc6ff" },
            { label: "color", rgb: "rgb(211, 173, 247)", hex: "#d3adf7" },
            { label: "color", rgb: "rgb(255, 173, 210)", hex: "#ffadd2" }
          ],
          [
            { label: "color", rgb: "rgb(255, 77, 79)", hex: "#ff4d4f" },
            { label: "color", rgb: "rgb(255, 122, 69)", hex: "#ff7a45" },
            { label: "color", rgb: "rgb(255, 169, 64)", hex: "#ffa940" },
            { label: "color", rgb: "rgb(255, 236, 61)", hex: "#ffec3d" },
            { label: "color", rgb: "rgb(115, 209, 61)", hex: "#73d13d" },
            { label: "color", rgb: "rgb(54, 207, 201)", hex: "#36cfc9" },
            { label: "color", rgb: "rgb(64, 169, 255)", hex: "#40a9ff" },
            { label: "color", rgb: "rgb(89, 126, 247)", hex: "#597ef7" },
            { label: "color", rgb: "rgb(146, 84, 222)", hex: "#9254de" },
            { label: "color", rgb: "rgb(247, 89, 171)", hex: "#f759ab" }
          ],
          [
            { label: "color", rgb: "rgb(207, 19, 34)", hex: "#cf1322" },
            { label: "color", rgb: "rgb(212, 56, 13)", hex: "#d4380d" },
            { label: "color", rgb: "rgb(212, 107, 8)", hex: "#d46b08" },
            { label: "color", rgb: "rgb(212, 177, 6)", hex: "#d4b106" },
            { label: "color", rgb: "rgb(56, 158, 13)", hex: "#389e0d" },
            { label: "color", rgb: "rgb(8, 151, 156)", hex: "#08979c" },
            { label: "color", rgb: "rgb(9, 109, 217)", hex: "#096dd9" },
            { label: "color", rgb: "rgb(29, 57, 196)", hex: "#1d39c4" },
            { label: "color", rgb: "rgb(83, 29, 171)", hex: "#531dab" },
            { label: "color", rgb: "rgb(196, 29, 127)", hex: "#c41d7f" }
          ],
          [
            { label: "color", rgb: "rgb(130, 0, 20)", hex: "#820014" },
            { label: "color", rgb: "rgb(135, 20, 0)", hex: "#871400" },
            { label: "color", rgb: "rgb(135, 56, 0)", hex: "#873800" },
            { label: "color", rgb: "rgb(97, 71, 0)", hex: "#614700" },
            { label: "color", rgb: "rgb(19, 82, 0)", hex: "#135200" },
            { label: "color", rgb: "rgb(0, 71, 79)", hex: "#00474f" },
            { label: "color", rgb: "rgb(0, 58, 140)", hex: "#003a8c" },
            { label: "color", rgb: "rgb(6, 17, 120)", hex: "#061178" },
            { label: "color", rgb: "rgb(34, 7, 94)", hex: "#22075e" },
            { label: "color", rgb: "rgb(120, 6, 80)", hex: "#780650" }
          ]
        ]);
        return (l, c2) => (openBlock(), createElementBlock("section", _1, [
          createBaseVNode("div", {
            class: "default-color",
            onClick: c2[0] || (c2[0] = (u) => i({ hex: t2.defaultColor }))
          }, [
            createBaseVNode("div", h1, [
              createBaseVNode("div", {
                class: "cell border",
                style: normalizeStyle({ background: t2.defaultColor })
              }, [
                createVNode(unref(fe), { name: "slash_forward" })
              ], 4)
            ]),
            createBaseVNode("div", g1, toDisplayString(t2.defaultLabel), 1)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (u, d) => (openBlock(), createElementBlock("div", {
            class: "color-row",
            key: `row-${d}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(u, (p2, m) => (openBlock(), createElementBlock("div", {
              class: "",
              key: `col-${m}`
            }, [
              createBaseVNode("div", {
                class: "cell-container",
                onClick: (f) => i(p2)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["cell", { border: p2.border }]),
                  style: normalizeStyle({ backgroundColor: p2.hex })
                }, [
                  s(p2.hex) ? (openBlock(), createBlock(unref(fe), {
                    key: 0,
                    name: "done",
                    style: normalizeStyle({ color: r(p2.rgb) })
                  }, null, 8, ["style"])) : createCommentVNode("", true)
                ], 6)
              ], 8, v1)
            ]))), 128))
          ]))), 128))
        ]));
      }
    }), St = /* @__PURE__ */ defineComponent({
      __name: "OCommandBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (o, i) => (openBlock(), createBlock(unref(Uo), { placement: t2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: i[0] || (i[0] = (s) => n("click", s))
            }, [
              createVNode(unref(fe), {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(o.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), dc = /* @__PURE__ */ defineComponent({
      __name: "OCommonBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (o, i) => (openBlock(), createBlock(unref(Uo), { placement: t2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", t2.contentClass]),
              style: normalizeStyle(t2.contentStyle),
              onClick: i[0] || (i[0] = (s) => n("click", s))
            }, [
              createVNode(unref(fe), {
                name: t2.icon,
                color: t2.color,
                class: normalizeClass(t2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(o.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(t2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), b1 = {
      key: 0,
      class: "o-doc-toc toc"
    }, k1 = { class: "mini-view" }, y1 = { class: "toc__list" }, w1 = { class: "main-view" }, j1 = { class: "toc__title" }, E1 = { class: "toc__list" }, S1 = ["onClick"], C1 = /* @__PURE__ */ defineComponent({
      __name: "ODocToc",
      props: {
        editor: {
          type: Tn
        },
        maxLevel: {
          type: Number,
          default: 3
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), o = ref([]), i = ref("");
        function s() {
          var u;
          i.value = window.location.hash, (u = e.editor) == null || u.on("update", a), setTimeout(() => {
            r(), a();
          }, 0);
        }
        function r() {
          const u = document.querySelector(".yiitap"), d = u == null ? void 0 : u.parentElement;
          d == null || d.addEventListener("scroll", l);
        }
        function a() {
          var d;
          const u = [];
          (d = e.editor) == null || d.state.doc.descendants((p2, m) => {
            if (p2.type.name === "heading") {
              const f = p2.attrs["data-id"];
              u.push({
                level: p2.attrs.level,
                text: p2.textContent,
                id: f
              });
            }
          }), o.value = u;
        }
        function l(u) {
          for (const d of o.value) {
            const m = document.querySelector(`[data-id="${d.id}"]`).getBoundingClientRect();
            if (m.top >= 0 && m.top < window.innerHeight / 2) {
              i.value = d.id;
              break;
            }
          }
        }
        function c2(u) {
          i.value = u.id;
          const d = document.querySelector(`[data-id="${u.id}"]`);
          d && d.scrollIntoView({ behavior: "smooth", block: "start" });
        }
        return watch(
          () => e.editor,
          (u) => {
            s();
          }
        ), (u, d) => o.value.length ? (openBlock(), createElementBlock("section", b1, [
          createVNode(unref(Qe), {
            ref: "popover",
            "tippy-class": "o-toc-popover",
            placement: "left-start",
            offset: [0, -50],
            delay: 0,
            duration: 100
          }, {
            trigger: withCtx(() => [
              createBaseVNode("div", k1, [
                createBaseVNode("ul", y1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (p2, m) => (openBlock(), createElementBlock(Fragment, { key: m }, [
                    p2.level <= Math.max(Math.min(t2.maxLevel, 3), 2) ? (openBlock(), createElementBlock("li", {
                      key: 0,
                      class: normalizeClass(["toc__item", [
                        i.value === p2.id ? "selected" : "",
                        `toc__item--${p2.level}`
                      ]])
                    }, null, 2)) : createCommentVNode("", true)
                  ], 64))), 128))
                ])
              ])
            ]),
            default: withCtx(() => [
              createBaseVNode("div", w1, [
                createBaseVNode("div", j1, toDisplayString(unref(n)("label.toc")), 1),
                createBaseVNode("ul", E1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (p2, m) => (openBlock(), createElementBlock("li", {
                    class: normalizeClass(["toc__item", `toc__item--${p2.level}`]),
                    key: m
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(["heading", { selected: i.value === p2.id }]),
                      onClick: (f) => c2(p2)
                    }, toDisplayString(p2.text), 11, S1)
                  ], 2))), 128))
                ])
              ])
            ]),
            _: 1
          }, 512)
        ])) : createCommentVNode("", true);
      }
    }), pu = (t2, e) => {
      const n = t2.__vccOpts || t2;
      for (const [o, i] of e)
        n[o] = i;
      return n;
    }, _M = /* @__PURE__ */ pu(C1, [["__scopeId", "data-v-0c365cf2"]]), mu = /* @__PURE__ */ JSON.parse('[{"name":"Smileys & Emotion","slug":"smileys_emotion","emojis":[{"emoji":"😀","skin_tone_support":false,"name":"grinning face","slug":"grinning_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😃","skin_tone_support":false,"name":"grinning face with big eyes","slug":"grinning_face_with_big_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😄","skin_tone_support":false,"name":"grinning face with smiling eyes","slug":"grinning_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😁","skin_tone_support":false,"name":"beaming face with smiling eyes","slug":"beaming_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😆","skin_tone_support":false,"name":"grinning squinting face","slug":"grinning_squinting_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😅","skin_tone_support":false,"name":"grinning face with sweat","slug":"grinning_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤣","skin_tone_support":false,"name":"rolling on the floor laughing","slug":"rolling_on_the_floor_laughing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"😂","skin_tone_support":false,"name":"face with tears of joy","slug":"face_with_tears_of_joy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙂","skin_tone_support":false,"name":"slightly smiling face","slug":"slightly_smiling_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🙃","skin_tone_support":false,"name":"upside-down face","slug":"upside_down_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫠","skin_tone_support":false,"name":"melting face","slug":"melting_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"😉","skin_tone_support":false,"name":"winking face","slug":"winking_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😊","skin_tone_support":false,"name":"smiling face with smiling eyes","slug":"smiling_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😇","skin_tone_support":false,"name":"smiling face with halo","slug":"smiling_face_with_halo","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥰","skin_tone_support":false,"name":"smiling face with hearts","slug":"smiling_face_with_hearts","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"😍","skin_tone_support":false,"name":"smiling face with heart-eyes","slug":"smiling_face_with_heart_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤩","skin_tone_support":false,"name":"star-struck","slug":"star_struck","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"😘","skin_tone_support":false,"name":"face blowing a kiss","slug":"face_blowing_a_kiss","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😗","skin_tone_support":false,"name":"kissing face","slug":"kissing_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"☺️","skin_tone_support":false,"name":"smiling face","slug":"smiling_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😚","skin_tone_support":false,"name":"kissing face with closed eyes","slug":"kissing_face_with_closed_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😙","skin_tone_support":false,"name":"kissing face with smiling eyes","slug":"kissing_face_with_smiling_eyes","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥲","skin_tone_support":false,"name":"smiling face with tear","slug":"smiling_face_with_tear","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"😋","skin_tone_support":false,"name":"face savoring food","slug":"face_savoring_food","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😛","skin_tone_support":false,"name":"face with tongue","slug":"face_with_tongue","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😜","skin_tone_support":false,"name":"winking face with tongue","slug":"winking_face_with_tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤪","skin_tone_support":false,"name":"zany face","slug":"zany_face","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"😝","skin_tone_support":false,"name":"squinting face with tongue","slug":"squinting_face_with_tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤑","skin_tone_support":false,"name":"money-mouth face","slug":"money_mouth_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤗","skin_tone_support":false,"name":"smiling face with open hands","slug":"smiling_face_with_open_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤭","skin_tone_support":false,"name":"face with hand over mouth","slug":"face_with_hand_over_mouth","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🫢","skin_tone_support":false,"name":"face with open eyes and hand over mouth","slug":"face_with_open_eyes_and_hand_over_mouth","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫣","skin_tone_support":false,"name":"face with peeking eye","slug":"face_with_peeking_eye","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🤫","skin_tone_support":false,"name":"shushing face","slug":"shushing_face","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤔","skin_tone_support":false,"name":"thinking face","slug":"thinking_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫡","skin_tone_support":false,"name":"saluting face","slug":"saluting_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🤐","skin_tone_support":false,"name":"zipper-mouth face","slug":"zipper_mouth_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤨","skin_tone_support":false,"name":"face with raised eyebrow","slug":"face_with_raised_eyebrow","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"😐","skin_tone_support":false,"name":"neutral face","slug":"neutral_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"😑","skin_tone_support":false,"name":"expressionless face","slug":"expressionless_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😶","skin_tone_support":false,"name":"face without mouth","slug":"face_without_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫥","skin_tone_support":false,"name":"dotted line face","slug":"dotted_line_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"😶‍🌫️","skin_tone_support":false,"name":"face in clouds","slug":"face_in_clouds","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"😏","skin_tone_support":false,"name":"smirking face","slug":"smirking_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😒","skin_tone_support":false,"name":"unamused face","slug":"unamused_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙄","skin_tone_support":false,"name":"face with rolling eyes","slug":"face_with_rolling_eyes","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😬","skin_tone_support":false,"name":"grimacing face","slug":"grimacing_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😮‍💨","skin_tone_support":false,"name":"face exhaling","slug":"face_exhaling","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"🤥","skin_tone_support":false,"name":"lying face","slug":"lying_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫨","skin_tone_support":false,"name":"shaking face","slug":"shaking_face","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🙂‍↔️","skin_tone_support":false,"name":"head shaking horizontally","slug":"head_shaking_horizontally","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🙂‍↕️","skin_tone_support":false,"name":"head shaking vertically","slug":"head_shaking_vertically","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"😌","skin_tone_support":false,"name":"relieved face","slug":"relieved_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😔","skin_tone_support":false,"name":"pensive face","slug":"pensive_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😪","skin_tone_support":false,"name":"sleepy face","slug":"sleepy_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤤","skin_tone_support":false,"name":"drooling face","slug":"drooling_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"😴","skin_tone_support":false,"name":"sleeping face","slug":"sleeping_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫩","skin_tone_support":false,"name":"face with bags under eyes","slug":"face_with_bags_under_eyes","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"😷","skin_tone_support":false,"name":"face with medical mask","slug":"face_with_medical_mask","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤒","skin_tone_support":false,"name":"face with thermometer","slug":"face_with_thermometer","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤕","skin_tone_support":false,"name":"face with head-bandage","slug":"face_with_head_bandage","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤢","skin_tone_support":false,"name":"nauseated face","slug":"nauseated_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤮","skin_tone_support":false,"name":"face vomiting","slug":"face_vomiting","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤧","skin_tone_support":false,"name":"sneezing face","slug":"sneezing_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥵","skin_tone_support":false,"name":"hot face","slug":"hot_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥶","skin_tone_support":false,"name":"cold face","slug":"cold_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥴","skin_tone_support":false,"name":"woozy face","slug":"woozy_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"😵","skin_tone_support":false,"name":"face with crossed-out eyes","slug":"face_with_crossed_out_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😵‍💫","skin_tone_support":false,"name":"face with spiral eyes","slug":"face_with_spiral_eyes","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"🤯","skin_tone_support":false,"name":"exploding head","slug":"exploding_head","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤠","skin_tone_support":false,"name":"cowboy hat face","slug":"cowboy_hat_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥳","skin_tone_support":false,"name":"partying face","slug":"partying_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥸","skin_tone_support":false,"name":"disguised face","slug":"disguised_face","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"😎","skin_tone_support":false,"name":"smiling face with sunglasses","slug":"smiling_face_with_sunglasses","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤓","skin_tone_support":false,"name":"nerd face","slug":"nerd_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🧐","skin_tone_support":false,"name":"face with monocle","slug":"face_with_monocle","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"😕","skin_tone_support":false,"name":"confused face","slug":"confused_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫤","skin_tone_support":false,"name":"face with diagonal mouth","slug":"face_with_diagonal_mouth","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"😟","skin_tone_support":false,"name":"worried face","slug":"worried_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🙁","skin_tone_support":false,"name":"slightly frowning face","slug":"slightly_frowning_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"☹️","skin_tone_support":false,"name":"frowning face","slug":"frowning_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"😮","skin_tone_support":false,"name":"face with open mouth","slug":"face_with_open_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😯","skin_tone_support":false,"name":"hushed face","slug":"hushed_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😲","skin_tone_support":false,"name":"astonished face","slug":"astonished_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😳","skin_tone_support":false,"name":"flushed face","slug":"flushed_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥺","skin_tone_support":false,"name":"pleading face","slug":"pleading_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥹","skin_tone_support":false,"name":"face holding back tears","slug":"face_holding_back_tears","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"😦","skin_tone_support":false,"name":"frowning face with open mouth","slug":"frowning_face_with_open_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😧","skin_tone_support":false,"name":"anguished face","slug":"anguished_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😨","skin_tone_support":false,"name":"fearful face","slug":"fearful_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😰","skin_tone_support":false,"name":"anxious face with sweat","slug":"anxious_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😥","skin_tone_support":false,"name":"sad but relieved face","slug":"sad_but_relieved_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😢","skin_tone_support":false,"name":"crying face","slug":"crying_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😭","skin_tone_support":false,"name":"loudly crying face","slug":"loudly_crying_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😱","skin_tone_support":false,"name":"face screaming in fear","slug":"face_screaming_in_fear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😖","skin_tone_support":false,"name":"confounded face","slug":"confounded_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😣","skin_tone_support":false,"name":"persevering face","slug":"persevering_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😞","skin_tone_support":false,"name":"disappointed face","slug":"disappointed_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😓","skin_tone_support":false,"name":"downcast face with sweat","slug":"downcast_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😩","skin_tone_support":false,"name":"weary face","slug":"weary_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😫","skin_tone_support":false,"name":"tired face","slug":"tired_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥱","skin_tone_support":false,"name":"yawning face","slug":"yawning_face","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"😤","skin_tone_support":false,"name":"face with steam from nose","slug":"face_with_steam_from_nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😡","skin_tone_support":false,"name":"enraged face","slug":"enraged_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😠","skin_tone_support":false,"name":"angry face","slug":"angry_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤬","skin_tone_support":false,"name":"face with symbols on mouth","slug":"face_with_symbols_on_mouth","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"😈","skin_tone_support":false,"name":"smiling face with horns","slug":"smiling_face_with_horns","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"👿","skin_tone_support":false,"name":"angry face with horns","slug":"angry_face_with_horns","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💀","skin_tone_support":false,"name":"skull","slug":"skull","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☠️","skin_tone_support":false,"name":"skull and crossbones","slug":"skull_and_crossbones","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💩","skin_tone_support":false,"name":"pile of poo","slug":"pile_of_poo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤡","skin_tone_support":false,"name":"clown face","slug":"clown_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"👹","skin_tone_support":false,"name":"ogre","slug":"ogre","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👺","skin_tone_support":false,"name":"goblin","slug":"goblin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👻","skin_tone_support":false,"name":"ghost","slug":"ghost","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👽","skin_tone_support":false,"name":"alien","slug":"alien","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👾","skin_tone_support":false,"name":"alien monster","slug":"alien_monster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤖","skin_tone_support":false,"name":"robot","slug":"robot","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"😺","skin_tone_support":false,"name":"grinning cat","slug":"grinning_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😸","skin_tone_support":false,"name":"grinning cat with smiling eyes","slug":"grinning_cat_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😹","skin_tone_support":false,"name":"cat with tears of joy","slug":"cat_with_tears_of_joy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😻","skin_tone_support":false,"name":"smiling cat with heart-eyes","slug":"smiling_cat_with_heart_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😼","skin_tone_support":false,"name":"cat with wry smile","slug":"cat_with_wry_smile","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😽","skin_tone_support":false,"name":"kissing cat","slug":"kissing_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙀","skin_tone_support":false,"name":"weary cat","slug":"weary_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😿","skin_tone_support":false,"name":"crying cat","slug":"crying_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"😾","skin_tone_support":false,"name":"pouting cat","slug":"pouting_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙈","skin_tone_support":false,"name":"see-no-evil monkey","slug":"see_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙉","skin_tone_support":false,"name":"hear-no-evil monkey","slug":"hear_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙊","skin_tone_support":false,"name":"speak-no-evil monkey","slug":"speak_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💌","skin_tone_support":false,"name":"love letter","slug":"love_letter","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💘","skin_tone_support":false,"name":"heart with arrow","slug":"heart_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💝","skin_tone_support":false,"name":"heart with ribbon","slug":"heart_with_ribbon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💖","skin_tone_support":false,"name":"sparkling heart","slug":"sparkling_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💗","skin_tone_support":false,"name":"growing heart","slug":"growing_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💓","skin_tone_support":false,"name":"beating heart","slug":"beating_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💞","skin_tone_support":false,"name":"revolving hearts","slug":"revolving_hearts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💕","skin_tone_support":false,"name":"two hearts","slug":"two_hearts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💟","skin_tone_support":false,"name":"heart decoration","slug":"heart_decoration","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❣️","skin_tone_support":false,"name":"heart exclamation","slug":"heart_exclamation","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💔","skin_tone_support":false,"name":"broken heart","slug":"broken_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❤️‍🔥","skin_tone_support":false,"name":"heart on fire","slug":"heart_on_fire","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"❤️‍🩹","skin_tone_support":false,"name":"mending heart","slug":"mending_heart","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"❤️","skin_tone_support":false,"name":"red heart","slug":"red_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩷","skin_tone_support":false,"name":"pink heart","slug":"pink_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🧡","skin_tone_support":false,"name":"orange heart","slug":"orange_heart","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"💛","skin_tone_support":false,"name":"yellow heart","slug":"yellow_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💚","skin_tone_support":false,"name":"green heart","slug":"green_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💙","skin_tone_support":false,"name":"blue heart","slug":"blue_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩵","skin_tone_support":false,"name":"light blue heart","slug":"light_blue_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"💜","skin_tone_support":false,"name":"purple heart","slug":"purple_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤎","skin_tone_support":false,"name":"brown heart","slug":"brown_heart","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🖤","skin_tone_support":false,"name":"black heart","slug":"black_heart","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🩶","skin_tone_support":false,"name":"grey heart","slug":"grey_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🤍","skin_tone_support":false,"name":"white heart","slug":"white_heart","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"💋","skin_tone_support":false,"name":"kiss mark","slug":"kiss_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💯","skin_tone_support":false,"name":"hundred points","slug":"hundred_points","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💢","skin_tone_support":false,"name":"anger symbol","slug":"anger_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💥","skin_tone_support":false,"name":"collision","slug":"collision","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💫","skin_tone_support":false,"name":"dizzy","slug":"dizzy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💦","skin_tone_support":false,"name":"sweat droplets","slug":"sweat_droplets","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💨","skin_tone_support":false,"name":"dashing away","slug":"dashing_away","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕳️","skin_tone_support":false,"name":"hole","slug":"hole","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💬","skin_tone_support":false,"name":"speech balloon","slug":"speech_balloon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👁️‍🗨️","skin_tone_support":false,"name":"eye in speech bubble","slug":"eye_in_speech_bubble","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🗨️","skin_tone_support":false,"name":"left speech bubble","slug":"left_speech_bubble","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🗯️","skin_tone_support":false,"name":"right anger bubble","slug":"right_anger_bubble","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💭","skin_tone_support":false,"name":"thought balloon","slug":"thought_balloon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💤","skin_tone_support":false,"name":"ZZZ","slug":"zzz","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"People & Body","slug":"people_body","emojis":[{"emoji":"👋","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"waving hand","slug":"waving_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤚","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"raised back of hand","slug":"raised_back_of_hand","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🖐️","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"hand with fingers splayed","slug":"hand_with_fingers_splayed","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"✋","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raised hand","slug":"raised_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖖","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"vulcan salute","slug":"vulcan_salute","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫱","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"rightwards hand","slug":"rightwards_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫲","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"leftwards hand","slug":"leftwards_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫳","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"palm down hand","slug":"palm_down_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫴","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"palm up hand","slug":"palm_up_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫷","skin_tone_support":true,"skin_tone_support_unicode_version":"15.0","name":"leftwards pushing hand","slug":"leftwards_pushing_hand","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🫸","skin_tone_support":true,"skin_tone_support_unicode_version":"15.0","name":"rightwards pushing hand","slug":"rightwards_pushing_hand","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"👌","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"OK hand","slug":"ok_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤌","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"pinched fingers","slug":"pinched_fingers","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🤏","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"pinching hand","slug":"pinching_hand","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"✌️","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"victory hand","slug":"victory_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤞","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"crossed fingers","slug":"crossed_fingers","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫰","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"hand with index finger and thumb crossed","slug":"hand_with_index_finger_and_thumb_crossed","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🤟","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"love-you gesture","slug":"love_you_gesture","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤘","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"sign of the horns","slug":"sign_of_the_horns","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🤙","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"call me hand","slug":"call_me_hand","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"👈","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing left","slug":"backhand_index_pointing_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👉","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing right","slug":"backhand_index_pointing_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👆","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing up","slug":"backhand_index_pointing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖕","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"middle finger","slug":"middle_finger","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"👇","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing down","slug":"backhand_index_pointing_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☝️","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"index pointing up","slug":"index_pointing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫵","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"index pointing at the viewer","slug":"index_pointing_at_the_viewer","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"👍","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"thumbs up","slug":"thumbs_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👎","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"thumbs down","slug":"thumbs_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✊","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raised fist","slug":"raised_fist","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👊","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"oncoming fist","slug":"oncoming_fist","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤛","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"left-facing fist","slug":"left_facing_fist","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤜","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"right-facing fist","slug":"right_facing_fist","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"👏","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"clapping hands","slug":"clapping_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙌","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raising hands","slug":"raising_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫶","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"heart hands","slug":"heart_hands","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"👐","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"open hands","slug":"open_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤲","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"palms up together","slug":"palms_up_together","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤝","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"handshake","slug":"handshake","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🙏","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"folded hands","slug":"folded_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✍️","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"writing hand","slug":"writing_hand","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💅","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"nail polish","slug":"nail_polish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤳","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"selfie","slug":"selfie","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"💪","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"flexed biceps","slug":"flexed_biceps","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦾","skin_tone_support":false,"name":"mechanical arm","slug":"mechanical_arm","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦿","skin_tone_support":false,"name":"mechanical leg","slug":"mechanical_leg","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦵","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"leg","slug":"leg","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦶","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"foot","slug":"foot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👂","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"ear","slug":"ear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦻","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"ear with hearing aid","slug":"ear_with_hearing_aid","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👃","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"nose","slug":"nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧠","skin_tone_support":false,"name":"brain","slug":"brain","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🫀","skin_tone_support":false,"name":"anatomical heart","slug":"anatomical_heart","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🫁","skin_tone_support":false,"name":"lungs","slug":"lungs","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦷","skin_tone_support":false,"name":"tooth","slug":"tooth","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦴","skin_tone_support":false,"name":"bone","slug":"bone","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👀","skin_tone_support":false,"name":"eyes","slug":"eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👁️","skin_tone_support":false,"name":"eye","slug":"eye","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"👅","skin_tone_support":false,"name":"tongue","slug":"tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👄","skin_tone_support":false,"name":"mouth","slug":"mouth","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫦","skin_tone_support":false,"name":"biting lip","slug":"biting_lip","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"👶","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"baby","slug":"baby","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧒","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"child","slug":"child","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"👦","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"boy","slug":"boy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👧","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"girl","slug":"girl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧑","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person","slug":"person","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"👱","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person blond hair","slug":"person_blond_hair","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👨","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"man","slug":"man","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧔","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person beard","slug":"person_beard","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧔‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"man beard","slug":"man_beard","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"🧔‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"woman beard","slug":"woman_beard","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"👨‍🦰","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man red hair","slug":"man_red_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👨‍🦱","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man curly hair","slug":"man_curly_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👨‍🦳","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man white hair","slug":"man_white_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👨‍🦲","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man bald","slug":"man_bald","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👩","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"woman","slug":"woman","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👩‍🦰","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman red hair","slug":"woman_red_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧑‍🦰","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person red hair","slug":"person_red_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👩‍🦱","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman curly hair","slug":"woman_curly_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧑‍🦱","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person curly hair","slug":"person_curly_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👩‍🦳","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman white hair","slug":"woman_white_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧑‍🦳","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person white hair","slug":"person_white_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👩‍🦲","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman bald","slug":"woman_bald","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧑‍🦲","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person bald","slug":"person_bald","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👱‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman blond hair","slug":"woman_blond_hair","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👱‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man blond hair","slug":"man_blond_hair","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧓","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"older person","slug":"older_person","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"👴","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"old man","slug":"old_man","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👵","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"old woman","slug":"old_woman","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙍","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person frowning","slug":"person_frowning","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙍‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man frowning","slug":"man_frowning","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙍‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman frowning","slug":"woman_frowning","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙎","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person pouting","slug":"person_pouting","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙎‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man pouting","slug":"man_pouting","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙎‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman pouting","slug":"woman_pouting","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙅","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person gesturing NO","slug":"person_gesturing_no","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙅‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man gesturing NO","slug":"man_gesturing_no","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙅‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman gesturing NO","slug":"woman_gesturing_no","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙆","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person gesturing OK","slug":"person_gesturing_ok","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙆‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man gesturing OK","slug":"man_gesturing_ok","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙆‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman gesturing OK","slug":"woman_gesturing_ok","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💁","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person tipping hand","slug":"person_tipping_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💁‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man tipping hand","slug":"man_tipping_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💁‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman tipping hand","slug":"woman_tipping_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙋","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person raising hand","slug":"person_raising_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙋‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man raising hand","slug":"man_raising_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙋‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman raising hand","slug":"woman_raising_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧏","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf person","slug":"deaf_person","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧏‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf man","slug":"deaf_man","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧏‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf woman","slug":"deaf_woman","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🙇","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person bowing","slug":"person_bowing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🙇‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man bowing","slug":"man_bowing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🙇‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman bowing","slug":"woman_bowing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤦","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person facepalming","slug":"person_facepalming","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤦‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man facepalming","slug":"man_facepalming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤦‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman facepalming","slug":"woman_facepalming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤷","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person shrugging","slug":"person_shrugging","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤷‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man shrugging","slug":"man_shrugging","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤷‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman shrugging","slug":"woman_shrugging","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍⚕️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"health worker","slug":"health_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍⚕️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man health worker","slug":"man_health_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍⚕️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman health worker","slug":"woman_health_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🎓","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"student","slug":"student","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🎓","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man student","slug":"man_student","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🎓","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman student","slug":"woman_student","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🏫","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"teacher","slug":"teacher","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🏫","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man teacher","slug":"man_teacher","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🏫","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman teacher","slug":"woman_teacher","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍⚖️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"judge","slug":"judge","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍⚖️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man judge","slug":"man_judge","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍⚖️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman judge","slug":"woman_judge","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🌾","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"farmer","slug":"farmer","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🌾","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man farmer","slug":"man_farmer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🌾","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman farmer","slug":"woman_farmer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🍳","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"cook","slug":"cook","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🍳","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man cook","slug":"man_cook","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🍳","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman cook","slug":"woman_cook","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🔧","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"mechanic","slug":"mechanic","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🔧","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man mechanic","slug":"man_mechanic","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🔧","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman mechanic","slug":"woman_mechanic","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🏭","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"factory worker","slug":"factory_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🏭","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man factory worker","slug":"man_factory_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🏭","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman factory worker","slug":"woman_factory_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍💼","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"office worker","slug":"office_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍💼","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man office worker","slug":"man_office_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍💼","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman office worker","slug":"woman_office_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🔬","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"scientist","slug":"scientist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🔬","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man scientist","slug":"man_scientist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🔬","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman scientist","slug":"woman_scientist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍💻","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"technologist","slug":"technologist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍💻","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man technologist","slug":"man_technologist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍💻","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman technologist","slug":"woman_technologist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🎤","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"singer","slug":"singer","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🎤","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man singer","slug":"man_singer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🎤","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman singer","slug":"woman_singer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🎨","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"artist","slug":"artist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🎨","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man artist","slug":"man_artist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🎨","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman artist","slug":"woman_artist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍✈️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"pilot","slug":"pilot","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍✈️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man pilot","slug":"man_pilot","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍✈️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman pilot","slug":"woman_pilot","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🚀","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"astronaut","slug":"astronaut","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🚀","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man astronaut","slug":"man_astronaut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🚀","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman astronaut","slug":"woman_astronaut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧑‍🚒","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"firefighter","slug":"firefighter","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"👨‍🚒","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man firefighter","slug":"man_firefighter","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍🚒","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman firefighter","slug":"woman_firefighter","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👮","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"police officer","slug":"police_officer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👮‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man police officer","slug":"man_police_officer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👮‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman police officer","slug":"woman_police_officer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🕵️","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"detective","slug":"detective","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕵️‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man detective","slug":"man_detective","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🕵️‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman detective","slug":"woman_detective","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💂","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"guard","slug":"guard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💂‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man guard","slug":"man_guard","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💂‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman guard","slug":"woman_guard","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🥷","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"ninja","slug":"ninja","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👷","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"construction worker","slug":"construction_worker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👷‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man construction worker","slug":"man_construction_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👷‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman construction worker","slug":"woman_construction_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🫅","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"person with crown","slug":"person_with_crown","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🤴","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"prince","slug":"prince","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"👸","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"princess","slug":"princess","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👳","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person wearing turban","slug":"person_wearing_turban","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👳‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man wearing turban","slug":"man_wearing_turban","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👳‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman wearing turban","slug":"woman_wearing_turban","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👲","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person with skullcap","slug":"person_with_skullcap","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧕","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman with headscarf","slug":"woman_with_headscarf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤵","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person in tuxedo","slug":"person_in_tuxedo","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤵‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man in tuxedo","slug":"man_in_tuxedo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🤵‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman in tuxedo","slug":"woman_in_tuxedo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👰","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person with veil","slug":"person_with_veil","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👰‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man with veil","slug":"man_with_veil","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👰‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman with veil","slug":"woman_with_veil","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🤰","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"pregnant woman","slug":"pregnant_woman","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫃","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"pregnant man","slug":"pregnant_man","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🫄","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"pregnant person","slug":"pregnant_person","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🤱","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"breast-feeding","slug":"breast_feeding","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"👩‍🍼","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman feeding baby","slug":"woman_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👨‍🍼","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man feeding baby","slug":"man_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧑‍🍼","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"person feeding baby","slug":"person_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👼","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"baby angel","slug":"baby_angel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎅","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"Santa Claus","slug":"santa_claus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤶","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"Mrs. Claus","slug":"mrs_claus","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🧑‍🎄","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"Mx Claus","slug":"mx_claus","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦸","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"superhero","slug":"superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦸‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man superhero","slug":"man_superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦸‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman superhero","slug":"woman_superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦹","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"supervillain","slug":"supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦹‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man supervillain","slug":"man_supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦹‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman supervillain","slug":"woman_supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧙","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"mage","slug":"mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧙‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man mage","slug":"man_mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧙‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman mage","slug":"woman_mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧚","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"fairy","slug":"fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧚‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man fairy","slug":"man_fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧚‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman fairy","slug":"woman_fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧛","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"vampire","slug":"vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧛‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man vampire","slug":"man_vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧛‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman vampire","slug":"woman_vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧜","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"merperson","slug":"merperson","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧜‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"merman","slug":"merman","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧜‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"mermaid","slug":"mermaid","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧝","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"elf","slug":"elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧝‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man elf","slug":"man_elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧝‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman elf","slug":"woman_elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧞","skin_tone_support":false,"name":"genie","slug":"genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧞‍♂️","skin_tone_support":false,"name":"man genie","slug":"man_genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧞‍♀️","skin_tone_support":false,"name":"woman genie","slug":"woman_genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧟","skin_tone_support":false,"name":"zombie","slug":"zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧟‍♂️","skin_tone_support":false,"name":"man zombie","slug":"man_zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧟‍♀️","skin_tone_support":false,"name":"woman zombie","slug":"woman_zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧌","skin_tone_support":false,"name":"troll","slug":"troll","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"💆","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person getting massage","slug":"person_getting_massage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💆‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man getting massage","slug":"man_getting_massage","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💆‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman getting massage","slug":"woman_getting_massage","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💇","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person getting haircut","slug":"person_getting_haircut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💇‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man getting haircut","slug":"man_getting_haircut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"💇‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman getting haircut","slug":"woman_getting_haircut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚶","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person walking","slug":"person_walking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚶‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man walking","slug":"man_walking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚶‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman walking","slug":"woman_walking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚶‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person walking facing right","slug":"person_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🚶‍♀️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman walking facing right","slug":"woman_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🚶‍♂️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man walking facing right","slug":"man_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧍","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"person standing","slug":"person_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧍‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man standing","slug":"man_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧍‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman standing","slug":"woman_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧎","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"person kneeling","slug":"person_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧎‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man kneeling","slug":"man_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧎‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman kneeling","slug":"woman_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧎‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person kneeling facing right","slug":"person_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧎‍♀️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman kneeling facing right","slug":"woman_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧎‍♂️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man kneeling facing right","slug":"man_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🦯","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person with white cane","slug":"person_with_white_cane","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"🧑‍🦯‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person with white cane facing right","slug":"person_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👨‍🦯","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man with white cane","slug":"man_with_white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👨‍🦯‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man with white cane facing right","slug":"man_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👩‍🦯","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman with white cane","slug":"woman_with_white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👩‍🦯‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman with white cane facing right","slug":"woman_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🦼","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person in motorized wheelchair","slug":"person_in_motorized_wheelchair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"🧑‍🦼‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person in motorized wheelchair facing right","slug":"person_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👨‍🦼","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man in motorized wheelchair","slug":"man_in_motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👨‍🦼‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man in motorized wheelchair facing right","slug":"man_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👩‍🦼","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman in motorized wheelchair","slug":"woman_in_motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👩‍🦼‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman in motorized wheelchair facing right","slug":"woman_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🦽","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person in manual wheelchair","slug":"person_in_manual_wheelchair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"🧑‍🦽‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person in manual wheelchair facing right","slug":"person_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👨‍🦽","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man in manual wheelchair","slug":"man_in_manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👨‍🦽‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man in manual wheelchair facing right","slug":"man_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👩‍🦽","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman in manual wheelchair","slug":"woman_in_manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👩‍🦽‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman in manual wheelchair facing right","slug":"woman_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🏃","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person running","slug":"person_running","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏃‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man running","slug":"man_running","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏃‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman running","slug":"woman_running","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏃‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person running facing right","slug":"person_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🏃‍♀️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman running facing right","slug":"woman_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🏃‍♂️‍➡️","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man running facing right","slug":"man_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"💃","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"woman dancing","slug":"woman_dancing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕺","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"man dancing","slug":"man_dancing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🕴️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person in suit levitating","slug":"person_in_suit_levitating","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"👯","skin_tone_support":false,"name":"people with bunny ears","slug":"people_with_bunny_ears","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👯‍♂️","skin_tone_support":false,"name":"men with bunny ears","slug":"men_with_bunny_ears","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👯‍♀️","skin_tone_support":false,"name":"women with bunny ears","slug":"women_with_bunny_ears","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧖","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person in steamy room","slug":"person_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧖‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man in steamy room","slug":"man_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧖‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman in steamy room","slug":"woman_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧗","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person climbing","slug":"person_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧗‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man climbing","slug":"man_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧗‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman climbing","slug":"woman_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🤺","skin_tone_support":false,"name":"person fencing","slug":"person_fencing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🏇","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"horse racing","slug":"horse_racing","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⛷️","skin_tone_support":false,"name":"skier","slug":"skier","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏂","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"snowboarder","slug":"snowboarder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏌️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person golfing","slug":"person_golfing","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏌️‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man golfing","slug":"man_golfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏌️‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman golfing","slug":"woman_golfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏄","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person surfing","slug":"person_surfing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏄‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man surfing","slug":"man_surfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏄‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman surfing","slug":"woman_surfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚣","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person rowing boat","slug":"person_rowing_boat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚣‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man rowing boat","slug":"man_rowing_boat","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚣‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman rowing boat","slug":"woman_rowing_boat","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏊","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person swimming","slug":"person_swimming","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏊‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man swimming","slug":"man_swimming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏊‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman swimming","slug":"woman_swimming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"⛹️","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"person bouncing ball","slug":"person_bouncing_ball","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⛹️‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man bouncing ball","slug":"man_bouncing_ball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"⛹️‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman bouncing ball","slug":"woman_bouncing_ball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏋️","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"person lifting weights","slug":"person_lifting_weights","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏋️‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man lifting weights","slug":"man_lifting_weights","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏋️‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman lifting weights","slug":"woman_lifting_weights","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚴","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person biking","slug":"person_biking","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚴‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man biking","slug":"man_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚴‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman biking","slug":"woman_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚵","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person mountain biking","slug":"person_mountain_biking","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚵‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man mountain biking","slug":"man_mountain_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🚵‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman mountain biking","slug":"woman_mountain_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤸","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person cartwheeling","slug":"person_cartwheeling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤸‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man cartwheeling","slug":"man_cartwheeling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤸‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman cartwheeling","slug":"woman_cartwheeling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤼","skin_tone_support":false,"name":"people wrestling","slug":"people_wrestling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤼‍♂️","skin_tone_support":false,"name":"men wrestling","slug":"men_wrestling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤼‍♀️","skin_tone_support":false,"name":"women wrestling","slug":"women_wrestling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤽","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person playing water polo","slug":"person_playing_water_polo","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤽‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man playing water polo","slug":"man_playing_water_polo","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤽‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman playing water polo","slug":"woman_playing_water_polo","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤾","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person playing handball","slug":"person_playing_handball","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤾‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man playing handball","slug":"man_playing_handball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤾‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman playing handball","slug":"woman_playing_handball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤹","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person juggling","slug":"person_juggling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🤹‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man juggling","slug":"man_juggling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🤹‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman juggling","slug":"woman_juggling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🧘","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person in lotus position","slug":"person_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧘‍♂️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man in lotus position","slug":"man_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧘‍♀️","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman in lotus position","slug":"woman_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🛀","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person taking bath","slug":"person_taking_bath","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛌","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person in bed","slug":"person_in_bed","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🧑‍🤝‍🧑","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"people holding hands","slug":"people_holding_hands","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👭","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"women holding hands","slug":"women_holding_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"👫","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman and man holding hands","slug":"woman_and_man_holding_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👬","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"men holding hands","slug":"men_holding_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💏","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss","slug":"kiss","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👩‍❤️‍💋‍👨","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss woman, man","slug":"kiss_woman_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍❤️‍💋‍👨","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss man, man","slug":"kiss_man_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍❤️‍💋‍👩","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss woman, woman","slug":"kiss_woman_woman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"💑","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart","slug":"couple_with_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👩‍❤️‍👨","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart woman, man","slug":"couple_with_heart_woman_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍❤️‍👨","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart man, man","slug":"couple_with_heart_man_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍❤️‍👩","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart woman, woman","slug":"couple_with_heart_woman_woman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👩‍👦","skin_tone_support":false,"name":"family man, woman, boy","slug":"family_man_woman_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👩‍👧","skin_tone_support":false,"name":"family man, woman, girl","slug":"family_man_woman_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👩‍👧‍👦","skin_tone_support":false,"name":"family man, woman, girl, boy","slug":"family_man_woman_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👩‍👦‍👦","skin_tone_support":false,"name":"family man, woman, boy, boy","slug":"family_man_woman_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👩‍👧‍👧","skin_tone_support":false,"name":"family man, woman, girl, girl","slug":"family_man_woman_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👨‍👦","skin_tone_support":false,"name":"family man, man, boy","slug":"family_man_man_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👨‍👧","skin_tone_support":false,"name":"family man, man, girl","slug":"family_man_man_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👨‍👧‍👦","skin_tone_support":false,"name":"family man, man, girl, boy","slug":"family_man_man_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👨‍👦‍👦","skin_tone_support":false,"name":"family man, man, boy, boy","slug":"family_man_man_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👨‍👧‍👧","skin_tone_support":false,"name":"family man, man, girl, girl","slug":"family_man_man_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍👩‍👦","skin_tone_support":false,"name":"family woman, woman, boy","slug":"family_woman_woman_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍👩‍👧","skin_tone_support":false,"name":"family woman, woman, girl","slug":"family_woman_woman_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍👩‍👧‍👦","skin_tone_support":false,"name":"family woman, woman, girl, boy","slug":"family_woman_woman_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍👩‍👦‍👦","skin_tone_support":false,"name":"family woman, woman, boy, boy","slug":"family_woman_woman_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👩‍👩‍👧‍👧","skin_tone_support":false,"name":"family woman, woman, girl, girl","slug":"family_woman_woman_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"👨‍👦","skin_tone_support":false,"name":"family man, boy","slug":"family_man_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👨‍👦‍👦","skin_tone_support":false,"name":"family man, boy, boy","slug":"family_man_boy_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👨‍👧","skin_tone_support":false,"name":"family man, girl","slug":"family_man_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👨‍👧‍👦","skin_tone_support":false,"name":"family man, girl, boy","slug":"family_man_girl_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👨‍👧‍👧","skin_tone_support":false,"name":"family man, girl, girl","slug":"family_man_girl_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍👦","skin_tone_support":false,"name":"family woman, boy","slug":"family_woman_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍👦‍👦","skin_tone_support":false,"name":"family woman, boy, boy","slug":"family_woman_boy_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍👧","skin_tone_support":false,"name":"family woman, girl","slug":"family_woman_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍👧‍👦","skin_tone_support":false,"name":"family woman, girl, boy","slug":"family_woman_girl_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"👩‍👧‍👧","skin_tone_support":false,"name":"family woman, girl, girl","slug":"family_woman_girl_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🗣️","skin_tone_support":false,"name":"speaking head","slug":"speaking_head","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"👤","skin_tone_support":false,"name":"bust in silhouette","slug":"bust_in_silhouette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👥","skin_tone_support":false,"name":"busts in silhouette","slug":"busts_in_silhouette","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫂","skin_tone_support":false,"name":"people hugging","slug":"people_hugging","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👪","skin_tone_support":false,"name":"family","slug":"family","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧑‍🧑‍🧒","skin_tone_support":false,"name":"family adult, adult, child","slug":"family_adult_adult_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🧑‍🧒‍🧒","skin_tone_support":false,"name":"family adult, adult, child, child","slug":"family_adult_adult_child_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🧒","skin_tone_support":false,"name":"family adult, child","slug":"family_adult_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🧑‍🧒‍🧒","skin_tone_support":false,"name":"family adult, child, child","slug":"family_adult_child_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"👣","skin_tone_support":false,"name":"footprints","slug":"footprints","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫆","skin_tone_support":false,"name":"fingerprint","slug":"fingerprint","unicode_version":"16.0","emoji_version":"16.0"}]},{"name":"Animals & Nature","slug":"animals_nature","emojis":[{"emoji":"🐵","skin_tone_support":false,"name":"monkey face","slug":"monkey_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐒","skin_tone_support":false,"name":"monkey","slug":"monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦍","skin_tone_support":false,"name":"gorilla","slug":"gorilla","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦧","skin_tone_support":false,"name":"orangutan","slug":"orangutan","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🐶","skin_tone_support":false,"name":"dog face","slug":"dog_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐕","skin_tone_support":false,"name":"dog","slug":"dog","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🦮","skin_tone_support":false,"name":"guide dog","slug":"guide_dog","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🐕‍🦺","skin_tone_support":false,"name":"service dog","slug":"service_dog","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🐩","skin_tone_support":false,"name":"poodle","slug":"poodle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐺","skin_tone_support":false,"name":"wolf","slug":"wolf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦊","skin_tone_support":false,"name":"fox","slug":"fox","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦝","skin_tone_support":false,"name":"raccoon","slug":"raccoon","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🐱","skin_tone_support":false,"name":"cat face","slug":"cat_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐈","skin_tone_support":false,"name":"cat","slug":"cat","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🐈‍⬛","skin_tone_support":false,"name":"black cat","slug":"black_cat","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦁","skin_tone_support":false,"name":"lion","slug":"lion","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐯","skin_tone_support":false,"name":"tiger face","slug":"tiger_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐅","skin_tone_support":false,"name":"tiger","slug":"tiger","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐆","skin_tone_support":false,"name":"leopard","slug":"leopard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐴","skin_tone_support":false,"name":"horse face","slug":"horse_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫎","skin_tone_support":false,"name":"moose","slug":"moose","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🫏","skin_tone_support":false,"name":"donkey","slug":"donkey","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🐎","skin_tone_support":false,"name":"horse","slug":"horse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦄","skin_tone_support":false,"name":"unicorn","slug":"unicorn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🦓","skin_tone_support":false,"name":"zebra","slug":"zebra","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🦌","skin_tone_support":false,"name":"deer","slug":"deer","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦬","skin_tone_support":false,"name":"bison","slug":"bison","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🐮","skin_tone_support":false,"name":"cow face","slug":"cow_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐂","skin_tone_support":false,"name":"ox","slug":"ox","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐃","skin_tone_support":false,"name":"water buffalo","slug":"water_buffalo","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐄","skin_tone_support":false,"name":"cow","slug":"cow","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐷","skin_tone_support":false,"name":"pig face","slug":"pig_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐖","skin_tone_support":false,"name":"pig","slug":"pig","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐗","skin_tone_support":false,"name":"boar","slug":"boar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐽","skin_tone_support":false,"name":"pig nose","slug":"pig_nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐏","skin_tone_support":false,"name":"ram","slug":"ram","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐑","skin_tone_support":false,"name":"ewe","slug":"ewe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐐","skin_tone_support":false,"name":"goat","slug":"goat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐪","skin_tone_support":false,"name":"camel","slug":"camel","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐫","skin_tone_support":false,"name":"two-hump camel","slug":"two_hump_camel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦙","skin_tone_support":false,"name":"llama","slug":"llama","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦒","skin_tone_support":false,"name":"giraffe","slug":"giraffe","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🐘","skin_tone_support":false,"name":"elephant","slug":"elephant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦣","skin_tone_support":false,"name":"mammoth","slug":"mammoth","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦏","skin_tone_support":false,"name":"rhinoceros","slug":"rhinoceros","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦛","skin_tone_support":false,"name":"hippopotamus","slug":"hippopotamus","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🐭","skin_tone_support":false,"name":"mouse face","slug":"mouse_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐁","skin_tone_support":false,"name":"mouse","slug":"mouse","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐀","skin_tone_support":false,"name":"rat","slug":"rat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐹","skin_tone_support":false,"name":"hamster","slug":"hamster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐰","skin_tone_support":false,"name":"rabbit face","slug":"rabbit_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐇","skin_tone_support":false,"name":"rabbit","slug":"rabbit","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐿️","skin_tone_support":false,"name":"chipmunk","slug":"chipmunk","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🦫","skin_tone_support":false,"name":"beaver","slug":"beaver","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦔","skin_tone_support":false,"name":"hedgehog","slug":"hedgehog","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🦇","skin_tone_support":false,"name":"bat","slug":"bat","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🐻","skin_tone_support":false,"name":"bear","slug":"bear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐻‍❄️","skin_tone_support":false,"name":"polar bear","slug":"polar_bear","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🐨","skin_tone_support":false,"name":"koala","slug":"koala","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐼","skin_tone_support":false,"name":"panda","slug":"panda","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦥","skin_tone_support":false,"name":"sloth","slug":"sloth","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦦","skin_tone_support":false,"name":"otter","slug":"otter","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦨","skin_tone_support":false,"name":"skunk","slug":"skunk","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦘","skin_tone_support":false,"name":"kangaroo","slug":"kangaroo","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦡","skin_tone_support":false,"name":"badger","slug":"badger","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🐾","skin_tone_support":false,"name":"paw prints","slug":"paw_prints","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦃","skin_tone_support":false,"name":"turkey","slug":"turkey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐔","skin_tone_support":false,"name":"chicken","slug":"chicken","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐓","skin_tone_support":false,"name":"rooster","slug":"rooster","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐣","skin_tone_support":false,"name":"hatching chick","slug":"hatching_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐤","skin_tone_support":false,"name":"baby chick","slug":"baby_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐥","skin_tone_support":false,"name":"front-facing baby chick","slug":"front_facing_baby_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐦","skin_tone_support":false,"name":"bird","slug":"bird","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐧","skin_tone_support":false,"name":"penguin","slug":"penguin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕊️","skin_tone_support":false,"name":"dove","slug":"dove","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🦅","skin_tone_support":false,"name":"eagle","slug":"eagle","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦆","skin_tone_support":false,"name":"duck","slug":"duck","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦢","skin_tone_support":false,"name":"swan","slug":"swan","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦉","skin_tone_support":false,"name":"owl","slug":"owl","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦤","skin_tone_support":false,"name":"dodo","slug":"dodo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪶","skin_tone_support":false,"name":"feather","slug":"feather","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦩","skin_tone_support":false,"name":"flamingo","slug":"flamingo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦚","skin_tone_support":false,"name":"peacock","slug":"peacock","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦜","skin_tone_support":false,"name":"parrot","slug":"parrot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪽","skin_tone_support":false,"name":"wing","slug":"wing","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🐦‍⬛","skin_tone_support":false,"name":"black bird","slug":"black_bird","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🪿","skin_tone_support":false,"name":"goose","slug":"goose","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🐦‍🔥","skin_tone_support":false,"name":"phoenix","slug":"phoenix","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🐸","skin_tone_support":false,"name":"frog","slug":"frog","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐊","skin_tone_support":false,"name":"crocodile","slug":"crocodile","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐢","skin_tone_support":false,"name":"turtle","slug":"turtle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦎","skin_tone_support":false,"name":"lizard","slug":"lizard","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🐍","skin_tone_support":false,"name":"snake","slug":"snake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐲","skin_tone_support":false,"name":"dragon face","slug":"dragon_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐉","skin_tone_support":false,"name":"dragon","slug":"dragon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🦕","skin_tone_support":false,"name":"sauropod","slug":"sauropod","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🦖","skin_tone_support":false,"name":"T-Rex","slug":"t_rex","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🐳","skin_tone_support":false,"name":"spouting whale","slug":"spouting_whale","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐋","skin_tone_support":false,"name":"whale","slug":"whale","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🐬","skin_tone_support":false,"name":"dolphin","slug":"dolphin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦭","skin_tone_support":false,"name":"seal","slug":"seal","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🐟","skin_tone_support":false,"name":"fish","slug":"fish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐠","skin_tone_support":false,"name":"tropical fish","slug":"tropical_fish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐡","skin_tone_support":false,"name":"blowfish","slug":"blowfish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦈","skin_tone_support":false,"name":"shark","slug":"shark","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🐙","skin_tone_support":false,"name":"octopus","slug":"octopus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐚","skin_tone_support":false,"name":"spiral shell","slug":"spiral_shell","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪸","skin_tone_support":false,"name":"coral","slug":"coral","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🪼","skin_tone_support":false,"name":"jellyfish","slug":"jellyfish","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🦀","skin_tone_support":false,"name":"crab","slug":"crab","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🦞","skin_tone_support":false,"name":"lobster","slug":"lobster","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦐","skin_tone_support":false,"name":"shrimp","slug":"shrimp","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦑","skin_tone_support":false,"name":"squid","slug":"squid","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦪","skin_tone_support":false,"name":"oyster","slug":"oyster","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🐌","skin_tone_support":false,"name":"snail","slug":"snail","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦋","skin_tone_support":false,"name":"butterfly","slug":"butterfly","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🐛","skin_tone_support":false,"name":"bug","slug":"bug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐜","skin_tone_support":false,"name":"ant","slug":"ant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🐝","skin_tone_support":false,"name":"honeybee","slug":"honeybee","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪲","skin_tone_support":false,"name":"beetle","slug":"beetle","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🐞","skin_tone_support":false,"name":"lady beetle","slug":"lady_beetle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🦗","skin_tone_support":false,"name":"cricket","slug":"cricket","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🪳","skin_tone_support":false,"name":"cockroach","slug":"cockroach","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🕷️","skin_tone_support":false,"name":"spider","slug":"spider","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕸️","skin_tone_support":false,"name":"spider web","slug":"spider_web","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🦂","skin_tone_support":false,"name":"scorpion","slug":"scorpion","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🦟","skin_tone_support":false,"name":"mosquito","slug":"mosquito","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪰","skin_tone_support":false,"name":"fly","slug":"fly","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪱","skin_tone_support":false,"name":"worm","slug":"worm","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🦠","skin_tone_support":false,"name":"microbe","slug":"microbe","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"💐","skin_tone_support":false,"name":"bouquet","slug":"bouquet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌸","skin_tone_support":false,"name":"cherry blossom","slug":"cherry_blossom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💮","skin_tone_support":false,"name":"white flower","slug":"white_flower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪷","skin_tone_support":false,"name":"lotus","slug":"lotus","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🏵️","skin_tone_support":false,"name":"rosette","slug":"rosette","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌹","skin_tone_support":false,"name":"rose","slug":"rose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥀","skin_tone_support":false,"name":"wilted flower","slug":"wilted_flower","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🌺","skin_tone_support":false,"name":"hibiscus","slug":"hibiscus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌻","skin_tone_support":false,"name":"sunflower","slug":"sunflower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌼","skin_tone_support":false,"name":"blossom","slug":"blossom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌷","skin_tone_support":false,"name":"tulip","slug":"tulip","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪻","skin_tone_support":false,"name":"hyacinth","slug":"hyacinth","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🌱","skin_tone_support":false,"name":"seedling","slug":"seedling","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪴","skin_tone_support":false,"name":"potted plant","slug":"potted_plant","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🌲","skin_tone_support":false,"name":"evergreen tree","slug":"evergreen_tree","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌳","skin_tone_support":false,"name":"deciduous tree","slug":"deciduous_tree","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌴","skin_tone_support":false,"name":"palm tree","slug":"palm_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌵","skin_tone_support":false,"name":"cactus","slug":"cactus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌾","skin_tone_support":false,"name":"sheaf of rice","slug":"sheaf_of_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌿","skin_tone_support":false,"name":"herb","slug":"herb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☘️","skin_tone_support":false,"name":"shamrock","slug":"shamrock","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🍀","skin_tone_support":false,"name":"four leaf clover","slug":"four_leaf_clover","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍁","skin_tone_support":false,"name":"maple leaf","slug":"maple_leaf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍂","skin_tone_support":false,"name":"fallen leaf","slug":"fallen_leaf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍃","skin_tone_support":false,"name":"leaf fluttering in wind","slug":"leaf_fluttering_in_wind","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪹","skin_tone_support":false,"name":"empty nest","slug":"empty_nest","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🪺","skin_tone_support":false,"name":"nest with eggs","slug":"nest_with_eggs","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🍄","skin_tone_support":false,"name":"mushroom","slug":"mushroom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪾","skin_tone_support":false,"name":"leafless tree","slug":"leafless_tree","unicode_version":"16.0","emoji_version":"16.0"}]},{"name":"Food & Drink","slug":"food_drink","emojis":[{"emoji":"🍇","skin_tone_support":false,"name":"grapes","slug":"grapes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍈","skin_tone_support":false,"name":"melon","slug":"melon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍉","skin_tone_support":false,"name":"watermelon","slug":"watermelon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍊","skin_tone_support":false,"name":"tangerine","slug":"tangerine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍋","skin_tone_support":false,"name":"lemon","slug":"lemon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🍋‍🟩","skin_tone_support":false,"name":"lime","slug":"lime","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🍌","skin_tone_support":false,"name":"banana","slug":"banana","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍍","skin_tone_support":false,"name":"pineapple","slug":"pineapple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥭","skin_tone_support":false,"name":"mango","slug":"mango","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🍎","skin_tone_support":false,"name":"red apple","slug":"red_apple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍏","skin_tone_support":false,"name":"green apple","slug":"green_apple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍐","skin_tone_support":false,"name":"pear","slug":"pear","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🍑","skin_tone_support":false,"name":"peach","slug":"peach","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍒","skin_tone_support":false,"name":"cherries","slug":"cherries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍓","skin_tone_support":false,"name":"strawberry","slug":"strawberry","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫐","skin_tone_support":false,"name":"blueberries","slug":"blueberries","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥝","skin_tone_support":false,"name":"kiwi fruit","slug":"kiwi_fruit","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍅","skin_tone_support":false,"name":"tomato","slug":"tomato","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫒","skin_tone_support":false,"name":"olive","slug":"olive","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥥","skin_tone_support":false,"name":"coconut","slug":"coconut","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥑","skin_tone_support":false,"name":"avocado","slug":"avocado","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍆","skin_tone_support":false,"name":"eggplant","slug":"eggplant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥔","skin_tone_support":false,"name":"potato","slug":"potato","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥕","skin_tone_support":false,"name":"carrot","slug":"carrot","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🌽","skin_tone_support":false,"name":"ear of corn","slug":"ear_of_corn","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌶️","skin_tone_support":false,"name":"hot pepper","slug":"hot_pepper","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🫑","skin_tone_support":false,"name":"bell pepper","slug":"bell_pepper","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥒","skin_tone_support":false,"name":"cucumber","slug":"cucumber","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥬","skin_tone_support":false,"name":"leafy green","slug":"leafy_green","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥦","skin_tone_support":false,"name":"broccoli","slug":"broccoli","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧄","skin_tone_support":false,"name":"garlic","slug":"garlic","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧅","skin_tone_support":false,"name":"onion","slug":"onion","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🥜","skin_tone_support":false,"name":"peanuts","slug":"peanuts","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫘","skin_tone_support":false,"name":"beans","slug":"beans","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🌰","skin_tone_support":false,"name":"chestnut","slug":"chestnut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫚","skin_tone_support":false,"name":"ginger root","slug":"ginger_root","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🫛","skin_tone_support":false,"name":"pea pod","slug":"pea_pod","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🍄‍🟫","skin_tone_support":false,"name":"brown mushroom","slug":"brown_mushroom","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"🫜","skin_tone_support":false,"name":"root vegetable","slug":"root_vegetable","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"🍞","skin_tone_support":false,"name":"bread","slug":"bread","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥐","skin_tone_support":false,"name":"croissant","slug":"croissant","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥖","skin_tone_support":false,"name":"baguette bread","slug":"baguette_bread","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫓","skin_tone_support":false,"name":"flatbread","slug":"flatbread","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥨","skin_tone_support":false,"name":"pretzel","slug":"pretzel","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥯","skin_tone_support":false,"name":"bagel","slug":"bagel","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥞","skin_tone_support":false,"name":"pancakes","slug":"pancakes","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🧇","skin_tone_support":false,"name":"waffle","slug":"waffle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧀","skin_tone_support":false,"name":"cheese wedge","slug":"cheese_wedge","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🍖","skin_tone_support":false,"name":"meat on bone","slug":"meat_on_bone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍗","skin_tone_support":false,"name":"poultry leg","slug":"poultry_leg","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥩","skin_tone_support":false,"name":"cut of meat","slug":"cut_of_meat","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥓","skin_tone_support":false,"name":"bacon","slug":"bacon","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍔","skin_tone_support":false,"name":"hamburger","slug":"hamburger","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍟","skin_tone_support":false,"name":"french fries","slug":"french_fries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍕","skin_tone_support":false,"name":"pizza","slug":"pizza","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌭","skin_tone_support":false,"name":"hot dog","slug":"hot_dog","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥪","skin_tone_support":false,"name":"sandwich","slug":"sandwich","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🌮","skin_tone_support":false,"name":"taco","slug":"taco","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌯","skin_tone_support":false,"name":"burrito","slug":"burrito","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🫔","skin_tone_support":false,"name":"tamale","slug":"tamale","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥙","skin_tone_support":false,"name":"stuffed flatbread","slug":"stuffed_flatbread","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🧆","skin_tone_support":false,"name":"falafel","slug":"falafel","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🥚","skin_tone_support":false,"name":"egg","slug":"egg","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍳","skin_tone_support":false,"name":"cooking","slug":"cooking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥘","skin_tone_support":false,"name":"shallow pan of food","slug":"shallow_pan_of_food","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍲","skin_tone_support":false,"name":"pot of food","slug":"pot_of_food","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫕","skin_tone_support":false,"name":"fondue","slug":"fondue","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🥣","skin_tone_support":false,"name":"bowl with spoon","slug":"bowl_with_spoon","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥗","skin_tone_support":false,"name":"green salad","slug":"green_salad","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🍿","skin_tone_support":false,"name":"popcorn","slug":"popcorn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🧈","skin_tone_support":false,"name":"butter","slug":"butter","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧂","skin_tone_support":false,"name":"salt","slug":"salt","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥫","skin_tone_support":false,"name":"canned food","slug":"canned_food","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🍱","skin_tone_support":false,"name":"bento box","slug":"bento_box","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍘","skin_tone_support":false,"name":"rice cracker","slug":"rice_cracker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍙","skin_tone_support":false,"name":"rice ball","slug":"rice_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍚","skin_tone_support":false,"name":"cooked rice","slug":"cooked_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍛","skin_tone_support":false,"name":"curry rice","slug":"curry_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍜","skin_tone_support":false,"name":"steaming bowl","slug":"steaming_bowl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍝","skin_tone_support":false,"name":"spaghetti","slug":"spaghetti","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍠","skin_tone_support":false,"name":"roasted sweet potato","slug":"roasted_sweet_potato","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍢","skin_tone_support":false,"name":"oden","slug":"oden","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍣","skin_tone_support":false,"name":"sushi","slug":"sushi","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍤","skin_tone_support":false,"name":"fried shrimp","slug":"fried_shrimp","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍥","skin_tone_support":false,"name":"fish cake with swirl","slug":"fish_cake_with_swirl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥮","skin_tone_support":false,"name":"moon cake","slug":"moon_cake","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🍡","skin_tone_support":false,"name":"dango","slug":"dango","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥟","skin_tone_support":false,"name":"dumpling","slug":"dumpling","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥠","skin_tone_support":false,"name":"fortune cookie","slug":"fortune_cookie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥡","skin_tone_support":false,"name":"takeout box","slug":"takeout_box","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🍦","skin_tone_support":false,"name":"soft ice cream","slug":"soft_ice_cream","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍧","skin_tone_support":false,"name":"shaved ice","slug":"shaved_ice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍨","skin_tone_support":false,"name":"ice cream","slug":"ice_cream","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍩","skin_tone_support":false,"name":"doughnut","slug":"doughnut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍪","skin_tone_support":false,"name":"cookie","slug":"cookie","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎂","skin_tone_support":false,"name":"birthday cake","slug":"birthday_cake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍰","skin_tone_support":false,"name":"shortcake","slug":"shortcake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧁","skin_tone_support":false,"name":"cupcake","slug":"cupcake","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥧","skin_tone_support":false,"name":"pie","slug":"pie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🍫","skin_tone_support":false,"name":"chocolate bar","slug":"chocolate_bar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍬","skin_tone_support":false,"name":"candy","slug":"candy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍭","skin_tone_support":false,"name":"lollipop","slug":"lollipop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍮","skin_tone_support":false,"name":"custard","slug":"custard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍯","skin_tone_support":false,"name":"honey pot","slug":"honey_pot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍼","skin_tone_support":false,"name":"baby bottle","slug":"baby_bottle","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥛","skin_tone_support":false,"name":"glass of milk","slug":"glass_of_milk","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"☕","skin_tone_support":false,"name":"hot beverage","slug":"hot_beverage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫖","skin_tone_support":false,"name":"teapot","slug":"teapot","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🍵","skin_tone_support":false,"name":"teacup without handle","slug":"teacup_without_handle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍶","skin_tone_support":false,"name":"sake","slug":"sake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍾","skin_tone_support":false,"name":"bottle with popping cork","slug":"bottle_with_popping_cork","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🍷","skin_tone_support":false,"name":"wine glass","slug":"wine_glass","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍸","skin_tone_support":false,"name":"cocktail glass","slug":"cocktail_glass","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍹","skin_tone_support":false,"name":"tropical drink","slug":"tropical_drink","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍺","skin_tone_support":false,"name":"beer mug","slug":"beer_mug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🍻","skin_tone_support":false,"name":"clinking beer mugs","slug":"clinking_beer_mugs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥂","skin_tone_support":false,"name":"clinking glasses","slug":"clinking_glasses","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥃","skin_tone_support":false,"name":"tumbler glass","slug":"tumbler_glass","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🫗","skin_tone_support":false,"name":"pouring liquid","slug":"pouring_liquid","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🥤","skin_tone_support":false,"name":"cup with straw","slug":"cup_with_straw","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧋","skin_tone_support":false,"name":"bubble tea","slug":"bubble_tea","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧃","skin_tone_support":false,"name":"beverage box","slug":"beverage_box","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧉","skin_tone_support":false,"name":"mate","slug":"mate","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧊","skin_tone_support":false,"name":"ice","slug":"ice","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🥢","skin_tone_support":false,"name":"chopsticks","slug":"chopsticks","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🍽️","skin_tone_support":false,"name":"fork and knife with plate","slug":"fork_and_knife_with_plate","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🍴","skin_tone_support":false,"name":"fork and knife","slug":"fork_and_knife","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥄","skin_tone_support":false,"name":"spoon","slug":"spoon","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🔪","skin_tone_support":false,"name":"kitchen knife","slug":"kitchen_knife","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫙","skin_tone_support":false,"name":"jar","slug":"jar","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🏺","skin_tone_support":false,"name":"amphora","slug":"amphora","unicode_version":"1.0","emoji_version":"1.0"}]},{"name":"Travel & Places","slug":"travel_places","emojis":[{"emoji":"🌍","skin_tone_support":false,"name":"globe showing Europe-Africa","slug":"globe_showing_europe_africa","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌎","skin_tone_support":false,"name":"globe showing Americas","slug":"globe_showing_americas","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌏","skin_tone_support":false,"name":"globe showing Asia-Australia","slug":"globe_showing_asia_australia","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌐","skin_tone_support":false,"name":"globe with meridians","slug":"globe_with_meridians","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🗺️","skin_tone_support":false,"name":"world map","slug":"world_map","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🗾","skin_tone_support":false,"name":"map of Japan","slug":"map_of_japan","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧭","skin_tone_support":false,"name":"compass","slug":"compass","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🏔️","skin_tone_support":false,"name":"snow-capped mountain","slug":"snow_capped_mountain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⛰️","skin_tone_support":false,"name":"mountain","slug":"mountain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌋","skin_tone_support":false,"name":"volcano","slug":"volcano","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗻","skin_tone_support":false,"name":"mount fuji","slug":"mount_fuji","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏕️","skin_tone_support":false,"name":"camping","slug":"camping","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏖️","skin_tone_support":false,"name":"beach with umbrella","slug":"beach_with_umbrella","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏜️","skin_tone_support":false,"name":"desert","slug":"desert","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏝️","skin_tone_support":false,"name":"desert island","slug":"desert_island","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏞️","skin_tone_support":false,"name":"national park","slug":"national_park","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏟️","skin_tone_support":false,"name":"stadium","slug":"stadium","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏛️","skin_tone_support":false,"name":"classical building","slug":"classical_building","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏗️","skin_tone_support":false,"name":"building construction","slug":"building_construction","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🧱","skin_tone_support":false,"name":"brick","slug":"brick","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪨","skin_tone_support":false,"name":"rock","slug":"rock","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪵","skin_tone_support":false,"name":"wood","slug":"wood","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🛖","skin_tone_support":false,"name":"hut","slug":"hut","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🏘️","skin_tone_support":false,"name":"houses","slug":"houses","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏚️","skin_tone_support":false,"name":"derelict house","slug":"derelict_house","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏠","skin_tone_support":false,"name":"house","slug":"house","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏡","skin_tone_support":false,"name":"house with garden","slug":"house_with_garden","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏢","skin_tone_support":false,"name":"office building","slug":"office_building","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏣","skin_tone_support":false,"name":"Japanese post office","slug":"japanese_post_office","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏤","skin_tone_support":false,"name":"post office","slug":"post_office","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏥","skin_tone_support":false,"name":"hospital","slug":"hospital","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏦","skin_tone_support":false,"name":"bank","slug":"bank","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏨","skin_tone_support":false,"name":"hotel","slug":"hotel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏩","skin_tone_support":false,"name":"love hotel","slug":"love_hotel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏪","skin_tone_support":false,"name":"convenience store","slug":"convenience_store","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏫","skin_tone_support":false,"name":"school","slug":"school","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏬","skin_tone_support":false,"name":"department store","slug":"department_store","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏭","skin_tone_support":false,"name":"factory","slug":"factory","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏯","skin_tone_support":false,"name":"Japanese castle","slug":"japanese_castle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏰","skin_tone_support":false,"name":"castle","slug":"castle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💒","skin_tone_support":false,"name":"wedding","slug":"wedding","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗼","skin_tone_support":false,"name":"Tokyo tower","slug":"tokyo_tower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗽","skin_tone_support":false,"name":"Statue of Liberty","slug":"statue_of_liberty","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛪","skin_tone_support":false,"name":"church","slug":"church","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕌","skin_tone_support":false,"name":"mosque","slug":"mosque","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛕","skin_tone_support":false,"name":"hindu temple","slug":"hindu_temple","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🕍","skin_tone_support":false,"name":"synagogue","slug":"synagogue","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⛩️","skin_tone_support":false,"name":"shinto shrine","slug":"shinto_shrine","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕋","skin_tone_support":false,"name":"kaaba","slug":"kaaba","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⛲","skin_tone_support":false,"name":"fountain","slug":"fountain","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛺","skin_tone_support":false,"name":"tent","slug":"tent","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌁","skin_tone_support":false,"name":"foggy","slug":"foggy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌃","skin_tone_support":false,"name":"night with stars","slug":"night_with_stars","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏙️","skin_tone_support":false,"name":"cityscape","slug":"cityscape","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌄","skin_tone_support":false,"name":"sunrise over mountains","slug":"sunrise_over_mountains","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌅","skin_tone_support":false,"name":"sunrise","slug":"sunrise","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌆","skin_tone_support":false,"name":"cityscape at dusk","slug":"cityscape_at_dusk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌇","skin_tone_support":false,"name":"sunset","slug":"sunset","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌉","skin_tone_support":false,"name":"bridge at night","slug":"bridge_at_night","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♨️","skin_tone_support":false,"name":"hot springs","slug":"hot_springs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎠","skin_tone_support":false,"name":"carousel horse","slug":"carousel_horse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛝","skin_tone_support":false,"name":"playground slide","slug":"playground_slide","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🎡","skin_tone_support":false,"name":"ferris wheel","slug":"ferris_wheel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎢","skin_tone_support":false,"name":"roller coaster","slug":"roller_coaster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💈","skin_tone_support":false,"name":"barber pole","slug":"barber_pole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎪","skin_tone_support":false,"name":"circus tent","slug":"circus_tent","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚂","skin_tone_support":false,"name":"locomotive","slug":"locomotive","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚃","skin_tone_support":false,"name":"railway car","slug":"railway_car","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚄","skin_tone_support":false,"name":"high-speed train","slug":"high_speed_train","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚅","skin_tone_support":false,"name":"bullet train","slug":"bullet_train","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚆","skin_tone_support":false,"name":"train","slug":"train","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚇","skin_tone_support":false,"name":"metro","slug":"metro","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚈","skin_tone_support":false,"name":"light rail","slug":"light_rail","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚉","skin_tone_support":false,"name":"station","slug":"station","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚊","skin_tone_support":false,"name":"tram","slug":"tram","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚝","skin_tone_support":false,"name":"monorail","slug":"monorail","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚞","skin_tone_support":false,"name":"mountain railway","slug":"mountain_railway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚋","skin_tone_support":false,"name":"tram car","slug":"tram_car","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚌","skin_tone_support":false,"name":"bus","slug":"bus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚍","skin_tone_support":false,"name":"oncoming bus","slug":"oncoming_bus","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🚎","skin_tone_support":false,"name":"trolleybus","slug":"trolleybus","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚐","skin_tone_support":false,"name":"minibus","slug":"minibus","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚑","skin_tone_support":false,"name":"ambulance","slug":"ambulance","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚒","skin_tone_support":false,"name":"fire engine","slug":"fire_engine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚓","skin_tone_support":false,"name":"police car","slug":"police_car","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚔","skin_tone_support":false,"name":"oncoming police car","slug":"oncoming_police_car","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🚕","skin_tone_support":false,"name":"taxi","slug":"taxi","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚖","skin_tone_support":false,"name":"oncoming taxi","slug":"oncoming_taxi","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚗","skin_tone_support":false,"name":"automobile","slug":"automobile","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚘","skin_tone_support":false,"name":"oncoming automobile","slug":"oncoming_automobile","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🚙","skin_tone_support":false,"name":"sport utility vehicle","slug":"sport_utility_vehicle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛻","skin_tone_support":false,"name":"pickup truck","slug":"pickup_truck","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🚚","skin_tone_support":false,"name":"delivery truck","slug":"delivery_truck","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚛","skin_tone_support":false,"name":"articulated lorry","slug":"articulated_lorry","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚜","skin_tone_support":false,"name":"tractor","slug":"tractor","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏎️","skin_tone_support":false,"name":"racing car","slug":"racing_car","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏍️","skin_tone_support":false,"name":"motorcycle","slug":"motorcycle","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛵","skin_tone_support":false,"name":"motor scooter","slug":"motor_scooter","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🦽","skin_tone_support":false,"name":"manual wheelchair","slug":"manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🦼","skin_tone_support":false,"name":"motorized wheelchair","slug":"motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🛺","skin_tone_support":false,"name":"auto rickshaw","slug":"auto_rickshaw","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🚲","skin_tone_support":false,"name":"bicycle","slug":"bicycle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛴","skin_tone_support":false,"name":"kick scooter","slug":"kick_scooter","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🛹","skin_tone_support":false,"name":"skateboard","slug":"skateboard","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🛼","skin_tone_support":false,"name":"roller skate","slug":"roller_skate","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🚏","skin_tone_support":false,"name":"bus stop","slug":"bus_stop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛣️","skin_tone_support":false,"name":"motorway","slug":"motorway","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛤️","skin_tone_support":false,"name":"railway track","slug":"railway_track","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛢️","skin_tone_support":false,"name":"oil drum","slug":"oil_drum","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⛽","skin_tone_support":false,"name":"fuel pump","slug":"fuel_pump","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛞","skin_tone_support":false,"name":"wheel","slug":"wheel","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🚨","skin_tone_support":false,"name":"police car light","slug":"police_car_light","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚥","skin_tone_support":false,"name":"horizontal traffic light","slug":"horizontal_traffic_light","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚦","skin_tone_support":false,"name":"vertical traffic light","slug":"vertical_traffic_light","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛑","skin_tone_support":false,"name":"stop sign","slug":"stop_sign","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🚧","skin_tone_support":false,"name":"construction","slug":"construction","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚓","skin_tone_support":false,"name":"anchor","slug":"anchor","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛟","skin_tone_support":false,"name":"ring buoy","slug":"ring_buoy","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"⛵","skin_tone_support":false,"name":"sailboat","slug":"sailboat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛶","skin_tone_support":false,"name":"canoe","slug":"canoe","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🚤","skin_tone_support":false,"name":"speedboat","slug":"speedboat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛳️","skin_tone_support":false,"name":"passenger ship","slug":"passenger_ship","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⛴️","skin_tone_support":false,"name":"ferry","slug":"ferry","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛥️","skin_tone_support":false,"name":"motor boat","slug":"motor_boat","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🚢","skin_tone_support":false,"name":"ship","slug":"ship","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✈️","skin_tone_support":false,"name":"airplane","slug":"airplane","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛩️","skin_tone_support":false,"name":"small airplane","slug":"small_airplane","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛫","skin_tone_support":false,"name":"airplane departure","slug":"airplane_departure","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛬","skin_tone_support":false,"name":"airplane arrival","slug":"airplane_arrival","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🪂","skin_tone_support":false,"name":"parachute","slug":"parachute","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"💺","skin_tone_support":false,"name":"seat","slug":"seat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚁","skin_tone_support":false,"name":"helicopter","slug":"helicopter","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚟","skin_tone_support":false,"name":"suspension railway","slug":"suspension_railway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚠","skin_tone_support":false,"name":"mountain cableway","slug":"mountain_cableway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚡","skin_tone_support":false,"name":"aerial tramway","slug":"aerial_tramway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛰️","skin_tone_support":false,"name":"satellite","slug":"satellite","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🚀","skin_tone_support":false,"name":"rocket","slug":"rocket","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛸","skin_tone_support":false,"name":"flying saucer","slug":"flying_saucer","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🛎️","skin_tone_support":false,"name":"bellhop bell","slug":"bellhop_bell","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🧳","skin_tone_support":false,"name":"luggage","slug":"luggage","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"⌛","skin_tone_support":false,"name":"hourglass done","slug":"hourglass_done","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏳","skin_tone_support":false,"name":"hourglass not done","slug":"hourglass_not_done","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⌚","skin_tone_support":false,"name":"watch","slug":"watch","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏰","skin_tone_support":false,"name":"alarm clock","slug":"alarm_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏱️","skin_tone_support":false,"name":"stopwatch","slug":"stopwatch","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⏲️","skin_tone_support":false,"name":"timer clock","slug":"timer_clock","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🕰️","skin_tone_support":false,"name":"mantelpiece clock","slug":"mantelpiece_clock","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕛","skin_tone_support":false,"name":"twelve o’clock","slug":"twelve_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕧","skin_tone_support":false,"name":"twelve-thirty","slug":"twelve_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕐","skin_tone_support":false,"name":"one o’clock","slug":"one_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕜","skin_tone_support":false,"name":"one-thirty","slug":"one_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕑","skin_tone_support":false,"name":"two o’clock","slug":"two_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕝","skin_tone_support":false,"name":"two-thirty","slug":"two_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕒","skin_tone_support":false,"name":"three o’clock","slug":"three_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕞","skin_tone_support":false,"name":"three-thirty","slug":"three_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕓","skin_tone_support":false,"name":"four o’clock","slug":"four_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕟","skin_tone_support":false,"name":"four-thirty","slug":"four_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕔","skin_tone_support":false,"name":"five o’clock","slug":"five_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕠","skin_tone_support":false,"name":"five-thirty","slug":"five_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕕","skin_tone_support":false,"name":"six o’clock","slug":"six_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕡","skin_tone_support":false,"name":"six-thirty","slug":"six_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕖","skin_tone_support":false,"name":"seven o’clock","slug":"seven_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕢","skin_tone_support":false,"name":"seven-thirty","slug":"seven_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕗","skin_tone_support":false,"name":"eight o’clock","slug":"eight_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕣","skin_tone_support":false,"name":"eight-thirty","slug":"eight_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕘","skin_tone_support":false,"name":"nine o’clock","slug":"nine_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕤","skin_tone_support":false,"name":"nine-thirty","slug":"nine_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕙","skin_tone_support":false,"name":"ten o’clock","slug":"ten_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕥","skin_tone_support":false,"name":"ten-thirty","slug":"ten_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🕚","skin_tone_support":false,"name":"eleven o’clock","slug":"eleven_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕦","skin_tone_support":false,"name":"eleven-thirty","slug":"eleven_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌑","skin_tone_support":false,"name":"new moon","slug":"new_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌒","skin_tone_support":false,"name":"waxing crescent moon","slug":"waxing_crescent_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌓","skin_tone_support":false,"name":"first quarter moon","slug":"first_quarter_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌔","skin_tone_support":false,"name":"waxing gibbous moon","slug":"waxing_gibbous_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌕","skin_tone_support":false,"name":"full moon","slug":"full_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌖","skin_tone_support":false,"name":"waning gibbous moon","slug":"waning_gibbous_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌗","skin_tone_support":false,"name":"last quarter moon","slug":"last_quarter_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌘","skin_tone_support":false,"name":"waning crescent moon","slug":"waning_crescent_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌙","skin_tone_support":false,"name":"crescent moon","slug":"crescent_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌚","skin_tone_support":false,"name":"new moon face","slug":"new_moon_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌛","skin_tone_support":false,"name":"first quarter moon face","slug":"first_quarter_moon_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌜","skin_tone_support":false,"name":"last quarter moon face","slug":"last_quarter_moon_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌡️","skin_tone_support":false,"name":"thermometer","slug":"thermometer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☀️","skin_tone_support":false,"name":"sun","slug":"sun","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌝","skin_tone_support":false,"name":"full moon face","slug":"full_moon_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🌞","skin_tone_support":false,"name":"sun with face","slug":"sun_with_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🪐","skin_tone_support":false,"name":"ringed planet","slug":"ringed_planet","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"⭐","skin_tone_support":false,"name":"star","slug":"star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌟","skin_tone_support":false,"name":"glowing star","slug":"glowing_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌠","skin_tone_support":false,"name":"shooting star","slug":"shooting_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌌","skin_tone_support":false,"name":"milky way","slug":"milky_way","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☁️","skin_tone_support":false,"name":"cloud","slug":"cloud","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛅","skin_tone_support":false,"name":"sun behind cloud","slug":"sun_behind_cloud","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛈️","skin_tone_support":false,"name":"cloud with lightning and rain","slug":"cloud_with_lightning_and_rain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌤️","skin_tone_support":false,"name":"sun behind small cloud","slug":"sun_behind_small_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌥️","skin_tone_support":false,"name":"sun behind large cloud","slug":"sun_behind_large_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌦️","skin_tone_support":false,"name":"sun behind rain cloud","slug":"sun_behind_rain_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌧️","skin_tone_support":false,"name":"cloud with rain","slug":"cloud_with_rain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌨️","skin_tone_support":false,"name":"cloud with snow","slug":"cloud_with_snow","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌩️","skin_tone_support":false,"name":"cloud with lightning","slug":"cloud_with_lightning","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌪️","skin_tone_support":false,"name":"tornado","slug":"tornado","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌫️","skin_tone_support":false,"name":"fog","slug":"fog","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌬️","skin_tone_support":false,"name":"wind face","slug":"wind_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🌀","skin_tone_support":false,"name":"cyclone","slug":"cyclone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌈","skin_tone_support":false,"name":"rainbow","slug":"rainbow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌂","skin_tone_support":false,"name":"closed umbrella","slug":"closed_umbrella","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☂️","skin_tone_support":false,"name":"umbrella","slug":"umbrella","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☔","skin_tone_support":false,"name":"umbrella with rain drops","slug":"umbrella_with_rain_drops","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛱️","skin_tone_support":false,"name":"umbrella on ground","slug":"umbrella_on_ground","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⚡","skin_tone_support":false,"name":"high voltage","slug":"high_voltage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❄️","skin_tone_support":false,"name":"snowflake","slug":"snowflake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☃️","skin_tone_support":false,"name":"snowman","slug":"snowman","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⛄","skin_tone_support":false,"name":"snowman without snow","slug":"snowman_without_snow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☄️","skin_tone_support":false,"name":"comet","slug":"comet","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔥","skin_tone_support":false,"name":"fire","slug":"fire","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💧","skin_tone_support":false,"name":"droplet","slug":"droplet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🌊","skin_tone_support":false,"name":"water wave","slug":"water_wave","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"Activities","slug":"activities","emojis":[{"emoji":"🎃","skin_tone_support":false,"name":"jack-o-lantern","slug":"jack_o_lantern","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎄","skin_tone_support":false,"name":"Christmas tree","slug":"christmas_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎆","skin_tone_support":false,"name":"fireworks","slug":"fireworks","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎇","skin_tone_support":false,"name":"sparkler","slug":"sparkler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧨","skin_tone_support":false,"name":"firecracker","slug":"firecracker","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"✨","skin_tone_support":false,"name":"sparkles","slug":"sparkles","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎈","skin_tone_support":false,"name":"balloon","slug":"balloon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎉","skin_tone_support":false,"name":"party popper","slug":"party_popper","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎊","skin_tone_support":false,"name":"confetti ball","slug":"confetti_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎋","skin_tone_support":false,"name":"tanabata tree","slug":"tanabata_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎍","skin_tone_support":false,"name":"pine decoration","slug":"pine_decoration","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎎","skin_tone_support":false,"name":"Japanese dolls","slug":"japanese_dolls","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎏","skin_tone_support":false,"name":"carp streamer","slug":"carp_streamer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎐","skin_tone_support":false,"name":"wind chime","slug":"wind_chime","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎑","skin_tone_support":false,"name":"moon viewing ceremony","slug":"moon_viewing_ceremony","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧧","skin_tone_support":false,"name":"red envelope","slug":"red_envelope","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🎀","skin_tone_support":false,"name":"ribbon","slug":"ribbon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎁","skin_tone_support":false,"name":"wrapped gift","slug":"wrapped_gift","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎗️","skin_tone_support":false,"name":"reminder ribbon","slug":"reminder_ribbon","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎟️","skin_tone_support":false,"name":"admission tickets","slug":"admission_tickets","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎫","skin_tone_support":false,"name":"ticket","slug":"ticket","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎖️","skin_tone_support":false,"name":"military medal","slug":"military_medal","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏆","skin_tone_support":false,"name":"trophy","slug":"trophy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏅","skin_tone_support":false,"name":"sports medal","slug":"sports_medal","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥇","skin_tone_support":false,"name":"1st place medal","slug":"1st_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥈","skin_tone_support":false,"name":"2nd place medal","slug":"2nd_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥉","skin_tone_support":false,"name":"3rd place medal","slug":"3rd_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"⚽","skin_tone_support":false,"name":"soccer ball","slug":"soccer_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚾","skin_tone_support":false,"name":"baseball","slug":"baseball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥎","skin_tone_support":false,"name":"softball","slug":"softball","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🏀","skin_tone_support":false,"name":"basketball","slug":"basketball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏐","skin_tone_support":false,"name":"volleyball","slug":"volleyball","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏈","skin_tone_support":false,"name":"american football","slug":"american_football","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏉","skin_tone_support":false,"name":"rugby football","slug":"rugby_football","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🎾","skin_tone_support":false,"name":"tennis","slug":"tennis","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥏","skin_tone_support":false,"name":"flying disc","slug":"flying_disc","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🎳","skin_tone_support":false,"name":"bowling","slug":"bowling","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏏","skin_tone_support":false,"name":"cricket game","slug":"cricket_game","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏑","skin_tone_support":false,"name":"field hockey","slug":"field_hockey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏒","skin_tone_support":false,"name":"ice hockey","slug":"ice_hockey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥍","skin_tone_support":false,"name":"lacrosse","slug":"lacrosse","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🏓","skin_tone_support":false,"name":"ping pong","slug":"ping_pong","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏸","skin_tone_support":false,"name":"badminton","slug":"badminton","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🥊","skin_tone_support":false,"name":"boxing glove","slug":"boxing_glove","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥋","skin_tone_support":false,"name":"martial arts uniform","slug":"martial_arts_uniform","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🥅","skin_tone_support":false,"name":"goal net","slug":"goal_net","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"⛳","skin_tone_support":false,"name":"flag in hole","slug":"flag_in_hole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛸️","skin_tone_support":false,"name":"ice skate","slug":"ice_skate","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎣","skin_tone_support":false,"name":"fishing pole","slug":"fishing_pole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🤿","skin_tone_support":false,"name":"diving mask","slug":"diving_mask","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🎽","skin_tone_support":false,"name":"running shirt","slug":"running_shirt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎿","skin_tone_support":false,"name":"skis","slug":"skis","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛷","skin_tone_support":false,"name":"sled","slug":"sled","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🥌","skin_tone_support":false,"name":"curling stone","slug":"curling_stone","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🎯","skin_tone_support":false,"name":"bullseye","slug":"bullseye","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪀","skin_tone_support":false,"name":"yo-yo","slug":"yo_yo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🪁","skin_tone_support":false,"name":"kite","slug":"kite","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🔫","skin_tone_support":false,"name":"water pistol","slug":"water_pistol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎱","skin_tone_support":false,"name":"pool 8 ball","slug":"pool_8_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔮","skin_tone_support":false,"name":"crystal ball","slug":"crystal_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪄","skin_tone_support":false,"name":"magic wand","slug":"magic_wand","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🎮","skin_tone_support":false,"name":"video game","slug":"video_game","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕹️","skin_tone_support":false,"name":"joystick","slug":"joystick","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎰","skin_tone_support":false,"name":"slot machine","slug":"slot_machine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎲","skin_tone_support":false,"name":"game die","slug":"game_die","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧩","skin_tone_support":false,"name":"puzzle piece","slug":"puzzle_piece","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧸","skin_tone_support":false,"name":"teddy bear","slug":"teddy_bear","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪅","skin_tone_support":false,"name":"piñata","slug":"pinata","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪩","skin_tone_support":false,"name":"mirror ball","slug":"mirror_ball","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🪆","skin_tone_support":false,"name":"nesting dolls","slug":"nesting_dolls","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"♠️","skin_tone_support":false,"name":"spade suit","slug":"spade_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♥️","skin_tone_support":false,"name":"heart suit","slug":"heart_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♦️","skin_tone_support":false,"name":"diamond suit","slug":"diamond_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♣️","skin_tone_support":false,"name":"club suit","slug":"club_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♟️","skin_tone_support":false,"name":"chess pawn","slug":"chess_pawn","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🃏","skin_tone_support":false,"name":"joker","slug":"joker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🀄","skin_tone_support":false,"name":"mahjong red dragon","slug":"mahjong_red_dragon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎴","skin_tone_support":false,"name":"flower playing cards","slug":"flower_playing_cards","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎭","skin_tone_support":false,"name":"performing arts","slug":"performing_arts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖼️","skin_tone_support":false,"name":"framed picture","slug":"framed_picture","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎨","skin_tone_support":false,"name":"artist palette","slug":"artist_palette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧵","skin_tone_support":false,"name":"thread","slug":"thread","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪡","skin_tone_support":false,"name":"sewing needle","slug":"sewing_needle","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧶","skin_tone_support":false,"name":"yarn","slug":"yarn","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪢","skin_tone_support":false,"name":"knot","slug":"knot","unicode_version":"13.0","emoji_version":"13.0"}]},{"name":"Objects","slug":"objects","emojis":[{"emoji":"👓","skin_tone_support":false,"name":"glasses","slug":"glasses","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕶️","skin_tone_support":false,"name":"sunglasses","slug":"sunglasses","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🥽","skin_tone_support":false,"name":"goggles","slug":"goggles","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥼","skin_tone_support":false,"name":"lab coat","slug":"lab_coat","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🦺","skin_tone_support":false,"name":"safety vest","slug":"safety_vest","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👔","skin_tone_support":false,"name":"necktie","slug":"necktie","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👕","skin_tone_support":false,"name":"t-shirt","slug":"t_shirt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👖","skin_tone_support":false,"name":"jeans","slug":"jeans","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧣","skin_tone_support":false,"name":"scarf","slug":"scarf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧤","skin_tone_support":false,"name":"gloves","slug":"gloves","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧥","skin_tone_support":false,"name":"coat","slug":"coat","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🧦","skin_tone_support":false,"name":"socks","slug":"socks","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"👗","skin_tone_support":false,"name":"dress","slug":"dress","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👘","skin_tone_support":false,"name":"kimono","slug":"kimono","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥻","skin_tone_support":false,"name":"sari","slug":"sari","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🩱","skin_tone_support":false,"name":"one-piece swimsuit","slug":"one_piece_swimsuit","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🩲","skin_tone_support":false,"name":"briefs","slug":"briefs","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🩳","skin_tone_support":false,"name":"shorts","slug":"shorts","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👙","skin_tone_support":false,"name":"bikini","slug":"bikini","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👚","skin_tone_support":false,"name":"woman’s clothes","slug":"woman_s_clothes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪭","skin_tone_support":false,"name":"folding hand fan","slug":"folding_hand_fan","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"👛","skin_tone_support":false,"name":"purse","slug":"purse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👜","skin_tone_support":false,"name":"handbag","slug":"handbag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👝","skin_tone_support":false,"name":"clutch bag","slug":"clutch_bag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛍️","skin_tone_support":false,"name":"shopping bags","slug":"shopping_bags","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎒","skin_tone_support":false,"name":"backpack","slug":"backpack","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩴","skin_tone_support":false,"name":"thong sandal","slug":"thong_sandal","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"👞","skin_tone_support":false,"name":"man’s shoe","slug":"man_s_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👟","skin_tone_support":false,"name":"running shoe","slug":"running_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🥾","skin_tone_support":false,"name":"hiking boot","slug":"hiking_boot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🥿","skin_tone_support":false,"name":"flat shoe","slug":"flat_shoe","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"👠","skin_tone_support":false,"name":"high-heeled shoe","slug":"high_heeled_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👡","skin_tone_support":false,"name":"woman’s sandal","slug":"woman_s_sandal","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩰","skin_tone_support":false,"name":"ballet shoes","slug":"ballet_shoes","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"👢","skin_tone_support":false,"name":"woman’s boot","slug":"woman_s_boot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪮","skin_tone_support":false,"name":"hair pick","slug":"hair_pick","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"👑","skin_tone_support":false,"name":"crown","slug":"crown","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"👒","skin_tone_support":false,"name":"woman’s hat","slug":"woman_s_hat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎩","skin_tone_support":false,"name":"top hat","slug":"top_hat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎓","skin_tone_support":false,"name":"graduation cap","slug":"graduation_cap","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧢","skin_tone_support":false,"name":"billed cap","slug":"billed_cap","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🪖","skin_tone_support":false,"name":"military helmet","slug":"military_helmet","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"⛑️","skin_tone_support":false,"name":"rescue worker’s helmet","slug":"rescue_worker_s_helmet","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📿","skin_tone_support":false,"name":"prayer beads","slug":"prayer_beads","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💄","skin_tone_support":false,"name":"lipstick","slug":"lipstick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💍","skin_tone_support":false,"name":"ring","slug":"ring","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💎","skin_tone_support":false,"name":"gem stone","slug":"gem_stone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔇","skin_tone_support":false,"name":"muted speaker","slug":"muted_speaker","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔈","skin_tone_support":false,"name":"speaker low volume","slug":"speaker_low_volume","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🔉","skin_tone_support":false,"name":"speaker medium volume","slug":"speaker_medium_volume","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔊","skin_tone_support":false,"name":"speaker high volume","slug":"speaker_high_volume","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📢","skin_tone_support":false,"name":"loudspeaker","slug":"loudspeaker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📣","skin_tone_support":false,"name":"megaphone","slug":"megaphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📯","skin_tone_support":false,"name":"postal horn","slug":"postal_horn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔔","skin_tone_support":false,"name":"bell","slug":"bell","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔕","skin_tone_support":false,"name":"bell with slash","slug":"bell_with_slash","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🎼","skin_tone_support":false,"name":"musical score","slug":"musical_score","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎵","skin_tone_support":false,"name":"musical note","slug":"musical_note","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎶","skin_tone_support":false,"name":"musical notes","slug":"musical_notes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎙️","skin_tone_support":false,"name":"studio microphone","slug":"studio_microphone","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎚️","skin_tone_support":false,"name":"level slider","slug":"level_slider","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎛️","skin_tone_support":false,"name":"control knobs","slug":"control_knobs","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎤","skin_tone_support":false,"name":"microphone","slug":"microphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎧","skin_tone_support":false,"name":"headphone","slug":"headphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📻","skin_tone_support":false,"name":"radio","slug":"radio","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎷","skin_tone_support":false,"name":"saxophone","slug":"saxophone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪗","skin_tone_support":false,"name":"accordion","slug":"accordion","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🎸","skin_tone_support":false,"name":"guitar","slug":"guitar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎹","skin_tone_support":false,"name":"musical keyboard","slug":"musical_keyboard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎺","skin_tone_support":false,"name":"trumpet","slug":"trumpet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎻","skin_tone_support":false,"name":"violin","slug":"violin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪕","skin_tone_support":false,"name":"banjo","slug":"banjo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🥁","skin_tone_support":false,"name":"drum","slug":"drum","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🪘","skin_tone_support":false,"name":"long drum","slug":"long_drum","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪇","skin_tone_support":false,"name":"maracas","slug":"maracas","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🪈","skin_tone_support":false,"name":"flute","slug":"flute","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"🪉","skin_tone_support":false,"name":"harp","slug":"harp","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"📱","skin_tone_support":false,"name":"mobile phone","slug":"mobile_phone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📲","skin_tone_support":false,"name":"mobile phone with arrow","slug":"mobile_phone_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☎️","skin_tone_support":false,"name":"telephone","slug":"telephone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📞","skin_tone_support":false,"name":"telephone receiver","slug":"telephone_receiver","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📟","skin_tone_support":false,"name":"pager","slug":"pager","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📠","skin_tone_support":false,"name":"fax machine","slug":"fax_machine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔋","skin_tone_support":false,"name":"battery","slug":"battery","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪫","skin_tone_support":false,"name":"low battery","slug":"low_battery","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🔌","skin_tone_support":false,"name":"electric plug","slug":"electric_plug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💻","skin_tone_support":false,"name":"laptop","slug":"laptop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖥️","skin_tone_support":false,"name":"desktop computer","slug":"desktop_computer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🖨️","skin_tone_support":false,"name":"printer","slug":"printer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⌨️","skin_tone_support":false,"name":"keyboard","slug":"keyboard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🖱️","skin_tone_support":false,"name":"computer mouse","slug":"computer_mouse","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🖲️","skin_tone_support":false,"name":"trackball","slug":"trackball","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💽","skin_tone_support":false,"name":"computer disk","slug":"computer_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💾","skin_tone_support":false,"name":"floppy disk","slug":"floppy_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💿","skin_tone_support":false,"name":"optical disk","slug":"optical_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📀","skin_tone_support":false,"name":"dvd","slug":"dvd","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧮","skin_tone_support":false,"name":"abacus","slug":"abacus","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🎥","skin_tone_support":false,"name":"movie camera","slug":"movie_camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎞️","skin_tone_support":false,"name":"film frames","slug":"film_frames","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📽️","skin_tone_support":false,"name":"film projector","slug":"film_projector","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🎬","skin_tone_support":false,"name":"clapper board","slug":"clapper_board","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📺","skin_tone_support":false,"name":"television","slug":"television","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📷","skin_tone_support":false,"name":"camera","slug":"camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📸","skin_tone_support":false,"name":"camera with flash","slug":"camera_with_flash","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"📹","skin_tone_support":false,"name":"video camera","slug":"video_camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📼","skin_tone_support":false,"name":"videocassette","slug":"videocassette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔍","skin_tone_support":false,"name":"magnifying glass tilted left","slug":"magnifying_glass_tilted_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔎","skin_tone_support":false,"name":"magnifying glass tilted right","slug":"magnifying_glass_tilted_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🕯️","skin_tone_support":false,"name":"candle","slug":"candle","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💡","skin_tone_support":false,"name":"light bulb","slug":"light_bulb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔦","skin_tone_support":false,"name":"flashlight","slug":"flashlight","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏮","skin_tone_support":false,"name":"red paper lantern","slug":"red_paper_lantern","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪔","skin_tone_support":false,"name":"diya lamp","slug":"diya_lamp","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"📔","skin_tone_support":false,"name":"notebook with decorative cover","slug":"notebook_with_decorative_cover","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📕","skin_tone_support":false,"name":"closed book","slug":"closed_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📖","skin_tone_support":false,"name":"open book","slug":"open_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📗","skin_tone_support":false,"name":"green book","slug":"green_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📘","skin_tone_support":false,"name":"blue book","slug":"blue_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📙","skin_tone_support":false,"name":"orange book","slug":"orange_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📚","skin_tone_support":false,"name":"books","slug":"books","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📓","skin_tone_support":false,"name":"notebook","slug":"notebook","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📒","skin_tone_support":false,"name":"ledger","slug":"ledger","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📃","skin_tone_support":false,"name":"page with curl","slug":"page_with_curl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📜","skin_tone_support":false,"name":"scroll","slug":"scroll","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📄","skin_tone_support":false,"name":"page facing up","slug":"page_facing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📰","skin_tone_support":false,"name":"newspaper","slug":"newspaper","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗞️","skin_tone_support":false,"name":"rolled-up newspaper","slug":"rolled_up_newspaper","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📑","skin_tone_support":false,"name":"bookmark tabs","slug":"bookmark_tabs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔖","skin_tone_support":false,"name":"bookmark","slug":"bookmark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏷️","skin_tone_support":false,"name":"label","slug":"label","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"💰","skin_tone_support":false,"name":"money bag","slug":"money_bag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪙","skin_tone_support":false,"name":"coin","slug":"coin","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"💴","skin_tone_support":false,"name":"yen banknote","slug":"yen_banknote","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💵","skin_tone_support":false,"name":"dollar banknote","slug":"dollar_banknote","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💶","skin_tone_support":false,"name":"euro banknote","slug":"euro_banknote","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💷","skin_tone_support":false,"name":"pound banknote","slug":"pound_banknote","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💸","skin_tone_support":false,"name":"money with wings","slug":"money_with_wings","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💳","skin_tone_support":false,"name":"credit card","slug":"credit_card","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🧾","skin_tone_support":false,"name":"receipt","slug":"receipt","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"💹","skin_tone_support":false,"name":"chart increasing with yen","slug":"chart_increasing_with_yen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✉️","skin_tone_support":false,"name":"envelope","slug":"envelope","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📧","skin_tone_support":false,"name":"e-mail","slug":"e_mail","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📨","skin_tone_support":false,"name":"incoming envelope","slug":"incoming_envelope","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📩","skin_tone_support":false,"name":"envelope with arrow","slug":"envelope_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📤","skin_tone_support":false,"name":"outbox tray","slug":"outbox_tray","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📥","skin_tone_support":false,"name":"inbox tray","slug":"inbox_tray","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📦","skin_tone_support":false,"name":"package","slug":"package","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📫","skin_tone_support":false,"name":"closed mailbox with raised flag","slug":"closed_mailbox_with_raised_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📪","skin_tone_support":false,"name":"closed mailbox with lowered flag","slug":"closed_mailbox_with_lowered_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📬","skin_tone_support":false,"name":"open mailbox with raised flag","slug":"open_mailbox_with_raised_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📭","skin_tone_support":false,"name":"open mailbox with lowered flag","slug":"open_mailbox_with_lowered_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📮","skin_tone_support":false,"name":"postbox","slug":"postbox","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗳️","skin_tone_support":false,"name":"ballot box with ballot","slug":"ballot_box_with_ballot","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"✏️","skin_tone_support":false,"name":"pencil","slug":"pencil","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✒️","skin_tone_support":false,"name":"black nib","slug":"black_nib","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖋️","skin_tone_support":false,"name":"fountain pen","slug":"fountain_pen","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🖊️","skin_tone_support":false,"name":"pen","slug":"pen","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🖌️","skin_tone_support":false,"name":"paintbrush","slug":"paintbrush","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🖍️","skin_tone_support":false,"name":"crayon","slug":"crayon","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📝","skin_tone_support":false,"name":"memo","slug":"memo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💼","skin_tone_support":false,"name":"briefcase","slug":"briefcase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📁","skin_tone_support":false,"name":"file folder","slug":"file_folder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📂","skin_tone_support":false,"name":"open file folder","slug":"open_file_folder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗂️","skin_tone_support":false,"name":"card index dividers","slug":"card_index_dividers","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📅","skin_tone_support":false,"name":"calendar","slug":"calendar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📆","skin_tone_support":false,"name":"tear-off calendar","slug":"tear_off_calendar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗒️","skin_tone_support":false,"name":"spiral notepad","slug":"spiral_notepad","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🗓️","skin_tone_support":false,"name":"spiral calendar","slug":"spiral_calendar","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📇","skin_tone_support":false,"name":"card index","slug":"card_index","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📈","skin_tone_support":false,"name":"chart increasing","slug":"chart_increasing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📉","skin_tone_support":false,"name":"chart decreasing","slug":"chart_decreasing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📊","skin_tone_support":false,"name":"bar chart","slug":"bar_chart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📋","skin_tone_support":false,"name":"clipboard","slug":"clipboard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📌","skin_tone_support":false,"name":"pushpin","slug":"pushpin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📍","skin_tone_support":false,"name":"round pushpin","slug":"round_pushpin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📎","skin_tone_support":false,"name":"paperclip","slug":"paperclip","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🖇️","skin_tone_support":false,"name":"linked paperclips","slug":"linked_paperclips","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"📏","skin_tone_support":false,"name":"straight ruler","slug":"straight_ruler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📐","skin_tone_support":false,"name":"triangular ruler","slug":"triangular_ruler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✂️","skin_tone_support":false,"name":"scissors","slug":"scissors","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗃️","skin_tone_support":false,"name":"card file box","slug":"card_file_box","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🗄️","skin_tone_support":false,"name":"file cabinet","slug":"file_cabinet","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🗑️","skin_tone_support":false,"name":"wastebasket","slug":"wastebasket","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🔒","skin_tone_support":false,"name":"locked","slug":"locked","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔓","skin_tone_support":false,"name":"unlocked","slug":"unlocked","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔏","skin_tone_support":false,"name":"locked with pen","slug":"locked_with_pen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔐","skin_tone_support":false,"name":"locked with key","slug":"locked_with_key","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔑","skin_tone_support":false,"name":"key","slug":"key","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🗝️","skin_tone_support":false,"name":"old key","slug":"old_key","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🔨","skin_tone_support":false,"name":"hammer","slug":"hammer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪓","skin_tone_support":false,"name":"axe","slug":"axe","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"⛏️","skin_tone_support":false,"name":"pick","slug":"pick","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⚒️","skin_tone_support":false,"name":"hammer and pick","slug":"hammer_and_pick","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛠️","skin_tone_support":false,"name":"hammer and wrench","slug":"hammer_and_wrench","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🗡️","skin_tone_support":false,"name":"dagger","slug":"dagger","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⚔️","skin_tone_support":false,"name":"crossed swords","slug":"crossed_swords","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"💣","skin_tone_support":false,"name":"bomb","slug":"bomb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪃","skin_tone_support":false,"name":"boomerang","slug":"boomerang","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🏹","skin_tone_support":false,"name":"bow and arrow","slug":"bow_and_arrow","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛡️","skin_tone_support":false,"name":"shield","slug":"shield","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🪚","skin_tone_support":false,"name":"carpentry saw","slug":"carpentry_saw","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🔧","skin_tone_support":false,"name":"wrench","slug":"wrench","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪛","skin_tone_support":false,"name":"screwdriver","slug":"screwdriver","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🔩","skin_tone_support":false,"name":"nut and bolt","slug":"nut_and_bolt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚙️","skin_tone_support":false,"name":"gear","slug":"gear","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🗜️","skin_tone_support":false,"name":"clamp","slug":"clamp","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⚖️","skin_tone_support":false,"name":"balance scale","slug":"balance_scale","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🦯","skin_tone_support":false,"name":"white cane","slug":"white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🔗","skin_tone_support":false,"name":"link","slug":"link","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛓️‍💥","skin_tone_support":false,"name":"broken chain","slug":"broken_chain","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"⛓️","skin_tone_support":false,"name":"chains","slug":"chains","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🪝","skin_tone_support":false,"name":"hook","slug":"hook","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧰","skin_tone_support":false,"name":"toolbox","slug":"toolbox","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧲","skin_tone_support":false,"name":"magnet","slug":"magnet","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪜","skin_tone_support":false,"name":"ladder","slug":"ladder","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪏","skin_tone_support":false,"name":"shovel","slug":"shovel","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"⚗️","skin_tone_support":false,"name":"alembic","slug":"alembic","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🧪","skin_tone_support":false,"name":"test tube","slug":"test_tube","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧫","skin_tone_support":false,"name":"petri dish","slug":"petri_dish","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧬","skin_tone_support":false,"name":"dna","slug":"dna","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🔬","skin_tone_support":false,"name":"microscope","slug":"microscope","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔭","skin_tone_support":false,"name":"telescope","slug":"telescope","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"📡","skin_tone_support":false,"name":"satellite antenna","slug":"satellite_antenna","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💉","skin_tone_support":false,"name":"syringe","slug":"syringe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩸","skin_tone_support":false,"name":"drop of blood","slug":"drop_of_blood","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"💊","skin_tone_support":false,"name":"pill","slug":"pill","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🩹","skin_tone_support":false,"name":"adhesive bandage","slug":"adhesive_bandage","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🩼","skin_tone_support":false,"name":"crutch","slug":"crutch","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🩺","skin_tone_support":false,"name":"stethoscope","slug":"stethoscope","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🩻","skin_tone_support":false,"name":"x-ray","slug":"x_ray","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🚪","skin_tone_support":false,"name":"door","slug":"door","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛗","skin_tone_support":false,"name":"elevator","slug":"elevator","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪞","skin_tone_support":false,"name":"mirror","slug":"mirror","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪟","skin_tone_support":false,"name":"window","slug":"window","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🛏️","skin_tone_support":false,"name":"bed","slug":"bed","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🛋️","skin_tone_support":false,"name":"couch and lamp","slug":"couch_and_lamp","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🪑","skin_tone_support":false,"name":"chair","slug":"chair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🚽","skin_tone_support":false,"name":"toilet","slug":"toilet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪠","skin_tone_support":false,"name":"plunger","slug":"plunger","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🚿","skin_tone_support":false,"name":"shower","slug":"shower","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛁","skin_tone_support":false,"name":"bathtub","slug":"bathtub","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🪤","skin_tone_support":false,"name":"mouse trap","slug":"mouse_trap","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪒","skin_tone_support":false,"name":"razor","slug":"razor","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🧴","skin_tone_support":false,"name":"lotion bottle","slug":"lotion_bottle","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧷","skin_tone_support":false,"name":"safety pin","slug":"safety_pin","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧹","skin_tone_support":false,"name":"broom","slug":"broom","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧺","skin_tone_support":false,"name":"basket","slug":"basket","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧻","skin_tone_support":false,"name":"roll of paper","slug":"roll_of_paper","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪣","skin_tone_support":false,"name":"bucket","slug":"bucket","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧼","skin_tone_support":false,"name":"soap","slug":"soap","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🫧","skin_tone_support":false,"name":"bubbles","slug":"bubbles","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🪥","skin_tone_support":false,"name":"toothbrush","slug":"toothbrush","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🧽","skin_tone_support":false,"name":"sponge","slug":"sponge","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🧯","skin_tone_support":false,"name":"fire extinguisher","slug":"fire_extinguisher","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🛒","skin_tone_support":false,"name":"shopping cart","slug":"shopping_cart","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"🚬","skin_tone_support":false,"name":"cigarette","slug":"cigarette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚰️","skin_tone_support":false,"name":"coffin","slug":"coffin","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🪦","skin_tone_support":false,"name":"headstone","slug":"headstone","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"⚱️","skin_tone_support":false,"name":"funeral urn","slug":"funeral_urn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🧿","skin_tone_support":false,"name":"nazar amulet","slug":"nazar_amulet","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🪬","skin_tone_support":false,"name":"hamsa","slug":"hamsa","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"🗿","skin_tone_support":false,"name":"moai","slug":"moai","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪧","skin_tone_support":false,"name":"placard","slug":"placard","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🪪","skin_tone_support":false,"name":"identification card","slug":"identification_card","unicode_version":"14.0","emoji_version":"14.0"}]},{"name":"Symbols","slug":"symbols","emojis":[{"emoji":"🏧","skin_tone_support":false,"name":"ATM sign","slug":"atm_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚮","skin_tone_support":false,"name":"litter in bin sign","slug":"litter_in_bin_sign","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚰","skin_tone_support":false,"name":"potable water","slug":"potable_water","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"♿","skin_tone_support":false,"name":"wheelchair symbol","slug":"wheelchair_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚹","skin_tone_support":false,"name":"men’s room","slug":"men_s_room","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚺","skin_tone_support":false,"name":"women’s room","slug":"women_s_room","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚻","skin_tone_support":false,"name":"restroom","slug":"restroom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚼","skin_tone_support":false,"name":"baby symbol","slug":"baby_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚾","skin_tone_support":false,"name":"water closet","slug":"water_closet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛂","skin_tone_support":false,"name":"passport control","slug":"passport_control","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛃","skin_tone_support":false,"name":"customs","slug":"customs","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛄","skin_tone_support":false,"name":"baggage claim","slug":"baggage_claim","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🛅","skin_tone_support":false,"name":"left luggage","slug":"left_luggage","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⚠️","skin_tone_support":false,"name":"warning","slug":"warning","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚸","skin_tone_support":false,"name":"children crossing","slug":"children_crossing","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⛔","skin_tone_support":false,"name":"no entry","slug":"no_entry","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚫","skin_tone_support":false,"name":"prohibited","slug":"prohibited","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚳","skin_tone_support":false,"name":"no bicycles","slug":"no_bicycles","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚭","skin_tone_support":false,"name":"no smoking","slug":"no_smoking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚯","skin_tone_support":false,"name":"no littering","slug":"no_littering","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚱","skin_tone_support":false,"name":"non-potable water","slug":"non_potable_water","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🚷","skin_tone_support":false,"name":"no pedestrians","slug":"no_pedestrians","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"📵","skin_tone_support":false,"name":"no mobile phones","slug":"no_mobile_phones","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔞","skin_tone_support":false,"name":"no one under eighteen","slug":"no_one_under_eighteen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☢️","skin_tone_support":false,"name":"radioactive","slug":"radioactive","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"☣️","skin_tone_support":false,"name":"biohazard","slug":"biohazard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⬆️","skin_tone_support":false,"name":"up arrow","slug":"up_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↗️","skin_tone_support":false,"name":"up-right arrow","slug":"up_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➡️","skin_tone_support":false,"name":"right arrow","slug":"right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↘️","skin_tone_support":false,"name":"down-right arrow","slug":"down_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⬇️","skin_tone_support":false,"name":"down arrow","slug":"down_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↙️","skin_tone_support":false,"name":"down-left arrow","slug":"down_left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⬅️","skin_tone_support":false,"name":"left arrow","slug":"left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↖️","skin_tone_support":false,"name":"up-left arrow","slug":"up_left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↕️","skin_tone_support":false,"name":"up-down arrow","slug":"up_down_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↔️","skin_tone_support":false,"name":"left-right arrow","slug":"left_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↩️","skin_tone_support":false,"name":"right arrow curving left","slug":"right_arrow_curving_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"↪️","skin_tone_support":false,"name":"left arrow curving right","slug":"left_arrow_curving_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⤴️","skin_tone_support":false,"name":"right arrow curving up","slug":"right_arrow_curving_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⤵️","skin_tone_support":false,"name":"right arrow curving down","slug":"right_arrow_curving_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔃","skin_tone_support":false,"name":"clockwise vertical arrows","slug":"clockwise_vertical_arrows","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔄","skin_tone_support":false,"name":"counterclockwise arrows button","slug":"counterclockwise_arrows_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔙","skin_tone_support":false,"name":"BACK arrow","slug":"back_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔚","skin_tone_support":false,"name":"END arrow","slug":"end_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔛","skin_tone_support":false,"name":"ON! arrow","slug":"on_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔜","skin_tone_support":false,"name":"SOON arrow","slug":"soon_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔝","skin_tone_support":false,"name":"TOP arrow","slug":"top_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛐","skin_tone_support":false,"name":"place of worship","slug":"place_of_worship","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"⚛️","skin_tone_support":false,"name":"atom symbol","slug":"atom_symbol","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🕉️","skin_tone_support":false,"name":"om","slug":"om","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"✡️","skin_tone_support":false,"name":"star of David","slug":"star_of_david","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☸️","skin_tone_support":false,"name":"wheel of dharma","slug":"wheel_of_dharma","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☯️","skin_tone_support":false,"name":"yin yang","slug":"yin_yang","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"✝️","skin_tone_support":false,"name":"latin cross","slug":"latin_cross","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☦️","skin_tone_support":false,"name":"orthodox cross","slug":"orthodox_cross","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"☪️","skin_tone_support":false,"name":"star and crescent","slug":"star_and_crescent","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"☮️","skin_tone_support":false,"name":"peace symbol","slug":"peace_symbol","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🕎","skin_tone_support":false,"name":"menorah","slug":"menorah","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔯","skin_tone_support":false,"name":"dotted six-pointed star","slug":"dotted_six_pointed_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🪯","skin_tone_support":false,"name":"khanda","slug":"khanda","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"♈","skin_tone_support":false,"name":"Aries","slug":"aries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♉","skin_tone_support":false,"name":"Taurus","slug":"taurus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♊","skin_tone_support":false,"name":"Gemini","slug":"gemini","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♋","skin_tone_support":false,"name":"Cancer","slug":"cancer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♌","skin_tone_support":false,"name":"Leo","slug":"leo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♍","skin_tone_support":false,"name":"Virgo","slug":"virgo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♎","skin_tone_support":false,"name":"Libra","slug":"libra","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♏","skin_tone_support":false,"name":"Scorpio","slug":"scorpio","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♐","skin_tone_support":false,"name":"Sagittarius","slug":"sagittarius","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♑","skin_tone_support":false,"name":"Capricorn","slug":"capricorn","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♒","skin_tone_support":false,"name":"Aquarius","slug":"aquarius","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♓","skin_tone_support":false,"name":"Pisces","slug":"pisces","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⛎","skin_tone_support":false,"name":"Ophiuchus","slug":"ophiuchus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔀","skin_tone_support":false,"name":"shuffle tracks button","slug":"shuffle_tracks_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔁","skin_tone_support":false,"name":"repeat button","slug":"repeat_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔂","skin_tone_support":false,"name":"repeat single button","slug":"repeat_single_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"▶️","skin_tone_support":false,"name":"play button","slug":"play_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏩","skin_tone_support":false,"name":"fast-forward button","slug":"fast_forward_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏭️","skin_tone_support":false,"name":"next track button","slug":"next_track_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⏯️","skin_tone_support":false,"name":"play or pause button","slug":"play_or_pause_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"◀️","skin_tone_support":false,"name":"reverse button","slug":"reverse_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏪","skin_tone_support":false,"name":"fast reverse button","slug":"fast_reverse_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏮️","skin_tone_support":false,"name":"last track button","slug":"last_track_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🔼","skin_tone_support":false,"name":"upwards button","slug":"upwards_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏫","skin_tone_support":false,"name":"fast up button","slug":"fast_up_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔽","skin_tone_support":false,"name":"downwards button","slug":"downwards_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏬","skin_tone_support":false,"name":"fast down button","slug":"fast_down_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⏸️","skin_tone_support":false,"name":"pause button","slug":"pause_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⏹️","skin_tone_support":false,"name":"stop button","slug":"stop_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⏺️","skin_tone_support":false,"name":"record button","slug":"record_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"⏏️","skin_tone_support":false,"name":"eject button","slug":"eject_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🎦","skin_tone_support":false,"name":"cinema","slug":"cinema","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔅","skin_tone_support":false,"name":"dim button","slug":"dim_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔆","skin_tone_support":false,"name":"bright button","slug":"bright_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"📶","skin_tone_support":false,"name":"antenna bars","slug":"antenna_bars","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🛜","skin_tone_support":false,"name":"wireless","slug":"wireless","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"📳","skin_tone_support":false,"name":"vibration mode","slug":"vibration_mode","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📴","skin_tone_support":false,"name":"mobile phone off","slug":"mobile_phone_off","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"♀️","skin_tone_support":false,"name":"female sign","slug":"female_sign","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"♂️","skin_tone_support":false,"name":"male sign","slug":"male_sign","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"⚧️","skin_tone_support":false,"name":"transgender symbol","slug":"transgender_symbol","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"✖️","skin_tone_support":false,"name":"multiply","slug":"multiply","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➕","skin_tone_support":false,"name":"plus","slug":"plus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➖","skin_tone_support":false,"name":"minus","slug":"minus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➗","skin_tone_support":false,"name":"divide","slug":"divide","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🟰","skin_tone_support":false,"name":"heavy equals sign","slug":"heavy_equals_sign","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"♾️","skin_tone_support":false,"name":"infinity","slug":"infinity","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"‼️","skin_tone_support":false,"name":"double exclamation mark","slug":"double_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⁉️","skin_tone_support":false,"name":"exclamation question mark","slug":"exclamation_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❓","skin_tone_support":false,"name":"red question mark","slug":"red_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❔","skin_tone_support":false,"name":"white question mark","slug":"white_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❕","skin_tone_support":false,"name":"white exclamation mark","slug":"white_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❗","skin_tone_support":false,"name":"red exclamation mark","slug":"red_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"〰️","skin_tone_support":false,"name":"wavy dash","slug":"wavy_dash","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💱","skin_tone_support":false,"name":"currency exchange","slug":"currency_exchange","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💲","skin_tone_support":false,"name":"heavy dollar sign","slug":"heavy_dollar_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚕️","skin_tone_support":false,"name":"medical symbol","slug":"medical_symbol","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"♻️","skin_tone_support":false,"name":"recycling symbol","slug":"recycling_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚜️","skin_tone_support":false,"name":"fleur-de-lis","slug":"fleur_de_lis","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🔱","skin_tone_support":false,"name":"trident emblem","slug":"trident_emblem","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"📛","skin_tone_support":false,"name":"name badge","slug":"name_badge","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔰","skin_tone_support":false,"name":"Japanese symbol for beginner","slug":"japanese_symbol_for_beginner","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⭕","skin_tone_support":false,"name":"hollow red circle","slug":"hollow_red_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✅","skin_tone_support":false,"name":"check mark button","slug":"check_mark_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"☑️","skin_tone_support":false,"name":"check box with check","slug":"check_box_with_check","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✔️","skin_tone_support":false,"name":"check mark","slug":"check_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❌","skin_tone_support":false,"name":"cross mark","slug":"cross_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❎","skin_tone_support":false,"name":"cross mark button","slug":"cross_mark_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➰","skin_tone_support":false,"name":"curly loop","slug":"curly_loop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"➿","skin_tone_support":false,"name":"double curly loop","slug":"double_curly_loop","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"〽️","skin_tone_support":false,"name":"part alternation mark","slug":"part_alternation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✳️","skin_tone_support":false,"name":"eight-spoked asterisk","slug":"eight_spoked_asterisk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"✴️","skin_tone_support":false,"name":"eight-pointed star","slug":"eight_pointed_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"❇️","skin_tone_support":false,"name":"sparkle","slug":"sparkle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"©️","skin_tone_support":false,"name":"copyright","slug":"copyright","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"®️","skin_tone_support":false,"name":"registered","slug":"registered","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"™️","skin_tone_support":false,"name":"trade mark","slug":"trade_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🫟","skin_tone_support":false,"name":"splatter","slug":"splatter","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"#️⃣","skin_tone_support":false,"name":"keycap #","slug":"keycap_number_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"*️⃣","skin_tone_support":false,"name":"keycap *","slug":"keycap_asterisk","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"0️⃣","skin_tone_support":false,"name":"keycap 0","slug":"keycap_0","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"1️⃣","skin_tone_support":false,"name":"keycap 1","slug":"keycap_1","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"2️⃣","skin_tone_support":false,"name":"keycap 2","slug":"keycap_2","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"3️⃣","skin_tone_support":false,"name":"keycap 3","slug":"keycap_3","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"4️⃣","skin_tone_support":false,"name":"keycap 4","slug":"keycap_4","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"5️⃣","skin_tone_support":false,"name":"keycap 5","slug":"keycap_5","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"6️⃣","skin_tone_support":false,"name":"keycap 6","slug":"keycap_6","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"7️⃣","skin_tone_support":false,"name":"keycap 7","slug":"keycap_7","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"8️⃣","skin_tone_support":false,"name":"keycap 8","slug":"keycap_8","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"9️⃣","skin_tone_support":false,"name":"keycap 9","slug":"keycap_9","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔟","skin_tone_support":false,"name":"keycap 10","slug":"keycap_10","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔠","skin_tone_support":false,"name":"input latin uppercase","slug":"input_latin_uppercase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔡","skin_tone_support":false,"name":"input latin lowercase","slug":"input_latin_lowercase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔢","skin_tone_support":false,"name":"input numbers","slug":"input_numbers","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔣","skin_tone_support":false,"name":"input symbols","slug":"input_symbols","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔤","skin_tone_support":false,"name":"input latin letters","slug":"input_latin_letters","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🅰️","skin_tone_support":false,"name":"A button (blood type)","slug":"a_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆎","skin_tone_support":false,"name":"AB button (blood type)","slug":"ab_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🅱️","skin_tone_support":false,"name":"B button (blood type)","slug":"b_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆑","skin_tone_support":false,"name":"CL button","slug":"cl_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆒","skin_tone_support":false,"name":"COOL button","slug":"cool_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆓","skin_tone_support":false,"name":"FREE button","slug":"free_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"ℹ️","skin_tone_support":false,"name":"information","slug":"information","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆔","skin_tone_support":false,"name":"ID button","slug":"id_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"Ⓜ️","skin_tone_support":false,"name":"circled M","slug":"circled_m","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆕","skin_tone_support":false,"name":"NEW button","slug":"new_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆖","skin_tone_support":false,"name":"NG button","slug":"ng_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🅾️","skin_tone_support":false,"name":"O button (blood type)","slug":"o_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆗","skin_tone_support":false,"name":"OK button","slug":"ok_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🅿️","skin_tone_support":false,"name":"P button","slug":"p_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆘","skin_tone_support":false,"name":"SOS button","slug":"sos_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆙","skin_tone_support":false,"name":"UP! button","slug":"up_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🆚","skin_tone_support":false,"name":"VS button","slug":"vs_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈁","skin_tone_support":false,"name":"Japanese “here” button","slug":"japanese_here_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈂️","skin_tone_support":false,"name":"Japanese “service charge” button","slug":"japanese_service_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈷️","skin_tone_support":false,"name":"Japanese “monthly amount” button","slug":"japanese_monthly_amount_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈶","skin_tone_support":false,"name":"Japanese “not free of charge” button","slug":"japanese_not_free_of_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈯","skin_tone_support":false,"name":"Japanese “reserved” button","slug":"japanese_reserved_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🉐","skin_tone_support":false,"name":"Japanese “bargain” button","slug":"japanese_bargain_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈹","skin_tone_support":false,"name":"Japanese “discount” button","slug":"japanese_discount_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈚","skin_tone_support":false,"name":"Japanese “free of charge” button","slug":"japanese_free_of_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈲","skin_tone_support":false,"name":"Japanese “prohibited” button","slug":"japanese_prohibited_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🉑","skin_tone_support":false,"name":"Japanese “acceptable” button","slug":"japanese_acceptable_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈸","skin_tone_support":false,"name":"Japanese “application” button","slug":"japanese_application_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈴","skin_tone_support":false,"name":"Japanese “passing grade” button","slug":"japanese_passing_grade_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈳","skin_tone_support":false,"name":"Japanese “vacancy” button","slug":"japanese_vacancy_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"㊗️","skin_tone_support":false,"name":"Japanese “congratulations” button","slug":"japanese_congratulations_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"㊙️","skin_tone_support":false,"name":"Japanese “secret” button","slug":"japanese_secret_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈺","skin_tone_support":false,"name":"Japanese “open for business” button","slug":"japanese_open_for_business_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🈵","skin_tone_support":false,"name":"Japanese “no vacancy” button","slug":"japanese_no_vacancy_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔴","skin_tone_support":false,"name":"red circle","slug":"red_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🟠","skin_tone_support":false,"name":"orange circle","slug":"orange_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟡","skin_tone_support":false,"name":"yellow circle","slug":"yellow_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟢","skin_tone_support":false,"name":"green circle","slug":"green_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🔵","skin_tone_support":false,"name":"blue circle","slug":"blue_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🟣","skin_tone_support":false,"name":"purple circle","slug":"purple_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟤","skin_tone_support":false,"name":"brown circle","slug":"brown_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"⚫","skin_tone_support":false,"name":"black circle","slug":"black_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⚪","skin_tone_support":false,"name":"white circle","slug":"white_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🟥","skin_tone_support":false,"name":"red square","slug":"red_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟧","skin_tone_support":false,"name":"orange square","slug":"orange_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟨","skin_tone_support":false,"name":"yellow square","slug":"yellow_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟩","skin_tone_support":false,"name":"green square","slug":"green_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟦","skin_tone_support":false,"name":"blue square","slug":"blue_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟪","skin_tone_support":false,"name":"purple square","slug":"purple_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"🟫","skin_tone_support":false,"name":"brown square","slug":"brown_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"⬛","skin_tone_support":false,"name":"black large square","slug":"black_large_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"⬜","skin_tone_support":false,"name":"white large square","slug":"white_large_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"◼️","skin_tone_support":false,"name":"black medium square","slug":"black_medium_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"◻️","skin_tone_support":false,"name":"white medium square","slug":"white_medium_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"◾","skin_tone_support":false,"name":"black medium-small square","slug":"black_medium_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"◽","skin_tone_support":false,"name":"white medium-small square","slug":"white_medium_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"▪️","skin_tone_support":false,"name":"black small square","slug":"black_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"▫️","skin_tone_support":false,"name":"white small square","slug":"white_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔶","skin_tone_support":false,"name":"large orange diamond","slug":"large_orange_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔷","skin_tone_support":false,"name":"large blue diamond","slug":"large_blue_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔸","skin_tone_support":false,"name":"small orange diamond","slug":"small_orange_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔹","skin_tone_support":false,"name":"small blue diamond","slug":"small_blue_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔺","skin_tone_support":false,"name":"red triangle pointed up","slug":"red_triangle_pointed_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔻","skin_tone_support":false,"name":"red triangle pointed down","slug":"red_triangle_pointed_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"💠","skin_tone_support":false,"name":"diamond with a dot","slug":"diamond_with_a_dot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔘","skin_tone_support":false,"name":"radio button","slug":"radio_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔳","skin_tone_support":false,"name":"white square button","slug":"white_square_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🔲","skin_tone_support":false,"name":"black square button","slug":"black_square_button","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"Flags","slug":"flags","emojis":[{"emoji":"🏁","skin_tone_support":false,"name":"chequered flag","slug":"chequered_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🚩","skin_tone_support":false,"name":"triangular flag","slug":"triangular_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🎌","skin_tone_support":false,"name":"crossed flags","slug":"crossed_flags","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🏴","skin_tone_support":false,"name":"black flag","slug":"black_flag","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"🏳️","skin_tone_support":false,"name":"white flag","slug":"white_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"🏳️‍🌈","skin_tone_support":false,"name":"rainbow flag","slug":"rainbow_flag","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🏳️‍⚧️","skin_tone_support":false,"name":"transgender flag","slug":"transgender_flag","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"🏴‍☠️","skin_tone_support":false,"name":"pirate flag","slug":"pirate_flag","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"🇦🇨","skin_tone_support":false,"name":"flag Ascension Island","slug":"flag_ascension_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇩","skin_tone_support":false,"name":"flag Andorra","slug":"flag_andorra","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇪","skin_tone_support":false,"name":"flag United Arab Emirates","slug":"flag_united_arab_emirates","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇫","skin_tone_support":false,"name":"flag Afghanistan","slug":"flag_afghanistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇬","skin_tone_support":false,"name":"flag Antigua & Barbuda","slug":"flag_antigua_barbuda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇮","skin_tone_support":false,"name":"flag Anguilla","slug":"flag_anguilla","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇱","skin_tone_support":false,"name":"flag Albania","slug":"flag_albania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇲","skin_tone_support":false,"name":"flag Armenia","slug":"flag_armenia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇴","skin_tone_support":false,"name":"flag Angola","slug":"flag_angola","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇶","skin_tone_support":false,"name":"flag Antarctica","slug":"flag_antarctica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇷","skin_tone_support":false,"name":"flag Argentina","slug":"flag_argentina","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇸","skin_tone_support":false,"name":"flag American Samoa","slug":"flag_american_samoa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇹","skin_tone_support":false,"name":"flag Austria","slug":"flag_austria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇺","skin_tone_support":false,"name":"flag Australia","slug":"flag_australia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇼","skin_tone_support":false,"name":"flag Aruba","slug":"flag_aruba","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇽","skin_tone_support":false,"name":"flag Åland Islands","slug":"flag_aland_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇦🇿","skin_tone_support":false,"name":"flag Azerbaijan","slug":"flag_azerbaijan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇦","skin_tone_support":false,"name":"flag Bosnia & Herzegovina","slug":"flag_bosnia_herzegovina","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇧","skin_tone_support":false,"name":"flag Barbados","slug":"flag_barbados","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇩","skin_tone_support":false,"name":"flag Bangladesh","slug":"flag_bangladesh","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇪","skin_tone_support":false,"name":"flag Belgium","slug":"flag_belgium","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇫","skin_tone_support":false,"name":"flag Burkina Faso","slug":"flag_burkina_faso","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇬","skin_tone_support":false,"name":"flag Bulgaria","slug":"flag_bulgaria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇭","skin_tone_support":false,"name":"flag Bahrain","slug":"flag_bahrain","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇮","skin_tone_support":false,"name":"flag Burundi","slug":"flag_burundi","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇯","skin_tone_support":false,"name":"flag Benin","slug":"flag_benin","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇱","skin_tone_support":false,"name":"flag St. Barthélemy","slug":"flag_st_barthelemy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇲","skin_tone_support":false,"name":"flag Bermuda","slug":"flag_bermuda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇳","skin_tone_support":false,"name":"flag Brunei","slug":"flag_brunei","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇴","skin_tone_support":false,"name":"flag Bolivia","slug":"flag_bolivia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇶","skin_tone_support":false,"name":"flag Caribbean Netherlands","slug":"flag_caribbean_netherlands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇷","skin_tone_support":false,"name":"flag Brazil","slug":"flag_brazil","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇸","skin_tone_support":false,"name":"flag Bahamas","slug":"flag_bahamas","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇹","skin_tone_support":false,"name":"flag Bhutan","slug":"flag_bhutan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇻","skin_tone_support":false,"name":"flag Bouvet Island","slug":"flag_bouvet_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇼","skin_tone_support":false,"name":"flag Botswana","slug":"flag_botswana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇾","skin_tone_support":false,"name":"flag Belarus","slug":"flag_belarus","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇧🇿","skin_tone_support":false,"name":"flag Belize","slug":"flag_belize","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇦","skin_tone_support":false,"name":"flag Canada","slug":"flag_canada","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇨","skin_tone_support":false,"name":"flag Cocos (Keeling) Islands","slug":"flag_cocos_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇩","skin_tone_support":false,"name":"flag Congo - Kinshasa","slug":"flag_congo_kinshasa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇫","skin_tone_support":false,"name":"flag Central African Republic","slug":"flag_central_african_republic","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇬","skin_tone_support":false,"name":"flag Congo - Brazzaville","slug":"flag_congo_brazzaville","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇭","skin_tone_support":false,"name":"flag Switzerland","slug":"flag_switzerland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇮","skin_tone_support":false,"name":"flag Côte d’Ivoire","slug":"flag_cote_d_ivoire","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇰","skin_tone_support":false,"name":"flag Cook Islands","slug":"flag_cook_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇱","skin_tone_support":false,"name":"flag Chile","slug":"flag_chile","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇲","skin_tone_support":false,"name":"flag Cameroon","slug":"flag_cameroon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇳","skin_tone_support":false,"name":"flag China","slug":"flag_china","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇨🇴","skin_tone_support":false,"name":"flag Colombia","slug":"flag_colombia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇵","skin_tone_support":false,"name":"flag Clipperton Island","slug":"flag_clipperton_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇶","skin_tone_support":false,"name":"flag Sark","slug":"flag_sark","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"🇨🇷","skin_tone_support":false,"name":"flag Costa Rica","slug":"flag_costa_rica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇺","skin_tone_support":false,"name":"flag Cuba","slug":"flag_cuba","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇻","skin_tone_support":false,"name":"flag Cape Verde","slug":"flag_cape_verde","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇼","skin_tone_support":false,"name":"flag Curaçao","slug":"flag_curacao","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇽","skin_tone_support":false,"name":"flag Christmas Island","slug":"flag_christmas_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇾","skin_tone_support":false,"name":"flag Cyprus","slug":"flag_cyprus","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇨🇿","skin_tone_support":false,"name":"flag Czechia","slug":"flag_czechia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇪","skin_tone_support":false,"name":"flag Germany","slug":"flag_germany","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇩🇬","skin_tone_support":false,"name":"flag Diego Garcia","slug":"flag_diego_garcia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇯","skin_tone_support":false,"name":"flag Djibouti","slug":"flag_djibouti","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇰","skin_tone_support":false,"name":"flag Denmark","slug":"flag_denmark","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇲","skin_tone_support":false,"name":"flag Dominica","slug":"flag_dominica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇴","skin_tone_support":false,"name":"flag Dominican Republic","slug":"flag_dominican_republic","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇩🇿","skin_tone_support":false,"name":"flag Algeria","slug":"flag_algeria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇦","skin_tone_support":false,"name":"flag Ceuta & Melilla","slug":"flag_ceuta_melilla","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇨","skin_tone_support":false,"name":"flag Ecuador","slug":"flag_ecuador","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇪","skin_tone_support":false,"name":"flag Estonia","slug":"flag_estonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇬","skin_tone_support":false,"name":"flag Egypt","slug":"flag_egypt","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇭","skin_tone_support":false,"name":"flag Western Sahara","slug":"flag_western_sahara","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇷","skin_tone_support":false,"name":"flag Eritrea","slug":"flag_eritrea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇸","skin_tone_support":false,"name":"flag Spain","slug":"flag_spain","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇪🇹","skin_tone_support":false,"name":"flag Ethiopia","slug":"flag_ethiopia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇪🇺","skin_tone_support":false,"name":"flag European Union","slug":"flag_european_union","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇮","skin_tone_support":false,"name":"flag Finland","slug":"flag_finland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇯","skin_tone_support":false,"name":"flag Fiji","slug":"flag_fiji","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇰","skin_tone_support":false,"name":"flag Falkland Islands","slug":"flag_falkland_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇲","skin_tone_support":false,"name":"flag Micronesia","slug":"flag_micronesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇴","skin_tone_support":false,"name":"flag Faroe Islands","slug":"flag_faroe_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇫🇷","skin_tone_support":false,"name":"flag France","slug":"flag_france","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇬🇦","skin_tone_support":false,"name":"flag Gabon","slug":"flag_gabon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇧","skin_tone_support":false,"name":"flag United Kingdom","slug":"flag_united_kingdom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇬🇩","skin_tone_support":false,"name":"flag Grenada","slug":"flag_grenada","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇪","skin_tone_support":false,"name":"flag Georgia","slug":"flag_georgia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇫","skin_tone_support":false,"name":"flag French Guiana","slug":"flag_french_guiana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇬","skin_tone_support":false,"name":"flag Guernsey","slug":"flag_guernsey","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇭","skin_tone_support":false,"name":"flag Ghana","slug":"flag_ghana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇮","skin_tone_support":false,"name":"flag Gibraltar","slug":"flag_gibraltar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇱","skin_tone_support":false,"name":"flag Greenland","slug":"flag_greenland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇲","skin_tone_support":false,"name":"flag Gambia","slug":"flag_gambia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇳","skin_tone_support":false,"name":"flag Guinea","slug":"flag_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇵","skin_tone_support":false,"name":"flag Guadeloupe","slug":"flag_guadeloupe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇶","skin_tone_support":false,"name":"flag Equatorial Guinea","slug":"flag_equatorial_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇷","skin_tone_support":false,"name":"flag Greece","slug":"flag_greece","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇸","skin_tone_support":false,"name":"flag South Georgia & South Sandwich Islands","slug":"flag_south_georgia_south_sandwich_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇹","skin_tone_support":false,"name":"flag Guatemala","slug":"flag_guatemala","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇺","skin_tone_support":false,"name":"flag Guam","slug":"flag_guam","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇼","skin_tone_support":false,"name":"flag Guinea-Bissau","slug":"flag_guinea_bissau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇬🇾","skin_tone_support":false,"name":"flag Guyana","slug":"flag_guyana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇰","skin_tone_support":false,"name":"flag Hong Kong SAR China","slug":"flag_hong_kong_sar_china","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇲","skin_tone_support":false,"name":"flag Heard & McDonald Islands","slug":"flag_heard_mcdonald_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇳","skin_tone_support":false,"name":"flag Honduras","slug":"flag_honduras","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇷","skin_tone_support":false,"name":"flag Croatia","slug":"flag_croatia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇹","skin_tone_support":false,"name":"flag Haiti","slug":"flag_haiti","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇭🇺","skin_tone_support":false,"name":"flag Hungary","slug":"flag_hungary","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇨","skin_tone_support":false,"name":"flag Canary Islands","slug":"flag_canary_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇩","skin_tone_support":false,"name":"flag Indonesia","slug":"flag_indonesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇪","skin_tone_support":false,"name":"flag Ireland","slug":"flag_ireland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇱","skin_tone_support":false,"name":"flag Israel","slug":"flag_israel","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇲","skin_tone_support":false,"name":"flag Isle of Man","slug":"flag_isle_of_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇳","skin_tone_support":false,"name":"flag India","slug":"flag_india","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇴","skin_tone_support":false,"name":"flag British Indian Ocean Territory","slug":"flag_british_indian_ocean_territory","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇶","skin_tone_support":false,"name":"flag Iraq","slug":"flag_iraq","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇷","skin_tone_support":false,"name":"flag Iran","slug":"flag_iran","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇸","skin_tone_support":false,"name":"flag Iceland","slug":"flag_iceland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇮🇹","skin_tone_support":false,"name":"flag Italy","slug":"flag_italy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇯🇪","skin_tone_support":false,"name":"flag Jersey","slug":"flag_jersey","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇯🇲","skin_tone_support":false,"name":"flag Jamaica","slug":"flag_jamaica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇯🇴","skin_tone_support":false,"name":"flag Jordan","slug":"flag_jordan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇯🇵","skin_tone_support":false,"name":"flag Japan","slug":"flag_japan","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇰🇪","skin_tone_support":false,"name":"flag Kenya","slug":"flag_kenya","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇬","skin_tone_support":false,"name":"flag Kyrgyzstan","slug":"flag_kyrgyzstan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇭","skin_tone_support":false,"name":"flag Cambodia","slug":"flag_cambodia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇮","skin_tone_support":false,"name":"flag Kiribati","slug":"flag_kiribati","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇲","skin_tone_support":false,"name":"flag Comoros","slug":"flag_comoros","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇳","skin_tone_support":false,"name":"flag St. Kitts & Nevis","slug":"flag_st_kitts_nevis","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇵","skin_tone_support":false,"name":"flag North Korea","slug":"flag_north_korea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇷","skin_tone_support":false,"name":"flag South Korea","slug":"flag_south_korea","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇰🇼","skin_tone_support":false,"name":"flag Kuwait","slug":"flag_kuwait","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇾","skin_tone_support":false,"name":"flag Cayman Islands","slug":"flag_cayman_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇰🇿","skin_tone_support":false,"name":"flag Kazakhstan","slug":"flag_kazakhstan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇦","skin_tone_support":false,"name":"flag Laos","slug":"flag_laos","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇧","skin_tone_support":false,"name":"flag Lebanon","slug":"flag_lebanon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇨","skin_tone_support":false,"name":"flag St. Lucia","slug":"flag_st_lucia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇮","skin_tone_support":false,"name":"flag Liechtenstein","slug":"flag_liechtenstein","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇰","skin_tone_support":false,"name":"flag Sri Lanka","slug":"flag_sri_lanka","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇷","skin_tone_support":false,"name":"flag Liberia","slug":"flag_liberia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇸","skin_tone_support":false,"name":"flag Lesotho","slug":"flag_lesotho","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇹","skin_tone_support":false,"name":"flag Lithuania","slug":"flag_lithuania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇺","skin_tone_support":false,"name":"flag Luxembourg","slug":"flag_luxembourg","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇻","skin_tone_support":false,"name":"flag Latvia","slug":"flag_latvia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇱🇾","skin_tone_support":false,"name":"flag Libya","slug":"flag_libya","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇦","skin_tone_support":false,"name":"flag Morocco","slug":"flag_morocco","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇨","skin_tone_support":false,"name":"flag Monaco","slug":"flag_monaco","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇩","skin_tone_support":false,"name":"flag Moldova","slug":"flag_moldova","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇪","skin_tone_support":false,"name":"flag Montenegro","slug":"flag_montenegro","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇫","skin_tone_support":false,"name":"flag St. Martin","slug":"flag_st_martin","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇬","skin_tone_support":false,"name":"flag Madagascar","slug":"flag_madagascar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇭","skin_tone_support":false,"name":"flag Marshall Islands","slug":"flag_marshall_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇰","skin_tone_support":false,"name":"flag North Macedonia","slug":"flag_north_macedonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇱","skin_tone_support":false,"name":"flag Mali","slug":"flag_mali","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇲","skin_tone_support":false,"name":"flag Myanmar (Burma)","slug":"flag_myanmar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇳","skin_tone_support":false,"name":"flag Mongolia","slug":"flag_mongolia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇴","skin_tone_support":false,"name":"flag Macao SAR China","slug":"flag_macao_sar_china","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇵","skin_tone_support":false,"name":"flag Northern Mariana Islands","slug":"flag_northern_mariana_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇶","skin_tone_support":false,"name":"flag Martinique","slug":"flag_martinique","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇷","skin_tone_support":false,"name":"flag Mauritania","slug":"flag_mauritania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇸","skin_tone_support":false,"name":"flag Montserrat","slug":"flag_montserrat","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇹","skin_tone_support":false,"name":"flag Malta","slug":"flag_malta","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇺","skin_tone_support":false,"name":"flag Mauritius","slug":"flag_mauritius","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇻","skin_tone_support":false,"name":"flag Maldives","slug":"flag_maldives","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇼","skin_tone_support":false,"name":"flag Malawi","slug":"flag_malawi","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇽","skin_tone_support":false,"name":"flag Mexico","slug":"flag_mexico","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇾","skin_tone_support":false,"name":"flag Malaysia","slug":"flag_malaysia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇲🇿","skin_tone_support":false,"name":"flag Mozambique","slug":"flag_mozambique","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇦","skin_tone_support":false,"name":"flag Namibia","slug":"flag_namibia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇨","skin_tone_support":false,"name":"flag New Caledonia","slug":"flag_new_caledonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇪","skin_tone_support":false,"name":"flag Niger","slug":"flag_niger","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇫","skin_tone_support":false,"name":"flag Norfolk Island","slug":"flag_norfolk_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇬","skin_tone_support":false,"name":"flag Nigeria","slug":"flag_nigeria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇮","skin_tone_support":false,"name":"flag Nicaragua","slug":"flag_nicaragua","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇱","skin_tone_support":false,"name":"flag Netherlands","slug":"flag_netherlands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇴","skin_tone_support":false,"name":"flag Norway","slug":"flag_norway","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇵","skin_tone_support":false,"name":"flag Nepal","slug":"flag_nepal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇷","skin_tone_support":false,"name":"flag Nauru","slug":"flag_nauru","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇺","skin_tone_support":false,"name":"flag Niue","slug":"flag_niue","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇳🇿","skin_tone_support":false,"name":"flag New Zealand","slug":"flag_new_zealand","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇴🇲","skin_tone_support":false,"name":"flag Oman","slug":"flag_oman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇦","skin_tone_support":false,"name":"flag Panama","slug":"flag_panama","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇪","skin_tone_support":false,"name":"flag Peru","slug":"flag_peru","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇫","skin_tone_support":false,"name":"flag French Polynesia","slug":"flag_french_polynesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇬","skin_tone_support":false,"name":"flag Papua New Guinea","slug":"flag_papua_new_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇭","skin_tone_support":false,"name":"flag Philippines","slug":"flag_philippines","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇰","skin_tone_support":false,"name":"flag Pakistan","slug":"flag_pakistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇱","skin_tone_support":false,"name":"flag Poland","slug":"flag_poland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇲","skin_tone_support":false,"name":"flag St. Pierre & Miquelon","slug":"flag_st_pierre_miquelon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇳","skin_tone_support":false,"name":"flag Pitcairn Islands","slug":"flag_pitcairn_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇷","skin_tone_support":false,"name":"flag Puerto Rico","slug":"flag_puerto_rico","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇸","skin_tone_support":false,"name":"flag Palestinian Territories","slug":"flag_palestinian_territories","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇹","skin_tone_support":false,"name":"flag Portugal","slug":"flag_portugal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇼","skin_tone_support":false,"name":"flag Palau","slug":"flag_palau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇵🇾","skin_tone_support":false,"name":"flag Paraguay","slug":"flag_paraguay","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇶🇦","skin_tone_support":false,"name":"flag Qatar","slug":"flag_qatar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇷🇪","skin_tone_support":false,"name":"flag Réunion","slug":"flag_reunion","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇷🇴","skin_tone_support":false,"name":"flag Romania","slug":"flag_romania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇷🇸","skin_tone_support":false,"name":"flag Serbia","slug":"flag_serbia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇷🇺","skin_tone_support":false,"name":"flag Russia","slug":"flag_russia","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇷🇼","skin_tone_support":false,"name":"flag Rwanda","slug":"flag_rwanda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇦","skin_tone_support":false,"name":"flag Saudi Arabia","slug":"flag_saudi_arabia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇧","skin_tone_support":false,"name":"flag Solomon Islands","slug":"flag_solomon_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇨","skin_tone_support":false,"name":"flag Seychelles","slug":"flag_seychelles","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇩","skin_tone_support":false,"name":"flag Sudan","slug":"flag_sudan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇪","skin_tone_support":false,"name":"flag Sweden","slug":"flag_sweden","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇬","skin_tone_support":false,"name":"flag Singapore","slug":"flag_singapore","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇭","skin_tone_support":false,"name":"flag St. Helena","slug":"flag_st_helena","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇮","skin_tone_support":false,"name":"flag Slovenia","slug":"flag_slovenia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇯","skin_tone_support":false,"name":"flag Svalbard & Jan Mayen","slug":"flag_svalbard_jan_mayen","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇰","skin_tone_support":false,"name":"flag Slovakia","slug":"flag_slovakia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇱","skin_tone_support":false,"name":"flag Sierra Leone","slug":"flag_sierra_leone","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇲","skin_tone_support":false,"name":"flag San Marino","slug":"flag_san_marino","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇳","skin_tone_support":false,"name":"flag Senegal","slug":"flag_senegal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇴","skin_tone_support":false,"name":"flag Somalia","slug":"flag_somalia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇷","skin_tone_support":false,"name":"flag Suriname","slug":"flag_suriname","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇸","skin_tone_support":false,"name":"flag South Sudan","slug":"flag_south_sudan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇹","skin_tone_support":false,"name":"flag São Tomé & Príncipe","slug":"flag_sao_tome_principe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇻","skin_tone_support":false,"name":"flag El Salvador","slug":"flag_el_salvador","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇽","skin_tone_support":false,"name":"flag Sint Maarten","slug":"flag_sint_maarten","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇾","skin_tone_support":false,"name":"flag Syria","slug":"flag_syria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇸🇿","skin_tone_support":false,"name":"flag Eswatini","slug":"flag_eswatini","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇦","skin_tone_support":false,"name":"flag Tristan da Cunha","slug":"flag_tristan_da_cunha","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇨","skin_tone_support":false,"name":"flag Turks & Caicos Islands","slug":"flag_turks_caicos_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇩","skin_tone_support":false,"name":"flag Chad","slug":"flag_chad","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇫","skin_tone_support":false,"name":"flag French Southern Territories","slug":"flag_french_southern_territories","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇬","skin_tone_support":false,"name":"flag Togo","slug":"flag_togo","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇭","skin_tone_support":false,"name":"flag Thailand","slug":"flag_thailand","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇯","skin_tone_support":false,"name":"flag Tajikistan","slug":"flag_tajikistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇰","skin_tone_support":false,"name":"flag Tokelau","slug":"flag_tokelau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇱","skin_tone_support":false,"name":"flag Timor-Leste","slug":"flag_timor_leste","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇲","skin_tone_support":false,"name":"flag Turkmenistan","slug":"flag_turkmenistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇳","skin_tone_support":false,"name":"flag Tunisia","slug":"flag_tunisia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇴","skin_tone_support":false,"name":"flag Tonga","slug":"flag_tonga","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇷","skin_tone_support":false,"name":"flag Türkiye","slug":"flag_turkiye","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇹","skin_tone_support":false,"name":"flag Trinidad & Tobago","slug":"flag_trinidad_tobago","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇻","skin_tone_support":false,"name":"flag Tuvalu","slug":"flag_tuvalu","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇼","skin_tone_support":false,"name":"flag Taiwan","slug":"flag_taiwan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇹🇿","skin_tone_support":false,"name":"flag Tanzania","slug":"flag_tanzania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇺🇦","skin_tone_support":false,"name":"flag Ukraine","slug":"flag_ukraine","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇺🇬","skin_tone_support":false,"name":"flag Uganda","slug":"flag_uganda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇺🇲","skin_tone_support":false,"name":"flag U.S. Outlying Islands","slug":"flag_u_s_outlying_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇺🇳","skin_tone_support":false,"name":"flag United Nations","slug":"flag_united_nations","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"🇺🇸","skin_tone_support":false,"name":"flag United States","slug":"flag_united_states","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"🇺🇾","skin_tone_support":false,"name":"flag Uruguay","slug":"flag_uruguay","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇺🇿","skin_tone_support":false,"name":"flag Uzbekistan","slug":"flag_uzbekistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇦","skin_tone_support":false,"name":"flag Vatican City","slug":"flag_vatican_city","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇨","skin_tone_support":false,"name":"flag St. Vincent & Grenadines","slug":"flag_st_vincent_grenadines","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇪","skin_tone_support":false,"name":"flag Venezuela","slug":"flag_venezuela","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇬","skin_tone_support":false,"name":"flag British Virgin Islands","slug":"flag_british_virgin_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇮","skin_tone_support":false,"name":"flag U.S. Virgin Islands","slug":"flag_u_s_virgin_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇳","skin_tone_support":false,"name":"flag Vietnam","slug":"flag_vietnam","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇻🇺","skin_tone_support":false,"name":"flag Vanuatu","slug":"flag_vanuatu","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇼🇫","skin_tone_support":false,"name":"flag Wallis & Futuna","slug":"flag_wallis_futuna","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇼🇸","skin_tone_support":false,"name":"flag Samoa","slug":"flag_samoa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇽🇰","skin_tone_support":false,"name":"flag Kosovo","slug":"flag_kosovo","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇾🇪","skin_tone_support":false,"name":"flag Yemen","slug":"flag_yemen","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇾🇹","skin_tone_support":false,"name":"flag Mayotte","slug":"flag_mayotte","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇿🇦","skin_tone_support":false,"name":"flag South Africa","slug":"flag_south_africa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇿🇲","skin_tone_support":false,"name":"flag Zambia","slug":"flag_zambia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🇿🇼","skin_tone_support":false,"name":"flag Zimbabwe","slug":"flag_zimbabwe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"🏴󠁧󠁢󠁥󠁮󠁧󠁿","skin_tone_support":false,"name":"flag England","slug":"flag_england","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🏴󠁧󠁢󠁳󠁣󠁴󠁿","skin_tone_support":false,"name":"flag Scotland","slug":"flag_scotland","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"🏴󠁧󠁢󠁷󠁬󠁳󠁿","skin_tone_support":false,"name":"flag Wales","slug":"flag_wales","unicode_version":"5.0","emoji_version":"5.0"}]}]'), B_ = (t2) => {
      const e = [];
      return mu.map((n) => {
        const o = n.emojis.filter(
          (i) => i.name.indexOf(t2.toLowerCase()) >= 0
        );
        e.push({
          name: n.name,
          slug: n.slug,
          emojis: o
        });
      }), e;
    }, x1 = {
      smileys_emotion: "emotion",
      people_body: "face",
      animals_nature: "psychiatry",
      food_drink: "carrot",
      travel_places: "airplane",
      activities: "sports_soccer",
      objects: "objects",
      symbols: "yin_yang",
      flags: "flag"
    }, T1 = { class: "o-emoji-select" }, O1 = { key: 0 }, N1 = { class: "groups o-scroll" }, A1 = { class: "items" }, M1 = ["onClick"], R1 = {
      key: 0,
      class: "groups-empty"
    }, I1 = { class: "group-icons" }, D1 = ["onClick"], fu = /* @__PURE__ */ defineComponent({
      __name: "OEmojiSelect",
      props: {
        items: {
          type: Array,
          required: true
        },
        enableSearch: {
          type: Boolean,
          default: false
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = ref(null), s = ref(""), r = ref([]), a = ref([]), l = ref(0), c2 = computed(() => s.value ? r.value : n.items), u = computed(() => {
          let f = false;
          return c2.value.map((_) => {
            f = f || _.emojis.length;
          }), f;
        });
        function d() {
          l.value = 0, r.value = s.value ? B_(s.value) : [];
        }
        function p2(f) {
          o("select", f);
        }
        function m(f, _) {
          l.value = _, a.value[_].scrollIntoView({ behavior: "instant", block: "start" });
        }
        return onMounted(() => {
        }), (f, _) => (openBlock(), createElementBlock("section", T1, [
          t2.enableSearch ? (openBlock(), createElementBlock("div", O1, [
            createVNode(unref(qi), {
              ref_key: "input",
              ref: i,
              modelValue: s.value,
              "onUpdate:modelValue": [
                _[0] || (_[0] = (h2) => s.value = h2),
                d
              ],
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(fe), {
                  name: "search",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])) : createCommentVNode("", true),
          createBaseVNode("section", N1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(c2.value, (h2, g) => {
              var k;
              return withDirectives((openBlock(), createElementBlock("div", {
                key: `group-${g}`,
                class: "group"
              }, [
                createBaseVNode("header", {
                  ref_for: true,
                  ref_key: "groupRefs",
                  ref: a
                }, toDisplayString(h2.name), 513),
                createBaseVNode("section", A1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(h2.emojis, (j, v) => (openBlock(), createElementBlock("div", {
                    key: `item-${v}`
                  }, [
                    createBaseVNode("div", {
                      class: "item",
                      onClick: (C) => p2(j)
                    }, toDisplayString(j.emoji), 9, M1)
                  ]))), 128))
                ])
              ], 512)), [
                [vShow, (k = h2.emojis) == null ? void 0 : k.length]
              ]);
            }), 128)),
            u.value ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", R1, "没有记录"))
          ]),
          createBaseVNode("section", I1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(c2.value, (h2, g) => (openBlock(), createBlock(unref(Uo), {
              key: `target-${g}`,
              delay: 300
            }, {
              trigger: withCtx(() => {
                var k;
                return [
                  withDirectives(createBaseVNode("div", {
                    class: normalizeClass(["item", { active: l.value === g }]),
                    onClick: (j) => m(h2, g)
                  }, [
                    createVNode(unref(fe), {
                      name: unref(x1)[h2.slug]
                    }, null, 8, ["name"])
                  ], 10, D1), [
                    [vShow, (k = h2.emojis) == null ? void 0 : k.length]
                  ])
                ];
              }),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(h2.name), 1)
              ]),
              _: 2
            }, 1024))), 128))
          ])
        ]));
      }
    }), Sl = [
      {
        label: "Arduino",
        value: "arduino",
        icon: "code_blocks"
      },
      {
        label: "Bash",
        value: "bash",
        icon: "code_blocks"
      },
      {
        label: "C",
        value: "c",
        icon: "code_blocks"
      },
      {
        label: "C++",
        value: "cpp",
        icon: "code_blocks"
      },
      {
        label: "C#",
        value: "csharp",
        icon: "code_blocks"
      },
      {
        label: "CSS",
        value: "css",
        icon: "code_blocks"
      },
      {
        label: "Diff",
        value: "diff",
        icon: "code_blocks"
      },
      {
        label: "Go",
        value: "go",
        icon: "code_blocks"
      },
      {
        label: "GraphQL",
        value: "graphql",
        icon: "code_blocks"
      },
      {
        label: "Ini",
        value: "ini",
        icon: "code_blocks"
      },
      {
        label: "Java",
        value: "java",
        icon: "code_blocks"
      },
      {
        label: "JavaScript",
        value: "javascript",
        icon: "code_blocks"
      },
      {
        label: "JSON",
        value: "json",
        icon: "code_blocks"
      },
      {
        label: "Kotlin",
        value: "kotlin",
        icon: "code_blocks"
      },
      {
        label: "Less",
        value: "less",
        icon: "code_blocks"
      },
      {
        label: "Lua",
        value: "lua",
        icon: "code_blocks"
      },
      {
        label: "Makefile",
        value: "makefile",
        icon: "code_blocks"
      },
      {
        label: "Markdown",
        value: "markdown",
        icon: "code_blocks"
      },
      {
        label: "Objective-C",
        value: "objectivec",
        icon: "code_blocks"
      },
      {
        label: "Perl",
        value: "perl",
        icon: "code_blocks"
      },
      {
        label: "PHP",
        value: "php",
        icon: "code_blocks"
      },
      {
        label: "PHP-Template",
        value: "php-template",
        icon: "code_blocks"
      },
      {
        label: "Plain Text",
        value: "plaintext",
        icon: "code_blocks"
      },
      {
        label: "Python",
        value: "python",
        icon: "code_blocks"
      },
      {
        label: "Python-Repl",
        value: "python-repl",
        icon: "code_blocks"
      },
      {
        label: "R",
        value: "r",
        icon: "code_blocks"
      },
      {
        label: "Ruby",
        value: "ruby",
        icon: "code_blocks"
      },
      {
        label: "Rust",
        value: "rust",
        icon: "code_blocks"
      },
      {
        label: "Scss",
        value: "scss",
        icon: "code_blocks"
      },
      {
        label: "Shell",
        value: "shell",
        icon: "code_blocks"
      },
      {
        label: "SQL",
        value: "sql",
        icon: "code_blocks"
      },
      {
        label: "Swift",
        value: "swift",
        icon: "code_blocks"
      },
      {
        label: "TypeScript",
        value: "typescript",
        icon: "code_blocks"
      },
      {
        label: "VB.Net",
        value: "vbnet",
        icon: "code_blocks"
      },
      {
        label: "WebAssembly",
        value: "wasm",
        icon: "code_blocks"
      },
      {
        label: "XML",
        value: "xml",
        icon: "code_blocks"
      },
      {
        label: "YAML",
        value: "yaml",
        icon: "code_blocks"
      }
    ], L1 = { class: "selected-language" }, P1 = { class: "header" }, B1 = { class: "o-scroll" }, $1 = /* @__PURE__ */ defineComponent({
      __name: "OLanguageDropdown",
      props: {
        language: {
          type: String,
          default: "shell"
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = t2, o = e;
        Ae();
        const s = ref(), r = ref(), a = ref(""), l = ref(0), c2 = ref(""), u = computed(() => a.value ? Sl.filter(
          (g) => g.value.toLowerCase().indexOf(a.value.toLowerCase()) >= 0
        ) : Sl), d = computed(() => Sl.find((g) => g.value === c2.value));
        function p2(g) {
          g && setTimeout(() => {
            var k;
            (k = r.value) == null || k.focus(), l.value = 0, window.addEventListener("keyup", h2);
          }, 0);
        }
        function m() {
          window.removeEventListener("keyup", h2);
        }
        function f(g) {
          m(), c2.value = g.value, o("select", g.value);
        }
        function _() {
          f(u.value[l.value]);
        }
        function h2(g) {
          if (u.value.length > 0) {
            switch (g.code) {
              case "ArrowDown":
                l.value = l.value + 1;
                break;
              case "ArrowUp":
                l.value = l.value - 1;
                break;
              case "Enter":
                _();
                break;
            }
            l.value >= u.value.length && (l.value = 0), l.value < 0 && (l.value = u.value.length - 1);
          } else
            l.value = 0;
        }
        return onMounted(() => {
          c2.value = n.language;
        }), (g, k) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: s,
          placement: "bottom-start",
          trigger: "click",
          "tippy-class": "o-language-popover dropdown",
          "onUpdate:show": p2
        }, {
          trigger: withCtx(() => [
            createVNode(unref(on), { class: "o-dropdown-btn" }, {
              default: withCtx(() => {
                var j;
                return [
                  createBaseVNode("span", L1, toDisplayString((j = d.value) == null ? void 0 : j.label), 1),
                  createVNode(unref(fe), {
                    name: "arrow_drop_down",
                    class: "arrow"
                  })
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("header", P1, [
              createVNode(unref(qi), {
                ref_key: "input",
                ref: r,
                modelValue: a.value,
                "onUpdate:modelValue": k[0] || (k[0] = (j) => a.value = j),
                type: "text",
                placeholder: "Search",
                autofocus: "",
                clearable: ""
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(fe), {
                    name: "search",
                    class: "o-tips"
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createBaseVNode("section", B1, [
              createVNode(unref(Bn), {
                hoverable: "",
                clickable: ""
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(u.value, (j, v) => (openBlock(), createBlock(unref(xn), {
                    key: v,
                    onClick: (C) => f(j),
                    class: normalizeClass({
                      "is-active": j.value === c2.value,
                      "is-select": v === l.value
                    })
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: j.icon
                      }, null, 8, ["name"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(j.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "class"]))), 128))
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 512));
      }
    }), z1 = { class: "o-media-input" }, F1 = { class: "fields" }, H1 = { class: "actions" }, $_ = /* @__PURE__ */ defineComponent({
      __name: "OMediaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["input"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: i } = Ae(), s = ref(), r = ref(""), a = ref("");
        function l() {
          return a.value ? (r.value = "null", true) : (r.value = "error", false);
        }
        function c2() {
          l() && o("input", a.value);
        }
        return onMounted(() => {
          a.value = n.val, setTimeout(() => {
            var u;
            (u = s.value) == null || u.focus();
          }, 0);
        }), (u, d) => (openBlock(), createElementBlock("section", z1, [
          createBaseVNode("section", F1, [
            d[1] || (d[1] = createBaseVNode("div", { class: "o-media-title" }, "Link", -1)),
            createVNode(unref(qi), {
              ref_key: "input",
              ref: s,
              modelValue: a.value,
              "onUpdate:modelValue": d[0] || (d[0] = (p2) => a.value = p2),
              status: r.value,
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(fe), {
                  name: "link",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue", "status"])
          ]),
          createBaseVNode("footer", H1, [
            createVNode(unref(on), {
              type: "info",
              onClick: c2
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), U1 = { class: "o-meta-input" }, V1 = { class: "header" }, q1 = { class: "title" }, K1 = { class: "fields" }, W1 = { class: "actions" }, z_ = /* @__PURE__ */ defineComponent({
      __name: "OMetaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: "Link"
        },
        type: {
          type: String,
          default: "link"
        },
        icon: {
          type: String,
          default: "link"
        },
        secondIcon: {
          type: String,
          default: ""
        },
        secondLabel: {
          type: String,
          default: ""
        }
      },
      emits: ["cancel", "confirm"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: i } = Ae(), s = ref(null), r = ref("");
        function a() {
          console.log("confirm", r.value), o("confirm", r.value);
        }
        return onMounted(() => {
          r.value = n.val, setTimeout(() => {
            var l;
            (l = s.value) == null || l.focus();
          }, 0);
        }), (l, c2) => (openBlock(), createElementBlock("section", U1, [
          createBaseVNode("section", V1, [
            createBaseVNode("div", q1, toDisplayString(t2.title), 1),
            createBaseVNode("div", null, [
              renderSlot(l.$slots, "header-right")
            ])
          ]),
          createBaseVNode("section", K1, [
            createVNode(unref(qi), {
              ref_key: "input",
              ref: s,
              modelValue: r.value,
              "onUpdate:modelValue": c2[0] || (c2[0] = (u) => r.value = u),
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(fe), {
                  name: t2.icon,
                  class: "o-tips"
                }, null, 8, ["name"])
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          createBaseVNode("footer", W1, [
            createVNode(unref(on), {
              type: "tertiary",
              onClick: c2[1] || (c2[1] = (u) => o("cancel"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i)("label.cancel")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(on), {
              type: "info",
              onClick: a
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), G1 = { class: "o-table-grid" }, J1 = ["onMouseover"], Y1 = /* @__PURE__ */ defineComponent({
      __name: "OTableGrid",
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e, o = ref(6), i = ref(6), s = ref(2), r = ref(2);
        function a(c2, u) {
          s.value = c2, r.value = u, o.value === c2 && o.value < 10 && (o.value += 1), i.value === u && i.value < 10 && (i.value += 1);
        }
        function l() {
          n("select", {
            rows: s.value,
            cols: r.value,
            withHeaderRow: true
          });
        }
        return (c2, u) => (openBlock(), createElementBlock("section", G1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (d, p2) => (openBlock(), createElementBlock("div", {
            class: "rows",
            key: `row-${p2}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (m, f) => (openBlock(), createElementBlock("div", {
              key: `col-${f}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["cell", { selected: d <= s.value && m <= r.value }]),
                onMouseover: (_) => a(d, m),
                onClick: l
              }, null, 42, J1)
            ]))), 128))
          ]))), 128)),
          createBaseVNode("footer", null, toDisplayString(s.value) + " x " + toDisplayString(r.value), 1)
        ]));
      }
    }), X1 = { class: "o-table-cell-background o-button-group" }, Z1 = { class: "o-command-btn" }, Q1 = /* @__PURE__ */ defineComponent({
      __name: "OTableCellBackground",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(), s = ref("#ffec3d");
        function r() {
          a(s.value);
        }
        function a(l) {
          i.value.setShow(false), s.value = l, o(e.editor, "tableCellAttribute", {
            name: "background",
            value: s.value
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          placement: "bottom-start",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Uo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", X1, [
                  createBaseVNode("div", {
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, [
                    createVNode(unref(fe), {
                      name: "crop_16_9",
                      class: "arrow"
                    }),
                    createBaseVNode("div", {
                      class: "indicator",
                      style: normalizeStyle(`background: ${s.value}`)
                    }, null, 4)
                  ]),
                  createBaseVNode("div", Z1, [
                    createVNode(unref(fe), { name: "arrow_drop_down" })
                  ])
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(du), {
              "default-color": "",
              "default-label": unref(n)("editor.noColor"),
              onSelect: a
            }, null, 8, ["default-label"])
          ]),
          _: 1
        }, 512));
      }
    }), eE = { class: "o-simple-color-board" }, tE = { class: "fore-colors" }, nE = { class: "color-row" }, oE = { class: "color-row" }, iE = { class: "back-colors" }, sE = { class: "color-row" }, rE = { class: "color-row" }, aE = /* @__PURE__ */ defineComponent({
      __name: "OTextColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(t2, { emit: e }) {
        const n = e;
        function o(r, a) {
          n("select", r, a.value);
        }
        const i = computed(() => [
          { label: "Grey", value: "#787774" },
          { label: "Brown", value: "#9F6B53" },
          { label: "Orange", value: "#D9730D" },
          { label: "Yellow", value: "#CB912F" },
          { label: "Green", value: "#448361" },
          { label: "Blue", value: "#337EA9" },
          { label: "Purple", value: "#9065B0" },
          { label: "Pink", value: "#C14C8A" },
          { label: "Red", value: "#D44C47" }
        ]), s = computed(() => [
          { label: "Grey", value: "#F1F1EF" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (r, a) => (openBlock(), createElementBlock("section", eE, [
          createBaseVNode("section", tE, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Color", -1)),
            createBaseVNode("div", nE, [
              createVNode(unref(Ye), {
                icon: "format_text",
                tooltip: "Default color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => o("foreColor", { value: "" }))
              }),
              t2.foreColor ? (openBlock(), createBlock(unref(Ye), {
                key: 0,
                icon: "format_text",
                color: t2.foreColor,
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[1] || (a[1] = (l) => o("foreColor", { value: t2.foreColor }))
              }, null, 8, ["color"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", oE, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(Ye), {
                key: `col-${c2}`,
                icon: "format_text",
                color: l.value,
                tooltip: l.label,
                onClick: (u) => o("foreColor", l)
              }, null, 8, ["color", "tooltip", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", iE, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", sE, [
              createVNode(unref(Ye), {
                icon: "slash_forward",
                tooltip: "No Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => o("backColor", { value: "" }))
              }),
              t2.backColor ? (openBlock(), createBlock(unref(Ye), {
                key: 0,
                icon: "format_text",
                tooltip: "Last used",
                "content-class": "border",
                "content-style": { backgroundColor: t2.backColor },
                onClick: a[3] || (a[3] = (l) => o("backColor", { value: t2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", rE, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (l, c2) => (openBlock(), createBlock(unref(Ye), {
                key: `col-${c2}`,
                icon: "format_text",
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => o("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), Xr = [
      {
        type: "paragraph",
        content: []
      }
    ], F_ = [
      {
        type: "listItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], H_ = [
      {
        type: "taskItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], lE = { class: "o-add-node-view" }, cE = {
      key: 0,
      class: "view-main"
    }, uE = { class: "group o-tips" }, dE = { class: "panel" }, pE = { class: "group o-tips" }, mE = {
      key: 1,
      class: "item"
    }, fE = {
      key: 1,
      class: "view-emoji"
    }, _E = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: s } = Ae();
        Be();
        const a = ref("main"), l = ref(0);
        function c2(p2) {
          const m = n.editor.chain();
          let f = null;
          switch (p2.value) {
            case "blockquote":
              f = {
                content: Xr
              };
              break;
            case "callout":
              f = {
                content: Xr,
                attrs: { icon: "💡" }
              };
              break;
            case "codeBlock":
              f = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              f = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              f = {
                attrs: p2.options
              };
              break;
            case "horizontalRule":
              f = {};
              break;
            case "paragraph":
              f = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              f = {
                content: F_
              };
              break;
            case "taskList":
              f = {
                content: H_
              };
              break;
            case "table":
              setTimeout(() => {
                m.insertContentAt(d.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              f = {
                type: "paragraph",
                content: [{ type: p2.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              f = { attrs: { src: "init" } };
              break;
          }
          f && (f.type = f.type || p2.value, setTimeout(() => {
            u.value ? m.insertContent(f).focus().run() : m.insertContentAt(d.value, f).focus().run();
          }, 1)), o("action", p2);
        }
        const u = computed(() => n.node.content.size === 0), d = computed(() => u.value ? l.value : l.value + n.node.nodeSize);
        return onMounted(() => {
          l.value = n.getPos();
        }), (p2, m) => (openBlock(), createElementBlock("section", lE, [
          a.value === "main" ? (openBlock(), createElementBlock("section", cE, [
            createBaseVNode("section", null, [
              createBaseVNode("div", uE, toDisplayString(unref(s)("label.basic")), 1),
              createBaseVNode("section", dE, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Ws), (f, _) => (openBlock(), createBlock(unref(Ye), {
                  key: _,
                  icon: f.icon,
                  tooltip: unref(s)(f.label),
                  quaternary: "",
                  onClick: (h2) => c2(f)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Ms).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Ms), (f, _) => (openBlock(), createElementBlock(Fragment, { key: _ }, [
                  f.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ > 0 ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", pE, toDisplayString(unref(s)(f.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(xn), {
                    class: "item",
                    clickable: "",
                    onClick: (h2) => c2(f)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: f.icon,
                        color: f.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(s)(f.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", mE, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", fE)) : createCommentVNode("", true)
        ]));
      }
    }), hE = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref(null), o = ref(false);
        function i(r) {
          o.value = r;
        }
        function s() {
          var r;
          (r = n.value) == null || r.setShow(false), o.value = false;
        }
        return (r, a) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: n,
          placement: "left",
          trigger: "mouseenter",
          arrow: "",
          "onUpdate:show": i
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-node", { "is-selected": o.value }])
            }, [
              createVNode(unref(on), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(fe), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(_E, mergeProps(e, { onAction: s }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), gE = { class: "o-drag-node-view" }, vE = {
      key: 0,
      class: "view-main"
    }, bE = { key: 0 }, kE = { class: "panel" }, yE = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: s } = Ae(), { onCommand: a } = Be(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var h2, g;
          const _ = (h2 = n.node) == null ? void 0 : h2.content.content;
          if (_.length > 0) {
            const k = _[0];
            if (k.type.name === "image")
              return k.type.name;
          }
          return (g = n.node) == null ? void 0 : g.type.name;
        }), d = computed(() => Yr.find((_) => _.value === u.value));
        function p2(_) {
          var h2;
          return _.value === u.value && ((h2 = n.editor) == null ? void 0 : h2.isActive(u.value, _.options));
        }
        function m(_) {
          switch (_.value) {
            default:
              f(_);
              break;
          }
          o("action", _);
        }
        function f(_) {
          var j, v, C, E, B;
          const h2 = n.getPos();
          if (_.value === u.value && c2.value.indexOf(u.value) < 0) {
            const U = (j = n.editor) == null ? void 0 : j.isActive(u.value), P = (v = n.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, U, P);
            return;
          }
          const g = (C = n.editor) == null ? void 0 : C.commands, k = (E = n.editor) == null ? void 0 : E.chain().focus(h2 + 1);
          console.log("runCommand", _), a(g, k, _.value, _.options), (B = n.editor) == null || B.commands.setNodeSelection(h2);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: Ve.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: Ve.deepOrange
          }
        ]), (_, h2) => (openBlock(), createElementBlock("section", gE, [
          l.value === "main" ? (openBlock(), createElementBlock("section", vE, [
            d.value ? (openBlock(), createElementBlock("section", bE, [
              h2[0] || (h2[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", kE, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Yr), (g, k) => (openBlock(), createBlock(unref(Ye), {
                  key: k,
                  icon: g.icon,
                  tooltip: unref(s)(g.label),
                  "content-class": { "is-active": p2(g) },
                  quaternary: "",
                  onClick: (j) => m(g)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Vi), mergeProps(n, {
              colorful: "",
              "show-group": "",
              onAction: m
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), wE = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e;
        Be();
        const s = ref(null), r = ref(0), a = ref(false), l = ref(["heading", "codeBlock", "paragraph"]), c2 = ref(false), u = computed(() => {
          var k, j;
          const g = (k = n.node) == null ? void 0 : k.content.content;
          if (g.length > 0) {
            const v = g[0];
            if (v.type.name === "image")
              return v.type.name;
          }
          return (j = n.node) == null ? void 0 : j.type.name;
        }), d = computed(() => {
          var k;
          let g = u.value;
          return g === "heading" ? {
            icon: `format_h${((k = n.node.attrs) == null ? void 0 : k.level) || 1}`,
            color: Ve.blue
          } : (g === "table-wrapper" && (g = "table"), cu.find((j) => j.value === g) || { icon: "title" });
        });
        function p2(g) {
          var k;
          (k = s.value) == null || k.setShow(false), o("action", g);
        }
        function m(g) {
          a.value = g, console.log("show", g), g && f();
        }
        function f() {
          var k;
          let g = n.getPos();
          l.value.includes(u.value) || (g += 1), (k = n.editor) == null || k.commands.setNodeSelection(g), r.value = g;
        }
        function _(g) {
          c2.value = true, setTimeout(() => {
            c2.value = false;
          }, 10);
        }
        function h2(g) {
          c2.value = false;
        }
        return (g, k) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: s,
          placement: "left",
          size: "medium",
          trigger: "click",
          arrow: "",
          "onUpdate:show": m
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-node", { "is-selected": a.value, "is-dragging": c2.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: _,
              onDragend: h2
            }, [
              createVNode(unref(on), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(fe), {
                    name: d.value.icon,
                    color: d.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(fe), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(yE, mergeProps(n, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), jE = /* @__PURE__ */ defineComponent({
      __name: "index",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = ref(false), s = ref(0);
        ref(0);
        const r = computed(() => a.value === "paragraph" && n.node.content.size === 0), a = computed(() => {
          var p2, m;
          const d = (p2 = n.node) == null ? void 0 : p2.content.content;
          if (d.length > 0) {
            const f = d[0];
            if (f.type.name === "image")
              return f.type.name;
          }
          return (m = n.node) == null ? void 0 : m.type.name;
        }), l = computed(() => {
          var d;
          return s.value || ((d = n.node.attrs) == null ? void 0 : d.level);
        }), c2 = computed(() => a.value === "heading" ? `type-heading-${l.value}` : `type-${a.value}`);
        function u(d) {
          o("action", d);
        }
        return onMounted(() => {
          s.value = 0;
        }), (d, p2) => {
          var m;
          return (m = d.editor) != null && m.isEditable ? (openBlock(), createElementBlock("section", {
            key: 0,
            class: normalizeClass(["o-side-node", { "is-active": i.value, "is-empty": r.value }])
          }, [
            createBaseVNode("section", {
              class: normalizeClass(["action-container", c2.value])
            }, [
              createVNode(hE, normalizeProps(guardReactiveProps(n)), null, 16),
              r.value ? createCommentVNode("", true) : (openBlock(), createBlock(wE, mergeProps({ key: 0 }, n, { onAction: u }), null, 16))
            ], 2)
          ], 2)) : createCommentVNode("", true);
        };
      }
    }), ho = /* @__PURE__ */ defineComponent({
      __name: "ONodeView",
      props: Ot,
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = inject("sideNode", { value: false });
        return computed(() => {
          const s = {};
          return n.node.attrs["data-id"] && (s["data-id"] = n.node.attrs["data-id"]), s;
        }), (s, r) => (openBlock(), createBlock(unref(ru), {
          class: "o-node-view",
          "data-id": s.node.attrs["data-id"]
        }, {
          default: withCtx(() => {
            var a;
            return [
              unref(i) && ((a = s.editor) != null && a.isEditable) ? (openBlock(), createBlock(jE, mergeProps({ key: 0 }, n, {
                onAction: r[0] || (r[0] = (l) => o("action"))
              }), null, 16)) : createCommentVNode("", true),
              renderSlot(s.$slots, "default")
            ];
          }),
          _: 3
        }, 8, ["data-id"]));
      }
    }), EE = { class: "o-add-node-view" }, SE = {
      key: 0,
      class: "view-main"
    }, CE = { class: "group o-tips" }, xE = { class: "panel" }, TE = { class: "group o-tips" }, OE = {
      key: 1,
      class: "item"
    }, NE = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: s } = Ae();
        Be();
        const a = ref("main");
        function l(d) {
          const p2 = n.editor.chain();
          let m = null;
          switch (d.value) {
            case "blockquote":
              m = {
                content: Xr
              };
              break;
            case "callout":
              m = {
                content: Xr,
                attrs: { icon: "💡" }
              };
              break;
            case "codeBlock":
              m = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              m = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              m = {
                attrs: d.options
              };
              break;
            case "horizontalRule":
              m = {};
              break;
            case "paragraph":
              m = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              m = {
                content: F_
              };
              break;
            case "taskList":
              m = {
                content: H_
              };
              break;
            case "table":
              setTimeout(() => {
                p2.insertContentAt(u.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1), o("action", d);
              return;
            case "image":
              m = {
                type: "paragraph",
                content: [{ type: d.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              m = { attrs: { src: "init" } };
              break;
          }
          if (m) {
            const f = u.value;
            m.type = m.type || d.value, setTimeout(() => {
              c2.value ? p2.insertContent(m).focus().run() : p2.insertContentAt(f, m).focus().run();
            }, 1);
          }
          o("action", d);
        }
        const c2 = computed(() => {
          var d;
          return ((d = n.node) == null ? void 0 : d.content.size) === 0;
        }), u = computed(() => c2.value ? n.getPos() : n.getPos() + n.node.nodeSize);
        return (d, p2) => (openBlock(), createElementBlock("section", EE, [
          a.value === "main" ? (openBlock(), createElementBlock("section", SE, [
            createBaseVNode("section", null, [
              createBaseVNode("div", CE, toDisplayString(unref(s)("label.basic")), 1),
              createBaseVNode("section", xE, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Ws), (m, f) => (openBlock(), createBlock(unref(Ye), {
                  key: f,
                  icon: m.icon,
                  tooltip: unref(s)(m.label),
                  quaternary: "",
                  onClick: (_) => l(m)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Ms).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Ms), (m, f) => (openBlock(), createElementBlock(Fragment, { key: f }, [
                  m.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    f > 0 ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", TE, toDisplayString(unref(s)(m.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(xn), {
                    class: "item",
                    clickable: "",
                    onClick: (_) => l(m)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: m.icon,
                        color: m.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(s)(m.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", OE, "No result"))
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ]));
      }
    }), AE = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      setup(t2) {
        const e = t2, n = ref(), o = ref(false), i = computed(() => {
          var l;
          return ((l = e.node) == null ? void 0 : l.content.size) === 0;
        });
        computed(() => i.value ? e.getPos() : e.getPos() + e.node.nodeSize);
        function s(l) {
          o.value = l;
        }
        function r() {
          var l;
          (l = n.value) == null || l.setShow(true);
        }
        function a() {
          var l;
          (l = n.value) == null || l.setShow(false), o.value = false;
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: n,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "manual",
          offset: [0, 4],
          "onUpdate:show": s
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-btn", { "is-selected": o.value }])
            }, [
              createVNode(unref(on), {
                type: "tertiary",
                class: "o-node-btn",
                onClick: r
              }, {
                default: withCtx(() => [
                  createVNode(unref(fe), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(NE, mergeProps(e, { onAction: a }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), ME = { class: "o-drag-node-view" }, RE = {
      key: 0,
      class: "view-main"
    }, IE = { key: 0 }, DE = { class: "panel" }, LE = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, { tr: s } = Ae(), { onCommand: a } = Be(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var h2, g;
          const _ = (h2 = n.node) == null ? void 0 : h2.content.content;
          if (_.length > 0) {
            const k = _[0];
            if (k.type.name === "image")
              return k.type.name;
          }
          return (g = n.node) == null ? void 0 : g.type.name;
        }), d = computed(() => Yr.find((_) => _.value === u.value));
        function p2(_) {
          var h2;
          return _.value === u.value && ((h2 = n.editor) == null ? void 0 : h2.isActive(u.value, _.options));
        }
        function m(_) {
          switch (_.value) {
            case "delete":
              break;
            case "duplicate":
              break;
            default:
              f(_);
              break;
          }
          o("action", _);
        }
        function f(_) {
          var j, v, C, E, B;
          const h2 = n.getPos();
          if (_.value === u.value && c2.value.indexOf(u.value) < 0) {
            const U = (j = n.editor) == null ? void 0 : j.isActive(u.value), P = (v = n.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, U, P);
            return;
          }
          const g = (C = n.editor) == null ? void 0 : C.commands, k = (E = n.editor) == null ? void 0 : E.chain().focus(h2 + 1);
          console.log("runCommand", _), a(g, k, _.value, _.options), (B = n.editor) == null || B.commands.focus();
        }
        return (_, h2) => (openBlock(), createElementBlock("section", ME, [
          l.value === "main" ? (openBlock(), createElementBlock("section", RE, [
            d.value ? (openBlock(), createElementBlock("section", IE, [
              h2[0] || (h2[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", DE, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Yr), (g, k) => (openBlock(), createBlock(unref(Ye), {
                  key: k,
                  icon: g.icon,
                  tooltip: unref(s)(g.label),
                  "content-class": { "is-active": p2(g) },
                  quaternary: "",
                  onClick: (j) => m(g)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Vi), mergeProps(n, {
              colorful: "",
              "show-group": "",
              onAction: m
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), PE = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action", "dragstart", "dragend"],
      setup(t2, { emit: e }) {
        const n = t2, o = e;
        Be();
        const s = ref(null), r = ref(false), a = ref(["heading", "codeBlock", "paragraph"]), l = computed(() => {
          var h2, g, k;
          const _ = (g = (h2 = n.node) == null ? void 0 : h2.content) == null ? void 0 : g.content;
          if ((_ == null ? void 0 : _.length) > 0) {
            const j = _[0];
            if (j.type.name === "image")
              return j.type.name;
          }
          return (k = n.node) == null ? void 0 : k.type.name;
        }), c2 = computed(() => {
          var h2;
          let _ = l.value;
          return _ === "heading" ? {
            icon: `format_h${((h2 = n.node.attrs) == null ? void 0 : h2.level) || 1}`,
            color: Ve.blue
          } : (_ === "table-wrapper" && (_ = "table"), cu.find((g) => g.value === _) || { icon: "title" });
        });
        function u(_) {
          o("dragstart", _);
        }
        function d(_) {
          o("dragend", _);
        }
        function p2(_) {
          var h2;
          (h2 = s.value) == null || h2.setShow(false), o("action", _);
        }
        function m(_) {
          r.value = _, _ && f();
        }
        function f() {
          var h2;
          let _ = n.getPos();
          a.value.includes(l.value) || (_ += 1), (h2 = n.editor) == null || h2.commands.setNodeSelection(_);
        }
        return watch(
          () => n.getPos(),
          (_) => {
            var h2;
            (h2 = s.value) == null || h2.setShow(false);
          }
        ), (_, h2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: s,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "click",
          offset: [0, 2],
          "onUpdate:show": m
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-btn", { selected: r.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: u,
              onDragend: d
            }, [
              createVNode(unref(on), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(fe), {
                    name: c2.value.icon,
                    color: c2.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(fe), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(LE, mergeProps(n, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), on = /* @__PURE__ */ defineComponent({
      __name: "OBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["click"],
      setup(t2, { emit: e }) {
        const n = e;
        return (o, i) => (openBlock(), createElementBlock("button", {
          class: normalizeClass(["o-btn", t2.type ? `type-${t2.type}` : ""]),
          onClick: i[0] || (i[0] = (s) => n("click", s))
        }, [
          t2.icon ? (openBlock(), createBlock(unref(fe), {
            key: 0,
            name: t2.icon,
            class: normalizeClass(t2.iconClass)
          }, null, 8, ["name", "class"])) : createCommentVNode("", true),
          renderSlot(o.$slots, "default")
        ], 2));
      }
    }), BE = { class: "o-checkbox" }, $E = { class: "o-checkbox__main" }, zE = { class: "o-checkbox__suffix" }, U_ = /* @__PURE__ */ defineComponent({
      __name: "OCheckbox",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        label: {
          type: String,
          default: ""
        }
      },
      emits: ["update:modelValue"],
      setup(t2, { emit: e }) {
        const n = t2, o = e, i = computed({
          get() {
            return n.modelValue;
          },
          set(s) {
            o("update:modelValue", s);
          }
        });
        return (s, r) => (openBlock(), createElementBlock("div", BE, [
          createBaseVNode("div", $E, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": r[0] || (r[0] = (a) => i.value = a),
              type: "checkbox"
            }, null, 512), [
              [vModelCheckbox, i.value]
            ])
          ]),
          createBaseVNode("div", zE, toDisplayString(t2.label), 1)
        ]));
      }
    }), Cn = /* @__PURE__ */ defineComponent({
      __name: "ODivider",
      props: {
        vertical: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-divider", { "o-divider-vertical": t2.vertical }])
        }, null, 2));
      }
    }), FE = { class: "o-input__prefix" }, HE = { class: "o-input__main" }, UE = { class: "o-input__suffix" }, qi = /* @__PURE__ */ defineComponent({
      __name: "OInput",
      props: {
        modelValue: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["blur", "update:modelValue"],
      setup(t2, { expose: e, emit: n }) {
        const o = t2, i = n, s = ref(null), r = computed({
          get() {
            return o.modelValue;
          },
          set(c2) {
            i("update:modelValue", c2);
          }
        });
        function a() {
          var c2;
          (c2 = s.value) == null || c2.focus();
        }
        function l() {
          r.value = "", a();
        }
        return e({
          clear: l,
          focus: a
        }), (c2, u) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-input", `type-${t2.type}`])
        }, [
          createBaseVNode("div", FE, [
            renderSlot(c2.$slots, "prefix")
          ]),
          createBaseVNode("div", HE, [
            withDirectives(createBaseVNode("input", {
              ref_key: "input",
              ref: s,
              "onUpdate:modelValue": u[0] || (u[0] = (d) => r.value = d),
              onBlur: u[1] || (u[1] = (d) => i("blur"))
            }, null, 544), [
              [vModelText, r.value]
            ])
          ]),
          createBaseVNode("div", UE, [
            renderSlot(c2.$slots, "suffix"),
            t2.clearable && r.value ? (openBlock(), createBlock(fe, {
              key: 0,
              name: "close",
              class: "clear o-tips",
              onClick: l
            })) : createCommentVNode("", true)
          ])
        ], 2));
      }
    }), Bn = /* @__PURE__ */ defineComponent({
      __name: "OList",
      props: {
        clickable: {
          type: Boolean,
          default: false
        },
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("ul", {
          class: normalizeClass(["o-list", { clickable: t2.clickable, hoverable: t2.hoverable }])
        }, [
          renderSlot(e.$slots, "default")
        ], 2));
      }
    }), VE = { class: "o-list-item" }, qE = { class: "o-list-item__prefix" }, KE = { class: "o-list-item__main" }, WE = { class: "o-list-item__suffix" }, xn = /* @__PURE__ */ defineComponent({
      __name: "OListItem",
      props: {
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(t2) {
        return (e, n) => (openBlock(), createElementBlock("li", VE, [
          createBaseVNode("div", qE, [
            renderSlot(e.$slots, "prefix")
          ]),
          createBaseVNode("div", KE, [
            renderSlot(e.$slots, "default")
          ]),
          createBaseVNode("div", WE, [
            renderSlot(e.$slots, "suffix")
          ])
        ]));
      }
    }), Qe = /* @__PURE__ */ defineComponent({
      __name: "OPopover",
      props: {
        disable: {
          type: Boolean,
          default: false
        },
        arrow: {
          type: Boolean,
          default: false
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
        },
        tippyClass: {
          type: String,
          default: "tippy"
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 200
        }
      },
      emits: ["update:show"],
      setup(t2, { expose: e, emit: n }) {
        const o = t2, i = n, { theme: s } = Va(), r = ref(null), a = ref(), l = ref();
        function c2(m) {
          var f, _, h2, g;
          m ? ((_ = l.value) == null || _.setProps({
            getReferenceClientRect: (f = o.event) != null && f.clientX ? u : null
          }), (h2 = l.value) == null || h2.show()) : (g = l.value) == null || g.hide();
        }
        function u() {
          var m, f;
          return {
            width: 0,
            height: 0,
            left: o.event.clientX,
            right: o.event.clientX,
            top: o.event.clientY,
            bottom: o.event.clientY,
            x: ((m = o.event) == null ? void 0 : m.clientX) || 0,
            // add missing x
            y: ((f = o.event) == null ? void 0 : f.clientY) || 0,
            toJSON: () => {
              var _, h2;
              return {
                // add toJSON method to satisfy DOMRect
                width: 100,
                height: 100,
                left: ((_ = o.event) == null ? void 0 : _.clientX) || 0,
                top: ((h2 = o.event) == null ? void 0 : h2.clientY) || 0
              };
            }
          };
        }
        function d() {
          l.value = Ln(r.value, {
            appendTo: () => document.body,
            animation: "shift-away",
            // perspective, scale, shift-away
            arrow: o.arrow,
            content: a.value,
            duration: o.duration,
            delay: o.delay,
            interactive: true,
            offset: o.offset,
            placement: o.placement,
            trigger: o.trigger,
            theme: s.value,
            onShow: (m) => {
              m.popper.classList.add(o.tippyClass || "tippy"), i("update:show", true);
            },
            onHide: (m) => {
              i("update:show", false);
            }
          });
        }
        function p2() {
          l.value.setProps({
            theme: s.value
          });
        }
        return watch(s, (m) => {
          p2();
        }), onMounted(() => {
          d();
        }), e({
          setShow: c2
        }), (m, f) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: r,
          "data-tippy-role": "popover",
          class: "o-popover"
        }, [
          renderSlot(m.$slots, "trigger"),
          t2.disable ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "contentRef",
            ref: a,
            class: "popover-content"
          }, [
            renderSlot(m.$slots, "default")
          ], 512))
        ], 512));
      }
    }), GE = /* @__PURE__ */ defineComponent({
      __name: "OAlignDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = computed(() => [
          { label: n("editor.left"), value: "left", icon: "format_align_center" },
          {
            label: n("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: n("editor.right"), value: "right", icon: "format_align_right" },
          {
            label: n("editor.justify"),
            value: "justify",
            icon: "format_align_justify"
          }
        ]);
        function r(a) {
          var l;
          (l = i.value) == null || l.setShow(false), o(e.editor, "textAlign", {
            textAlign: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "format_align_center",
              "content-class": "o-align-dropdown dropdown",
              tooltip: unref(n)("editor.align")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(xn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = t2.editor) == null ? void 0 : d.isActive({ textAlign: c2.value }) }),
                    onClick: (p2) => r(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = t2.editor) != null && p2.isActive({ textAlign: c2.value }) ? (openBlock(), createBlock(unref(fe), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), JE = { class: "o-align-group" }, YE = /* @__PURE__ */ defineComponent({
      __name: "OAlignGroup",
      props: {
        editor: {
          type: Tn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = computed(() => [
          { label: n("editor.left"), value: "left", icon: "format_align_left" },
          {
            label: n("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: n("editor.right"), value: "right", icon: "format_align_right" }
        ]);
        function s(r) {
          o(e.editor, "textAlign", {
            textAlign: r.value
          });
        }
        return (r, a) => (openBlock(), createElementBlock("div", JE, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(Ye, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": {
                "is-active": (u = t2.editor) == null ? void 0 : u.isActive({ textAlign: l.value })
              },
              onClick: (d) => s(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), XE = { class: "o-back-color-dropdown o-button-group" }, ZE = /* @__PURE__ */ defineComponent({
      __name: "OBackColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = ref("#ffec3d");
        function r() {
          a(s.value);
        }
        function a(l) {
          i.value.setShow(false), s.value = l, o(e.editor, "backColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Uo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", XE, [
                  createVNode(unref(on), {
                    icon: "ink_highlighter",
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${s.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(on), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(du), {
                "default-color": "",
                "default-label": unref(n)("editor.noColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("highlight").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), QE = /* @__PURE__ */ defineComponent({
      __name: "OEmojiBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null);
        function s(r) {
          var a;
          (a = i.value) == null || a.setShow(false), o(e.editor, "content", { content: r.emoji });
        }
        return (r, a) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "o-emoji-popover",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "emoji_emotions",
              "content-class": "o-emoji-btn",
              tooltip: unref(n)("editor.emoji")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(fu), {
              items: unref(mu),
              onSelect: s,
              "enable-search": ""
            }, null, 8, ["items"])
          ]),
          _: 1
        }, 512));
      }
    }), eS = /* @__PURE__ */ defineComponent({
      __name: "OFontFamilyDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = computed(() => [
          { label: n("editor.default"), value: "system-ui" },
          // todo
          { label: "Arial", value: "Arial", separator: true },
          { label: "Arial Black", value: "Arial Black" },
          { label: "Georgia", value: "Georgia" },
          { label: "Impact", value: "Impact" },
          { label: "Helvetica", value: "Helvetica" },
          { label: "Roboto", value: "Roboto" },
          { label: "Tahoma", value: "Tahoma" },
          { label: "Times New Roman", value: "Times New Roman" },
          { label: "Verdana", value: "Verdana" },
          { label: "Courier New", value: "Courier New", separator: true },
          { label: "Monaco", value: "Monaco" },
          { label: "Monospace", value: "monospace" }
        ]);
        function r(a) {
          var l;
          (l = i.value) == null || l.setShow(false), o(e.editor, "fontFamily", {
            fontFamily: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "format_font",
              "content-class": "o-font-family-dropdown dropdown",
              tooltip: unref(n)("editor.fontFamily")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (c2, u) => {
                  var d;
                  return openBlock(), createElementBlock(Fragment, { key: u }, [
                    c2.separator ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                    createVNode(unref(xn), {
                      class: normalizeClass({
                        "is-active": (d = t2.editor) == null ? void 0 : d.isActive("textStyle", {
                          fontFamily: c2.value
                        })
                      }),
                      onClick: (p2) => r(c2.value)
                    }, {
                      suffix: withCtx(() => {
                        var p2;
                        return [
                          (p2 = t2.editor) != null && p2.isActive("textStyle", { fontFamily: c2.value }) ? (openBlock(), createBlock(unref(fe), {
                            key: 0,
                            name: "done",
                            small: ""
                          })) : createCommentVNode("", true)
                        ];
                      }),
                      default: withCtx(() => [
                        createBaseVNode("span", {
                          style: normalizeStyle(`font-family: ${c2.value}`)
                        }, toDisplayString(c2.label), 5)
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])
                  ], 64);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), tS = { class: "o-fore-color-dropdown o-button-group" }, nS = /* @__PURE__ */ defineComponent({
      __name: "OForeColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = ref("#ff4d4f");
        function r() {
          a(s.value);
        }
        function a(l) {
          var c2;
          (c2 = i.value) == null || c2.setShow(false), s.value = l, o(e.editor, "foreColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Uo), null, {
              trigger: withCtx(() => [
                createBaseVNode("div", tS, [
                  createVNode(unref(on), {
                    icon: "format_color_text",
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${s.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(on), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(n)("editor.textColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(du), {
                "default-color": "",
                "default-label": unref(n)("editor.defaultColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), oS = /* @__PURE__ */ defineComponent({
      __name: "OHeadingDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = computed(() => [
          {
            label: n("editor.paragraph"),
            value: "paragraph",
            valueAlt: "",
            icon: "title"
          },
          {
            label: n("editor.heading1"),
            value: "heading",
            valueAlt: 1,
            icon: "format_h1",
            separator: true
          },
          {
            label: n("editor.heading2"),
            value: "heading",
            valueAlt: 2,
            icon: "format_h2"
          },
          {
            label: n("editor.heading3"),
            value: "heading",
            valueAlt: 3,
            icon: "format_h3"
          },
          {
            label: n("editor.heading4"),
            value: "heading",
            valueAlt: 4,
            icon: "format_h4"
          },
          {
            label: n("editor.heading5"),
            value: "heading",
            valueAlt: 5,
            icon: "format_h5"
          }
        ]);
        function r(l) {
          var c2, u;
          return l.value === "heading" ? (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, { level: l.valueAlt }) : (u = e.editor) == null ? void 0 : u.isActive(l.value);
        }
        function a(l) {
          var c2;
          (c2 = i.value) == null || c2.setShow(false), o(e.editor, l.value, {
            level: l.valueAlt
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "format_header_pound",
              "content-class": "o-heading-dropdown dropdown",
              tooltip: unref(n)("editor.heading")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(xn), {
                    class: normalizeClass({ "is-active": r(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      r(u) ? (openBlock(), createBlock(unref(fe), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), iS = { class: "o-list-dropdown o-button-group" }, sS = /* @__PURE__ */ defineComponent({
      __name: "OListDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = ref();
        function r() {
          o(e.editor, s.value.value);
        }
        function a(c2) {
          i.value.setShow(false), s.value = c2, o(e.editor, c2.value);
        }
        const l = computed(() => [
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        return onMounted(() => {
          s.value = l.value[0];
        }), (c2, u) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Uo), { trigger: "hover" }, {
              trigger: withCtx(() => {
                var d;
                return [
                  createBaseVNode("div", iS, [
                    createVNode(unref(on), {
                      icon: (d = s.value) == null ? void 0 : d.icon,
                      class: "o-command-btn",
                      onClick: withModifiers(r, ["stop"])
                    }, null, 8, ["icon"]),
                    createVNode(unref(on), {
                      icon: "arrow_drop_down",
                      class: "o-command-btn"
                    })
                  ])
                ];
              }),
              default: withCtx(() => {
                var d;
                return [
                  createTextVNode(" " + toDisplayString((d = s.value) == null ? void 0 : d.label), 1)
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => {
                  var m;
                  return openBlock(), createBlock(unref(xn), {
                    key: p2,
                    class: normalizeClass({ "is-active": (m = t2.editor) == null ? void 0 : m.isActive(d.value) }),
                    onClick: (f) => a(d)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: d.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var f;
                      return [
                        (f = t2.editor) != null && f.isActive(d.value) ? (openBlock(), createBlock(unref(fe), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(d.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), rS = { class: "o-list-group" }, aS = /* @__PURE__ */ defineComponent({
      __name: "OListGroup",
      props: {
        editor: {
          type: Tn,
          required: true
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = computed(() => [
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        function s(r) {
          o(e.editor, r.value);
        }
        return (r, a) => (openBlock(), createElementBlock("div", rS, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(Ye, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": { "is-active": (u = t2.editor) == null ? void 0 : u.isActive(l.value) },
              onClick: (d) => s(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), lS = /* @__PURE__ */ defineComponent({
      __name: "OLinkBtn",
      props: {
        editor: {
          type: Tn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(), s = ref(false), r = ref(""), a = ref(true);
        function l() {
          var p2;
          r.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (r.value = d.href, a.value = d.target === "_blank", console.log("show", s.value, d, a.value));
        }
        function c2() {
          var d;
          (d = i.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? o(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : o(e.editor, "linkUnset"), (p2 = i.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: s.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (m) => s.value = m),
            l
          ]
        }, {
          trigger: withCtx(() => {
            var m;
            return [
              createVNode(unref(St), {
                icon: "link",
                "content-class": { "is-active": (m = t2.editor) == null ? void 0 : m.isActive("link") },
                tooltip: unref(n)("editor.hyperlink")
              }, null, 8, ["content-class", "tooltip"])
            ];
          }),
          default: withCtx(() => [
            s.value ? (openBlock(), createBlock(unref(z_), {
              key: 0,
              title: unref(n)("editor.hyperlink"),
              val: r.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(U_), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (m) => a.value = m),
                  label: unref(n)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), cS = /* @__PURE__ */ defineComponent({
      __name: "OLinkEditBtn",
      props: {
        editor: {
          type: Tn,
          required: true
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(), s = ref(false), r = ref(""), a = ref(true);
        function l() {
          var p2;
          r.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (r.value = d.href, a.value = d.target === "_blank");
        }
        function c2() {
          var d;
          (d = i.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? o(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : o(e.editor, "linkUnset"), (p2 = i.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: s.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (m) => s.value = m),
            l
          ]
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "edit",
              tooltip: unref(n)("link.edit")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            s.value ? (openBlock(), createBlock(unref(z_), {
              key: 0,
              title: unref(n)("link.edit"),
              val: r.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(U_), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (m) => a.value = m),
                  label: unref(n)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), uS = /* @__PURE__ */ defineComponent({
      __name: "OLinkOpenBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae();
        function o() {
          var s;
          const i = (s = e.editor) == null ? void 0 : s.getAttributes("link");
          i != null && i.href && window.open(i.href, "target");
        }
        return (i, s) => (openBlock(), createBlock(Ye, {
          icon: "open_in_new",
          tooltip: unref(n)("link.open"),
          "content-class": "o-link-open-btn",
          onClick: o
        }, null, 8, ["tooltip"]));
      }
    }), dS = [
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "fore-color",
      "back-color",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "codeBlock",
      "link",
      "image",
      "video",
      "modelViewer",
      "table",
      "callout",
      "emoji",
      "columns",
      "aiViewer"
    ], pS = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "link",
      "image"
    ], mS = [
      "bold",
      "strike",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "list-group",
      "link",
      "callout",
      "separator",
      "align-dropdown",
      "more"
    ], fS = ["link-open", "link-edit", "linkUnset"], _S = ["align-group", "separator", "link"], hS = [
      "align-group",
      "separator",
      "link-open",
      "link-edit",
      "linkUnset"
    ], gS = [
      "heading",
      "separator",
      "italic",
      "underline",
      "font-family",
      "separator",
      "code",
      "blockquote"
    ], vS = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "font-family",
      "text-color-dropdown",
      "separator",
      "align-group"
    ], bS = [
      "style-dropdown",
      "separator",
      "bold",
      "italic",
      "text-color-dropdown",
      "separator",
      "align-dropdown"
    ], kS = { class: "o-command-btn" }, yS = { class: "o-more-bubble" }, wS = /* @__PURE__ */ defineComponent({
      __name: "OMoreBubble",
      props: {
        editor: {
          type: Tn,
          required: true
        }
      },
      setup(t2) {
        const e = ref();
        return (n, o) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: e,
          offset: [4, 10],
          class: "o-simple-command-btn",
          "tippy-class": "o-more-bubble-popover",
          placement: "top-end",
          size: "medium",
          trigger: "mouseenter"
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", kS, [
              createVNode(unref(fe), { name: "more_horiz" })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("section", yS, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gS), (i, s) => (openBlock(), createElementBlock(Fragment, { key: s }, [
                i === "separator" ? (openBlock(), createBlock(unref(Cn), {
                  key: 0,
                  vertical: ""
                })) : typeof i == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(qa)(i)), {
                  key: 1,
                  name: i,
                  editor: t2.editor
                }, null, 8, ["name", "editor"])) : createCommentVNode("", true)
              ], 64))), 128))
            ])
          ]),
          _: 1
        }, 512));
      }
    }), jS = /* @__PURE__ */ defineComponent({
      __name: "OStyleDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = computed(() => [
          { label: n("editor.paragraph"), value: "paragraph", icon: "title" },
          {
            label: n("editor.heading1"),
            value: "heading",
            icon: "format_h1",
            options: { level: 1 }
          },
          {
            label: n("editor.heading2"),
            value: "heading",
            icon: "format_h2",
            options: { level: 2 }
          },
          {
            label: n("editor.heading3"),
            value: "heading",
            icon: "format_h3",
            options: { level: 3 }
          },
          { label: n("editor.todoList"), value: "taskList", icon: "check_box" },
          {
            label: n("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: n("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          {
            label: n("editor.blockquote"),
            value: "blockquote",
            icon: "format_quote_open"
          },
          {
            label: n("editor.removeFormat"),
            value: "clearFormat",
            icon: "format_clear",
            separator: true
          }
        ]);
        function r(l) {
          var c2;
          return (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, l.options);
        }
        function a(l) {
          i.value.setShow(false), o(e.editor, l.value, l.options);
        }
        return (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "format_paint",
              "content-class": "o-style-dropdown o-command-btn dropdown",
              tooltip: unref(n)("label.styles")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(Cn), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(xn), {
                    class: normalizeClass({ "is-active": r(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      r(u) ? (openBlock(), createBlock(unref(fe), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), ES = /* @__PURE__ */ defineComponent({
      __name: "OTableBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null);
        function s(r) {
          var a;
          (a = i.value) == null || a.setShow(false), o(e.editor, "tableInsert", r);
        }
        return (r, a) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "window",
              "content-class": "o-table-btn",
              tooltip: unref(n)("table.insert")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Y1), { onSelect: s })
          ]),
          _: 1
        }, 512));
      }
    }), SS = { class: "o-table-group" }, CS = /* @__PURE__ */ defineComponent({
      __name: "OTableGroup",
      props: {
        editor: {
          type: Tn,
          required: true
        }
      },
      setup(t2) {
        const { tr: e } = Ae(), { run: n } = Be();
        return (o, i) => {
          var s, r;
          return openBlock(), createElementBlock("section", SS, [
            (s = t2.editor) != null && s.can().mergeCells() ? (openBlock(), createBlock(unref(Ye), {
              key: 0,
              icon: "cell_merge",
              tooltip: unref(e)("table.merge"),
              onClick: i[0] || (i[0] = (a) => unref(n)(t2.editor, "tableMergeCells"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            (r = t2.editor) != null && r.can().splitCell() ? (openBlock(), createBlock(unref(Ye), {
              key: 1,
              icon: "splitscreen_left",
              tooltip: unref(e)("table.split"),
              onClick: i[1] || (i[1] = (a) => unref(n)(t2.editor, "tableSplitCell"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            createVNode(unref(Q1), { editor: t2.editor }, null, 8, ["editor"])
          ]);
        };
      }
    }), xS = /* @__PURE__ */ defineComponent({
      __name: "OTextColorDropdown",
      props: {
        editor: {
          type: Tn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(null), s = ref(""), r = ref("");
        function a(l, c2) {
          l === "foreColor" ? (s.value = c2, localStorage.setItem("yiitap.text-color.fore", c2)) : l === "backColor" && (r.value = c2, localStorage.setItem("yiitap.text-color.back", c2)), i.value.setShow(false), o(e.editor, l, {
            color: c2
          });
        }
        return onMounted(() => {
          s.value = localStorage.getItem("yiitap.text-color.fore") || "", r.value = localStorage.getItem("yiitap.text-color.back") || "";
        }), (l, c2) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "format_text",
              "content-class": "o-text-color-dropdown dropdown",
              tooltip: unref(n)("editor.textColor")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(aE), {
                "fore-color": s.value,
                "back-color": r.value,
                "default-label": unref(n)("editor.defaultColor"),
                "active-color": (u = t2.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["fore-color", "back-color", "default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), TS = /* @__PURE__ */ defineComponent({
      __name: "OTextFormatDropdown",
      props: {
        editor: {
          type: Tn
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { run: o } = Be(), i = ref(), s = computed(() => [
          {
            label: n("editor.strikethrough"),
            value: "strike",
            icon: "format_strikethrough"
          },
          {
            label: n("editor.underline"),
            value: "underline",
            icon: "format_underlined"
          },
          { label: n("editor.code"), value: "code", icon: "code" }
        ]);
        function r(a) {
          var l;
          (l = i.value) == null || l.setShow(false), o(e.editor, a);
        }
        return (a, l) => (openBlock(), createBlock(unref(Qe), {
          ref_key: "popover",
          ref: i,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(St), {
              icon: "title",
              "content-class": "o-text-format-dropdown dropdown",
              tooltip: unref(n)("editor.textFormat")
            }, {
              default: withCtx(() => [
                createVNode(unref(fe), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Bn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(xn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = t2.editor) == null ? void 0 : d.isActive(c2.value) }),
                    onClick: (p2) => r(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(fe), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = t2.editor) != null && p2.isActive(c2.value) ? (openBlock(), createBlock(unref(fe), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), OS = {
      // 'add-more': 'o-add-more-btn',
      "align-dropdown": GE,
      "align-group": YE,
      "back-color": ZE,
      "font-family": eS,
      "fore-color": nS,
      heading: oS,
      // 'indent-dropdown': 'o-indent-dropdown',
      // 'line-height': 'o-line-height-dropdown',
      "list-dropdown": sS,
      "list-group": aS,
      link: lS,
      "link-edit": cS,
      "link-open": uS,
      // 'image-settings': 'o-image-settings-btn',
      emoji: QE,
      more: wS,
      // 'node': 'o-node-btn',
      // 'node-dropdown': 'o-node-dropdown',
      "style-dropdown": jS,
      table: ES,
      "table-group": CS,
      "text-color-dropdown": xS,
      "text-format-dropdown": TS
    }, qa = (t2) => OS[t2] || Qj, NS = { class: "o-main-menu" }, AS = { class: "left" }, MS = { class: "right" }, RS = /* @__PURE__ */ defineComponent({
      __name: "OMainMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        }
      },
      setup(t2) {
        const e = t2, n = computed(() => {
          var i;
          let o = e.menu;
          return (i = e.editor) != null && i.isActive("table") && (o = pS), o.length > 0 ? o : dS;
        });
        return (o, i) => (openBlock(), createElementBlock("section", NS, [
          createBaseVNode("section", AS, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(n.value, (s, r) => (openBlock(), createElementBlock(Fragment, { key: r }, [
              s === "separator" ? (openBlock(), createBlock(unref(Cn), {
                key: 0,
                vertical: ""
              })) : typeof s == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(qa)(s)), {
                key: 1,
                name: s,
                editor: t2.editor
              }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(s), {
                key: 2,
                editor: t2.editor
              }, null, 8, ["editor"]))
            ], 64))), 128)),
            renderSlot(o.$slots, "left")
          ]),
          createBaseVNode("section", MS, [
            renderSlot(o.$slots, "right")
          ])
        ]));
      }
    }), IS = {
      key: 0,
      class: "o-bubble-menu"
    }, DS = { class: "container" }, LS = /* @__PURE__ */ defineComponent({
      __name: "OBubbleMenu",
      props: {
        editor: {
          type: Tn
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, { tr: n } = Ae();
        Va();
        const i = ref(false), s = ref({
          duration: 100,
          placement: "top",
          role: "popover",
          arrow: false,
          // offset: [0, 0]
          onShow: () => {
            i.value = false;
          }
        });
        function r() {
          i.value = true;
        }
        function a(p2) {
          const { schema: m } = e.editor, f = m.marks.link;
          if (!f || !p2) return false;
          const { $from: _, $to: h2 } = p2;
          return !!Ui(_, f);
        }
        function l({ editor: p2, element: m, view: f, state: _, oldState: h2, from: g, to: k }) {
          var ne;
          const { doc: j, selection: v } = _, { empty: C } = v, E = !j.textBetween(g, k).length && $a(_.selection);
          if (!f.hasFocus() || C || E && p2.isActive("link") && !p2.isActive("image"))
            return false;
          const B = ["image"], U = ["toc", "video", "model-viewer"], P = v.node, V = (ne = P == null ? void 0 : P.type) == null ? void 0 : ne.name;
          return !(p2.isActive("codeBlock") || U.indexOf(V) >= 0 || V && !B.includes(V));
        }
        const c2 = computed(() => {
          if (e.editor) {
            const { state: p2 } = e.editor, { tr: m } = p2, { selection: f } = m;
            return a(f);
          } else
            return false;
        }), u = computed(() => {
          var p2;
          return !i.value && c2.value && !((p2 = e.editor) != null && p2.isActive("image"));
        }), d = computed(() => {
          var m, f;
          let p2 = e.menu;
          return i.value || ((m = e.editor) != null && m.isActive("image") ? p2 = c2.value ? hS : _S : (f = e.editor) != null && f.isActive("table") ? p2 = vS : c2.value && (p2 = fS)), p2.length > 0 ? p2 : mS;
        });
        return onMounted(() => {
          i.value = false;
        }), (p2, m) => t2.editor ? (openBlock(), createElementBlock("section", IS, [
          createVNode(unref(Kw), {
            class: normalizeClass(["bubble-menu", t2.menuClass]),
            editor: t2.editor,
            "should-show": l,
            "tippy-options": s.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", DS, [
                u.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(unref(Ye), {
                    icon: "arrow_back",
                    tooltip: unref(n)("link.back"),
                    onClick: r
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(Cn), { vertical: "" })
                ], 64)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (f, _) => (openBlock(), createElementBlock(Fragment, { key: _ }, [
                  f === "separator" ? (openBlock(), createBlock(unref(Cn), {
                    key: 0,
                    vertical: ""
                  })) : typeof f == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(qa)(f)), {
                    key: 1,
                    name: f,
                    editor: t2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(f), {
                    key: 2,
                    editor: t2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    }), PS = {
      key: 0,
      class: "o-floating-menu"
    }, BS = { class: "container" }, $S = /* @__PURE__ */ defineComponent({
      __name: "OFloatingMenu",
      props: {
        editor: {
          type: j_
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, n = ref(false), o = ref({
          arrow: false,
          duration: 100,
          role: "popover",
          placement: "right",
          offset: [0, 168]
        });
        function i() {
          n.value = true;
        }
        function s(c2) {
          const { schema: u } = e.editor, d = u.marks.link;
          if (!d || !c2) return false;
          const { $from: p2, $to: m } = c2;
          return !!Ui(p2, d);
        }
        const r = computed(() => {
          if (e.editor) {
            const { state: c2 } = e.editor, { tr: u } = c2, { selection: d } = u;
            return s(d);
          } else
            return false;
        }), a = computed(() => !n.value && r.value), l = computed(() => {
          let c2 = e.menu;
          return c2.length > 0 ? c2 : bS;
        });
        return (c2, u) => t2.editor ? (openBlock(), createElementBlock("section", PS, [
          createVNode(unref(Gw), {
            class: normalizeClass(["floating-menu", t2.menuClass]),
            editor: t2.editor,
            "tippy-options": o.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", BS, [
                a.value ? (openBlock(), createBlock(unref(Ye), {
                  key: 0,
                  icon: "arrow_back",
                  onClick: i
                })) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => (openBlock(), createElementBlock(Fragment, { key: p2 }, [
                  d === "separator" ? (openBlock(), createBlock(unref(Cn), {
                    key: 0,
                    vertical: ""
                  })) : typeof d == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(qa)(d)), {
                    key: 1,
                    name: d,
                    editor: t2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(d), {
                    key: 2,
                    editor: t2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    function _u(t2, e) {
      const n = e == null ? void 0 : e.posAtCoords(t2);
      if (!n)
        return;
      let o = Or(n.pos, e);
      if (o !== e.dom) {
        for (; o && o.parentNode && o.parentNode !== e.dom; )
          o = o.parentNode;
        if (o)
          return o;
      }
    }
    function Or(t2, e) {
      return e.nodeDOM(t2) || e.domAtPos(t2).node;
    }
    function hu(t2, e) {
      const n = _u(t2, e);
      if (n && n.nodeType === 1) {
        const o = e.docView, i = o.nearestDesc(n, true);
        return !i || i === o ? null : i.posBefore;
      }
      return null;
    }
    function zS(t2, e) {
      let n, o;
      const i = e.resolve(t2.from).node().type.spec.group === "blockContent", s = e.resolve(t2.to).node().type.spec.group === "blockContent", r = Math.min(t2.$anchor.depth, t2.$head.depth);
      if (i && s) {
        const a = t2.$from.start(r - 1), l = t2.$to.end(r - 1);
        n = e.resolve(a - 1).pos, o = e.resolve(l + 1).pos;
      } else
        n = t2.from, o = t2.to;
      return { from: n, to: o };
    }
    function FS(t2, e) {
      const n = hu(t2, e.view);
      return n && n >= 0 ? {
        node: e.state.doc.nodeAt(n),
        pos: n
      } : {
        node: null,
        pos: n
      };
    }
    const Zr = new Fe("sideMenu");
    class HS {
      constructor() {
        ft(this, "hovered", false);
        ft(this, "coords", { left: 0, top: 0 });
        ft(this, "className", "");
      }
      init(e) {
        return this;
      }
      apply({ tr: e, oldState: n, newState: o }) {
        return e.docChanged ? this : this;
      }
      setHover(e, n, o = "") {
        this.hovered = e, this.coords = n, this.className = o;
      }
    }
    class US {
      constructor({
        editor: e,
        element: n,
        view: o,
        tippyOptions: i = {},
        updateDelay: s = 250
      }) {
        ft(this, "editor");
        ft(this, "element");
        ft(this, "view");
        ft(this, "preventHide", false);
        ft(this, "tippy");
        ft(this, "tippyOptions");
        ft(this, "updateDelay");
        ft(this, "updateDebounceTimer");
        ft(this, "mousedownHandler", () => {
          this.preventHide = true;
        });
        ft(this, "onDragStart", (e2) => {
          this.hide();
        });
        ft(this, "blurHandler", ({ event: e2 }) => {
          var n2;
          e2 != null && e2.relatedTarget && ((n2 = this.element.parentNode) != null && n2.contains(e2.relatedTarget)) || this.hide();
        });
        ft(this, "tippyBlurHandler", (e2) => {
          this.blurHandler({ event: e2 });
        });
        ft(this, "handleDebouncedUpdate", (e2, n2) => {
          const o2 = !(n2 != null && n2.selection.eq(e2.state.selection)), i2 = !(n2 != null && n2.doc.eq(e2.state.doc));
          !o2 && !i2 || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(e2, o2, i2, n2);
          }, this.updateDelay));
        });
        ft(this, "updateHandler", (e2, n2, o2, i2) => {
          var u, d;
          const { state: s2, composing: r } = e2, { coords: a } = Zr.getState(s2), l = _u(a, e2), c2 = hu(a, e2);
          !l || c2 <= 0 || (this.createTooltip(), (d = this.tippy) == null || d.setProps({
            getReferenceClientRect: ((u = this.tippyOptions) == null ? void 0 : u.getReferenceClientRect) || (() => l.getBoundingClientRect())
          }), this.show());
        });
        this.editor = e, this.element = n, this.view = o, this.updateDelay = s, this.view.dom.addEventListener("dragstart", this.onDragStart), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, n = !!e.parentElement;
        this.tippy || !n || (this.tippy = Ln(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "left",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
      }
      update(e, n) {
        const { state: o } = e, i = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
        this.updateHandler(e, i, s, n);
      }
      show() {
        var e;
        (e = this.tippy) == null || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) == null || e.hide();
      }
      destroy() {
        var e, n;
        (e = this.tippy) != null && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ), (n = this.tippy) == null || n.destroy(), this.view.dom.removeEventListener("dragstart", this.onDragStart);
      }
    }
    const VS = (t2, e) => {
      if (!t2.dataTransfer) return;
      const n = e.view, o = n.dom.getBoundingClientRect(), i = {
        left: o.left + o.width / 2,
        // take middle of editor
        top: t2.clientY
      }, s = hu(i, n);
      if (s === null) return;
      const r = n.state.selection, a = n.state.doc;
      zS(r, a), n.dispatch(
        n.state.tr.setSelection(ie.create(n.state.doc, s))
      ), KS(n, s);
      const l = n.state.selection.content(), { dom: c2, text: u } = n.serializeForClipboard(l);
      t2.dataTransfer.clearData(), t2.dataTransfer.setData("text/html", c2.innerHTML), t2.dataTransfer.setData("text/plain", u), t2.dataTransfer.effectAllowed = "move", t2.dataTransfer.setDragImage(ii, 0, 0), n.dragging = { slice: l, move: true };
    }, qS = (t2, e) => {
      V_();
    };
    let ii;
    function KS(t2, e, n = e) {
      const o = t2.domAtPos(e).node.cloneNode(true), i = t2.domAtPos(e).node, s = (d, p2) => Array.prototype.indexOf.call(d.children, p2), r = (d) => {
        let p2 = d, m = p2.parentElement;
        for (; m; ) {
          if (m === t2.dom)
            return p2;
          p2 = m, m = p2.parentElement;
        }
        return p2;
      };
      let a = -1, l = -1;
      e === n ? (a = s(
        i,
        r(Or(e, t2))
      ), l = a) : (a = s(
        i,
        // Expects from position to be just before the first selected block.
        r(Or(e + 1, t2))
      ), l = s(
        i,
        // Expects to position to be just after the last selected block.
        r(Or(n - 1, t2))
      ));
      for (let d = i.childElementCount - 1; d >= 0; d--)
        (d > a || d < l) && o.removeChild(o.children[d]);
      V_(), ii = o;
      const u = t2.dom.className.split(" ").filter(
        (d) => d !== "ProseMirror" && d !== "yiitap-root" && d !== "yiitap-editor"
      ).join(" ");
      ii.className += " yiitap-dragging-preview " + u, document.body.appendChild(ii);
    }
    function V_() {
      ii !== void 0 && (document.body.removeChild(ii), ii = void 0);
    }
    class WS {
      constructor(e) {
        ft(this, "options");
        ft(this, "plugin");
        ft(this, "sideMenuView");
        const n = new HS();
        this.options = e, this.plugin = new ze({
          key: Zr,
          props: {
            handleDOMEvents: {
              mouseover(o, i) {
                const s = {
                  left: i.clientX,
                  top: i.clientY
                }, r = _u(s, o), a = (r == null ? void 0 : r.className) || "", l = n.className;
                a.indexOf("o-table-wrapper-view") >= 0 && l.indexOf("o-table-wrapper-view") >= 0 || (n.setHover(true, s, a), o.dispatch(o.state.tr.setMeta(Zr, n)));
              }
            }
          },
          state: {
            init(o, i) {
              return n.init(i);
            },
            apply(o, i, s, r) {
              return n.apply({ tr: o, oldState: s, newState: r });
            }
          },
          view: (o) => (this.sideMenuView = new US({ view: o, ...e }), this.sideMenuView)
        });
      }
      dragstart(e) {
        VS(e, this.options.editor);
      }
      dragend(e) {
        qS(e, this.options.editor);
      }
    }
    const GS = /* @__PURE__ */ defineComponent({
      name: "SideMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "sideMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        }
      },
      setup(t2, { expose: e, slots: n }) {
        const o = ref(null), i = ref(), s = (a) => {
          var l;
          (l = i.value) == null || l.dragstart(a);
        }, r = (a) => {
          var l;
          (l = i.value) == null || l.dragend(a);
        };
        return onMounted(() => {
          const { pluginKey: a, editor: l, updateDelay: c2, tippyOptions: u } = t2;
          i.value = new WS({
            updateDelay: c2,
            editor: l,
            element: o.value,
            pluginKey: a,
            tippyOptions: u
          }), l.registerPlugin(i.value.plugin);
        }), onBeforeUnmount(() => {
          const { pluginKey: a, editor: l } = t2;
          l.unregisterPlugin(a);
        }), e({
          ...t2,
          dragstart: s,
          dragend: r
        }), () => {
          var a;
          return h("div", { ref: o }, (a = n.default) == null ? void 0 : a.call(n));
        };
      }
    }), JS = {
      key: 0,
      class: "o-side-menu"
    }, YS = { class: "container" }, XS = /* @__PURE__ */ defineComponent({
      __name: "OSideMenu",
      props: {
        editor: {
          type: Tn,
          required: true
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(t2) {
        const e = t2, n = ref(null), o = ref(null), i = ref(0), s = computed(() => ({
          arrow: false,
          duration: 100,
          placement: "left"
          // offset: [0, 0]
        })), r = computed(() => ({
          editor: e.editor,
          node: o.value,
          decorations: [],
          selected: false,
          extension: {},
          getPos: () => i.value,
          pos: i.value,
          updateAttributes: l,
          deleteNode: a,
          view: void 0,
          innerDecorations: [],
          HTMLAttributes: void 0
        }));
        function a() {
          var f, _;
          const p2 = i.value, m = p2 + ((f = o.value) == null ? void 0 : f.nodeSize);
          (_ = e.editor) == null || _.commands.deleteRange({ from: p2, to: m });
        }
        function l(p2) {
          var m;
          (m = e.editor) == null || m.commands.command(({ tr: f }) => {
            var _;
            return f.setNodeMarkup(i.value, void 0, {
              ...(_ = o.value) == null ? void 0 : _.attrs,
              ...p2
            }), true;
          });
        }
        function c2({ editor: p2, transaction: m }) {
          let f = { left: 0, top: 0 };
          const _ = Zr.getState(e.editor.view.state);
          if (_) {
            f = _.coords;
            const h2 = FS(f, p2);
            h2.node && h2.pos > 0 && (o.value = h2.node, i.value = h2.pos);
          }
        }
        function u(p2) {
          var m;
          (m = n.value) == null || m.dragstart(p2);
        }
        function d(p2) {
          var m;
          (m = n.value) == null || m.dragend(p2);
        }
        return onMounted(() => {
          var p2;
          (p2 = e.editor) == null || p2.on("transaction", c2);
        }), (p2, m) => t2.editor ? (openBlock(), createElementBlock("section", JS, [
          createVNode(unref(GS), {
            ref_key: "menu",
            ref: n,
            class: normalizeClass(["side-menu", t2.menuClass]),
            editor: t2.editor,
            "tippy-options": s.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", YS, [
                o.value ? (openBlock(), createBlock(unref(AE), normalizeProps(mergeProps({ key: 0 }, r.value)), null, 16)) : createCommentVNode("", true),
                o.value ? (openBlock(), createBlock(unref(PE), mergeProps({ key: 1 }, r.value, {
                  onDragstart: u,
                  onDragend: d
                }), null, 16)) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Sp = (t2) => {
      const e = /(#[0-9a-f]{3,6})\b/gi, n = [];
      return t2.descendants((o, i) => {
        o.text && Array.from(o.text.matchAll(e)).forEach((s) => {
          const r = s[0], a = s.index || 0, l = i + a, c2 = l + r.length, u = _t.inline(l, c2, {
            class: "color",
            style: `--color: ${r}`
          });
          n.push(u);
        });
      }), qe.create(t2, n);
    }, ZS = We.create({
      name: "colorHighlighter",
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("colorHighlighter"),
            state: {
              init(t2, { doc: e }) {
                return Sp(e);
              },
              apply(t2, e) {
                return t2.docChanged ? Sp(t2.doc) : e;
              }
            },
            props: {
              decorations(t2) {
                return this.getState(t2);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    We.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("focus"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const { isEditable: n, isFocused: o } = this.editor, { anchor: i } = e, s = [];
                if (!n || !o)
                  return qe.create(t2, []);
                let r = 0;
                this.options.mode === "deepest" && t2.descendants((l, c2) => {
                  if (!l.isText) {
                    if (!(i >= c2 && i <= c2 + l.nodeSize - 1))
                      return false;
                    r += 1;
                  }
                });
                let a = 0;
                return t2.descendants((l, c2) => {
                  if (l.isText || !(i >= c2 && i <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && r - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  s.push(
                    _t.node(c2, c2 + l.nodeSize, {
                      class: this.options.className
                    })
                  );
                }), qe.create(t2, s);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const QS = We.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something …",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("placeholder"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: o } = e, i = [];
                return n ? (t2.descendants((s, r) => {
                  const a = o >= r && o <= r + s.nodeSize, l = !s.isLeaf && !s.childCount, c2 = this.options.showOnlyCurrent;
                  if ((a || !c2) && l) {
                    const u = [this.options.emptyNodeClass];
                    this.editor.isEmpty && u.push(this.options.emptyEditorClass);
                    const d = _t.node(r, r + s.nodeSize, {
                      class: u.join(" "),
                      "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                        editor: this.editor,
                        node: s,
                        pos: r,
                        hasAnchor: a
                      }) : this.options.placeholder
                    });
                    i.push(d);
                  }
                  return this.options.includeChildren;
                }), qe.create(t2, i)) : null;
              }
            }
          })
        ];
      }
    });
    var pc, mc;
    if (typeof WeakMap < "u") {
      let t2 = /* @__PURE__ */ new WeakMap();
      pc = (e) => t2.get(e), mc = (e, n) => (t2.set(e, n), n);
    } else {
      const t2 = [];
      let n = 0;
      pc = (o) => {
        for (let i = 0; i < t2.length; i += 2)
          if (t2[i] == o) return t2[i + 1];
      }, mc = (o, i) => (n == 10 && (n = 0), t2[n++] = o, t2[n++] = i);
    }
    var ut = class {
      constructor(t2, e, n, o) {
        this.width = t2, this.height = e, this.map = n, this.problems = o;
      }
      // Find the dimensions of the cell at the given position.
      findCell(t2) {
        for (let e = 0; e < this.map.length; e++) {
          const n = this.map[e];
          if (n != t2) continue;
          const o = e % this.width, i = e / this.width | 0;
          let s = o + 1, r = i + 1;
          for (let a = 1; s < this.width && this.map[e + a] == n; a++)
            s++;
          for (let a = 1; r < this.height && this.map[e + this.width * a] == n; a++)
            r++;
          return { left: o, top: i, right: s, bottom: r };
        }
        throw new RangeError(`No cell with offset ${t2} found`);
      }
      // Find the left side of the cell at the given position.
      colCount(t2) {
        for (let e = 0; e < this.map.length; e++)
          if (this.map[e] == t2)
            return e % this.width;
        throw new RangeError(`No cell with offset ${t2} found`);
      }
      // Find the next cell in the given direction, starting from the cell
      // at `pos`, if any.
      nextCell(t2, e, n) {
        const { left: o, right: i, top: s, bottom: r } = this.findCell(t2);
        return e == "horiz" ? (n < 0 ? o == 0 : i == this.width) ? null : this.map[s * this.width + (n < 0 ? o - 1 : i)] : (n < 0 ? s == 0 : r == this.height) ? null : this.map[o + this.width * (n < 0 ? s - 1 : r)];
      }
      // Get the rectangle spanning the two given cells.
      rectBetween(t2, e) {
        const {
          left: n,
          right: o,
          top: i,
          bottom: s
        } = this.findCell(t2), {
          left: r,
          right: a,
          top: l,
          bottom: c2
        } = this.findCell(e);
        return {
          left: Math.min(n, r),
          top: Math.min(i, l),
          right: Math.max(o, a),
          bottom: Math.max(s, c2)
        };
      }
      // Return the position of all cells that have the top left corner in
      // the given rectangle.
      cellsInRect(t2) {
        const e = [], n = {};
        for (let o = t2.top; o < t2.bottom; o++)
          for (let i = t2.left; i < t2.right; i++) {
            const s = o * this.width + i, r = this.map[s];
            n[r] || (n[r] = true, !(i == t2.left && i && this.map[s - 1] == r || o == t2.top && o && this.map[s - this.width] == r) && e.push(r));
          }
        return e;
      }
      // Return the position at which the cell at the given row and column
      // starts, or would start, if a cell started there.
      positionAt(t2, e, n) {
        for (let o = 0, i = 0; ; o++) {
          const s = i + n.child(o).nodeSize;
          if (o == t2) {
            let r = e + t2 * this.width;
            const a = (t2 + 1) * this.width;
            for (; r < a && this.map[r] < i; ) r++;
            return r == a ? s - 1 : this.map[r];
          }
          i = s;
        }
      }
      // Find the table map for the given table node.
      static get(t2) {
        return pc(t2) || mc(t2, eC(t2));
      }
    };
    function eC(t2) {
      if (t2.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + t2.type.name);
      const e = tC(t2), n = t2.childCount, o = [];
      let i = 0, s = null;
      const r = [];
      for (let c2 = 0, u = e * n; c2 < u; c2++) o[c2] = 0;
      for (let c2 = 0, u = 0; c2 < n; c2++) {
        const d = t2.child(c2);
        u++;
        for (let f = 0; ; f++) {
          for (; i < o.length && o[i] != 0; ) i++;
          if (f == d.childCount) break;
          const _ = d.child(f), { colspan: h2, rowspan: g, colwidth: k } = _.attrs;
          for (let j = 0; j < g; j++) {
            if (j + c2 >= n) {
              (s || (s = [])).push({
                type: "overlong_rowspan",
                pos: u,
                n: g - j
              });
              break;
            }
            const v = i + j * e;
            for (let C = 0; C < h2; C++) {
              o[v + C] == 0 ? o[v + C] = u : (s || (s = [])).push({
                type: "collision",
                row: c2,
                pos: u,
                n: h2 - C
              });
              const E = k && k[C];
              if (E) {
                const B = (v + C) % e * 2, U = r[B];
                U == null || U != E && r[B + 1] == 1 ? (r[B] = E, r[B + 1] = 1) : U == E && r[B + 1]++;
              }
            }
          }
          i += h2, u += _.nodeSize;
        }
        const p2 = (c2 + 1) * e;
        let m = 0;
        for (; i < p2; ) o[i++] == 0 && m++;
        m && (s || (s = [])).push({ type: "missing", row: c2, n: m }), u++;
      }
      (e === 0 || n === 0) && (s || (s = [])).push({ type: "zero_sized" });
      const a = new ut(e, n, o, s);
      let l = false;
      for (let c2 = 0; !l && c2 < r.length; c2 += 2)
        r[c2] != null && r[c2 + 1] < n && (l = true);
      return l && nC(a, r, t2), a;
    }
    function tC(t2) {
      let e = -1, n = false;
      for (let o = 0; o < t2.childCount; o++) {
        const i = t2.child(o);
        let s = 0;
        if (n)
          for (let r = 0; r < o; r++) {
            const a = t2.child(r);
            for (let l = 0; l < a.childCount; l++) {
              const c2 = a.child(l);
              r + c2.attrs.rowspan > o && (s += c2.attrs.colspan);
            }
          }
        for (let r = 0; r < i.childCount; r++) {
          const a = i.child(r);
          s += a.attrs.colspan, a.attrs.rowspan > 1 && (n = true);
        }
        e == -1 ? e = s : e != s && (e = Math.max(e, s));
      }
      return e;
    }
    function nC(t2, e, n) {
      t2.problems || (t2.problems = []);
      const o = {};
      for (let i = 0; i < t2.map.length; i++) {
        const s = t2.map[i];
        if (o[s]) continue;
        o[s] = true;
        const r = n.nodeAt(s);
        if (!r)
          throw new RangeError(`No cell with offset ${s} found`);
        let a = null;
        const l = r.attrs;
        for (let c2 = 0; c2 < l.colspan; c2++) {
          const u = (i + c2) % t2.width, d = e[u * 2];
          d != null && (!l.colwidth || l.colwidth[c2] != d) && ((a || (a = oC(l)))[c2] = d);
        }
        a && t2.problems.unshift({
          type: "colwidth mismatch",
          pos: s,
          colwidth: a
        });
      }
    }
    function oC(t2) {
      if (t2.colwidth) return t2.colwidth.slice();
      const e = [];
      for (let n = 0; n < t2.colspan; n++) e.push(0);
      return e;
    }
    function Ft(t2) {
      let e = t2.cached.tableNodeTypes;
      if (!e) {
        e = t2.cached.tableNodeTypes = {};
        for (const n in t2.nodes) {
          const o = t2.nodes[n], i = o.spec.tableRole;
          i && (e[i] = o);
        }
      }
      return e;
    }
    var Co = new Fe("selectingCells");
    function Ki(t2) {
      for (let e = t2.depth - 1; e > 0; e--)
        if (t2.node(e).type.spec.tableRole == "row")
          return t2.node(0).resolve(t2.before(e + 1));
      return null;
    }
    function iC(t2) {
      for (let e = t2.depth; e > 0; e--) {
        const n = t2.node(e).type.spec.tableRole;
        if (n === "cell" || n === "header_cell") return t2.node(e);
      }
      return null;
    }
    function $n(t2) {
      const e = t2.selection.$head;
      for (let n = e.depth; n > 0; n--)
        if (e.node(n).type.spec.tableRole == "row") return true;
      return false;
    }
    function Ka(t2) {
      const e = t2.selection;
      if ("$anchorCell" in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
      if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
      const n = Ki(e.$head) || sC(e.$head);
      if (n)
        return n;
      throw new RangeError(`No cell found around position ${e.head}`);
    }
    function sC(t2) {
      for (let e = t2.nodeAfter, n = t2.pos; e; e = e.firstChild, n++) {
        const o = e.type.spec.tableRole;
        if (o == "cell" || o == "header_cell") return t2.doc.resolve(n);
      }
      for (let e = t2.nodeBefore, n = t2.pos; e; e = e.lastChild, n--) {
        const o = e.type.spec.tableRole;
        if (o == "cell" || o == "header_cell")
          return t2.doc.resolve(n - e.nodeSize);
      }
    }
    function fc(t2) {
      return t2.parent.type.spec.tableRole == "row" && !!t2.nodeAfter;
    }
    function rC(t2) {
      return t2.node(0).resolve(t2.pos + t2.nodeAfter.nodeSize);
    }
    function gu(t2, e) {
      return t2.depth == e.depth && t2.pos >= e.start(-1) && t2.pos <= e.end(-1);
    }
    function q_(t2, e, n) {
      const o = t2.node(-1), i = ut.get(o), s = t2.start(-1), r = i.nextCell(t2.pos - s, e, n);
      return r == null ? null : t2.node(0).resolve(s + r);
    }
    function di(t2, e, n = 1) {
      const o = { ...t2, colspan: t2.colspan - n };
      return o.colwidth && (o.colwidth = o.colwidth.slice(), o.colwidth.splice(e, n), o.colwidth.some((i) => i > 0) || (o.colwidth = null)), o;
    }
    function K_(t2, e, n = 1) {
      const o = { ...t2, colspan: t2.colspan + n };
      if (o.colwidth) {
        o.colwidth = o.colwidth.slice();
        for (let i = 0; i < n; i++) o.colwidth.splice(e, 0, 0);
      }
      return o;
    }
    function aC(t2, e, n) {
      const o = Ft(e.type.schema).header_cell;
      for (let i = 0; i < t2.height; i++)
        if (e.nodeAt(t2.map[n + i * t2.width]).type != o)
          return false;
      return true;
    }
    var Xe = class io extends de {
      // A table selection is identified by its anchor and head cells. The
      // positions given to this constructor should point _before_ two
      // cells in the same table. They may be the same, to select a single
      // cell.
      constructor(e, n = e) {
        const o = e.node(-1), i = ut.get(o), s = e.start(-1), r = i.rectBetween(
          e.pos - s,
          n.pos - s
        ), a = e.node(0), l = i.cellsInRect(r).filter((u) => u != n.pos - s);
        l.unshift(n.pos - s);
        const c2 = l.map((u) => {
          const d = o.nodeAt(u);
          if (!d)
            throw RangeError(`No cell with offset ${u} found`);
          const p2 = s + u + 1;
          return new qm(
            a.resolve(p2),
            a.resolve(p2 + d.content.size)
          );
        });
        super(c2[0].$from, c2[0].$to, c2), this.$anchorCell = e, this.$headCell = n;
      }
      map(e, n) {
        const o = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
        if (fc(o) && fc(i) && gu(o, i)) {
          const s = this.$anchorCell.node(-1) != o.node(-1);
          return s && this.isRowSelection() ? io.rowSelection(o, i) : s && this.isColSelection() ? io.colSelection(o, i) : new io(o, i);
        }
        return re.between(o, i);
      }
      // Returns a rectangular slice of table rows containing the selected
      // cells.
      content() {
        const e = this.$anchorCell.node(-1), n = ut.get(e), o = this.$anchorCell.start(-1), i = n.rectBetween(
          this.$anchorCell.pos - o,
          this.$headCell.pos - o
        ), s = {}, r = [];
        for (let l = i.top; l < i.bottom; l++) {
          const c2 = [];
          for (let u = l * n.width + i.left, d = i.left; d < i.right; d++, u++) {
            const p2 = n.map[u];
            if (s[p2]) continue;
            s[p2] = true;
            const m = n.findCell(p2);
            let f = e.nodeAt(p2);
            if (!f)
              throw RangeError(`No cell with offset ${p2} found`);
            const _ = i.left - m.left, h2 = m.right - i.right;
            if (_ > 0 || h2 > 0) {
              let g = f.attrs;
              if (_ > 0 && (g = di(g, 0, _)), h2 > 0 && (g = di(
                g,
                g.colspan - h2,
                h2
              )), m.left < i.left) {
                if (f = f.type.createAndFill(g), !f)
                  throw RangeError(
                    `Could not create cell with attrs ${JSON.stringify(g)}`
                  );
              } else
                f = f.type.create(g, f.content);
            }
            if (m.top < i.top || m.bottom > i.bottom) {
              const g = {
                ...f.attrs,
                rowspan: Math.min(m.bottom, i.bottom) - Math.max(m.top, i.top)
              };
              m.top < i.top ? f = f.type.createAndFill(g) : f = f.type.create(g, f.content);
            }
            c2.push(f);
          }
          r.push(e.child(l).copy(D.from(c2)));
        }
        const a = this.isColSelection() && this.isRowSelection() ? e : r;
        return new K(D.from(a), 1, 1);
      }
      replace(e, n = K.empty) {
        const o = e.steps.length, i = this.ranges;
        for (let r = 0; r < i.length; r++) {
          const { $from: a, $to: l } = i[r], c2 = e.mapping.slice(o);
          e.replace(
            c2.map(a.pos),
            c2.map(l.pos),
            r ? K.empty : n
          );
        }
        const s = de.findFrom(
          e.doc.resolve(e.mapping.slice(o).map(this.to)),
          -1
        );
        s && e.setSelection(s);
      }
      replaceWith(e, n) {
        this.replace(e, new K(D.from(n), 0, 0));
      }
      forEachCell(e) {
        const n = this.$anchorCell.node(-1), o = ut.get(n), i = this.$anchorCell.start(-1), s = o.cellsInRect(
          o.rectBetween(
            this.$anchorCell.pos - i,
            this.$headCell.pos - i
          )
        );
        for (let r = 0; r < s.length; r++)
          e(n.nodeAt(s[r]), i + s[r]);
      }
      // True if this selection goes all the way from the top to the
      // bottom of the table.
      isColSelection() {
        const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
        if (Math.min(e, n) > 0) return false;
        const o = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(o, i) == this.$headCell.node(-1).childCount;
      }
      // Returns the smallest column selection that covers the given anchor
      // and head cell.
      static colSelection(e, n = e) {
        const o = e.node(-1), i = ut.get(o), s = e.start(-1), r = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
        return r.top <= a.top ? (r.top > 0 && (e = l.resolve(s + i.map[r.left])), a.bottom < i.height && (n = l.resolve(
          s + i.map[i.width * (i.height - 1) + a.right - 1]
        ))) : (a.top > 0 && (n = l.resolve(s + i.map[a.left])), r.bottom < i.height && (e = l.resolve(
          s + i.map[i.width * (i.height - 1) + r.right - 1]
        ))), new io(e, n);
      }
      // True if this selection goes all the way from the left to the
      // right of the table.
      isRowSelection() {
        const e = this.$anchorCell.node(-1), n = ut.get(e), o = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - o), s = n.colCount(this.$headCell.pos - o);
        if (Math.min(i, s) > 0) return false;
        const r = i + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(r, a) == n.width;
      }
      eq(e) {
        return e instanceof io && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
      }
      // Returns the smallest row selection that covers the given anchor
      // and head cell.
      static rowSelection(e, n = e) {
        const o = e.node(-1), i = ut.get(o), s = e.start(-1), r = i.findCell(e.pos - s), a = i.findCell(n.pos - s), l = e.node(0);
        return r.left <= a.left ? (r.left > 0 && (e = l.resolve(
          s + i.map[r.top * i.width]
        )), a.right < i.width && (n = l.resolve(
          s + i.map[i.width * (a.top + 1) - 1]
        ))) : (a.left > 0 && (n = l.resolve(s + i.map[a.top * i.width])), r.right < i.width && (e = l.resolve(
          s + i.map[i.width * (r.top + 1) - 1]
        ))), new io(e, n);
      }
      toJSON() {
        return {
          type: "cell",
          anchor: this.$anchorCell.pos,
          head: this.$headCell.pos
        };
      }
      static fromJSON(e, n) {
        return new io(e.resolve(n.anchor), e.resolve(n.head));
      }
      static create(e, n, o = n) {
        return new io(e.resolve(n), e.resolve(o));
      }
      getBookmark() {
        return new lC(this.$anchorCell.pos, this.$headCell.pos);
      }
    };
    Xe.prototype.visible = false;
    de.jsonID("cell", Xe);
    var lC = class W_ {
      constructor(e, n) {
        this.anchor = e, this.head = n;
      }
      map(e) {
        return new W_(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        const n = e.resolve(this.anchor), o = e.resolve(this.head);
        return n.parent.type.spec.tableRole == "row" && o.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && o.index() < o.parent.childCount && gu(n, o) ? new Xe(n, o) : de.near(o, 1);
      }
    };
    function cC(t2) {
      if (!(t2.selection instanceof Xe)) return null;
      const e = [];
      return t2.selection.forEachCell((n, o) => {
        e.push(
          _t.node(o, o + n.nodeSize, { class: "selectedCell" })
        );
      }), qe.create(t2.doc, e);
    }
    function uC({ $from: t2, $to: e }) {
      if (t2.pos == e.pos || t2.pos < e.pos - 6) return false;
      let n = t2.pos, o = e.pos, i = t2.depth;
      for (; i >= 0 && !(t2.after(i + 1) < t2.end(i)); i--, n++)
        ;
      for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, o--)
        ;
      return n == o && /row|table/.test(t2.node(i).type.spec.tableRole);
    }
    function dC({ $from: t2, $to: e }) {
      let n, o;
      for (let i = t2.depth; i > 0; i--) {
        const s = t2.node(i);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
          n = s;
          break;
        }
      }
      for (let i = e.depth; i > 0; i--) {
        const s = e.node(i);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
          o = s;
          break;
        }
      }
      return n !== o && e.parentOffset === 0;
    }
    function pC(t2, e, n) {
      const o = (e || t2).selection, i = (e || t2).doc;
      let s, r;
      if (o instanceof ie && (r = o.node.type.spec.tableRole)) {
        if (r == "cell" || r == "header_cell")
          s = Xe.create(i, o.from);
        else if (r == "row") {
          const a = i.resolve(o.from + 1);
          s = Xe.rowSelection(a, a);
        } else if (!n) {
          const a = ut.get(o.node), l = o.from + 1, c2 = l + a.map[a.width * a.height - 1];
          s = Xe.create(i, l + 1, c2);
        }
      } else o instanceof re && uC(o) ? s = re.create(i, o.from) : o instanceof re && dC(o) && (s = re.create(i, o.$from.start(), o.$from.end()));
      return s && (e || (e = t2.tr)).setSelection(s), e;
    }
    var mC = new Fe("fix-tables");
    function G_(t2, e, n, o) {
      const i = t2.childCount, s = e.childCount;
      e: for (let r = 0, a = 0; r < s; r++) {
        const l = e.child(r);
        for (let c2 = a, u = Math.min(i, r + 3); c2 < u; c2++)
          if (t2.child(c2) == l) {
            a = c2 + 1, n += l.nodeSize;
            continue e;
          }
        o(l, n), a < i && t2.child(a).sameMarkup(l) ? G_(t2.child(a), l, n + 1, o) : l.nodesBetween(0, l.content.size, o, n + 1), n += l.nodeSize;
      }
    }
    function J_(t2, e) {
      let n;
      const o = (i, s) => {
        i.type.spec.tableRole == "table" && (n = fC(t2, i, s, n));
      };
      return e ? e.doc != t2.doc && G_(e.doc, t2.doc, 0, o) : t2.doc.descendants(o), n;
    }
    function fC(t2, e, n, o) {
      const i = ut.get(e);
      if (!i.problems) return o;
      o || (o = t2.tr);
      const s = [];
      for (let l = 0; l < i.height; l++) s.push(0);
      for (let l = 0; l < i.problems.length; l++) {
        const c2 = i.problems[l];
        if (c2.type == "collision") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          const d = u.attrs;
          for (let p2 = 0; p2 < d.rowspan; p2++) s[c2.row + p2] += c2.n;
          o.setNodeMarkup(
            o.mapping.map(n + 1 + c2.pos),
            null,
            di(d, d.colspan - c2.n, c2.n)
          );
        } else if (c2.type == "missing")
          s[c2.row] += c2.n;
        else if (c2.type == "overlong_rowspan") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          o.setNodeMarkup(o.mapping.map(n + 1 + c2.pos), null, {
            ...u.attrs,
            rowspan: u.attrs.rowspan - c2.n
          });
        } else if (c2.type == "colwidth mismatch") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          o.setNodeMarkup(o.mapping.map(n + 1 + c2.pos), null, {
            ...u.attrs,
            colwidth: c2.colwidth
          });
        } else if (c2.type == "zero_sized") {
          const u = o.mapping.map(n);
          o.delete(u, u + e.nodeSize);
        }
      }
      let r, a;
      for (let l = 0; l < s.length; l++)
        s[l] && (r == null && (r = l), a = l);
      for (let l = 0, c2 = n + 1; l < i.height; l++) {
        const u = e.child(l), d = c2 + u.nodeSize, p2 = s[l];
        if (p2 > 0) {
          let m = "cell";
          u.firstChild && (m = u.firstChild.type.spec.tableRole);
          const f = [];
          for (let h2 = 0; h2 < p2; h2++) {
            const g = Ft(t2.schema)[m].createAndFill();
            g && f.push(g);
          }
          const _ = (l == 0 || r == l - 1) && a == l ? c2 + 1 : d - 1;
          o.insert(o.mapping.map(_), f);
        }
        c2 = d;
      }
      return o.setMeta(mC, { fixTables: true });
    }
    function Qn(t2) {
      const e = t2.selection, n = Ka(t2), o = n.node(-1), i = n.start(-1), s = ut.get(o);
      return { ...e instanceof Xe ? s.rectBetween(
        e.$anchorCell.pos - i,
        e.$headCell.pos - i
      ) : s.findCell(n.pos - i), tableStart: i, map: s, table: o };
    }
    function Y_(t2, { map: e, tableStart: n, table: o }, i) {
      let s = i > 0 ? -1 : 0;
      aC(e, o, i + s) && (s = i == 0 || i == e.width ? null : 0);
      for (let r = 0; r < e.height; r++) {
        const a = r * e.width + i;
        if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
          const l = e.map[a], c2 = o.nodeAt(l);
          t2.setNodeMarkup(
            t2.mapping.map(n + l),
            null,
            K_(c2.attrs, i - e.colCount(l))
          ), r += c2.attrs.rowspan - 1;
        } else {
          const l = s == null ? Ft(o.type.schema).cell : o.nodeAt(e.map[a + s]).type, c2 = e.positionAt(r, i, o);
          t2.insert(t2.mapping.map(n + c2), l.createAndFill());
        }
      }
      return t2;
    }
    function _C(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Y_(t2.tr, n, n.left));
      }
      return true;
    }
    function hC(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(Y_(t2.tr, n, n.right));
      }
      return true;
    }
    function gC(t2, { map: e, table: n, tableStart: o }, i) {
      const s = t2.mapping.maps.length;
      for (let r = 0; r < e.height; ) {
        const a = r * e.width + i, l = e.map[a], c2 = n.nodeAt(l), u = c2.attrs;
        if (i > 0 && e.map[a - 1] == l || i < e.width - 1 && e.map[a + 1] == l)
          t2.setNodeMarkup(
            t2.mapping.slice(s).map(o + l),
            null,
            di(u, i - e.colCount(l))
          );
        else {
          const d = t2.mapping.slice(s).map(o + l);
          t2.delete(d, d + c2.nodeSize);
        }
        r += u.rowspan;
      }
    }
    function vC(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2), o = t2.tr;
        if (n.left == 0 && n.right == n.map.width) return false;
        for (let i = n.right - 1; gC(o, n, i), i != n.left; i--) {
          const s = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
          if (!s)
            throw RangeError("No table found");
          n.table = s, n.map = ut.get(s);
        }
        e(o);
      }
      return true;
    }
    function bC(t2, e, n) {
      var o;
      const i = Ft(e.type.schema).header_cell;
      for (let s = 0; s < t2.width; s++)
        if (((o = e.nodeAt(t2.map[s + n * t2.width])) == null ? void 0 : o.type) != i)
          return false;
      return true;
    }
    function X_(t2, { map: e, tableStart: n, table: o }, i) {
      var s;
      let r = n;
      for (let c2 = 0; c2 < i; c2++) r += o.child(c2).nodeSize;
      const a = [];
      let l = i > 0 ? -1 : 0;
      bC(e, o, i + l) && (l = i == 0 || i == e.height ? null : 0);
      for (let c2 = 0, u = e.width * i; c2 < e.width; c2++, u++)
        if (i > 0 && i < e.height && e.map[u] == e.map[u - e.width]) {
          const d = e.map[u], p2 = o.nodeAt(d).attrs;
          t2.setNodeMarkup(n + d, null, {
            ...p2,
            rowspan: p2.rowspan + 1
          }), c2 += p2.colspan - 1;
        } else {
          const d = l == null ? Ft(o.type.schema).cell : (s = o.nodeAt(e.map[u + l * e.width])) == null ? void 0 : s.type, p2 = d == null ? void 0 : d.createAndFill();
          p2 && a.push(p2);
        }
      return t2.insert(r, Ft(o.type.schema).row.create(null, a)), t2;
    }
    function kC(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(X_(t2.tr, n, n.top));
      }
      return true;
    }
    function yC(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2);
        e(X_(t2.tr, n, n.bottom));
      }
      return true;
    }
    function wC(t2, { map: e, table: n, tableStart: o }, i) {
      let s = 0;
      for (let c2 = 0; c2 < i; c2++) s += n.child(c2).nodeSize;
      const r = s + n.child(i).nodeSize, a = t2.mapping.maps.length;
      t2.delete(s + o, r + o);
      const l = /* @__PURE__ */ new Set();
      for (let c2 = 0, u = i * e.width; c2 < e.width; c2++, u++) {
        const d = e.map[u];
        if (!l.has(d)) {
          if (l.add(d), i > 0 && d == e.map[u - e.width]) {
            const p2 = n.nodeAt(d).attrs;
            t2.setNodeMarkup(t2.mapping.slice(a).map(d + o), null, {
              ...p2,
              rowspan: p2.rowspan - 1
            }), c2 += p2.colspan - 1;
          } else if (i < e.height && d == e.map[u + e.width]) {
            const p2 = n.nodeAt(d), m = p2.attrs, f = p2.type.create(
              { ...m, rowspan: p2.attrs.rowspan - 1 },
              p2.content
            ), _ = e.positionAt(i + 1, c2, n);
            t2.insert(t2.mapping.slice(a).map(o + _), f), c2 += m.colspan - 1;
          }
        }
      }
    }
    function jC(t2, e) {
      if (!$n(t2)) return false;
      if (e) {
        const n = Qn(t2), o = t2.tr;
        if (n.top == 0 && n.bottom == n.map.height) return false;
        for (let i = n.bottom - 1; wC(o, n, i), i != n.top; i--) {
          const s = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
          if (!s)
            throw RangeError("No table found");
          n.table = s, n.map = ut.get(n.table);
        }
        e(o);
      }
      return true;
    }
    function Cp(t2) {
      const e = t2.content;
      return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
    }
    function EC({ width: t2, height: e, map: n }, o) {
      let i = o.top * t2 + o.left, s = i, r = (o.bottom - 1) * t2 + o.left, a = i + (o.right - o.left - 1);
      for (let l = o.top; l < o.bottom; l++) {
        if (o.left > 0 && n[s] == n[s - 1] || o.right < t2 && n[a] == n[a + 1])
          return true;
        s += t2, a += t2;
      }
      for (let l = o.left; l < o.right; l++) {
        if (o.top > 0 && n[i] == n[i - t2] || o.bottom < e && n[r] == n[r + t2])
          return true;
        i++, r++;
      }
      return false;
    }
    function xp(t2, e) {
      const n = t2.selection;
      if (!(n instanceof Xe) || n.$anchorCell.pos == n.$headCell.pos)
        return false;
      const o = Qn(t2), { map: i } = o;
      if (EC(i, o)) return false;
      if (e) {
        const s = t2.tr, r = {};
        let a = D.empty, l, c2;
        for (let u = o.top; u < o.bottom; u++)
          for (let d = o.left; d < o.right; d++) {
            const p2 = i.map[u * i.width + d], m = o.table.nodeAt(p2);
            if (!(r[p2] || !m))
              if (r[p2] = true, l == null)
                l = p2, c2 = m;
              else {
                Cp(m) || (a = a.append(m.content));
                const f = s.mapping.map(p2 + o.tableStart);
                s.delete(f, f + m.nodeSize);
              }
          }
        if (l == null || c2 == null)
          return true;
        if (s.setNodeMarkup(l + o.tableStart, null, {
          ...K_(
            c2.attrs,
            c2.attrs.colspan,
            o.right - o.left - c2.attrs.colspan
          ),
          rowspan: o.bottom - o.top
        }), a.size) {
          const u = l + 1 + c2.content.size, d = Cp(c2) ? l + 1 : u;
          s.replaceWith(d + o.tableStart, u + o.tableStart, a);
        }
        s.setSelection(
          new Xe(s.doc.resolve(l + o.tableStart))
        ), e(s);
      }
      return true;
    }
    function Tp(t2, e) {
      const n = Ft(t2.schema);
      return SC(({ node: o }) => n[o.type.spec.tableRole])(t2, e);
    }
    function SC(t2) {
      return (e, n) => {
        var o;
        const i = e.selection;
        let s, r;
        if (i instanceof Xe) {
          if (i.$anchorCell.pos != i.$headCell.pos) return false;
          s = i.$anchorCell.nodeAfter, r = i.$anchorCell.pos;
        } else {
          if (s = iC(i.$from), !s) return false;
          r = (o = Ki(i.$from)) == null ? void 0 : o.pos;
        }
        if (s == null || r == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
          return false;
        if (n) {
          let a = s.attrs;
          const l = [], c2 = a.colwidth;
          a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
          const u = Qn(e), d = e.tr;
          for (let m = 0; m < u.right - u.left; m++)
            l.push(
              c2 ? {
                ...a,
                colwidth: c2 && c2[m] ? [c2[m]] : null
              } : a
            );
          let p2;
          for (let m = u.top; m < u.bottom; m++) {
            let f = u.map.positionAt(m, u.left, u.table);
            m == u.top && (f += s.nodeSize);
            for (let _ = u.left, h2 = 0; _ < u.right; _++, h2++)
              _ == u.left && m == u.top || d.insert(
                p2 = d.mapping.map(f + u.tableStart, 1),
                t2({ node: s, row: m, col: _ }).createAndFill(l[h2])
              );
          }
          d.setNodeMarkup(
            r,
            t2({ node: s, row: u.top, col: u.left }),
            l[0]
          ), i instanceof Xe && d.setSelection(
            new Xe(
              d.doc.resolve(i.$anchorCell.pos),
              p2 ? d.doc.resolve(p2) : void 0
            )
          ), n(d);
        }
        return true;
      };
    }
    function CC(t2, e) {
      return function(n, o) {
        if (!$n(n)) return false;
        const i = Ka(n);
        if (i.nodeAfter.attrs[t2] === e) return false;
        if (o) {
          const s = n.tr;
          n.selection instanceof Xe ? n.selection.forEachCell((r, a) => {
            r.attrs[t2] !== e && s.setNodeMarkup(a, null, {
              ...r.attrs,
              [t2]: e
            });
          }) : s.setNodeMarkup(i.pos, null, {
            ...i.nodeAfter.attrs,
            [t2]: e
          }), o(s);
        }
        return true;
      };
    }
    function xC(t2) {
      return function(e, n) {
        if (!$n(e)) return false;
        if (n) {
          const o = Ft(e.schema), i = Qn(e), s = e.tr, r = i.map.cellsInRect(
            t2 == "column" ? {
              left: i.left,
              top: 0,
              right: i.right,
              bottom: i.map.height
            } : t2 == "row" ? {
              left: 0,
              top: i.top,
              right: i.map.width,
              bottom: i.bottom
            } : i
          ), a = r.map((l) => i.table.nodeAt(l));
          for (let l = 0; l < r.length; l++)
            a[l].type == o.header_cell && s.setNodeMarkup(
              i.tableStart + r[l],
              o.cell,
              a[l].attrs
            );
          if (s.steps.length == 0)
            for (let l = 0; l < r.length; l++)
              s.setNodeMarkup(
                i.tableStart + r[l],
                o.header_cell,
                a[l].attrs
              );
          n(s);
        }
        return true;
      };
    }
    function Op(t2, e, n) {
      const o = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: t2 == "row" ? e.map.width : 1,
        bottom: t2 == "column" ? e.map.height : 1
      });
      for (let i = 0; i < o.length; i++) {
        const s = e.table.nodeAt(o[i]);
        if (s && s.type !== n.header_cell)
          return false;
      }
      return true;
    }
    function Is(t2, e) {
      return e = e || { useDeprecatedLogic: false }, e.useDeprecatedLogic ? xC(t2) : function(n, o) {
        if (!$n(n)) return false;
        if (o) {
          const i = Ft(n.schema), s = Qn(n), r = n.tr, a = Op("row", s, i), l = Op(
            "column",
            s,
            i
          ), u = (t2 === "column" ? a : t2 === "row" ? l : false) ? 1 : 0, d = t2 == "column" ? {
            left: 0,
            top: u,
            right: 1,
            bottom: s.map.height
          } : t2 == "row" ? {
            left: u,
            top: 0,
            right: s.map.width,
            bottom: 1
          } : s, p2 = t2 == "column" ? l ? i.cell : i.header_cell : t2 == "row" ? a ? i.cell : i.header_cell : i.cell;
          s.map.cellsInRect(d).forEach((m) => {
            const f = m + s.tableStart, _ = r.doc.nodeAt(f);
            _ && r.setNodeMarkup(f, p2, _.attrs);
          }), o(r);
        }
        return true;
      };
    }
    Is("row", {
      useDeprecatedLogic: true
    });
    Is("column", {
      useDeprecatedLogic: true
    });
    var TC = Is("cell", {
      useDeprecatedLogic: true
    });
    function OC(t2, e) {
      if (e < 0) {
        const n = t2.nodeBefore;
        if (n) return t2.pos - n.nodeSize;
        for (let o = t2.index(-1) - 1, i = t2.before(); o >= 0; o--) {
          const s = t2.node(-1).child(o), r = s.lastChild;
          if (r)
            return i - 1 - r.nodeSize;
          i -= s.nodeSize;
        }
      } else {
        if (t2.index() < t2.parent.childCount - 1)
          return t2.pos + t2.nodeAfter.nodeSize;
        const n = t2.node(-1);
        for (let o = t2.indexAfter(-1), i = t2.after(); o < n.childCount; o++) {
          const s = n.child(o);
          if (s.childCount) return i + 1;
          i += s.nodeSize;
        }
      }
      return null;
    }
    function Np(t2) {
      return function(e, n) {
        if (!$n(e)) return false;
        const o = OC(Ka(e), t2);
        if (o == null) return false;
        if (n) {
          const i = e.doc.resolve(o);
          n(
            e.tr.setSelection(re.between(i, rC(i))).scrollIntoView()
          );
        }
        return true;
      };
    }
    function NC(t2, e) {
      const n = t2.selection.$anchor;
      for (let o = n.depth; o > 0; o--)
        if (n.node(o).type.spec.tableRole == "table")
          return e && e(
            t2.tr.delete(n.before(o), n.after(o)).scrollIntoView()
          ), true;
      return false;
    }
    function lr(t2, e) {
      const n = t2.selection;
      if (!(n instanceof Xe)) return false;
      if (e) {
        const o = t2.tr, i = Ft(t2.schema).cell.createAndFill().content;
        n.forEachCell((s, r) => {
          s.content.eq(i) || o.replace(
            o.mapping.map(r + 1),
            o.mapping.map(r + s.nodeSize - 1),
            new K(i, 0, 0)
          );
        }), o.docChanged && e(o);
      }
      return true;
    }
    function AC(t2) {
      if (!t2.size) return null;
      let { content: e, openStart: n, openEnd: o } = t2;
      for (; e.childCount == 1 && (n > 0 && o > 0 || e.child(0).type.spec.tableRole == "table"); )
        n--, o--, e = e.child(0).content;
      const i = e.child(0), s = i.type.spec.tableRole, r = i.type.schema, a = [];
      if (s == "row")
        for (let l = 0; l < e.childCount; l++) {
          let c2 = e.child(l).content;
          const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, o - 1);
          (u || d) && (c2 = _c(
            Ft(r).row,
            new K(c2, u, d)
          ).content), a.push(c2);
        }
      else if (s == "cell" || s == "header_cell")
        a.push(
          n || o ? _c(
            Ft(r).row,
            new K(e, n, o)
          ).content : e
        );
      else
        return null;
      return MC(r, a);
    }
    function MC(t2, e) {
      const n = [];
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        for (let r = s.childCount - 1; r >= 0; r--) {
          const { rowspan: a, colspan: l } = s.child(r).attrs;
          for (let c2 = i; c2 < i + a; c2++)
            n[c2] = (n[c2] || 0) + l;
        }
      }
      let o = 0;
      for (let i = 0; i < n.length; i++) o = Math.max(o, n[i]);
      for (let i = 0; i < n.length; i++)
        if (i >= e.length && e.push(D.empty), n[i] < o) {
          const s = Ft(t2).cell.createAndFill(), r = [];
          for (let a = n[i]; a < o; a++)
            r.push(s);
          e[i] = e[i].append(D.from(r));
        }
      return { height: e.length, width: o, rows: e };
    }
    function _c(t2, e) {
      const n = t2.createAndFill();
      return new Oc(n).replace(0, n.content.size, e).doc;
    }
    function RC({ width: t2, height: e, rows: n }, o, i) {
      if (t2 != o) {
        const s = [], r = [];
        for (let a = 0; a < n.length; a++) {
          const l = n[a], c2 = [];
          for (let u = s[a] || 0, d = 0; u < o; d++) {
            let p2 = l.child(d % l.childCount);
            u + p2.attrs.colspan > o && (p2 = p2.type.createChecked(
              di(
                p2.attrs,
                p2.attrs.colspan,
                u + p2.attrs.colspan - o
              ),
              p2.content
            )), c2.push(p2), u += p2.attrs.colspan;
            for (let m = 1; m < p2.attrs.rowspan; m++)
              s[a + m] = (s[a + m] || 0) + p2.attrs.colspan;
          }
          r.push(D.from(c2));
        }
        n = r, t2 = o;
      }
      if (e != i) {
        const s = [];
        for (let r = 0, a = 0; r < i; r++, a++) {
          const l = [], c2 = n[a % e];
          for (let u = 0; u < c2.childCount; u++) {
            let d = c2.child(u);
            r + d.attrs.rowspan > i && (d = d.type.create(
              {
                ...d.attrs,
                rowspan: Math.max(1, i - d.attrs.rowspan)
              },
              d.content
            )), l.push(d);
          }
          s.push(D.from(l));
        }
        n = s, e = i;
      }
      return { width: t2, height: e, rows: n };
    }
    function IC(t2, e, n, o, i, s, r) {
      const a = t2.doc.type.schema, l = Ft(a);
      let c2, u;
      if (i > e.width)
        for (let d = 0, p2 = 0; d < e.height; d++) {
          const m = n.child(d);
          p2 += m.nodeSize;
          const f = [];
          let _;
          m.lastChild == null || m.lastChild.type == l.cell ? _ = c2 || (c2 = l.cell.createAndFill()) : _ = u || (u = l.header_cell.createAndFill());
          for (let h2 = e.width; h2 < i; h2++) f.push(_);
          t2.insert(t2.mapping.slice(r).map(p2 - 1 + o), f);
        }
      if (s > e.height) {
        const d = [];
        for (let f = 0, _ = (e.height - 1) * e.width; f < Math.max(e.width, i); f++) {
          const h2 = f >= e.width ? false : n.nodeAt(e.map[_ + f]).type == l.header_cell;
          d.push(
            h2 ? u || (u = l.header_cell.createAndFill()) : c2 || (c2 = l.cell.createAndFill())
          );
        }
        const p2 = l.row.create(null, D.from(d)), m = [];
        for (let f = e.height; f < s; f++) m.push(p2);
        t2.insert(t2.mapping.slice(r).map(o + n.nodeSize - 2), m);
      }
      return !!(c2 || u);
    }
    function Ap(t2, e, n, o, i, s, r, a) {
      if (r == 0 || r == e.height) return false;
      let l = false;
      for (let c2 = i; c2 < s; c2++) {
        const u = r * e.width + c2, d = e.map[u];
        if (e.map[u - e.width] == d) {
          l = true;
          const p2 = n.nodeAt(d), { top: m, left: f } = e.findCell(d);
          t2.setNodeMarkup(t2.mapping.slice(a).map(d + o), null, {
            ...p2.attrs,
            rowspan: r - m
          }), t2.insert(
            t2.mapping.slice(a).map(e.positionAt(r, f, n)),
            p2.type.createAndFill({
              ...p2.attrs,
              rowspan: m + p2.attrs.rowspan - r
            })
          ), c2 += p2.attrs.colspan - 1;
        }
      }
      return l;
    }
    function Mp(t2, e, n, o, i, s, r, a) {
      if (r == 0 || r == e.width) return false;
      let l = false;
      for (let c2 = i; c2 < s; c2++) {
        const u = c2 * e.width + r, d = e.map[u];
        if (e.map[u - 1] == d) {
          l = true;
          const p2 = n.nodeAt(d), m = e.colCount(d), f = t2.mapping.slice(a).map(d + o);
          t2.setNodeMarkup(
            f,
            null,
            di(
              p2.attrs,
              r - m,
              p2.attrs.colspan - (r - m)
            )
          ), t2.insert(
            f + p2.nodeSize,
            p2.type.createAndFill(
              di(p2.attrs, 0, r - m)
            )
          ), c2 += p2.attrs.rowspan - 1;
        }
      }
      return l;
    }
    function Rp(t2, e, n, o, i) {
      let s = n ? t2.doc.nodeAt(n - 1) : t2.doc;
      if (!s)
        throw new Error("No table found");
      let r = ut.get(s);
      const { top: a, left: l } = o, c2 = l + i.width, u = a + i.height, d = t2.tr;
      let p2 = 0;
      function m() {
        if (s = n ? d.doc.nodeAt(n - 1) : d.doc, !s)
          throw new Error("No table found");
        r = ut.get(s), p2 = d.mapping.maps.length;
      }
      IC(d, r, s, n, c2, u, p2) && m(), Ap(d, r, s, n, l, c2, a, p2) && m(), Ap(d, r, s, n, l, c2, u, p2) && m(), Mp(d, r, s, n, a, u, l, p2) && m(), Mp(d, r, s, n, a, u, c2, p2) && m();
      for (let f = a; f < u; f++) {
        const _ = r.positionAt(f, l, s), h2 = r.positionAt(f, c2, s);
        d.replace(
          d.mapping.slice(p2).map(_ + n),
          d.mapping.slice(p2).map(h2 + n),
          new K(i.rows[f - a], 0, 0)
        );
      }
      m(), d.setSelection(
        new Xe(
          d.doc.resolve(n + r.positionAt(a, l, s)),
          d.doc.resolve(n + r.positionAt(u - 1, c2 - 1, s))
        )
      ), e(d);
    }
    var DC = zc({
      ArrowLeft: cr("horiz", -1),
      ArrowRight: cr("horiz", 1),
      ArrowUp: cr("vert", -1),
      ArrowDown: cr("vert", 1),
      "Shift-ArrowLeft": ur("horiz", -1),
      "Shift-ArrowRight": ur("horiz", 1),
      "Shift-ArrowUp": ur("vert", -1),
      "Shift-ArrowDown": ur("vert", 1),
      Backspace: lr,
      "Mod-Backspace": lr,
      Delete: lr,
      "Mod-Delete": lr
    });
    function Nr(t2, e, n) {
      return n.eq(t2.selection) ? false : (e && e(t2.tr.setSelection(n).scrollIntoView()), true);
    }
    function cr(t2, e) {
      return (n, o, i) => {
        if (!i) return false;
        const s = n.selection;
        if (s instanceof Xe)
          return Nr(
            n,
            o,
            de.near(s.$headCell, e)
          );
        if (t2 != "horiz" && !s.empty) return false;
        const r = Z_(i, t2, e);
        if (r == null) return false;
        if (t2 == "horiz")
          return Nr(
            n,
            o,
            de.near(n.doc.resolve(s.head + e), e)
          );
        {
          const a = n.doc.resolve(r), l = q_(a, t2, e);
          let c2;
          return l ? c2 = de.near(l, 1) : e < 0 ? c2 = de.near(n.doc.resolve(a.before(-1)), -1) : c2 = de.near(n.doc.resolve(a.after(-1)), 1), Nr(n, o, c2);
        }
      };
    }
    function ur(t2, e) {
      return (n, o, i) => {
        if (!i) return false;
        const s = n.selection;
        let r;
        if (s instanceof Xe)
          r = s;
        else {
          const l = Z_(i, t2, e);
          if (l == null) return false;
          r = new Xe(n.doc.resolve(l));
        }
        const a = q_(r.$headCell, t2, e);
        return a ? Nr(
          n,
          o,
          new Xe(r.$anchorCell, a)
        ) : false;
      };
    }
    function LC(t2, e) {
      const n = t2.state.doc, o = Ki(n.resolve(e));
      return o ? (t2.dispatch(t2.state.tr.setSelection(new Xe(o))), true) : false;
    }
    function PC(t2, e, n) {
      if (!$n(t2.state)) return false;
      let o = AC(n);
      const i = t2.state.selection;
      if (i instanceof Xe) {
        o || (o = {
          width: 1,
          height: 1,
          rows: [
            D.from(
              _c(Ft(t2.state.schema).cell, n)
            )
          ]
        });
        const s = i.$anchorCell.node(-1), r = i.$anchorCell.start(-1), a = ut.get(s).rectBetween(
          i.$anchorCell.pos - r,
          i.$headCell.pos - r
        );
        return o = RC(o, a.right - a.left, a.bottom - a.top), Rp(t2.state, t2.dispatch, r, a, o), true;
      } else if (o) {
        const s = Ka(t2.state), r = s.start(-1);
        return Rp(
          t2.state,
          t2.dispatch,
          r,
          ut.get(s.node(-1)).findCell(s.pos - r),
          o
        ), true;
      } else
        return false;
    }
    function BC(t2, e) {
      var n;
      if (e.ctrlKey || e.metaKey) return;
      const o = Ip(t2, e.target);
      let i;
      if (e.shiftKey && t2.state.selection instanceof Xe)
        s(t2.state.selection.$anchorCell, e), e.preventDefault();
      else if (e.shiftKey && o && (i = Ki(t2.state.selection.$anchor)) != null && ((n = Cl(t2, e)) == null ? void 0 : n.pos) != i.pos)
        s(i, e), e.preventDefault();
      else if (!o)
        return;
      function s(l, c2) {
        let u = Cl(t2, c2);
        const d = Co.getState(t2.state) == null;
        if (!u || !gu(l, u))
          if (d) u = l;
          else return;
        const p2 = new Xe(l, u);
        if (d || !t2.state.selection.eq(p2)) {
          const m = t2.state.tr.setSelection(p2);
          d && m.setMeta(Co, l.pos), t2.dispatch(m);
        }
      }
      function r() {
        t2.root.removeEventListener("mouseup", r), t2.root.removeEventListener("dragstart", r), t2.root.removeEventListener("mousemove", a), Co.getState(t2.state) != null && t2.dispatch(t2.state.tr.setMeta(Co, -1));
      }
      function a(l) {
        const c2 = l, u = Co.getState(t2.state);
        let d;
        if (u != null)
          d = t2.state.doc.resolve(u);
        else if (Ip(t2, c2.target) != o && (d = Cl(t2, e), !d))
          return r();
        d && s(d, c2);
      }
      t2.root.addEventListener("mouseup", r), t2.root.addEventListener("dragstart", r), t2.root.addEventListener("mousemove", a);
    }
    function Z_(t2, e, n) {
      if (!(t2.state.selection instanceof re)) return null;
      const { $head: o } = t2.state.selection;
      for (let i = o.depth - 1; i >= 0; i--) {
        const s = o.node(i);
        if ((n < 0 ? o.index(i) : o.indexAfter(i)) != (n < 0 ? 0 : s.childCount)) return null;
        if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
          const a = o.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
          return t2.endOfTextblock(l) ? a : null;
        }
      }
      return null;
    }
    function Ip(t2, e) {
      for (; e && e != t2.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
          return e;
      return null;
    }
    function Cl(t2, e) {
      const n = t2.posAtCoords({
        left: e.clientX,
        top: e.clientY
      });
      return n && n ? Ki(t2.state.doc.resolve(n.pos)) : null;
    }
    var $C = class {
      constructor(e, n) {
        this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
          "--default-cell-min-width",
          `${n}px`
        ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), hc(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type != this.node.type ? false : (this.node = e, hc(
          e,
          this.colgroup,
          this.table,
          this.defaultCellMinWidth
        ), true);
      }
      ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
      }
    };
    function hc(t2, e, n, o, i, s) {
      var r;
      let a = 0, l = true, c2 = e.firstChild;
      const u = t2.firstChild;
      if (u) {
        for (let d = 0, p2 = 0; d < u.childCount; d++) {
          const { colspan: m, colwidth: f } = u.child(d).attrs;
          for (let _ = 0; _ < m; _++, p2++) {
            const h2 = i == p2 ? s : f && f[_], g = h2 ? h2 + "px" : "";
            if (a += h2 || o, h2 || (l = false), c2)
              c2.style.width != g && (c2.style.width = g), c2 = c2.nextSibling;
            else {
              const k = document.createElement("col");
              k.style.width = g, e.appendChild(k);
            }
          }
        }
        for (; c2; ) {
          const d = c2.nextSibling;
          (r = c2.parentNode) == null || r.removeChild(c2), c2 = d;
        }
        l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
      }
    }
    var dn = new Fe(
      "tableColumnResizing"
    );
    function zC({
      handleWidth: t2 = 5,
      cellMinWidth: e = 25,
      defaultCellMinWidth: n = 100,
      View: o = $C,
      lastColumnResizable: i = true
    } = {}) {
      const s = new ze({
        key: dn,
        state: {
          init(r, a) {
            var l, c2;
            const u = (c2 = (l = s.spec) == null ? void 0 : l.props) == null ? void 0 : c2.nodeViews, d = Ft(a.schema).table.name;
            return o && u && (u[d] = (p2, m) => new o(p2, n, m)), new FC(-1, false);
          },
          apply(r, a) {
            return a.apply(r);
          }
        },
        props: {
          attributes: (r) => {
            const a = dn.getState(r);
            return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
          },
          handleDOMEvents: {
            mousemove: (r, a) => {
              HC(r, a, t2, i);
            },
            mouseleave: (r) => {
              UC(r);
            },
            mousedown: (r, a) => {
              VC(r, a, e, n);
            }
          },
          decorations: (r) => {
            const a = dn.getState(r);
            if (a && a.activeHandle > -1)
              return JC(r, a.activeHandle);
          },
          nodeViews: {}
        }
      });
      return s;
    }
    var FC = class Ar {
      constructor(e, n) {
        this.activeHandle = e, this.dragging = n;
      }
      apply(e) {
        const n = this, o = e.getMeta(dn);
        if (o && o.setHandle != null)
          return new Ar(o.setHandle, false);
        if (o && o.setDragging !== void 0)
          return new Ar(n.activeHandle, o.setDragging);
        if (n.activeHandle > -1 && e.docChanged) {
          let i = e.mapping.map(n.activeHandle, -1);
          return fc(e.doc.resolve(i)) || (i = -1), new Ar(i, n.dragging);
        }
        return n;
      }
    };
    function HC(t2, e, n, o) {
      if (!t2.editable) return;
      const i = dn.getState(t2.state);
      if (i && !i.dragging) {
        const s = KC(e.target);
        let r = -1;
        if (s) {
          const { left: a, right: l } = s.getBoundingClientRect();
          e.clientX - a <= n ? r = Dp(t2, e, "left", n) : l - e.clientX <= n && (r = Dp(t2, e, "right", n));
        }
        if (r != i.activeHandle) {
          if (!o && r !== -1) {
            const a = t2.state.doc.resolve(r), l = a.node(-1), c2 = ut.get(l), u = a.start(-1);
            if (c2.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c2.width - 1)
              return;
          }
          Q_(t2, r);
        }
      }
    }
    function UC(t2) {
      if (!t2.editable) return;
      const e = dn.getState(t2.state);
      e && e.activeHandle > -1 && !e.dragging && Q_(t2, -1);
    }
    function VC(t2, e, n, o) {
      var i;
      if (!t2.editable) return false;
      const s = (i = t2.dom.ownerDocument.defaultView) != null ? i : window, r = dn.getState(t2.state);
      if (!r || r.activeHandle == -1 || r.dragging)
        return false;
      const a = t2.state.doc.nodeAt(r.activeHandle), l = qC(t2, r.activeHandle, a.attrs);
      t2.dispatch(
        t2.state.tr.setMeta(dn, {
          setDragging: { startX: e.clientX, startWidth: l }
        })
      );
      function c2(d) {
        s.removeEventListener("mouseup", c2), s.removeEventListener("mousemove", u);
        const p2 = dn.getState(t2.state);
        p2 != null && p2.dragging && (WC(
          t2,
          p2.activeHandle,
          Lp(p2.dragging, d, n)
        ), t2.dispatch(
          t2.state.tr.setMeta(dn, { setDragging: null })
        ));
      }
      function u(d) {
        if (!d.which) return c2(d);
        const p2 = dn.getState(t2.state);
        if (p2 && p2.dragging) {
          const m = Lp(p2.dragging, d, n);
          Pp(
            t2,
            p2.activeHandle,
            m,
            o
          );
        }
      }
      return Pp(
        t2,
        r.activeHandle,
        l,
        o
      ), s.addEventListener("mouseup", c2), s.addEventListener("mousemove", u), e.preventDefault(), true;
    }
    function qC(t2, e, { colspan: n, colwidth: o }) {
      const i = o && o[o.length - 1];
      if (i) return i;
      const s = t2.domAtPos(e);
      let a = s.node.childNodes[s.offset].offsetWidth, l = n;
      if (o)
        for (let c2 = 0; c2 < n; c2++)
          o[c2] && (a -= o[c2], l--);
      return a / l;
    }
    function KC(t2) {
      for (; t2 && t2.nodeName != "TD" && t2.nodeName != "TH"; )
        t2 = t2.classList && t2.classList.contains("ProseMirror") ? null : t2.parentNode;
      return t2;
    }
    function Dp(t2, e, n, o) {
      const i = n == "right" ? -o : o, s = t2.posAtCoords({
        left: e.clientX + i,
        top: e.clientY
      });
      if (!s) return -1;
      const { pos: r } = s, a = Ki(t2.state.doc.resolve(r));
      if (!a) return -1;
      if (n == "right") return a.pos;
      const l = ut.get(a.node(-1)), c2 = a.start(-1), u = l.map.indexOf(a.pos - c2);
      return u % l.width == 0 ? -1 : c2 + l.map[u - 1];
    }
    function Lp(t2, e, n) {
      const o = e.clientX - t2.startX;
      return Math.max(n, t2.startWidth + o);
    }
    function Q_(t2, e) {
      t2.dispatch(
        t2.state.tr.setMeta(dn, { setHandle: e })
      );
    }
    function WC(t2, e, n) {
      const o = t2.state.doc.resolve(e), i = o.node(-1), s = ut.get(i), r = o.start(-1), a = s.colCount(o.pos - r) + o.nodeAfter.attrs.colspan - 1, l = t2.state.tr;
      for (let c2 = 0; c2 < s.height; c2++) {
        const u = c2 * s.width + a;
        if (c2 && s.map[u] == s.map[u - s.width]) continue;
        const d = s.map[u], p2 = i.nodeAt(d).attrs, m = p2.colspan == 1 ? 0 : a - s.colCount(d);
        if (p2.colwidth && p2.colwidth[m] == n) continue;
        const f = p2.colwidth ? p2.colwidth.slice() : GC(p2.colspan);
        f[m] = n, l.setNodeMarkup(r + d, null, { ...p2, colwidth: f });
      }
      l.docChanged && t2.dispatch(l);
    }
    function Pp(t2, e, n, o) {
      const i = t2.state.doc.resolve(e), s = i.node(-1), r = i.start(-1), a = ut.get(s).colCount(i.pos - r) + i.nodeAfter.attrs.colspan - 1;
      let l = t2.domAtPos(i.start(-1)).node;
      for (; l && l.nodeName != "TABLE"; )
        l = l.parentNode;
      l && hc(
        s,
        l.firstChild,
        l,
        o,
        a,
        n
      );
    }
    function GC(t2) {
      return Array(t2).fill(0);
    }
    function JC(t2, e) {
      var n;
      const o = [], i = t2.doc.resolve(e), s = i.node(-1);
      if (!s)
        return qe.empty;
      const r = ut.get(s), a = i.start(-1), l = r.colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
      for (let c2 = 0; c2 < r.height; c2++) {
        const u = l + c2 * r.width;
        if ((l == r.width - 1 || r.map[u] != r.map[u + 1]) && (c2 == 0 || r.map[u] != r.map[u - r.width])) {
          const d = r.map[u], p2 = a + d + s.nodeAt(d).nodeSize - 1, m = document.createElement("div");
          m.className = "column-resize-handle", (n = dn.getState(t2)) != null && n.dragging && o.push(
            _t.node(
              a + d,
              a + d + s.nodeAt(d).nodeSize,
              {
                class: "column-resize-dragging"
              }
            )
          ), o.push(_t.widget(p2, m));
        }
      }
      return qe.create(t2.doc, o);
    }
    function YC({
      allowTableNodeSelection: t2 = false
    } = {}) {
      return new ze({
        key: Co,
        // This piece of state is used to remember when a mouse-drag
        // cell-selection is happening, so that it can continue even as
        // transactions (which might move its anchor cell) come in.
        state: {
          init() {
            return null;
          },
          apply(e, n) {
            const o = e.getMeta(Co);
            if (o != null) return o == -1 ? null : o;
            if (n == null || !e.docChanged) return n;
            const { deleted: i, pos: s } = e.mapping.mapResult(n);
            return i ? null : s;
          }
        },
        props: {
          decorations: cC,
          handleDOMEvents: {
            mousedown: BC
          },
          createSelectionBetween(e) {
            return Co.getState(e.state) != null ? e.state.selection : null;
          },
          handleTripleClick: LC,
          handleKeyDown: DC,
          handlePaste: PC
        },
        appendTransaction(e, n, o) {
          return pC(
            o,
            J_(o, n),
            t2
          );
        }
      });
    }
    function gc(t2, e) {
      return e ? ["width", `${Math.max(e, t2)}px`] : ["min-width", `${t2}px`];
    }
    function Bp(t2, e, n, o, i, s) {
      var r;
      let a = 0, l = true, c2 = e.firstChild;
      const u = t2.firstChild;
      if (u !== null)
        for (let d = 0, p2 = 0; d < u.childCount; d += 1) {
          const { colspan: m, colwidth: f } = u.child(d).attrs;
          for (let _ = 0; _ < m; _ += 1, p2 += 1) {
            const h2 = i === p2 ? s : f && f[_], g = h2 ? `${h2}px` : "";
            if (a += h2 || o, h2 || (l = false), c2) {
              if (c2.style.width !== g) {
                const [k, j] = gc(o, h2);
                c2.style.setProperty(k, j);
              }
              c2 = c2.nextSibling;
            } else {
              const k = document.createElement("col"), [j, v] = gc(o, h2);
              k.style.setProperty(j, v), e.appendChild(k);
            }
          }
        }
      for (; c2; ) {
        const d = c2.nextSibling;
        (r = c2.parentNode) === null || r === void 0 || r.removeChild(c2), c2 = d;
      }
      l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
    }
    class XC {
      constructor(e, n) {
        this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Bp(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, Bp(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    function ZC(t2, e, n, o) {
      let i = 0, s = true;
      const r = [], a = t2.firstChild;
      if (!a)
        return {};
      for (let d = 0, p2 = 0; d < a.childCount; d += 1) {
        const { colspan: m, colwidth: f } = a.child(d).attrs;
        for (let _ = 0; _ < m; _ += 1, p2 += 1) {
          const h2 = n === p2 ? o : f && f[_];
          i += h2 || e, h2 || (s = false);
          const [g, k] = gc(e, h2);
          r.push([
            "col",
            { style: `${g}: ${k}` }
          ]);
        }
      }
      const l = s ? `${i}px` : "", c2 = s ? "" : `${i}px`;
      return { colgroup: ["colgroup", {}, ...r], tableWidth: l, tableMinWidth: c2 };
    }
    function $p(t2, e) {
      return t2.createAndFill();
    }
    function QC(t2) {
      if (t2.cached.tableNodeTypes)
        return t2.cached.tableNodeTypes;
      const e = {};
      return Object.keys(t2.nodes).forEach((n) => {
        const o = t2.nodes[n];
        o.spec.tableRole && (e[o.spec.tableRole] = o);
      }), t2.cached.tableNodeTypes = e, e;
    }
    function eh(t2, e, n, o, i) {
      const s = QC(t2), r = [], a = [];
      for (let c2 = 0; c2 < n; c2 += 1) {
        const u = $p(s.cell);
        if (u && a.push(u), o) {
          const d = $p(s.header_cell);
          d && r.push(d);
        }
      }
      const l = [];
      for (let c2 = 0; c2 < e; c2 += 1)
        l.push(s.row.createChecked(null, o && c2 === 0 ? r : a));
      return s.table.createChecked(null, l);
    }
    function ex(t2) {
      return t2 instanceof Xe;
    }
    const dr = ({ editor: t2 }) => {
      const { selection: e } = t2.state;
      if (!ex(e))
        return false;
      let n = 0;
      const o = Jf(e.ranges[0].$from, (s) => s.type.name === "table");
      return o == null || o.node.descendants((s) => {
        if (s.type.name === "table")
          return false;
        ["tableCell", "tableHeader"].includes(s.type.name) && (n += 1);
      }), n === e.ranges.length ? (t2.commands.deleteTable(), true) : false;
    }, th = it.create({
      name: "table",
      // @ts-ignore
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: false,
          handleWidth: 5,
          cellMinWidth: 25,
          // TODO: fix
          View: XC,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      content: "tableRow+",
      tableRole: "table",
      isolating: true,
      group: "block",
      parseHTML() {
        return [{ tag: "table" }];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        const { colgroup: n, tableWidth: o, tableMinWidth: i } = ZC(t2, this.options.cellMinWidth);
        return [
          "table",
          Pe(this.options.HTMLAttributes, e, {
            style: o ? `width: ${o}` : `min-width: ${i}`
          }),
          n,
          ["tbody", 0]
        ];
      },
      addCommands() {
        return {
          insertTable: ({ rows: t2 = 3, cols: e = 3, withHeaderRow: n = true } = {}) => ({ tr: o, dispatch: i, editor: s }) => {
            const r = eh(s.schema, t2, e, n);
            if (i) {
              const a = o.selection.from + 1;
              o.replaceSelectionWith(r).scrollIntoView().setSelection(re.near(o.doc.resolve(a)));
            }
            return true;
          },
          addColumnBefore: () => ({ state: t2, dispatch: e }) => _C(t2, e),
          addColumnAfter: () => ({ state: t2, dispatch: e }) => hC(t2, e),
          deleteColumn: () => ({ state: t2, dispatch: e }) => vC(t2, e),
          addRowBefore: () => ({ state: t2, dispatch: e }) => kC(t2, e),
          addRowAfter: () => ({ state: t2, dispatch: e }) => yC(t2, e),
          deleteRow: () => ({ state: t2, dispatch: e }) => jC(t2, e),
          deleteTable: () => ({ state: t2, dispatch: e }) => NC(t2, e),
          mergeCells: () => ({ state: t2, dispatch: e }) => xp(t2, e),
          splitCell: () => ({ state: t2, dispatch: e }) => Tp(t2, e),
          toggleHeaderColumn: () => ({ state: t2, dispatch: e }) => Is("column")(t2, e),
          toggleHeaderRow: () => ({ state: t2, dispatch: e }) => Is("row")(t2, e),
          toggleHeaderCell: () => ({ state: t2, dispatch: e }) => TC(t2, e),
          mergeOrSplit: () => ({ state: t2, dispatch: e }) => xp(t2, e) ? true : Tp(t2, e),
          setCellAttribute: (t2, e) => ({ state: n, dispatch: o }) => CC(t2, e)(n, o),
          goToNextCell: () => ({ state: t2, dispatch: e }) => Np(1)(t2, e),
          goToPreviousCell: () => ({ state: t2, dispatch: e }) => Np(-1)(t2, e),
          fixTables: () => ({ state: t2, dispatch: e }) => (e && J_(t2), true),
          setCellSelection: (t2) => ({ tr: e, dispatch: n }) => {
            if (n) {
              const o = Xe.create(e.doc, t2.anchorCell, t2.headCell);
              e.setSelection(o);
            }
            return true;
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          Tab: () => this.editor.commands.goToNextCell() ? true : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : false,
          "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
          Backspace: dr,
          "Mod-Backspace": dr,
          Delete: dr,
          "Mod-Delete": dr
        };
      },
      addProseMirrorPlugins() {
        return [
          ...this.options.resizable && this.editor.isEditable ? [
            zC({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              View: this.options.View,
              lastColumnResizable: this.options.lastColumnResizable
            })
          ] : [],
          YC({
            allowTableNodeSelection: this.options.allowTableNodeSelection
          })
        ];
      },
      extendNodeSchema(t2) {
        const e = {
          name: t2.name,
          options: t2.options,
          storage: t2.storage
        };
        return {
          tableRole: Te(Z(t2, "tableRole", e))
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function zp(t2, e, n, o, i, s) {
      let r = 0, a = true, l = e.firstChild;
      const c2 = t2.firstChild;
      for (let u = 0, d = 0; u < c2.childCount; u += 1) {
        const { colspan: p2, colwidth: m } = c2.child(u).attrs;
        for (let f = 0; f < p2; f += 1, d += 1) {
          const _ = i === d ? s : m && m[f], h2 = _ ? `${_}px` : "";
          if (r += _ || o, _ || (a = false), l)
            l.style.width !== h2 && (l.style.width = h2), l = l.nextSibling;
          else {
            const g = document.createElement("col");
            g.className = `col-${d}`, e.appendChild(g).style.width = h2;
          }
        }
      }
      for (; l; ) {
        const u = l.nextSibling;
        l.parentNode.removeChild(l), l = u;
      }
      a ? (n.style.width = `${r}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${r}px`);
    }
    class tx {
      constructor(e, n, o) {
        this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), zp(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        );
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, zp(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    const nx = th.extend({
      addOptions() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          HTMLAttributes: {},
          resizable: true,
          handleWidth: 5,
          cellMinWidth: 25,
          View: tx,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      addCommands() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          insertTable: (e) => ({ editor: n, commands: o, tr: i, dispatch: s }) => {
            const { rows: r = 3, cols: a = 3, withHeaderRow: l = true } = e || {}, c2 = eh(n.schema, r, a, l);
            if (s) {
              const u = i.selection.anchor + 1;
              o.insertContent({
                type: "table-wrapper",
                content: [c2.toJSON()]
              }), i.scrollIntoView().setSelection(
                re.near(i.doc.resolve(u))
              );
            }
            return true;
          },
          deleteTable: () => ({ state: e, dispatch: n }) => {
            const o = e.selection.$anchor;
            for (let i = o.depth; i > 0; i--)
              if (o.node(i).type.name === "table-wrapper")
                return n && n(
                  e.tr.delete(o.before(i), o.after(i)).scrollIntoView()
                ), true;
            return false;
          },
          selectRow: (e) => ({ tr: n, dispatch: o }) => {
            if (o) {
              const i = n.doc.resolve(e), s = Xe.rowSelection(i);
              n.setSelection(s);
            }
            return true;
          },
          selectColumn: (e) => ({ tr: n, dispatch: o }) => {
            if (o) {
              const i = n.doc.resolve(e), s = Xe.colSelection(i);
              n.setSelection(s);
            }
            return true;
          }
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function ox({
      node: t2,
      types: e
    }) {
      return Array.isArray(e) && e.includes(t2.type) || t2.type === e;
    }
    function pr({
      node: t2,
      types: e
    }) {
      return t2 ? !ox({ node: t2, types: e }) : false;
    }
    const ix = We.create({
      name: "trailingNode",
      addOptions() {
        return {
          node: "paragraph",
          notAfter: ["paragraph"]
        };
      },
      addProseMirrorPlugins() {
        const t2 = new Fe(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
        return [
          new ze({
            key: t2,
            appendTransaction: (n, o, i) => {
              const { doc: s, tr: r, schema: a } = i, l = t2.getState(i), c2 = s.content.size, u = a.nodes[this.options.node];
              if (!(!l || !u))
                return r.insert(c2, u.create());
            },
            state: {
              init: (n, o) => {
                const i = o.tr.doc.lastChild, s = (i == null ? void 0 : i.firstChild) ?? null;
                return pr({ node: i, types: e }) || pr({ node: s, types: e });
              },
              apply: (n, o) => {
                var r;
                if (!n.docChanged) return o;
                const i = n.doc.lastChild, s = ((r = n.doc.lastChild) == null ? void 0 : r.firstChild) ?? null;
                return pr({ node: i, types: e }) || pr({ node: s, types: e });
              }
            }
          })
        ];
      }
    });
    var Rt = [];
    for (var xl = 0; xl < 256; ++xl)
      Rt.push((xl + 256).toString(16).slice(1));
    function sx(t2, e = 0) {
      return (Rt[t2[e + 0]] + Rt[t2[e + 1]] + Rt[t2[e + 2]] + Rt[t2[e + 3]] + "-" + Rt[t2[e + 4]] + Rt[t2[e + 5]] + "-" + Rt[t2[e + 6]] + Rt[t2[e + 7]] + "-" + Rt[t2[e + 8]] + Rt[t2[e + 9]] + "-" + Rt[t2[e + 10]] + Rt[t2[e + 11]] + Rt[t2[e + 12]] + Rt[t2[e + 13]] + Rt[t2[e + 14]] + Rt[t2[e + 15]]).toLowerCase();
    }
    var mr, rx = new Uint8Array(16);
    function ax() {
      if (!mr && (mr = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !mr))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return mr(rx);
    }
    var lx = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const Fp = {
      randomUUID: lx
    };
    function cx(t2, e, n) {
      if (Fp.randomUUID && !t2)
        return Fp.randomUUID();
      t2 = t2 || {};
      var o = t2.random || (t2.rng || ax)();
      return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, sx(o);
    }
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const ux = it.create({
      name: "uniqueID",
      priority: 1e4,
      addOptions: () => ({
        attributeName: "data-id",
        types: ["heading"],
        enableRender: false,
        generateId: () => cx()
      }),
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              [this.options.attributeName]: {
                default: null,
                parseHTML: (t2) => t2.getAttribute(this.options.attributeName),
                renderHTML: (t2) => this.options.enableRender ? {
                  [this.options.attributeName]: t2[this.options.attributeName]
                } : {}
              }
            }
          }
        ];
      },
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe(this.name),
            props: {
              transformPastedHTML: (t2) => {
                const e = new DOMParser().parseFromString(t2, "text/html"), n = this.options.attributeName;
                return e.querySelectorAll(`[${n}]`).forEach((o) => {
                  o.setAttribute(n, this.options.generateId());
                }), e.body.innerHTML;
              }
            },
            appendTransaction: (t2, e, n) => {
              const o = n.tr, i = this.options.attributeName;
              let s = false;
              return n.doc.descendants((r, a) => {
                r.isText || !r.attrs[i] && this.options.types.includes(r.type.name) && (o.setNodeMarkup(a, void 0, {
                  ...r.attrs,
                  [i]: this.options.generateId()
                }), s = true);
              }), s ? o : null;
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function dx(t2) {
      var e;
      const { char: n, allowSpaces: o, allowToIncludeChar: i, allowedPrefixes: s, startOfLine: r, $position: a } = t2, l = o && !i, c2 = uy(n), u = new RegExp(`\\s${c2}$`), d = r ? "^" : "", p2 = i ? "" : c2, m = l ? new RegExp(`${d}${c2}.*?(?=\\s${p2}|$)`, "gm") : new RegExp(`${d}(?:^)?${c2}[^\\s${p2}]*`, "gm"), f = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
      if (!f)
        return null;
      const _ = a.pos - f.length, h2 = Array.from(f.matchAll(m)).pop();
      if (!h2 || h2.input === void 0 || h2.index === void 0)
        return null;
      const g = h2.input.slice(Math.max(0, h2.index - 1), h2.index), k = new RegExp(`^[${s == null ? void 0 : s.join("")}\0]?$`).test(g);
      if (s !== null && !k)
        return null;
      const j = _ + h2.index;
      let v = j + h2[0].length;
      return l && u.test(f.slice(v - 1, v + 1)) && (h2[0] += " ", v += 1), j < a.pos && v >= a.pos ? {
        range: {
          from: j,
          to: v
        },
        query: h2[0].slice(n.length),
        text: h2[0]
      } : null;
    }
    const px = new Fe("suggestion");
    function vu({ pluginKey: t2 = px, editor: e, char: n = "@", allowSpaces: o = false, allowToIncludeChar: i = false, allowedPrefixes: s = [" "], startOfLine: r = false, decorationTag: a = "span", decorationClass: l = "suggestion", command: c2 = () => null, items: u = () => [], render: d = () => ({}), allow: p2 = () => true, findSuggestionMatch: m = dx }) {
      let f;
      const _ = d == null ? void 0 : d(), h2 = new ze({
        key: t2,
        view() {
          return {
            update: async (g, k) => {
              var j, v, C, E, B, U, P;
              const V = (j = this.key) === null || j === void 0 ? void 0 : j.getState(k), ne = (v = this.key) === null || v === void 0 ? void 0 : v.getState(g.state), pe = V.active && ne.active && V.range.from !== ne.range.from, we = !V.active && ne.active, ye = V.active && !ne.active, _e = !we && !ye && V.query !== ne.query, he = we || pe && _e, N = _e || pe, L = ye || pe && _e;
              if (!he && !N && !L)
                return;
              const J = L && !he ? V : ne, se = g.dom.querySelector(`[data-decoration-id="${J.decorationId}"]`);
              f = {
                editor: e,
                range: J.range,
                query: J.query,
                text: J.text,
                items: [],
                command: (ue) => c2({
                  editor: e,
                  range: J.range,
                  props: ue
                }),
                decorationNode: se,
                // virtual node for popper.js or tippy.js
                // this can be used for building popups without a DOM node
                clientRect: se ? () => {
                  var ue;
                  const { decorationId: Se } = (ue = this.key) === null || ue === void 0 ? void 0 : ue.getState(e.state), He = g.dom.querySelector(`[data-decoration-id="${Se}"]`);
                  return (He == null ? void 0 : He.getBoundingClientRect()) || null;
                } : null
              }, he && ((C = _ == null ? void 0 : _.onBeforeStart) === null || C === void 0 || C.call(_, f)), N && ((E = _ == null ? void 0 : _.onBeforeUpdate) === null || E === void 0 || E.call(_, f)), (N || he) && (f.items = await u({
                editor: e,
                query: J.query
              })), L && ((B = _ == null ? void 0 : _.onExit) === null || B === void 0 || B.call(_, f)), N && ((U = _ == null ? void 0 : _.onUpdate) === null || U === void 0 || U.call(_, f)), he && ((P = _ == null ? void 0 : _.onStart) === null || P === void 0 || P.call(_, f));
            },
            destroy: () => {
              var g;
              f && ((g = _ == null ? void 0 : _.onExit) === null || g === void 0 || g.call(_, f));
            }
          };
        },
        state: {
          // Initialize the plugin's internal state.
          init() {
            return {
              active: false,
              range: {
                from: 0,
                to: 0
              },
              query: null,
              text: null,
              composing: false
            };
          },
          // Apply changes to the plugin state from a view transaction.
          apply(g, k, j, v) {
            const { isEditable: C } = e, { composing: E } = e.view, { selection: B } = g, { empty: U, from: P } = B, V = { ...k };
            if (V.composing = E, C && (U || e.view.composing)) {
              (P < k.range.from || P > k.range.to) && !E && !k.composing && (V.active = false);
              const ne = m({
                char: n,
                allowSpaces: o,
                allowToIncludeChar: i,
                allowedPrefixes: s,
                startOfLine: r,
                $position: B.$from
              }), pe = `id_${Math.floor(Math.random() * 4294967295)}`;
              ne && p2({
                editor: e,
                state: v,
                range: ne.range,
                isActive: k.active
              }) ? (V.active = true, V.decorationId = k.decorationId ? k.decorationId : pe, V.range = ne.range, V.query = ne.query, V.text = ne.text) : V.active = false;
            } else
              V.active = false;
            return V.active || (V.decorationId = null, V.range = { from: 0, to: 0 }, V.query = null, V.text = null), V;
          }
        },
        props: {
          // Call the keydown hook if suggestion is active.
          handleKeyDown(g, k) {
            var j;
            const { active: v, range: C } = h2.getState(g.state);
            return v && ((j = _ == null ? void 0 : _.onKeyDown) === null || j === void 0 ? void 0 : j.call(_, { view: g, event: k, range: C })) || false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(g) {
            const { active: k, range: j, decorationId: v } = h2.getState(g);
            return k ? qe.create(g.doc, [
              _t.inline(j.from, j.to, {
                nodeName: a,
                class: l,
                "data-decoration-id": v
              })
            ]) : null;
          }
        }
      });
      return h2;
    }
    const mx = We.create({
      name: "slash-command",
      addOptions() {
        return {
          suggestion: {
            char: "/",
            command: ({
              editor: t2,
              range: e,
              props: n
            }) => {
              n.command({ editor: t2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          vu({
            pluginKey: new Fe("slash-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), fx = We.create({
      name: "colon-command",
      addOptions() {
        return {
          suggestion: {
            char: ":",
            command: ({
              editor: t2,
              range: e,
              props: n
            }) => {
              n.command({ editor: t2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          vu({
            pluginKey: new Fe("colon-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), _x = We.create({
      name: "slash-zh-command",
      addOptions() {
        return {
          suggestion: {
            char: "、",
            command: ({
              editor: t2,
              range: e,
              props: n
            }) => {
              n.command({ editor: t2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          vu({
            pluginKey: new Fe("slash-zh-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), hx = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, o) => (openBlock(), createBlock(unref(ho), mergeProps(e, { class: "o-blockquote-view" }), {
          default: withCtx(() => [
            createBaseVNode("blockquote", null, [
              createVNode(unref(_o))
            ])
          ]),
          _: 1
        }, 16));
      }
    }), gx = E_.extend({
      draggable: true,
      addNodeView() {
        return Pn(hx);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const vx = it.create({
      name: "callout",
      group: "block",
      content: "block+",
      draggable: true,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return {
          icon: {
            default: "🌾"
          },
          borderColor: {
            default: "#dddddd"
          },
          borderColorDark: {
            default: "#333333"
          },
          backColor: {
            default: "#eeeeee"
          },
          backColorDark: {
            default: "rgba(101, 117, 133, 0.16)"
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: 'div[data-type="callout"]'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return [
          "div",
          Pe(t2, { "data-type": "callout" }),
          0
        ];
      },
      addCommands() {
        return {
          setCallout: () => ({ commands: t2 }) => t2.wrapIn(this.name),
          toggleCallout: () => ({ commands: t2 }) => t2.toggleWrap(this.name),
          unsetCallout: () => ({ commands: t2 }) => t2.lift(this.name)
        };
      }
    }), bx = { class: "callout-container" }, kx = { class: "callout-icon" }, yx = { class: "callout-content" }, wx = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { theme: n } = Va(), { isEditable: o } = Be(), i = ref(false), s = ref(false), r = ref({}), a = ref(null), l = computed(() => {
          const { selection: v } = e.editor.view.state, C = v.from, E = e.getPos(), B = E + e.node.nodeSize;
          return C >= E && C <= B;
        }), c2 = computed({
          get() {
            return e.node.attrs.backColor;
          },
          set(v) {
            e.updateAttributes({ backColor: v });
          }
        }), u = computed({
          get() {
            return e.node.attrs.backColorDark;
          },
          set(v) {
            e.updateAttributes({ backColorDark: v });
          }
        }), d = computed({
          get() {
            return e.node.attrs.borderColor;
          },
          set(v) {
            e.updateAttributes({ borderColor: v });
          }
        }), p2 = computed({
          get() {
            return e.node.attrs.borderColorDark;
          },
          set(v) {
            e.updateAttributes({ borderColorDark: v });
          }
        }), m = computed(() => n.value === "dark" ? u.value : c2.value), f = computed(() => n.value === "dark" ? p2.value : d.value);
        function _(v) {
          e.updateAttributes({ icon: v });
        }
        function h2(v) {
          switch (i.value = false, v.value) {
            case "palette":
              k(true);
              break;
          }
        }
        function g(v) {
          i.value = true, r.value = v;
        }
        function k(v) {
          s.value = v;
        }
        function j(v, C) {
          var E;
          switch (v) {
            case "backColor":
              c2.value = C;
              break;
            case "foreColor":
              d.value = C;
              break;
            case "icon":
              _(C.emoji), (E = a.value) == null || E.setShow(false);
              break;
          }
        }
        return watch(l, (v) => {
          k(v);
        }), (v, C) => (openBlock(), createBlock(unref(ho), mergeProps(e, {
          class: "o-callout-view",
          style: `--callout-border-color: ${f.value}; --callout-back-color: ${m.value}`,
          onContextmenu: withModifiers(g, ["prevent"])
        }), {
          default: withCtx(() => [
            createBaseVNode("div", bx, [
              createVNode(unref(Qe), {
                ref_key: "iconPopover",
                ref: a,
                placement: "bottom-start",
                trigger: "click",
                offset: [0, 0],
                disable: !unref(o)
              }, {
                trigger: withCtx(() => [
                  createBaseVNode("div", kx, toDisplayString(v.node.attrs.icon), 1)
                ]),
                default: withCtx(() => [
                  createVNode(unref(fu), {
                    items: unref(mu),
                    onSelect: C[0] || (C[0] = (E) => j("icon", E)),
                    "enable-search": ""
                  }, null, 8, ["items"])
                ]),
                _: 1
              }, 8, ["disable"]),
              createBaseVNode("div", yx, [
                createVNode(unref(_o))
              ]),
              unref(o) ? (openBlock(), createBlock(unref(uu), {
                key: 0,
                modelValue: i.value,
                "onUpdate:modelValue": C[1] || (C[1] = (E) => i.value = E),
                event: r.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Vi), mergeProps(e, { onAction: h2 }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), jx = vx.extend({
      addNodeView() {
        return Pn(wx);
      }
    });
    function Ex(t2) {
      return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
    }
    function nh(t2) {
      return t2 instanceof Map ? t2.clear = t2.delete = t2.set = function() {
        throw new Error("map is read-only");
      } : t2 instanceof Set && (t2.add = t2.clear = t2.delete = function() {
        throw new Error("set is read-only");
      }), Object.freeze(t2), Object.getOwnPropertyNames(t2).forEach((e) => {
        const n = t2[e], o = typeof n;
        (o === "object" || o === "function") && !Object.isFrozen(n) && nh(n);
      }), t2;
    }
    class Hp {
      /**
       * @param {CompiledMode} mode
       */
      constructor(e) {
        e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function oh(t2) {
      return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function Ao(t2, ...e) {
      const n = /* @__PURE__ */ Object.create(null);
      for (const o in t2)
        n[o] = t2[o];
      return e.forEach(function(o) {
        for (const i in o)
          n[i] = o[i];
      }), /** @type {T} */
      n;
    }
    const Sx = "</span>", Up = (t2) => !!t2.scope, Cx = (t2, { prefix: e }) => {
      if (t2.startsWith("language:"))
        return t2.replace("language:", "language-");
      if (t2.includes(".")) {
        const n = t2.split(".");
        return [
          `${e}${n.shift()}`,
          ...n.map((o, i) => `${o}${"_".repeat(i + 1)}`)
        ].join(" ");
      }
      return `${e}${t2}`;
    };
    class xx {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(e, n) {
        this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(e) {
        this.buffer += oh(e);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(e) {
        if (!Up(e)) return;
        const n = Cx(
          e.scope,
          { prefix: this.classPrefix }
        );
        this.span(n);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(e) {
        Up(e) && (this.buffer += Sx);
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(e) {
        this.buffer += `<span class="${e}">`;
      }
    }
    const Vp = (t2 = {}) => {
      const e = { children: [] };
      return Object.assign(e, t2), e;
    };
    class bu {
      constructor() {
        this.rootNode = Vp(), this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(e) {
        this.top.children.push(e);
      }
      /** @param {string} scope */
      openNode(e) {
        const n = Vp({ scope: e });
        this.add(n), this.stack.push(n);
      }
      closeNode() {
        if (this.stack.length > 1)
          return this.stack.pop();
      }
      closeAllNodes() {
        for (; this.closeNode(); ) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(e) {
        return this.constructor._walk(e, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(e, n) {
        return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((o) => this._walk(e, o)), e.closeNode(n)), e;
      }
      /**
       * @param {Node} node
       */
      static _collapse(e) {
        typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
          bu._collapse(n);
        }));
      }
    }
    class Tx extends bu {
      /**
       * @param {*} options
       */
      constructor(e) {
        super(), this.options = e;
      }
      /**
       * @param {string} text
       */
      addText(e) {
        e !== "" && this.add(e);
      }
      /** @param {string} scope */
      startScope(e) {
        this.openNode(e);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(e, n) {
        const o = e.root;
        n && (o.scope = `language:${n}`), this.add(o);
      }
      toHTML() {
        return new xx(this, this.options).value();
      }
      finalize() {
        return this.closeAllNodes(), true;
      }
    }
    function Ds(t2) {
      return t2 ? typeof t2 == "string" ? t2 : t2.source : null;
    }
    function ih(t2) {
      return fi("(?=", t2, ")");
    }
    function Ox(t2) {
      return fi("(?:", t2, ")*");
    }
    function Nx(t2) {
      return fi("(?:", t2, ")?");
    }
    function fi(...t2) {
      return t2.map((n) => Ds(n)).join("");
    }
    function Ax(t2) {
      const e = t2[t2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (t2.splice(t2.length - 1, 1), e) : {};
    }
    function ku(...t2) {
      return "(" + (Ax(t2).capture ? "" : "?:") + t2.map((o) => Ds(o)).join("|") + ")";
    }
    function sh(t2) {
      return new RegExp(t2.toString() + "|").exec("").length - 1;
    }
    function Mx(t2, e) {
      const n = t2 && t2.exec(e);
      return n && n.index === 0;
    }
    const Rx = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function yu(t2, { joinWith: e }) {
      let n = 0;
      return t2.map((o) => {
        n += 1;
        const i = n;
        let s = Ds(o), r = "";
        for (; s.length > 0; ) {
          const a = Rx.exec(s);
          if (!a) {
            r += s;
            break;
          }
          r += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? r += "\\" + String(Number(a[1]) + i) : (r += a[0], a[0] === "(" && n++);
        }
        return r;
      }).map((o) => `(${o})`).join(e);
    }
    const Ix = /\b\B/, rh = "[a-zA-Z]\\w*", wu = "[a-zA-Z_]\\w*", ah = "\\b\\d+(\\.\\d+)?", lh = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", ch = "\\b(0b[01]+)", Dx = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", Lx = (t2 = {}) => {
      const e = /^#![ ]*\//;
      return t2.binary && (t2.begin = fi(
        e,
        /.*\b/,
        t2.binary,
        /\b.*/
      )), Ao({
        scope: "meta",
        begin: e,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (n, o) => {
          n.index !== 0 && o.ignoreMatch();
        }
      }, t2);
    }, Ls = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    }, Px = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [Ls]
    }, Bx = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [Ls]
    }, $x = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    }, Wa = function(t2, e, n = {}) {
      const o = Ao(
        {
          scope: "comment",
          begin: t2,
          end: e,
          contains: []
        },
        n
      );
      o.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const i = ku(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      return o.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: fi(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            i,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      ), o;
    }, zx = Wa("//", "$"), Fx = Wa("/\\*", "\\*/"), Hx = Wa("#", "$"), Ux = {
      scope: "number",
      begin: ah,
      relevance: 0
    }, Vx = {
      scope: "number",
      begin: lh,
      relevance: 0
    }, qx = {
      scope: "number",
      begin: ch,
      relevance: 0
    }, Kx = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        Ls,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [Ls]
        }
      ]
    }, Wx = {
      scope: "title",
      begin: rh,
      relevance: 0
    }, Gx = {
      scope: "title",
      begin: wu,
      relevance: 0
    }, Jx = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + wu,
      relevance: 0
    }, Yx = function(t2) {
      return Object.assign(
        t2,
        {
          /** @type {ModeCallback} */
          "on:begin": (e, n) => {
            n.data._beginMatch = e[1];
          },
          /** @type {ModeCallback} */
          "on:end": (e, n) => {
            n.data._beginMatch !== e[1] && n.ignoreMatch();
          }
        }
      );
    };
    var fr = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE: Px,
      BACKSLASH_ESCAPE: Ls,
      BINARY_NUMBER_MODE: qx,
      BINARY_NUMBER_RE: ch,
      COMMENT: Wa,
      C_BLOCK_COMMENT_MODE: Fx,
      C_LINE_COMMENT_MODE: zx,
      C_NUMBER_MODE: Vx,
      C_NUMBER_RE: lh,
      END_SAME_AS_BEGIN: Yx,
      HASH_COMMENT_MODE: Hx,
      IDENT_RE: rh,
      MATCH_NOTHING_RE: Ix,
      METHOD_GUARD: Jx,
      NUMBER_MODE: Ux,
      NUMBER_RE: ah,
      PHRASAL_WORDS_MODE: $x,
      QUOTE_STRING_MODE: Bx,
      REGEXP_MODE: Kx,
      RE_STARTERS_RE: Dx,
      SHEBANG: Lx,
      TITLE_MODE: Wx,
      UNDERSCORE_IDENT_RE: wu,
      UNDERSCORE_TITLE_MODE: Gx
    });
    function Xx(t2, e) {
      t2.input[t2.index - 1] === "." && e.ignoreMatch();
    }
    function Zx(t2, e) {
      t2.className !== void 0 && (t2.scope = t2.className, delete t2.className);
    }
    function Qx(t2, e) {
      e && t2.beginKeywords && (t2.begin = "\\b(" + t2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t2.__beforeBegin = Xx, t2.keywords = t2.keywords || t2.beginKeywords, delete t2.beginKeywords, t2.relevance === void 0 && (t2.relevance = 0));
    }
    function eT(t2, e) {
      Array.isArray(t2.illegal) && (t2.illegal = ku(...t2.illegal));
    }
    function tT(t2, e) {
      if (t2.match) {
        if (t2.begin || t2.end) throw new Error("begin & end are not supported with match");
        t2.begin = t2.match, delete t2.match;
      }
    }
    function nT(t2, e) {
      t2.relevance === void 0 && (t2.relevance = 1);
    }
    const oT = (t2, e) => {
      if (!t2.beforeMatch) return;
      if (t2.starts) throw new Error("beforeMatch cannot be used with starts");
      const n = Object.assign({}, t2);
      Object.keys(t2).forEach((o) => {
        delete t2[o];
      }), t2.keywords = n.keywords, t2.begin = fi(n.beforeMatch, ih(n.begin)), t2.starts = {
        relevance: 0,
        contains: [
          Object.assign(n, { endsParent: true })
        ]
      }, t2.relevance = 0, delete n.beforeMatch;
    }, iT = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ], sT = "keyword";
    function uh(t2, e, n = sT) {
      const o = /* @__PURE__ */ Object.create(null);
      return typeof t2 == "string" ? i(n, t2.split(" ")) : Array.isArray(t2) ? i(n, t2) : Object.keys(t2).forEach(function(s) {
        Object.assign(
          o,
          uh(t2[s], e, s)
        );
      }), o;
      function i(s, r) {
        e && (r = r.map((a) => a.toLowerCase())), r.forEach(function(a) {
          const l = a.split("|");
          o[l[0]] = [s, rT(l[0], l[1])];
        });
      }
    }
    function rT(t2, e) {
      return e ? Number(e) : aT(t2) ? 0 : 1;
    }
    function aT(t2) {
      return iT.includes(t2.toLowerCase());
    }
    const qp = {}, si = (t2) => {
      console.error(t2);
    }, Kp = (t2, ...e) => {
      console.log(`WARN: ${t2}`, ...e);
    }, vi = (t2, e) => {
      qp[`${t2}/${e}`] || (console.log(`Deprecated as of ${t2}. ${e}`), qp[`${t2}/${e}`] = true);
    }, Qr = new Error();
    function dh(t2, e, { key: n }) {
      let o = 0;
      const i = t2[n], s = {}, r = {};
      for (let a = 1; a <= e.length; a++)
        r[a + o] = i[a], s[a + o] = true, o += sh(e[a - 1]);
      t2[n] = r, t2[n]._emit = s, t2[n]._multi = true;
    }
    function lT(t2) {
      if (Array.isArray(t2.begin)) {
        if (t2.skip || t2.excludeBegin || t2.returnBegin)
          throw si("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Qr;
        if (typeof t2.beginScope != "object" || t2.beginScope === null)
          throw si("beginScope must be object"), Qr;
        dh(t2, t2.begin, { key: "beginScope" }), t2.begin = yu(t2.begin, { joinWith: "" });
      }
    }
    function cT(t2) {
      if (Array.isArray(t2.end)) {
        if (t2.skip || t2.excludeEnd || t2.returnEnd)
          throw si("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Qr;
        if (typeof t2.endScope != "object" || t2.endScope === null)
          throw si("endScope must be object"), Qr;
        dh(t2, t2.end, { key: "endScope" }), t2.end = yu(t2.end, { joinWith: "" });
      }
    }
    function uT(t2) {
      t2.scope && typeof t2.scope == "object" && t2.scope !== null && (t2.beginScope = t2.scope, delete t2.scope);
    }
    function dT(t2) {
      uT(t2), typeof t2.beginScope == "string" && (t2.beginScope = { _wrap: t2.beginScope }), typeof t2.endScope == "string" && (t2.endScope = { _wrap: t2.endScope }), lT(t2), cT(t2);
    }
    function pT(t2) {
      function e(r, a) {
        return new RegExp(
          Ds(r),
          "m" + (t2.case_insensitive ? "i" : "") + (t2.unicodeRegex ? "u" : "") + (a ? "g" : "")
        );
      }
      class n {
        constructor() {
          this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += sh(a) + 1;
        }
        compile() {
          this.regexes.length === 0 && (this.exec = () => null);
          const a = this.regexes.map((l) => l[1]);
          this.matcherRe = e(yu(a, { joinWith: "|" }), true), this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(a) {
          this.matcherRe.lastIndex = this.lastIndex;
          const l = this.matcherRe.exec(a);
          if (!l)
            return null;
          const c2 = l.findIndex((d, p2) => p2 > 0 && d !== void 0), u = this.matchIndexes[c2];
          return l.splice(0, c2), Object.assign(l, u);
        }
      }
      class o {
        constructor() {
          this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(a) {
          if (this.multiRegexes[a]) return this.multiRegexes[a];
          const l = new n();
          return this.rules.slice(a).forEach(([c2, u]) => l.addRule(c2, u)), l.compile(), this.multiRegexes[a] = l, l;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          this.rules.push([a, l]), l.type === "begin" && this.count++;
        }
        /** @param {string} s */
        exec(a) {
          const l = this.getMatcher(this.regexIndex);
          l.lastIndex = this.lastIndex;
          let c2 = l.exec(a);
          if (this.resumingScanAtSamePosition() && !(c2 && c2.index === this.lastIndex)) {
            const u = this.getMatcher(0);
            u.lastIndex = this.lastIndex + 1, c2 = u.exec(a);
          }
          return c2 && (this.regexIndex += c2.position + 1, this.regexIndex === this.count && this.considerAll()), c2;
        }
      }
      function i(r) {
        const a = new o();
        return r.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), r.terminatorEnd && a.addRule(r.terminatorEnd, { type: "end" }), r.illegal && a.addRule(r.illegal, { type: "illegal" }), a;
      }
      function s(r, a) {
        const l = (
          /** @type CompiledMode */
          r
        );
        if (r.isCompiled) return l;
        [
          Zx,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          tT,
          dT,
          oT
        ].forEach((u) => u(r, a)), t2.compilerExtensions.forEach((u) => u(r, a)), r.__beforeBegin = null, [
          Qx,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          eT,
          // default to 1 relevance if not specified
          nT
        ].forEach((u) => u(r, a)), r.isCompiled = true;
        let c2 = null;
        return typeof r.keywords == "object" && r.keywords.$pattern && (r.keywords = Object.assign({}, r.keywords), c2 = r.keywords.$pattern, delete r.keywords.$pattern), c2 = c2 || /\w+/, r.keywords && (r.keywords = uh(r.keywords, t2.case_insensitive)), l.keywordPatternRe = e(c2, true), a && (r.begin || (r.begin = /\B|\b/), l.beginRe = e(l.begin), !r.end && !r.endsWithParent && (r.end = /\B|\b/), r.end && (l.endRe = e(l.end)), l.terminatorEnd = Ds(l.end) || "", r.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (r.end ? "|" : "") + a.terminatorEnd)), r.illegal && (l.illegalRe = e(
          /** @type {RegExp | string} */
          r.illegal
        )), r.contains || (r.contains = []), r.contains = [].concat(...r.contains.map(function(u) {
          return mT(u === "self" ? r : u);
        })), r.contains.forEach(function(u) {
          s(
            /** @type Mode */
            u,
            l
          );
        }), r.starts && s(r.starts, a), l.matcher = i(l), l;
      }
      if (t2.compilerExtensions || (t2.compilerExtensions = []), t2.contains && t2.contains.includes("self"))
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      return t2.classNameAliases = Ao(t2.classNameAliases || {}), s(
        /** @type Mode */
        t2
      );
    }
    function ph(t2) {
      return t2 ? t2.endsWithParent || ph(t2.starts) : false;
    }
    function mT(t2) {
      return t2.variants && !t2.cachedVariants && (t2.cachedVariants = t2.variants.map(function(e) {
        return Ao(t2, { variants: null }, e);
      })), t2.cachedVariants ? t2.cachedVariants : ph(t2) ? Ao(t2, { starts: t2.starts ? Ao(t2.starts) : null }) : Object.isFrozen(t2) ? Ao(t2) : t2;
    }
    var fT = "11.10.0";
    class _T extends Error {
      constructor(e, n) {
        super(e), this.name = "HTMLInjectionError", this.html = n;
      }
    }
    const Tl = oh, Wp = Ao, Gp = Symbol("nomatch"), hT = 7, mh = function(t2) {
      const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), o = [];
      let i = true;
      const s = "Could not find the language '{}', did you forget to load/include a language module?", r = { disableAutodetect: true, name: "Plain text", contains: [] };
      let a = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: Tx
      };
      function l(N) {
        return a.noHighlightRe.test(N);
      }
      function c2(N) {
        let L = N.className + " ";
        L += N.parentNode ? N.parentNode.className : "";
        const J = a.languageDetectRe.exec(L);
        if (J) {
          const se = P(J[1]);
          return se || (Kp(s.replace("{}", J[1])), Kp("Falling back to no-highlight mode for this block.", N)), se ? J[1] : "no-highlight";
        }
        return L.split(/\s+/).find((se) => l(se) || P(se));
      }
      function u(N, L, J) {
        let se = "", ue = "";
        typeof L == "object" ? (se = N, J = L.ignoreIllegals, ue = L.language) : (vi("10.7.0", "highlight(lang, code, ...args) has been deprecated."), vi("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ue = N, se = L), J === void 0 && (J = true);
        const Se = {
          code: se,
          language: ue
        };
        _e("before:highlight", Se);
        const He = Se.result ? Se.result : d(Se.language, Se.code, J);
        return He.code = Se.code, _e("after:highlight", He), He;
      }
      function d(N, L, J, se) {
        const ue = /* @__PURE__ */ Object.create(null);
        function Se(F, Y) {
          return F.keywords[Y];
        }
        function He() {
          if (!le.keywords) {
            Ge.addText(Ie);
            return;
          }
          let F = 0;
          le.keywordPatternRe.lastIndex = 0;
          let Y = le.keywordPatternRe.exec(Ie), je = "";
          for (; Y; ) {
            je += Ie.substring(F, Y.index);
            const De = ke.case_insensitive ? Y[0].toLowerCase() : Y[0], ht = Se(le, De);
            if (ht) {
              const [an, Wi] = ht;
              if (Ge.addText(je), je = "", ue[De] = (ue[De] || 0) + 1, ue[De] <= hT && (Vt += Wi), an.startsWith("_"))
                je += Y[0];
              else {
                const O = ke.classNameAliases[an] || an;
                et(Y[0], O);
              }
            } else
              je += Y[0];
            F = le.keywordPatternRe.lastIndex, Y = le.keywordPatternRe.exec(Ie);
          }
          je += Ie.substring(F), Ge.addText(je);
        }
        function yt() {
          if (Ie === "") return;
          let F = null;
          if (typeof le.subLanguage == "string") {
            if (!e[le.subLanguage]) {
              Ge.addText(Ie);
              return;
            }
            F = d(le.subLanguage, Ie, true, Ut[le.subLanguage]), Ut[le.subLanguage] = /** @type {CompiledMode} */
            F._top;
          } else
            F = m(Ie, le.subLanguage.length ? le.subLanguage : null);
          le.relevance > 0 && (Vt += F.relevance), Ge.__addSublanguage(F._emitter, F.language);
        }
        function Ue() {
          le.subLanguage != null ? yt() : He(), Ie = "";
        }
        function et(F, Y) {
          F !== "" && (Ge.startScope(Y), Ge.addText(F), Ge.endScope());
        }
        function sn(F, Y) {
          let je = 1;
          const De = Y.length - 1;
          for (; je <= De; ) {
            if (!F._emit[je]) {
              je++;
              continue;
            }
            const ht = ke.classNameAliases[F[je]] || F[je], an = Y[je];
            ht ? et(an, ht) : (Ie = an, He(), Ie = ""), je++;
          }
        }
        function Nt(F, Y) {
          return F.scope && typeof F.scope == "string" && Ge.openNode(ke.classNameAliases[F.scope] || F.scope), F.beginScope && (F.beginScope._wrap ? (et(Ie, ke.classNameAliases[F.beginScope._wrap] || F.beginScope._wrap), Ie = "") : F.beginScope._multi && (sn(F.beginScope, Y), Ie = "")), le = Object.create(F, { parent: { value: le } }), le;
        }
        function fn(F, Y, je) {
          let De = Mx(F.endRe, je);
          if (De) {
            if (F["on:end"]) {
              const ht = new Hp(F);
              F["on:end"](Y, ht), ht.isMatchIgnored && (De = false);
            }
            if (De) {
              for (; F.endsParent && F.parent; )
                F = F.parent;
              return F;
            }
          }
          if (F.endsWithParent)
            return fn(F.parent, Y, je);
        }
        function At(F) {
          return le.matcher.regexIndex === 0 ? (Ie += F[0], 1) : (qt = true, 0);
        }
        function _n(F) {
          const Y = F[0], je = F.rule, De = new Hp(je), ht = [je.__beforeBegin, je["on:begin"]];
          for (const an of ht)
            if (an && (an(F, De), De.isMatchIgnored))
              return At(Y);
          return je.skip ? Ie += Y : (je.excludeBegin && (Ie += Y), Ue(), !je.returnBegin && !je.excludeBegin && (Ie = Y)), Nt(je, F), je.returnBegin ? 0 : Y.length;
        }
        function zn(F) {
          const Y = F[0], je = L.substring(F.index), De = fn(le, F, je);
          if (!De)
            return Gp;
          const ht = le;
          le.endScope && le.endScope._wrap ? (Ue(), et(Y, le.endScope._wrap)) : le.endScope && le.endScope._multi ? (Ue(), sn(le.endScope, F)) : ht.skip ? Ie += Y : (ht.returnEnd || ht.excludeEnd || (Ie += Y), Ue(), ht.excludeEnd && (Ie = Y));
          do
            le.scope && Ge.closeNode(), !le.skip && !le.subLanguage && (Vt += le.relevance), le = le.parent;
          while (le !== De.parent);
          return De.starts && Nt(De.starts, F), ht.returnEnd ? 0 : Y.length;
        }
        function On() {
          const F = [];
          for (let Y = le; Y !== ke; Y = Y.parent)
            Y.scope && F.unshift(Y.scope);
          F.forEach((Y) => Ge.openNode(Y));
        }
        let rn = {};
        function Nn(F, Y) {
          const je = Y && Y[0];
          if (Ie += F, je == null)
            return Ue(), 0;
          if (rn.type === "begin" && Y.type === "end" && rn.index === Y.index && je === "") {
            if (Ie += L.slice(Y.index, Y.index + 1), !i) {
              const De = new Error(`0 width match regex (${N})`);
              throw De.languageName = N, De.badRule = rn.rule, De;
            }
            return 1;
          }
          if (rn = Y, Y.type === "begin")
            return _n(Y);
          if (Y.type === "illegal" && !J) {
            const De = new Error('Illegal lexeme "' + je + '" for mode "' + (le.scope || "<unnamed>") + '"');
            throw De.mode = le, De;
          } else if (Y.type === "end") {
            const De = zn(Y);
            if (De !== Gp)
              return De;
          }
          if (Y.type === "illegal" && je === "")
            return 1;
          if (An > 1e5 && An > Y.index * 3)
            throw new Error("potential infinite loop, way more iterations than matches");
          return Ie += je, je.length;
        }
        const ke = P(N);
        if (!ke)
          throw si(s.replace("{}", N)), new Error('Unknown language: "' + N + '"');
        const Xt = pT(ke);
        let Pt = "", le = se || Xt;
        const Ut = {}, Ge = new a.__emitter(a);
        On();
        let Ie = "", Vt = 0, mt = 0, An = 0, qt = false;
        try {
          if (ke.__emitTokens)
            ke.__emitTokens(L, Ge);
          else {
            for (le.matcher.considerAll(); ; ) {
              An++, qt ? qt = false : le.matcher.considerAll(), le.matcher.lastIndex = mt;
              const F = le.matcher.exec(L);
              if (!F) break;
              const Y = L.substring(mt, F.index), je = Nn(Y, F);
              mt = F.index + je;
            }
            Nn(L.substring(mt));
          }
          return Ge.finalize(), Pt = Ge.toHTML(), {
            language: N,
            value: Pt,
            relevance: Vt,
            illegal: false,
            _emitter: Ge,
            _top: le
          };
        } catch (F) {
          if (F.message && F.message.includes("Illegal"))
            return {
              language: N,
              value: Tl(L),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: F.message,
                index: mt,
                context: L.slice(mt - 100, mt + 100),
                mode: F.mode,
                resultSoFar: Pt
              },
              _emitter: Ge
            };
          if (i)
            return {
              language: N,
              value: Tl(L),
              illegal: false,
              relevance: 0,
              errorRaised: F,
              _emitter: Ge,
              _top: le
            };
          throw F;
        }
      }
      function p2(N) {
        const L = {
          value: Tl(N),
          illegal: false,
          relevance: 0,
          _top: r,
          _emitter: new a.__emitter(a)
        };
        return L._emitter.addText(N), L;
      }
      function m(N, L) {
        L = L || a.languages || Object.keys(e);
        const J = p2(N), se = L.filter(P).filter(ne).map(
          (Ue) => d(Ue, N, false)
        );
        se.unshift(J);
        const ue = se.sort((Ue, et) => {
          if (Ue.relevance !== et.relevance) return et.relevance - Ue.relevance;
          if (Ue.language && et.language) {
            if (P(Ue.language).supersetOf === et.language)
              return 1;
            if (P(et.language).supersetOf === Ue.language)
              return -1;
          }
          return 0;
        }), [Se, He] = ue, yt = Se;
        return yt.secondBest = He, yt;
      }
      function f(N, L, J) {
        const se = L && n[L] || J;
        N.classList.add("hljs"), N.classList.add(`language-${se}`);
      }
      function _(N) {
        let L = null;
        const J = c2(N);
        if (l(J)) return;
        if (_e(
          "before:highlightElement",
          { el: N, language: J }
        ), N.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", N);
          return;
        }
        if (N.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(N)), a.throwUnescapedHTML))
          throw new _T(
            "One of your code blocks includes unescaped HTML.",
            N.innerHTML
          );
        L = N;
        const se = L.textContent, ue = J ? u(se, { language: J, ignoreIllegals: true }) : m(se);
        N.innerHTML = ue.value, N.dataset.highlighted = "yes", f(N, J, ue.language), N.result = {
          language: ue.language,
          // TODO: remove with version 11.0
          re: ue.relevance,
          relevance: ue.relevance
        }, ue.secondBest && (N.secondBest = {
          language: ue.secondBest.language,
          relevance: ue.secondBest.relevance
        }), _e("after:highlightElement", { el: N, result: ue, text: se });
      }
      function h2(N) {
        a = Wp(a, N);
      }
      const g = () => {
        v(), vi("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function k() {
        v(), vi("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let j = false;
      function v() {
        if (document.readyState === "loading") {
          j = true;
          return;
        }
        document.querySelectorAll(a.cssSelector).forEach(_);
      }
      function C() {
        j && v();
      }
      typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", C, false);
      function E(N, L) {
        let J = null;
        try {
          J = L(t2);
        } catch (se) {
          if (si("Language definition for '{}' could not be registered.".replace("{}", N)), i)
            si(se);
          else
            throw se;
          J = r;
        }
        J.name || (J.name = N), e[N] = J, J.rawDefinition = L.bind(null, t2), J.aliases && V(J.aliases, { languageName: N });
      }
      function B(N) {
        delete e[N];
        for (const L of Object.keys(n))
          n[L] === N && delete n[L];
      }
      function U() {
        return Object.keys(e);
      }
      function P(N) {
        return N = (N || "").toLowerCase(), e[N] || e[n[N]];
      }
      function V(N, { languageName: L }) {
        typeof N == "string" && (N = [N]), N.forEach((J) => {
          n[J.toLowerCase()] = L;
        });
      }
      function ne(N) {
        const L = P(N);
        return L && !L.disableAutodetect;
      }
      function pe(N) {
        N["before:highlightBlock"] && !N["before:highlightElement"] && (N["before:highlightElement"] = (L) => {
          N["before:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        }), N["after:highlightBlock"] && !N["after:highlightElement"] && (N["after:highlightElement"] = (L) => {
          N["after:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        });
      }
      function we(N) {
        pe(N), o.push(N);
      }
      function ye(N) {
        const L = o.indexOf(N);
        L !== -1 && o.splice(L, 1);
      }
      function _e(N, L) {
        const J = N;
        o.forEach(function(se) {
          se[J] && se[J](L);
        });
      }
      function he(N) {
        return vi("10.7.0", "highlightBlock will be removed entirely in v12.0"), vi("10.7.0", "Please use highlightElement now."), _(N);
      }
      Object.assign(t2, {
        highlight: u,
        highlightAuto: m,
        highlightAll: v,
        highlightElement: _,
        // TODO: Remove with v12 API
        highlightBlock: he,
        configure: h2,
        initHighlighting: g,
        initHighlightingOnLoad: k,
        registerLanguage: E,
        unregisterLanguage: B,
        listLanguages: U,
        getLanguage: P,
        registerAliases: V,
        autoDetection: ne,
        inherit: Wp,
        addPlugin: we,
        removePlugin: ye
      }), t2.debugMode = function() {
        i = false;
      }, t2.safeMode = function() {
        i = true;
      }, t2.versionString = fT, t2.regex = {
        concat: fi,
        lookahead: ih,
        either: ku,
        optional: Nx,
        anyNumberOfTimes: Ox
      };
      for (const N in fr)
        typeof fr[N] == "object" && nh(fr[N]);
      return Object.assign(t2, fr), t2;
    }, zi = mh({});
    zi.newInstance = () => mh({});
    var gT = zi;
    zi.HighlightJS = zi;
    zi.default = zi;
    var vT = /* @__PURE__ */ Ex(gT);
    function fh(t2, e = []) {
      return t2.map((n) => {
        const o = [...e, ...n.properties ? n.properties.className : []];
        return n.children ? fh(n.children, o) : {
          text: n.value,
          classes: o
        };
      }).flat();
    }
    function Jp(t2) {
      return t2.value || t2.children || [];
    }
    function bT(t2) {
      return !!vT.getLanguage(t2);
    }
    function Yp({ doc: t2, name: e, lowlight: n, defaultLanguage: o }) {
      const i = [];
      return oc(t2, (s) => s.type.name === e).forEach((s) => {
        var r;
        let a = s.pos + 1;
        const l = s.node.attrs.language || o, c2 = n.listLanguages(), u = l && (c2.includes(l) || bT(l) || !((r = n.registered) === null || r === void 0) && r.call(n, l)) ? Jp(n.highlight(l, s.node.textContent)) : Jp(n.highlightAuto(s.node.textContent));
        fh(u).forEach((d) => {
          const p2 = a + d.text.length;
          if (d.classes.length) {
            const m = _t.inline(a, p2, {
              class: d.classes.join(" ")
            });
            i.push(m);
          }
          a = p2;
        });
      }), qe.create(t2, i);
    }
    function kT(t2) {
      return typeof t2 == "function";
    }
    function yT({ name: t2, lowlight: e, defaultLanguage: n }) {
      if (!["highlight", "highlightAuto", "listLanguages"].every((i) => kT(e[i])))
        throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
      const o = new ze({
        key: new Fe("lowlight"),
        state: {
          init: (i, { doc: s }) => Yp({
            doc: s,
            name: t2,
            lowlight: e,
            defaultLanguage: n
          }),
          apply: (i, s, r, a) => {
            const l = r.selection.$head.parent.type.name, c2 = a.selection.$head.parent.type.name, u = oc(r.doc, (p2) => p2.type.name === t2), d = oc(a.doc, (p2) => p2.type.name === t2);
            return i.docChanged && ([l, c2].includes(t2) || d.length !== u.length || i.steps.some((p2) => (
              // @ts-ignore
              p2.from !== void 0 && p2.to !== void 0 && u.some((m) => (
                // @ts-ignore
                m.pos >= p2.from && m.pos + m.node.nodeSize <= p2.to
              ))
            ))) ? Yp({
              doc: i.doc,
              name: t2,
              lowlight: e,
              defaultLanguage: n
            }) : s.map(i.mapping, i.doc);
          }
        },
        props: {
          decorations(i) {
            return o.getState(i);
          }
        }
      });
      return o;
    }
    const wT = S_.extend({
      addOptions() {
        var t2;
        return {
          ...(t2 = this.parent) === null || t2 === void 0 ? void 0 : t2.call(this),
          lowlight: {},
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      addProseMirrorPlugins() {
        var t2;
        return [
          ...((t2 = this.parent) === null || t2 === void 0 ? void 0 : t2.call(this)) || [],
          yT({
            name: this.name,
            lowlight: this.options.lowlight,
            defaultLanguage: this.options.defaultLanguage
          })
        ];
      }
    });
    function jT(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", r = "(?!struct)(" + o + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i) + t2.IDENT_RE,
        relevance: 0
      }, m = e.optional(i) + t2.IDENT_RE + "\\s*\\(", f = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], _ = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], h2 = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], g = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: _,
        keyword: f,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: h2
      }, C = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: g
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          t2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, E = [
        C,
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], B = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: E.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: E.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, U = {
        className: "function",
        begin: "(" + r + "[\\*&\\s]+)+" + m,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: v,
            relevance: 0
          },
          {
            begin: m,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          B,
          U,
          C,
          E,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: t2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function ET(t2) {
      const e = {
        type: [
          "boolean",
          "byte",
          "word",
          "String"
        ],
        built_in: [
          "KeyboardController",
          "MouseController",
          "SoftwareSerial",
          "EthernetServer",
          "EthernetClient",
          "LiquidCrystal",
          "RobotControl",
          "GSMVoiceCall",
          "EthernetUDP",
          "EsploraTFT",
          "HttpClient",
          "RobotMotor",
          "WiFiClient",
          "GSMScanner",
          "FileSystem",
          "Scheduler",
          "GSMServer",
          "YunClient",
          "YunServer",
          "IPAddress",
          "GSMClient",
          "GSMModem",
          "Keyboard",
          "Ethernet",
          "Console",
          "GSMBand",
          "Esplora",
          "Stepper",
          "Process",
          "WiFiUDP",
          "GSM_SMS",
          "Mailbox",
          "USBHost",
          "Firmata",
          "PImage",
          "Client",
          "Server",
          "GSMPIN",
          "FileIO",
          "Bridge",
          "Serial",
          "EEPROM",
          "Stream",
          "Mouse",
          "Audio",
          "Servo",
          "File",
          "Task",
          "GPRS",
          "WiFi",
          "Wire",
          "TFT",
          "GSM",
          "SPI",
          "SD"
        ],
        _hints: [
          "setup",
          "loop",
          "runShellCommandAsynchronously",
          "analogWriteResolution",
          "retrieveCallingNumber",
          "printFirmwareVersion",
          "analogReadResolution",
          "sendDigitalPortPair",
          "noListenOnLocalhost",
          "readJoystickButton",
          "setFirmwareVersion",
          "readJoystickSwitch",
          "scrollDisplayRight",
          "getVoiceCallStatus",
          "scrollDisplayLeft",
          "writeMicroseconds",
          "delayMicroseconds",
          "beginTransmission",
          "getSignalStrength",
          "runAsynchronously",
          "getAsynchronously",
          "listenOnLocalhost",
          "getCurrentCarrier",
          "readAccelerometer",
          "messageAvailable",
          "sendDigitalPorts",
          "lineFollowConfig",
          "countryNameWrite",
          "runShellCommand",
          "readStringUntil",
          "rewindDirectory",
          "readTemperature",
          "setClockDivider",
          "readLightSensor",
          "endTransmission",
          "analogReference",
          "detachInterrupt",
          "countryNameRead",
          "attachInterrupt",
          "encryptionType",
          "readBytesUntil",
          "robotNameWrite",
          "readMicrophone",
          "robotNameRead",
          "cityNameWrite",
          "userNameWrite",
          "readJoystickY",
          "readJoystickX",
          "mouseReleased",
          "openNextFile",
          "scanNetworks",
          "noInterrupts",
          "digitalWrite",
          "beginSpeaker",
          "mousePressed",
          "isActionDone",
          "mouseDragged",
          "displayLogos",
          "noAutoscroll",
          "addParameter",
          "remoteNumber",
          "getModifiers",
          "keyboardRead",
          "userNameRead",
          "waitContinue",
          "processInput",
          "parseCommand",
          "printVersion",
          "readNetworks",
          "writeMessage",
          "blinkVersion",
          "cityNameRead",
          "readMessage",
          "setDataMode",
          "parsePacket",
          "isListening",
          "setBitOrder",
          "beginPacket",
          "isDirectory",
          "motorsWrite",
          "drawCompass",
          "digitalRead",
          "clearScreen",
          "serialEvent",
          "rightToLeft",
          "setTextSize",
          "leftToRight",
          "requestFrom",
          "keyReleased",
          "compassRead",
          "analogWrite",
          "interrupts",
          "WiFiServer",
          "disconnect",
          "playMelody",
          "parseFloat",
          "autoscroll",
          "getPINUsed",
          "setPINUsed",
          "setTimeout",
          "sendAnalog",
          "readSlider",
          "analogRead",
          "beginWrite",
          "createChar",
          "motorsStop",
          "keyPressed",
          "tempoWrite",
          "readButton",
          "subnetMask",
          "debugPrint",
          "macAddress",
          "writeGreen",
          "randomSeed",
          "attachGPRS",
          "readString",
          "sendString",
          "remotePort",
          "releaseAll",
          "mouseMoved",
          "background",
          "getXChange",
          "getYChange",
          "answerCall",
          "getResult",
          "voiceCall",
          "endPacket",
          "constrain",
          "getSocket",
          "writeJSON",
          "getButton",
          "available",
          "connected",
          "findUntil",
          "readBytes",
          "exitValue",
          "readGreen",
          "writeBlue",
          "startLoop",
          "IPAddress",
          "isPressed",
          "sendSysex",
          "pauseMode",
          "gatewayIP",
          "setCursor",
          "getOemKey",
          "tuneWrite",
          "noDisplay",
          "loadImage",
          "switchPIN",
          "onRequest",
          "onReceive",
          "changePIN",
          "playFile",
          "noBuffer",
          "parseInt",
          "overflow",
          "checkPIN",
          "knobRead",
          "beginTFT",
          "bitClear",
          "updateIR",
          "bitWrite",
          "position",
          "writeRGB",
          "highByte",
          "writeRed",
          "setSpeed",
          "readBlue",
          "noStroke",
          "remoteIP",
          "transfer",
          "shutdown",
          "hangCall",
          "beginSMS",
          "endWrite",
          "attached",
          "maintain",
          "noCursor",
          "checkReg",
          "checkPUK",
          "shiftOut",
          "isValid",
          "shiftIn",
          "pulseIn",
          "connect",
          "println",
          "localIP",
          "pinMode",
          "getIMEI",
          "display",
          "noBlink",
          "process",
          "getBand",
          "running",
          "beginSD",
          "drawBMP",
          "lowByte",
          "setBand",
          "release",
          "bitRead",
          "prepare",
          "pointTo",
          "readRed",
          "setMode",
          "noFill",
          "remove",
          "listen",
          "stroke",
          "detach",
          "attach",
          "noTone",
          "exists",
          "buffer",
          "height",
          "bitSet",
          "circle",
          "config",
          "cursor",
          "random",
          "IRread",
          "setDNS",
          "endSMS",
          "getKey",
          "micros",
          "millis",
          "begin",
          "print",
          "write",
          "ready",
          "flush",
          "width",
          "isPIN",
          "blink",
          "clear",
          "press",
          "mkdir",
          "rmdir",
          "close",
          "point",
          "yield",
          "image",
          "BSSID",
          "click",
          "delay",
          "read",
          "text",
          "move",
          "peek",
          "beep",
          "rect",
          "line",
          "open",
          "seek",
          "fill",
          "size",
          "turn",
          "stop",
          "home",
          "find",
          "step",
          "tone",
          "sqrt",
          "RSSI",
          "SSID",
          "end",
          "bit",
          "tan",
          "cos",
          "sin",
          "pow",
          "map",
          "abs",
          "max",
          "min",
          "get",
          "run",
          "put"
        ],
        literal: [
          "DIGITAL_MESSAGE",
          "FIRMATA_STRING",
          "ANALOG_MESSAGE",
          "REPORT_DIGITAL",
          "REPORT_ANALOG",
          "INPUT_PULLUP",
          "SET_PIN_MODE",
          "INTERNAL2V56",
          "SYSTEM_RESET",
          "LED_BUILTIN",
          "INTERNAL1V1",
          "SYSEX_START",
          "INTERNAL",
          "EXTERNAL",
          "DEFAULT",
          "OUTPUT",
          "INPUT",
          "HIGH",
          "LOW"
        ]
      }, n = jT(t2), o = (
        /** @type {Record<string,any>} */
        n.keywords
      );
      return o.type = [
        ...o.type,
        ...e.type
      ], o.literal = [
        ...o.literal,
        ...e.literal
      ], o.built_in = [
        ...o.built_in,
        ...e.built_in
      ], o._hints = e._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
    }
    function ST(t2) {
      const e = t2.regex, n = {}, o = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [n]
          }
          // default values
        ]
      };
      Object.assign(n, {
        className: "variable",
        variants: [
          { begin: e.concat(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            "(?![\\w\\d])(?![$])"
          ) },
          o
        ]
      });
      const i = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [t2.BACKSLASH_ESCAPE]
      }, s = t2.inherit(
        t2.COMMENT(),
        {
          match: [
            /(^|\s)/,
            /#.*$/
          ],
          scope: {
            2: "comment"
          }
        }
      ), r = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          t2.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      }, a = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          t2.BACKSLASH_ESCAPE,
          n,
          i
        ]
      };
      i.contains.push(a);
      const l = {
        match: /\\"/
      }, c2 = {
        className: "string",
        begin: /'/,
        end: /'/
      }, u = {
        match: /\\'/
      }, d = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          t2.NUMBER_MODE,
          n
        ]
      }, p2 = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ], m = t2.SHEBANG({
        binary: `(${p2.join("|")})`,
        relevance: 10
      }), f = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [t2.inherit(t2.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      }, _ = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ], h2 = [
        "true",
        "false"
      ], g = { match: /(\/[a-z._-]+)+/ }, k = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ], j = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ], v = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ], C = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        // "false", // keyword literal already
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        // "true", // keyword literal already
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: _,
          literal: h2,
          built_in: [
            ...k,
            ...j,
            // Shell modifiers
            "set",
            "shopt",
            ...v,
            ...C
          ]
        },
        contains: [
          m,
          // to catch known shells and boost relevancy
          t2.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          f,
          d,
          s,
          r,
          g,
          a,
          l,
          c2,
          u,
          n
        ]
      };
    }
    function CT(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", r = "(" + o + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        variants: [
          { begin: "\\b[a-z\\d_]*_t\\b" },
          { match: /\batomic_[a-z]{3,6}\b/ }
        ]
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          { match: /\b(0b[01']+)/ },
          { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
          { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i) + t2.IDENT_RE,
        relevance: 0
      }, m = e.optional(i) + t2.IDENT_RE + "\\s*\\(", h2 = {
        keyword: [
          "asm",
          "auto",
          "break",
          "case",
          "continue",
          "default",
          "do",
          "else",
          "enum",
          "extern",
          "for",
          "fortran",
          "goto",
          "if",
          "inline",
          "register",
          "restrict",
          "return",
          "sizeof",
          "typeof",
          "typeof_unqual",
          "struct",
          "switch",
          "typedef",
          "union",
          "volatile",
          "while",
          "_Alignas",
          "_Alignof",
          "_Atomic",
          "_Generic",
          "_Noreturn",
          "_Static_assert",
          "_Thread_local",
          // aliases
          "alignas",
          "alignof",
          "noreturn",
          "static_assert",
          "thread_local",
          // not a C keyword but is, for all intents and purposes, treated exactly like one.
          "_Pragma"
        ],
        type: [
          "float",
          "double",
          "signed",
          "unsigned",
          "int",
          "short",
          "long",
          "char",
          "void",
          "_Bool",
          "_BitInt",
          "_Complex",
          "_Imaginary",
          "_Decimal32",
          "_Decimal64",
          "_Decimal96",
          "_Decimal128",
          "_Decimal64x",
          "_Decimal128x",
          "_Float16",
          "_Float32",
          "_Float64",
          "_Float128",
          "_Float32x",
          "_Float64x",
          "_Float128x",
          // modifiers
          "const",
          "static",
          "constexpr",
          // aliases
          "complex",
          "bool",
          "imaginary"
        ],
        literal: "true false NULL",
        // TODO: apply hinting work similar to what was done in cpp.js
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      }, g = [
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], k = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: h2,
        contains: g.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: h2,
            contains: g.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, j = {
        begin: "(" + r + "[\\*&\\s]+)+" + m,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: h2,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: h2,
            relevance: 0
          },
          {
            begin: m,
            returnBegin: true,
            contains: [t2.inherit(p2, { className: "title.function" })],
            relevance: 0
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: h2,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: h2,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: h2,
        // Until differentiations are added between `c` and `cpp`, `c` will
        // not be auto-detected to avoid auto-detect conflicts between C and C++
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(
          k,
          j,
          g,
          [
            d,
            {
              begin: t2.IDENT_RE + "::",
              keywords: h2
            },
            {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [
                { beginKeywords: "final class struct" },
                t2.TITLE_MODE
              ]
            }
          ]
        ),
        exports: {
          preprocessor: d,
          strings: c2,
          keywords: h2
        }
      };
    }
    function xT(t2) {
      const e = t2.regex, n = t2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", r = "(?!struct)(" + o + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          t2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t2.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          n,
          t2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i) + t2.IDENT_RE,
        relevance: 0
      }, m = e.optional(i) + t2.IDENT_RE + "\\s*\\(", f = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], _ = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], h2 = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], g = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: _,
        keyword: f,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: h2
      }, C = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: g
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          t2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, E = [
        C,
        d,
        a,
        n,
        t2.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], B = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: E.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: E.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, U = {
        className: "function",
        begin: "(" + r + "[\\*&\\s]+)+" + m,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: v,
            relevance: 0
          },
          {
            begin: m,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              n,
              t2.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  n,
                  t2.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          n,
          t2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          B,
          U,
          C,
          E,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: t2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function TT(t2) {
      const e = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ], n = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ], o = [
        "default",
        "false",
        "null",
        "true"
      ], i = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ], s = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ], r = {
        keyword: i.concat(s),
        built_in: e,
        literal: o
      }, a = t2.inherit(t2.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      }, c2 = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      }, u = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      }, d = t2.inherit(u, { illegal: /\n/ }), p2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: r
      }, m = t2.inherit(p2, { illegal: /\n/ }), f = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          t2.BACKSLASH_ESCAPE,
          m
        ]
      }, _ = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          p2
        ]
      }, h2 = t2.inherit(_, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          m
        ]
      });
      p2.contains = [
        _,
        f,
        u,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        l,
        t2.C_BLOCK_COMMENT_MODE
      ], m.contains = [
        h2,
        f,
        d,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        l,
        t2.inherit(t2.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const g = { variants: [
        c2,
        _,
        f,
        u,
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE
      ] }, k = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          a
        ]
      }, j = t2.IDENT_RE + "(<" + t2.IDENT_RE + "(\\s*,\\s*" + t2.IDENT_RE + ")*>)?(\\[\\])?", v = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + t2.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: r,
        illegal: /::/,
        contains: [
          t2.COMMENT(
            "///",
            "$",
            {
              returnBegin: true,
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: "///",
                      relevance: 0
                    },
                    { begin: "<!--|-->" },
                    {
                      begin: "</?",
                      end: ">"
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          g,
          l,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              a,
              k,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              k,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + j + "\\s+)+" + t2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: r,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: n.join(" "),
                relevance: 0
              },
              {
                begin: t2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  t2.TITLE_MODE,
                  k
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: r,
                relevance: 0,
                contains: [
                  g,
                  l,
                  t2.C_BLOCK_COMMENT_MODE
                ]
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          v
        ]
      };
    }
    const OT = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), NT = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], AT = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], MT = [
      ...NT,
      ...AT
    ], RT = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), IT = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), DT = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), LT = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function PT(t2) {
      const e = t2.regex, n = OT(t2), o = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", s = /@-?\w[\w]*(-\w+)*/, r = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          n.BLOCK_COMMENT,
          o,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          n.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + r,
            relevance: 0
          },
          n.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + IT.join("|") + ")" },
              { begin: ":(:)?(" + DT.join("|") + ")" }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          n.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + LT.join("|") + ")\\b"
          },
          // attribute values
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              n.BLOCK_COMMENT,
              n.HEXCOLOR,
              n.IMPORTANT,
              n.CSS_NUMBER_MODE,
              ...a,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                // from keywords
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...a,
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              n.FUNCTION_DISPATCH
            ]
          },
          {
            begin: e.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            // break on Less variables @var: ...
            contains: [
              {
                className: "keyword",
                begin: s
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: i,
                  attribute: RT.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...a,
                  n.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + MT.join("|") + ")\\b"
          }
        ]
      };
    }
    function BT(t2) {
      const e = t2.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: e.either(
              /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
              /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
              /^--- +\d+,\d+ +----$/
            )
          },
          {
            className: "comment",
            variants: [
              {
                begin: e.either(
                  /Index: /,
                  /^index/,
                  /={3,}/,
                  /^-{3}/,
                  /^\*{3} /,
                  /^\+{3}/,
                  /^diff --git/
                ),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    function $T(t2) {
      const s = {
        keyword: [
          "break",
          "case",
          "chan",
          "const",
          "continue",
          "default",
          "defer",
          "else",
          "fallthrough",
          "for",
          "func",
          "go",
          "goto",
          "if",
          "import",
          "interface",
          "map",
          "package",
          "range",
          "return",
          "select",
          "struct",
          "switch",
          "type",
          "var"
        ],
        type: [
          "bool",
          "byte",
          "complex64",
          "complex128",
          "error",
          "float32",
          "float64",
          "int8",
          "int16",
          "int32",
          "int64",
          "string",
          "uint8",
          "uint16",
          "uint32",
          "uint64",
          "int",
          "uint",
          "uintptr",
          "rune"
        ],
        literal: [
          "true",
          "false",
          "iota",
          "nil"
        ],
        built_in: [
          "append",
          "cap",
          "close",
          "complex",
          "copy",
          "imag",
          "len",
          "make",
          "new",
          "panic",
          "print",
          "println",
          "real",
          "recover",
          "delete"
        ]
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: s,
        illegal: "</",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                // hex without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                // hex with a present digit before . (making a digit afterwards optional)
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                // leading 0o octal
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                // decimal without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                // decimal with a present digit before . (making a digit afterwards optional)
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
            // relevance booster
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              t2.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: s,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    function zT(t2) {
      const e = t2.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: [
            "true",
            "false",
            "null"
          ]
        },
        contains: [
          t2.HASH_COMMENT_MODE,
          t2.QUOTE_STRING_MODE,
          t2.NUMBER_MODE,
          {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          },
          {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          },
          {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          },
          {
            scope: "meta",
            match: /@\w+/,
            excludeEnd: true
          },
          {
            scope: "symbol",
            begin: e.concat(n, e.lookahead(/\s*:/)),
            relevance: 0
          }
        ],
        illegal: [
          /[;<']/,
          /BEGIN/
        ]
      };
    }
    function FT(t2) {
      const e = t2.regex, n = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: /([+-]+)?[\d]+_[\d_]+/ },
          { begin: t2.NUMBER_RE }
        ]
      }, o = t2.COMMENT();
      o.variants = [
        {
          begin: /;/,
          end: /$/
        },
        {
          begin: /#/,
          end: /$/
        }
      ];
      const i = {
        className: "variable",
        variants: [
          { begin: /\$[\w\d"][\w\d_]*/ },
          { begin: /\$\{(.*?)\}/ }
        ]
      }, s = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      }, r = {
        className: "string",
        contains: [t2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: "'''",
            end: "'''",
            relevance: 10
          },
          {
            begin: '"""',
            end: '"""',
            relevance: 10
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "'",
            end: "'"
          }
        ]
      }, a = {
        begin: /\[/,
        end: /\]/,
        contains: [
          o,
          s,
          i,
          r,
          n,
          "self"
        ],
        relevance: 0
      }, l = /[A-Za-z0-9_-]+/, c2 = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
        l,
        c2,
        u
      ), p2 = e.concat(
        d,
        "(\\s*\\.\\s*",
        d,
        ")*",
        e.lookahead(/\s*=\s*[^#\s]/)
      );
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [
          o,
          {
            className: "section",
            begin: /\[+/,
            end: /\]+/
          },
          {
            begin: p2,
            className: "attr",
            starts: {
              end: /$/,
              contains: [
                o,
                a,
                s,
                i,
                r,
                n
              ]
            }
          }
        ]
      };
    }
    var wi = "[0-9](_*[0-9])*", _r = `\\.(${wi})`, hr = "[0-9a-fA-F](_*[0-9a-fA-F])*", Xp = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${wi})((${_r})|\\.)?|(${_r}))[eE][+-]?(${wi})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${wi})((${_r})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${_r})[fFdD]?\\b` },
        { begin: `\\b(${wi})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hr})\\.?|(${hr})?\\.(${hr}))[pP][+-]?(${wi})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${hr})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function _h(t2, e, n) {
      return n === -1 ? "" : t2.replace(e, (o) => _h(t2, e, n - 1));
    }
    function HT(t2) {
      const e = t2.regex, n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", o = n + _h("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
        keyword: [
          "synchronized",
          "abstract",
          "private",
          "var",
          "static",
          "if",
          "const ",
          "for",
          "while",
          "strictfp",
          "finally",
          "protected",
          "import",
          "native",
          "final",
          "void",
          "enum",
          "else",
          "break",
          "transient",
          "catch",
          "instanceof",
          "volatile",
          "case",
          "assert",
          "package",
          "default",
          "public",
          "try",
          "switch",
          "continue",
          "throws",
          "protected",
          "public",
          "private",
          "module",
          "requires",
          "exports",
          "do",
          "sealed",
          "yield",
          "permits",
          "goto",
          "when"
        ],
        literal: [
          "false",
          "true",
          "null"
        ],
        type: [
          "char",
          "boolean",
          "long",
          "float",
          "int",
          "byte",
          "short",
          "double"
        ],
        built_in: [
          "super",
          "this"
        ]
      }, c2 = {
        className: "meta",
        begin: "@" + n,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
            // allow nested () inside our annotation
          }
        ]
      }, u = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: l,
        relevance: 0,
        contains: [t2.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: l,
        illegal: /<\/|#/,
        contains: [
          t2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/,
                  relevance: 0
                },
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              n
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            // Exceptions for hyphenated keywords
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              e.concat(/(?!else)/, n),
              /\s+/,
              n,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              n
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              u,
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + o + "\\s+)",
              t2.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: l,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: l,
                relevance: 0,
                contains: [
                  c2,
                  t2.APOS_STRING_MODE,
                  t2.QUOTE_STRING_MODE,
                  Xp,
                  t2.C_BLOCK_COMMENT_MODE
                ]
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          Xp,
          c2
        ]
      };
    }
    const Zp = "[A-Za-z$_][0-9A-Za-z$_]*", UT = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], VT = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], hh = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], gh = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], vh = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], qT = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], KT = [].concat(
      vh,
      hh,
      gh
    );
    function WT(t2) {
      const e = t2.regex, n = (L, { after: J }) => {
        const se = "</" + L[0].slice(1);
        return L.input.indexOf(se, J) !== -1;
      }, o = Zp, i = {
        begin: "<>",
        end: "</>"
      }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, r = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, J) => {
          const se = L[0].length + L.index, ue = L.input[se];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ue === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ue === ","
          ) {
            J.ignoreMatch();
            return;
          }
          ue === ">" && (n(L, { after: se }) || J.ignoreMatch());
          let Se;
          const He = L.input.substring(se);
          if (Se = He.match(/^\s*=/)) {
            J.ignoreMatch();
            return;
          }
          if ((Se = He.match(/^\s+extends\s+/)) && Se.index === 0) {
            J.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: Zp,
        keyword: UT,
        literal: VT,
        built_in: KT,
        "variable.language": qT
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, m = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, f = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, _ = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, h2 = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          t2.BACKSLASH_ESCAPE,
          p2
        ]
      }, k = {
        className: "comment",
        variants: [
          t2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: o + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_LINE_COMMENT_MODE
        ]
      }, j = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        m,
        f,
        _,
        h2,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = j.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(j)
      });
      const v = [].concat(k, p2.contains), C = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), E = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: C
      }, B = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              o,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(o, "(", e.concat(/\./, o), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              o
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, U = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...hh,
            ...gh
          ]
        }
      }, P = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, V = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              o,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [E],
        illegal: /%/
      }, ne = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function pe(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const we = {
        match: e.concat(
          /\b/,
          pe([
            ...vh,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          o,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, ye = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(o, /(?![0-9A-Za-z$_(])/)
        )),
        end: o,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, _e = {
        match: [
          /get|set/,
          /\s+/,
          o,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          E
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          o,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          E
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: C, CLASS_REFERENCE: U },
        illegal: /#(?![$_A-z])/,
        contains: [
          t2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          P,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          m,
          f,
          _,
          h2,
          k,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          U,
          {
            scope: "attr",
            match: o + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + t2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              k,
              t2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: t2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: C
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: i.begin, end: i.end },
                  { match: s },
                  {
                    begin: r.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": r.isTrulyOpeningTag,
                    end: r.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: r.begin,
                    end: r.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          V,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + t2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              E,
              t2.inherit(t2.TITLE_MODE, { begin: o, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          ye,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + o,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [E]
          },
          we,
          ne,
          B,
          _e,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function GT(t2) {
      const e = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      }, n = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      }, o = [
        "true",
        "false",
        "null"
      ], i = {
        scope: "literal",
        beginKeywords: o.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: o
        },
        contains: [
          e,
          n,
          t2.QUOTE_STRING_MODE,
          i,
          t2.C_NUMBER_MODE,
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    var ji = "[0-9](_*[0-9])*", gr = `\\.(${ji})`, vr = "[0-9a-fA-F](_*[0-9a-fA-F])*", JT = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${ji})((${gr})|\\.)?|(${gr}))[eE][+-]?(${ji})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${ji})((${gr})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${gr})[fFdD]?\\b` },
        { begin: `\\b(${ji})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${vr})\\.?|(${vr})?\\.(${vr}))[pP][+-]?(${ji})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${vr})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function YT(t2) {
      const e = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      }, n = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      }, o = {
        className: "symbol",
        begin: t2.UNDERSCORE_IDENT_RE + "@"
      }, i = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [t2.C_NUMBER_MODE]
      }, s = {
        className: "variable",
        begin: "\\$" + t2.UNDERSCORE_IDENT_RE
      }, r = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              s,
              i
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [t2.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              s,
              i
            ]
          }
        ]
      };
      i.contains.push(r);
      const a = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t2.UNDERSCORE_IDENT_RE + ")?"
      }, l = {
        className: "meta",
        begin: "@" + t2.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              t2.inherit(r, { className: "string" }),
              "self"
            ]
          }
        ]
      }, c2 = JT, u = t2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [t2.C_BLOCK_COMMENT_MODE] }
      ), d = { variants: [
        {
          className: "type",
          begin: t2.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
          // defined later
        }
      ] }, p2 = d;
      return p2.variants[1].contains = [d], d.variants[1].contains = [p2], {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: e,
        contains: [
          t2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          t2.C_LINE_COMMENT_MODE,
          u,
          n,
          o,
          a,
          l,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: e,
            relevance: 5,
            contains: [
              {
                begin: t2.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [t2.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: e,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      d,
                      t2.C_LINE_COMMENT_MODE,
                      u
                    ],
                    relevance: 0
                  },
                  t2.C_LINE_COMMENT_MODE,
                  u,
                  a,
                  l,
                  r,
                  t2.C_NUMBER_MODE
                ]
              },
              u
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              t2.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              t2.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              a,
              l
            ]
          },
          r,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: `
`
          },
          c2
        ]
      };
    }
    const XT = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), ZT = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], QT = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], eO = [
      ...ZT,
      ...QT
    ], tO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), bh = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), kh = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), nO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse(), oO = bh.concat(kh).sort().reverse();
    function iO(t2) {
      const e = XT(t2), n = oO, o = "and or not only", i = "[\\w-]+", s = "(" + i + "|@\\{" + i + "\\})", r = [], a = [], l = function(j) {
        return {
          // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
          className: "string",
          begin: "~?" + j + ".*?" + j
        };
      }, c2 = function(j, v, C) {
        return {
          className: j,
          begin: v,
          relevance: C
        };
      }, u = {
        $pattern: /[a-z-]+/,
        keyword: o,
        attribute: tO.join(" ")
      }, d = {
        // used only to properly balance nested parens inside mixin call, def. arg list
        begin: "\\(",
        end: "\\)",
        contains: a,
        keywords: u,
        relevance: 0
      };
      a.push(
        t2.C_LINE_COMMENT_MODE,
        t2.C_BLOCK_COMMENT_MODE,
        l("'"),
        l('"'),
        e.CSS_NUMBER_MODE,
        // fixme: it does not include dot for numbers like .5em :(
        {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        },
        e.HEXCOLOR,
        d,
        c2("variable", "@@?" + i, 10),
        c2("variable", "@\\{" + i + "\\}"),
        c2("built_in", "~?`[^`]*?`"),
        // inline javascript (or whatever host language) *multiline* string
        {
          // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
          className: "attribute",
          begin: i + "\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        },
        e.IMPORTANT,
        { beginKeywords: "and not" },
        e.FUNCTION_DISPATCH
      );
      const p2 = a.concat({
        begin: /\{/,
        end: /\}/,
        contains: r
      }), m = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{ beginKeywords: "and not" }].concat(a)
        // using this form to override VALUE’s 'function' match
      }, f = {
        begin: s + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + nO.join("|") + ")\\b",
            end: /(?=:)/,
            starts: {
              endsWithParent: true,
              illegal: "[<=$]",
              relevance: 0,
              contains: a
            }
          }
        ]
      }, _ = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: u,
          returnEnd: true,
          contains: a,
          relevance: 0
        }
      }, h2 = {
        className: "variable",
        variants: [
          // using more strict pattern for higher relevance to increase chances of Less detection.
          // this is *the only* Less specific statement used in most of the sources, so...
          // (we’ll still often loose to the css-parser unless there's '//' comment,
          // simply because 1 variable just can't beat 99 properties :)
          {
            begin: "@" + i + "\\s*:",
            relevance: 15
          },
          { begin: "@" + i }
        ],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: p2
        }
      }, g = {
        // first parse unambiguous selectors (i.e. those not starting with tag)
        // then fall into the scary lookahead-discriminator variant.
        // this mode also handles mixin definitions and calls
        variants: [
          {
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
            // mixin calls end with ';'
          },
          {
            begin: s,
            end: /\{/
          }
        ],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          m,
          c2("keyword", "all\\b"),
          c2("variable", "@\\{" + i + "\\}"),
          // otherwise it’s identified as tag
          {
            begin: "\\b(" + eO.join("|") + ")\\b",
            className: "selector-tag"
          },
          e.CSS_NUMBER_MODE,
          c2("selector-tag", s, 0),
          c2("selector-id", "#" + s),
          c2("selector-class", "\\." + s, 0),
          c2("selector-tag", "&", 0),
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            begin: ":(" + bh.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + kh.join("|") + ")"
          },
          {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: p2
          },
          // argument list of parametric mixins
          { begin: "!important" },
          // eat !important after mixin call or it will be colored as tag
          e.FUNCTION_DISPATCH
        ]
      }, k = {
        begin: i + `:(:)?(${n.join("|")})`,
        returnBegin: true,
        contains: [g]
      };
      return r.push(
        t2.C_LINE_COMMENT_MODE,
        t2.C_BLOCK_COMMENT_MODE,
        _,
        h2,
        k,
        f,
        g,
        m,
        e.FUNCTION_DISPATCH
      ), {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: r
      };
    }
    function sO(t2) {
      const e = "\\[=*\\[", n = "\\]=*\\]", o = {
        begin: e,
        end: n,
        contains: ["self"]
      }, i = [
        t2.COMMENT("--(?!" + e + ")", "$"),
        t2.COMMENT(
          "--" + e,
          n,
          {
            contains: [o],
            relevance: 10
          }
        )
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: t2.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: (
            // Metatags and globals:
            "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          )
        },
        contains: i.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              t2.inherit(t2.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: i
              }
            ].concat(i)
          },
          t2.C_NUMBER_MODE,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: e,
            end: n,
            contains: [o],
            relevance: 5
          }
        ])
      };
    }
    function rO(t2) {
      const e = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + t2.UNDERSCORE_IDENT_RE + "\\)",
            contains: [t2.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      }, n = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          t2.BACKSLASH_ESCAPE,
          e
        ]
      }, o = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          e,
          n
          // Added QUOTE_STRING as they can be a part of functions
        ]
      }, i = { begin: "^" + t2.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, s = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      }, r = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [e]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          t2.HASH_COMMENT_MODE,
          e,
          n,
          o,
          i,
          s,
          r
        ]
      };
    }
    function aO(t2) {
      const e = t2.regex, n = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      }, o = {
        begin: "^[-\\*]{3,}",
        end: "$"
      }, i = {
        className: "code",
        variants: [
          // TODO: fix to allow these to work with sublanguage also
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          // needed to allow markdown as a sublanguage to work
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            // use contains to gobble up multiple lines to allow the block to be whatever size
            // but only have a single open/close tag vs one per line
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      }, s = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      }, r = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
        variants: [
          // too much like nested array access in so many languages
          // to have any real relevance
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          // popular internet URLs
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
            relevance: 2
          },
          // relative urls
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          // whatever else, lower relevance (might not be a link at all)
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            // empty strings for alt or link text
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      }, c2 = {
        className: "strong",
        contains: [],
        // defined later
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      }, u = {
        className: "emphasis",
        contains: [],
        // defined later
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      }, d = t2.inherit(c2, { contains: [] }), p2 = t2.inherit(u, { contains: [] });
      c2.contains.push(p2), u.contains.push(d);
      let m = [
        n,
        l
      ];
      return [
        c2,
        u,
        d,
        p2
      ].forEach((g) => {
        g.contains = g.contains.concat(m);
      }), m = m.concat(c2, u), {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          {
            className: "section",
            variants: [
              {
                begin: "^#{1,6}",
                end: "$",
                contains: m
              },
              {
                begin: "(?=^.+?\\n[=-]{2,}$)",
                contains: [
                  { begin: "^[=-]*$" },
                  {
                    begin: "^",
                    end: "\\n",
                    contains: m
                  }
                ]
              }
            ]
          },
          n,
          s,
          c2,
          u,
          {
            className: "quote",
            begin: "^>\\s+",
            contains: m,
            end: "$"
          },
          i,
          o,
          l,
          r,
          {
            //https://spec.commonmark.org/0.31.2/#entity-references
            scope: "literal",
            match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
          }
        ]
      };
    }
    function lO(t2) {
      const e = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: n,
        keyword: [
          "while",
          "export",
          "sizeof",
          "typedef",
          "const",
          "struct",
          "for",
          "union",
          "volatile",
          "static",
          "mutable",
          "if",
          "do",
          "return",
          "goto",
          "enum",
          "else",
          "break",
          "extern",
          "asm",
          "case",
          "default",
          "register",
          "explicit",
          "typename",
          "switch",
          "continue",
          "inline",
          "readonly",
          "assign",
          "readwrite",
          "self",
          "@synchronized",
          "id",
          "typeof",
          "nonatomic",
          "IBOutlet",
          "IBAction",
          "strong",
          "weak",
          "copy",
          "in",
          "out",
          "inout",
          "bycopy",
          "byref",
          "oneway",
          "__strong",
          "__weak",
          "__block",
          "__autoreleasing",
          "@private",
          "@protected",
          "@public",
          "@try",
          "@property",
          "@end",
          "@throw",
          "@catch",
          "@finally",
          "@autoreleasepool",
          "@synthesize",
          "@dynamic",
          "@selector",
          "@optional",
          "@required",
          "@encode",
          "@package",
          "@import",
          "@defs",
          "@compatibility_alias",
          "__bridge",
          "__bridge_transfer",
          "__bridge_retained",
          "__bridge_retain",
          "__covariant",
          "__contravariant",
          "__kindof",
          "_Nonnull",
          "_Nullable",
          "_Null_unspecified",
          "__FUNCTION__",
          "__PRETTY_FUNCTION__",
          "__attribute__",
          "getter",
          "setter",
          "retain",
          "unsafe_unretained",
          "nonnull",
          "nullable",
          "null_unspecified",
          "null_resettable",
          "class",
          "instancetype",
          "NS_DESIGNATED_INITIALIZER",
          "NS_UNAVAILABLE",
          "NS_REQUIRES_SUPER",
          "NS_RETURNS_INNER_POINTER",
          "NS_INLINE",
          "NS_AVAILABLE",
          "NS_DEPRECATED",
          "NS_ENUM",
          "NS_OPTIONS",
          "NS_SWIFT_UNAVAILABLE",
          "NS_ASSUME_NONNULL_BEGIN",
          "NS_ASSUME_NONNULL_END",
          "NS_REFINED_FOR_SWIFT",
          "NS_SWIFT_NAME",
          "NS_SWIFT_NOTHROW",
          "NS_DURING",
          "NS_HANDLER",
          "NS_ENDHANDLER",
          "NS_VALUERETURN",
          "NS_VOIDRETURN"
        ],
        literal: [
          "false",
          "true",
          "FALSE",
          "TRUE",
          "nil",
          "YES",
          "NO",
          "NULL"
        ],
        built_in: [
          "dispatch_once_t",
          "dispatch_queue_t",
          "dispatch_sync",
          "dispatch_async",
          "dispatch_once"
        ],
        type: [
          "int",
          "float",
          "char",
          "unsigned",
          "signed",
          "short",
          "long",
          "double",
          "wchar_t",
          "unichar",
          "void",
          "bool",
          "BOOL",
          "id|0",
          "_Bool"
        ]
      }, l = {
        $pattern: n,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: a,
        illegal: "</",
        contains: [
          e,
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_NUMBER_MODE,
          t2.QUOTE_STRING_MODE,
          t2.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [t2.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              t2.inherit(t2.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              t2.C_LINE_COMMENT_MODE,
              t2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + l.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: l,
            contains: [t2.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + t2.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    function cO(t2) {
      const e = t2.regex, n = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ], o = /[dualxmsipngr]{0,12}/, i = {
        $pattern: /[\w.]+/,
        keyword: n.join(" ")
      }, s = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: i
      }, r = {
        begin: /->\{/,
        end: /\}/
        // contains defined later
      }, a = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      }, l = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: e.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              // negative look-ahead tries to avoid matching patterns that are not
              // Perl at all like $ident$, @ident@, etc.
              "(?![A-Za-z])(?![@$%])"
            )
          },
          {
            // Only $= is a special Perl variable and one can't declare @= or %=.
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [a]
      }, c2 = {
        className: "number",
        variants: [
          // decimal numbers:
          // include the case where a number starts with a dot (eg. .9), and
          // the leading 0? avoids mixing the first and second match on 0.x cases
          { match: /0?\.[0-9][0-9_]+\b/ },
          // include the special versioned number (eg. v5.38)
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          // non-decimal numbers:
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      }, u = [
        t2.BACKSLASH_ESCAPE,
        s,
        l
      ], d = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        // valid but infrequent and weird
        /#/
        // valid but infrequent and weird
      ], p2 = (_, h2, g = "\\1") => {
        const k = g === "\\1" ? g : e.concat(g, h2);
        return e.concat(
          e.concat("(?:", _, ")"),
          h2,
          /(?:\\.|[^\\\/])*?/,
          k,
          /(?:\\.|[^\\\/])*?/,
          g,
          o
        );
      }, m = (_, h2, g) => e.concat(
        e.concat("(?:", _, ")"),
        h2,
        /(?:\\.|[^\\\/])*?/,
        g,
        o
      ), f = [
        l,
        t2.HASH_COMMENT_MODE,
        t2.COMMENT(
          /^=\w/,
          /=cut/,
          { endsWithParent: true }
        ),
        r,
        {
          className: "string",
          contains: u,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [t2.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [t2.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        c2,
        {
          // regexp container
          begin: "(\\/\\/|" + t2.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            t2.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                // allow matching common delimiters
                { begin: p2("s|tr|y", e.either(...d, { capture: true })) },
                // and then paired delmis
                { begin: p2("s|tr|y", "\\(", "\\)") },
                { begin: p2("s|tr|y", "\\[", "\\]") },
                { begin: p2("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  // could be a comment in many languages so do not count
                  // as relevant
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                // prefix is optional with /regex/
                { begin: m("(?:m|qr)?", /\//, /\//) },
                // allow matching common delimiters
                { begin: m("m|qr", e.either(...d, { capture: true }), /\1/) },
                // allow common paired delmins
                { begin: m("m|qr", /\(/, /\)/) },
                { begin: m("m|qr", /\[/, /\]/) },
                { begin: m("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [t2.TITLE_MODE, a]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [t2.TITLE_MODE, a, c2]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      return s.contains = f, r.contains = f, {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: i,
        contains: f
      };
    }
    function uO(t2) {
      const e = t2.regex, n = /(?![A-Za-z0-9])(?![$])/, o = e.concat(
        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
        n
      ), i = e.concat(
        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
        n
      ), s = e.concat(
        /[A-Z]+/,
        n
      ), r = {
        scope: "variable",
        match: "\\$+" + o
      }, a = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          // boost for obvious PHP
          { begin: /<\?=/ },
          // less relevant per PSR-1 which says not to use short-tags
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
          // end php tag
        ]
      }, l = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      }, c2 = t2.inherit(t2.APOS_STRING_MODE, { illegal: null }), u = t2.inherit(t2.QUOTE_STRING_MODE, {
        illegal: null,
        contains: t2.QUOTE_STRING_MODE.contains.concat(l)
      }), d = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: t2.QUOTE_STRING_MODE.contains.concat(l),
        "on:begin": (ye, _e) => {
          _e.data._beginMatch = ye[1] || ye[2];
        },
        "on:end": (ye, _e) => {
          _e.data._beginMatch !== ye[1] && _e.ignoreMatch();
        }
      }, p2 = t2.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      }), m = `[ 	
]`, f = {
        scope: "string",
        variants: [
          u,
          c2,
          d,
          p2
        ]
      }, _ = {
        scope: "number",
        variants: [
          { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
          // Binary w/ underscore support
          { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
          // Octals w/ underscore support
          { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
          // Hex w/ underscore support
          // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
          { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
        ],
        relevance: 0
      }, h2 = [
        "false",
        "null",
        "true"
      ], g = [
        // Magic constants:
        // <https://www.php.net/manual/en/language.constants.predefined.php>
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        // Function that look like language construct or language construct that look like function:
        // List of keywords that may not require parenthesis
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
        // Other keywords:
        // <https://www.php.net/manual/en/reserved.php>
        // <https://www.php.net/manual/en/language.types.type-juggling.php>
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ], k = [
        // Standard PHP library:
        // <https://www.php.net/manual/en/book.spl.php>
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        // Reserved interfaces:
        // <https://www.php.net/manual/en/reserved.interfaces.php>
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        // Reserved classes:
        // <https://www.php.net/manual/en/reserved.classes.php>
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ], v = {
        keyword: g,
        literal: ((ye) => {
          const _e = [];
          return ye.forEach((he) => {
            _e.push(he), he.toLowerCase() === he ? _e.push(he.toUpperCase()) : _e.push(he.toLowerCase());
          }), _e;
        })(h2),
        built_in: k
      }, C = (ye) => ye.map((_e) => _e.replace(/\|\d+$/, "")), E = { variants: [
        {
          match: [
            /new/,
            e.concat(m, "+"),
            // to prevent built ins from being confused as the class constructor call
            e.concat("(?!", C(k).join("\\b|"), "\\b)"),
            i
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] }, B = e.concat(o, "\\b(?!\\()"), U = { variants: [
        {
          match: [
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            B
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            i,
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            B
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            i,
            e.concat(
              "::",
              e.lookahead(/(?!class\b)/)
            )
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            i,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] }, P = {
        scope: "attr",
        match: e.concat(o, e.lookahead(":"), e.lookahead(/(?!::)/))
      }, V = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: [
          P,
          r,
          U,
          t2.C_BLOCK_COMMENT_MODE,
          f,
          _,
          E
        ]
      }, ne = {
        relevance: 0,
        match: [
          /\b/,
          // to prevent keywords from being confused as the function title
          e.concat("(?!fn\\b|function\\b|", C(g).join("\\b|"), "|", C(k).join("\\b|"), "\\b)"),
          o,
          e.concat(m, "*"),
          e.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [V]
      };
      V.contains.push(ne);
      const pe = [
        P,
        U,
        t2.C_BLOCK_COMMENT_MODE,
        f,
        _,
        E
      ], we = {
        begin: e.concat(
          /#\[\s*\\?/,
          e.either(
            i,
            s
          )
        ),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: h2,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: h2,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...pe
            ]
          },
          ...pe,
          {
            scope: "meta",
            variants: [
              { match: i },
              { match: s }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: v,
        contains: [
          we,
          t2.HASH_COMMENT_MODE,
          t2.COMMENT("//", "$"),
          t2.COMMENT(
            "/\\*",
            "\\*/",
            { contains: [
              {
                scope: "doctag",
                match: "@[A-Za-z]+"
              }
            ] }
          ),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: t2.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          a,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          r,
          ne,
          U,
          {
            match: [
              /const/,
              /\s/,
              o
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          E,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              t2.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                // No markup, just a relevance booster
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: v,
                contains: [
                  "self",
                  we,
                  r,
                  U,
                  t2.C_BLOCK_COMMENT_MODE,
                  f,
                  _
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              t2.UNDERSCORE_TITLE_MODE
            ]
          },
          // both use and namespace still use "old style" rules (vs multi-match)
          // because the namespace name can include `\` and we still want each
          // element to be treated as its own *individual* title
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [t2.inherit(t2.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              // TODO: title.function vs title.class
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              // TODO: could be title.class or title.function
              t2.UNDERSCORE_TITLE_MODE
            ]
          },
          f,
          _
        ]
      };
    }
    function dO(t2) {
      return {
        name: "PHP template",
        subLanguage: "xml",
        contains: [
          {
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [
              // We don't want the php closing tag ?> to close the PHP block when
              // inside any of the following blocks:
              {
                begin: "/\\*",
                end: "\\*/",
                skip: true
              },
              {
                begin: 'b"',
                end: '"',
                skip: true
              },
              {
                begin: "b'",
                end: "'",
                skip: true
              },
              t2.inherit(t2.APOS_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              }),
              t2.inherit(t2.QUOTE_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              })
            ]
          }
        ]
      };
    }
    function pO(t2) {
      return {
        name: "Plain text",
        aliases: [
          "text",
          "txt"
        ],
        disableAutodetect: true
      };
    }
    function mO(t2) {
      const e = t2.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), o = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ], a = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: o,
        built_in: [
          "__import__",
          "abs",
          "all",
          "any",
          "ascii",
          "bin",
          "bool",
          "breakpoint",
          "bytearray",
          "bytes",
          "callable",
          "chr",
          "classmethod",
          "compile",
          "complex",
          "delattr",
          "dict",
          "dir",
          "divmod",
          "enumerate",
          "eval",
          "exec",
          "filter",
          "float",
          "format",
          "frozenset",
          "getattr",
          "globals",
          "hasattr",
          "hash",
          "help",
          "hex",
          "id",
          "input",
          "int",
          "isinstance",
          "issubclass",
          "iter",
          "len",
          "list",
          "locals",
          "map",
          "max",
          "memoryview",
          "min",
          "next",
          "object",
          "oct",
          "open",
          "ord",
          "pow",
          "print",
          "property",
          "range",
          "repr",
          "reversed",
          "round",
          "set",
          "setattr",
          "slice",
          "sorted",
          "staticmethod",
          "str",
          "sum",
          "super",
          "tuple",
          "type",
          "vars",
          "zip"
        ],
        literal: [
          "__debug__",
          "Ellipsis",
          "False",
          "None",
          "NotImplemented",
          "True"
        ],
        type: [
          "Any",
          "Callable",
          "Coroutine",
          "Dict",
          "List",
          "Literal",
          "Generic",
          "Optional",
          "Sequence",
          "Set",
          "Tuple",
          "Type",
          "Union"
        ]
      }, l = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      }, c2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: a,
        illegal: /#/
      }, u = {
        begin: /\{\{/,
        relevance: 0
      }, d = {
        className: "string",
        contains: [t2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              t2.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      }, p2 = "[0-9](_?[0-9])*", m = `(\\b(${p2}))?\\.(${p2})|\\b(${p2})\\.`, f = `\\b|${o.join("|")}`, _ = {
        className: "number",
        relevance: 0,
        variants: [
          // exponentfloat, pointfloat
          // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
          // optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          // Note: no leading \b because floats can start with a decimal point
          // and we don't want to mishandle e.g. `fn(.5)`,
          // no trailing \b for pointfloat because it can end with a decimal point
          // and we don't want to mishandle e.g. `0..hex()`; this should be safe
          // because both MUST contain a decimal point and so cannot be confused with
          // the interior part of an identifier
          {
            begin: `(\\b(${p2})|(${m}))[eE][+-]?(${p2})[jJ]?(?=${f})`
          },
          {
            begin: `(${m})[jJ]?`
          },
          // decinteger, bininteger, octinteger, hexinteger
          // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
          // optionally "long" in Python 2
          // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
          // decinteger is optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${f})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${f})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${f})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${f})`
          },
          // imagnumber (digitpart-based)
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b(${p2})[jJ](?=${f})`
          }
        ]
      }, h2 = {
        className: "comment",
        begin: e.lookahead(/# type:/),
        end: /$/,
        keywords: a,
        contains: [
          {
            // prevent keywords from coloring `type`
            begin: /# type:/
          },
          // comment within a datatype comment includes no keywords
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      }, g = {
        className: "params",
        variants: [
          // Exclude params in functions without params
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: a,
            contains: [
              "self",
              l,
              _,
              d,
              t2.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      return c2.contains = [
        d,
        _,
        l
      ], {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: a,
        illegal: /(<\/|\?)|=>/,
        contains: [
          l,
          _,
          {
            // very common convention
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            // eat "if" prior to string so that it won't accidentally be
            // labeled as an f-string
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          d,
          h2,
          t2.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              n
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [g]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  n,
                  /\s*/,
                  /\(\s*/,
                  n,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  n
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              _,
              g,
              d
            ]
          }
        ]
      };
    }
    function fO(t2) {
      return {
        aliases: ["pycon"],
        contains: [
          {
            className: "meta.prompt",
            starts: {
              // a space separates the REPL prefix from the actual code
              // this is purely for cleaner HTML output
              end: / |$/,
              starts: {
                end: "$",
                subLanguage: "python"
              }
            },
            variants: [
              { begin: /^>>>(?=[ ]|$)/ },
              { begin: /^\.\.\.(?=[ ]|$)/ }
            ]
          }
        ]
      };
    }
    function _O(t2) {
      const e = t2.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, o = e.either(
        // Special case: only hexadecimal binary powers can contain fractions
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        // Hexadecimal numbers without fraction and optional binary power
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        // Decimal numbers
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, s = e.either(
        /[()]/,
        /[{}]/,
        /\[\[/,
        /[[\]]/,
        /\\/,
        /,/
      );
      return {
        name: "R",
        keywords: {
          $pattern: n,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: (
            // Builtin constants
            "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          )
        },
        contains: [
          // Roxygen comments
          t2.COMMENT(
            /#'/,
            /$/,
            { contains: [
              {
                // Handle `@examples` separately to cause all subsequent code
                // until the next `@`-tag on its own line to be kept as-is,
                // preventing highlighting. This code is example R code, so nested
                // doctags shouldn’t be treated as such. See
                // `test/markup/r/roxygen.txt` for an example.
                scope: "doctag",
                match: /@examples/,
                starts: {
                  end: e.lookahead(e.either(
                    // end if another doc comment
                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                    // or a line with no comment
                    /\n^(?!#')/
                  )),
                  endsParent: true
                }
              },
              {
                // Handle `@param` to highlight the parameter name following
                // after.
                scope: "doctag",
                begin: "@param",
                end: /$/,
                contains: [
                  {
                    scope: "variable",
                    variants: [
                      { match: n },
                      { match: /`(?:\\.|[^`\\])+`/ }
                    ],
                    endsParent: true
                  }
                ]
              },
              {
                scope: "doctag",
                match: /@[a-zA-Z]+/
              },
              {
                scope: "keyword",
                match: /\\[a-zA-Z]+/
              }
            ] }
          ),
          t2.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [t2.BACKSLASH_ESCAPE],
            variants: [
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              t2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          // Matching numbers immediately following punctuation and operators is
          // tricky since we need to look at the character ahead of a number to
          // ensure the number is not part of an identifier, and we cannot use
          // negative look-behind assertions. So instead we explicitly handle all
          // possible combinations of (operator|punctuation), number.
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  i,
                  o
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  o
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  s,
                  o
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  // not part of an identifier, or start of document
                  o
                ]
              }
            ]
          },
          // Operators/punctuation when they're not directly followed by numbers
          {
            // Relevance boost for the most common assignment form.
            scope: { 3: "operator" },
            match: [
              n,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: i },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: s
          },
          {
            // Escaped identifier
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    function hO(t2) {
      const e = t2.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", o = e.either(
        /\b([A-Z]+[a-z0-9]+)+/,
        // ends in caps
        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
      ), i = e.concat(o, /(::\w+)*/), r = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...[
            "include",
            "extend",
            "prepend",
            "public",
            "private",
            "protected",
            "raise",
            "throw"
          ]
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      }, a = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      }, l = {
        begin: "#<",
        end: ">"
      }, c2 = [
        t2.COMMENT(
          "#",
          "$",
          { contains: [a] }
        ),
        t2.COMMENT(
          "^=begin",
          "^=end",
          {
            contains: [a],
            relevance: 10
          }
        ),
        t2.COMMENT("^__END__", t2.MATCH_NOTHING_RE)
      ], u = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: r
      }, d = {
        className: "string",
        contains: [
          t2.BACKSLASH_ESCAPE,
          u
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
          // where ? is the last character of a preceding identifier, as in: `func?4`
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          // heredocs
          {
            // this guard makes sure that we have an entire heredoc and not a false
            // positive (auto-detect, etc.)
            begin: e.concat(
              /<<[-~]?'?/,
              e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
            ),
            contains: [
              t2.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  t2.BACKSLASH_ESCAPE,
                  u
                ]
              })
            ]
          }
        ]
      }, p2 = "[1-9](_?[0-9])*|0", m = "[0-9](_?[0-9])*", f = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal integer/float, optionally exponential or rational, optionally imaginary
          { begin: `\\b(${p2})(\\.(${m}))?([eE][+-]?(${m})|r)?i?\\b` },
          // explicit decimal/binary/octal/hexadecimal integer,
          // optionally rational and/or imaginary
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          // 0-prefixed implicit octal integer, optionally rational and/or imaginary
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      }, _ = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: r
          }
        ]
      }, E = [
        d,
        {
          variants: [
            {
              match: [
                /class\s+/,
                i,
                /\s+<\s+/,
                i
              ]
            },
            {
              match: [
                /\b(class|module)\s+/,
                i
              ]
            }
          ],
          scope: {
            2: "title.class",
            4: "title.class.inherited"
          },
          keywords: r
        },
        {
          match: [
            /(include|extend)\s+/,
            i
          ],
          scope: {
            2: "title.class"
          },
          keywords: r
        },
        {
          relevance: 0,
          match: [
            i,
            /\.new[. (]/
          ],
          scope: {
            1: "title.class"
          }
        },
        {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        },
        {
          relevance: 0,
          match: o,
          scope: "title.class"
        },
        {
          match: [
            /def/,
            /\s+/,
            n
          ],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [
            _
          ]
        },
        {
          // swallow namespace qualifiers before symbols
          begin: t2.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: t2.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            d,
            { begin: n }
          ],
          relevance: 0
        },
        f,
        {
          // negative-look forward attempts to prevent false matches like:
          // @ident@ or $ident$ that might indicate this is not ruby at all
          className: "variable",
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          // this could be a lot of things (in other languages) other than params
          keywords: r
        },
        {
          // regexp container
          begin: "(" + t2.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                t2.BACKSLASH_ESCAPE,
                u
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(l, c2),
          relevance: 0
        }
      ].concat(l, c2);
      u.contains = E, _.contains = E;
      const V = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: E
          }
        },
        {
          className: "meta.prompt",
          begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
          starts: {
            end: "$",
            keywords: r,
            contains: E
          }
        }
      ];
      return c2.unshift(l), {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: r,
        illegal: /\/\*/,
        contains: [t2.SHEBANG({ binary: "ruby" })].concat(V).concat(c2).concat(E)
      };
    }
    function gO(t2) {
      const e = t2.regex, n = /(r#)?/, o = e.concat(n, t2.UNDERSCORE_IDENT_RE), i = e.concat(n, t2.IDENT_RE), s = {
        className: "title.function.invoke",
        relevance: 0,
        begin: e.concat(
          /\b/,
          /(?!let|for|while|if|else|match\b)/,
          i,
          e.lookahead(/\s*\(/)
        )
      }, r = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ], l = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ], c2 = [
        // functions
        "drop ",
        // traits
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        // macros
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ], u = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: t2.IDENT_RE + "!?",
          type: u,
          keyword: a,
          literal: l,
          built_in: c2
        },
        illegal: "</",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          t2.inherit(t2.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            // negative lookahead to avoid matching `'`
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + r },
              { begin: "\\b0o([0-7_]+)" + r },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + r },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  t2.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              o
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          // must come before impl/for rule later
          {
            begin: [
              /for/,
              /\s+/,
              o,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: t2.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: c2,
              type: u
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          s
        ]
      };
    }
    const vO = (t2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: t2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: t2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), bO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], kO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], yO = [
      ...bO,
      ...kO
    ], wO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), jO = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), EO = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), SO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function CO(t2) {
      const e = vO(t2), n = EO, o = jO, i = "@[a-z-]+", s = "and or not only", a = {
        className: "variable",
        begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [
          t2.C_LINE_COMMENT_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          e.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          },
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-tag",
            begin: "\\b(" + yO.join("|") + ")\\b",
            // was there, before, but why?
            relevance: 0
          },
          {
            className: "selector-pseudo",
            begin: ":(" + o.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + n.join("|") + ")"
          },
          a,
          {
            // pseudo-selector params
            begin: /\(/,
            end: /\)/,
            contains: [e.CSS_NUMBER_MODE]
          },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + SO.join("|") + ")\\b"
          },
          { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
          {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [
              e.BLOCK_COMMENT,
              a,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE,
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              e.IMPORTANT,
              e.FUNCTION_DISPATCH
            ]
          },
          // matching these here allows us to treat them more like regular CSS
          // rules so everything between the {} gets regular rule highlighting,
          // which is what we want for page and font-face
          {
            begin: "@(page|font-face)",
            keywords: {
              $pattern: i,
              keyword: "@page @font-face"
            }
          },
          {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: s,
              attribute: wO.join(" ")
            },
            contains: [
              {
                begin: i,
                className: "keyword"
              },
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              a,
              t2.QUOTE_STRING_MODE,
              t2.APOS_STRING_MODE,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE
            ]
          },
          e.FUNCTION_DISPATCH
        ]
      };
    }
    function xO(t2) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
            // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
            // echo /path/to/home > t.exe
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    function TO(t2) {
      const e = t2.regex, n = t2.COMMENT("--", "$"), o = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      }, i = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      }, s = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ], r = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ], a = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        // modifier (character varying)
        "varbinary"
      ], l = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ], c2 = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ], u = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ], d = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ], p2 = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ], m = u, f = [
        ...c2,
        ...l
      ].filter((C) => !u.includes(C)), _ = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      }, h2 = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      }, g = {
        match: e.concat(/\b/, e.either(...m), /\s*\(/),
        relevance: 0,
        keywords: { built_in: m }
      };
      function k(C) {
        return e.concat(
          /\b/,
          e.either(...C.map((E) => E.replace(/\s+/, "\\s+"))),
          /\b/
        );
      }
      const j = {
        scope: "keyword",
        match: k(p2),
        relevance: 0
      };
      function v(C, {
        exceptions: E,
        when: B
      } = {}) {
        const U = B;
        return E = E || [], C.map((P) => P.match(/\|\d+$/) || E.includes(P) ? P : U(P) ? `${P}|0` : P);
      }
      return {
        name: "SQL",
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: v(f, { when: (C) => C.length < 3 }),
          literal: s,
          type: a,
          built_in: d
        },
        contains: [
          {
            scope: "type",
            match: k(r)
          },
          j,
          g,
          _,
          o,
          i,
          t2.C_NUMBER_MODE,
          t2.C_BLOCK_COMMENT_MODE,
          n,
          h2
        ]
      };
    }
    function yh(t2) {
      return t2 ? typeof t2 == "string" ? t2 : t2.source : null;
    }
    function Zi(t2) {
      return Je("(?=", t2, ")");
    }
    function Je(...t2) {
      return t2.map((n) => yh(n)).join("");
    }
    function OO(t2) {
      const e = t2[t2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (t2.splice(t2.length - 1, 1), e) : {};
    }
    function Wt(...t2) {
      return "(" + (OO(t2).capture ? "" : "?:") + t2.map((o) => yh(o)).join("|") + ")";
    }
    const ju = (t2) => Je(
      /\b/,
      t2,
      /\w$/.test(t2) ? /\b/ : /\B/
    ), NO = [
      "Protocol",
      // contextual
      "Type"
      // contextual
    ].map(ju), Qp = [
      "init",
      "self"
    ].map(ju), AO = [
      "Any",
      "Self"
    ], Ol = [
      // strings below will be fed into the regular `keywords` engine while regex
      // will result in additional modes being created to scan for those keywords to
      // avoid conflicts with other rules
      "actor",
      "any",
      // contextual
      "associatedtype",
      "async",
      "await",
      /as\?/,
      // operator
      /as!/,
      // operator
      "as",
      // operator
      "borrowing",
      // contextual
      "break",
      "case",
      "catch",
      "class",
      "consume",
      // contextual
      "consuming",
      // contextual
      "continue",
      "convenience",
      // contextual
      "copy",
      // contextual
      "default",
      "defer",
      "deinit",
      "didSet",
      // contextual
      "distributed",
      "do",
      "dynamic",
      // contextual
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      // contextual
      "for",
      "func",
      "get",
      // contextual
      "guard",
      "if",
      "import",
      "indirect",
      // contextual
      "infix",
      // contextual
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      // operator
      "isolated",
      // contextual
      "nonisolated",
      // contextual
      "lazy",
      // contextual
      "let",
      "macro",
      "mutating",
      // contextual
      "nonmutating",
      // contextual
      /open\(set\)/,
      // contextual
      "open",
      // contextual
      "operator",
      "optional",
      // contextual
      "override",
      // contextual
      "package",
      "postfix",
      // contextual
      "precedencegroup",
      "prefix",
      // contextual
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      // contextual
      "rethrows",
      "return",
      "set",
      // contextual
      "some",
      // contextual
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      // operator
      /try!/,
      // operator
      "try",
      // operator
      "typealias",
      /unowned\(safe\)/,
      // contextual
      /unowned\(unsafe\)/,
      // contextual
      "unowned",
      // contextual
      "var",
      "weak",
      // contextual
      "where",
      "while",
      "willSet"
      // contextual
    ], em = [
      "false",
      "nil",
      "true"
    ], MO = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ], RO = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ], tm = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ], wh = Wt(
      /[/=\-+!*%<>&|^~?]/,
      /[\u00A1-\u00A7]/,
      /[\u00A9\u00AB]/,
      /[\u00AC\u00AE]/,
      /[\u00B0\u00B1]/,
      /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
      /[\u2016-\u2017]/,
      /[\u2020-\u2027]/,
      /[\u2030-\u203E]/,
      /[\u2041-\u2053]/,
      /[\u2055-\u205E]/,
      /[\u2190-\u23FF]/,
      /[\u2500-\u2775]/,
      /[\u2794-\u2BFF]/,
      /[\u2E00-\u2E7F]/,
      /[\u3001-\u3003]/,
      /[\u3008-\u3020]/,
      /[\u3030]/
    ), jh = Wt(
      wh,
      /[\u0300-\u036F]/,
      /[\u1DC0-\u1DFF]/,
      /[\u20D0-\u20FF]/,
      /[\uFE00-\uFE0F]/,
      /[\uFE20-\uFE2F]/
      // TODO: The following characters are also allowed, but the regex isn't supported yet.
      // /[\u{E0100}-\u{E01EF}]/u
    ), Nl = Je(wh, jh, "*"), Eh = Wt(
      /[a-zA-Z_]/,
      /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
      /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
      /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
      /[\u1E00-\u1FFF]/,
      /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
      /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
      /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
      /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
      /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
      /[\uFE47-\uFEFE\uFF00-\uFFFD]/
      // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
      // The following characters are also allowed, but the regexes aren't supported yet.
      // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
      // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
      // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
      // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
    ), ea = Wt(
      Eh,
      /\d/,
      /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
    ), Un = Je(Eh, ea, "*"), br = Je(/[A-Z]/, ea, "*"), IO = [
      "attached",
      "autoclosure",
      Je(/convention\(/, Wt("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      Je(/objc\(/, Un, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ], DO = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function LO(t2) {
      const e = {
        match: /\s+/,
        relevance: 0
      }, n = t2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: ["self"] }
      ), o = [
        t2.C_LINE_COMMENT_MODE,
        n
      ], i = {
        match: [
          /\./,
          Wt(...NO, ...Qp)
        ],
        className: { 2: "keyword" }
      }, s = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: Je(/\./, Wt(...Ol)),
        relevance: 0
      }, r = Ol.filter((ke) => typeof ke == "string").concat(["_|0"]), a = Ol.filter((ke) => typeof ke != "string").concat(AO).map(ju), l = { variants: [
        {
          className: "keyword",
          match: Wt(...a, ...Qp)
        }
      ] }, c2 = {
        $pattern: Wt(
          /\b\w+/,
          // regular keywords
          /#\w+/
          // number keywords
        ),
        keyword: r.concat(RO),
        literal: em
      }, u = [
        i,
        s,
        l
      ], d = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: Je(/\./, Wt(...tm)),
        relevance: 0
      }, p2 = {
        className: "built_in",
        match: Je(/\b/, Wt(...tm), /(?=\()/)
      }, m = [
        d,
        p2
      ], f = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
      }, _ = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: Nl },
          {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: `\\.(\\.|${jh})+`
          }
        ]
      }, h2 = [
        f,
        _
      ], g = "([0-9]_*)+", k = "([0-9a-fA-F]_*)+", j = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal floating-point-literal (subsumes decimal-literal)
          { match: `\\b(${g})(\\.(${g}))?([eE][+-]?(${g}))?\\b` },
          // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
          { match: `\\b0x(${k})(\\.(${k}))?([pP][+-]?(${g}))?\\b` },
          // octal-literal
          { match: /\b0o([0-7]_*)+\b/ },
          // binary-literal
          { match: /\b0b([01]_*)+\b/ }
        ]
      }, v = (ke = "") => ({
        className: "subst",
        variants: [
          { match: Je(/\\/, ke, /[0\\tnr"']/) },
          { match: Je(/\\/, ke, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      }), C = (ke = "") => ({
        className: "subst",
        match: Je(/\\/, ke, /[\t ]*(?:[\r\n]|\r\n)/)
      }), E = (ke = "") => ({
        className: "subst",
        label: "interpol",
        begin: Je(/\\/, ke, /\(/),
        end: /\)/
      }), B = (ke = "") => ({
        begin: Je(ke, /"""/),
        end: Je(/"""/, ke),
        contains: [
          v(ke),
          C(ke),
          E(ke)
        ]
      }), U = (ke = "") => ({
        begin: Je(ke, /"/),
        end: Je(/"/, ke),
        contains: [
          v(ke),
          E(ke)
        ]
      }), P = {
        className: "string",
        variants: [
          B(),
          B("#"),
          B("##"),
          B("###"),
          U(),
          U("#"),
          U("##"),
          U("###")
        ]
      }, V = [
        t2.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [t2.BACKSLASH_ESCAPE]
        }
      ], ne = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: V
      }, pe = (ke) => {
        const Xt = Je(ke, /\//), Pt = Je(/\//, ke);
        return {
          begin: Xt,
          end: Pt,
          contains: [
            ...V,
            {
              scope: "comment",
              begin: `#(?!.*${Pt})`,
              end: /$/
            }
          ]
        };
      }, we = {
        scope: "regexp",
        variants: [
          pe("###"),
          pe("##"),
          pe("#"),
          ne
        ]
      }, ye = { match: Je(/`/, Un, /`/) }, _e = {
        className: "variable",
        match: /\$\d+/
      }, he = {
        className: "variable",
        match: `\\$${ea}+`
      }, N = [
        ye,
        _e,
        he
      ], L = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: DO,
            contains: [
              ...h2,
              j,
              P
            ]
          }
        ] }
      }, J = {
        scope: "keyword",
        match: Je(/@/, Wt(...IO), Zi(Wt(/\(/, /\s+/)))
      }, se = {
        scope: "meta",
        match: Je(/@/, Un)
      }, ue = [
        L,
        J,
        se
      ], Se = {
        match: Zi(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            // Common Apple frameworks, for relevance boost
            className: "type",
            match: Je(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, ea, "+")
          },
          {
            // Type identifier
            className: "type",
            match: br,
            relevance: 0
          },
          {
            // Optional type
            match: /[?!]+/,
            relevance: 0
          },
          {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
          },
          {
            // Protocol composition
            match: Je(/\s+&\s+/, Zi(br)),
            relevance: 0
          }
        ]
      }, He = {
        begin: /</,
        end: />/,
        keywords: c2,
        contains: [
          ...o,
          ...u,
          ...ue,
          f,
          Se
        ]
      };
      Se.contains.push(He);
      const yt = {
        match: Je(Un, /\s*:/),
        keywords: "_|0",
        relevance: 0
      }, Ue = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: c2,
        contains: [
          "self",
          yt,
          ...o,
          we,
          ...u,
          ...m,
          ...h2,
          j,
          P,
          ...N,
          ...ue,
          Se
        ]
      }, et = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...o,
          Se
        ]
      }, sn = {
        begin: Wt(
          Zi(Je(Un, /\s*:/)),
          Zi(Je(Un, /\s+/, Un, /\s*:/))
        ),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: Un
          }
        ]
      }, Nt = {
        begin: /\(/,
        end: /\)/,
        keywords: c2,
        contains: [
          sn,
          ...o,
          ...u,
          ...h2,
          j,
          P,
          ...ue,
          Se,
          Ue
        ],
        endsParent: true,
        illegal: /["']/
      }, fn = {
        match: [
          /(func|macro)/,
          /\s+/,
          Wt(ye.match, Un, Nl)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          et,
          Nt,
          e
        ],
        illegal: [
          /\[/,
          /%/
        ]
      }, At = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          et,
          Nt,
          e
        ],
        illegal: /\[|%/
      }, _n = {
        match: [
          /operator/,
          /\s+/,
          Nl
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      }, zn = {
        begin: [
          /precedencegroup/,
          /\s+/,
          br
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [Se],
        keywords: [
          ...MO,
          ...em
        ],
        end: /}/
      }, On = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      }, rn = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      }, Nn = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          Un,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: c2,
        contains: [
          et,
          ...u,
          {
            begin: /:/,
            end: /\{/,
            keywords: c2,
            contains: [
              {
                scope: "title.class.inherited",
                match: br
              },
              ...u
            ],
            relevance: 0
          }
        ]
      };
      for (const ke of P.variants) {
        const Xt = ke.contains.find((le) => le.label === "interpol");
        Xt.keywords = c2;
        const Pt = [
          ...u,
          ...m,
          ...h2,
          j,
          P,
          ...N
        ];
        Xt.contains = [
          ...Pt,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...Pt
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: c2,
        contains: [
          ...o,
          fn,
          At,
          On,
          rn,
          Nn,
          _n,
          zn,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...o],
            relevance: 0
          },
          we,
          ...u,
          ...m,
          ...h2,
          j,
          P,
          ...N,
          ...ue,
          Se,
          Ue
        ]
      };
    }
    const ta = "[A-Za-z$_][0-9A-Za-z$_]*", Sh = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], Ch = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], xh = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], Th = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], Oh = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], Nh = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], Ah = [].concat(
      Oh,
      xh,
      Th
    );
    function PO(t2) {
      const e = t2.regex, n = (L, { after: J }) => {
        const se = "</" + L[0].slice(1);
        return L.input.indexOf(se, J) !== -1;
      }, o = ta, i = {
        begin: "<>",
        end: "</>"
      }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, r = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, J) => {
          const se = L[0].length + L.index, ue = L.input[se];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ue === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ue === ","
          ) {
            J.ignoreMatch();
            return;
          }
          ue === ">" && (n(L, { after: se }) || J.ignoreMatch());
          let Se;
          const He = L.input.substring(se);
          if (Se = He.match(/^\s*=/)) {
            J.ignoreMatch();
            return;
          }
          if ((Se = He.match(/^\s+extends\s+/)) && Se.index === 0) {
            J.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: ta,
        keyword: Sh,
        literal: Ch,
        built_in: Ah,
        "variable.language": Nh
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, m = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, f = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, _ = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            t2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, h2 = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          t2.BACKSLASH_ESCAPE,
          p2
        ]
      }, k = {
        className: "comment",
        variants: [
          t2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: o + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          t2.C_BLOCK_COMMENT_MODE,
          t2.C_LINE_COMMENT_MODE
        ]
      }, j = [
        t2.APOS_STRING_MODE,
        t2.QUOTE_STRING_MODE,
        m,
        f,
        _,
        h2,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = j.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(j)
      });
      const v = [].concat(k, p2.contains), C = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), E = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: C
      }, B = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              o,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(o, "(", e.concat(/\./, o), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              o
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, U = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...xh,
            ...Th
          ]
        }
      }, P = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, V = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              o,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [E],
        illegal: /%/
      }, ne = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function pe(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const we = {
        match: e.concat(
          /\b/,
          pe([
            ...Oh,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          o,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, ye = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(o, /(?![0-9A-Za-z$_(])/)
        )),
        end: o,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, _e = {
        match: [
          /get|set/,
          /\s+/,
          o,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          E
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          o,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          E
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: C, CLASS_REFERENCE: U },
        illegal: /#(?![$_A-z])/,
        contains: [
          t2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          P,
          t2.APOS_STRING_MODE,
          t2.QUOTE_STRING_MODE,
          m,
          f,
          _,
          h2,
          k,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          U,
          {
            scope: "attr",
            match: o + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + t2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              k,
              t2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: t2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: C
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: i.begin, end: i.end },
                  { match: s },
                  {
                    begin: r.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": r.isTrulyOpeningTag,
                    end: r.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: r.begin,
                    end: r.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          V,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + t2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              E,
              t2.inherit(t2.TITLE_MODE, { begin: o, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          ye,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + o,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [E]
          },
          we,
          ne,
          B,
          _e,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function BO(t2) {
      const e = t2.regex, n = PO(t2), o = ta, i = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ], s = {
        begin: [
          /namespace/,
          /\s+/,
          t2.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      }, r = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: i
        },
        contains: [n.exports.CLASS_REFERENCE]
      }, a = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      }, l = [
        "type",
        // "namespace",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ], c2 = {
        $pattern: ta,
        keyword: Sh.concat(l),
        literal: Ch,
        built_in: Ah.concat(i),
        "variable.language": Nh
      }, u = {
        className: "meta",
        begin: "@" + o
      }, d = (_, h2, g) => {
        const k = _.contains.findIndex((j) => j.label === h2);
        if (k === -1)
          throw new Error("can not find mode to replace");
        _.contains.splice(k, 1, g);
      };
      Object.assign(n.keywords, c2), n.exports.PARAMS_CONTAINS.push(u);
      const p2 = n.contains.find((_) => _.scope === "attr"), m = Object.assign(
        {},
        p2,
        { match: e.concat(o, e.lookahead(/\s*\?:/)) }
      );
      n.exports.PARAMS_CONTAINS.push([
        n.exports.CLASS_REFERENCE,
        // class reference for highlighting the params types
        p2,
        // highlight the params key
        m
        // Added for optional property assignment highlighting
      ]), n.contains = n.contains.concat([
        u,
        s,
        r,
        m
        // Added for optional property assignment highlighting
      ]), d(n, "shebang", t2.SHEBANG()), d(n, "use_strict", a);
      const f = n.contains.find((_) => _.label === "func.def");
      return f.relevance = 0, Object.assign(n, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      }), n;
    }
    function $O(t2) {
      const e = t2.regex, n = {
        className: "string",
        begin: /"(""|[^/n])"C\b/
      }, o = {
        className: "string",
        begin: /"/,
        end: /"/,
        illegal: /\n/,
        contains: [
          {
            // double quote escape
            begin: /""/
          }
        ]
      }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, s = /\d{4}-\d{1,2}-\d{1,2}/, r = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
        className: "literal",
        variants: [
          {
            // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
            begin: e.concat(/# */, e.either(s, i), / *#/)
          },
          {
            // #H:mm[:ss]# (24h Time)
            begin: e.concat(/# */, a, / *#/)
          },
          {
            // #h[:mm[:ss]] A# (12h Time)
            begin: e.concat(/# */, r, / *#/)
          },
          {
            // date plus time
            begin: e.concat(
              /# */,
              e.either(s, i),
              / +/,
              e.either(r, a),
              / *#/
            )
          }
        ]
      }, c2 = {
        className: "number",
        relevance: 0,
        variants: [
          {
            // Float
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          },
          {
            // Integer (base 10)
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 16)
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 8)
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 2)
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }
        ]
      }, u = {
        className: "label",
        begin: /^\w+:/
      }, d = t2.COMMENT(/'''/, /$/, { contains: [
        {
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }
      ] }), p2 = t2.COMMENT(null, /$/, { variants: [
        { begin: /'/ },
        {
          // TODO: Use multi-class for leading spaces
          begin: /([\t ]|^)REM(?=\s)/
        }
      ] });
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: { label: "symbol" },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: (
            // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
            "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
          ),
          type: (
            // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
            "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
          ),
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [
          n,
          o,
          l,
          c2,
          u,
          d,
          p2,
          {
            className: "meta",
            // TODO: Use multi-class for indentation once available
            begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
            end: /$/,
            keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
            contains: [p2]
          }
        ]
      };
    }
    function zO(t2) {
      t2.regex;
      const e = t2.COMMENT(/\(;/, /;\)/);
      e.contains.push("self");
      const n = t2.COMMENT(/;;/, /$/), o = [
        "anyfunc",
        "block",
        "br",
        "br_if",
        "br_table",
        "call",
        "call_indirect",
        "data",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "func",
        "global.get",
        "global.set",
        "local.get",
        "local.set",
        "local.tee",
        "get_global",
        "get_local",
        "global",
        "if",
        "import",
        "local",
        "loop",
        "memory",
        "memory.grow",
        "memory.size",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "return",
        "select",
        "set_global",
        "set_local",
        "start",
        "table",
        "tee_local",
        "then",
        "type",
        "unreachable"
      ], i = {
        begin: [
          /(?:func|call|call_indirect)/,
          /\s+/,
          /\$[^\s)]+/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      }, s = {
        className: "variable",
        begin: /\$[\w_]+/
      }, r = {
        match: /(\((?!;)|\))+/,
        className: "punctuation",
        relevance: 0
      }, a = {
        className: "number",
        relevance: 0,
        // borrowed from Prism, TODO: split out into variants
        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
      }, l = {
        // look-ahead prevents us from gobbling up opcodes
        match: /(i32|i64|f32|f64)(?!\.)/,
        className: "type"
      }, c2 = {
        className: "keyword",
        // borrowed from Prism, TODO: split out into variants
        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
      };
      return {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: o
        },
        contains: [
          n,
          e,
          {
            match: [
              /(?:offset|align)/,
              /\s*/,
              /=/
            ],
            className: {
              1: "keyword",
              3: "operator"
            }
          },
          s,
          r,
          i,
          t2.QUOTE_STRING_MODE,
          l,
          c2,
          a
        ]
      };
    }
    function FO(t2) {
      const e = t2.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), o = /[\p{L}0-9._:-]+/u, i = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      }, s = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      }, r = t2.inherit(s, {
        begin: /\(/,
        end: /\)/
      }), a = t2.inherit(t2.APOS_STRING_MODE, { className: "string" }), l = t2.inherit(t2.QUOTE_STRING_MODE, { className: "string" }), c2 = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: o,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [i]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [i]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              s,
              l,
              a,
              r,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      s,
                      r,
                      l,
                      a
                    ]
                  }
                ]
              }
            ]
          },
          t2.COMMENT(
            /<!--/,
            /-->/,
            { relevance: 10 }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          i,
          // xml processing instructions
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  l
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending bracket.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [c2],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [c2],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: e.concat(
              /</,
              e.lookahead(e.concat(
                n,
                // <tag/>
                // <tag>
                // <tag ...
                e.either(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: n,
                relevance: 0,
                starts: c2
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: e.concat(
              /<\//,
              e.lookahead(e.concat(
                n,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: n,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    function HO(t2) {
      const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", o = {
        className: "attr",
        variants: [
          // added brackets support and special char support
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets and special char support
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets and special char support
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      }, i = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      }, s = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      }, r = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          t2.BACKSLASH_ESCAPE,
          i
        ]
      }, a = t2.inherit(r, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] }), p2 = {
        className: "number",
        begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
      }, m = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: e,
        relevance: 0
      }, f = {
        begin: /\{/,
        end: /\}/,
        contains: [m],
        illegal: "\\n",
        relevance: 0
      }, _ = {
        begin: "\\[",
        end: "\\]",
        contains: [m],
        illegal: "\\n",
        relevance: 0
      }, h2 = [
        o,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + n
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + n + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + n
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + n
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + t2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + t2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        t2.HASH_COMMENT_MODE,
        {
          beginKeywords: e,
          keywords: { literal: e }
        },
        p2,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: t2.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        f,
        _,
        s,
        r
      ], g = [...h2];
      return g.pop(), g.push(a), m.contains = g, {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: h2
      };
    }
    const UO = {
      arduino: ET,
      bash: ST,
      c: CT,
      cpp: xT,
      csharp: TT,
      css: PT,
      diff: BT,
      go: $T,
      graphql: zT,
      ini: FT,
      java: HT,
      javascript: WT,
      json: GT,
      kotlin: YT,
      less: iO,
      lua: sO,
      makefile: rO,
      markdown: aO,
      objectivec: lO,
      perl: cO,
      php: uO,
      "php-template": dO,
      plaintext: pO,
      python: mO,
      "python-repl": fO,
      r: _O,
      ruby: hO,
      rust: gO,
      scss: CO,
      shell: xO,
      sql: TO,
      swift: LO,
      typescript: BO,
      vbnet: $O,
      wasm: zO,
      xml: FO,
      yaml: HO
    };
    function VO(t2) {
      return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
    }
    var Al, nm;
    function qO() {
      if (nm) return Al;
      nm = 1;
      function t2(w) {
        return w instanceof Map ? w.clear = w.delete = w.set = function() {
          throw new Error("map is read-only");
        } : w instanceof Set && (w.add = w.clear = w.delete = function() {
          throw new Error("set is read-only");
        }), Object.freeze(w), Object.getOwnPropertyNames(w).forEach((M) => {
          const H = w[M], ge = typeof H;
          (ge === "object" || ge === "function") && !Object.isFrozen(H) && t2(H);
        }), w;
      }
      class e {
        /**
         * @param {CompiledMode} mode
         */
        constructor(M) {
          M.data === void 0 && (M.data = {}), this.data = M.data, this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function n(w) {
        return w.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function o(w, ...M) {
        const H = /* @__PURE__ */ Object.create(null);
        for (const ge in w)
          H[ge] = w[ge];
        return M.forEach(function(ge) {
          for (const st in ge)
            H[st] = ge[st];
        }), /** @type {T} */
        H;
      }
      const i = "</span>", s = (w) => !!w.scope, r = (w, { prefix: M }) => {
        if (w.startsWith("language:"))
          return w.replace("language:", "language-");
        if (w.includes(".")) {
          const H = w.split(".");
          return [
            `${M}${H.shift()}`,
            ...H.map((ge, st) => `${ge}${"_".repeat(st + 1)}`)
          ].join(" ");
        }
        return `${M}${w}`;
      };
      class a {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(M, H) {
          this.buffer = "", this.classPrefix = H.classPrefix, M.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(M) {
          this.buffer += n(M);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(M) {
          if (!s(M)) return;
          const H = r(
            M.scope,
            { prefix: this.classPrefix }
          );
          this.span(H);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(M) {
          s(M) && (this.buffer += i);
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(M) {
          this.buffer += `<span class="${M}">`;
        }
      }
      const l = (w = {}) => {
        const M = { children: [] };
        return Object.assign(M, w), M;
      };
      class c2 {
        constructor() {
          this.rootNode = l(), this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(M) {
          this.top.children.push(M);
        }
        /** @param {string} scope */
        openNode(M) {
          const H = l({ scope: M });
          this.add(H), this.stack.push(H);
        }
        closeNode() {
          if (this.stack.length > 1)
            return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); ) ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(M) {
          return this.constructor._walk(M, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(M, H) {
          return typeof H == "string" ? M.addText(H) : H.children && (M.openNode(H), H.children.forEach((ge) => this._walk(M, ge)), M.closeNode(H)), M;
        }
        /**
         * @param {Node} node
         */
        static _collapse(M) {
          typeof M != "string" && M.children && (M.children.every((H) => typeof H == "string") ? M.children = [M.children.join("")] : M.children.forEach((H) => {
            c2._collapse(H);
          }));
        }
      }
      class u extends c2 {
        /**
         * @param {*} options
         */
        constructor(M) {
          super(), this.options = M;
        }
        /**
         * @param {string} text
         */
        addText(M) {
          M !== "" && this.add(M);
        }
        /** @param {string} scope */
        startScope(M) {
          this.openNode(M);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(M, H) {
          const ge = M.root;
          H && (ge.scope = `language:${H}`), this.add(ge);
        }
        toHTML() {
          return new a(this, this.options).value();
        }
        finalize() {
          return this.closeAllNodes(), true;
        }
      }
      function d(w) {
        return w ? typeof w == "string" ? w : w.source : null;
      }
      function p2(w) {
        return _("(?=", w, ")");
      }
      function m(w) {
        return _("(?:", w, ")*");
      }
      function f(w) {
        return _("(?:", w, ")?");
      }
      function _(...w) {
        return w.map((H) => d(H)).join("");
      }
      function h2(w) {
        const M = w[w.length - 1];
        return typeof M == "object" && M.constructor === Object ? (w.splice(w.length - 1, 1), M) : {};
      }
      function g(...w) {
        return "(" + (h2(w).capture ? "" : "?:") + w.map((ge) => d(ge)).join("|") + ")";
      }
      function k(w) {
        return new RegExp(w.toString() + "|").exec("").length - 1;
      }
      function j(w, M) {
        const H = w && w.exec(M);
        return H && H.index === 0;
      }
      const v = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function C(w, { joinWith: M }) {
        let H = 0;
        return w.map((ge) => {
          H += 1;
          const st = H;
          let tt2 = d(ge), te = "";
          for (; tt2.length > 0; ) {
            const X = v.exec(tt2);
            if (!X) {
              te += tt2;
              break;
            }
            te += tt2.substring(0, X.index), tt2 = tt2.substring(X.index + X[0].length), X[0][0] === "\\" && X[1] ? te += "\\" + String(Number(X[1]) + st) : (te += X[0], X[0] === "(" && H++);
          }
          return te;
        }).map((ge) => `(${ge})`).join(M);
      }
      const E = /\b\B/, B = "[a-zA-Z]\\w*", U = "[a-zA-Z_]\\w*", P = "\\b\\d+(\\.\\d+)?", V = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", ne = "\\b(0b[01]+)", pe = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", we = (w = {}) => {
        const M = /^#![ ]*\//;
        return w.binary && (w.begin = _(
          M,
          /.*\b/,
          w.binary,
          /\b.*/
        )), o({
          scope: "meta",
          begin: M,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (H, ge) => {
            H.index !== 0 && ge.ignoreMatch();
          }
        }, w);
      }, ye = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      }, _e = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [ye]
      }, he = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [ye]
      }, N = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      }, L = function(w, M, H = {}) {
        const ge = o(
          {
            scope: "comment",
            begin: w,
            end: M,
            contains: []
          },
          H
        );
        ge.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const st = g(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        return ge.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: _(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              st,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        ), ge;
      }, J = L("//", "$"), se = L("/\\*", "\\*/"), ue = L("#", "$"), Se = {
        scope: "number",
        begin: P,
        relevance: 0
      }, He = {
        scope: "number",
        begin: V,
        relevance: 0
      }, yt = {
        scope: "number",
        begin: ne,
        relevance: 0
      }, Ue = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          ye,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [ye]
          }
        ]
      }, et = {
        scope: "title",
        begin: B,
        relevance: 0
      }, sn = {
        scope: "title",
        begin: U,
        relevance: 0
      }, Nt = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + U,
        relevance: 0
      };
      var At = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: _e,
        BACKSLASH_ESCAPE: ye,
        BINARY_NUMBER_MODE: yt,
        BINARY_NUMBER_RE: ne,
        COMMENT: L,
        C_BLOCK_COMMENT_MODE: se,
        C_LINE_COMMENT_MODE: J,
        C_NUMBER_MODE: He,
        C_NUMBER_RE: V,
        END_SAME_AS_BEGIN: function(w) {
          return Object.assign(
            w,
            {
              /** @type {ModeCallback} */
              "on:begin": (M, H) => {
                H.data._beginMatch = M[1];
              },
              /** @type {ModeCallback} */
              "on:end": (M, H) => {
                H.data._beginMatch !== M[1] && H.ignoreMatch();
              }
            }
          );
        },
        HASH_COMMENT_MODE: ue,
        IDENT_RE: B,
        MATCH_NOTHING_RE: E,
        METHOD_GUARD: Nt,
        NUMBER_MODE: Se,
        NUMBER_RE: P,
        PHRASAL_WORDS_MODE: N,
        QUOTE_STRING_MODE: he,
        REGEXP_MODE: Ue,
        RE_STARTERS_RE: pe,
        SHEBANG: we,
        TITLE_MODE: et,
        UNDERSCORE_IDENT_RE: U,
        UNDERSCORE_TITLE_MODE: sn
      });
      function _n(w, M) {
        w.input[w.index - 1] === "." && M.ignoreMatch();
      }
      function zn(w, M) {
        w.className !== void 0 && (w.scope = w.className, delete w.className);
      }
      function On(w, M) {
        M && w.beginKeywords && (w.begin = "\\b(" + w.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", w.__beforeBegin = _n, w.keywords = w.keywords || w.beginKeywords, delete w.beginKeywords, w.relevance === void 0 && (w.relevance = 0));
      }
      function rn(w, M) {
        Array.isArray(w.illegal) && (w.illegal = g(...w.illegal));
      }
      function Nn(w, M) {
        if (w.match) {
          if (w.begin || w.end) throw new Error("begin & end are not supported with match");
          w.begin = w.match, delete w.match;
        }
      }
      function ke(w, M) {
        w.relevance === void 0 && (w.relevance = 1);
      }
      const Xt = (w, M) => {
        if (!w.beforeMatch) return;
        if (w.starts) throw new Error("beforeMatch cannot be used with starts");
        const H = Object.assign({}, w);
        Object.keys(w).forEach((ge) => {
          delete w[ge];
        }), w.keywords = H.keywords, w.begin = _(H.beforeMatch, p2(H.begin)), w.starts = {
          relevance: 0,
          contains: [
            Object.assign(H, { endsParent: true })
          ]
        }, w.relevance = 0, delete H.beforeMatch;
      }, Pt = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ], le = "keyword";
      function Ut(w, M, H = le) {
        const ge = /* @__PURE__ */ Object.create(null);
        return typeof w == "string" ? st(H, w.split(" ")) : Array.isArray(w) ? st(H, w) : Object.keys(w).forEach(function(tt2) {
          Object.assign(
            ge,
            Ut(w[tt2], M, tt2)
          );
        }), ge;
        function st(tt2, te) {
          M && (te = te.map((X) => X.toLowerCase())), te.forEach(function(X) {
            const ve = X.split("|");
            ge[ve[0]] = [tt2, Ge(ve[0], ve[1])];
          });
        }
      }
      function Ge(w, M) {
        return M ? Number(M) : Ie(w) ? 0 : 1;
      }
      function Ie(w) {
        return Pt.includes(w.toLowerCase());
      }
      const Vt = {}, mt = (w) => {
        console.error(w);
      }, An = (w, ...M) => {
        console.log(`WARN: ${w}`, ...M);
      }, qt = (w, M) => {
        Vt[`${w}/${M}`] || (console.log(`Deprecated as of ${w}. ${M}`), Vt[`${w}/${M}`] = true);
      }, F = new Error();
      function Y(w, M, { key: H }) {
        let ge = 0;
        const st = w[H], tt2 = {}, te = {};
        for (let X = 1; X <= M.length; X++)
          te[X + ge] = st[X], tt2[X + ge] = true, ge += k(M[X - 1]);
        w[H] = te, w[H]._emit = tt2, w[H]._multi = true;
      }
      function je(w) {
        if (Array.isArray(w.begin)) {
          if (w.skip || w.excludeBegin || w.returnBegin)
            throw mt("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), F;
          if (typeof w.beginScope != "object" || w.beginScope === null)
            throw mt("beginScope must be object"), F;
          Y(w, w.begin, { key: "beginScope" }), w.begin = C(w.begin, { joinWith: "" });
        }
      }
      function De(w) {
        if (Array.isArray(w.end)) {
          if (w.skip || w.excludeEnd || w.returnEnd)
            throw mt("skip, excludeEnd, returnEnd not compatible with endScope: {}"), F;
          if (typeof w.endScope != "object" || w.endScope === null)
            throw mt("endScope must be object"), F;
          Y(w, w.end, { key: "endScope" }), w.end = C(w.end, { joinWith: "" });
        }
      }
      function ht(w) {
        w.scope && typeof w.scope == "object" && w.scope !== null && (w.beginScope = w.scope, delete w.scope);
      }
      function an(w) {
        ht(w), typeof w.beginScope == "string" && (w.beginScope = { _wrap: w.beginScope }), typeof w.endScope == "string" && (w.endScope = { _wrap: w.endScope }), je(w), De(w);
      }
      function Wi(w) {
        function M(te, X) {
          return new RegExp(
            d(te),
            "m" + (w.case_insensitive ? "i" : "") + (w.unicodeRegex ? "u" : "") + (X ? "g" : "")
          );
        }
        class H {
          constructor() {
            this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
          }
          // @ts-ignore
          addRule(X, ve) {
            ve.position = this.position++, this.matchIndexes[this.matchAt] = ve, this.regexes.push([ve, X]), this.matchAt += k(X) + 1;
          }
          compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            const X = this.regexes.map((ve) => ve[1]);
            this.matcherRe = M(C(X, { joinWith: "|" }), true), this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(X) {
            this.matcherRe.lastIndex = this.lastIndex;
            const ve = this.matcherRe.exec(X);
            if (!ve)
              return null;
            const jt = ve.findIndex((Ji, Ja) => Ja > 0 && Ji !== void 0), gt = this.matchIndexes[jt];
            return ve.splice(0, jt), Object.assign(ve, gt);
          }
        }
        class ge {
          constructor() {
            this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(X) {
            if (this.multiRegexes[X]) return this.multiRegexes[X];
            const ve = new H();
            return this.rules.slice(X).forEach(([jt, gt]) => ve.addRule(jt, gt)), ve.compile(), this.multiRegexes[X] = ve, ve;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(X, ve) {
            this.rules.push([X, ve]), ve.type === "begin" && this.count++;
          }
          /** @param {string} s */
          exec(X) {
            const ve = this.getMatcher(this.regexIndex);
            ve.lastIndex = this.lastIndex;
            let jt = ve.exec(X);
            if (this.resumingScanAtSamePosition() && !(jt && jt.index === this.lastIndex)) {
              const gt = this.getMatcher(0);
              gt.lastIndex = this.lastIndex + 1, jt = gt.exec(X);
            }
            return jt && (this.regexIndex += jt.position + 1, this.regexIndex === this.count && this.considerAll()), jt;
          }
        }
        function st(te) {
          const X = new ge();
          return te.contains.forEach((ve) => X.addRule(ve.begin, { rule: ve, type: "begin" })), te.terminatorEnd && X.addRule(te.terminatorEnd, { type: "end" }), te.illegal && X.addRule(te.illegal, { type: "illegal" }), X;
        }
        function tt2(te, X) {
          const ve = (
            /** @type CompiledMode */
            te
          );
          if (te.isCompiled) return ve;
          [
            zn,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            Nn,
            an,
            Xt
          ].forEach((gt) => gt(te, X)), w.compilerExtensions.forEach((gt) => gt(te, X)), te.__beforeBegin = null, [
            On,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            rn,
            // default to 1 relevance if not specified
            ke
          ].forEach((gt) => gt(te, X)), te.isCompiled = true;
          let jt = null;
          return typeof te.keywords == "object" && te.keywords.$pattern && (te.keywords = Object.assign({}, te.keywords), jt = te.keywords.$pattern, delete te.keywords.$pattern), jt = jt || /\w+/, te.keywords && (te.keywords = Ut(te.keywords, w.case_insensitive)), ve.keywordPatternRe = M(jt, true), X && (te.begin || (te.begin = /\B|\b/), ve.beginRe = M(ve.begin), !te.end && !te.endsWithParent && (te.end = /\B|\b/), te.end && (ve.endRe = M(ve.end)), ve.terminatorEnd = d(ve.end) || "", te.endsWithParent && X.terminatorEnd && (ve.terminatorEnd += (te.end ? "|" : "") + X.terminatorEnd)), te.illegal && (ve.illegalRe = M(
            /** @type {RegExp | string} */
            te.illegal
          )), te.contains || (te.contains = []), te.contains = [].concat(...te.contains.map(function(gt) {
            return Q(gt === "self" ? te : gt);
          })), te.contains.forEach(function(gt) {
            tt2(
              /** @type Mode */
              gt,
              ve
            );
          }), te.starts && tt2(te.starts, X), ve.matcher = st(ve), ve;
        }
        if (w.compilerExtensions || (w.compilerExtensions = []), w.contains && w.contains.includes("self"))
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return w.classNameAliases = o(w.classNameAliases || {}), tt2(
          /** @type Mode */
          w
        );
      }
      function O(w) {
        return w ? w.endsWithParent || O(w.starts) : false;
      }
      function Q(w) {
        return w.variants && !w.cachedVariants && (w.cachedVariants = w.variants.map(function(M) {
          return o(w, { variants: null }, M);
        })), w.cachedVariants ? w.cachedVariants : O(w) ? o(w, { starts: w.starts ? o(w.starts) : null }) : Object.isFrozen(w) ? o(w) : w;
      }
      var me = "11.11.1";
      class $e extends Error {
        constructor(M, H) {
          super(M), this.name = "HTMLInjectionError", this.html = H;
        }
      }
      const Ne = n, wt = o, Kt = Symbol("nomatch"), go = 7, Gi = function(w) {
        const M = /* @__PURE__ */ Object.create(null), H = /* @__PURE__ */ Object.create(null), ge = [];
        let st = true;
        const tt2 = "Could not find the language '{}', did you forget to load/include a language module?", te = { disableAutodetect: true, name: "Plain text", contains: [] };
        let X = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: u
        };
        function ve(z) {
          return X.noHighlightRe.test(z);
        }
        function jt(z) {
          let ae = z.className + " ";
          ae += z.parentNode ? z.parentNode.className : "";
          const Me = X.languageDetectRe.exec(ae);
          if (Me) {
            const nt = vo(Me[1]);
            return nt || (An(tt2.replace("{}", Me[1])), An("Falling back to no-highlight mode for this block.", z)), nt ? Me[1] : "no-highlight";
          }
          return ae.split(/\s+/).find((nt) => ve(nt) || vo(nt));
        }
        function gt(z, ae, Me) {
          let nt = "", kt = "";
          typeof ae == "object" ? (nt = z, Me = ae.ignoreIllegals, kt = ae.language) : (qt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), qt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), kt = z, nt = ae), Me === void 0 && (Me = true);
          const Mn = {
            code: nt,
            language: kt
          };
          Js("before:highlight", Mn);
          const bo = Mn.result ? Mn.result : Ji(Mn.language, Mn.code, Me);
          return bo.code = Mn.code, Js("after:highlight", bo), bo;
        }
        function Ji(z, ae, Me, nt) {
          const kt = /* @__PURE__ */ Object.create(null);
          function Mn(G, oe) {
            return G.keywords[oe];
          }
          function bo() {
            if (!Ee.keywords) {
              Mt.addText(ot);
              return;
            }
            let G = 0;
            Ee.keywordPatternRe.lastIndex = 0;
            let oe = Ee.keywordPatternRe.exec(ot), Oe = "";
            for (; oe; ) {
              Oe += ot.substring(G, oe.index);
              const Ke = Hn.case_insensitive ? oe[0].toLowerCase() : oe[0], Bt = Mn(Ee, Ke);
              if (Bt) {
                const [eo, ag] = Bt;
                if (Mt.addText(Oe), Oe = "", kt[Ke] = (kt[Ke] || 0) + 1, kt[Ke] <= go && (Zs += ag), eo.startsWith("_"))
                  Oe += oe[0];
                else {
                  const lg = Hn.classNameAliases[eo] || eo;
                  Fn(oe[0], lg);
                }
              } else
                Oe += oe[0];
              G = Ee.keywordPatternRe.lastIndex, oe = Ee.keywordPatternRe.exec(ot);
            }
            Oe += ot.substring(G), Mt.addText(Oe);
          }
          function Ys() {
            if (ot === "") return;
            let G = null;
            if (typeof Ee.subLanguage == "string") {
              if (!M[Ee.subLanguage]) {
                Mt.addText(ot);
                return;
              }
              G = Ji(Ee.subLanguage, ot, true, zu[Ee.subLanguage]), zu[Ee.subLanguage] = /** @type {CompiledMode} */
              G._top;
            } else
              G = Ya(ot, Ee.subLanguage.length ? Ee.subLanguage : null);
            Ee.relevance > 0 && (Zs += G.relevance), Mt.__addSublanguage(G._emitter, G.language);
          }
          function ln() {
            Ee.subLanguage != null ? Ys() : bo(), ot = "";
          }
          function Fn(G, oe) {
            G !== "" && (Mt.startScope(oe), Mt.addText(G), Mt.endScope());
          }
          function Lu(G, oe) {
            let Oe = 1;
            const Ke = oe.length - 1;
            for (; Oe <= Ke; ) {
              if (!G._emit[Oe]) {
                Oe++;
                continue;
              }
              const Bt = Hn.classNameAliases[G[Oe]] || G[Oe], eo = oe[Oe];
              Bt ? Fn(eo, Bt) : (ot = eo, bo(), ot = ""), Oe++;
            }
          }
          function Pu(G, oe) {
            return G.scope && typeof G.scope == "string" && Mt.openNode(Hn.classNameAliases[G.scope] || G.scope), G.beginScope && (G.beginScope._wrap ? (Fn(ot, Hn.classNameAliases[G.beginScope._wrap] || G.beginScope._wrap), ot = "") : G.beginScope._multi && (Lu(G.beginScope, oe), ot = "")), Ee = Object.create(G, { parent: { value: Ee } }), Ee;
          }
          function Bu(G, oe, Oe) {
            let Ke = j(G.endRe, Oe);
            if (Ke) {
              if (G["on:end"]) {
                const Bt = new e(G);
                G["on:end"](oe, Bt), Bt.isMatchIgnored && (Ke = false);
              }
              if (Ke) {
                for (; G.endsParent && G.parent; )
                  G = G.parent;
                return G;
              }
            }
            if (G.endsWithParent)
              return Bu(G.parent, oe, Oe);
          }
          function ng(G) {
            return Ee.matcher.regexIndex === 0 ? (ot += G[0], 1) : (el = true, 0);
          }
          function og(G) {
            const oe = G[0], Oe = G.rule, Ke = new e(Oe), Bt = [Oe.__beforeBegin, Oe["on:begin"]];
            for (const eo of Bt)
              if (eo && (eo(G, Ke), Ke.isMatchIgnored))
                return ng(oe);
            return Oe.skip ? ot += oe : (Oe.excludeBegin && (ot += oe), ln(), !Oe.returnBegin && !Oe.excludeBegin && (ot = oe)), Pu(Oe, G), Oe.returnBegin ? 0 : oe.length;
          }
          function ig(G) {
            const oe = G[0], Oe = ae.substring(G.index), Ke = Bu(Ee, G, Oe);
            if (!Ke)
              return Kt;
            const Bt = Ee;
            Ee.endScope && Ee.endScope._wrap ? (ln(), Fn(oe, Ee.endScope._wrap)) : Ee.endScope && Ee.endScope._multi ? (ln(), Lu(Ee.endScope, G)) : Bt.skip ? ot += oe : (Bt.returnEnd || Bt.excludeEnd || (ot += oe), ln(), Bt.excludeEnd && (ot = oe));
            do
              Ee.scope && Mt.closeNode(), !Ee.skip && !Ee.subLanguage && (Zs += Ee.relevance), Ee = Ee.parent;
            while (Ee !== Ke.parent);
            return Ke.starts && Pu(Ke.starts, G), Bt.returnEnd ? 0 : oe.length;
          }
          function sg() {
            const G = [];
            for (let oe = Ee; oe !== Hn; oe = oe.parent)
              oe.scope && G.unshift(oe.scope);
            G.forEach((oe) => Mt.openNode(oe));
          }
          let Xs = {};
          function $u(G, oe) {
            const Oe = oe && oe[0];
            if (ot += G, Oe == null)
              return ln(), 0;
            if (Xs.type === "begin" && oe.type === "end" && Xs.index === oe.index && Oe === "") {
              if (ot += ae.slice(oe.index, oe.index + 1), !st) {
                const Ke = new Error(`0 width match regex (${z})`);
                throw Ke.languageName = z, Ke.badRule = Xs.rule, Ke;
              }
              return 1;
            }
            if (Xs = oe, oe.type === "begin")
              return og(oe);
            if (oe.type === "illegal" && !Me) {
              const Ke = new Error('Illegal lexeme "' + Oe + '" for mode "' + (Ee.scope || "<unnamed>") + '"');
              throw Ke.mode = Ee, Ke;
            } else if (oe.type === "end") {
              const Ke = ig(oe);
              if (Ke !== Kt)
                return Ke;
            }
            if (oe.type === "illegal" && Oe === "")
              return ot += `
`, 1;
            if (Qa > 1e5 && Qa > oe.index * 3)
              throw new Error("potential infinite loop, way more iterations than matches");
            return ot += Oe, Oe.length;
          }
          const Hn = vo(z);
          if (!Hn)
            throw mt(tt2.replace("{}", z)), new Error('Unknown language: "' + z + '"');
          const rg = Wi(Hn);
          let Za = "", Ee = nt || rg;
          const zu = {}, Mt = new X.__emitter(X);
          sg();
          let ot = "", Zs = 0, Vo = 0, Qa = 0, el = false;
          try {
            if (Hn.__emitTokens)
              Hn.__emitTokens(ae, Mt);
            else {
              for (Ee.matcher.considerAll(); ; ) {
                Qa++, el ? el = false : Ee.matcher.considerAll(), Ee.matcher.lastIndex = Vo;
                const G = Ee.matcher.exec(ae);
                if (!G) break;
                const oe = ae.substring(Vo, G.index), Oe = $u(oe, G);
                Vo = G.index + Oe;
              }
              $u(ae.substring(Vo));
            }
            return Mt.finalize(), Za = Mt.toHTML(), {
              language: z,
              value: Za,
              relevance: Zs,
              illegal: false,
              _emitter: Mt,
              _top: Ee
            };
          } catch (G) {
            if (G.message && G.message.includes("Illegal"))
              return {
                language: z,
                value: Ne(ae),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: G.message,
                  index: Vo,
                  context: ae.slice(Vo - 100, Vo + 100),
                  mode: G.mode,
                  resultSoFar: Za
                },
                _emitter: Mt
              };
            if (st)
              return {
                language: z,
                value: Ne(ae),
                illegal: false,
                relevance: 0,
                errorRaised: G,
                _emitter: Mt,
                _top: Ee
              };
            throw G;
          }
        }
        function Ja(z) {
          const ae = {
            value: Ne(z),
            illegal: false,
            relevance: 0,
            _top: te,
            _emitter: new X.__emitter(X)
          };
          return ae._emitter.addText(z), ae;
        }
        function Ya(z, ae) {
          ae = ae || X.languages || Object.keys(M);
          const Me = Ja(z), nt = ae.filter(vo).filter(Du).map(
            (ln) => Ji(ln, z, false)
          );
          nt.unshift(Me);
          const kt = nt.sort((ln, Fn) => {
            if (ln.relevance !== Fn.relevance) return Fn.relevance - ln.relevance;
            if (ln.language && Fn.language) {
              if (vo(ln.language).supersetOf === Fn.language)
                return 1;
              if (vo(Fn.language).supersetOf === ln.language)
                return -1;
            }
            return 0;
          }), [Mn, bo] = kt, Ys = Mn;
          return Ys.secondBest = bo, Ys;
        }
        function qh(z, ae, Me) {
          const nt = ae && H[ae] || Me;
          z.classList.add("hljs"), z.classList.add(`language-${nt}`);
        }
        function Xa(z) {
          let ae = null;
          const Me = jt(z);
          if (ve(Me)) return;
          if (Js(
            "before:highlightElement",
            { el: z, language: Me }
          ), z.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", z);
            return;
          }
          if (z.children.length > 0 && (X.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(z)), X.throwUnescapedHTML))
            throw new $e(
              "One of your code blocks includes unescaped HTML.",
              z.innerHTML
            );
          ae = z;
          const nt = ae.textContent, kt = Me ? gt(nt, { language: Me, ignoreIllegals: true }) : Ya(nt);
          z.innerHTML = kt.value, z.dataset.highlighted = "yes", qh(z, Me, kt.language), z.result = {
            language: kt.language,
            // TODO: remove with version 11.0
            re: kt.relevance,
            relevance: kt.relevance
          }, kt.secondBest && (z.secondBest = {
            language: kt.secondBest.language,
            relevance: kt.secondBest.relevance
          }), Js("after:highlightElement", { el: z, result: kt, text: nt });
        }
        function Kh(z) {
          X = wt(X, z);
        }
        const Wh = () => {
          Gs(), qt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function Gh() {
          Gs(), qt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let Ru = false;
        function Gs() {
          function z() {
            Gs();
          }
          if (document.readyState === "loading") {
            Ru || window.addEventListener("DOMContentLoaded", z, false), Ru = true;
            return;
          }
          document.querySelectorAll(X.cssSelector).forEach(Xa);
        }
        function Jh(z, ae) {
          let Me = null;
          try {
            Me = ae(w);
          } catch (nt) {
            if (mt("Language definition for '{}' could not be registered.".replace("{}", z)), st)
              mt(nt);
            else
              throw nt;
            Me = te;
          }
          Me.name || (Me.name = z), M[z] = Me, Me.rawDefinition = ae.bind(null, w), Me.aliases && Iu(Me.aliases, { languageName: z });
        }
        function Yh(z) {
          delete M[z];
          for (const ae of Object.keys(H))
            H[ae] === z && delete H[ae];
        }
        function Xh() {
          return Object.keys(M);
        }
        function vo(z) {
          return z = (z || "").toLowerCase(), M[z] || M[H[z]];
        }
        function Iu(z, { languageName: ae }) {
          typeof z == "string" && (z = [z]), z.forEach((Me) => {
            H[Me.toLowerCase()] = ae;
          });
        }
        function Du(z) {
          const ae = vo(z);
          return ae && !ae.disableAutodetect;
        }
        function Zh(z) {
          z["before:highlightBlock"] && !z["before:highlightElement"] && (z["before:highlightElement"] = (ae) => {
            z["before:highlightBlock"](
              Object.assign({ block: ae.el }, ae)
            );
          }), z["after:highlightBlock"] && !z["after:highlightElement"] && (z["after:highlightElement"] = (ae) => {
            z["after:highlightBlock"](
              Object.assign({ block: ae.el }, ae)
            );
          });
        }
        function Qh(z) {
          Zh(z), ge.push(z);
        }
        function eg(z) {
          const ae = ge.indexOf(z);
          ae !== -1 && ge.splice(ae, 1);
        }
        function Js(z, ae) {
          const Me = z;
          ge.forEach(function(nt) {
            nt[Me] && nt[Me](ae);
          });
        }
        function tg(z) {
          return qt("10.7.0", "highlightBlock will be removed entirely in v12.0"), qt("10.7.0", "Please use highlightElement now."), Xa(z);
        }
        Object.assign(w, {
          highlight: gt,
          highlightAuto: Ya,
          highlightAll: Gs,
          highlightElement: Xa,
          // TODO: Remove with v12 API
          highlightBlock: tg,
          configure: Kh,
          initHighlighting: Wh,
          initHighlightingOnLoad: Gh,
          registerLanguage: Jh,
          unregisterLanguage: Yh,
          listLanguages: Xh,
          getLanguage: vo,
          registerAliases: Iu,
          autoDetection: Du,
          inherit: wt,
          addPlugin: Qh,
          removePlugin: eg
        }), w.debugMode = function() {
          st = false;
        }, w.safeMode = function() {
          st = true;
        }, w.versionString = me, w.regex = {
          concat: _,
          lookahead: p2,
          either: g,
          optional: f,
          anyNumberOfTimes: m
        };
        for (const z in At)
          typeof At[z] == "object" && t2(At[z]);
        return Object.assign(w, At), w;
      }, Zt = Gi({});
      return Zt.newInstance = () => Gi({}), Al = Zt, Zt.HighlightJS = Zt, Zt.default = Zt, Al;
    }
    var KO = /* @__PURE__ */ qO();
    const WO = /* @__PURE__ */ VO(KO), om = {}, GO = "hljs-";
    function JO(t2) {
      const e = WO.newInstance();
      return t2 && s(t2), {
        highlight: n,
        highlightAuto: o,
        listLanguages: i,
        register: s,
        registerAlias: r,
        registered: a
      };
      function n(l, c2, u) {
        const d = u || om, p2 = typeof d.prefix == "string" ? d.prefix : GO;
        if (!e.getLanguage(l))
          throw new Error("Unknown language: `" + l + "` is not registered");
        e.configure({ __emitter: YO, classPrefix: p2 });
        const m = (
          /** @type {HighlightResult & {_emitter: HastEmitter}} */
          e.highlight(c2, { ignoreIllegals: true, language: l })
        );
        if (m.errorRaised)
          throw new Error("Could not highlight with `Highlight.js`", {
            cause: m.errorRaised
          });
        const f = m._emitter.root, _ = (
          /** @type {RootData} */
          f.data
        );
        return _.language = m.language, _.relevance = m.relevance, f;
      }
      function o(l, c2) {
        const d = (c2 || om).subset || i();
        let p2 = -1, m = 0, f;
        for (; ++p2 < d.length; ) {
          const _ = d[p2];
          if (!e.getLanguage(_)) continue;
          const h2 = n(_, l, c2);
          h2.data && h2.data.relevance !== void 0 && h2.data.relevance > m && (m = h2.data.relevance, f = h2);
        }
        return f || {
          type: "root",
          children: [],
          data: { language: void 0, relevance: m }
        };
      }
      function i() {
        return e.listLanguages();
      }
      function s(l, c2) {
        if (typeof l == "string")
          e.registerLanguage(l, c2);
        else {
          let u;
          for (u in l)
            Object.hasOwn(l, u) && e.registerLanguage(u, l[u]);
        }
      }
      function r(l, c2) {
        if (typeof l == "string")
          e.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof c2 == "string" ? c2 : [...c2],
            { languageName: l }
          );
        else {
          let u;
          for (u in l)
            if (Object.hasOwn(l, u)) {
              const d = l[u];
              e.registerAliases(
                // Note: copy needed because hljs doesn’t accept readonly arrays yet.
                typeof d == "string" ? d : [...d],
                { languageName: u }
              );
            }
        }
      }
      function a(l) {
        return !!e.getLanguage(l);
      }
    }
    class YO {
      /**
       * @param {Readonly<HljsOptions>} options
       *   Configuration.
       * @returns
       *   Instance.
       */
      constructor(e) {
        this.options = e, this.root = {
          type: "root",
          children: [],
          data: { language: void 0, relevance: 0 }
        }, this.stack = [this.root];
      }
      /**
       * @param {string} value
       *   Text to add.
       * @returns {undefined}
       *   Nothing.
       *
       */
      addText(e) {
        if (e === "") return;
        const n = this.stack[this.stack.length - 1], o = n.children[n.children.length - 1];
        o && o.type === "text" ? o.value += e : n.children.push({ type: "text", value: e });
      }
      /**
       *
       * @param {unknown} rawName
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      startScope(e) {
        this.openNode(String(e));
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      endScope() {
        this.closeNode();
      }
      /**
       * @param {HastEmitter} other
       *   Other emitter.
       * @param {string} name
       *   Name of the sublanguage.
       * @returns {undefined}
       *   Nothing.
       */
      __addSublanguage(e, n) {
        const o = this.stack[this.stack.length - 1], i = (
          /** @type {Array<ElementContent>} */
          e.root.children
        );
        n ? o.children.push({
          type: "element",
          tagName: "span",
          properties: { className: [n] },
          children: i
        }) : o.children.push(...i);
      }
      /**
       * @param {string} name
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      openNode(e) {
        const n = this, o = e.split(".").map(function(r, a) {
          return a ? r + "_".repeat(a) : n.options.classPrefix + r;
        }), i = this.stack[this.stack.length - 1], s = {
          type: "element",
          tagName: "span",
          properties: { className: o },
          children: []
        };
        i.children.push(s), this.stack.push(s);
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      closeNode() {
        this.stack.pop();
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      finalize() {
      }
      /**
       * @returns {string}
       *   Nothing.
       */
      toHTML() {
        return "";
      }
    }
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function XO(t2) {
      const e = document.createElement("textarea");
      e.value = t2, e.contentEditable = "true", e.style.position = "fixed", document.body.appendChild(e), e.focus(), e.select();
      const n = document.execCommand("copy");
      return e.remove(), n;
    }
    function ZO(t2) {
      return navigator.clipboard !== void 0 ? navigator.clipboard.writeText(t2) : new Promise((e, n) => {
        const o = XO(t2);
        o ? e(true) : n(o);
      });
    }
    const QO = { class: "code-block-toolbar" }, eN = { class: "wrap editable" }, tN = { class: "wrap" }, nN = { class: "language readonly" }, oN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = ref("content_copy"), o = computed({
          get() {
            return e.node.attrs.language;
          },
          set(c2) {
            e.updateAttributes({ language: c2 });
          }
        }), i = computed({
          get() {
            return e.node.attrs.wrap;
          },
          set(c2) {
            e.updateAttributes({ wrap: c2 });
          }
        }), s = computed(() => i.value ? "text_select_move_down" : "format_text_wrap");
        function r(c2) {
          o.value = c2;
        }
        function a() {
          const c2 = e.node.content.content[0].text;
          ZO(c2).then(() => {
            n.value = "done", setTimeout(() => {
              n.value = "content_copy";
            }, 2e3);
          });
        }
        function l() {
          i.value = !i.value;
        }
        return (c2, u) => (openBlock(), createBlock(unref(ho), mergeProps(e, { class: "o-code-block-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", QO, [
              createBaseVNode("div", eN, [
                createVNode(unref($1), {
                  language: o.value,
                  onSelect: r
                }, null, 8, ["language"])
              ]),
              createBaseVNode("div", tN, [
                createBaseVNode("div", nN, toDisplayString(o.value), 1),
                createVNode(unref(Ye), {
                  icon: s.value,
                  "icon-class": { "rotate-270": i.value },
                  tooltip: "Wrap",
                  class: "editable",
                  onClick: l
                }, null, 8, ["icon", "icon-class"]),
                createVNode(unref(Ye), {
                  icon: n.value,
                  tooltip: "Copy",
                  onClick: a
                }, null, 8, ["icon"])
              ])
            ]),
            createBaseVNode("pre", null, [
              createVNode(unref(_o), {
                as: "code",
                class: normalizeClass({ wrap: i.value })
              }, null, 8, ["class"])
            ])
          ]),
          _: 1
        }, 16));
      }
    }), iN = JO(UO), sN = wT.extend({
      draggable: true,
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          wrap: {
            default: true,
            rendered: false
          }
        };
      },
      addNodeView() {
        return Pn(oN);
      }
    }).configure({
      languageClassPrefix: "language-",
      defaultLanguage: "bash",
      lowlight: iN
    }), rN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = computed(() => e.node.attrs.level);
        return (o, i) => (openBlock(), createBlock(unref(ho), mergeProps(e, {
          class: ["o-heading-view", `h${n.value}`],
          style: `text-align: ${o.node.attrs.textAlign}`
        }), {
          default: withCtx(() => [
            createVNode(unref(_o))
          ]),
          _: 1
        }, 16, ["class", "style"]));
      }
    }), aN = x_.extend({
      draggable: true,
      addNodeView() {
        return Pn(rN);
      }
    }), lN = { class: "horizontal" }, cN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, o) => (openBlock(), createBlock(unref(ho), mergeProps(e, { class: "o-horizontal-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", lN, [
              createVNode(unref(_o), {
                as: "div",
                class: "divider"
              })
            ])
          ]),
          _: 1
        }, 16));
      }
    }), uN = M_.extend({
      draggable: true,
      addNodeView() {
        return Pn(cN);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const dN = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, pN = it.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["img", Pe(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setImage: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: dN,
            type: this.type,
            getAttributes: (t2) => {
              const [, , e, n, o] = t2;
              return { src: n, alt: e, title: o };
            }
          })
        ];
      }
    }), mN = pN.extend({
      draggable: true,
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          size: {
            default: "",
            rendered: false
          },
          // small, medium, large
          ratio: {
            default: "",
            rendered: false
          },
          isDraggable: {
            default: true,
            renderHTML: (e) => ({})
          }
        };
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return e.size = t2.attrs.size, e.ratio = t2.attrs.ratio, ["img", Pe(this.options.HTMLAttributes, e)];
      }
    }), fN = {
      key: 1,
      class: "image-container"
    }, _N = { key: 1 }, hN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { isEditable: n } = Be(), o = ref(false), i = ref(false), s = ref({}), r = ref(null), a = ref(false), l = computed(() => e.node.attrs), c2 = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        }), u = computed({
          get() {
            return e.node.attrs.title;
          },
          set(g) {
            e.updateAttributes({ title: g });
          }
        });
        function d() {
          a.value = true, setTimeout(() => {
            var g;
            (g = r.value) == null || g.focus();
          }, 0);
        }
        function p2() {
          a.value = false;
        }
        function m() {
          c2.value === "init" && h2(true);
        }
        function f(g) {
          switch (o.value = false, g.value) {
            case "replace":
              h2(true);
              break;
          }
        }
        function _(g) {
          c2.value = g, h2(false);
        }
        function h2(g) {
          i.value = g;
        }
        return onMounted(() => {
          h2(c2.value === "init");
        }), (g, k) => {
          var j;
          return openBlock(), createBlock(unref(ho), mergeProps(e, {
            class: ["o-image-view", {
              "with-caption": l.value.alt,
              "with-ratio": l.value.ratio,
              readonly: !((j = g.editor) != null && j.isEditable),
              init: c2.value === "init"
            }],
            size: l.value.size,
            as: "div",
            onClick: m
          }), {
            default: withCtx(() => [
              createVNode(unref(Rs), {
                modelValue: i.value,
                "onUpdate:modelValue": k[1] || (k[1] = (v) => i.value = v),
                placement: c2.value === "init" ? "bottom" : "top",
                "show-arrow": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref($_), {
                    val: c2.value === "init" ? "" : c2.value,
                    type: "image",
                    onInput: _
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var v;
                  return [
                    c2.value === "init" ? (openBlock(), createBlock(unref(D_), {
                      key: 0,
                      icon: "image",
                      placeholder: "Add an image"
                    })) : (openBlock(), createElementBlock("div", fN, [
                      unref(n) ? (openBlock(), createBlock(unref(L_), mergeProps({ key: 0 }, e, { onAction: f }), {
                        default: withCtx(() => [
                          createVNode(unref(Ye), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: d
                          })
                        ]),
                        _: 1
                      }, 16)) : createCommentVNode("", true),
                      createBaseVNode("img", mergeProps(l.value, {
                        draggable: "true",
                        "data-drag-handle": ""
                      }), null, 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: d
                      }, [
                        (v = g.editor) != null && v.isEditable && a.value ? (openBlock(), createBlock(unref(qi), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: r,
                          class: "caption-input",
                          modelValue: u.value,
                          "onUpdate:modelValue": k[0] || (k[0] = (C) => u.value = C),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: p2
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", _N, toDisplayString(u.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(uu), {
                modelValue: o.value,
                "onUpdate:modelValue": k[2] || (k[2] = (v) => o.value = v),
                event: s.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Vi), mergeProps(e, { onAction: f }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class", "size"]);
        };
      }
    }), gN = mN.extend({
      addNodeView() {
        return Pn(hN);
      }
    }).configure({
      inline: true
    }), vN = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", bN = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Fi = (t2, e) => {
      for (const n in e)
        t2[n] = e[n];
      return t2;
    }, vc = "numeric", bc = "ascii", kc = "alpha", ms = "asciinumeric", ss = "alphanumeric", yc = "domain", Mh = "emoji", kN = "scheme", yN = "slashscheme", Ml = "whitespace";
    function wN(t2, e) {
      return t2 in e || (e[t2] = []), e[t2];
    }
    function Xo(t2, e, n) {
      e[vc] && (e[ms] = true, e[ss] = true), e[bc] && (e[ms] = true, e[kc] = true), e[ms] && (e[ss] = true), e[kc] && (e[ss] = true), e[ss] && (e[yc] = true), e[Mh] && (e[yc] = true);
      for (const o in e) {
        const i = wN(o, n);
        i.indexOf(t2) < 0 && i.push(t2);
      }
    }
    function jN(t2, e) {
      const n = {};
      for (const o in e)
        e[o].indexOf(t2) >= 0 && (n[o] = true);
      return n;
    }
    function Qt(t2 = null) {
      this.j = {}, this.jr = [], this.jd = null, this.t = t2;
    }
    Qt.groups = {};
    Qt.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(t2) {
        const e = this, n = e.j[t2];
        if (n)
          return n;
        for (let o = 0; o < e.jr.length; o++) {
          const i = e.jr[o][0], s = e.jr[o][1];
          if (s && i.test(t2))
            return s;
        }
        return e.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(t2, e = false) {
        return e ? t2 in this.j : !!this.go(t2);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(t2, e, n, o) {
        for (let i = 0; i < t2.length; i++)
          this.tt(t2[i], e, n, o);
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(t2, e, n, o) {
        o = o || Qt.groups;
        let i;
        return e && e.j ? i = e : (i = new Qt(e), n && o && Xo(e, n, o)), this.jr.push([t2, i]), i;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(t2, e, n, o) {
        let i = this;
        const s = t2.length;
        if (!s)
          return i;
        for (let r = 0; r < s - 1; r++)
          i = i.tt(t2[r]);
        return i.tt(t2[s - 1], e, n, o);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(t2, e, n, o) {
        o = o || Qt.groups;
        const i = this;
        if (e && e.j)
          return i.j[t2] = e, e;
        const s = e;
        let r, a = i.go(t2);
        if (a ? (r = new Qt(), Fi(r.j, a.j), r.jr.push.apply(r.jr, a.jr), r.jd = a.jd, r.t = a.t) : r = new Qt(), s) {
          if (o)
            if (r.t && typeof r.t == "string") {
              const l = Fi(jN(r.t, o), n);
              Xo(s, l, o);
            } else n && Xo(s, n, o);
          r.t = s;
        }
        return i.j[t2] = r, r;
      }
    };
    const xe = (t2, e, n, o, i) => t2.ta(e, n, o, i), lt = (t2, e, n, o, i) => t2.tr(e, n, o, i), im = (t2, e, n, o, i) => t2.ts(e, n, o, i), $ = (t2, e, n, o, i) => t2.tt(e, n, o, i), so = "WORD", wc = "UWORD", Rh = "ASCIINUMERICAL", Ih = "ALPHANUMERICAL", Ps = "LOCALHOST", jc = "TLD", Ec = "UTLD", Mr = "SCHEME", Ei = "SLASH_SCHEME", Eu = "NUM", Sc = "WS", Su = "NL", fs = "OPENBRACE", _s = "CLOSEBRACE", na = "OPENBRACKET", oa = "CLOSEBRACKET", ia = "OPENPAREN", sa = "CLOSEPAREN", ra = "OPENANGLEBRACKET", aa = "CLOSEANGLEBRACKET", la = "FULLWIDTHLEFTPAREN", ca = "FULLWIDTHRIGHTPAREN", ua = "LEFTCORNERBRACKET", da = "RIGHTCORNERBRACKET", pa = "LEFTWHITECORNERBRACKET", ma = "RIGHTWHITECORNERBRACKET", fa = "FULLWIDTHLESSTHAN", _a = "FULLWIDTHGREATERTHAN", ha = "AMPERSAND", Cu = "APOSTROPHE", ga = "ASTERISK", Eo = "AT", va = "BACKSLASH", ba = "BACKTICK", ka = "CARET", xo = "COLON", xu = "COMMA", ya = "DOLLAR", qn = "DOT", wa = "EQUALS", Tu = "EXCLAMATION", gn = "HYPHEN", hs = "PERCENT", ja = "PIPE", Ea = "PLUS", Sa = "POUND", gs = "QUERY", Ou = "QUOTE", Dh = "FULLWIDTHMIDDLEDOT", Nu = "SEMI", Kn = "SLASH", vs = "TILDE", Ca = "UNDERSCORE", Lh = "EMOJI", xa = "SYM";
    var Ph = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      WORD: so,
      UWORD: wc,
      ASCIINUMERICAL: Rh,
      ALPHANUMERICAL: Ih,
      LOCALHOST: Ps,
      TLD: jc,
      UTLD: Ec,
      SCHEME: Mr,
      SLASH_SCHEME: Ei,
      NUM: Eu,
      WS: Sc,
      NL: Su,
      OPENBRACE: fs,
      CLOSEBRACE: _s,
      OPENBRACKET: na,
      CLOSEBRACKET: oa,
      OPENPAREN: ia,
      CLOSEPAREN: sa,
      OPENANGLEBRACKET: ra,
      CLOSEANGLEBRACKET: aa,
      FULLWIDTHLEFTPAREN: la,
      FULLWIDTHRIGHTPAREN: ca,
      LEFTCORNERBRACKET: ua,
      RIGHTCORNERBRACKET: da,
      LEFTWHITECORNERBRACKET: pa,
      RIGHTWHITECORNERBRACKET: ma,
      FULLWIDTHLESSTHAN: fa,
      FULLWIDTHGREATERTHAN: _a,
      AMPERSAND: ha,
      APOSTROPHE: Cu,
      ASTERISK: ga,
      AT: Eo,
      BACKSLASH: va,
      BACKTICK: ba,
      CARET: ka,
      COLON: xo,
      COMMA: xu,
      DOLLAR: ya,
      DOT: qn,
      EQUALS: wa,
      EXCLAMATION: Tu,
      HYPHEN: gn,
      PERCENT: hs,
      PIPE: ja,
      PLUS: Ea,
      POUND: Sa,
      QUERY: gs,
      QUOTE: Ou,
      FULLWIDTHMIDDLEDOT: Dh,
      SEMI: Nu,
      SLASH: Kn,
      TILDE: vs,
      UNDERSCORE: Ca,
      EMOJI: Lh,
      SYM: xa
    });
    const no = /[a-z]/, Qi = new RegExp("\\p{L}", "u"), Rl = new RegExp("\\p{Emoji}", "u"), oo = /\d/, Il = /\s/, sm = "\r", Dl = `
`, EN = "️", SN = "‍", Ll = "￼";
    let kr = null, yr = null;
    function CN(t2 = []) {
      const e = {};
      Qt.groups = e;
      const n = new Qt();
      kr == null && (kr = rm(vN)), yr == null && (yr = rm(bN)), $(n, "'", Cu), $(n, "{", fs), $(n, "}", _s), $(n, "[", na), $(n, "]", oa), $(n, "(", ia), $(n, ")", sa), $(n, "<", ra), $(n, ">", aa), $(n, "（", la), $(n, "）", ca), $(n, "「", ua), $(n, "」", da), $(n, "『", pa), $(n, "』", ma), $(n, "＜", fa), $(n, "＞", _a), $(n, "&", ha), $(n, "*", ga), $(n, "@", Eo), $(n, "`", ba), $(n, "^", ka), $(n, ":", xo), $(n, ",", xu), $(n, "$", ya), $(n, ".", qn), $(n, "=", wa), $(n, "!", Tu), $(n, "-", gn), $(n, "%", hs), $(n, "|", ja), $(n, "+", Ea), $(n, "#", Sa), $(n, "?", gs), $(n, '"', Ou), $(n, "/", Kn), $(n, ";", Nu), $(n, "~", vs), $(n, "_", Ca), $(n, "\\", va), $(n, "・", Dh);
      const o = lt(n, oo, Eu, {
        [vc]: true
      });
      lt(o, oo, o);
      const i = lt(o, no, Rh, {
        [ms]: true
      }), s = lt(o, Qi, Ih, {
        [ss]: true
      }), r = lt(n, no, so, {
        [bc]: true
      });
      lt(r, oo, i), lt(r, no, r), lt(i, oo, i), lt(i, no, i);
      const a = lt(n, Qi, wc, {
        [kc]: true
      });
      lt(a, no), lt(a, oo, s), lt(a, Qi, a), lt(s, oo, s), lt(s, no), lt(s, Qi, s);
      const l = $(n, Dl, Su, {
        [Ml]: true
      }), c2 = $(n, sm, Sc, {
        [Ml]: true
      }), u = lt(n, Il, Sc, {
        [Ml]: true
      });
      $(n, Ll, u), $(c2, Dl, l), $(c2, Ll, u), lt(c2, Il, u), $(u, sm), $(u, Dl), lt(u, Il, u), $(u, Ll, u);
      const d = lt(n, Rl, Lh, {
        [Mh]: true
      });
      $(d, "#"), lt(d, Rl, d), $(d, EN, d);
      const p2 = $(d, SN);
      $(p2, "#"), lt(p2, Rl, d);
      const m = [[no, r], [oo, i]], f = [[no, null], [Qi, a], [oo, s]];
      for (let _ = 0; _ < kr.length; _++)
        ko(n, kr[_], jc, so, m);
      for (let _ = 0; _ < yr.length; _++)
        ko(n, yr[_], Ec, wc, f);
      Xo(jc, {
        tld: true,
        ascii: true
      }, e), Xo(Ec, {
        utld: true,
        alpha: true
      }, e), ko(n, "file", Mr, so, m), ko(n, "mailto", Mr, so, m), ko(n, "http", Ei, so, m), ko(n, "https", Ei, so, m), ko(n, "ftp", Ei, so, m), ko(n, "ftps", Ei, so, m), Xo(Mr, {
        scheme: true,
        ascii: true
      }, e), Xo(Ei, {
        slashscheme: true,
        ascii: true
      }, e), t2 = t2.sort((_, h2) => _[0] > h2[0] ? 1 : -1);
      for (let _ = 0; _ < t2.length; _++) {
        const h2 = t2[_][0], k = t2[_][1] ? {
          [kN]: true
        } : {
          [yN]: true
        };
        h2.indexOf("-") >= 0 ? k[yc] = true : no.test(h2) ? oo.test(h2) ? k[ms] = true : k[bc] = true : k[vc] = true, im(n, h2, h2, k);
      }
      return im(n, "localhost", Ps, {
        ascii: true
      }), n.jd = new Qt(xa), {
        start: n,
        tokens: Fi({
          groups: e
        }, Ph)
      };
    }
    function Bh(t2, e) {
      const n = xN(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), o = n.length, i = [];
      let s = 0, r = 0;
      for (; r < o; ) {
        let a = t2, l = null, c2 = 0, u = null, d = -1, p2 = -1;
        for (; r < o && (l = a.go(n[r])); )
          a = l, a.accepts() ? (d = 0, p2 = 0, u = a) : d >= 0 && (d += n[r].length, p2++), c2 += n[r].length, s += n[r].length, r++;
        s -= d, r -= p2, c2 -= d, i.push({
          t: u.t,
          // token type/name
          v: e.slice(s - c2, s),
          // string value
          s: s - c2,
          // start index
          e: s
          // end index (excluding)
        });
      }
      return i;
    }
    function xN(t2) {
      const e = [], n = t2.length;
      let o = 0;
      for (; o < n; ) {
        let i = t2.charCodeAt(o), s, r = i < 55296 || i > 56319 || o + 1 === n || (s = t2.charCodeAt(o + 1)) < 56320 || s > 57343 ? t2[o] : t2.slice(o, o + 2);
        e.push(r), o += r.length;
      }
      return e;
    }
    function ko(t2, e, n, o, i) {
      let s;
      const r = e.length;
      for (let a = 0; a < r - 1; a++) {
        const l = e[a];
        t2.j[l] ? s = t2.j[l] : (s = new Qt(o), s.jr = i.slice(), t2.j[l] = s), t2 = s;
      }
      return s = new Qt(n), s.jr = i.slice(), t2.j[e[r - 1]] = s, s;
    }
    function rm(t2) {
      const e = [], n = [];
      let o = 0, i = "0123456789";
      for (; o < t2.length; ) {
        let s = 0;
        for (; i.indexOf(t2[o + s]) >= 0; )
          s++;
        if (s > 0) {
          e.push(n.join(""));
          for (let r = parseInt(t2.substring(o, o + s), 10); r > 0; r--)
            n.pop();
          o += s;
        } else
          n.push(t2[o]), o++;
      }
      return e;
    }
    const Bs = {
      defaultProtocol: "http",
      events: null,
      format: am,
      formatHref: am,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: 1 / 0,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    function Au(t2, e = null) {
      let n = Fi({}, Bs);
      t2 && (n = Fi(n, t2 instanceof Au ? t2.o : t2));
      const o = n.ignoreTags, i = [];
      for (let s = 0; s < o.length; s++)
        i.push(o[s].toUpperCase());
      this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
    }
    Au.prototype = {
      o: Bs,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(t2) {
        return t2;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(t2) {
        return this.get("validate", t2.toString(), t2);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(t2, e, n) {
        const o = e != null;
        let i = this.o[t2];
        return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Bs[t2], typeof i == "function" && o && (i = i(e, n))) : typeof i == "function" && o && (i = i(e, n.t, n)), i);
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(t2, e, n) {
        let o = this.o[t2];
        return typeof o == "function" && e != null && (o = o(e, n.t, n)), o;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(t2) {
        const e = t2.render(this);
        return (this.get("render", null, t2) || this.defaultRender)(e, t2.t, t2);
      }
    };
    function am(t2) {
      return t2;
    }
    function $h(t2, e) {
      this.t = "token", this.v = t2, this.tk = e;
    }
    $h.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
       */
      toHref(t2) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(t2) {
        const e = this.toString(), n = t2.get("truncate", e, this), o = t2.get("format", e, this);
        return n && o.length > n ? o.substring(0, n) + "…" : o;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(t2) {
        return t2.get("formatHref", this.toHref(t2.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(t2 = Bs.defaultProtocol) {
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(t2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(t2) {
        return {
          type: this.t,
          value: this.toFormattedString(t2),
          isLink: this.isLink,
          href: this.toFormattedHref(t2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(t2) {
        return t2.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(t2) {
        const e = this, n = this.toHref(t2.get("defaultProtocol")), o = t2.get("formatHref", n, this), i = t2.get("tagName", n, e), s = this.toFormattedString(t2), r = {}, a = t2.get("className", n, e), l = t2.get("target", n, e), c2 = t2.get("rel", n, e), u = t2.getObj("attributes", n, e), d = t2.getObj("events", n, e);
        return r.href = o, a && (r.class = a), l && (r.target = l), c2 && (r.rel = c2), u && Fi(r, u), {
          tagName: i,
          attributes: r,
          content: s,
          eventListeners: d
        };
      }
    };
    function Ga(t2, e) {
      class n extends $h {
        constructor(i, s) {
          super(i, s), this.t = t2;
        }
      }
      for (const o in e)
        n.prototype[o] = e[o];
      return n.t = t2, n;
    }
    const lm = Ga("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    }), cm = Ga("text"), TN = Ga("nl"), wr = Ga("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(t2 = Bs.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${t2}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const t2 = this.tk;
        return t2.length >= 2 && t2[0].t !== Ps && t2[1].t === xo;
      }
    }), hn = (t2) => new Qt(t2);
    function ON({
      groups: t2
    }) {
      const e = t2.domain.concat([ha, ga, Eo, va, ba, ka, ya, wa, gn, Eu, hs, ja, Ea, Sa, Kn, xa, vs, Ca]), n = [xo, xu, qn, Tu, hs, gs, Ou, Nu, ra, aa, fs, _s, oa, na, ia, sa, la, ca, ua, da, pa, ma, fa, _a], o = [ha, Cu, ga, va, ba, ka, ya, wa, gn, fs, _s, hs, ja, Ea, Sa, gs, Kn, xa, vs, Ca], i = hn(), s = $(i, vs);
      xe(s, o, s), xe(s, t2.domain, s);
      const r = hn(), a = hn(), l = hn();
      xe(i, t2.domain, r), xe(i, t2.scheme, a), xe(i, t2.slashscheme, l), xe(r, o, s), xe(r, t2.domain, r);
      const c2 = $(r, Eo);
      $(s, Eo, c2), $(a, Eo, c2), $(l, Eo, c2);
      const u = $(s, qn);
      xe(u, o, s), xe(u, t2.domain, s);
      const d = hn();
      xe(c2, t2.domain, d), xe(d, t2.domain, d);
      const p2 = $(d, qn);
      xe(p2, t2.domain, d);
      const m = hn(lm);
      xe(p2, t2.tld, m), xe(p2, t2.utld, m), $(c2, Ps, m);
      const f = $(d, gn);
      $(f, gn, f), xe(f, t2.domain, d), xe(m, t2.domain, d), $(m, qn, p2), $(m, gn, f);
      const _ = $(m, xo);
      xe(_, t2.numeric, lm);
      const h2 = $(r, gn), g = $(r, qn);
      $(h2, gn, h2), xe(h2, t2.domain, r), xe(g, o, s), xe(g, t2.domain, r);
      const k = hn(wr);
      xe(g, t2.tld, k), xe(g, t2.utld, k), xe(k, t2.domain, r), xe(k, o, s), $(k, qn, g), $(k, gn, h2), $(k, Eo, c2);
      const j = $(k, xo), v = hn(wr);
      xe(j, t2.numeric, v);
      const C = hn(wr), E = hn();
      xe(C, e, C), xe(C, n, E), xe(E, e, C), xe(E, n, E), $(k, Kn, C), $(v, Kn, C);
      const B = $(a, xo), U = $(l, xo), P = $(U, Kn), V = $(P, Kn);
      xe(a, t2.domain, r), $(a, qn, g), $(a, gn, h2), xe(l, t2.domain, r), $(l, qn, g), $(l, gn, h2), xe(B, t2.domain, C), $(B, Kn, C), $(B, gs, C), xe(V, t2.domain, C), xe(V, e, C), $(V, Kn, C);
      const ne = [
        [fs, _s],
        // {}
        [na, oa],
        // []
        [ia, sa],
        // ()
        [ra, aa],
        // <>
        [la, ca],
        // （）
        [ua, da],
        // 「」
        [pa, ma],
        // 『』
        [fa, _a]
        // ＜＞
      ];
      for (let pe = 0; pe < ne.length; pe++) {
        const [we, ye] = ne[pe], _e = $(C, we);
        $(E, we, _e), $(_e, ye, C);
        const he = hn(wr);
        xe(_e, e, he);
        const N = hn();
        xe(_e, n), xe(he, e, he), xe(he, n, N), xe(N, e, he), xe(N, n, N), $(he, ye, C), $(N, ye, C);
      }
      return $(i, Ps, k), $(i, Su, TN), {
        start: i,
        tokens: Ph
      };
    }
    function NN(t2, e, n) {
      let o = n.length, i = 0, s = [], r = [];
      for (; i < o; ) {
        let a = t2, l = null, c2 = null, u = 0, d = null, p2 = -1;
        for (; i < o && !(l = a.go(n[i].t)); )
          r.push(n[i++]);
        for (; i < o && (c2 = l || a.go(n[i].t)); )
          l = null, a = c2, a.accepts() ? (p2 = 0, d = a) : p2 >= 0 && p2++, i++, u++;
        if (p2 < 0)
          i -= u, i < o && (r.push(n[i]), i++);
        else {
          r.length > 0 && (s.push(Pl(cm, e, r)), r = []), i -= p2, u -= p2;
          const m = d.t, f = n.slice(i - u, i);
          s.push(Pl(m, e, f));
        }
      }
      return r.length > 0 && s.push(Pl(cm, e, r)), s;
    }
    function Pl(t2, e, n) {
      const o = n[0].s, i = n[n.length - 1].e, s = e.slice(o, i);
      return new t2(s, n);
    }
    const AN = typeof console < "u" && console && console.warn || (() => {
    }), MN = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", rt = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
    function RN() {
      return Qt.groups = {}, rt.scanner = null, rt.parser = null, rt.tokenQueue = [], rt.pluginQueue = [], rt.customSchemes = [], rt.initialized = false, rt;
    }
    function um(t2, e = false) {
      if (rt.initialized && AN(`linkifyjs: already initialized - will not register custom scheme "${t2}" ${MN}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t2))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
      rt.customSchemes.push([t2, e]);
    }
    function IN() {
      rt.scanner = CN(rt.customSchemes);
      for (let t2 = 0; t2 < rt.tokenQueue.length; t2++)
        rt.tokenQueue[t2][1]({
          scanner: rt.scanner
        });
      rt.parser = ON(rt.scanner.tokens);
      for (let t2 = 0; t2 < rt.pluginQueue.length; t2++)
        rt.pluginQueue[t2][1]({
          scanner: rt.scanner,
          parser: rt.parser
        });
      return rt.initialized = true, rt;
    }
    function Mu(t2) {
      return rt.initialized || IN(), NN(rt.parser.start, t2, Bh(rt.scanner.start, t2));
    }
    Mu.scan = Bh;
    function zh(t2, e = null, n = null) {
      if (e && typeof e == "object") {
        if (n)
          throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        n = e, e = null;
      }
      const o = new Au(n), i = Mu(t2), s = [];
      for (let r = 0; r < i.length; r++) {
        const a = i[r];
        a.isLink && (!e || a.t === e) && o.check(a) && s.push(a.toFormattedObject(o));
      }
      return s;
    }
    function DN(t2) {
      return t2.length === 1 ? t2[0].isLink : t2.length === 3 && t2[1].isLink ? ["()", "[]"].includes(t2[0].value + t2[2].value) : false;
    }
    function LN(t2) {
      return new ze({
        key: new Fe("autolink"),
        appendTransaction: (e, n, o) => {
          const i = e.some((c2) => c2.docChanged) && !n.doc.eq(o.doc), s = e.some((c2) => c2.getMeta("preventAutolink"));
          if (!i || s)
            return;
          const { tr: r } = o, a = Ck(n.doc, [...e]);
          if (Mk(a).forEach(({ newRange: c2 }) => {
            const u = Tk(o.doc, c2, (m) => m.isTextblock);
            let d, p2;
            if (u.length > 1 ? (d = u[0], p2 = o.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && o.doc.textBetween(c2.from, c2.to, " ", " ").endsWith(" ") && (d = u[0], p2 = o.doc.textBetween(d.pos, c2.to, void 0, " ")), d && p2) {
              const m = p2.split(" ").filter((g) => g !== "");
              if (m.length <= 0)
                return false;
              const f = m[m.length - 1], _ = d.pos + p2.lastIndexOf(f);
              if (!f)
                return false;
              const h2 = Mu(f).map((g) => g.toObject(t2.defaultProtocol));
              if (!DN(h2))
                return false;
              h2.filter((g) => g.isLink).map((g) => ({
                ...g,
                from: _ + g.start + 1,
                to: _ + g.end + 1
              })).filter((g) => o.schema.marks.code ? !o.doc.rangeHasMark(g.from, g.to, o.schema.marks.code) : true).filter((g) => t2.validate(g.value)).filter((g) => t2.shouldAutoLink(g.value)).forEach((g) => {
                Yc(g.from, g.to, o.doc).some((k) => k.mark.type === t2.type) || r.addMark(g.from, g.to, t2.type.create({
                  href: g.href
                }));
              });
            }
          }), !!r.steps.length)
            return r;
        }
      });
    }
    function PN(t2) {
      return new ze({
        key: new Fe("handleClickLink"),
        props: {
          handleClick: (e, n, o) => {
            var i, s;
            if (o.button !== 0 || !e.editable)
              return false;
            let r = o.target;
            const a = [];
            for (; r.nodeName !== "DIV"; )
              a.push(r), r = r.parentNode;
            if (!a.find((p2) => p2.nodeName === "A"))
              return false;
            const l = Xf(e.state, t2.type.name), c2 = o.target, u = (i = c2 == null ? void 0 : c2.href) !== null && i !== void 0 ? i : l.href, d = (s = c2 == null ? void 0 : c2.target) !== null && s !== void 0 ? s : l.target;
            return c2 && u ? (window.open(u, d), true) : false;
          }
        }
      });
    }
    function BN(t2) {
      return new ze({
        key: new Fe("handlePasteLink"),
        props: {
          handlePaste: (e, n, o) => {
            const { state: i } = e, { selection: s } = i, { empty: r } = s;
            if (r)
              return false;
            let a = "";
            o.content.forEach((c2) => {
              a += c2.textContent;
            });
            const l = zh(a, { defaultProtocol: t2.defaultProtocol }).find((c2) => c2.isLink && c2.value === a);
            return !a || !l ? false : t2.editor.commands.setMark(t2.type, {
              href: l.href
            });
          }
        }
      });
    }
    const $N = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
    function qo(t2, e) {
      const n = [
        "http",
        "https",
        "ftp",
        "ftps",
        "mailto",
        "tel",
        "callto",
        "sms",
        "cid",
        "xmpp"
      ];
      return e && e.forEach((o) => {
        const i = typeof o == "string" ? o : o.scheme;
        i && n.push(i);
      }), !t2 || t2.replace($N, "").match(new RegExp(
        // eslint-disable-next-line no-useless-escape
        `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
        "i"
      ));
    }
    const Fh = jn.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      exitable: true,
      onCreate() {
        this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t2) => {
          if (typeof t2 == "string") {
            um(t2);
            return;
          }
          um(t2.scheme, t2.optionalSlashes);
        });
      },
      onDestroy() {
        RN();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          defaultProtocol: "http",
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          isAllowedUri: (t2, e) => !!qo(t2, e.protocols),
          validate: (t2) => !!t2,
          shouldAutoLink: (t2) => !!t2
        };
      },
      addAttributes() {
        return {
          href: {
            default: null,
            parseHTML(t2) {
              return t2.getAttribute("href");
            }
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]",
            getAttrs: (t2) => {
              const e = t2.getAttribute("href");
              return !e || !this.options.isAllowedUri(e, {
                defaultValidate: (n) => !!qo(n, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol
              }) ? false : null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return this.options.isAllowedUri(t2.href, {
          defaultValidate: (e) => !!qo(e, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? ["a", Pe(this.options.HTMLAttributes, t2), 0] : [
          "a",
          Pe(this.options.HTMLAttributes, { ...t2, href: "" }),
          0
        ];
      },
      addCommands() {
        return {
          setLink: (t2) => ({ chain: e }) => {
            const { href: n } = t2;
            return this.options.isAllowedUri(n, {
              defaultValidate: (o) => !!qo(o, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().setMark(this.name, t2).setMeta("preventAutolink", true).run() : false;
          },
          toggleLink: (t2) => ({ chain: e }) => {
            const { href: n } = t2;
            return this.options.isAllowedUri(n, {
              defaultValidate: (o) => !!qo(o, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().toggleMark(this.name, t2, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() : false;
          },
          unsetLink: () => ({ chain: t2 }) => t2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run()
        };
      },
      addPasteRules() {
        return [
          Bo({
            find: (t2) => {
              const e = [];
              if (t2) {
                const { protocols: n, defaultProtocol: o } = this.options, i = zh(t2).filter((s) => s.isLink && this.options.isAllowedUri(s.value, {
                  defaultValidate: (r) => !!qo(r, n),
                  protocols: n,
                  defaultProtocol: o
                }));
                i.length && i.forEach((s) => e.push({
                  text: s.value,
                  data: {
                    href: s.href
                  },
                  index: s.start
                }));
              }
              return e;
            },
            type: this.type,
            getAttributes: (t2) => {
              var e;
              return {
                href: (e = t2.data) === null || e === void 0 ? void 0 : e.href
              };
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const t2 = [], { protocols: e, defaultProtocol: n } = this.options;
        return this.options.autolink && t2.push(LN({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (o) => this.options.isAllowedUri(o, {
            defaultValidate: (i) => !!qo(i, e),
            protocols: e,
            defaultProtocol: n
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })), this.options.openOnClick === true && t2.push(PN({
          type: this.type
        })), this.options.linkOnPaste && t2.push(BN({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })), t2;
      }
    });
    function zN(t2) {
      return new ze({
        key: new Fe("handleClickSelectLink"),
        props: {
          handleClick: (e, n, o) => {
            const { schema: i, doc: s, tr: r } = e.state, a = Ui(s.resolve(n), i.marks.link);
            if (!a) return false;
            const l = s.resolve(a.from), c2 = s.resolve(a.to), u = r.setSelection(new re(l, c2));
            return e.dispatch(u), true;
          }
        }
      });
    }
    const FN = Fh.extend({
      addProseMirrorPlugins() {
        var t2;
        return [
          ...((t2 = this.parent) == null ? void 0 : t2.call(this)) || [],
          zN({
            type: this.type
          })
        ];
      }
    }).configure({
      openOnClick: false
    }), HN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2;
        return (n, o) => (openBlock(), createBlock(unref(ho), mergeProps(e, { class: "o-paragraph-view" }), {
          default: withCtx(() => [
            createVNode(unref(_o), {
              as: "p",
              style: normalizeStyle(`text-align: ${n.node.attrs.textAlign}`)
            }, null, 8, ["style"])
          ]),
          _: 1
        }, 16));
      }
    }), UN = R_.extend({
      draggable: false,
      addNodeView() {
        return Pn(HN, {
          stopEvent: () => false
        });
      }
    }), Hh = it.create({
      name: "tableCell",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (t2) => {
              const e = t2.getAttribute("colwidth");
              return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
            }
          }
        };
      },
      tableRole: "cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "td" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["td", Pe(this.options.HTMLAttributes, t2), 0];
      }
    }), VN = { class: "add" }, qN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { isEditable: o, run: i } = Be(), s = ref(false);
        function r() {
          s.value = true;
        }
        function a() {
          l("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function l(c2, u = {}) {
          c2 === "tableDeleteRow" && (s.value = false), setTimeout(() => {
            i(e.editor, c2, u);
          }, 0);
        }
        return (c2, u) => (openBlock(), createBlock(unref(ru), mergeProps({
          class: "o-table-cell-view",
          as: "td"
        }, c2.node.attrs, {
          style: { background: c2.node.attrs.background }
        }), {
          default: withCtx(() => [
            unref(o) ? (openBlock(), createBlock(unref(Rs), {
              key: 0,
              modelValue: s.value,
              "onUpdate:modelValue": u[2] || (u[2] = (d) => s.value = d),
              placement: "left",
              "tippy-class": "o-row-popover",
              offset: [16, 40],
              "hide-click-outside": ""
            }, {
              "popover-content": withCtx(() => [
                createVNode(unref(St), {
                  icon: "select_all",
                  tooltip: unref(n)("table.removeColumn"),
                  onClick: a
                }, null, 8, ["tooltip"]),
                createVNode(unref(St), {
                  icon: "delete",
                  tooltip: unref(n)("table.removeRow"),
                  onClick: u[1] || (u[1] = (d) => l("tableDeleteRow"))
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createBaseVNode("section", {
                  class: normalizeClass(["row-handler", { active: s.value }]),
                  onClick: r
                }, [
                  createBaseVNode("div", VN, [
                    u[3] || (u[3] = createBaseVNode("div", { class: "indicator" }, [
                      createBaseVNode("svg", {
                        width: "3",
                        height: "3",
                        viewBox: "0 0 3 3",
                        fill: "none"
                      }, [
                        createBaseVNode("circle", {
                          cx: "1.5",
                          cy: "1.5",
                          r: "1.5",
                          fill: "#BBBFC4"
                        })
                      ])
                    ], -1)),
                    createVNode(unref(dc), {
                      icon: "add_circle",
                      color: unref(Ve).blue,
                      tooltip: unref(n)("table.addRow"),
                      placement: "left",
                      onClick: u[0] || (u[0] = withModifiers((d) => l("tableAddRow"), ["stop"]))
                    }, null, 8, ["color", "tooltip"])
                  ])
                ], 2)
              ]),
              _: 1
            }, 8, ["modelValue"])) : createCommentVNode("", true),
            createVNode(unref(_o))
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), KN = Hh.extend({
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Pn(qN, {
          stopEvent: () => false
        });
      }
    }), Uh = it.create({
      name: "tableHeader",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (t2) => {
              const e = t2.getAttribute("colwidth");
              return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
            }
          }
        };
      },
      tableRole: "header_cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "th" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["th", Pe(this.options.HTMLAttributes, t2), 0];
      }
    }), WN = { class: "add" }, GN = { class: "add" }, JN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { tr: n } = Ae(), { isEditable: o, run: i } = Be(), s = ref(false), r = ref(false);
        function a() {
          setTimeout(() => {
            s.value = true;
          }, 0);
        }
        function l() {
          r.value = true;
        }
        function c2() {
          s.value = false, d("tableSelectColumn", {
            pos: e.getPos()
          });
        }
        function u() {
          d("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function d(p2, m = {}) {
          p2 === "tableDeleteRow" ? r.value = false : p2 === "tableDeleteColumn" && (s.value = false), setTimeout(() => {
            i(e.editor, p2, m);
          }, 0);
        }
        return (p2, m) => (openBlock(), createBlock(unref(ru), mergeProps({
          class: "o-table-header-view",
          as: "th"
        }, p2.node.attrs, {
          style: { background: p2.node.attrs.background }
        }), {
          default: withCtx(() => [
            unref(o) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(unref(Rs), {
                modelValue: s.value,
                "onUpdate:modelValue": m[2] || (m[2] = (f) => s.value = f),
                placement: "top",
                "tippy-class": "o-column-popover",
                offset: [0, 20],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(St), {
                    icon: "select_all",
                    tooltip: unref(n)("table.removeColumn"),
                    onClick: c2
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(St), {
                    icon: "delete",
                    tooltip: unref(n)("table.removeColumn"),
                    onClick: m[1] || (m[1] = (f) => d("tableDeleteColumn"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["col-handler", { active: s.value }]),
                    onClick: a
                  }, [
                    createBaseVNode("div", WN, [
                      m[6] || (m[6] = createBaseVNode("div", { class: "indicator" }, [
                        createBaseVNode("svg", {
                          width: "3",
                          height: "3",
                          viewBox: "0 0 3 3",
                          fill: "none"
                        }, [
                          createBaseVNode("circle", {
                            cx: "1.5",
                            cy: "1.5",
                            r: "1.5",
                            fill: "#BBBFC4"
                          })
                        ])
                      ], -1)),
                      createVNode(unref(dc), {
                        icon: "add_circle",
                        color: unref(Ve).blue,
                        tooltip: unref(n)("table.addColumn"),
                        onClick: m[0] || (m[0] = withModifiers((f) => d("tableAddColumn"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createVNode(unref(Rs), {
                modelValue: r.value,
                "onUpdate:modelValue": m[5] || (m[5] = (f) => r.value = f),
                placement: "left",
                "tippy-class": "o-row-popover",
                offset: [15, 40],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(St), {
                    icon: "select_all",
                    tooltip: unref(n)("table.removeColumn"),
                    onClick: u
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(St), {
                    icon: "delete",
                    tooltip: unref(n)("table.removeRow"),
                    onClick: m[4] || (m[4] = (f) => d("tableDeleteRow"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["row-handler", { active: r.value }]),
                    onClick: l
                  }, [
                    createBaseVNode("div", GN, [
                      m[7] || (m[7] = createBaseVNode("div", { class: "indicator" }, [
                        createBaseVNode("svg", {
                          width: "3",
                          height: "3",
                          viewBox: "0 0 3 3",
                          fill: "none"
                        }, [
                          createBaseVNode("circle", {
                            cx: "1.5",
                            cy: "1.5",
                            r: "1.5",
                            fill: "#BBBFC4"
                          })
                        ])
                      ], -1)),
                      createVNode(unref(dc), {
                        icon: "add_circle",
                        color: unref(Ve).blue,
                        tooltip: unref(n)("table.addRow"),
                        placement: "left",
                        onClick: m[3] || (m[3] = withModifiers((f) => d("tableAddRow"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 64)) : createCommentVNode("", true),
            createVNode(unref(_o))
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), YN = Uh.extend({
      addAttributes() {
        var t2;
        return {
          ...(t2 = this.parent) == null ? void 0 : t2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Pn(JN, {
          stopEvent: () => false
        });
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const XN = it.create({
      name: "table-wrapper",
      group: "block",
      content: "table",
      draggable: true,
      parseHTML() {
        return [{ tag: "table-wrapper" }];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["table-wrapper", Pe(t2), 0];
      }
    }), ZN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, n = inject("sideNode", { value: false }), o = ref(false), i = computed(() => {
          const { selection: r } = e.editor.view.state, a = r.from, l = e.getPos(), c2 = l + e.node.nodeSize;
          return a >= l && a <= c2;
        });
        function s(r) {
          o.value = r;
        }
        return watch(i, (r) => {
          s(r);
        }), (r, a) => (openBlock(), createBlock(unref(ho), mergeProps(e, {
          class: ["o-table-wrapper-view", { "side-node-enabled": unref(n) }]
        }), {
          default: withCtx(() => [
            createVNode(unref(_o), { as: "table" })
          ]),
          _: 1
        }, 16, ["class"]));
      }
    }), QN = XN.extend({
      addNodeView() {
        return Pn(ZN, {
          stopEvent: () => false
        });
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const eA = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, tA = it.create({
      name: "video",
      draggable: true,
      addOptions() {
        return {
          inline: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      addAttributes() {
        return {
          // small, medium, large
          caption: {
            default: "",
            rendered: false
          },
          src: {
            default: null,
            parseHTML: (t2) => {
              var e;
              return ((e = t2.firstElementChild) == null ? void 0 : e.src) ?? "";
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "video"
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "video",
          {
            caption: t2.attrs.caption
          },
          ["source", Pe(this.options.HTMLAttributes, e)]
        ];
      },
      addCommands() {
        return {
          setVideo: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: eA,
            type: this.type,
            getAttributes: (t2) => {
              const [e] = t2;
              return { src: e };
            }
          })
        ];
      }
    }), nA = {
      key: 1,
      class: "video-container"
    }, oA = { key: 1 }, iA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: Ot,
      setup(t2) {
        const e = t2, { isEditable: n } = Be(), o = ref(false), i = ref({}), s = ref(null), r = ref(false), a = ref(false), l = computed({
          get() {
            return e.node.attrs.caption;
          },
          set(g) {
            e.updateAttributes({ caption: g });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        });
        function u(g) {
          switch (o.value = false, g.value) {
            case "replace":
              h2(true);
              break;
          }
        }
        function d() {
          r.value = true, setTimeout(() => {
            var g;
            (g = s.value) == null || g.focus();
          }, 0);
        }
        function p2() {
          r.value = false;
        }
        function m() {
          c2.value === "init" && h2(true);
        }
        function f(g) {
          o.value = true, i.value = g;
        }
        function _(g) {
          c2.value = g, h2(false);
        }
        function h2(g) {
          a.value = g;
        }
        return onMounted(() => {
          h2(c2.value === "init");
        }), (g, k) => {
          var j;
          return openBlock(), createBlock(unref(ho), mergeProps(e, {
            class: ["o-video-view", {
              readonly: !((j = g.editor) != null && j.isEditable),
              init: c2.value === "init"
            }],
            as: "div",
            onContextmenu: withModifiers(f, ["prevent"]),
            onClick: m
          }), {
            default: withCtx(() => [
              createVNode(unref(Rs), {
                modelValue: a.value,
                "onUpdate:modelValue": k[1] || (k[1] = (v) => a.value = v),
                placement: c2.value === "init" ? "bottom" : "top"
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref($_), {
                    val: c2.value === "init" ? "" : c2.value,
                    type: "video",
                    onInput: _
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var v;
                  return [
                    c2.value === "init" ? (openBlock(), createBlock(unref(D_), {
                      key: 0,
                      icon: "videocam",
                      placeholder: "Add a video"
                    })) : (openBlock(), createElementBlock("div", nA, [
                      k[3] || (k[3] = createBaseVNode("div", { class: "video-cover" }, null, -1)),
                      unref(n) ? (openBlock(), createBlock(unref(L_), mergeProps({ key: 0 }, e, { onAction: u }), {
                        default: withCtx(() => [
                          createVNode(unref(Ye), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: d
                          })
                        ]),
                        _: 1
                      }, 16)) : createCommentVNode("", true),
                      createBaseVNode("video", mergeProps(g.node.attrs, {
                        draggable: "true",
                        "data-drag-handle": "",
                        controls: ""
                      }), [
                        createBaseVNode("source", normalizeProps(guardReactiveProps(g.node.attrs)), null, 16)
                      ], 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: d
                      }, [
                        (v = g.editor) != null && v.isEditable && r.value ? (openBlock(), createBlock(unref(qi), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: s,
                          class: "caption-input",
                          modelValue: l.value,
                          "onUpdate:modelValue": k[0] || (k[0] = (C) => l.value = C),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: p2
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", oA, toDisplayString(l.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(uu), {
                modelValue: o.value,
                "onUpdate:modelValue": k[2] || (k[2] = (v) => o.value = v),
                event: i.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Vi), mergeProps(e, { onAction: u }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class"]);
        };
      }
    }), sA = tA.extend({
      addNodeView() {
        return Pn(iA);
      }
    }), rA = [
      "BackColor",
      "Focus",
      "FontFamily",
      "ForeColor",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline",
      "OHorizontalRule",
      "OUniqueID"
    ], aA = [
      "BackColor",
      "Blockquote",
      "Bold",
      "BulletList",
      "Code",
      "CodeBlockLowlight",
      "Focus",
      "FontFamily",
      "ForeColor",
      "HorizontalRule",
      "Image",
      "Italic",
      "Link",
      "ListItem",
      "OrderedList",
      "Strike",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline"
    ], lA = [
      "OBlockquote",
      "OCallout",
      "OCodeBlock",
      "OColon",
      "OColorHighlighter",
      "OColumnExtension",
      "ODiagram",
      "ODoc",
      "ODraggableItem",
      "OEmbed",
      "OFocus",
      "OFontFamily",
      "OFormatClear",
      "OHeading",
      "OHorizontalRule",
      "OIframe",
      "OImage",
      "OIndent",
      "OInsertHtml",
      "OKatexBlock",
      "OKatexInline",
      "OLineHeight",
      "OLink",
      "OModelViewer",
      "OParagraph",
      "OPrint",
      "OSlash",
      "OSlashZh",
      "OTOC",
      "OTableWrapper",
      "OTitle",
      "OTodoItem",
      "OTrailingNode",
      "OUniqueID",
      "OVideo"
    ], cA = [...aA, ...lA], uA = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, dA = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, pA = jn.create({
      name: "highlight",
      addOptions() {
        return {
          multicolor: false,
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return this.options.multicolor ? {
          color: {
            default: null,
            parseHTML: (t2) => t2.getAttribute("data-color") || t2.style.backgroundColor,
            renderHTML: (t2) => t2.color ? {
              "data-color": t2.color,
              style: `background-color: ${t2.color}; color: inherit`
            } : {}
          }
        } : {};
      },
      parseHTML() {
        return [
          {
            tag: "mark"
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["mark", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setHighlight: (t2) => ({ commands: e }) => e.setMark(this.name, t2),
          toggleHighlight: (t2) => ({ commands: e }) => e.toggleMark(this.name, t2),
          unsetHighlight: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
        };
      },
      addInputRules() {
        return [
          ci({
            find: uA,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Bo({
            find: dA,
            type: this.type
          })
        ];
      }
    }), mA = We.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new ze({
            key: new Fe("focus"),
            props: {
              decorations: ({ doc: t2, selection: e }) => {
                const { isEditable: n, isFocused: o } = this.editor, { anchor: i } = e, s = [];
                if (!n || !o)
                  return qe.create(t2, []);
                let r = 0;
                this.options.mode === "deepest" && t2.descendants((l, c2) => {
                  if (l.isText)
                    return;
                  if (!(i >= c2 && i <= c2 + l.nodeSize - 1))
                    return false;
                  r += 1;
                });
                let a = 0;
                return t2.descendants((l, c2) => {
                  if (l.isText || !(i >= c2 && i <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && r - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  s.push(_t.node(c2, c2 + l.nodeSize, {
                    class: this.options.className
                  }));
                }), qe.create(t2, s);
              }
            }
          })
        ];
      }
    }), fA = We.create({
      name: "fontFamily",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontFamily: {
                default: null,
                parseHTML: (t2) => t2.style.fontFamily,
                renderHTML: (t2) => t2.fontFamily ? {
                  style: `font-family: ${t2.fontFamily}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontFamily: (t2) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t2 }).run(),
          unsetFontFamily: () => ({ chain: t2 }) => t2().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
        };
      }
    }), _A = We.create({
      name: "color",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (t2) => {
                  var e;
                  return (e = t2.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
                },
                renderHTML: (t2) => t2.color ? {
                  style: `color: ${t2.color}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setColor: (t2) => ({ chain: e }) => e().setMark("textStyle", { color: t2 }).run(),
          unsetColor: () => ({ chain: t2 }) => t2().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
        };
      }
    }), hA = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, gA = it.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["img", Pe(this.options.HTMLAttributes, t2)];
      },
      addCommands() {
        return {
          setImage: (t2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: t2
          })
        };
      },
      addInputRules() {
        return [
          Ha({
            find: hA,
            type: this.type,
            getAttributes: (t2) => {
              const [, , e, n, o] = t2;
              return { src: n, alt: e, title: o };
            }
          })
        ];
      }
    }), vA = /^\s*(\[([( |x])?\])\s$/, bA = it.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList"
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (t2) => {
              const e = t2.getAttribute("data-checked");
              return e === "" || e === "true";
            },
            renderHTML: (t2) => ({
              "data-checked": t2.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node: t2, HTMLAttributes: e }) {
        return [
          "li",
          Pe(this.options.HTMLAttributes, e, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: t2.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      addKeyboardShortcuts() {
        const t2 = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        return this.options.nested ? {
          ...t2,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        } : t2;
      },
      addNodeView() {
        return ({ node: t2, HTMLAttributes: e, getPos: n, editor: o }) => {
          const i = document.createElement("li"), s = document.createElement("label"), r = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
          return s.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c2) => c2.preventDefault()), a.addEventListener("change", (c2) => {
            if (!o.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked;
              return;
            }
            const { checked: u } = c2.target;
            o.isEditable && typeof n == "function" && o.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: d }) => {
              const p2 = n();
              if (typeof p2 != "number")
                return false;
              const m = d.doc.nodeAt(p2);
              return d.setNodeMarkup(p2, void 0, {
                ...m == null ? void 0 : m.attrs,
                checked: u
              }), true;
            }).run(), !o.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t2, u) || (a.checked = !a.checked));
          }), Object.entries(this.options.HTMLAttributes).forEach(([c2, u]) => {
            i.setAttribute(c2, u);
          }), i.dataset.checked = t2.attrs.checked, a.checked = t2.attrs.checked, s.append(a, r), i.append(s, l), Object.entries(e).forEach(([c2, u]) => {
            i.setAttribute(c2, u);
          }), {
            dom: i,
            contentDOM: l,
            update: (c2) => c2.type !== this.type ? false : (i.dataset.checked = c2.attrs.checked, a.checked = c2.attrs.checked, true)
          };
        };
      },
      addInputRules() {
        return [
          Di({
            find: vA,
            type: this.type,
            getAttributes: (t2) => ({
              checked: t2[t2.length - 1] === "x"
            })
          })
        ];
      }
    }), kA = it.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["ul", Pe(this.options.HTMLAttributes, t2, { "data-type": this.name }), 0];
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: t2 }) => t2.toggleList(this.name, this.options.itemTypeName)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    }), yA = We.create({
      name: "textAlign",
      addOptions() {
        return {
          types: [],
          alignments: ["left", "center", "right", "justify"],
          defaultAlignment: null
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              textAlign: {
                default: this.options.defaultAlignment,
                parseHTML: (t2) => {
                  const e = t2.style.textAlign;
                  return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
                },
                renderHTML: (t2) => t2.textAlign ? { style: `text-align: ${t2.textAlign}` } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setTextAlign: (t2) => ({ commands: e }) => this.options.alignments.includes(t2) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t2 })).every((n) => n) : false,
          unsetTextAlign: () => ({ commands: t2 }) => this.options.types.map((e) => t2.resetAttributes(e, "textAlign")).every((e) => e)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
          "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
          "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
          "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
        };
      }
    }), wA = (t2) => pt({
      find: /--$/,
      replace: t2 ?? "—"
    }), jA = (t2) => pt({
      find: /\.\.\.$/,
      replace: t2 ?? "…"
    }), EA = (t2) => pt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
      replace: t2 ?? "“"
    }), SA = (t2) => pt({
      find: /"$/,
      replace: t2 ?? "”"
    }), CA = (t2) => pt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
      replace: t2 ?? "‘"
    }), xA = (t2) => pt({
      find: /'$/,
      replace: t2 ?? "’"
    }), TA = (t2) => pt({
      find: /<-$/,
      replace: t2 ?? "←"
    }), OA = (t2) => pt({
      find: /->$/,
      replace: t2 ?? "→"
    }), NA = (t2) => pt({
      find: /\(c\)$/,
      replace: t2 ?? "©"
    }), AA = (t2) => pt({
      find: /\(tm\)$/,
      replace: t2 ?? "™"
    }), MA = (t2) => pt({
      find: /\(sm\)$/,
      replace: t2 ?? "℠"
    }), RA = (t2) => pt({
      find: /\(r\)$/,
      replace: t2 ?? "®"
    }), IA = (t2) => pt({
      find: /(?:^|\s)(1\/2)\s$/,
      replace: t2 ?? "½"
    }), DA = (t2) => pt({
      find: /\+\/-$/,
      replace: t2 ?? "±"
    }), LA = (t2) => pt({
      find: /!=$/,
      replace: t2 ?? "≠"
    }), PA = (t2) => pt({
      find: /<<$/,
      replace: t2 ?? "«"
    }), BA = (t2) => pt({
      find: />>$/,
      replace: t2 ?? "»"
    }), $A = (t2) => pt({
      find: /\d+\s?([*x])\s?\d+$/,
      replace: t2 ?? "×"
    }), zA = (t2) => pt({
      find: /\^2$/,
      replace: t2 ?? "²"
    }), FA = (t2) => pt({
      find: /\^3$/,
      replace: t2 ?? "³"
    }), HA = (t2) => pt({
      find: /(?:^|\s)(1\/4)\s$/,
      replace: t2 ?? "¼"
    }), UA = (t2) => pt({
      find: /(?:^|\s)(3\/4)\s$/,
      replace: t2 ?? "¾"
    }), VA = We.create({
      name: "typography",
      addOptions() {
        return {
          closeDoubleQuote: "”",
          closeSingleQuote: "’",
          copyright: "©",
          ellipsis: "…",
          emDash: "—",
          laquo: "«",
          leftArrow: "←",
          multiplication: "×",
          notEqual: "≠",
          oneHalf: "½",
          oneQuarter: "¼",
          openDoubleQuote: "“",
          openSingleQuote: "‘",
          plusMinus: "±",
          raquo: "»",
          registeredTrademark: "®",
          rightArrow: "→",
          servicemark: "℠",
          superscriptThree: "³",
          superscriptTwo: "²",
          threeQuarters: "¾",
          trademark: "™"
        };
      },
      addInputRules() {
        const t2 = [];
        return this.options.emDash !== false && t2.push(wA(this.options.emDash)), this.options.ellipsis !== false && t2.push(jA(this.options.ellipsis)), this.options.openDoubleQuote !== false && t2.push(EA(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== false && t2.push(SA(this.options.closeDoubleQuote)), this.options.openSingleQuote !== false && t2.push(CA(this.options.openSingleQuote)), this.options.closeSingleQuote !== false && t2.push(xA(this.options.closeSingleQuote)), this.options.leftArrow !== false && t2.push(TA(this.options.leftArrow)), this.options.rightArrow !== false && t2.push(OA(this.options.rightArrow)), this.options.copyright !== false && t2.push(NA(this.options.copyright)), this.options.trademark !== false && t2.push(AA(this.options.trademark)), this.options.servicemark !== false && t2.push(MA(this.options.servicemark)), this.options.registeredTrademark !== false && t2.push(RA(this.options.registeredTrademark)), this.options.oneHalf !== false && t2.push(IA(this.options.oneHalf)), this.options.plusMinus !== false && t2.push(DA(this.options.plusMinus)), this.options.notEqual !== false && t2.push(LA(this.options.notEqual)), this.options.laquo !== false && t2.push(PA(this.options.laquo)), this.options.raquo !== false && t2.push(BA(this.options.raquo)), this.options.multiplication !== false && t2.push($A(this.options.multiplication)), this.options.superscriptTwo !== false && t2.push(zA(this.options.superscriptTwo)), this.options.superscriptThree !== false && t2.push(FA(this.options.superscriptThree)), this.options.oneQuarter !== false && t2.push(HA(this.options.oneQuarter)), this.options.threeQuarters !== false && t2.push(UA(this.options.threeQuarters)), t2;
      }
    }), qA = jn.create({
      name: "underline",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "u"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (t2) => t2.includes("underline") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["u", Pe(this.options.HTMLAttributes, t2), 0];
      },
      addCommands() {
        return {
          setUnderline: () => ({ commands: t2 }) => t2.setMark(this.name),
          toggleUnderline: () => ({ commands: t2 }) => t2.toggleMark(this.name),
          unsetUnderline: () => ({ commands: t2 }) => t2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline()
        };
      }
    }), Vh = it.create({
      name: "tableRow",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "(tableCell | tableHeader)*",
      tableRole: "row",
      parseHTML() {
        return [
          { tag: "tr" }
        ];
      },
      renderHTML({ HTMLAttributes: t2 }) {
        return ["tr", Pe(this.options.HTMLAttributes, t2), 0];
      }
    }), KA = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: t2, tr: e } = Ae(), { onCommand: n } = Be();
        return {
          locale: t2,
          tr: e,
          onCommand: n
        };
      },
      data() {
        return {
          view: "main",
          selectedIndex: 0
        };
      },
      components: {
        ODivider: Cn,
        OIcon: fe,
        OList: Bn,
        OListItem: xn
      },
      watch: {
        items() {
          this.selectedIndex = 0;
        }
      },
      methods: {
        onClick(t2) {
          switch (t2.value) {
            default:
              this.run(t2);
              break;
          }
          return true;
        },
        run(t2) {
          const e = this.editor.chain().focus().deleteRange(this.range), n = this.editor.commands;
          switch (t2.value) {
            case "codeBlock":
              n.deleteRange(this.range), this.editor.commands.setCodeBlock({ language: "bash" });
              break;
            case "content":
              n.deleteRange(this.range), this.editor.commands.insertContent(t2.options.content);
              break;
            case "emoji":
              n.deleteRange(this.range), this.editor.commands.insertContent(":");
              break;
            case "taskList":
              n.deleteRange(this.range), this.editor.commands.toggleTaskList();
              break;
            default:
              this.onCommand(n, e, t2.value, t2.options);
              break;
          }
        },
        onKeyDown({ event: t2 }) {
          return t2.key === "ArrowUp" ? (this.upHandler(), true) : t2.key === "ArrowDown" ? (this.downHandler(), true) : t2.key === "Enter" ? (this.enterHandler(), true) : false;
        },
        upHandler() {
          this.selectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
        },
        downHandler() {
          this.selectedIndex = (this.selectedIndex + 1) % this.items.length;
        },
        enterHandler() {
          this.selectItem(this.selectedIndex);
        },
        selectItem(t2) {
          const e = this.items[t2];
          e && this.onClick(e);
        },
        setEmoji(t2) {
          this.onClick({ value: "content", options: { content: t2 } });
        }
      },
      computed: {
        basicBlocks() {
          return Ws.slice(1);
        }
      },
      mounted() {
        this.selectedIndex = 0;
      }
    }, WA = {
      key: 0,
      class: "view-main"
    }, GA = { class: "group o-tips" }, JA = { class: "o-tips" }, YA = {
      key: 1,
      class: "item"
    }, XA = {
      key: 1,
      class: "view-emoji"
    }, ZA = {
      key: 2,
      class: "view-emoji"
    };
    function QA(t2, e, n, o, i, s) {
      const r = resolveComponent("o-divider"), a = resolveComponent("o-icon"), l = resolveComponent("o-list-item"), c2 = resolveComponent("o-list");
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(["o-slash-view o-shadow-3 o-menu o-scroll", `view-${i.view}`])
      }, [
        i.view === "main" ? (openBlock(), createElementBlock("section", WA, [
          createVNode(c2, {
            hoverable: "",
            clickable: ""
          }, {
            default: withCtx(() => [
              n.items.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(n.items, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                u.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  d > 0 ? (openBlock(), createBlock(r, { key: 0 })) : createCommentVNode("", true),
                  createBaseVNode("div", GA, toDisplayString(o.tr(u.group)), 1)
                ], 64)) : createCommentVNode("", true),
                createVNode(l, {
                  class: normalizeClass(["item", { "is-active": d === i.selectedIndex }]),
                  clickable: "",
                  onClick: (p2) => s.onClick(u)
                }, {
                  prefix: withCtx(() => [
                    createVNode(a, {
                      name: u.icon,
                      color: u.color
                    }, null, 8, ["name", "color"])
                  ]),
                  suffix: withCtx(() => [
                    createBaseVNode("span", JA, toDisplayString(u.tips), 1)
                  ]),
                  default: withCtx(() => [
                    createTextVNode(" " + toDisplayString(o.tr(u.label)), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])
              ], 64))), 128)) : (openBlock(), createElementBlock("div", YA, "No result"))
            ]),
            _: 1
          })
        ])) : i.view === "emoji" ? (openBlock(), createElementBlock("section", XA)) : i.view === "ai" ? (openBlock(), createElementBlock("section", ZA)) : createCommentVNode("", true)
      ], 2);
    }
    const eM = /* @__PURE__ */ pu(KA, [["render", QA]]), dm = {
      items: ({ query: t2 }) => cu.filter(
        (e) => e.value.toLowerCase().startsWith(t2.toLowerCase())
      ),
      render: () => {
        let t2, e;
        return {
          onStart: (n) => {
            t2 = new au(eM, {
              props: n,
              editor: n.editor
            }), e = Ln("body", {
              getReferenceClientRect: n.clientRect,
              appendTo: () => document.body,
              content: t2.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false
            });
          },
          onUpdate(n) {
            t2.updateProps(n), e[0].setProps({
              getReferenceClientRect: n.clientRect
            });
          },
          onKeyDown(n) {
            var o;
            return n.event.key === "Escape" ? (e[0].hide(), t2.destroy(), true) : (o = t2.ref) == null ? void 0 : o.onKeyDown(n);
          },
          onExit() {
            e[0].destroy(), t2.destroy();
          }
        };
      }
    }, tM = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: t2, tr: e } = Ae(), { run: n } = Be();
        return {
          locale: t2,
          tr: e,
          run: n
        };
      },
      data() {
        return {
          view: "main"
        };
      },
      components: {
        OEmojiSelect: fu
      },
      methods: {
        onSelect(t2) {
          this.editor.commands.deleteRange(this.range), this.editor.commands.insertContent(t2.emoji), this.editor.chain().focus();
        },
        onKeyDown({ event: t2 }) {
          return false;
        }
      }
    }, nM = { class: "o-colon-view" };
    function oM(t2, e, n, o, i, s) {
      const r = resolveComponent("o-emoji-select");
      return openBlock(), createElementBlock("section", nM, [
        createVNode(r, {
          items: n.items,
          onSelect: s.onSelect
        }, null, 8, ["items", "onSelect"])
      ]);
    }
    const iM = /* @__PURE__ */ pu(tM, [["render", oM]]), sM = {
      items: ({ query: t2 }) => B_(t2),
      render: () => {
        let t2, e;
        return {
          onStart: (n) => {
            t2 = new au(iM, {
              props: n,
              editor: n.editor
            }), e = Ln("body", {
              getReferenceClientRect: n.clientRect,
              appendTo: () => document.body,
              content: t2.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false,
              onShow(o) {
                o.popper.classList.add("emoji-tippy");
              }
            });
          },
          onUpdate(n) {
            t2.updateProps(n), e[0].setProps({
              getReferenceClientRect: n.clientRect
            });
          },
          onKeyDown(n) {
            var o;
            return n.event.key === "Escape" ? (e[0].hide(), t2.destroy(), true) : (o = t2.ref) == null ? void 0 : o.onKeyDown(n);
          },
          onExit() {
            e[0].destroy(), t2.destroy();
          }
        };
      }
    }, rM = {
      // default
      BackColor: pA.configure({
        multicolor: true
      }),
      Focus: mA,
      ForeColor: _A,
      FontFamily: fA,
      Image: gA,
      Link: Fh,
      TextAlign: yA.configure({
        types: ["heading", "paragraph"]
      }),
      // task
      TaskItem: bA,
      TaskList: kA.configure({
        itemTypeName: "taskItem"
      }),
      Underline: qA,
      Typography: VA,
      // Custom extensions
      OColon: fx.configure({
        suggestion: sM
      }),
      OSlash: mx.configure({
        suggestion: dm
      }),
      OSlashZh: _x.configure({
        suggestion: dm
      }),
      // OTOC: TOC,
      // OModelViewer: ModelViewer,
      OBlockquote: gx,
      OCallout: jx,
      OCodeBlock: sN,
      OColorHighlighter: ZS,
      OHeading: aN,
      OHorizontalRule: uN,
      OImage: gN,
      OLink: FN.configure({
        openOnClick: false
      }),
      OParagraph: UN,
      OTrailingNode: ix,
      // OColumnExtension: ColumnExtension,
      // OColon: Colon.configure({
      //   suggestion: colonSuggestion
      // }),
      OUniqueID: ux.configure({
        attributeName: "data-id",
        enableRender: false,
        types: [
          "blockquote",
          "codeBlock",
          "callout",
          "heading",
          "image",
          "paragraph",
          "table-wrapper",
          "video"
        ]
      }),
      OVideo: sA
    };
    class aM {
      constructor(e) {
        return rM[e];
      }
    }
    const lM = [
      QN,
      nx.configure({
        resizable: true
      }),
      Vh,
      YN,
      KN
    ];
    th.configure({
      resizable: true
    });
    const cM = ["data-theme"], uM = /* @__PURE__ */ defineComponent({
      __name: "YiiEditor",
      props: {
        content: {
          type: [String, Object],
          default: ""
        },
        editable: {
          type: Boolean,
          default: true
        },
        locale: {
          type: String,
          default: "en"
        },
        darkMode: {
          type: Boolean,
          default: false
        },
        showMainMenu: {
          type: Boolean,
          default: false
        },
        showBubbleMenu: {
          type: Boolean,
          default: false
        },
        showFloatingMenu: {
          type: Boolean,
          default: false
        },
        showSideMenu: {
          type: Boolean,
          default: false
        },
        showSideNode: {
          type: Boolean,
          default: false
        },
        showContent: {
          type: Boolean,
          default: true
        },
        showGuide: {
          type: Boolean,
          default: false
        },
        scrollable: {
          type: Boolean,
          default: false
        },
        editorProps: {
          type: Object,
          default: function() {
            return {};
          }
        },
        extensions: {
          type: Array,
          default: function() {
            return [];
          }
        },
        mainMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        bubbleMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        floatingMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        pageView: {
          type: String,
          default: "page"
        },
        options: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["transaction", "update"],
      setup(t2, { expose: e, emit: n }) {
        const o = t2, i = n, { tr: s } = Ae(), r = ref(false), a = ref(true), l = ref("en"), c2 = ref(false);
        provide("darkMode", r), provide("isEditable", a), provide("locale", l), provide("sideNode", c2);
        const u = computed(() => h2()), d = Jw({
          editable: o.editable,
          content: o.content,
          extensions: u.value,
          onUpdate: () => {
            var j, v;
            const g = (j = d.value) == null ? void 0 : j.getJSON(), k = (v = d.value) == null ? void 0 : v.getHTML();
            i("update", { json: g, html: k });
          },
          onTransaction: ({ editor: g, transaction: k }) => {
            i("transaction", { editor: g, transaction: k });
          }
        }), p2 = computed(() => ({
          editor: d.value,
          menu: o.mainMenu
        })), m = computed(() => ({
          editor: d.value,
          menu: o.bubbleMenu
        })), f = computed(() => ({
          editor: d.value,
          menu: o.floatingMenu
        })), _ = computed(() => ({
          editor: d.value,
          menu: []
        }));
        function h2() {
          const g = [];
          o.extensions.includes("OColumn") || g.push(
            C_.extend({
              content: "heading block*"
            })
          ), g.push(
            QS.configure({
              placeholder: ({ editor: j, node: v, pos: C }) => {
                if (v.type.name === "heading") {
                  const E = v.attrs.level;
                  return C > 0 ? `H${E}` : s("label.untitled");
                } else return v.type.name === "paragraph" ? s("label.typeForCommands") : "";
              }
            })
          ), g.push(Kj), g.push(
            Vj.configure({
              document: false,
              blockquote: o.extensions.includes("OBlockquote") ? false : {},
              codeBlock: false,
              heading: o.extensions.includes("OHeading") ? false : {
                levels: [1, 2, 3, 4, 5]
              },
              paragraph: o.extensions.includes("OParagraph") ? false : {},
              dropcursor: {
                width: 5,
                color: "skyblue",
                class: "yiitap-dropcursor"
              },
              horizontalRule: false
            })
          );
          const k = rA.concat(o.extensions);
          for (const j of k)
            if (typeof j == "string") {
              if (!cA.includes(j))
                continue;
              switch (j) {
                case "Table":
                  g.push(...lM);
                  break;
                default:
                  try {
                    const v = new aM(j);
                    g.push(v);
                  } catch (v) {
                    console.error(v.message);
                  }
                  break;
              }
            } else
              g.push(j);
          return g;
        }
        return watch(
          () => o.darkMode,
          (g) => {
            r.value = g;
          }
        ), watch(
          () => o.locale,
          (g) => {
            l.value = g;
          }
        ), watch(
          () => o.editable,
          (g) => {
            var k;
            (k = d.value) == null || k.setEditable(g), a.value = g;
          }
        ), onBeforeMount(() => {
          r.value = o.darkMode, l.value = o.locale, c2.value = !o.showSideMenu && o.showSideNode;
        }), e({
          editor: d,
          darkModeAlt: r,
          localeAlt: l
        }), (g, k) => {
          var j, v, C;
          return openBlock(), createElementBlock("main", {
            class: "yiitap yiitap-editor",
            "data-theme": r.value ? "dark" : ""
          }, [
            t2.showMainMenu ? (openBlock(), createBlock(RS, mergeProps({ key: 0 }, p2.value, { class: "desktop-only" }), {
              left: withCtx(() => [
                renderSlot(g.$slots, "toolbar-left")
              ]),
              right: withCtx(() => [
                renderSlot(g.$slots, "toolbar-right")
              ]),
              _: 3
            }, 16)) : createCommentVNode("", true),
            (j = unref(d)) != null && j.isEditable && t2.showBubbleMenu ? (openBlock(), createBlock(LS, normalizeProps(mergeProps({ key: 1 }, m.value)), null, 16)) : createCommentVNode("", true),
            (v = unref(d)) != null && v.isEditable && t2.showFloatingMenu ? (openBlock(), createBlock($S, normalizeProps(mergeProps({ key: 2 }, f.value)), null, 16)) : createCommentVNode("", true),
            (C = unref(d)) != null && C.isEditable && t2.showSideMenu ? (openBlock(), createBlock(XS, normalizeProps(mergeProps({ key: 3 }, _.value)), null, 16)) : createCommentVNode("", true),
            createVNode(unref(Ww), {
              class: normalizeClass(["editor-content", t2.pageView]),
              editor: unref(d)
            }, null, 8, ["class", "editor"])
          ], 8, cM);
        };
      }
    });
    const BasicFeaturesArticle = `
<h1>Introduction</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em> </em></strong></span>is a WYSIWYG rich-text block-based editor built on top of <span style="font-family: &quot;Arial Black&quot;">tiptap</span>.🔥</p><h2>Callout</h2><div icon="🌾" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>Announcement</strong></p><p>Make writing stand out.</p></div><h2>Blockquote</h2><blockquote><p>A gentleman should constantly strike to become stronger just like the evolution of the universe.</p><p>A gentleman should generously cultivate to become tolerant just like the earth bears everything on it.</p></blockquote><h2>Table</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th4</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">Cell Background</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>Merged Cell</p></td></tr></tbody></table></table-wrapper><h2>Image</h2><blockquote><p>A picture is worth a thousand of words.</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="Title" size="large" ratio="5/1"></p><h2>Video</h2><video caption="Caption"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>Model View</h2><h2>List</h2><h3>Unordered List</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>Ordered List</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>Task</h3><ul data-type="taskList"><li data-checked="true" data-type="taskItem"><label><input type="checkbox" checked="checked"><span></span></label><div><p>Model Viewer</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Diagram</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Math Formula</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Draggable handler for all blocks</p></div></li></ul><h2>Code Block</h2><blockquote><p>Friendly to developer, with syntax highlight.</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Shortcut</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Remarks</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Heading</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Blockquote</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code Block</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>Typography</h2><h3>Heading 3</h3><h4>Heading 4</h4><h3>Paragraph</h3><p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p><p>Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p><p>Whether 60 or 16, there is in every human being’s heart the lure of wonder, the unfailing childlike appetite of what’s next and the joy of the game of living. In the center of your heart and my heart there is a wireless station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the Infinite, so long are you young.</p><p>When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at 20, but as long as your aerials are up, to catch waves of optimism, there is hope you may die young at 80.</p><h3>Smart</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Input</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Output</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>Copyright</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code></p></td><td colspan="1" rowspan="1" background=""><p>©</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Right</p></td><td colspan="1" rowspan="1" background=""><p><code>(r)</code></p></td><td colspan="1" rowspan="1" background=""><p>®</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>»</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>→</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Not equal</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p>≠</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Ratio</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code>&nbsp;&nbsp;<code>1/4</code>&nbsp;&nbsp;<code>3/4</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>½ ¼ ¾&nbsp;</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Dash</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p>—</p></td></tr></tbody></table></table-wrapper><h3>Color Highlighter</h3><p>#abc, #00ff00, Info color #2080f0</p><h2>Text</h2><p><span style="font-family: &quot;Arial Black&quot;"><strong>Bold text</strong></span></p><p><em>Italic text</em></p><p><u>Underline text</u></p><p><s>Strike through text</s></p><hr><p><code>Inline code</code></p><p><span style="color: rgb(255, 77, 79)">Text with color</span></p><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">Text with highlight background</mark></p><p></p>
`;
    const BasicFeaturesArticleZh = `
<h1>Yiitap</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em>&nbsp;</em></strong></span>是一个所见即所得的编辑器，基于<a target="_blank" rel="noopener noreferrer nofollow" href="https://tiptap.dev/"><span style="font-family: system-ui">Tiptap</span></a>🔥。</p><h2>高亮块</h2><div icon="🌾" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>通知</strong></p><p>着重强调的内容</p></div><h2>引用</h2><blockquote><p>天行健，君子以自强不息；<br>地势坤，君子以厚德载物。</p></blockquote><h2>表格</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th3</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">单元格背景</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>合并单元格</p></td></tr></tbody></table></table-wrapper><h2>图片</h2><blockquote><p>一图胜千言。</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="图片描述" size="large" ratio="5/1"></p><h2>视频</h2><video caption="视频描述"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>列表</h2><h3>无序列表</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>有序列表</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>任务</h3><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>表情</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>图表</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>数学公式</p></div></li></ul><h2>代码块</h2><blockquote><p>对开发人员友好，支持代码高亮。</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">名称</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">快捷</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">备注</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>标题</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>引用</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>行内代码</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>代码块</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>排版</h2><h3>标题 3</h3><h4>标题 4</h4><h3>段落</h3><p>青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的感情；青春是生命的深泉在涌流。</p><p>青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。</p><p>岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p><p>无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p><p>一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p><h3>快捷输入</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">名称</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">输入</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">输出</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>版权</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code>&nbsp; <code>(r)</code>&nbsp; <code>(tm)</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>© ® ™ </p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>箭头</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>»</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>箭头</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p>→</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>不等号</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p>≠</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>分类</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code></p></td><td colspan="1" rowspan="1" background=""><p>½</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>长横线</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p>—</p></td></tr></tbody></table></table-wrapper><h2>文本</h2><ul><li><p><span style="font-family: &quot;Arial Black&quot;"><strong>加粗文本</strong></span></p></li><li><p><em>斜体文本</em></p></li><li><p><u>下划线</u></p></li><li><p><s>删除线</s></p></li><li><p><code>行内代码</code></p></li><li><p><span style="color: rgb(255, 77, 79)">文本颜色 </span></p></li><li><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">高亮颜色</mark></p></li></ul><p></p>
`;
    const _hoisted_1$1 = ["href"];
    const _hoisted_2$1 = ["src"];
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "VersionBadge",
      props: {
        package: {}
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("a", {
            href: `https://www.npmjs.com/package/${_ctx.package}`,
            target: "_blank",
            rel: "noopener noreferrer"
          }, [
            createBaseVNode("img", {
              src: `https://img.shields.io/npm/v/${_ctx.package}.svg`,
              alt: "NPM version"
            }, null, 8, _hoisted_2$1)
          ], 8, _hoisted_1$1);
        };
      }
    });
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const VersionBadge = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-8d0105bf"]]);
    const _hoisted_1 = { class: "layout-toolbar" };
    const _hoisted_2 = { class: "info" };
    const _hoisted_3 = { class: "version" };
    const _hoisted_4 = { class: "actions" };
    const _hoisted_5 = { class: "toolbar" };
    const _hoisted_6 = { class: "layout-content" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "Demo",
      emits: ["mode"],
      setup(__props, { emit: __emit }) {
        const emit2 = __emit;
        const yiiEditor = ref();
        const locale = ref("en");
        const darkMode = ref(false);
        const editable = ref(true);
        const showDrawer = ref(false);
        provide("locale", locale);
        provide("darkMode", darkMode);
        const options = computed(() => {
          return {
            locale: locale.value,
            darkMode: darkMode.value,
            editable: editable.value,
            content: content.value,
            showMainMenu: false,
            showBubbleMenu: true,
            showFloatingMenu: true,
            showSideMenu: true,
            // showSideNode: true,
            pageView: "page",
            mainMenu: [
              "bold",
              "italic",
              "text-format-dropdown",
              "separator",
              "heading",
              "font-family",
              "text-color-dropdown",
              "fore-color",
              "back-color",
              "clearFormat",
              "separator",
              "align-dropdown",
              "separator",
              "horizontalRule",
              "blockquote",
              "list-dropdown",
              "codeBlock",
              "link",
              "image",
              "video",
              "table",
              "callout",
              "emoji"
            ],
            extensions: [
              "OBlockquote",
              "OCallout",
              "OCodeBlock",
              "OColon",
              "OColorHighlighter",
              "OHeading",
              "OImage",
              "OParagraph",
              "OSlash",
              "OSlashZh",
              "OLink",
              "OTrailingNode",
              "OVideo"
            ]
          };
        });
        const content = computed(() => {
          return locale.value === "zh" ? BasicFeaturesArticleZh : BasicFeaturesArticle;
        });
        function onToggleDrawer() {
          showDrawer.value = !showDrawer.value;
        }
        function onGithub() {
          window.open("https://github.com/yiitap/yiitap", "_blank");
        }
        function onMode() {
          emit2("mode", darkMode.value);
        }
        function onUpdate({ json, html }) {
        }
        watch(locale, (newValue) => {
          var _a2;
          (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor.commands.setContent(content.value);
        });
        onMounted(() => {
        });
        return (_ctx, _cache) => {
          var _a2, _b2;
          return openBlock(), createElementBlock("section", {
            class: normalizeClass(["page-demo", { dark: darkMode.value }])
          }, [
            createBaseVNode("section", _hoisted_1, [
              createBaseVNode("header", null, [
                createBaseVNode("section", _hoisted_2, [
                  _cache[4] || (_cache[4] = createBaseVNode("img", {
                    src: _imports_0,
                    alt: "Logo"
                  }, null, -1)),
                  _cache[5] || (_cache[5] = createBaseVNode("div", { class: "title" }, "Yiitap", -1)),
                  createBaseVNode("div", _hoisted_3, [
                    createVNode(VersionBadge, { package: "@yiitap/vue" })
                  ])
                ]),
                createBaseVNode("section", _hoisted_4, [
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onGithub
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(fe), { name: "github" })
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onToggleDrawer
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(fe), { name: "menu" })
                    ]),
                    _: 1
                  })
                ])
              ]),
              createBaseVNode("div", _hoisted_5, [
                createVNode(unref(RS), {
                  editor: (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor,
                  menu: options.value.mainMenu,
                  "data-theme": darkMode.value ? "dark" : ""
                }, null, 8, ["editor", "menu", "data-theme"])
              ])
            ]),
            createBaseVNode("section", _hoisted_6, [
              createVNode(unref(uM), mergeProps({
                ref_key: "yiiEditor",
                ref: yiiEditor
              }, options.value, { onUpdate }), null, 16)
            ]),
            createVNode(unref(NDrawer), {
              show: showDrawer.value,
              "onUpdate:show": _cache[3] || (_cache[3] = ($event) => showDrawer.value = $event),
              "default-width": 400,
              placement: "right",
              resizable: ""
            }, {
              default: withCtx(() => [
                createVNode(unref(NDrawerContent), {
                  title: "Yii Editor",
                  closable: ""
                }, {
                  default: withCtx(() => [
                    createVNode(unref(NForm), {
                      ref: "form",
                      "label-placement": "left",
                      "label-width": "auto"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), { label: "Language" }, {
                          default: withCtx(() => [
                            createVNode(unref(NRadioGroup), {
                              value: locale.value,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => locale.value = $event),
                              name: "radiogroup1"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NSpace), null, {
                                  default: withCtx(() => [
                                    createVNode(unref(NRadio), { value: "en" }, {
                                      default: withCtx(() => _cache[6] || (_cache[6] = [
                                        createTextVNode(" English ")
                                      ])),
                                      _: 1
                                    }),
                                    createVNode(unref(NRadio), { value: "zh" }, {
                                      default: withCtx(() => _cache[7] || (_cache[7] = [
                                        createTextVNode(" 中文 ")
                                      ])),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Mode" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: darkMode.value,
                              "onUpdate:value": [
                                _cache[1] || (_cache[1] = ($event) => darkMode.value = $event),
                                onMode
                              ]
                            }, {
                              checked: withCtx(() => _cache[8] || (_cache[8] = [
                                createTextVNode(" Dark ")
                              ])),
                              unchecked: withCtx(() => _cache[9] || (_cache[9] = [
                                createTextVNode(" Light ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Edit" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: editable.value,
                              "onUpdate:value": _cache[2] || (_cache[2] = ($event) => editable.value = $event)
                            }, {
                              checked: withCtx(() => _cache[10] || (_cache[10] = [
                                createTextVNode(" Editable ")
                              ])),
                              unchecked: withCtx(() => _cache[11] || (_cache[11] = [
                                createTextVNode(" Readonly ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["show"]),
            createVNode(unref(_M), {
              editor: (_b2 = yiiEditor.value) == null ? void 0 : _b2.editor,
              "max-level": 3
            }, null, 8, ["editor"])
          ], 2);
        };
      }
    });
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const darkMode = ref(false);
        const theme = computed(() => {
          return darkMode.value ? darkTheme : null;
        });
        function onMode(value) {
          darkMode.value = value;
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(NConfigProvider), { theme: theme.value }, {
            default: withCtx(() => [
              createVNode(_sfc_main$1, { onMode })
            ]),
            _: 1
          }, 8, ["theme"]);
        };
      }
    });
    const app = createApp(_sfc_main);
    app.mount("#app");
  }
});
export default require_index_001();
//# sourceMappingURL=index-Bx7LkBoo.js.map
