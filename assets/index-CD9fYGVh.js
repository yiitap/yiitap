var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-CD9fYGVh.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO$1 = () => false;
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el2) => {
      const i = arr.indexOf(el2);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$9 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$9.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
          const dep = deps[i];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    let activeEffect;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect {
      constructor(fn2, scheduler2 = null, scope) {
        this.fn = fn2;
        this.scheduler = scheduler2;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].delete(effect2);
        }
        deps.length = 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$1(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$1(dep) ? dep : [...dep];
      for (const effect2 of effects) {
        if (effect2.computed) {
          triggerEffect(effect2);
        }
      }
      for (const effect2 of effects) {
        if (!effect2.computed) {
          triggerEffect(effect2);
        }
      }
    }
    function triggerEffect(effect2, debuggerEventExtraInfo) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
    function getDepFromReactive(object, key) {
      var _a2;
      return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$8(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$8;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!this._shallow) {
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger$1(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size$1(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger$1(target, "add", value, value);
      }
      return this;
    }
    function set(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger$1(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger$1(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1(this, key);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1(this, key, false, true);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        {
          triggerEffects(dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$1(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function warn$3(msg2, ...args) {
      return;
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      let res;
      try {
        res = args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$1(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn2.length; i++) {
        values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb2) {
      if (!isArray$1(cb2)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb2,
          cb2.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb2);
        }
      } else {
        pendingPostFlushCbs.push(...cb2);
      }
      queueFlush();
    }
    function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb2 = queue[i];
        if (cb2 && cb2.pre) {
          queue.splice(i, 1);
          i--;
          cb2();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false) ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn2, ctx2 = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx2)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx2);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        data,
        setupState,
        ctx: ctx2,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          result = normalizeVNode(
            render2.call(
              proxyToUse,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx2
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false) ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el2) {
      while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el2;
        parent = parent.parent;
      }
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        {
          const selfName = getComponentName(
            Component,
            false
            /* do not include inferred name to avoid breaking existing code */
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb2, options) {
      return doWatch(source, cb2, options);
    }
    function doWatch(source, cb2, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      var _a2;
      const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction$1(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else ;
        });
      } else if (isFunction$1(source)) {
        if (cb2) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb2 && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb2) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb2, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx2 = useSSRContext();
          ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active) {
          return;
        }
        if (cb2) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb2, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb2;
      let scheduler2;
      if (flush === "sync") {
        scheduler2 = job;
      } else if (flush === "post") {
        scheduler2 = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler2 = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, scheduler2);
      if (cb2) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      const unwatch = () => {
        effect2.stop();
        if (instance && instance.scope) {
          remove(instance.scope.effects, effect2);
        }
      };
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb2;
      if (isFunction$1(value)) {
        cb2 = value;
      } else {
        cb2 = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb2.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx2, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx2;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, seen) {
      if (!isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c2 of children) {
              if (c2.type !== Comment) {
                child = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el2[leaveCbKey] = () => {
                  earlyRemove();
                  el2[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el2) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el2[leaveCbKey]) {
            el2[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el2]);
        },
        enter(el2) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el2[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el2]);
            } else {
              callHook2(afterHook, [el2]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el2[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el2, done]);
          } else {
            done();
          }
        },
        leave(el2, remove2) {
          const key2 = String(vnode.key);
          if (el2[enterCbKey$1]) {
            el2[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el2]);
          let called = false;
          const done = el2[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el2]);
            } else {
              callHook2(onAfterLeave, [el2]);
            }
            el2[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el2, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          unsetCurrentInstance();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache2, index) {
      let ret;
      const cached = cache2;
      if (isArray$1(source) || isString(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached)
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            ret[i] = renderItem(source[key], key, i, cached);
          }
        }
      } else {
        ret = [];
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback);
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || [],
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx: ctx2, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx2[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
            accessCache[key] = 4;
            return ctx2[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx: ctx2 } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx2[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx2 = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx2[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data)) ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx2, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
              /* treat default function as factory */
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx2[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx2, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx2[raw];
        if (isFunction$1(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$1(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from[key]) : from[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from) {
      if (!from) {
        return to2;
      }
      if (!to2) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to2) ? to2.call(this, this) : to2,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to2, from) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from) {
      return to2 ? [...new Set([].concat(to2, from))] : from;
    }
    function mergeObjectOptions(to2, from) {
      return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
    }
    function mergeEmitsOrPropsOptions(to2, from) {
      if (to2) {
        if (isArray$1(to2) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to2, from) {
      if (!to2)
        return from;
      if (!from)
        return to2;
      const merged = extend(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from) {
        merged[key] = mergeAsArray(to2[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO$1,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted2 = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin2, ...options) {
            if (installedPlugins.has(plugin2)) ;
            else if (plugin2 && isFunction$1(plugin2.install)) {
              installedPlugins.add(plugin2);
              plugin2.install(app2, ...options);
            } else if (isFunction$1(plugin2)) {
              installedPlugins.add(plugin2);
              plugin2(app2, ...options);
            } else ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, isSVG2) {
            if (!isMounted2) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              {
                render2(vnode, rootContainer, isSVG2);
              }
              isMounted2 = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted2) {
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn2) {
            currentApp = app2;
            try {
              return fn2();
            } finally {
              currentApp = null;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                  /* isAbsent */
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                  /* isAbsent */
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              unsetCurrentInstance();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys)
            needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$1(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$1(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx2) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false) ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx2);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx2 = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx2);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG2 = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n12 === n2) {
          return;
        }
        if (n12 && !isSameVNodeType(n12, n2)) {
          anchor = getNextHostNode(n12);
          unmount2(n12, parentComponent, parentSuspense, true);
          n12 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n12, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n12, n2, container, anchor);
            break;
          case Static:
            if (n12 == null) {
              mountStaticNode(n2, container, anchor, isSVG2);
            }
            break;
          case Fragment:
            processFragment(
              n12,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized,
                internals
              );
            } else ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
        }
      };
      const processText = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el2 = n2.el = n12.el;
          if (n2.children !== n12.children) {
            hostSetText(el2, n2.children);
          }
        }
      };
      const processCommentNode = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n12.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          isSVG2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostInsert(el2, container, nextSibling);
          el2 = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el: el2, anchor }) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostRemove(el2);
          el2 = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        isSVG2 = isSVG2 || n2.type === "svg";
        if (n12 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n12,
            n2,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
          vnode.type,
          isSVG2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el2,
            null,
            parentComponent,
            parentSuspense,
            isSVG2 && type !== "foreignObject",
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el2,
                key,
                null,
                props[key],
                isSVG2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el2, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el2);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el2, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el2,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n12, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const el2 = n2.el = n12.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n12.patchFlag & 16;
        const oldProps = n12.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG2 && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(
            n12.dynamicChildren,
            dynamicChildren,
            el2,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n12,
            n2,
            el2,
            null,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el2,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG2
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el2, "class", null, newProps.class, isSVG2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el2,
                    key,
                    prev,
                    next,
                    isSVG2,
                    n12.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n12.children !== n2.children) {
              hostSetElementText(el2, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el2,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            isSVG2
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
            dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el2,
                  key,
                  oldProps[key],
                  null,
                  isSVG2,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el2,
                key,
                prev,
                next,
                isSVG2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el2, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n12 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            n2.children,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n12.dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n12,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n12,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n12 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              isSVG2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              optimized
            );
          }
        } else {
          updateComponent(n12, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          isSVG2,
          optimized
        );
      };
      const updateComponent = (n12, n2, optimized) => {
        const instance = n2.component = n12.component;
        if (shouldUpdateComponent(n12, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n12.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el: el2, props } = initialVNode;
            const { bm: bm2, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm2) {
              invokeArrayFns(bm2);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                isSVG2
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu: bu2, u, parent, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu2) {
              invokeArrayFns(bu2);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              isSVG2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => effect2.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs();
        resetTracking();
      };
      const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized = false) => {
        const c12 = n12 && n12.children;
        const prevShapeFlag = n12 ? n12.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c12, parentComponent, parentSuspense);
          }
          if (c2 !== c12) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c12,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c12, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c12, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        c12 = c12 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c12.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c12[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c12,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c12, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e12 = c12.length - 1;
        let e2 = l2 - 1;
        while (i <= e12 && i <= e2) {
          const n12 = c12[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e12 && i <= e2) {
          const n12 = c12[e12];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e12--;
          e2--;
        }
        if (i > e12) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e12) {
            unmount2(c12[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s12 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s12; i <= e12; i++) {
            const prevChild = c12[i];
            if (patched >= toBePatched) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el2, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el2);
            hostInsert(el2, container, anchor);
            queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el2, container, anchor);
            const performLeave = () => {
              leave(el2, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el2, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el2, container, anchor);
        }
      };
      const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el: el2, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el2, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el2);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el2, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um: um2 } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount2(subTree, instance, parentSuspense, doRemove);
        }
        if (um2) {
          queuePostRenderEffect(um2, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount2(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render2 = (vnode, container, isSVG2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount2(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG2);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount2,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2)
      };
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n12, n2, shallow = false) {
      const ch1 = n12.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c12 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c12.el;
            }
            if (!shallow)
              traverseStaticChildren(c12, c2);
          }
          if (c2.type === Text) {
            c2.el = c12.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c2;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c2 = u + v >> 1;
            if (arr[result[c2]] < arrI) {
              u = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      __isTeleport: true,
      process(n12, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n12 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG2 = isSVG2 || isTargetSVG(target);
          }
          const mount2 = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount2(container, mainAnchor);
          } else if (target) {
            mount2(target, targetAnchor);
          }
        } else {
          n2.el = n12.el;
          const mainAnchor = n2.anchor = n12.anchor;
          const target = n2.target = n12.target;
          const targetAnchor = n2.targetAnchor = n12.targetAnchor;
          const wasDisabled = isTeleportDisabled(n12.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG2 = isSVG2 || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds
            );
            traverseStaticChildren(n12, n2, true);
          } else if (!optimized) {
            patchChildren(
              n12,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n12.props && n2.props.to !== n12.props.to) {
                n2.props.to = n12.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount2(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el: el2, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el2, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx2 = vnode.ctx;
      if (ctx2 && ctx2.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx2.uid);
          node = node.nextSibling;
        }
        ctx2.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
          /* isBlock */
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
          /* isBlock: prevent a block from tracking itself */
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n12, n2) {
      return n12.type === n2.type && n12.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style2)) {
          if (isProxy(style2) && !isArray$1(style2)) {
            style2 = extend({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let globalCurrentInstanceSetters;
    let settersKey = "__VUE_INSTANCE_SETTERS__";
    {
      if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
        globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
      }
      globalCurrentInstanceSetters.push((i) => currentInstance = i);
      internalSetCurrentInstance = (instance) => {
        if (globalCurrentInstanceSetters.length > 1) {
          globalCurrentInstanceSetters.forEach((s) => s(instance));
        } else {
          globalCurrentInstanceSetters[0](instance);
        }
      };
    }
    const setCurrentInstance = (instance) => {
      internalSetCurrentInstance(instance);
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup: setup2 } = Component;
      if (setup2) {
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [instance.props, setupContext]
        );
        resetTracking();
        unsetCurrentInstance();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult);
        }
      } else {
        finishComponentSetup(instance);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else ;
      finishComponentSetup(instance);
    }
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        instance.render = Component.render || NOOP;
      }
      {
        setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          unsetCurrentInstance();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const ssrContextKey$1 = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx2 = inject(ssrContextKey$1);
        return ctx2;
      }
    };
    const version = "3.3.8";
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG2, is2, props) => {
        const el2 = isSVG2 ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el2.setAttribute("multiple", props.multiple);
        }
        return el2;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el2, text) => {
        el2.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el2, id) {
        el2.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG2, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG2 ? `<svg>${content}</svg>` : content;
          const template = templateContainer.content;
          if (isSVG2) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el2, isAppear, done) => {
        removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el2, done) => {
        el2._isLeaving = false;
        removeTransitionClass(el2, leaveFromClass);
        removeTransitionClass(el2, leaveToClass);
        removeTransitionClass(el2, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el2, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el2, isAppear, done);
          callHook(hook, [el2, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el2, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el2) {
          callHook(onBeforeEnter, [el2]);
          addTransitionClass(el2, enterFromClass);
          addTransitionClass(el2, enterActiveClass);
        },
        onBeforeAppear(el2) {
          callHook(onBeforeAppear, [el2]);
          addTransitionClass(el2, appearFromClass);
          addTransitionClass(el2, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el2, done) {
          el2._isLeaving = true;
          const resolve2 = () => finishLeave(el2, done);
          addTransitionClass(el2, leaveFromClass);
          forceReflow();
          addTransitionClass(el2, leaveActiveClass);
          nextFrame(() => {
            if (!el2._isLeaving) {
              return;
            }
            removeTransitionClass(el2, leaveFromClass);
            addTransitionClass(el2, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el2, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el2, resolve2]);
        },
        onEnterCancelled(el2) {
          finishEnter(el2, false);
          callHook(onEnterCancelled, [el2]);
        },
        onAppearCancelled(el2) {
          finishEnter(el2, true);
          callHook(onAppearCancelled, [el2]);
        },
        onLeaveCancelled(el2) {
          finishLeave(el2);
          callHook(onLeaveCancelled, [el2]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$1(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.add(c2));
      (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.remove(c2));
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el2[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb2) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb2);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
      const id = el2._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el2._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el2.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el2 && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el2.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el2, expectedType) {
      const styles = window.getComputedStyle(el2);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el2, value, isSVG2) {
      const transitionClasses = el2[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el2.removeAttribute("class");
      } else if (isSVG2) {
        el2.setAttribute("class", value);
      } else {
        el2.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el2, { value }, { transition }) {
        el2[vShowOldKey] = el2.style.display === "none" ? "" : el2.style.display;
        if (transition && value) {
          transition.beforeEnter(el2);
        } else {
          setDisplay(el2, value);
        }
      },
      mounted(el2, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el2);
        }
      },
      updated(el2, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el2);
            setDisplay(el2, true);
            transition.enter(el2);
          } else {
            transition.leave(el2, () => {
              setDisplay(el2, false);
            });
          }
        } else {
          setDisplay(el2, value);
        }
      },
      beforeUnmount(el2, { value }) {
        setDisplay(el2, value);
      }
    };
    function setDisplay(el2, value) {
      el2.style.display = value ? el2[vShowOldKey] : "none";
    }
    function patchStyle(el2, prev, next) {
      const style2 = el2.style;
      const isCssString = isString(next);
      if (next && !isCssString) {
        if (prev && !isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style2, key, next[key]);
        }
      } else {
        const currentDisplay = style2.display;
        if (isCssString) {
          if (prev !== next) {
            style2.cssText = next;
          }
        } else if (prev) {
          el2.removeAttribute("style");
        }
        if (vShowOldKey in el2) {
          style2.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el2, key, value, isSVG2, instance) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el2.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el2.removeAttribute(key);
        } else {
          el2.setAttribute(key, isBoolean ? "" : value);
        }
      }
    }
    function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el2[key] = value == null ? "" : value;
        return;
      }
      const tag = el2.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el2._value = value;
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el2.value = newValue;
        }
        if (value == null) {
          el2.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el2[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el2[key] = value;
      } catch (e) {
      }
      needRemove && el2.removeAttribute(key);
    }
    function addEventListener(el2, event, handler, options) {
      el2.addEventListener(event, handler, options);
    }
    function removeEventListener(el2, event, handler, options) {
      el2.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
      const invokers = el2[veiKey] || (el2[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el2, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
      } else {
        return value;
      }
    }
    const nativeOnRE = /^on[a-z]/;
    const patchProp = (el2, key, prevValue, nextValue, isSVG2 = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el2, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG2)) {
        patchDOMProp(
          el2,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el2._trueValue = nextValue;
        } else if (key === "false-value") {
          el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el2, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el2 && nativeOnRE.test(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el2.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
      }
      if (nativeOnRE.test(key) && isString(value)) {
        return false;
      }
      return key in el2;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el2 = c2.el;
            const style2 = el2.style;
            addTransitionClass(el2, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb2 = el2[moveCbKey] = (e) => {
              if (e && e.target !== el2) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el2.removeEventListener("transitionend", cb2);
                el2[moveCbKey] = null;
                removeTransitionClass(el2, moveClass);
              }
            };
            el2.addEventListener("transitionend", cb2);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el2 = c2.el;
      if (el2[moveCbKey]) {
        el2[moveCbKey]();
      }
      if (el2[enterCbKey]) {
        el2[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx2 = oldPos.left - newPos.left;
      const dy2 = oldPos.top - newPos.top;
      if (dx2 || dy2) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx2}px,${dy2}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el2, root2, moveClass) {
      const clone = el2.cloneNode();
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el2, { modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el2, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el2.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el2[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el2, "change", () => {
            el2.value = el2.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el2, "compositionstart", onCompositionStart);
          addEventListener(el2, "compositionend", onCompositionEnd);
          addEventListener(el2, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el2, { value }) {
        el2.value = value == null ? "" : value;
      },
      beforeUpdate(el2, { value, modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        if (el2.composing)
          return;
        if (document.activeElement === el2 && el2.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim && el2.value.trim() === value) {
            return;
          }
          if ((number || el2.type === "number") && looseToNumber(el2.value) === value) {
            return;
          }
        }
        const newValue = value == null ? "" : value;
        if (el2.value !== newValue) {
          el2.value = newValue;
        }
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el2, _, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        addEventListener(el2, "change", () => {
          const modelValue = el2._modelValue;
          const elementValue = getValue$2(el2);
          const checked = el2.checked;
          const assign = el2[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el2, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el2, binding, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        setChecked(el2, binding, vnode);
      }
    };
    function setChecked(el2, { value, oldValue }, vnode) {
      el2._modelValue = value;
      if (isArray$1(value)) {
        el2.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        el2.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el2.checked = looseEqual(value, getCheckboxValue(el2, true));
      }
    }
    function getValue$2(el2) {
      return "_value" in el2 ? el2._value : el2.value;
    }
    function getCheckboxValue(el2, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el2 ? el2[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn2, modifiers) => {
      return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      };
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render$1 = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount: mount2 } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount2(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }
    function depx(value) {
      if (typeof value === "string") {
        if (value.endsWith("px")) {
          return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
      }
      return value;
    }
    function pxfy(value) {
      if (value === void 0 || value === null)
        return void 0;
      if (typeof value === "number")
        return `${value}px`;
      if (value.endsWith("px"))
        return value;
      return `${value}px`;
    }
    function getGap(value, orient) {
      const [rowGap, colGap] = value.split(" ");
      return {
        row: rowGap,
        col: colGap || rowGap
      };
    }
    const colors = {
      black: "#000",
      silver: "#C0C0C0",
      gray: "#808080",
      white: "#FFF",
      maroon: "#800000",
      red: "#F00",
      purple: "#800080",
      fuchsia: "#F0F",
      green: "#008000",
      lime: "#0F0",
      olive: "#808000",
      yellow: "#FF0",
      navy: "#000080",
      blue: "#00F",
      teal: "#008080",
      aqua: "#0FF",
      transparent: "#0000"
    };
    const prefix$1 = "^\\s*";
    const suffix = "\\s*$";
    const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    const hex = "([0-9A-Fa-f])";
    const dhex = "([0-9A-Fa-f]{2})";
    const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
    function parseHex(value) {
      return parseInt(value, 16);
    }
    function rgba(color) {
      try {
        let i;
        if (i = hexRegex.exec(color)) {
          return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
        } else if (i = rgbRegex.exec(color)) {
          return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
        } else if (i = rgbaRegex.exec(color)) {
          return [
            roundChannel(i[1]),
            roundChannel(i[5]),
            roundChannel(i[9]),
            roundAlpha(i[13])
          ];
        } else if (i = sHexRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            1
          ];
        } else if (i = hexaRegex.exec(color)) {
          return [
            parseHex(i[1]),
            parseHex(i[2]),
            parseHex(i[3]),
            roundAlpha(parseHex(i[4]) / 255)
          ];
        } else if (i = sHexaRegex.exec(color)) {
          return [
            parseHex(i[1] + i[1]),
            parseHex(i[2] + i[2]),
            parseHex(i[3] + i[3]),
            roundAlpha(parseHex(i[4] + i[4]) / 255)
          ];
        } else if (color in colors) {
          return rgba(colors[color]);
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function normalizeAlpha(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }
    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
    }
    function compositeChannel(v12, a12, v2, a2, a) {
      return roundChannel((v12 * a12 * (1 - a2) + v2 * a2) / a);
    }
    function composite(background, overlay2) {
      if (!Array.isArray(background))
        background = rgba(background);
      if (!Array.isArray(overlay2))
        overlay2 = rgba(overlay2);
      const a12 = background[3];
      const a2 = overlay2[3];
      const alpha = roundAlpha(a12 + a2 - a12 * a2);
      return stringifyRgba(compositeChannel(background[0], a12, overlay2[0], a2, alpha), compositeChannel(background[1], a12, overlay2[1], a2, alpha), compositeChannel(background[2], a12, overlay2[2], a2, alpha), alpha);
    }
    function changeColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      if (options.alpha) {
        return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
        return 1;
      if (v < 0)
        return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
        return 255;
      if (v < 0)
        return 0;
      return v;
    }
    function toRgbaString(base2) {
      const [r, g, b] = base2;
      if (3 in base2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function createId(length = 8) {
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function getSlot$1(instance, slotName = "default", fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0)
        return fallback;
      return slot();
    }
    function flatten(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null)
          return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment) {
          if (vNode.children === null)
            return;
          if (Array.isArray(vNode.children)) {
            flatten(vNode.children, filterCommentNode, result);
          }
        } else if (vNode.type !== Comment) {
          result.push(vNode);
        }
      });
      return result;
    }
    function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
      } else
        return funcs(...args);
    }
    function keysOf(obj) {
      return Object.keys(obj);
    }
    function warn$2(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }
    function createInjectionKey(key) {
      return key;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) {
          return true;
        }
        if (child.type === Comment) {
          return false;
        }
        if (child.type === Fragment && !ensureValidVNode(child.children)) {
          return false;
        }
        return true;
      }) ? vnodes : null;
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      render() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    });
    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length, { c: c2 = 1, offset = 0, attachPx = true } = {}) {
      if (typeof length === "number") {
        const result = (length + offset) * c2;
        if (result === 0)
          return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c2;
          if (attachPx) {
            if (result === 0)
              return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result)
            return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
        }
      }
      return length;
    }
    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s/g, "_");
    }
    function ampCount(selector) {
      let cnt = 0;
      for (let i = 0; i < selector.length; ++i) {
        if (selector[i] === "&")
          ++cnt;
      }
      return cnt;
    }
    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        let round = ampCount(partialSelector);
        if (!round) {
          amp.forEach((partialAmp) => {
            nextAmp.push(
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              (partialAmp && partialAmp + " ") + partialSelector
            );
          });
          return;
        } else if (round === 1) {
          amp.forEach((partialAmp) => {
            nextAmp.push(partialSelector.replace("&", partialAmp));
          });
          return;
        }
        let partialNextAmp = [
          partialSelector
        ];
        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach((selectorItr) => {
            amp.forEach((partialAmp) => {
              nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach((part) => nextAmp.push(part));
      });
      return nextAmp;
    }
    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        amp.forEach((partialAmp) => {
          nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
        });
      });
      return nextAmp;
    }
    function parseSelectorPath(selectorPaths) {
      let amp = [""];
      selectorPaths.forEach((selector) => {
        selector = selector && selector.trim();
        if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector
        ) {
          return;
        }
        if (selector.includes("&")) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(", ").replace(extraSpaceRegex, " ");
    }
    function removeElement(el2) {
      if (!el2)
        return;
      const parentElement = el2.parentElement;
      if (parentElement)
        parentElement.removeChild(el2);
    }
    function queryElement(id) {
      return document.querySelector(`style[cssr-id="${id}"]`);
    }
    function createElement(id) {
      const el2 = document.createElement("style");
      el2.setAttribute("cssr-id", id);
      return el2;
    }
    function isMediaOrSupports(selector) {
      if (!selector)
        return false;
      return /^\s*@(s|m)/.test(selector);
    }
    const kebabRegex = /[A-Z]/g;
    function kebabCase(pattern) {
      return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
    }
    function unwrapProperty(prop, indent = "  ") {
      if (typeof prop === "object" && prop !== null) {
        return " {\n" + Object.entries(prop).map((v) => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join("\n") + "\n" + indent + "}";
      }
      return `: ${prop};`;
    }
    function unwrapProperties(props, instance, params) {
      if (typeof props === "function") {
        return props({
          context: instance.context,
          props: params
        });
      }
      return props;
    }
    function createStyle(selector, props, instance, params) {
      if (!props)
        return "";
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
        return "";
      if (typeof unwrappedProps === "string") {
        return `${selector} {
${unwrappedProps}
}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
          return selector + " {\n}";
        return "";
      }
      const statements = selector ? [
        selector + " {"
      ] : [];
      propertyNames.forEach((propertyName) => {
        const property = unwrappedProps[propertyName];
        if (propertyName === "raw") {
          statements.push("\n" + property + "\n");
          return;
        }
        propertyName = kebabCase(propertyName);
        if (property !== null && property !== void 0) {
          statements.push(`  ${propertyName}${unwrapProperty(property)}`);
        }
      });
      if (selector) {
        statements.push("}");
      }
      return statements.join("\n");
    }
    function loopCNodeListWithCallback(children, options, callback) {
      if (!children)
        return;
      children.forEach((child) => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === "function") {
          const grandChildren = child(options);
          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }
    function traverseCNode(node, selectorPaths, styles, instance, params, styleSheet) {
      const $ = node.$;
      let blockSelector = "";
      if (!$ || typeof $ === "string") {
        if (isMediaOrSupports($)) {
          blockSelector = $;
        } else {
          selectorPaths.push($);
        }
      } else if (typeof $ === "function") {
        const selector2 = $({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      } else {
        if ($.before)
          $.before(instance.context);
        if (!$.$ || typeof $.$ === "string") {
          if (isMediaOrSupports($.$)) {
            blockSelector = $.$;
          } else {
            selectorPaths.push($.$);
          }
        } else if ($.$) {
          const selector2 = $.$({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style2 = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
        styles.push(`${blockSelector} {`);
        if (styleSheet && style2) {
          styleSheet.insertRule(`${blockSelector} {
${style2}
}
`);
        }
      } else {
        if (styleSheet && style2) {
          styleSheet.insertRule(style2);
        }
        if (!styleSheet && style2.length)
          styles.push(style2);
      }
      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, (childNode) => {
          if (typeof childNode === "string") {
            const style3 = createStyle(selector, { raw: childNode }, instance, params);
            if (styleSheet) {
              styleSheet.insertRule(style3);
            } else {
              styles.push(style3);
            }
          } else {
            traverseCNode(childNode, selectorPaths, styles, instance, params, styleSheet);
          }
        });
      }
      selectorPaths.pop();
      if (blockSelector) {
        styles.push("}");
      }
      if ($ && $.after)
        $.after(instance.context);
    }
    function render(node, instance, props, insertRule = false) {
      const styles = [];
      traverseCNode(node, [], styles, instance, props, insertRule ? node.instance.__styleSheet : void 0);
      if (insertRule)
        return "";
      return styles.join("\n\n");
    }
    function murmur2(str) {
      var h2 = 0;
      var k, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= /* k >>> r: */
        k >>> 24;
        h2 = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
    function unmount(intance, node, id) {
      const { els } = node;
      if (id === void 0) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id);
        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter((el2) => el2 !== target);
        }
      }
    }
    function addElementToList(els, target) {
      els.push(target);
    }
    function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter2) {
      if (silent && !ssrAdapter2) {
        if (id === void 0) {
          console.error("[css-render/mount]: `id` is required in `silent` mode.");
          return;
        }
        const cssrContext = window.__cssrContext;
        if (!cssrContext[id]) {
          cssrContext[id] = true;
          render(node, instance, props, silent);
        }
        return;
      }
      let style2;
      if (id === void 0) {
        style2 = node.render(props);
        id = murmur2(style2);
      }
      if (ssrAdapter2) {
        ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
        return;
      }
      const queriedTarget = queryElement(id);
      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
      if (style2 === void 0)
        style2 = node.render(props);
      target.textContent = style2;
      if (queriedTarget !== null)
        return queriedTarget;
      if (anchorMetaName) {
        const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
        if (anchorMetaEl) {
          document.head.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }
      if (head) {
        document.head.insertBefore(target, document.head.querySelector("style, link"));
      } else {
        document.head.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
    }
    function wrappedRender(props) {
      return render(this, this.instance, props);
    }
    function wrappedMount(options = {}) {
      const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
      const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
      return targetElement;
    }
    function wrappedUnmount(options = {}) {
      const { id } = options;
      unmount(this.instance, this, id);
    }
    const createCNode = function(instance, $, props, children) {
      return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    const c$1 = function(instance, $, props, children) {
      if (Array.isArray($)) {
        return createCNode(instance, { $: null }, null, $);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
      } else {
        return createCNode(instance, $, props, null);
      }
    };
    function CssRender(config = {}) {
      let styleSheet = null;
      const cssr2 = {
        c: (...args) => c$1(cssr2, ...args),
        use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
        find: queryElement,
        context: {},
        config,
        get __styleSheet() {
          if (!styleSheet) {
            const style2 = document.createElement("style");
            document.head.appendChild(style2);
            styleSheet = document.styleSheets[document.styleSheets.length - 1];
            return styleSheet;
          }
          return styleSheet;
        }
      };
      return cssr2;
    }
    function exists(id, ssr) {
      if (id === void 0)
        return false;
      if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id);
      }
      return queryElement(id) !== null;
    }
    function plugin$1(options) {
      let _bPrefix = ".";
      let _ePrefix = "__";
      let _mPrefix = "--";
      let c2;
      if (options) {
        let t = options.blockPrefix;
        if (t) {
          _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
          _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
          _mPrefix = t;
        }
      }
      const _plugin = {
        install(instance) {
          c2 = instance.c;
          const ctx2 = instance.context;
          ctx2.bem = {};
          ctx2.bem.b = null;
          ctx2.bem.els = null;
        }
      };
      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx2) {
            memorizedB = ctx2.bem.b;
            memorizedE = ctx2.bem.els;
            ctx2.bem.els = null;
          },
          after(ctx2) {
            ctx2.bem.b = memorizedB;
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }
        };
      }
      function e(arg) {
        let memorizedE;
        return {
          before(ctx2) {
            memorizedE = ctx2.bem.els;
          },
          after(ctx2) {
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.els = arg.split(",").map((v) => v.trim());
            return context.bem.els.map((el2) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el2}`).join(", ");
          }
        };
      }
      function m(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const modifiers = arg.split(",").map((v) => v.trim());
            function elementToSelector(el2) {
              return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el2 !== void 0 ? `${_ePrefix}${el2}` : ""}${_mPrefix}${modifier}`).join(", ");
            }
            const els = context.bem.els;
            if (els !== null) {
              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }
        };
      }
      function notM(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const els = context.bem.els;
            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
          }
        };
      }
      const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
      const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
      const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
      const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
      Object.assign(_plugin, {
        cB: cB2,
        cE: cE2,
        cM: cM2,
        cNotM: cNotM2
      });
      return _plugin;
    }
    function createKey(prefix2, suffix2) {
      return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
    }
    createKey("abc", "def");
    const namespace = "n";
    const prefix = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const { c, find } = cssr;
    const { cB, cE: cE$1, cM: cM$1, cNotM } = plugin;
    const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
    const eventSet = /* @__PURE__ */ new WeakSet();
    function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
    }
    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a2;
      const injection = inject(injectionName, null);
      if (injection === null)
        return;
      const vm2 = (_a2 = getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
        const collection = injection[collectionKey];
        if (oldKey !== void 0)
          removeInstance(collection, oldKey);
        if (key !== void 0)
          addInstance(collection, key);
      }
      function removeInstance(collection, key) {
        if (!collection[key])
          collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm2), 1);
      }
      function addInstance(collection, key) {
        if (!collection[key])
          collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm2)) {
          collection[key].push(vm2);
        }
      }
    }
    function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
        return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return readonly(currentRef);
    }
    function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
        valueRef.value = value;
      });
      if (typeof getterOrOptions === "function") {
        return valueRef;
      } else {
        return {
          __v_isRef: true,
          get value() {
            return valueRef.value;
          },
          set value(v) {
            getterOrOptions.set(v);
          }
        };
      }
    }
    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }
    const traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
    function createTrapHandler(name, el2, originalHandler) {
      if (name === "mousemoveoutside") {
        const moveHandler = (e) => {
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === "clickoutside") {
        let mouseDownOutside = false;
        const downHandler = (e) => {
          mouseDownOutside = !el2.contains(getEventTarget(e));
        };
        const upHanlder = (e) => {
          if (!mouseDownOutside)
            return;
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }
      console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
      );
      return {};
    }
    function ensureTrapHandlers(name, el2, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el2);
      if (elHandlers === void 0) {
        handlers.set(el2, elHandlers = /* @__PURE__ */ new WeakMap());
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === void 0) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el2, handler));
      }
      return trapHandler;
    }
    function trapOn(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          on$1(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function trapOff(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function createDelegate() {
      if (typeof window === "undefined") {
        return {
          on: () => {
          },
          off: () => {
          }
        };
      }
      const propagationStopped = /* @__PURE__ */ new WeakMap();
      const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
      function trackPropagation() {
        propagationStopped.set(this, true);
      }
      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn2) {
        const source = event[propName];
        event[propName] = function() {
          fn2.apply(event, arguments);
          return source.apply(event, arguments);
        };
        return event;
      }
      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }
      const currentTargets = /* @__PURE__ */ new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
      function getCurrentTarget() {
        var _a2;
        return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === void 0)
          return;
        Object.defineProperty(event, "currentTarget", {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }
      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
        const delegeteHandler = function(e) {
          const { type, eventPhase, bubbles } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2)
            return;
          const phase = eventPhase === 1 ? "capture" : "bubble";
          let cursor = target;
          const path = [];
          while (true) {
            if (cursor === null)
              cursor = window;
            path.push(cursor);
            if (cursor === window) {
              break;
            }
            cursor = cursor.parentNode || null;
          }
          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
          spy(e, "stopPropagation", trackPropagation);
          spy(e, "stopImmediatePropagation", trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);
          if (phase === "capture") {
            if (captureElToHandlers === void 0)
              return;
            for (let i = path.length - 1; i >= 0; --i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = captureElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
              if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                const bubbleHandlers = bubbleElToHandlers.get(target2);
                if (bubbleHandlers !== void 0) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === "bubble") {
            if (bubbleElToHandlers === void 0)
              return;
            for (let i = 0; i < path.length; ++i) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i];
              const handlers = bubbleElToHandlers.get(target2);
              if (handlers !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
          unspy(e, "stopPropagation");
          unspy(e, "stopImmediatePropagation");
          defineCurrentTarget(e);
        };
        delegeteHandler.displayName = "evtdUnifiedHandler";
        return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
        const delegateHandler = function(e) {
          const { type, eventPhase } = e;
          if (eventPhase !== 2)
            return;
          const handlers = typeToWindowEventHandlers[type];
          if (handlers === void 0)
            return;
          handlers.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
        return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type] === void 0) {
          phaseHandlers[type] = /* @__PURE__ */ new Map();
          window.addEventListener(type, unifiedHandler, phase === "capture");
        }
        return phaseHandlers[type];
      }
      function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        if (windowEventHandlers === void 0) {
          typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
          window.addEventListener(type, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type];
      }
      function ensureHandlers(elToHandlers, el2) {
        let elHandlers = elToHandlers.get(el2);
        if (elHandlers === void 0) {
          elToHandlers.set(el2, elHandlers = /* @__PURE__ */ new Set());
        }
        return elHandlers;
      }
      function handlerExist(el2, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type];
        if (elToHandlers !== void 0) {
          const handlers = elToHandlers.get(el2);
          if (handlers !== void 0) {
            if (handlers.has(handler))
              return true;
          }
        }
        return false;
      }
      function windowEventHandlerExist(type, handler) {
        const handlers = typeToWindowEventHandlers[type];
        if (handlers !== void 0) {
          if (handlers.has(handler)) {
            return true;
          }
        }
        return false;
      }
      function on2(type, el2, handler, options) {
        let mergedHandler;
        if (typeof options === "object" && options.once === true) {
          mergedHandler = (e) => {
            off2(type, el2, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }
        const trapped = trapOn(type, el2, mergedHandler, options);
        if (trapped)
          return;
        const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el2);
        if (!handlers.has(mergedHandler))
          handlers.add(mergedHandler);
        if (el2 === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type);
          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }
      function off2(type, el2, handler, options) {
        const trapped = trapOff(type, el2, handler, options);
        if (trapped)
          return;
        const capture = options === true || typeof options === "object" && options.capture === true;
        const phase = capture ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers = ensureHandlers(elToHandlers, el2);
        if (el2 === window) {
          const mirrorPhase = capture ? "bubble" : "capture";
          if (!handlerExist(el2, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
            const windowEventHandlers = typeToWindowEventHandlers[type];
            windowEventHandlers.delete(handler);
            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type] = void 0;
            }
          }
        }
        if (handlers.has(handler))
          handlers.delete(handler);
        if (handlers.size === 0) {
          elToHandlers.delete(el2);
        }
        if (elToHandlers.size === 0) {
          window.removeEventListener(type, unifiedHandler, phase === "capture");
          phaseToTypeToElToHandlers[phase][type] = void 0;
        }
      }
      return {
        on: on2,
        off: off2
      };
    }
    const { on: on$1, off } = createDelegate();
    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, (value) => {
        if (value !== void 0) {
          uncontrolledStateRef.value = value;
        }
      });
      return computed(() => {
        if (controlledStateRef.value === void 0) {
          return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
      });
    }
    function isMounted() {
      const isMounted2 = ref(false);
      onMounted(() => {
        isMounted2.value = true;
      });
      return readonly(isMounted2);
    }
    const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }
    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const drawerInjectionKey = createInjectionKey("n-drawer");
    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
    function getSlot(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
    }
    const ctxKey = "@@coContext";
    const clickoutside = {
      mounted(el2, { value, modifiers }) {
        el2[ctxKey] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el2[ctxKey].handler = value;
          on$1("clickoutside", el2, value, {
            capture: modifiers.capture
          });
        }
      },
      updated(el2, { value, modifiers }) {
        const ctx2 = el2[ctxKey];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("clickoutside", el2, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = value;
              on$1("clickoutside", el2, value, {
                capture: modifiers.capture
              });
            }
          } else {
            el2[ctxKey].handler = value;
            on$1("clickoutside", el2, value, {
              capture: modifiers.capture
            });
          }
        } else {
          if (ctx2.handler) {
            off("clickoutside", el2, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el2, { modifiers }) {
        const { handler } = el2[ctxKey];
        if (handler) {
          off("clickoutside", el2, handler, {
            capture: modifiers.capture
          });
        }
        el2[ctxKey].handler = void 0;
      }
    };
    function warn$1(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }
    class ZIndexManager {
      constructor() {
        this.elementZIndex = /* @__PURE__ */ new Map();
        this.nextZIndex = 2e3;
      }
      get elementCount() {
        return this.elementZIndex.size;
      }
      ensureZIndex(el2, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== void 0) {
          el2.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el2);
          return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el2)) {
          const currentZIndex = elementZIndex.get(el2);
          if (currentZIndex + 1 === this.nextZIndex)
            return;
        }
        el2.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el2, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }
      unregister(el2, zIndex) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el2)) {
          elementZIndex.delete(el2);
        } else if (zIndex === void 0) {
          warn$1("z-index-manager/unregister-element", "Element not found when unregistering.");
        }
        this.squashState();
      }
      squashState() {
        const { elementCount } = this;
        if (!elementCount) {
          this.nextZIndex = 2e3;
        }
        if (this.nextZIndex - elementCount > 2500)
          this.rearrange();
      }
      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2e3;
        elementZIndexPair.forEach((pair) => {
          const el2 = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el2.style.zIndex)
            el2.style.zIndex = `${zIndex}`;
        });
      }
    }
    const zIndexManager = new ZIndexManager();
    const ctx = "@@ziContext";
    const zindexable = {
      mounted(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        el2[ctx] = {
          enabled: !!enabled,
          initialized: false
        };
        if (enabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
      },
      updated(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el2[ctx].enabled;
        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
        el2[ctx].enabled = !!enabled;
      },
      unmounted(el2, bindings) {
        if (!el2[ctx].initialized)
          return;
        const { value = {} } = bindings;
        const { zIndex } = value;
        zIndexManager.unregister(el2, zIndex);
      }
    };
    const ssrContextKey = Symbol("@css-render/vue3-ssr");
    function createStyleString(id, style2) {
      return `<style cssr-id="${id}">
${style2}
</style>`;
    }
    function ssrAdapter(id, style2) {
      const ssrContext = inject(ssrContextKey, null);
      if (ssrContext === null) {
        console.error("[css-render/vue3-ssr]: no ssr context found.");
        return;
      }
      const { styles, ids } = ssrContext;
      if (ids.has(id))
        return;
      if (styles !== null) {
        ids.add(id);
        styles.push(createStyleString(id, style2));
      }
    }
    const isBrowser = typeof document !== "undefined";
    function useSsrAdapter() {
      if (isBrowser)
        return void 0;
      const context = inject(ssrContextKey, null);
      if (context === null)
        return void 0;
      return {
        adapter: ssrAdapter,
        context
      };
    }
    function warn(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }
    function resolveTo(selector) {
      if (typeof selector === "string") {
        return document.querySelector(selector);
      }
      return selector();
    }
    const LazyTeleport = /* @__PURE__ */ defineComponent({
      name: "LazyTeleport",
      props: {
        to: {
          type: [String, Object],
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(toRef(props, "show")),
          mergedTo: computed(() => {
            const { to: to2 } = props;
            return to2 !== null && to2 !== void 0 ? to2 : "body";
          })
        };
      },
      render() {
        return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : h(Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot("lazy-teleport", this.$slots)) : null;
      }
    });
    var resizeObservers = [];
    var hasActiveObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.activeTargets.length > 0;
      });
    };
    var hasSkippedObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.skippedTargets.length > 0;
      });
    };
    var msg = "ResizeObserver loop completed with undelivered notifications.";
    var deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
    var ResizeObserverBoxOptions;
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
    var freeze = function(obj) {
      return Object.freeze(obj);
    };
    var ResizeObserverSize = /* @__PURE__ */ function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
    var DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
    var isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    var isHidden = function(target) {
      if (isSVG(target)) {
        var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
        return !width && !height;
      }
      var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function(obj) {
      var _a2;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
    var global$1 = typeof window !== "undefined" ? window : {};
    var cache = /* @__PURE__ */ new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE$1 = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
    var parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    var size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE$1 && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    var calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
    var ResizeObserverEntry = /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
    var calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
    var broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro2) {
        if (ro2.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro2.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro2.callback.call(ro2.observer, entries, ro2.observer);
        });
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
      });
      for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
        var callback = callbacks_1[_i2];
        callback();
      }
      return shallowestDepth;
    };
    var gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro2) {
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
        ro2.skippedTargets.splice(0, ro2.skippedTargets.length);
        ro2.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro2.activeTargets.push(ot);
            } else {
              ro2.skippedTargets.push(ot);
            }
          }
        });
      });
    };
    var process = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
    var trigger;
    var callbacks = [];
    var notify = function() {
      return callbacks.splice(0).forEach(function(cb2) {
        return cb2();
      });
    };
    var queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
    var queueResizeObserver = function(cb2) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb2);
      });
    };
    var watching = 0;
    var isWatching = function() {
      return !!watching;
    };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    var time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb2 = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb2() : global$1.addEventListener("DOMContentLoaded", cb2);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    var scheduler = new Scheduler();
    var updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
    var skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    var ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverDetail = /* @__PURE__ */ function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
    var observerMap = /* @__PURE__ */ new WeakMap();
    var getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
        this.elHandlersMap = /* @__PURE__ */ new Map();
      }
      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);
          if (handler !== void 0) {
            handler(entry);
          }
        }
      }
      registerHandler(el2, handler) {
        this.elHandlersMap.set(el2, handler);
        this.observer.observe(el2);
      }
      unregisterHandler(el2) {
        if (!this.elHandlersMap.has(el2)) {
          return;
        }
        this.elHandlersMap.delete(el2);
        this.observer.unobserve(el2);
      }
    }
    const resizeObserverManager = new ResizeObserverDelegate();
    const VResizeObserver = /* @__PURE__ */ defineComponent({
      name: "ResizeObserver",
      props: {
        onResize: Function
      },
      setup(props) {
        let registered = false;
        const proxy = getCurrentInstance().proxy;
        function handleResize(entry) {
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        onMounted(() => {
          const el2 = proxy.$el;
          if (el2 === void 0) {
            warn("resize-observer", "$el does not exist.");
            return;
          }
          if (el2.nextElementSibling !== el2.nextSibling) {
            if (el2.nodeType === 3 && el2.nodeValue !== "") {
              warn("resize-observer", "$el can not be observed (it may be a text node).");
              return;
            }
          }
          if (el2.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el2.nextElementSibling, handleResize);
            registered = true;
          }
        });
        onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },
      render() {
        return renderSlot(this.$slots, "default");
      }
    });
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }
    function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }
      try {
        element.focus({ preventScroll: true });
      } catch (e) {
      }
      return document.activeElement === element;
    }
    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.getAttribute("disabled")) {
        return false;
      }
      switch (element.nodeName) {
        case "A":
          return !!element.href && element.rel !== "ignore";
        case "INPUT":
          return element.type !== "hidden" && element.type !== "file";
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
          return true;
        default:
          return false;
      }
    }
    let stack = [];
    const FocusTrap = /* @__PURE__ */ defineComponent({
      name: "FocusTrap",
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        const id = createId();
        const focusableStartRef = ref(null);
        const focusableEndRef = ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id;
        }
        function handleDocumentKeydown(e) {
          var _a2;
          if (e.code === "Escape") {
            if (isCurrentActive()) {
              (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
            }
          }
        }
        onMounted(() => {
          watch(() => props.active, (value) => {
            if (value) {
              activate();
              on$1("keydown", document, handleDocumentKeydown);
            } else {
              off("keydown", document, handleDocumentKeydown);
              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          off("keydown", document, handleDocumentKeydown);
          if (activated)
            deactivate();
        });
        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (mainEl.contains(getPreciseEventTarget(e)))
              return;
            resetFocusTo("first");
          }
        }
        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null)
            return null;
          let mainEl = focusableStartEl;
          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null)
              break;
            if (mainEl instanceof Element && mainEl.tagName === "DIV") {
              break;
            }
          }
          return mainEl;
        }
        function activate() {
          var _a2;
          if (props.disabled)
            return;
          stack.push(id);
          if (props.autoFocus) {
            const { initialFocusTo } = props;
            if (initialFocusTo === void 0) {
              resetFocusTo("first");
            } else {
              (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
            }
          }
          activated = true;
          document.addEventListener("focus", handleDocumentFocus, true);
        }
        function deactivate() {
          var _a2;
          if (props.disabled)
            return;
          document.removeEventListener("focus", handleDocumentFocus, true);
          stack = stack.filter((idInStack) => idInStack !== id);
          if (isCurrentActive())
            return;
          const { finalFocusTo } = props;
          if (finalFocusTo !== void 0) {
            (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
        function resetFocusTo(target) {
          if (!isCurrentActive())
            return;
          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;
            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();
              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
                return;
              }
              ignoreInternalFocusChange = true;
              const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;
              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }
        function handleStartFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        function handleEndFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: "position: absolute; height: 0; width: 0;",
          handleStartFocus,
          handleEndFocus
        };
      },
      render() {
        const { default: defaultSlot } = this.$slots;
        if (defaultSlot === void 0)
          return null;
        if (this.disabled)
          return defaultSlot();
        const { active, focusableStyle } = this;
        return h(Fragment, null, [
          h("div", {
            "aria-hidden": "true",
            tabindex: active ? "0" : "-1",
            ref: "focusableStartRef",
            style: focusableStyle,
            onFocus: this.handleStartFocus
          }),
          defaultSlot(),
          h("div", {
            "aria-hidden": "true",
            style: focusableStyle,
            ref: "focusableEndRef",
            tabindex: active ? "0" : "-1",
            onFocus: this.handleEndFocus
          })
        ]);
      }
    });
    let lockCount = 0;
    let originalMarginRight = "";
    let originalOverflow = "";
    let originalOverflowX = "";
    let originalOverflowY = "";
    const lockHtmlScrollRightCompensationRef = ref("0px");
    function useLockHtmlScroll(lockRef) {
      if (typeof document === "undefined")
        return;
      const el2 = document.documentElement;
      let watchStopHandle;
      let activated = false;
      const unlock = () => {
        el2.style.marginRight = originalMarginRight;
        el2.style.overflow = originalOverflow;
        el2.style.overflowX = originalOverflowX;
        el2.style.overflowY = originalOverflowY;
        lockHtmlScrollRightCompensationRef.value = "0px";
      };
      onMounted(() => {
        watchStopHandle = watch(lockRef, (value) => {
          if (value) {
            if (!lockCount) {
              const scrollbarWidth = window.innerWidth - el2.offsetWidth;
              if (scrollbarWidth > 0) {
                originalMarginRight = el2.style.marginRight;
                el2.style.marginRight = `${scrollbarWidth}px`;
                lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
              }
              originalOverflow = el2.style.overflow;
              originalOverflowX = el2.style.overflowX;
              originalOverflowY = el2.style.overflowY;
              el2.style.overflow = "hidden";
              el2.style.overflowX = "hidden";
              el2.style.overflowY = "hidden";
            }
            activated = true;
            lockCount++;
          } else {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
        if (activated) {
          lockCount--;
          if (!lockCount) {
            unlock();
          }
          activated = false;
        }
      });
    }
    const isComposingRef = ref(false);
    const compositionStartHandler = () => {
      isComposingRef.value = true;
    };
    const compositionEndHandler = () => {
      isComposingRef.value = false;
    };
    let mountedCount = 0;
    const useIsComposing = () => {
      if (isBrowser$1) {
        onBeforeMount(() => {
          if (!mountedCount) {
            window.addEventListener("compositionstart", compositionStartHandler);
            window.addEventListener("compositionend", compositionEndHandler);
          }
          mountedCount++;
        });
        onBeforeUnmount(() => {
          if (mountedCount <= 1) {
            window.removeEventListener("compositionstart", compositionStartHandler);
            window.removeEventListener("compositionend", compositionEndHandler);
            mountedCount = 0;
          } else {
            mountedCount--;
          }
        });
      }
      return isComposingRef;
    };
    function useReactivated(callback) {
      const isDeactivatedRef = { isDeactivated: false };
      let activateStateInitialized = false;
      onActivated(() => {
        isDeactivatedRef.isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        callback();
      });
      onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }
    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props, { defaultSize = "medium", mergedSize, mergedDisabled } = {}) {
      const NFormItem2 = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
        const { size: size2 } = props;
        if (size2)
          return size2;
        if (NFormItem2) {
          const { mergedSize: mergedSize2 } = NFormItem2;
          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }
        return defaultSize;
      });
      const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
        const { disabled } = props;
        if (disabled !== void 0) {
          return disabled;
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      });
      const mergedStatusRef = computed(() => {
        const { status } = props;
        if (status)
          return status;
        return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
        if (NFormItem2) {
          NFormItem2.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur() {
          if (NFormItem2) {
            NFormItem2.handleContentBlur();
          }
        },
        nTriggerFormChange() {
          if (NFormItem2) {
            NFormItem2.handleContentChange();
          }
        },
        nTriggerFormFocus() {
          if (NFormItem2) {
            NFormItem2.handleContentFocus();
          }
        },
        nTriggerFormInput() {
          if (NFormItem2) {
            NFormItem2.handleContentInput();
          }
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$9.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$8 = Object.prototype;
    var nativeObjectToString = objectProto$8.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$1 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return false ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsZWJ$1 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      {
        return buffer.slice();
      }
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const commonVariables$m = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };
    const {
      fontSize,
      fontFamily,
      lineHeight
    } = commonVariables$m;
    const globalStyle = c("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
    const configProviderInjectionKey = createInjectionKey("n-config-provider");
    const cssrAnchorMetaName = "naive-ui-style";
    function createTheme(theme) {
      return theme;
    }
    function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      if (style2) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          onBeforeMount(mountStyle);
        }
      }
      const mergedThemeRef = computed(() => {
        var _a2;
        const { theme: { common: selfCommon, self: self2, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
        const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
        const { common: globalCommon = void 0, [resolveId]: { common: globalSelfCommon = void 0, self: globalSelf = void 0, peers: globalPeers = {} } = {} } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
        const { common: globalCommonOverrides = void 0, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
        const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
        const mergedCommon = merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = merge(
          // {}, executed every time, no need for empty obj
          (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
          builtinOverrides,
          globalSelfOverrides,
          selfOverrides
        );
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: merge({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: merge({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }
    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };
    const defaultClsPrefix = "n";
    function useConfig(props = {}, options = {
      defaultBordered: true
    }) {
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      return {
        // NConfigProvider,
        inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
        mergedBorderedRef: computed(() => {
          var _a2, _b2;
          const { bordered } = props;
          if (bordered !== void 0)
            return bordered;
          return (_b2 = (_a2 = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
        }),
        mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
        namespaceRef: computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
      };
    }
    function useStyle(mountId, style2, clsPrefixRef) {
      if (!style2) {
        return;
      }
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2
        });
        if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      var _a2;
      if (!cssVarsRef)
        throwError("useThemeClass", "cssVarsRef is not passed");
      const mergedThemeHashRef = (_a2 = inject(configProviderInjectionKey, null)) === null || _a2 === void 0 ? void 0 : _a2.mergedThemeHashRef;
      const themeClassRef = ref("");
      const ssrAdapter2 = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash)
          finalThemeHash += "-" + themeHash;
        if (hashValue)
          finalThemeHash += "-" + hashValue;
        const { themeOverrides, builtinThemeOverrides } = props;
        if (themeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(themeOverrides));
        }
        if (builtinThemeOverrides) {
          finalThemeHash += "-" + murmur2(JSON.stringify(builtinThemeOverrides));
        }
        themeClassRef.value = finalThemeHash;
        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style2 = "";
          for (const key in cssVars) {
            style2 += `${key}: ${cssVars[key]};`;
          }
          c(`.${finalThemeHash}`, style2).mount({
            id: finalThemeHash,
            ssr: ssrAdapter2
          });
          renderCallback = void 0;
        };
      };
      watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
        }
      };
    }
    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef)
        return void 0;
      const ssrAdapter2 = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
        const { value: rtlState } = rtlStateRef;
        if (!rtlState) {
          return void 0;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
          return void 0;
        }
        return componentRtlState;
      });
      const mountStyle = () => {
        watchEffect(() => {
          const { value: clsPrefix } = clsPrefixRef;
          const id = `${clsPrefix}${mountId}Rtl`;
          if (exists(id, ssrAdapter2))
            return;
          const { value: componentRtlState } = componentRtlStateRef;
          if (!componentRtlState)
            return;
          componentRtlState.style.mount({
            id,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2
          });
        });
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
    }
    function replaceable(name, icon) {
      return /* @__PURE__ */ defineComponent({
        name: upperFirst(name),
        setup() {
          var _a2;
          const mergedIconsRef = (_a2 = inject(configProviderInjectionKey, null)) === null || _a2 === void 0 ? void 0 : _a2.mergedIconsRef;
          return () => {
            var _a3;
            const iconOverride = (_a3 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a3 === void 0 ? void 0 : _a3[name];
            return iconOverride ? iconOverride() : icon;
          };
        }
      });
    }
    const ErrorIcon = replaceable("close", h(
      "svg",
      { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": true },
      h(
        "g",
        { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
        h(
          "g",
          { fill: "currentColor", "fill-rule": "nonzero" },
          h("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" })
        )
      )
    ));
    const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, { slots }) {
        const isMountedRef = isMounted();
        return () => h(Transition, { name: "icon-switch-transition", appear: isMountedRef.value }, slots);
      }
    });
    const NFadeInExpandTransition = /* @__PURE__ */ defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
      },
      setup(props, { slots }) {
        function handleBeforeLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = `${el2.offsetWidth}px`;
          } else {
            el2.style.maxHeight = `${el2.offsetHeight}px`;
          }
          void el2.offsetWidth;
        }
        function handleLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "0";
          } else {
            el2.style.maxHeight = "0";
          }
          void el2.offsetWidth;
          const { onLeave } = props;
          if (onLeave)
            onLeave();
        }
        function handleAfterLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            el2.style.maxHeight = "";
          }
          const { onAfterLeave } = props;
          if (onAfterLeave)
            onAfterLeave();
        }
        function handleEnter(el2) {
          el2.style.transition = "none";
          if (props.width) {
            const memorizedWidth = el2.offsetWidth;
            el2.style.maxWidth = "0";
            void el2.offsetWidth;
            el2.style.transition = "";
            el2.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el2.style.maxHeight = `${el2.offsetHeight}px`;
              void el2.offsetHeight;
              el2.style.transition = "";
              el2.style.maxHeight = "0";
            } else {
              const memorizedHeight = el2.offsetHeight;
              el2.style.maxHeight = "0";
              void el2.offsetWidth;
              el2.style.transition = "";
              el2.style.maxHeight = `${memorizedHeight}px`;
            }
          }
          void el2.offsetWidth;
        }
        function handleAfterEnter(el2) {
          var _a2;
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el2.style.maxHeight = "";
            }
          }
          (_a2 = props.onAfterEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        return () => {
          const { group, width, appear, mode } = props;
          const type = group ? TransitionGroup : Transition;
          const resolvedProps = {
            name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          };
          if (!group) {
            resolvedProps.mode = mode;
          }
          return h(type, resolvedProps, slots);
        };
      }
    });
    const style$b = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c("svg", `
 height: 1em;
 width: 1em;
 `)]);
    const NBaseIcon = /* @__PURE__ */ defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$b, toRef(props, "clsPrefix"));
      },
      render() {
        return h("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots);
      }
    });
    const style$a = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM$1("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM$1("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM$1("round", [c("&::before", `
 border-radius: 50%;
 `)])]);
    const NBaseClose = /* @__PURE__ */ defineComponent({
      name: "BaseClose",
      props: {
        isButtonTag: {
          type: Boolean,
          default: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$a, toRef(props, "clsPrefix"));
        return () => {
          const { clsPrefix, disabled, absolute, round, isButtonTag } = props;
          const Tag = isButtonTag ? "button" : "div";
          return h(
            Tag,
            { type: isButtonTag ? "button" : void 0, tabindex: disabled || !props.focusable ? -1 : 0, "aria-disabled": disabled, "aria-label": "close", role: isButtonTag ? void 0 : "button", disabled, class: [
              `${clsPrefix}-base-close`,
              absolute && `${clsPrefix}-base-close--absolute`,
              disabled && `${clsPrefix}-base-close--disabled`,
              round && `${clsPrefix}-base-close--round`
            ], onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            }, onClick: props.onClick },
            h(NBaseIcon, { clsPrefix }, {
              default: () => h(ErrorIcon, null)
            })
          );
        };
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$m;
    function iconSwitchTransition({
      originalTransform = "",
      left = 0,
      top = 0,
      transition = `all .3s ${cubicBezierEaseInOut$3} !important`
    } = {}) {
      return [c("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: originalTransform + " scale(0.75)",
        left,
        top,
        opacity: 0
      }), c("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }
    const style$9 = c([c("@keyframes loading-container-rotate", `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), c("@keyframes loading-layer-rotate", `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), c("@keyframes loading-left-spin", `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), c("@keyframes loading-right-spin", `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE$1("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE$1("container", `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [cE$1("svg", `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), cE$1("container-layer", `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [cE$1("container-layer-left", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE$1("svg", `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), cE$1("container-layer-patch", `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [cE$1("svg", `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), cE$1("container-layer-right", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE$1("svg", `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), cE$1("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })])])]);
    const exposedLoadingProps = {
      strokeWidth: {
        type: Number,
        default: 28
      },
      stroke: {
        type: String,
        default: void 0
      }
    };
    const NBaseLoading = /* @__PURE__ */ defineComponent({
      name: "BaseLoading",
      props: Object.assign({ clsPrefix: {
        type: String,
        required: true
      }, show: {
        type: Boolean,
        default: true
      }, scale: {
        type: Number,
        default: 1
      }, radius: {
        type: Number,
        default: 100
      } }, exposedLoadingProps),
      setup(props) {
        useStyle("-base-loading", style$9, toRef(props, "clsPrefix"));
      },
      render() {
        const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
        const scaledRadius = radius / scale;
        return h(
          "div",
          { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" },
          h(NIconSwitchTransition, null, {
            default: () => this.show ? h(
              "div",
              { key: "icon", class: `${clsPrefix}-base-loading__transition-wrapper` },
              h(
                "div",
                { class: `${clsPrefix}-base-loading__container` },
                h(
                  "div",
                  { class: `${clsPrefix}-base-loading__container-layer` },
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-left` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  ),
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-patch` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  ),
                  h(
                    "div",
                    { class: `${clsPrefix}-base-loading__container-layer-right` },
                    h(
                      "svg",
                      { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius })
                    )
                  )
                )
              )
            ) : h("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots)
          })
        );
      }
    });
    const base$1 = {
      neutralBase: "#000",
      neutralInvertBase: "#fff",
      neutralTextBase: "#fff",
      neutralPopover: "rgb(72, 72, 78)",
      neutralCard: "rgb(24, 24, 28)",
      neutralModal: "rgb(44, 44, 50)",
      neutralBody: "rgb(16, 16, 20)",
      alpha1: "0.9",
      alpha2: "0.82",
      alpha3: "0.52",
      alpha4: "0.38",
      alpha5: "0.28",
      alphaClose: "0.52",
      alphaDisabled: "0.38",
      alphaDisabledInput: "0.06",
      alphaPending: "0.09",
      alphaTablePending: "0.06",
      alphaTableStriped: "0.05",
      alphaPressed: "0.05",
      alphaAvatar: "0.18",
      alphaRail: "0.2",
      alphaProgressRail: "0.12",
      alphaBorder: "0.24",
      alphaDivider: "0.09",
      alphaInput: "0.1",
      alphaAction: "0.06",
      alphaTab: "0.04",
      alphaScrollbar: "0.2",
      alphaScrollbarHover: "0.3",
      alphaCode: "0.12",
      alphaTag: "0.2",
      // primary
      primaryHover: "#7fe7c4",
      primaryDefault: "#63e2b7",
      primaryActive: "#5acea7",
      primarySuppl: "rgb(42, 148, 125)",
      // info
      infoHover: "#8acbec",
      infoDefault: "#70c0e8",
      infoActive: "#66afd3",
      infoSuppl: "rgb(56, 137, 197)",
      // error
      errorHover: "#e98b8b",
      errorDefault: "#e88080",
      errorActive: "#e57272",
      errorSuppl: "rgb(208, 58, 82)",
      // warning
      warningHover: "#f5d599",
      warningDefault: "#f2c97d",
      warningActive: "#e6c260",
      warningSuppl: "rgb(240, 138, 0)",
      // success
      successHover: "#7fe7c4",
      successDefault: "#63e2b7",
      successActive: "#5acea7",
      successSuppl: "rgb(42, 148, 125)"
    };
    const baseBackgroundRgb$1 = rgba(base$1.neutralBase);
    const baseInvertBackgroundRgb$1 = rgba(base$1.neutralInvertBase);
    const overlayPrefix$1 = "rgba(" + baseInvertBackgroundRgb$1.slice(0, 3).join(", ") + ", ";
    function overlay$1(alpha) {
      return overlayPrefix$1 + String(alpha) + ")";
    }
    function neutral$1(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb$1, overlayRgba);
    }
    const derived$1 = Object.assign(Object.assign({ name: "common" }, commonVariables$m), {
      baseColor: base$1.neutralBase,
      // primary color
      primaryColor: base$1.primaryDefault,
      primaryColorHover: base$1.primaryHover,
      primaryColorPressed: base$1.primaryActive,
      primaryColorSuppl: base$1.primarySuppl,
      // info color
      infoColor: base$1.infoDefault,
      infoColorHover: base$1.infoHover,
      infoColorPressed: base$1.infoActive,
      infoColorSuppl: base$1.infoSuppl,
      // success color
      successColor: base$1.successDefault,
      successColorHover: base$1.successHover,
      successColorPressed: base$1.successActive,
      successColorSuppl: base$1.successSuppl,
      // warning color
      warningColor: base$1.warningDefault,
      warningColorHover: base$1.warningHover,
      warningColorPressed: base$1.warningActive,
      warningColorSuppl: base$1.warningSuppl,
      // error color
      errorColor: base$1.errorDefault,
      errorColorHover: base$1.errorHover,
      errorColorPressed: base$1.errorActive,
      errorColorSuppl: base$1.errorSuppl,
      // text color
      textColorBase: base$1.neutralTextBase,
      textColor1: overlay$1(base$1.alpha1),
      textColor2: overlay$1(base$1.alpha2),
      textColor3: overlay$1(base$1.alpha3),
      // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
      // textColor5: overlay(base.alpha5),
      textColorDisabled: overlay$1(base$1.alpha4),
      placeholderColor: overlay$1(base$1.alpha4),
      placeholderColorDisabled: overlay$1(base$1.alpha5),
      iconColor: overlay$1(base$1.alpha4),
      iconColorDisabled: overlay$1(base$1.alpha5),
      iconColorHover: overlay$1(Number(base$1.alpha4) * 1.25),
      iconColorPressed: overlay$1(Number(base$1.alpha4) * 0.8),
      opacity1: base$1.alpha1,
      opacity2: base$1.alpha2,
      opacity3: base$1.alpha3,
      opacity4: base$1.alpha4,
      opacity5: base$1.alpha5,
      dividerColor: overlay$1(base$1.alphaDivider),
      borderColor: overlay$1(base$1.alphaBorder),
      // close
      closeIconColorHover: overlay$1(Number(base$1.alphaClose)),
      closeIconColor: overlay$1(Number(base$1.alphaClose)),
      closeIconColorPressed: overlay$1(Number(base$1.alphaClose)),
      closeColorHover: "rgba(255, 255, 255, .12)",
      closeColorPressed: "rgba(255, 255, 255, .08)",
      // clear
      clearColor: overlay$1(base$1.alpha4),
      clearColorHover: scaleColor(overlay$1(base$1.alpha4), { alpha: 1.25 }),
      clearColorPressed: scaleColor(overlay$1(base$1.alpha4), { alpha: 0.8 }),
      scrollbarColor: overlay$1(base$1.alphaScrollbar),
      scrollbarColorHover: overlay$1(base$1.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: overlay$1(base$1.alphaProgressRail),
      railColor: overlay$1(base$1.alphaRail),
      popoverColor: base$1.neutralPopover,
      tableColor: base$1.neutralCard,
      cardColor: base$1.neutralCard,
      modalColor: base$1.neutralModal,
      bodyColor: base$1.neutralBody,
      tagColor: neutral$1(base$1.alphaTag),
      avatarColor: overlay$1(base$1.alphaAvatar),
      invertedColor: base$1.neutralBase,
      inputColor: overlay$1(base$1.alphaInput),
      codeColor: overlay$1(base$1.alphaCode),
      tabColor: overlay$1(base$1.alphaTab),
      actionColor: overlay$1(base$1.alphaAction),
      tableHeaderColor: overlay$1(base$1.alphaAction),
      hoverColor: overlay$1(base$1.alphaPending),
      tableColorHover: overlay$1(base$1.alphaTablePending),
      tableColorStriped: overlay$1(base$1.alphaTableStriped),
      pressedColor: overlay$1(base$1.alphaPressed),
      opacityDisabled: base$1.alphaDisabled,
      inputColorDisabled: overlay$1(base$1.alphaDisabledInput),
      buttonColor2: "rgba(255, 255, 255, .08)",
      buttonColor2Hover: "rgba(255, 255, 255, .12)",
      buttonColor2Pressed: "rgba(255, 255, 255, .08)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const base = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      alpha5: "0.18",
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaAvatar: "0.2",
      alphaProgressRail: ".08",
      alphaInput: "0",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      // primary
      primaryHover: "#36ad6a",
      primaryDefault: "#18a058",
      primaryActive: "#0c7a43",
      primarySuppl: "#36ad6a",
      // info
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      // error
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      // warning
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      // success
      successHover: "#36ad6a",
      successDefault: "#18a058",
      successActive: "#0c7a43",
      successSuppl: "#36ad6a"
    };
    const baseBackgroundRgb = rgba(base.neutralBase);
    const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
    const overlayPrefix = "rgba(" + baseInvertBackgroundRgb.slice(0, 3).join(", ") + ", ";
    function overlay(alpha) {
      return overlayPrefix + String(alpha) + ")";
    }
    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }
    const derived = Object.assign(Object.assign({ name: "common" }, commonVariables$m), {
      baseColor: base.neutralBase,
      // primary color
      primaryColor: base.primaryDefault,
      primaryColorHover: base.primaryHover,
      primaryColorPressed: base.primaryActive,
      primaryColorSuppl: base.primarySuppl,
      // info color
      infoColor: base.infoDefault,
      infoColorHover: base.infoHover,
      infoColorPressed: base.infoActive,
      infoColorSuppl: base.infoSuppl,
      // success color
      successColor: base.successDefault,
      successColorHover: base.successHover,
      successColorPressed: base.successActive,
      successColorSuppl: base.successSuppl,
      // warning color
      warningColor: base.warningDefault,
      warningColorHover: base.warningHover,
      warningColorPressed: base.warningActive,
      warningColorSuppl: base.warningSuppl,
      // error color
      errorColor: base.errorDefault,
      errorColorHover: base.errorHover,
      errorColorPressed: base.errorActive,
      errorColorSuppl: base.errorSuppl,
      // text color
      textColorBase: base.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base.alpha4),
      placeholderColor: neutral(base.alpha4),
      placeholderColorDisabled: neutral(base.alpha5),
      iconColor: neutral(base.alpha4),
      iconColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
      iconColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
      iconColorDisabled: neutral(base.alpha5),
      opacity1: base.alpha1,
      opacity2: base.alpha2,
      opacity3: base.alpha3,
      opacity4: base.alpha4,
      opacity5: base.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      // close
      closeIconColor: neutral(Number(base.alphaClose)),
      closeIconColorHover: neutral(Number(base.alphaClose)),
      closeIconColorPressed: neutral(Number(base.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      // clear
      clearColor: neutral(base.alpha4),
      clearColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }),
      clearColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }),
      scrollbarColor: overlay(base.alphaScrollbar),
      scrollbarColorHover: overlay(base.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base.neutralPopover,
      tableColor: base.neutralCard,
      cardColor: base.neutralCard,
      modalColor: base.neutralModal,
      bodyColor: base.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const commonVars$c = {
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };
    const self$R = (vars) => {
      const { textColorDisabled, iconColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge } = vars;
      return Object.assign(Object.assign({}, commonVars$c), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      });
    };
    const emptyLight = {
      name: "Empty",
      common: derived,
      self: self$R
    };
    const emptyDark = {
      name: "Empty",
      common: derived$1,
      self: self$R
    };
    const self$Q = (vars) => {
      const { scrollbarColor, scrollbarColorHover } = vars;
      return {
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      };
    };
    const scrollbarLight = {
      name: "Scrollbar",
      common: derived,
      self: self$Q
    };
    const scrollbarDark = {
      name: "Scrollbar",
      common: derived$1,
      self: self$Q
    };
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$m;
    function fadeInTransition({
      name = "fade-in",
      enterDuration = "0.2s",
      leaveDuration = "0.2s",
      enterCubicBezier = cubicBezierEaseInOut$2,
      leaveCubicBezier = cubicBezierEaseInOut$2
    } = {}) {
      return [c(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }
    const style$8 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c(">", [cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)])])]), c(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 -webkit-user-select: none;
 `, [cM$1("horizontal", `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--n-scrollbar-height);
 `, [c(">", [cE$1("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM$1("vertical", `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--n-scrollbar-width);
 `, [c(">", [cE$1("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM$1("disabled", [c(">", [cE$1("scrollbar", {
      pointerEvents: "none"
    })])]), c(">", [cE$1("scrollbar", `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c("&:hover", {
      backgroundColor: "var(--n-scrollbar-color-hover)"
    })])])])])]);
    const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: Number,
        default: 5
      },
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      // If container is set, resize observer won't not attached
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: String,
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean
    });
    const Scrollbar = /* @__PURE__ */ defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      inheritAttrs: false,
      setup(props) {
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = ref(null);
        const containerRef = ref(null);
        const contentRef = ref(null);
        const yRailRef = ref(null);
        const xRailRef = ref(null);
        const contentHeightRef = ref(null);
        const contentWidthRef = ref(null);
        const containerHeightRef = ref(null);
        const containerWidthRef = ref(null);
        const yRailSizeRef = ref(null);
        const xRailSizeRef = ref(null);
        const containerScrollTopRef = ref(0);
        const containerScrollLeftRef = ref(0);
        const isShowXBarRef = ref(false);
        const isShowYBarRef = ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos2 = useIsIos();
        const yBarSizeRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + props.size * 1.5);
          }
        });
        const yBarSizePxRef = computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + props.size * 1.5;
          }
        });
        const xBarSizePxRef = computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: containerScrollTop } = containerScrollTopRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yRailSize } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff)
              return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: containerScrollLeft } = containerScrollLeftRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xRailSize } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff)
              return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = computed(() => {
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = computed(() => {
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = computed(() => {
          const { trigger: trigger2 } = props;
          return trigger2 === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = computed(() => {
          const { trigger: trigger2 } = props;
          return trigger2 === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = computed(() => {
          const { container } = props;
          if (container)
            return container();
          return containerRef.value;
        });
        const mergedContentRef = computed(() => {
          const { content } = props;
          if (content)
            return content();
          return contentRef.value;
        });
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated)
            return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated)
            return;
          const { onResize } = props;
          if (onResize)
            onResize(e);
          sync();
        };
        const scrollTo = (options, y) => {
          if (!props.scrollable)
            return;
          if (typeof options === "number") {
            scrollToPosition(y !== null && y !== void 0 ? y : 0, options, 0, false, "auto");
            return;
          }
          const { left, top, index, elSize, position, behavior, el: el2, debounce = true } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
          }
          if (el2 !== void 0) {
            scrollToPosition(0, el2.offsetTop, el2.offsetHeight, debounce, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable)
            return;
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
          const { value: container } = mergedContainerRef;
          if (!container)
            return;
          if (debounce) {
            const { scrollTop, offsetHeight } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight) ;
              else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const { onScroll } = props;
          if (onScroll)
            onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          }
        }
        function syncPositionState() {
          const { value: content } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const { value: container } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const { value: container } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable)
            return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          var _a2;
          return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on$1("mousemove", window, handleXScrollMouseMove, true);
          on$1("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerWidth } = containerWidthRef;
          const { value: contentWidth } = contentWidthRef;
          const { value: xBarSize } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null)
            return;
          const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            const { internalOnUpdateScrollLeft } = props;
            if (internalOnUpdateScrollLeft)
              internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on$1("mousemove", window, handleYScrollMouseMove, true);
          on$1("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed)
            return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const { value: containerHeight } = containerHeightRef;
          const { value: contentHeight } = contentHeightRef;
          const { value: yBarSize } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null)
            return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const { value: container } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        watchEffect(() => {
          const { value: needXBar } = needXBarRef;
          const { value: needYBar } = needYBarRef;
          const { value: mergedClsPrefix } = mergedClsPrefixRef;
          const { value: xRailEl } = xRailRef;
          const { value: yRailEl } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
        });
        onMounted(() => {
          if (props.container)
            return;
          sync();
        });
        onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const themeRef = useTheme("Scrollbar", "-scrollbar", style$8, scrollbarLight, props, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color, colorHover } } = themeRef.value;
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut2,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": scrollbarBorderRadius,
            "--n-scrollbar-width": scrollbarWidth,
            "--n-scrollbar-height": scrollbarHeight
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos: isIos2,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a2;
        const { $slots, mergedClsPrefix, triggerDisplayManually, rtlEnabled, internalHoistYRail } = this;
        if (!this.scrollable)
          return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        const triggerIsNone = this.trigger === "none";
        const createYRail = (style2) => {
          return h("div", { ref: "yRailRef", class: [
            `${mergedClsPrefix}-scrollbar-rail`,
            `${mergedClsPrefix}-scrollbar-rail--vertical`
          ], "data-scrollbar-rail": true, style: [style2 || "", this.verticalRailStyle], "aria-hiddens": true }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
            default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
              height: this.yBarSizePx,
              top: this.yBarTopPx
            }, onMousedown: this.handleYScrollMouseDown }) : null
          }));
        };
        const createChildren = () => {
          var _a3, _b2;
          (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
          return h("div", mergeProps(this.$attrs, {
            role: "none",
            ref: "wrapperRef",
            class: [
              `${mergedClsPrefix}-scrollbar`,
              this.themeClass,
              rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
            ],
            style: this.cssVars,
            onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
            onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
          }), [
            this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h(
              "div",
              { role: "none", ref: "containerRef", class: [
                `${mergedClsPrefix}-scrollbar-container`,
                this.containerClass
              ], style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel },
              h(VResizeObserver, { onResize: this.handleContentResize }, {
                default: () => h("div", { ref: "contentRef", role: "none", style: [
                  {
                    width: this.xScrollable ? "fit-content" : null
                  },
                  this.contentStyle
                ], class: [
                  `${mergedClsPrefix}-scrollbar-content`,
                  this.contentClass
                ] }, $slots)
              })
            ),
            internalHoistYRail ? null : createYRail(void 0),
            this.xScrollable && h("div", { ref: "xRailRef", class: [
              `${mergedClsPrefix}-scrollbar-rail`,
              `${mergedClsPrefix}-scrollbar-rail--horizontal`
            ], style: this.horizontalRailStyle, "data-scrollbar-rail": true, "aria-hidden": true }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : { name: "fade-in-transition" }, {
              default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                width: this.xBarSizePx,
                right: rtlEnabled ? this.xBarLeftPx : void 0,
                left: rtlEnabled ? void 0 : this.xBarLeftPx
              }, onMousedown: this.handleXScrollMouseDown }) : null
            }))
          ]);
        };
        const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, { onResize: this.handleContainerResize }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return h(
            Fragment,
            null,
            scrollbarNode,
            createYRail(this.cssVars)
          );
        } else {
          return scrollbarNode;
        }
      }
    });
    const commonVariables$l = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };
    const self$P = (vars) => {
      const { borderRadius, popoverColor, textColor3, dividerColor, textColor2, primaryColorPressed, textColorDisabled, primaryColor, opacityDisabled, hoverColor, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge } = vars;
      return Object.assign(Object.assign({}, commonVariables$l), { optionFontSizeSmall: fontSizeSmall, optionFontSizeMedium: fontSizeMedium, optionFontSizeLarge: fontSizeLarge, optionFontSizeHuge: fontSizeHuge, optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius, color: popoverColor, groupHeaderTextColor: textColor3, actionDividerColor: dividerColor, optionTextColor: textColor2, optionTextColorPressed: primaryColorPressed, optionTextColorDisabled: textColorDisabled, optionTextColorActive: primaryColor, optionOpacityDisabled: opacityDisabled, optionCheckColor: primaryColor, optionColorPending: hoverColor, optionColorActive: "rgba(0, 0, 0, 0)", optionColorActivePending: hoverColor, actionTextColor: textColor2, loadingColor: primaryColor });
    };
    const internalSelectMenuDark = {
      name: "InternalSelectMenu",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self: self$P
    };
    const style$7 = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
    const NBaseWave = /* @__PURE__ */ defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$7, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const activeRef = ref(false);
        let animationTimerId = null;
        onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void nextTick(() => {
              var _a2;
              void ((_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight);
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const { clsPrefix } = this;
        return h("div", { ref: "selfRef", "aria-hidden": true, class: [
          `${clsPrefix}-base-wave`,
          this.active && `${clsPrefix}-base-wave--active`
        ] });
      }
    });
    const commonVariables$k = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };
    const self$O = (vars) => {
      const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize: fontSize2, dividerColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$k), {
        fontSize: fontSize2,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      });
    };
    const popoverDark = {
      name: "Popover",
      common: derived$1,
      self: self$O
    };
    const commonVariables$j = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px",
      closeMarginRtl: "0 4px 0 0"
    };
    const tagDark = {
      name: "Tag",
      common: derived$1,
      self(vars) {
        const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, tagColor, opacityDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
        return Object.assign(Object.assign({}, commonVariables$j), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          // checked
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          // default
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "#0000",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, { alpha: 0.16 }),
          colorBorderedPrimary: "#0000",
          closeIconColorPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
          closeIconColorHoverPrimary: scaleColor(primaryColor, { lightness: 0.7 }),
          closeIconColorPressedPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.16 }),
          closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.12 }),
          borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, { alpha: 0.16 }),
          colorBorderedInfo: "#0000",
          closeIconColorInfo: scaleColor(infoColor, { alpha: 0.7 }),
          closeIconColorHoverInfo: scaleColor(infoColor, { alpha: 0.7 }),
          closeIconColorPressedInfo: scaleColor(infoColor, { alpha: 0.7 }),
          closeColorHoverInfo: changeColor(infoColor, { alpha: 0.16 }),
          closeColorPressedInfo: changeColor(infoColor, { alpha: 0.12 }),
          borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, { alpha: 0.16 }),
          colorBorderedSuccess: "#0000",
          closeIconColorSuccess: scaleColor(successColor, { alpha: 0.7 }),
          closeIconColorHoverSuccess: scaleColor(successColor, { alpha: 0.7 }),
          closeIconColorPressedSuccess: scaleColor(successColor, { alpha: 0.7 }),
          closeColorHoverSuccess: changeColor(successColor, { alpha: 0.16 }),
          closeColorPressedSuccess: changeColor(successColor, { alpha: 0.12 }),
          borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.3 })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, { alpha: 0.16 }),
          colorBorderedWarning: "#0000",
          closeIconColorWarning: scaleColor(warningColor, { alpha: 0.7 }),
          closeIconColorHoverWarning: scaleColor(warningColor, { alpha: 0.7 }),
          closeIconColorPressedWarning: scaleColor(warningColor, { alpha: 0.7 }),
          closeColorHoverWarning: changeColor(warningColor, { alpha: 0.16 }),
          closeColorPressedWarning: changeColor(warningColor, { alpha: 0.11 }),
          borderError: `1px solid ${changeColor(errorColor, { alpha: 0.3 })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, { alpha: 0.16 }),
          colorBorderedError: "#0000",
          closeIconColorError: scaleColor(errorColor, { alpha: 0.7 }),
          closeIconColorHoverError: scaleColor(errorColor, { alpha: 0.7 }),
          closeIconColorPressedError: scaleColor(errorColor, { alpha: 0.7 }),
          closeColorHoverError: changeColor(errorColor, { alpha: 0.16 }),
          closeColorPressedError: changeColor(errorColor, { alpha: 0.12 })
        });
      }
    };
    const commonVars$b = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };
    const internalSelectionDark = {
      name: "InternalSelection",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
        return Object.assign(Object.assign({}, commonVars$b), {
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          // default
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: changeColor(primaryColor, { alpha: 0.1 }),
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          // warning
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          colorActiveWarning: changeColor(warningColor, { alpha: 0.1 }),
          caretColorWarning: warningColor,
          // error
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          colorActiveError: changeColor(errorColor, { alpha: 0.1 }),
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      }
    };
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1
    } = commonVariables$m;
    function fadeInWidthExpandTransition({
      duration = ".2s",
      delay = ".1s"
    } = {}) {
      return [c("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$1},
 max-width ${duration} ${cubicBezierEaseInOut$1} ${delay},
 margin-left ${duration} ${cubicBezierEaseInOut$1} ${delay},
 margin-right ${duration} ${cubicBezierEaseInOut$1} ${delay};
 `), c("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$1} ${delay},
 max-width ${duration} ${cubicBezierEaseInOut$1},
 margin-left ${duration} ${cubicBezierEaseInOut$1},
 margin-right ${duration} ${cubicBezierEaseInOut$1};
 `)];
    }
    const commonVars$a = {
      iconMargin: "11px 8px 0 12px",
      iconMarginRtl: "11px 12px 0 8px",
      iconSize: "24px",
      closeIconSize: "16px",
      closeSize: "20px",
      closeMargin: "13px 14px 0 0",
      closeMarginRtl: "13px 0 0 14px",
      padding: "13px"
    };
    const alertDark = {
      name: "Alert",
      common: derived$1,
      self(vars) {
        const { lineHeight: lineHeight2, borderRadius, fontWeightStrong, dividerColor, inputColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, commonVars$a), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: inputColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${changeColor(infoColorSuppl, { alpha: 0.35 })}`,
          colorInfo: changeColor(infoColorSuppl, { alpha: 0.25 }),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColorSuppl,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${changeColor(successColorSuppl, {
            alpha: 0.35
          })}`,
          colorSuccess: changeColor(successColorSuppl, { alpha: 0.25 }),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColorSuppl,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${changeColor(warningColorSuppl, {
            alpha: 0.35
          })}`,
          colorWarning: changeColor(warningColorSuppl, { alpha: 0.25 }),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColorSuppl,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${changeColor(errorColorSuppl, { alpha: 0.35 })}`,
          colorError: changeColor(errorColorSuppl, { alpha: 0.25 }),
          titleTextColorError: textColor1,
          iconColorError: errorColorSuppl,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        });
      }
    };
    const commonVars$9 = {
      linkFontSize: "13px",
      linkPadding: "0 0 0 16px",
      railWidth: "4px"
    };
    const self$N = (vars) => {
      const { borderRadius, railColor, primaryColor, primaryColorHover, primaryColorPressed, textColor2 } = vars;
      return Object.assign(Object.assign({}, commonVars$9), {
        borderRadius,
        railColor,
        railColorActive: primaryColor,
        linkColor: changeColor(primaryColor, { alpha: 0.15 }),
        linkTextColor: textColor2,
        linkTextColorHover: primaryColorHover,
        linkTextColorPressed: primaryColorPressed,
        linkTextColorActive: primaryColor
      });
    };
    const anchorDark = {
      name: "Anchor",
      common: derived$1,
      self: self$N
    };
    const isChrome = isBrowser$1 && "chrome" in window;
    isBrowser$1 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$1 && navigator.userAgent.includes("Safari") && !isChrome;
    const commonVariables$i = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };
    const inputDark = {
      name: "Input",
      common: derived$1,
      self(vars) {
        const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight: lineHeight2, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$i), {
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: inputColor,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          groupLabelTextColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: changeColor(primaryColor, { alpha: 0.1 }),
          groupLabelBorder: "1px solid #0000",
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: "1px solid #0000",
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}`,
          loadingColor: primaryColor,
          // warning
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: changeColor(warningColor, { alpha: 0.1 }),
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          caretColorWarning: warningColor,
          // error
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: changeColor(errorColor, { alpha: 0.1 }),
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      }
    };
    function self$M(vars) {
      const { boxShadow2 } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const autoCompleteDark = {
      name: "AutoComplete",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self: self$M
    };
    const self$L = (vars) => {
      const { borderRadius, avatarColor, cardColor, fontSize: fontSize2, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, modalColor, popoverColor } = vars;
      return {
        borderRadius,
        fontSize: fontSize2,
        border: `2px solid ${cardColor}`,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        color: composite(cardColor, avatarColor),
        colorModal: composite(modalColor, avatarColor),
        colorPopover: composite(popoverColor, avatarColor)
      };
    };
    const avatarDark = {
      name: "Avatar",
      common: derived$1,
      self: self$L
    };
    const self$K = () => {
      return {
        gap: "-12px"
      };
    };
    const avatarGroupDark = {
      name: "AvatarGroup",
      common: derived$1,
      peers: {
        Avatar: avatarDark
      },
      self: self$K
    };
    const commonVariables$h = {
      width: "44px",
      height: "44px",
      borderRadius: "22px",
      iconSize: "26px"
    };
    const backTopDark = {
      name: "BackTop",
      common: derived$1,
      self(vars) {
        const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
        return Object.assign(Object.assign({}, commonVariables$h), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
      }
    };
    const badgeDark = {
      name: "Badge",
      common: derived$1,
      self(vars) {
        const { errorColorSuppl, infoColorSuppl, successColorSuppl, warningColorSuppl, fontFamily: fontFamily2 } = vars;
        return {
          color: errorColorSuppl,
          colorInfo: infoColorSuppl,
          colorSuccess: successColorSuppl,
          colorError: errorColorSuppl,
          colorWarning: warningColorSuppl,
          fontSize: "12px",
          fontFamily: fontFamily2
        };
      }
    };
    const commonVariables$g = {
      fontWeightActive: "400"
    };
    const self$J = (vars) => {
      const { fontSize: fontSize2, textColor3, textColor2, borderRadius, buttonColor2Hover, buttonColor2Pressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$g), { fontSize: fontSize2, itemLineHeight: "1.25", itemTextColor: textColor3, itemTextColorHover: textColor2, itemTextColorPressed: textColor2, itemTextColorActive: textColor2, itemBorderRadius: borderRadius, itemColorHover: buttonColor2Hover, itemColorPressed: buttonColor2Pressed, separatorColor: textColor3 });
    };
    const breadcrumbDark = {
      name: "Breadcrumb",
      common: derived$1,
      self: self$J
    };
    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }
    const buttonGroupInjectionKey = createInjectionKey("n-button-group");
    const commonVariables$f = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };
    const self$I = (vars) => {
      const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$f), {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        // secondary
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        // tertiary
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        // quaternary
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        // default type
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        // primary
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        // info
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        // success
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        // warning
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        // error
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      });
    };
    const buttonLight = {
      common: derived,
      self: self$I
    };
    const buttonDark = {
      name: "Button",
      common: derived$1,
      self(vars) {
        const commonSelf = self$I(vars);
        commonSelf.waveOpacity = "0.8";
        commonSelf.colorOpacitySecondary = "0.16";
        commonSelf.colorOpacitySecondaryHover = "0.2";
        commonSelf.colorOpacitySecondaryPressed = "0.12";
        return commonSelf;
      }
    };
    const style$6 = c([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM$1("color", [cE$1("border", {
      borderColor: "var(--n-border-color)"
    }), cM$1("disabled", [cE$1("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c("&:focus", [cE$1("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c("&:hover", [cE$1("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c("&:active", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM$1("pressed", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM$1("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE$1("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE$1("state-border", {
      border: "var(--n-border-focus)"
    })]), c("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE$1("state-border", {
      border: "var(--n-border-hover)"
    })]), c("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM$1("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM$1("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM$1("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$1 && "MozBoxSizing" in document.createElement("div").style ? c("&::moz-focus-inner", {
      border: 0
    }) : null, cE$1("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE$1("border", {
      border: "var(--n-border)"
    }), cE$1("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE$1("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE$1("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c("~", [cE$1("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM$1("block", `
 display: flex;
 width: 100%;
 `), cM$1("dashed", [cE$1("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM$1("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        // don't use exact 5px since chrome will display the animation with glitches
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);
    const buttonProps = Object.assign(Object.assign({}, useTheme.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
      type: Boolean,
      default: true
    }, keyboard: {
      type: Boolean,
      default: true
    }, tag: {
      type: String,
      default: "button"
    }, type: {
      type: String,
      default: "default"
    }, dashed: Boolean, renderIcon: Function, iconPlacement: {
      type: String,
      default: "left"
    }, attrType: {
      type: String,
      default: "button"
    }, bordered: {
      type: Boolean,
      default: true
    }, onClick: [Function, Array], nativeFocusBehavior: {
      type: Boolean,
      default: !isSafari
    } });
    const Button = /* @__PURE__ */ defineComponent({
      name: "Button",
      props: buttonProps,
      setup(props) {
        const selfElRef = ref(null);
        const waveElRef = ref(null);
        const enterPressedRef = ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup = inject(buttonGroupInjectionKey, {});
        const { mergedSizeRef } = useFormItem({}, {
          defaultSize: "medium",
          mergedSize: (NFormItem2) => {
            const { size: size2 } = props;
            if (size2)
              return size2;
            const { size: buttonGroupSize } = NButtonGroup;
            if (buttonGroupSize)
              return buttonGroupSize;
            const { mergedSize: formItemSize2 } = NFormItem2 || {};
            if (formItemSize2) {
              return formItemSize2.value;
            }
            return "medium";
          }
        });
        const mergedFocusableRef = computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          var _a2;
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            (_a2 = selfElRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          }
        };
        const handleClick = (e) => {
          var _a2;
          if (!props.disabled && !props.loading) {
            const { onClick } = props;
            if (onClick)
              call(onClick, e);
            if (!props.text) {
              (_a2 = waveElRef.value) === null || _a2 === void 0 ? void 0 : _a2.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Button", "-button", style$6, buttonLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const theme = themeRef.value;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: self2 } = theme;
          const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self2;
          const size2 = mergedSizeRef.value;
          const { dashed, type, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
          const fontProps = {
            "font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type === "tertiary";
          const typeIsDefault = type === "default";
          const mergedType = typeIsTertiary ? "default" : type;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type !== "default" && type !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondary)
              }) : self2.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryPressed)
              }) : self2.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-disabled": self2.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self2.colorTertiary;
              colorProps["--n-color-hover"] = self2.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self2.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self2.colorTertiary;
            } else {
              colorProps["--n-color"] = self2.colorQuaternary;
              colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self2.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self2[createKey("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
              "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
              "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self2[createKey("border", mergedType)],
              "--n-border-hover": self2[createKey("borderHover", mergedType)],
              "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
              "--n-border-focus": self2[createKey("borderFocus", mergedType)],
              "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
            };
          }
          const { [createKey("height", size2)]: height, [createKey("fontSize", size2)]: fontSize2, [createKey("padding", size2)]: padding, [createKey("paddingRound", size2)]: paddingRound, [createKey("iconSize", size2)]: iconSize, [createKey("borderRadius", size2)]: borderRadius, [createKey("iconMargin", size2)]: iconMargin, waveOpacity } = self2;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize2,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({ "--n-bezier": cubicBezierEaseInOut2, "--n-bezier-ease-out": cubicBezierEaseOut2, "--n-ripple-duration": rippleDuration, "--n-opacity-disabled": opacityDisabled, "--n-wave-opacity": waveOpacity }, fontProps), colorProps), borderProps), sizeProps);
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
          let hash = "";
          const { dashed, type, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
          if (dashed)
            hash += "a";
          if (ghost)
            hash += "b";
          if (text)
            hash += "c";
          if (round)
            hash += "d";
          if (circle)
            hash += "e";
          if (secondary)
            hash += "f";
          if (tertiary)
            hash += "g";
          if (quaternary)
            hash += "h";
          if (strong)
            hash += "i";
          if (color)
            hash += "j" + color2Class(color);
          if (textColor)
            hash += "k" + color2Class(textColor);
          const { value: size2 } = mergedSizeRef;
          hash += "l" + size2[0];
          hash += "m" + type[0];
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: computed(() => {
            const { color } = props;
            if (!color)
              return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { mergedClsPrefix, tag: Component, onRender } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", { class: `${mergedClsPrefix}-button__content` }, children2));
        return h(
          Component,
          { ref: "selfElRef", class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
            // required for button group border collapse
          ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
          this.iconPlacement === "right" && children,
          h(NFadeInExpandTransition, { width: true }, {
            default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h(
              "span",
              { class: `${mergedClsPrefix}-button__icon`, style: {
                margin: isSlotEmpty(this.$slots.default) ? "0" : ""
              } },
              h(NIconSwitchTransition, null, {
                default: () => this.loading ? h(NBaseLoading, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 }) : h("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, this.renderIcon ? this.renderIcon() : children2)
              })
            ))
          }),
          this.iconPlacement === "left" && children,
          !this.text ? h(NBaseWave, { ref: "waveElRef", clsPrefix: mergedClsPrefix }) : null,
          this.showBorder ? h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars }) : null,
          this.showBorder ? h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars }) : null
        );
      }
    });
    const commonVariables$e = {
      titleFontSize: "22px"
    };
    const self$H = (vars) => {
      const { borderRadius, fontSize: fontSize2, lineHeight: lineHeight2, textColor2, textColor1, textColorDisabled, dividerColor, fontWeightStrong, primaryColor, baseColor, hoverColor, cardColor, modalColor, popoverColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$e), {
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        textColor: textColor2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        dayTextColor: textColorDisabled,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        dateColorCurrent: primaryColor,
        dateTextColorCurrent: baseColor,
        cellColorHover: composite(cardColor, hoverColor),
        cellColorHoverModal: composite(modalColor, hoverColor),
        cellColorHoverPopover: composite(popoverColor, hoverColor),
        cellColor: cardColor,
        cellColorModal: modalColor,
        cellColorPopover: popoverColor,
        barColor: primaryColor
      });
    };
    const calendarDark = {
      name: "Calendar",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$H
    };
    const self$G = (vars) => {
      const { fontSize: fontSize2, boxShadow2, popoverColor, textColor2, borderRadius, borderColor, heightSmall, heightMedium, heightLarge, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor } = vars;
      return {
        panelFontSize: fontSize2,
        boxShadow: boxShadow2,
        color: popoverColor,
        textColor: textColor2,
        borderRadius,
        border: `1px solid ${borderColor}`,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      };
    };
    const colorPickerDark = {
      name: "ColorPicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self: self$G
    };
    const commonVariables$d = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };
    const self$F = (vars) => {
      const { primaryColor, borderRadius, lineHeight: lineHeight2, fontSize: fontSize2, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$d), {
        lineHeight: lineHeight2,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        colorEmbeddedModal: actionColor,
        colorEmbeddedPopover: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize2,
        fontSizeMedium: fontSize2,
        fontSizeLarge: fontSize2,
        fontSizeHuge: fontSize2,
        boxShadow: boxShadow1,
        borderRadius
      });
    };
    const cardDark = {
      name: "Card",
      common: derived$1,
      self(vars) {
        const commonSelf = self$F(vars);
        const { cardColor, modalColor, popoverColor } = vars;
        commonSelf.colorEmbedded = cardColor;
        commonSelf.colorEmbeddedModal = modalColor;
        commonSelf.colorEmbeddedPopover = popoverColor;
        return commonSelf;
      }
    };
    const self$E = (vars) => {
      return {
        dotSize: "8px",
        dotColor: "rgba(255, 255, 255, .3)",
        dotColorActive: "rgba(255, 255, 255, 1)",
        dotColorFocus: "rgba(255, 255, 255, .5)",
        dotLineWidth: "16px",
        dotLineWidthActive: "24px",
        arrowColor: "#eee"
      };
    };
    const carouselDark = {
      name: "Carousel",
      common: derived$1,
      self: self$E
    };
    const commonVariables$c = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const self$D = (vars) => {
      const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall, lineHeight: lineHeight2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), {
        labelLineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
        textColor: textColor2,
        textColorDisabled
      });
    };
    const checkboxDark = {
      name: "Checkbox",
      common: derived$1,
      self(vars) {
        const { cardColor } = vars;
        const commonSelf = self$D(vars);
        commonSelf.color = "#0000";
        commonSelf.checkMarkColor = cardColor;
        return commonSelf;
      }
    };
    const self$C = (vars) => {
      const { borderRadius, boxShadow2, popoverColor, textColor2, textColor3, primaryColor, textColorDisabled, dividerColor, hoverColor, fontSizeMedium, heightMedium } = vars;
      return {
        menuBorderRadius: borderRadius,
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuDividerColor: dividerColor,
        menuHeight: "calc(var(--n-option-height) * 6.6)",
        optionArrowColor: textColor3,
        optionHeight: heightMedium,
        optionFontSize: fontSizeMedium,
        optionColorHover: hoverColor,
        optionTextColor: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorDisabled: textColorDisabled,
        optionCheckMarkColor: primaryColor,
        loadingColor: primaryColor,
        columnWidth: "180px"
      };
    };
    const cascaderDark = {
      name: "Cascader",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        InternalSelection: internalSelectionDark,
        Scrollbar: scrollbarDark,
        Checkbox: checkboxDark,
        Empty: emptyLight
      },
      self: self$C
    };
    const codeDark = {
      name: "Code",
      common: derived$1,
      self(vars) {
        const { textColor2, fontSize: fontSize2, fontWeightStrong, textColor3 } = vars;
        return {
          textColor: textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          // extracted from hljs atom-one-dark.scss
          "mono-3": "#5c6370",
          "hue-1": "#56b6c2",
          "hue-2": "#61aeee",
          "hue-3": "#c678dd",
          "hue-4": "#98c379",
          "hue-5": "#e06c75",
          "hue-5-2": "#be5046",
          "hue-6": "#d19a66",
          "hue-6-2": "#e6c07b",
          // line-number styles
          lineNumberTextColor: textColor3
        };
      }
    };
    const self$B = (vars) => {
      const { fontWeight, textColor1, textColor2, textColorDisabled, dividerColor, fontSize: fontSize2 } = vars;
      return {
        titleFontSize: fontSize2,
        titleFontWeight: fontWeight,
        dividerColor,
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        fontSize: fontSize2,
        textColor: textColor2,
        arrowColor: textColor2,
        arrowColorDisabled: textColorDisabled,
        itemMargin: "16px 0 0 0",
        titlePadding: "16px 0 0 0"
      };
    };
    const collapseDark = {
      name: "Collapse",
      common: derived$1,
      self: self$B
    };
    const self$A = (vars) => {
      const { cubicBezierEaseInOut: cubicBezierEaseInOut2 } = vars;
      return {
        bezier: cubicBezierEaseInOut2
      };
    };
    const collapseTransitionDark = {
      name: "CollapseTransition",
      common: derived$1,
      self: self$A
    };
    const configProviderProps = {
      abstract: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: { type: String, default: defaultClsPrefix },
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
        type: String,
        default: "div"
      },
      hljs: Object,
      katex: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      inlineThemeDisabled: {
        type: Boolean,
        default: void 0
      },
      // deprecated
      as: {
        type: String,
        validator: () => {
          warn$2("config-provider", "`as` is deprecated, please use `tag` instead.");
          return true;
        },
        default: void 0
      }
    };
    const NConfigProvider = /* @__PURE__ */ defineComponent({
      name: "ConfigProvider",
      alias: ["App"],
      props: configProviderProps,
      setup(props) {
        const NConfigProvider2 = inject(configProviderInjectionKey, null);
        const mergedThemeRef = computed(() => {
          const { theme } = props;
          if (theme === null)
            return void 0;
          const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
          return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = computed(() => {
          const { themeOverrides } = props;
          if (themeOverrides === null)
            return void 0;
          if (themeOverrides === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
          } else {
            const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            if (inheritedThemeOverrides === void 0) {
              return themeOverrides;
            } else {
              return merge({}, inheritedThemeOverrides, themeOverrides);
            }
          }
        });
        const mergedNamespaceRef = useMemo(() => {
          const { namespace: namespace2 } = props;
          return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
        });
        const mergedBorderedRef = useMemo(() => {
          const { bordered } = props;
          return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
        });
        const mergedIconsRef = computed(() => {
          const { icons } = props;
          return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = computed(() => {
          const { componentOptions } = props;
          if (componentOptions !== void 0)
            return componentOptions;
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = computed(() => {
          const { clsPrefix } = props;
          if (clsPrefix !== void 0)
            return clsPrefix;
          if (NConfigProvider2)
            return NConfigProvider2.mergedClsPrefixRef.value;
          return defaultClsPrefix;
        });
        const mergedRtlRef = computed(() => {
          var _a2;
          const { rtl } = props;
          if (rtl === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
          }
          const rtlEnabledState = {};
          for (const rtlInfo of rtl) {
            rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
            (_a2 = rtlInfo.peers) === null || _a2 === void 0 ? void 0 : _a2.forEach((peerRtlInfo) => {
              if (!(peerRtlInfo.name in rtlEnabledState)) {
                rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
              }
            });
          }
          return rtlEnabledState;
        });
        const mergedBreakpointsRef = computed(() => {
          return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
        });
        const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
        const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
        const mergedThemeHashRef = computed(() => {
          const { value: theme } = mergedThemeRef;
          const { value: mergedThemeOverrides } = mergedThemeOverridesRef;
          const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
          const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
          if (themeName) {
            if (hasThemeOverrides) {
              return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
            }
            return themeName;
          } else {
            if (hasThemeOverrides) {
              return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
            }
            return "";
          }
        });
        provide(configProviderInjectionKey, {
          mergedThemeHashRef,
          mergedBreakpointsRef,
          mergedRtlRef,
          mergedIconsRef,
          mergedComponentPropsRef,
          mergedBorderedRef,
          mergedNamespaceRef,
          mergedClsPrefixRef,
          mergedLocaleRef: computed(() => {
            const { locale } = props;
            if (locale === null)
              return void 0;
            return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
          }),
          mergedDateLocaleRef: computed(() => {
            const { dateLocale } = props;
            if (dateLocale === null)
              return void 0;
            return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
          }),
          mergedHljsRef: computed(() => {
            const { hljs } = props;
            return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
          }),
          mergedKatexRef: computed(() => {
            const { katex } = props;
            return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
          }),
          mergedThemeRef,
          mergedThemeOverridesRef,
          inlineThemeDisabled: inlineThemeDisabled || false,
          preflightStyleDisabled: preflightStyleDisabled || false
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedNamespace: mergedNamespaceRef,
          mergedTheme: mergedThemeRef,
          mergedThemeOverrides: mergedThemeOverridesRef
        };
      },
      render() {
        var _a2, _b2, _c2, _d2;
        return !this.abstract ? h(this.as || this.tag, {
          class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
        }, (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) : (_d2 = (_c2 = this.$slots).default) === null || _d2 === void 0 ? void 0 : _d2.call(_c2);
      }
    });
    const popselect = {
      name: "Popselect",
      common: derived$1,
      peers: {
        Popover: popoverDark,
        InternalSelectMenu: internalSelectMenuDark
      }
    };
    function self$z(vars) {
      const { boxShadow2 } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectDark = {
      name: "Select",
      common: derived$1,
      peers: {
        InternalSelection: internalSelectionDark,
        InternalSelectMenu: internalSelectMenuDark
      },
      self: self$z
    };
    const commonVariables$b = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };
    const self$y = (vars) => {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        // item font size
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        // item size
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), { buttonColor: "#0000", buttonColorHover: "#0000", buttonColorPressed: "#0000", buttonBorder: `1px solid ${borderColor}`, buttonBorderHover: `1px solid ${borderColor}`, buttonBorderPressed: `1px solid ${borderColor}`, buttonIconColor: textColor2, buttonIconColorHover: textColor2, buttonIconColorPressed: textColor2, itemTextColor: textColor2, itemTextColorHover: primaryColorHover, itemTextColorPressed: primaryColorPressed, itemTextColorActive: primaryColor, itemTextColorDisabled: textColorDisabled, itemColor: "#0000", itemColorHover: "#0000", itemColorPressed: "#0000", itemColorActive: "#0000", itemColorActiveHover: "#0000", itemColorDisabled: inputColorDisabled, itemBorder: "1px solid #0000", itemBorderHover: "1px solid #0000", itemBorderPressed: "1px solid #0000", itemBorderActive: `1px solid ${primaryColor}`, itemBorderDisabled: `1px solid ${borderColor}`, itemBorderRadius: borderRadius, itemSizeSmall: heightTiny, itemSizeMedium: heightSmall, itemSizeLarge: heightMedium, itemFontSizeSmall: fontSizeTiny, itemFontSizeMedium: fontSizeSmall, itemFontSizeLarge: fontSizeMedium, jumperFontSizeSmall: fontSizeTiny, jumperFontSizeMedium: fontSizeSmall, jumperFontSizeLarge: fontSizeMedium, jumperTextColor: textColor2, jumperTextColorDisabled: textColorDisabled });
    };
    const paginationDark = {
      name: "Pagination",
      common: derived$1,
      peers: {
        Select: selectDark,
        Input: inputDark,
        Popselect: popselect
      },
      self(vars) {
        const { primaryColor, opacity3 } = vars;
        const borderColorActive = changeColor(primaryColor, {
          alpha: Number(opacity3)
        });
        const commonSelf = self$y(vars);
        commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
        commonSelf.itemBorderDisabled = "1px solid #0000";
        return commonSelf;
      }
    };
    const commonVars$8 = {
      padding: "8px 14px"
    };
    const tooltipDark = {
      name: "Tooltip",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const { borderRadius, boxShadow2, popoverColor, textColor2 } = vars;
        return Object.assign(Object.assign({}, commonVars$8), { borderRadius, boxShadow: boxShadow2, color: popoverColor, textColor: textColor2 });
      }
    };
    const ellipsisDark = {
      name: "Ellipsis",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      }
    };
    const commonVariables$a = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const radioDark = {
      name: "Radio",
      common: derived$1,
      self(vars) {
        const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight2 } = vars;
        return Object.assign(Object.assign({}, commonVariables$a), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: "#0000",
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: primaryColor,
          buttonColor: "#0000",
          buttonColorActive: primaryColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: baseColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
          buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      }
    };
    const self$x = (vars) => {
      const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight: lineHeight2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), {
        labelLineHeight: lineHeight2,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        colorActive: "#0000",
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      });
    };
    const radioLight = {
      common: derived,
      self: self$x
    };
    const commonVariables$9 = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };
    const self$w = (vars) => {
      const { primaryColor, textColor2, dividerColor, hoverColor, popoverColor, invertedColor, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge, textColor3, opacityDisabled } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), {
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        // non-inverted
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, { alpha: 0.1 }),
        groupHeaderTextColor: textColor3,
        // inverted
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      });
    };
    const dropdownDark = {
      name: "Dropdown",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const { primaryColorSuppl, primaryColor, popoverColor } = vars;
        const commonSelf = self$w(vars);
        commonSelf.colorInverted = popoverColor;
        commonSelf.optionColorActive = changeColor(primaryColor, { alpha: 0.15 });
        commonSelf.optionColorActiveInverted = primaryColorSuppl;
        commonSelf.optionColorHoverInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const commonVariables$8 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      resizableContainerSize: "8px",
      resizableSize: "2px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };
    const self$v = (vars) => {
      const { cardColor, modalColor, popoverColor, textColor2, textColor1, tableHeaderColor, tableColorHover, iconColor, primaryColor, fontWeightStrong, borderRadius, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor, heightSmall, opacityDisabled, tableColorStriped } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), {
        actionDividerColor: dividerColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        // modal
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        // popover
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        // loading
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      });
    };
    const dataTableDark = {
      name: "DataTable",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Checkbox: checkboxDark,
        Radio: radioDark,
        Pagination: paginationDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark,
        Popover: popoverDark,
        Ellipsis: ellipsisDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const commonSelf = self$v(vars);
        commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
        commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
        return commonSelf;
      }
    };
    const radioBaseProps = {
      name: String,
      value: {
        type: [String, Number, Boolean],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      // deprecated
      checkedValue: {
        type: Boolean,
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");
    function setup(props) {
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const { size: size2 } = props;
          if (size2 !== void 0)
            return size2;
          if (NRadioGroup2) {
            const { mergedSizeRef: { value: mergedSize } } = NRadioGroup2;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            return NFormItem2.mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          if (props.disabled)
            return true;
          if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value)
            return true;
          if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value)
            return true;
          return false;
        }
      });
      const { mergedSizeRef, mergedDisabledRef } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const NRadioGroup2 = inject(radioGroupInjectionKey, null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup2)
          return NRadioGroup2.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const { name } = props;
        if (name !== void 0)
          return name;
        if (NRadioGroup2)
          return NRadioGroup2.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
        if (NRadioGroup2) {
          const { doUpdateValue } = NRadioGroup2;
          const { value } = props;
          call(doUpdateValue, value);
        } else {
          const { onUpdateChecked, "onUpdate:checked": _onUpdateChecked } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (onUpdateChecked)
            call(onUpdateChecked, true);
          if (_onUpdateChecked)
            call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }
      function toggle() {
        if (mergedDisabledRef.value)
          return;
        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }
      function handleRadioInputChange() {
        toggle();
      }
      function handleRadioInputBlur() {
        focusRef.value = false;
      }
      function handleRadioInputFocus() {
        focusRef.value = true;
      }
      return {
        mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        uncontrolledChecked: uncontrolledCheckedRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }
    const style$5 = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM$1("checked", [cE$1("dot", `
 background-color: var(--n-color-active);
 `)]), cE$1("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE$1("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM$1("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE$1("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM$1("disabled", `
 cursor: not-allowed;
 `, [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM$1("checked", `
 opacity: 1;
 `)]), cE$1("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
    const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
    const NRadio = /* @__PURE__ */ defineComponent({
      name: "Radio",
      props: radioProps,
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme("Radio", "-radio", style$5, radioLight, props, radio.mergedClsPrefix);
        const cssVarsRef = computed(() => {
          const { mergedSize: { value: size2 } } = radio;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { boxShadow, boxShadowActive, boxShadowDisabled, boxShadowFocus, boxShadowHover, color, colorDisabled, colorActive, textColor, textColorDisabled, dotColorActive, dotColorDisabled, labelPadding, labelLineHeight, labelFontWeight, [createKey("fontSize", size2)]: fontSize2, [createKey("radioSize", size2)]: radioSize } } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize2,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const { $slots, mergedClsPrefix, onRender, label } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h(
          "label",
          { class: [
            `${mergedClsPrefix}-radio`,
            this.themeClass,
            {
              [`${mergedClsPrefix}-radio--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
              [`${mergedClsPrefix}-radio--focus`]: this.focus
            }
          ], style: this.cssVars },
          h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
          h(
            "div",
            { class: `${mergedClsPrefix}-radio__dot-wrapper` },
            "",
            h("div", { class: [
              `${mergedClsPrefix}-radio__dot`,
              this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
            ] })
          ),
          resolveWrappedSlot($slots.default, (children) => {
            if (!children && !label)
              return null;
            return h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || label);
          })
        );
      }
    });
    const style$4 = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE$1("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM$1("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM$1("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM$1("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE$1("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE$1("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM$1("focus", [c("&:not(:active)", [cE$1("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM$1("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM$1("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
    function mapSlot(defaultSlot, value, clsPrefix) {
      var _a2;
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
        const wrappedInstance = defaultSlot[i];
        const name = (_a2 = wrappedInstance.type) === null || _a2 === void 0 ? void 0 : _a2.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(h("div", { class: [`${clsPrefix}-radio-group__splitor`, splitorClass] }), wrappedInstance);
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), { name: String, value: [String, Number, Boolean], defaultValue: {
      type: [String, Number, Boolean],
      default: null
    }, size: String, disabled: {
      type: Boolean,
      default: void 0
    }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] });
    const NRadioGroup = /* @__PURE__ */ defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = ref(null);
        const { mergedSizeRef, mergedDisabledRef, nTriggerFormChange, nTriggerFormInput, nTriggerFormBlur, nTriggerFormFocus } = useFormItem(props);
        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Radio", "-radio-group", style$4, radioLight, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
          const { onUpdateValue, "onUpdate:value": _onUpdateValue } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const { value: selfEl } = selfElRef;
          if (!selfEl)
            return;
          if (selfEl.contains(e.relatedTarget))
            return;
          nTriggerFormBlur();
        }
        provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const { value: size2 } = mergedSizeRef;
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { buttonBorderColor, buttonBorderColorActive, buttonBorderRadius, buttonBoxShadow, buttonBoxShadowFocus, buttonBoxShadowHover, buttonColorActive, buttonTextColor, buttonTextColorActive, buttonTextColorHover, opacityDisabled, [createKey("buttonHeight", size2)]: height, [createKey("fontSize", size2)]: fontSize2 } } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a2;
        const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
        const { children, isButtonGroup } = mapSlot(flatten(getSlot$1(this)), mergedValue, mergedClsPrefix);
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        return h("div", { onFocusin: handleFocusin, onFocusout: handleFocusout, ref: "selfElRef", class: [
          `${mergedClsPrefix}-radio-group`,
          this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`,
          this.themeClass,
          isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
        ], style: this.cssVars }, children);
      }
    });
    const self$u = (vars) => {
      const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    };
    const iconDark$1 = {
      name: "Icon",
      common: derived$1,
      self: self$u
    };
    const commonVars$7 = {
      itemFontSize: "12px",
      itemHeight: "36px",
      itemWidth: "52px",
      panelActionPadding: "8px 0"
    };
    const self$t = (vars) => {
      const { popoverColor, textColor2, primaryColor, hoverColor, dividerColor, opacityDisabled, boxShadow2, borderRadius, iconColor, iconColorDisabled } = vars;
      return Object.assign(Object.assign({}, commonVars$7), {
        panelColor: popoverColor,
        panelBoxShadow: boxShadow2,
        panelDividerColor: dividerColor,
        itemTextColor: textColor2,
        itemTextColorActive: primaryColor,
        itemColorHover: hoverColor,
        itemOpacityDisabled: opacityDisabled,
        itemBorderRadius: borderRadius,
        borderRadius,
        iconColor,
        iconColorDisabled
      });
    };
    const timePickerDark = {
      name: "TimePicker",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Button: buttonDark,
        Input: inputDark
      },
      self: self$t
    };
    const commonVars$6 = {
      itemSize: "24px",
      itemCellWidth: "38px",
      itemCellHeight: "32px",
      scrollItemWidth: "80px",
      scrollItemHeight: "40px",
      panelExtraFooterPadding: "8px 12px",
      panelActionPadding: "8px 12px",
      calendarTitlePadding: "0",
      calendarTitleHeight: "28px",
      arrowSize: "14px",
      panelHeaderPadding: "8px 12px",
      calendarDaysHeight: "32px",
      calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
      // type
      calendarLeftPaddingDate: "6px 12px 4px 12px",
      calendarLeftPaddingDatetime: "4px 12px",
      calendarLeftPaddingDaterange: "6px 12px 4px 12px",
      calendarLeftPaddingDatetimerange: "4px 12px",
      calendarLeftPaddingMonth: "0",
      calendarLeftPaddingYear: "0",
      calendarLeftPaddingQuarter: "0",
      calendarLeftPaddingMonthrange: "0",
      calendarLeftPaddingQuarterrange: "0",
      calendarLeftPaddingYearrange: "0",
      calendarRightPaddingDate: "6px 12px 4px 12px",
      calendarRightPaddingDatetime: "4px 12px",
      calendarRightPaddingDaterange: "6px 12px 4px 12px",
      calendarRightPaddingDatetimerange: "4px 12px",
      calendarRightPaddingMonth: "0",
      calendarRightPaddingYear: "0",
      calendarRightPaddingQuarter: "0",
      calendarRightPaddingMonthrange: "0",
      calendarRightPaddingQuarterrange: "0",
      calendarRightPaddingYearrange: "0"
    };
    const self$s = (vars) => {
      const { hoverColor, fontSize: fontSize2, textColor2, textColorDisabled, popoverColor, primaryColor, borderRadiusSmall, iconColor, iconColorDisabled, textColor1, dividerColor, boxShadow2, borderRadius, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVars$6), {
        itemFontSize: fontSize2,
        calendarDaysFontSize: fontSize2,
        calendarTitleFontSize: fontSize2,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemTextColorActive: popoverColor,
        itemTextColorCurrent: primaryColor,
        itemColorIncluded: changeColor(primaryColor, { alpha: 0.1 }),
        itemColorHover: hoverColor,
        itemColorDisabled: hoverColor,
        itemColorActive: primaryColor,
        itemBorderRadius: borderRadiusSmall,
        panelColor: popoverColor,
        panelTextColor: textColor2,
        arrowColor: iconColor,
        calendarTitleTextColor: textColor1,
        calendarTitleColorHover: hoverColor,
        calendarDaysTextColor: textColor2,
        panelHeaderDividerColor: dividerColor,
        calendarDaysDividerColor: dividerColor,
        calendarDividerColor: dividerColor,
        panelActionDividerColor: dividerColor,
        panelBoxShadow: boxShadow2,
        panelBorderRadius: borderRadius,
        calendarTitleFontWeight: fontWeightStrong,
        scrollItemBorderRadius: borderRadius,
        iconColor,
        iconColorDisabled
      });
    };
    const datePickerDark = {
      name: "DatePicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        TimePicker: timePickerDark,
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const { popoverColor, hoverColor, primaryColor } = vars;
        const commonSelf = self$s(vars);
        commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
        commonSelf.itemColorIncluded = changeColor(primaryColor, { alpha: 0.15 });
        commonSelf.itemColorHover = composite(popoverColor, hoverColor);
        return commonSelf;
      }
    };
    const commonVariables$7 = {
      thPaddingBorderedSmall: "8px 12px",
      thPaddingBorderedMedium: "12px 16px",
      thPaddingBorderedLarge: "16px 24px",
      thPaddingSmall: "0",
      thPaddingMedium: "0",
      thPaddingLarge: "0",
      tdPaddingBorderedSmall: "8px 12px",
      tdPaddingBorderedMedium: "12px 16px",
      tdPaddingBorderedLarge: "16px 24px",
      tdPaddingSmall: "0 0 8px 0",
      tdPaddingMedium: "0 0 12px 0",
      tdPaddingLarge: "0 0 16px 0"
    };
    const self$r = (vars) => {
      const { tableHeaderColor, textColor2, textColor1, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), {
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        titleTextColor: textColor1,
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        tdTextColor: textColor2,
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius
      });
    };
    const descriptionsDark = {
      name: "Descriptions",
      common: derived$1,
      self: self$r
    };
    const commonVars$5 = {
      titleFontSize: "18px",
      padding: "16px 28px 20px 28px",
      iconSize: "28px",
      actionSpace: "12px",
      contentMargin: "8px 0 16px 0",
      iconMargin: "0 4px 0 0",
      iconMarginIconTop: "4px 0 8px 0",
      closeSize: "22px",
      closeIconSize: "18px",
      closeMargin: "20px 26px 0 0",
      closeMarginIconTop: "10px 16px 0 0"
    };
    const self$q = (vars) => {
      const { textColor1, textColor2, modalColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, infoColor, successColor, warningColor, errorColor, primaryColor, dividerColor, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSize: fontSize2 } = vars;
      return Object.assign(Object.assign({}, commonVars$5), {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        border: `1px solid ${dividerColor}`,
        titleTextColor: textColor1,
        textColor: textColor2,
        color: modalColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        iconColor: primaryColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        borderRadius,
        titleFontWeight: fontWeightStrong
      });
    };
    const dialogDark = {
      name: "Dialog",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$q
    };
    const self$p = (vars) => {
      const { modalColor, textColor2, boxShadow3 } = vars;
      return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
      };
    };
    const modalDark = {
      name: "Modal",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Dialog: dialogDark,
        Card: cardDark
      },
      self: self$p
    };
    const self$o = (vars) => {
      const { textColor1, dividerColor, fontWeightStrong } = vars;
      return {
        textColor: textColor1,
        color: dividerColor,
        fontWeight: fontWeightStrong
      };
    };
    const dividerDark = {
      name: "Divider",
      common: derived$1,
      self: self$o
    };
    const self$n = (vars) => {
      const { modalColor, textColor1, textColor2, boxShadow3, lineHeight: lineHeight2, fontWeightStrong, dividerColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadius, primaryColorHover } = vars;
      return {
        bodyPadding: "16px 24px",
        headerPadding: "16px 24px",
        footerPadding: "16px 24px",
        color: modalColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        titleFontSize: "18px",
        titleFontWeight: fontWeightStrong,
        boxShadow: boxShadow3,
        lineHeight: lineHeight2,
        headerBorderBottom: `1px solid ${dividerColor}`,
        footerBorderTop: `1px solid ${dividerColor}`,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeSize: "22px",
        closeIconSize: "18px",
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        resizableTriggerColorHover: primaryColorHover
      };
    };
    const drawerLight = createTheme({
      name: "Drawer",
      common: derived,
      peers: {
        Scrollbar: scrollbarLight
      },
      self: self$n
    });
    const drawerDark = {
      name: "Drawer",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$n
    };
    const NDrawerBodyWrapper = /* @__PURE__ */ defineComponent({
      name: "NDrawerContent",
      inheritAttrs: false,
      props: {
        blockScroll: Boolean,
        show: {
          type: Boolean,
          default: void 0
        },
        displayDirective: {
          type: String,
          required: true
        },
        placement: {
          type: String,
          required: true
        },
        contentStyle: [Object, String],
        nativeScrollbar: {
          type: Boolean,
          required: true
        },
        scrollbarProps: Object,
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          required: true
        },
        maxWidth: Number,
        maxHeight: Number,
        minWidth: Number,
        minHeight: Number,
        resizable: Boolean,
        onClickoutside: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const displayedRef = ref(!!props.show);
        const bodyRef = ref(null);
        const NDrawer2 = inject(drawerInjectionKey);
        let startPosition = 0;
        let memoizedBodyStyleCursor = "";
        let hoverTimerId = null;
        const isHoverOnResizeTriggerRef = ref(false);
        const isDraggingRef = ref(false);
        const isVertical = computed(() => {
          return props.placement === "top" || props.placement === "bottom";
        });
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
        const handleMousedownResizeTrigger = (e) => {
          isDraggingRef.value = true;
          startPosition = isVertical.value ? e.clientY : e.clientX;
          memoizedBodyStyleCursor = document.body.style.cursor;
          document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
          document.body.addEventListener("mousemove", handleBodyMousemove);
          document.body.addEventListener("mouseleave", handleBodyMouseleave);
          document.body.addEventListener("mouseup", handleBodyMouseup);
        };
        const handleMouseenterResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          if (isDraggingRef.value) {
            isHoverOnResizeTriggerRef.value = true;
          } else {
            hoverTimerId = window.setTimeout(() => {
              isHoverOnResizeTriggerRef.value = true;
            }, 300);
          }
        };
        const handleMouseleaveResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          isHoverOnResizeTriggerRef.value = false;
        };
        const { doUpdateHeight, doUpdateWidth } = NDrawer2;
        const regulateWidth = (size2) => {
          const { maxWidth } = props;
          if (maxWidth && size2 > maxWidth)
            return maxWidth;
          const { minWidth } = props;
          if (minWidth && size2 < minWidth)
            return minWidth;
          return size2;
        };
        const regulateHeight = (size2) => {
          const { maxHeight } = props;
          if (maxHeight && size2 > maxHeight)
            return maxHeight;
          const { minHeight } = props;
          if (minHeight && size2 < minHeight)
            return minHeight;
          return size2;
        };
        const handleBodyMousemove = (e) => {
          var _a2, _b2;
          if (isDraggingRef.value) {
            if (isVertical.value) {
              let height = ((_a2 = bodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
              const increment = startPosition - e.clientY;
              height += props.placement === "bottom" ? increment : -increment;
              height = regulateHeight(height);
              doUpdateHeight(height);
              startPosition = e.clientY;
            } else {
              let width = ((_b2 = bodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.offsetWidth) || 0;
              const increment = startPosition - e.clientX;
              width += props.placement === "right" ? increment : -increment;
              width = regulateWidth(width);
              doUpdateWidth(width);
              startPosition = e.clientX;
            }
          }
        };
        const handleBodyMouseup = () => {
          if (isDraggingRef.value) {
            startPosition = 0;
            isDraggingRef.value = false;
            document.body.style.cursor = memoizedBodyStyleCursor;
            document.body.removeEventListener("mousemove", handleBodyMousemove);
            document.body.removeEventListener("mouseup", handleBodyMouseup);
            document.body.removeEventListener("mouseleave", handleBodyMouseleave);
          }
        };
        const handleBodyMouseleave = handleBodyMouseup;
        watchEffect(() => {
          if (props.show)
            displayedRef.value = true;
        });
        watch(() => props.show, (value) => {
          if (!value) {
            handleBodyMouseup();
          }
        });
        onBeforeUnmount(() => {
          handleBodyMouseup();
        });
        const bodyDirectivesRef = computed(() => {
          const { show } = props;
          const directives = [[vShow, show]];
          if (!props.showMask) {
            directives.push([
              clickoutside,
              props.onClickoutside,
              void 0,
              { capture: true }
            ]);
          }
          return directives;
        });
        function handleAfterLeave() {
          var _a2;
          displayedRef.value = false;
          (_a2 = props.onAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
        provide(drawerBodyInjectionKey, bodyRef);
        provide(popoverBodyInjectionKey, null);
        provide(modalBodyInjectionKey, null);
        return {
          bodyRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef,
          isMounted: NDrawer2.isMountedRef,
          mergedTheme: NDrawer2.mergedThemeRef,
          displayed: displayedRef,
          transitionName: computed(() => {
            return {
              right: "slide-in-from-right-transition",
              left: "slide-in-from-left-transition",
              top: "slide-in-from-top-transition",
              bottom: "slide-in-from-bottom-transition"
            }[props.placement];
          }),
          handleAfterLeave,
          bodyDirectives: bodyDirectivesRef,
          handleMousedownResizeTrigger,
          handleMouseenterResizeTrigger,
          handleMouseleaveResizeTrigger,
          isDragging: isDraggingRef,
          isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
        };
      },
      render() {
        const { $slots, mergedClsPrefix } = this;
        return this.displayDirective === "show" || this.displayed || this.show ? withDirectives(
          /* Keep the wrapper dom. Make sure the drawer has a host.
          Nor the detached content will disappear without transition */
          h(
            "div",
            { role: "none" },
            h(FocusTrap, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, {
              default: () => h(Transition, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, {
                default: () => withDirectives(h("div", mergeProps(this.$attrs, {
                  role: "dialog",
                  ref: "bodyRef",
                  "aria-modal": "true",
                  class: [
                    `${mergedClsPrefix}-drawer`,
                    this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                    `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                    /**
                     * When the mouse is pressed to resize the drawer,
                     * disable text selection
                     */
                    this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                    this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                  ]
                }), [
                  this.resizable ? h("div", { class: [
                    `${mergedClsPrefix}-drawer__resize-trigger`,
                    (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`
                  ], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null,
                  this.nativeScrollbar ? h("div", { class: `${mergedClsPrefix}-drawer-content-wrapper`, style: this.contentStyle, role: "none" }, $slots) : h(Scrollbar, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: `${mergedClsPrefix}-drawer-content-wrapper`, theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), $slots)
                ]), this.bodyDirectives)
              })
            })
          ),
          [
            [
              vShow,
              this.displayDirective === "if" || this.displayed || this.show
            ]
          ]
        ) : null;
      }
    });
    const { cubicBezierEaseIn: cubicBezierEaseIn$3, cubicBezierEaseOut: cubicBezierEaseOut$3 } = commonVariables$m;
    function slideInFromRightTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-right" } = {}) {
      return [
        c(`&.${name}-transition-leave-active`, {
          transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
        }),
        c(`&.${name}-transition-enter-active`, {
          transition: `transform ${duration} ${cubicBezierEaseOut$3}`
        }),
        c(`&.${name}-transition-enter-to`, {
          transform: "translateX(0)"
        }),
        c(`&.${name}-transition-enter-from`, {
          transform: "translateX(100%)"
        }),
        c(`&.${name}-transition-leave-from`, {
          transform: "translateX(0)"
        }),
        c(`&.${name}-transition-leave-to`, {
          transform: "translateX(100%)"
        })
      ];
    }
    const { cubicBezierEaseIn: cubicBezierEaseIn$2, cubicBezierEaseOut: cubicBezierEaseOut$2 } = commonVariables$m;
    function slideInFromLeftTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-left" } = {}) {
      return [
        c(`&.${name}-transition-leave-active`, {
          transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
        }),
        c(`&.${name}-transition-enter-active`, {
          transition: `transform ${duration} ${cubicBezierEaseOut$2}`
        }),
        c(`&.${name}-transition-enter-to`, {
          transform: "translateX(0)"
        }),
        c(`&.${name}-transition-enter-from`, {
          transform: "translateX(-100%)"
        }),
        c(`&.${name}-transition-leave-from`, {
          transform: "translateX(0)"
        }),
        c(`&.${name}-transition-leave-to`, {
          transform: "translateX(-100%)"
        })
      ];
    }
    const { cubicBezierEaseIn: cubicBezierEaseIn$1, cubicBezierEaseOut: cubicBezierEaseOut$1 } = commonVariables$m;
    function slideInFromTopTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-top" } = {}) {
      return [
        c(`&.${name}-transition-leave-active`, {
          transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
        }),
        c(`&.${name}-transition-enter-active`, {
          transition: `transform ${duration} ${cubicBezierEaseOut$1}`
        }),
        c(`&.${name}-transition-enter-to`, {
          transform: "translateY(0)"
        }),
        c(`&.${name}-transition-enter-from`, {
          transform: "translateY(-100%)"
        }),
        c(`&.${name}-transition-leave-from`, {
          transform: "translateY(0)"
        }),
        c(`&.${name}-transition-leave-to`, {
          transform: "translateY(-100%)"
        })
      ];
    }
    const { cubicBezierEaseIn, cubicBezierEaseOut } = commonVariables$m;
    function slideInFromBottomTransition({ duration = "0.3s", leaveDuration = "0.2s", name = "slide-in-from-bottom" } = {}) {
      return [
        c(`&.${name}-transition-leave-active`, {
          transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
        }),
        c(`&.${name}-transition-enter-active`, {
          transition: `transform ${duration} ${cubicBezierEaseOut}`
        }),
        c(`&.${name}-transition-enter-to`, {
          transform: "translateY(0)"
        }),
        c(`&.${name}-transition-enter-from`, {
          transform: "translateY(100%)"
        }),
        c(`&.${name}-transition-leave-from`, {
          transform: "translateY(0)"
        }),
        c(`&.${name}-transition-leave-to`, {
          transform: "translateY(100%)"
        })
      ];
    }
    const style$3 = c([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM$1("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM$1("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE$1("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM$1("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM$1("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE$1("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM$1("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM$1("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM$1("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM$1("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c("body", [c(">", [cB("drawer-container", {
      position: "fixed"
    })])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c("> *", {
      pointerEvents: "all"
    })]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM$1("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
      enterDuration: "0.2s",
      leaveDuration: "0.2s",
      enterCubicBezier: "var(--n-bezier-in)",
      leaveCubicBezier: "var(--n-bezier-out)"
    })])]);
    const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
      show: Boolean,
      width: [Number, String],
      height: [Number, String],
      placement: {
        type: String,
        default: "right"
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        default: true
      },
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      onMaskClick: Function,
      scrollbarProps: Object,
      contentStyle: [Object, String],
      trapFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: {
        type: Boolean,
        default: true
      },
      maxWidth: Number,
      maxHeight: Number,
      minWidth: Number,
      minHeight: Number,
      resizable: Boolean,
      defaultWidth: {
        type: [Number, String],
        default: 251
      },
      defaultHeight: {
        type: [Number, String],
        default: 251
      },
      onUpdateWidth: [Function, Array],
      onUpdateHeight: [Function, Array],
      "onUpdate:width": [Function, Array],
      "onUpdate:height": [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      /** @deprecated */
      drawerStyle: [String, Object],
      drawerClass: String,
      target: null,
      onShow: Function,
      onHide: Function
    });
    const NDrawer = /* @__PURE__ */ defineComponent({
      name: "Drawer",
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
        const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
        const isMountedRef = isMounted();
        const themeRef = useTheme("Drawer", "-drawer", style$3, drawerLight, props, mergedClsPrefixRef);
        const uncontrolledWidthRef = ref(props.defaultWidth);
        const uncontrolledHeightRef = ref(props.defaultHeight);
        const mergedWidthRef = useMergedState(toRef(props, "width"), uncontrolledWidthRef);
        const mergedHeightRef = useMergedState(toRef(props, "height"), uncontrolledHeightRef);
        const styleWidthRef = computed(() => {
          const { placement } = props;
          if (placement === "top" || placement === "bottom")
            return "";
          return formatLength(mergedWidthRef.value);
        });
        const styleHeightRef = computed(() => {
          const { placement } = props;
          if (placement === "left" || placement === "right")
            return "";
          return formatLength(mergedHeightRef.value);
        });
        const doUpdateWidth = (value) => {
          const { onUpdateWidth, "onUpdate:width": _onUpdateWidth } = props;
          if (onUpdateWidth)
            call(onUpdateWidth, value);
          if (_onUpdateWidth)
            call(_onUpdateWidth, value);
          uncontrolledWidthRef.value = value;
        };
        const doUpdateHeight = (value) => {
          const { onUpdateHeight, "onUpdate:width": _onUpdateHeight } = props;
          if (onUpdateHeight)
            call(onUpdateHeight, value);
          if (_onUpdateHeight)
            call(_onUpdateHeight, value);
          uncontrolledHeightRef.value = value;
        };
        const mergedBodyStyleRef = computed(() => {
          return [
            {
              width: styleWidthRef.value,
              height: styleHeightRef.value
            },
            props.drawerStyle || ""
          ];
        });
        function handleMaskClick(e) {
          const { onMaskClick, maskClosable } = props;
          if (maskClosable) {
            doUpdateShow(false);
          }
          if (onMaskClick)
            onMaskClick(e);
        }
        const isComposingRef2 = useIsComposing();
        function handleEsc(e) {
          var _a2;
          (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props);
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            !isComposingRef2.value && doUpdateShow(false);
          }
        }
        function doUpdateShow(show) {
          const { onHide, onUpdateShow, "onUpdate:show": _onUpdateShow } = props;
          if (onUpdateShow)
            call(onUpdateShow, show);
          if (_onUpdateShow)
            call(_onUpdateShow, show);
          if (onHide && !show)
            call(onHide, show);
        }
        provide(drawerInjectionKey, {
          isMountedRef,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          doUpdateShow,
          doUpdateHeight,
          doUpdateWidth
        });
        const cssVarsRef = computed(() => {
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2, cubicBezierEaseIn: cubicBezierEaseIn2, cubicBezierEaseOut: cubicBezierEaseOut2 }, self: { color, textColor, boxShadow, lineHeight: lineHeight2, headerPadding, footerPadding, bodyPadding, titleFontSize, titleTextColor, titleFontWeight, headerBorderBottom, footerBorderTop, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeIconSize, closeSize, closeBorderRadius, resizableTriggerColorHover } } = themeRef.value;
          return {
            "--n-line-height": lineHeight2,
            "--n-color": color,
            "--n-text-color": textColor,
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-out": cubicBezierEaseOut2,
            "--n-bezier-in": cubicBezierEaseIn2,
            "--n-header-padding": headerPadding,
            "--n-body-padding": bodyPadding,
            "--n-footer-padding": footerPadding,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-header-border-bottom": headerBorderBottom,
            "--n-footer-border-top": footerBorderTop,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-size": closeSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-resize-trigger-color-hover": resizableTriggerColorHover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedBodyStyle: mergedBodyStyleRef,
          handleMaskClick,
          handleEsc,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
          isMounted: isMountedRef
        };
      },
      render() {
        const { mergedClsPrefix } = this;
        return h(LazyTeleport, { to: this.to, show: this.show }, {
          default: () => {
            var _a2;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return withDirectives(h(
              "div",
              { class: [
                `${mergedClsPrefix}-drawer-container`,
                this.namespace,
                this.themeClass
              ], style: this.cssVars, role: "none" },
              this.showMask ? h(Transition, { name: "fade-in-transition", appear: this.isMounted }, {
                default: () => this.show ? h("div", { "aria-hidden": true, class: [
                  `${mergedClsPrefix}-drawer-mask`,
                  this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`
                ], onClick: this.handleMaskClick }) : null
              }) : null,
              h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleMaskClick }), this.$slots)
            ), [[zindexable, { zIndex: this.zIndex, enabled: this.show }]]);
          }
        });
      }
    });
    const drawerContentProps = {
      title: {
        type: String
      },
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      bodyStyle: [Object, String],
      bodyContentStyle: [Object, String],
      nativeScrollbar: { type: Boolean, default: true },
      scrollbarProps: Object,
      closable: Boolean
    };
    const NDrawerContent = /* @__PURE__ */ defineComponent({
      name: "DrawerContent",
      props: drawerContentProps,
      setup() {
        const NDrawer2 = inject(drawerInjectionKey, null);
        if (!NDrawer2) {
          throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
        }
        const { doUpdateShow } = NDrawer2;
        function handleCloseClick() {
          doUpdateShow(false);
        }
        return {
          handleCloseClick,
          mergedTheme: NDrawer2.mergedThemeRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef
        };
      },
      render() {
        const { title, mergedClsPrefix, nativeScrollbar, mergedTheme, bodyStyle, bodyContentStyle, headerStyle, footerStyle, scrollbarProps: scrollbarProps2, closable, $slots } = this;
        return h(
          "div",
          { role: "none", class: [
            `${mergedClsPrefix}-drawer-content`,
            nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`
          ] },
          $slots.header || title || closable ? h(
            "div",
            { class: `${mergedClsPrefix}-drawer-header`, style: headerStyle, role: "none" },
            h("div", { class: `${mergedClsPrefix}-drawer-header__main`, role: "heading", "aria-level": "1" }, $slots.header !== void 0 ? $slots.header() : title),
            closable && h(NBaseClose, { onClick: this.handleCloseClick, clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-drawer-header__close`, absolute: true })
          ) : null,
          nativeScrollbar ? h(
            "div",
            { class: `${mergedClsPrefix}-drawer-body`, style: bodyStyle, role: "none" },
            h("div", { class: `${mergedClsPrefix}-drawer-body-content-wrapper`, style: bodyContentStyle, role: "none" }, $slots)
          ) : h(Scrollbar, Object.assign({ themeOverrides: mergedTheme.peerOverrides.Scrollbar, theme: mergedTheme.peers.Scrollbar }, scrollbarProps2, { class: `${mergedClsPrefix}-drawer-body`, contentClass: `${mergedClsPrefix}-drawer-body-content-wrapper`, contentStyle: bodyContentStyle }), $slots),
          $slots.footer ? h("div", { class: `${mergedClsPrefix}-drawer-footer`, style: footerStyle, role: "none" }, $slots.footer()) : null
        );
      }
    });
    const commonVariables$6 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };
    const dynamicInputDark = {
      name: "DynamicInput",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self() {
        return commonVariables$6;
      }
    };
    const commonVars$4 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const spaceDark = {
      name: "Space",
      self() {
        return commonVars$4;
      }
    };
    const self$m = () => {
      return commonVars$4;
    };
    const spaceLight = {
      self: self$m
    };
    let supportFlexGap;
    const ensureSupportFlexGap = () => {
      if (!isBrowser$1)
        return true;
      if (supportFlexGap === void 0) {
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        const isSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return supportFlexGap = isSupported;
      }
      return supportFlexGap;
    };
    const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
      align: String,
      justify: {
        type: String,
        default: "start"
      },
      inline: Boolean,
      vertical: Boolean,
      size: {
        type: [String, Number, Array],
        default: "medium"
      },
      wrapItem: {
        type: Boolean,
        default: true
      },
      itemStyle: [String, Object],
      wrap: {
        type: Boolean,
        default: true
      },
      // internal
      internalUseGap: {
        type: Boolean,
        default: void 0
      }
    });
    const NSpace = /* @__PURE__ */ defineComponent({
      name: "Space",
      props: spaceProps,
      setup(props) {
        const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
        const themeRef = useTheme("Space", "-space", void 0, spaceLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
        return {
          useGap: ensureSupportFlexGap(),
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          margin: computed(() => {
            const { size: size2 } = props;
            if (Array.isArray(size2)) {
              return {
                horizontal: size2[0],
                vertical: size2[1]
              };
            }
            if (typeof size2 === "number") {
              return {
                horizontal: size2,
                vertical: size2
              };
            }
            const { self: { [createKey("gap", size2)]: gap } } = themeRef.value;
            const { row, col } = getGap(gap);
            return {
              horizontal: depx(col),
              vertical: depx(row)
            };
          })
        };
      },
      render() {
        const { vertical, align, inline, justify, itemStyle, margin, wrap, mergedClsPrefix, rtlEnabled, useGap, wrapItem, internalUseGap } = this;
        const children = flatten(getSlot$1(this));
        if (!children.length)
          return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith("space-");
        return h("div", { role: "none", class: [
          `${mergedClsPrefix}-space`,
          rtlEnabled && `${mergedClsPrefix}-space--rtl`
        ], style: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: vertical ? "column" : "row",
          justifyContent: ["start", "end"].includes(justify) ? "flex-" + justify : justify,
          flexWrap: !wrap || vertical ? "nowrap" : "wrap",
          marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
          marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
          alignItems: align,
          gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
        } }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => h("div", { role: "none", style: [
          itemStyle,
          {
            maxWidth: "100%"
          },
          useGap ? "" : vertical ? {
            marginBottom: index !== lastIndex ? verticalMargin : ""
          } : rtlEnabled ? {
            marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          } : {
            marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          }
        ] }, child)));
      }
    });
    const dynamicTagsDark = {
      name: "DynamicTags",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        Tag: tagDark,
        Space: spaceDark
      },
      self() {
        return {
          inputWidth: "64px"
        };
      }
    };
    const elementDark = {
      name: "Element",
      common: derived$1
    };
    const commonVariables$5 = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right",
      labelFontWeight: "400"
    };
    const self$l = (vars) => {
      const { heightSmall, heightMedium, heightLarge, textColor1, errorColor, warningColor, lineHeight: lineHeight2, textColor3 } = vars;
      return Object.assign(Object.assign({}, commonVariables$5), { blankHeightSmall: heightSmall, blankHeightMedium: heightMedium, blankHeightLarge: heightLarge, lineHeight: lineHeight2, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
    };
    const formLight = {
      common: derived,
      self: self$l
    };
    const formItemDark = {
      name: "Form",
      common: derived$1,
      self: self$l
    };
    const style$2 = cB("form", [cM$1("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c("&:last-child", {
      marginRight: 0
    })])])]);
    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
    var __awaiter$1 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formProps = Object.assign(Object.assign({}, useTheme.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: {
      type: String,
      default: "top"
    }, model: {
      type: Object,
      default: () => {
      }
    }, rules: Object, disabled: Boolean, size: String, showRequireMark: {
      type: Boolean,
      default: void 0
    }, requireMarkPlacement: String, showFeedback: {
      type: Boolean,
      default: true
    }, onSubmit: {
      type: Function,
      default: (e) => {
        e.preventDefault();
      }
    }, showLabel: {
      type: Boolean,
      default: void 0
    }, validateMessages: Object });
    const NForm = /* @__PURE__ */ defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        useTheme("Form", "-form", style$2, formLight, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        function validate(validateCallback, shouldRuleBeApplied = () => true) {
          return __awaiter$1(this, void 0, void 0, function* () {
            yield new Promise((resolve2, reject) => {
              const formItemValidationPromises = [];
              for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                  if (formItemInstance.path) {
                    formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                  }
                }
              }
              void Promise.all(formItemValidationPromises).then((results) => {
                if (results.some((result) => !result.valid)) {
                  const errors = results.filter((result) => result.errors).map((result) => result.errors);
                  if (validateCallback) {
                    validateCallback(errors);
                  }
                  reject(errors);
                } else {
                  if (validateCallback)
                    validateCallback();
                  resolve2();
                }
              });
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        provide(formItemInstsInjectionKey, { formItems });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const { mergedClsPrefix } = this;
        return h("form", { class: [
          `${mergedClsPrefix}-form`,
          this.inline && `${mergedClsPrefix}-form--inline`
        ], onSubmit: this.onSubmit }, this.$slots);
      }
    });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
        o2.__proto__ = p22;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i >= len) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip2 = function ip22(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip2.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip2.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip2.v4().source;
      var ipv6 = ip2.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float2(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex2(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc === void 0) {
          oc = function oc2() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add2(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys = options.keys || Object.keys(this.rules);
        keys.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb2, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e) {
              return cb2(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType2(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys = Object.keys(rule);
        var messageIndex = keys.indexOf("message");
        if (messageIndex !== -1) {
          keys.splice(messageIndex, 1);
        }
        if (keys.length === 1 && keys[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    function formItemSize(props) {
      const NForm2 = inject(formInjectionKey, null);
      return {
        mergedSize: computed(() => {
          if (props.size !== void 0)
            return props.size;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0)
            return NForm2.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm2 = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
        const { labelPlacement } = props;
        if (labelPlacement !== void 0)
          return labelPlacement;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement)
          return NForm2.props.labelPlacement;
        return "top";
      });
      const isAutoLabelWidthRef = computed(() => {
        return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
      });
      const mergedLabelWidthRef = computed(() => {
        if (mergedLabelPlacementRef.value === "top")
          return;
        const { labelWidth } = props;
        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }
        if (isAutoLabelWidthRef.value) {
          const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
          return formatLength(NForm2.props.labelWidth);
        }
        return void 0;
      });
      const mergedLabelAlignRef = computed(() => {
        const { labelAlign } = props;
        if (labelAlign)
          return labelAlign;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign)
          return NForm2.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = computed(() => {
        var _a2;
        return [
          (_a2 = props.labelProps) === null || _a2 === void 0 ? void 0 : _a2.style,
          props.labelStyle,
          {
            width: mergedLabelWidthRef.value
          }
        ];
      });
      const mergedShowRequireMarkRef = computed(() => {
        const { showRequireMark } = props;
        if (showRequireMark !== void 0)
          return showRequireMark;
        return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
        const { requireMarkPlacement } = props;
        if (requireMarkPlacement !== void 0)
          return requireMarkPlacement;
        return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
        const { validationStatus } = props;
        if (validationStatus !== void 0)
          return validationStatus;
        if (validationErroredRef.value)
          return "error";
        return void 0;
      });
      const mergedShowFeedbackRef = computed(() => {
        const { showFeedback } = props;
        if (showFeedback !== void 0)
          return showFeedback;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0)
          return NForm2.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = computed(() => {
        const { showLabel } = props;
        if (showLabel !== void 0)
          return showLabel;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0)
          return NForm2.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef,
        isAutoLabelWidth: isAutoLabelWidthRef
      };
    }
    function formItemRule(props) {
      const NForm2 = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
        const { rulePath } = props;
        if (rulePath !== void 0)
          return rulePath;
        const { path } = props;
        if (path !== void 0)
          return path;
        return void 0;
      });
      const mergedRulesRef = computed(() => {
        const rules2 = [];
        const { rule } = props;
        if (rule !== void 0) {
          if (Array.isArray(rule))
            rules2.push(...rule);
          else
            rules2.push(rule);
        }
        if (NForm2) {
          const { rules: formRules } = NForm2.props;
          const { value: rulePath } = compatibleRulePathRef;
          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = get(formRules, rulePath);
            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules2.push(...formRule);
              } else {
                rules2.push(formRule);
              }
            }
          }
        }
        return rules2;
      });
      const hasRequiredRuleRef = computed(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
      });
      const mergedRequiredRef = computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }
    const {
      cubicBezierEaseInOut
    } = commonVariables$m;
    function fadeDownTransition({
      name = "fade-down",
      fromOffset = "-4px",
      enterDuration = ".3s",
      leaveDuration = ".3s",
      enterCubicBezier = cubicBezierEaseInOut,
      leaveCubicBezier = cubicBezierEaseInOut
    } = {}) {
      return [c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }
    const style$1 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE$1("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE$1("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM$1("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM$1("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM$1("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM$1("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM$1("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM$1("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE$1("text", `
 grid-area: text; 
 `), cE$1("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM$1("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM$1("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM$1("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM$1("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);
    var __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formItemProps = Object.assign(Object.assign({}, useTheme.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: {
      type: Boolean,
      default: void 0
    }, requireMarkPlacement: String, showFeedback: {
      type: Boolean,
      default: void 0
    }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, showLabel: {
      type: Boolean,
      default: void 0
    }, labelProps: Object });
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || // Error[]
          (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn$2("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ` + (async ? "`Promise`" : "`boolean`, `Error` or `Promise`") + " typed value instead.");
            return true;
          }
        } catch (err) {
          warn$2("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
          console.error(err);
          return void 0;
        }
      };
    }
    const NFormItem = /* @__PURE__ */ defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const NForm2 = inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const { validationErrored: validationErroredRef } = formItemMiscRefs;
        const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
        const { mergedSize: mergedSizeRef } = formItemSizeRefs;
        const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef, mergedRequireMarkPlacement: mergedRequireMarkPlacementRef } = formItemMiscRefs;
        const renderExplainsRef = ref([]);
        const feedbackIdRef = ref(createId());
        const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
        const themeRef = useTheme("Form", "-form-item", style$1, formLight, props, mergedClsPrefixRef);
        watch(toRef(props, "path"), () => {
          if (props.ignorePathChange)
            return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        function validate(options, callback) {
          return __awaiter(this, void 0, void 0, function* () {
            let trigger2;
            let validateCallback;
            let shouldRuleBeApplied;
            let asyncValidatorOptions;
            if (typeof options === "string") {
              trigger2 = options;
              validateCallback = callback;
            } else if (options !== null && typeof options === "object") {
              trigger2 = options.trigger;
              validateCallback = options.callback;
              shouldRuleBeApplied = options.shouldRuleBeApplied;
              asyncValidatorOptions = options.options;
            }
            yield new Promise((resolve2, reject) => {
              void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                if (valid) {
                  if (validateCallback) {
                    validateCallback();
                  }
                  resolve2();
                } else {
                  if (validateCallback) {
                    validateCallback(errors);
                  }
                  reject(errors);
                }
              });
            });
          });
        }
        const internalValidate = (trigger2 = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) => __awaiter(this, void 0, void 0, function* () {
          const { path } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first)
              options.first = props.first;
          }
          const { value: rules2 } = mergedRulesRef;
          const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          })).filter(shouldRuleBeApplied).map((rule, i) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          if (!activeRules.length) {
            return {
              valid: true
            };
          }
          const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
          const validator = new Schema({ [mergedPath]: activeRules });
          const { validateMessages } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
          if (validateMessages) {
            validator.messages(validateMessages);
          }
          return yield new Promise((resolve2) => {
            void validator.validate({ [mergedPath]: value }, options, (errors) => {
              if (errors === null || errors === void 0 ? void 0 : errors.length) {
                renderExplainsRef.value = errors.map((error) => {
                  const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
                  return {
                    key: transformedMessage,
                    render: () => {
                      if (transformedMessage.startsWith("__renderMessage__")) {
                        return messageRenderers[transformedMessage]();
                      }
                      return transformedMessage;
                    }
                  };
                });
                errors.forEach((error) => {
                  var _a2;
                  if ((_a2 = error.message) === null || _a2 === void 0 ? void 0 : _a2.startsWith("__renderMessage__")) {
                    error.message = originalMessageRendersMessage[error.message];
                  }
                });
                validationErroredRef.value = true;
                resolve2({
                  valid: false,
                  errors
                });
              } else {
                restoreValidation();
                resolve2({
                  valid: true
                });
              }
            });
          });
        });
        provide(formItemInjectionKey, {
          path: toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = ref(null);
        onMounted(() => {
          if (!formItemMiscRefs.isAutoLabelWidth.value)
            return;
          const labelElement = labelElementRef.value;
          if (labelElement !== null) {
            const memoizedWhitespace = labelElement.style.whiteSpace;
            labelElement.style.whiteSpace = "nowrap";
            labelElement.style.width = "";
            NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
            labelElement.style.whiteSpace = memoizedWhitespace;
          }
        });
        const cssVarsRef = computed(() => {
          var _a2;
          const { value: size2 } = mergedSizeRef;
          const { value: labelPlacement } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const { common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 }, self: { labelTextColor, asteriskColor, lineHeight: lineHeight2, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, labelFontWeight, [createKey("labelHeight", size2)]: labelHeight, [createKey("blankHeight", size2)]: blankHeight, [createKey("feedbackFontSize", size2)]: feedbackFontSize, [createKey("feedbackHeight", size2)]: feedbackHeight, [createKey("labelPadding", direction)]: labelPadding, [createKey("labelTextAlign", direction)]: labelTextAlign, [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize } } = themeRef.value;
          let mergedLabelTextAlign = (_a2 = labelTextAlignRef.value) !== null && _a2 !== void 0 ? _a2 : labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-line-height": lineHeight2,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-label-font-weight": labelFontWeight,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
          var _a2;
          return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a2 = labelTextAlignRef.value) === null || _a2 === void 0 ? void 0 : _a2[0]) || ""}`;
        }), cssVarsRef, props) : void 0;
        const reverseColSpaceRef = computed(() => {
          return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
        });
        return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef, mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, feedbackId: feedbackIdRef, renderExplains: renderExplainsRef, reverseColSpace: reverseColSpaceRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: inlineThemeDisabled ? void 0 : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
        const { $slots, mergedClsPrefix, mergedShowLabel, mergedShowRequireMark, mergedRequireMarkPlacement, onRender } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderLabel = () => {
          const labelText = this.$slots.label ? this.$slots.label() : this.label;
          if (!labelText)
            return null;
          const textNode = h("span", { class: `${mergedClsPrefix}-form-item-label__text` }, labelText);
          const markNode = renderedShowRequireMark ? h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, mergedRequireMarkPlacement !== "left" ? "*" : "*") : mergedRequireMarkPlacement === "right-hanging" && h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder` }, "*");
          const { labelProps } = this;
          return h("label", Object.assign({}, labelProps, { class: [
            labelProps === null || labelProps === void 0 ? void 0 : labelProps.class,
            `${mergedClsPrefix}-form-item-label`,
            `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`,
            this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`
          ], style: this.mergedLabelStyle, ref: "labelElementRef" }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
        };
        return h(
          "div",
          { class: [
            `${mergedClsPrefix}-form-item`,
            this.themeClass,
            `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
            `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
            this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`,
            !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
          ], style: this.cssVars },
          mergedShowLabel && renderLabel(),
          h("div", { class: [
            `${mergedClsPrefix}-form-item-blank`,
            this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
          ] }, $slots),
          this.mergedShowFeedback ? h(
            "div",
            { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
            h(Transition, { name: "fade-down-transition", mode: "out-in" }, {
              default: () => {
                const { mergedValidationStatus } = this;
                return resolveWrappedSlot($slots.feedback, (children) => {
                  var _a2;
                  const { feedback } = this;
                  const feedbackNodes = children || feedback ? h("div", { key: "__feedback__", class: `${mergedClsPrefix}-form-item-feedback__line` }, children || feedback) : this.renderExplains.length ? (_a2 = this.renderExplains) === null || _a2 === void 0 ? void 0 : _a2.map(({ key, render: render2 }) => h("div", { key, class: `${mergedClsPrefix}-form-item-feedback__line` }, render2())) : null;
                  return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbackNodes) : h("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbackNodes) : null;
                });
              }
            })
          ) : null
        );
      }
    });
    const gradientTextDark = {
      name: "GradientText",
      common: derived$1,
      self(vars) {
        const { primaryColor, successColor, warningColor, errorColor, infoColor, primaryColorSuppl, successColorSuppl, warningColorSuppl, errorColorSuppl, infoColorSuppl, fontWeightStrong } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: primaryColor,
          colorEndPrimary: primaryColorSuppl,
          colorStartInfo: infoColor,
          colorEndInfo: infoColorSuppl,
          colorStartWarning: warningColor,
          colorEndWarning: warningColorSuppl,
          colorStartError: errorColor,
          colorEndError: errorColorSuppl,
          colorStartSuccess: successColor,
          colorEndSuccess: successColorSuppl
        };
      }
    };
    const self$k = (vars) => {
      const { primaryColor, baseColor } = vars;
      return {
        color: primaryColor,
        iconColor: baseColor
      };
    };
    const iconDark = {
      name: "IconWrapper",
      common: derived$1,
      self: self$k
    };
    const commonVars$3 = {
      closeMargin: "16px 12px",
      closeSize: "20px",
      closeIconSize: "16px",
      width: "365px",
      padding: "16px",
      titleFontSize: "16px",
      metaFontSize: "12px",
      descriptionFontSize: "12px"
    };
    const self$j = (vars) => {
      const { textColor2, successColor, infoColor, warningColor, errorColor, popoverColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, textColor1, textColor3, borderRadius, fontWeightStrong, boxShadow2, lineHeight: lineHeight2, fontSize: fontSize2 } = vars;
      return Object.assign(Object.assign({}, commonVars$3), {
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        headerFontWeight: fontWeightStrong,
        iconColor: textColor2,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        color: popoverColor,
        textColor: textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        headerTextColor: textColor1,
        descriptionTextColor: textColor3,
        actionTextColor: textColor2,
        boxShadow: boxShadow2
      });
    };
    const notificationDark = {
      name: "Notification",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$j
    };
    const commonVariables$4 = {
      margin: "0 0 8px 0",
      padding: "10px 20px",
      maxWidth: "720px",
      minWidth: "420px",
      iconMargin: "0 10px 0 0",
      closeMargin: "0 0 0 10px",
      closeSize: "20px",
      closeIconSize: "16px",
      iconSize: "20px",
      fontSize: "14px"
    };
    const self$i = (vars) => {
      const { textColor2, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, errorColor, warningColor, popoverColor, boxShadow2, primaryColor, lineHeight: lineHeight2, borderRadius, closeColorHover, closeColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), {
        closeBorderRadius: borderRadius,
        textColor: textColor2,
        textColorInfo: textColor2,
        textColorSuccess: textColor2,
        textColorError: textColor2,
        textColorWarning: textColor2,
        textColorLoading: textColor2,
        color: popoverColor,
        colorInfo: popoverColor,
        colorSuccess: popoverColor,
        colorError: popoverColor,
        colorWarning: popoverColor,
        colorLoading: popoverColor,
        boxShadow: boxShadow2,
        boxShadowInfo: boxShadow2,
        boxShadowSuccess: boxShadow2,
        boxShadowError: boxShadow2,
        boxShadowWarning: boxShadow2,
        boxShadowLoading: boxShadow2,
        iconColor: textColor2,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        iconColorLoading: primaryColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        closeColorHoverLoading: closeColorHover,
        closeColorPressedLoading: closeColorPressed,
        closeIconColorLoading: closeIconColor,
        closeIconColorHoverLoading: closeIconColorHover,
        closeIconColorPressedLoading: closeIconColorPressed,
        loadingColor: primaryColor,
        lineHeight: lineHeight2,
        borderRadius
      });
    };
    const messageDark = {
      name: "Message",
      common: derived$1,
      self: self$i
    };
    const buttonGroupDark = {
      name: "ButtonGroup",
      common: derived$1
    };
    const inputNumberDark = {
      name: "InputNumber",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Input: inputDark
      },
      self(vars) {
        const { textColorDisabled } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      }
    };
    const layoutDark = {
      name: "Layout",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const { textColor2, bodyColor, popoverColor, cardColor, dividerColor, scrollbarColor, scrollbarColorHover } = vars;
        return {
          textColor: textColor2,
          textColorInverted: textColor2,
          color: bodyColor,
          colorEmbedded: bodyColor,
          headerColor: cardColor,
          headerColorInverted: cardColor,
          footerColor: cardColor,
          footerColorInverted: cardColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: dividerColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: dividerColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: dividerColor,
          siderColor: cardColor,
          siderColorInverted: cardColor,
          siderToggleButtonBorder: "1px solid transparent",
          siderToggleButtonColor: popoverColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          __invertScrollbar: "false"
        };
      }
    };
    const self$h = (vars) => {
      const { textColor2, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontSize: fontSize2, hoverColor } = vars;
      return {
        textColor: textColor2,
        color: cardColor,
        colorHover: hoverColor,
        colorModal: modalColor,
        colorHoverModal: composite(modalColor, hoverColor),
        colorPopover: popoverColor,
        colorHoverPopover: composite(popoverColor, hoverColor),
        borderColor: dividerColor,
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius,
        fontSize: fontSize2
      };
    };
    const listDark$1 = {
      name: "List",
      common: derived$1,
      self: self$h
    };
    const loadingBarDark = {
      name: "LoadingBar",
      common: derived$1,
      self(vars) {
        const { primaryColor } = vars;
        return {
          colorError: "red",
          colorLoading: primaryColor,
          height: "2px"
        };
      }
    };
    const logDark = {
      name: "Log",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Code: codeDark
      },
      self(vars) {
        const { textColor2, inputColor, fontSize: fontSize2, primaryColor } = vars;
        return {
          loaderFontSize: fontSize2,
          loaderTextColor: textColor2,
          loaderColor: inputColor,
          loaderBorder: "1px solid #0000",
          loadingColor: primaryColor
        };
      }
    };
    const listDark = {
      name: "Mention",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self(vars) {
        const { boxShadow2 } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
    };
    function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
        itemColorHoverInverted: "#0000",
        itemColorActiveInverted: activeItemColor,
        itemColorActiveHoverInverted: activeItemColor,
        itemColorActiveCollapsedInverted: activeItemColor,
        itemTextColorInverted: color,
        itemTextColorHoverInverted: activeTextColor,
        itemTextColorChildActiveInverted: activeTextColor,
        itemTextColorChildActiveHoverInverted: activeTextColor,
        itemTextColorActiveInverted: activeTextColor,
        itemTextColorActiveHoverInverted: activeTextColor,
        itemTextColorHorizontalInverted: color,
        itemTextColorHoverHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
        itemTextColorActiveHorizontalInverted: activeTextColor,
        itemTextColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorInverted: color,
        itemIconColorHoverInverted: activeTextColor,
        itemIconColorActiveInverted: activeTextColor,
        itemIconColorActiveHoverInverted: activeTextColor,
        itemIconColorChildActiveInverted: activeTextColor,
        itemIconColorChildActiveHoverInverted: activeTextColor,
        itemIconColorCollapsedInverted: color,
        itemIconColorHorizontalInverted: color,
        itemIconColorHoverHorizontalInverted: activeTextColor,
        itemIconColorActiveHorizontalInverted: activeTextColor,
        itemIconColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
        arrowColorInverted: color,
        arrowColorHoverInverted: activeTextColor,
        arrowColorActiveInverted: activeTextColor,
        arrowColorActiveHoverInverted: activeTextColor,
        arrowColorChildActiveInverted: activeTextColor,
        arrowColorChildActiveHoverInverted: activeTextColor,
        groupTextColorInverted: groupTextColor
      };
    }
    const self$g = (vars) => {
      const { borderRadius, textColor3, primaryColor, textColor2, textColor1, fontSize: fontSize2, dividerColor, hoverColor, primaryColorHover } = vars;
      return Object.assign({
        borderRadius,
        color: "#0000",
        groupTextColor: textColor3,
        itemColorHover: hoverColor,
        itemColorActive: changeColor(primaryColor, { alpha: 0.1 }),
        itemColorActiveHover: changeColor(primaryColor, { alpha: 0.1 }),
        itemColorActiveCollapsed: changeColor(primaryColor, { alpha: 0.1 }),
        itemTextColor: textColor2,
        itemTextColorHover: textColor2,
        itemTextColorActive: primaryColor,
        itemTextColorActiveHover: primaryColor,
        itemTextColorChildActive: primaryColor,
        itemTextColorChildActiveHover: primaryColor,
        itemTextColorHorizontal: textColor2,
        itemTextColorHoverHorizontal: primaryColorHover,
        itemTextColorActiveHorizontal: primaryColor,
        itemTextColorActiveHoverHorizontal: primaryColor,
        itemTextColorChildActiveHorizontal: primaryColor,
        itemTextColorChildActiveHoverHorizontal: primaryColor,
        itemIconColor: textColor1,
        itemIconColorHover: textColor1,
        itemIconColorActive: primaryColor,
        itemIconColorActiveHover: primaryColor,
        itemIconColorChildActive: primaryColor,
        itemIconColorChildActiveHover: primaryColor,
        itemIconColorCollapsed: textColor1,
        itemIconColorHorizontal: textColor1,
        itemIconColorHoverHorizontal: primaryColorHover,
        itemIconColorActiveHorizontal: primaryColor,
        itemIconColorActiveHoverHorizontal: primaryColor,
        itemIconColorChildActiveHorizontal: primaryColor,
        itemIconColorChildActiveHoverHorizontal: primaryColor,
        itemHeight: "42px",
        arrowColor: textColor2,
        arrowColorHover: textColor2,
        arrowColorActive: primaryColor,
        arrowColorActiveHover: primaryColor,
        arrowColorChildActive: primaryColor,
        arrowColorChildActiveHover: primaryColor,
        colorInverted: "#0000",
        borderColorHorizontal: "#0000",
        fontSize: fontSize2,
        dividerColor
      }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
    };
    const menuDark = {
      name: "Menu",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const { primaryColor, primaryColorSuppl } = vars;
        const commonSelf = self$g(vars);
        commonSelf.itemColorActive = changeColor(primaryColor, { alpha: 0.15 });
        commonSelf.itemColorActiveHover = changeColor(primaryColor, { alpha: 0.15 });
        commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveInverted = primaryColorSuppl;
        commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
        commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const common = {
      titleFontSize: "18px",
      backSize: "22px"
    };
    function self$f(vars) {
      const { textColor1, textColor2, textColor3, fontSize: fontSize2, fontWeightStrong, primaryColorHover, primaryColorPressed } = vars;
      return Object.assign(Object.assign({}, common), { titleFontWeight: fontWeightStrong, fontSize: fontSize2, titleTextColor: textColor1, backColor: textColor2, backColorHover: primaryColorHover, backColorPressed: primaryColorPressed, subtitleTextColor: textColor3 });
    }
    const pageHeaderDark = {
      name: "PageHeader",
      common: derived$1,
      self: self$f
    };
    const commonVars$2 = {
      iconSize: "22px"
    };
    const self$e = (vars) => {
      const { fontSize: fontSize2, warningColor } = vars;
      return Object.assign(Object.assign({}, commonVars$2), { fontSize: fontSize2, iconColor: warningColor });
    };
    const popconfirmDark = {
      name: "Popconfirm",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Popover: popoverDark
      },
      self: self$e
    };
    const self$d = (vars) => {
      const { infoColor, successColor, warningColor, errorColor, textColor2, progressRailColor, fontSize: fontSize2, fontWeight } = vars;
      return {
        fontSize: fontSize2,
        fontSizeCircle: "28px",
        fontWeightCircle: fontWeight,
        railColor: progressRailColor,
        railHeight: "8px",
        iconSizeCircle: "36px",
        iconSizeLine: "18px",
        iconColor: infoColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        textColorCircle: textColor2,
        textColorLineInner: "rgb(255, 255, 255)",
        textColorLineOuter: textColor2,
        fillColor: infoColor,
        fillColorInfo: infoColor,
        fillColorSuccess: successColor,
        fillColorWarning: warningColor,
        fillColorError: errorColor,
        lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
      };
    };
    const progressDark = {
      name: "Progress",
      common: derived$1,
      self(vars) {
        const commonSelf = self$d(vars);
        commonSelf.textColorLineInner = "rgb(0, 0, 0)";
        commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
        return commonSelf;
      }
    };
    const rateDark = {
      name: "Rate",
      common: derived$1,
      self(vars) {
        const { railColor } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#CCAA33",
          itemSize: "20px",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      }
    };
    const commonVariables$3 = {
      titleFontSizeSmall: "26px",
      titleFontSizeMedium: "32px",
      titleFontSizeLarge: "40px",
      titleFontSizeHuge: "48px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      iconSizeSmall: "64px",
      iconSizeMedium: "80px",
      iconSizeLarge: "100px",
      iconSizeHuge: "125px",
      iconColor418: void 0,
      iconColor404: void 0,
      iconColor403: void 0,
      iconColor500: void 0
    };
    const self$c = (vars) => {
      const { textColor2, textColor1, errorColor, successColor, infoColor, warningColor, lineHeight: lineHeight2, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), { lineHeight: lineHeight2, titleFontWeight: fontWeightStrong, titleTextColor: textColor1, textColor: textColor2, iconColorError: errorColor, iconColorSuccess: successColor, iconColorInfo: infoColor, iconColorWarning: warningColor });
    };
    const resultDark = {
      name: "Result",
      common: derived$1,
      self: self$c
    };
    const sizeVariables$3 = {
      railHeight: "4px",
      railWidthVertical: "4px",
      handleSize: "18px",
      dotHeight: "8px",
      dotWidth: "8px",
      dotBorderRadius: "4px"
    };
    const sliderDark = {
      name: "Slider",
      common: derived$1,
      self(vars) {
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const { railColor, modalColor, primaryColorSuppl, popoverColor, textColor2, cardColor, borderRadius, fontSize: fontSize2, opacityDisabled } = vars;
        return Object.assign(Object.assign({}, sizeVariables$3), { fontSize: fontSize2, markFontSize: fontSize2, railColor, railColorHover: railColor, fillColor: primaryColorSuppl, fillColorHover: primaryColorSuppl, opacityDisabled, handleColor: "#FFF", dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", indicatorColor: popoverColor, indicatorBoxShadow: boxShadow, indicatorTextColor: textColor2, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColorSuppl}`, dotBoxShadow: "" });
      }
    };
    const self$b = (vars) => {
      const { opacityDisabled, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, primaryColor, fontSize: fontSize2 } = vars;
      return {
        fontSize: fontSize2,
        textColor: primaryColor,
        sizeTiny: heightTiny,
        sizeSmall: heightSmall,
        sizeMedium: heightMedium,
        sizeLarge: heightLarge,
        sizeHuge: heightHuge,
        color: primaryColor,
        opacitySpinning: opacityDisabled
      };
    };
    const spinDark = {
      name: "Spin",
      common: derived$1,
      self: self$b
    };
    const self$a = (vars) => {
      const { textColor2, textColor3, fontSize: fontSize2, fontWeight } = vars;
      return {
        labelFontSize: fontSize2,
        labelFontWeight: fontWeight,
        valueFontWeight: fontWeight,
        valueFontSize: "24px",
        labelTextColor: textColor3,
        valuePrefixTextColor: textColor2,
        valueSuffixTextColor: textColor2,
        valueTextColor: textColor2
      };
    };
    const statisticDark = {
      name: "Statistic",
      common: derived$1,
      self: self$a
    };
    const commonVariables$2 = {
      stepHeaderFontSizeSmall: "14px",
      stepHeaderFontSizeMedium: "16px",
      indicatorIndexFontSizeSmall: "14px",
      indicatorIndexFontSizeMedium: "16px",
      indicatorSizeSmall: "22px",
      indicatorSizeMedium: "28px",
      indicatorIconSizeSmall: "14px",
      indicatorIconSizeMedium: "18px"
    };
    const self$9 = (vars) => {
      const { fontWeightStrong, baseColor, textColorDisabled, primaryColor, errorColor, textColor1, textColor2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), { stepHeaderFontWeight: fontWeightStrong, indicatorTextColorProcess: baseColor, indicatorTextColorWait: textColorDisabled, indicatorTextColorFinish: primaryColor, indicatorTextColorError: errorColor, indicatorBorderColorProcess: primaryColor, indicatorBorderColorWait: textColorDisabled, indicatorBorderColorFinish: primaryColor, indicatorBorderColorError: errorColor, indicatorColorProcess: primaryColor, indicatorColorWait: "#0000", indicatorColorFinish: "#0000", indicatorColorError: "#0000", splitorColorProcess: textColorDisabled, splitorColorWait: textColorDisabled, splitorColorFinish: primaryColor, splitorColorError: textColorDisabled, headerTextColorProcess: textColor1, headerTextColorWait: textColorDisabled, headerTextColorFinish: textColorDisabled, headerTextColorError: errorColor, descriptionTextColorProcess: textColor2, descriptionTextColorWait: textColorDisabled, descriptionTextColorFinish: textColorDisabled, descriptionTextColorError: errorColor });
    };
    const stepsDark = {
      name: "Steps",
      common: derived$1,
      self: self$9
    };
    const commonVars$1 = {
      buttonHeightSmall: "14px",
      buttonHeightMedium: "18px",
      buttonHeightLarge: "22px",
      buttonWidthSmall: "14px",
      buttonWidthMedium: "18px",
      buttonWidthLarge: "22px",
      buttonWidthPressedSmall: "20px",
      buttonWidthPressedMedium: "24px",
      buttonWidthPressedLarge: "28px",
      railHeightSmall: "18px",
      railHeightMedium: "22px",
      railHeightLarge: "26px",
      railWidthSmall: "32px",
      railWidthMedium: "40px",
      railWidthLarge: "48px"
    };
    const switchDark = {
      name: "Switch",
      common: derived$1,
      self(vars) {
        const { primaryColorSuppl, opacityDisabled, borderRadius, primaryColor, textColor2, baseColor } = vars;
        const railOverlayColor = "rgba(255, 255, 255, .20)";
        return Object.assign(Object.assign({}, commonVars$1), { iconColor: baseColor, textColor: textColor2, loadingColor: primaryColorSuppl, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColorSuppl, buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, { alpha: 0.3 })}` });
      }
    };
    const self$8 = (vars) => {
      const { primaryColor, opacityDisabled, borderRadius, textColor3 } = vars;
      const railOverlayColor = "rgba(0, 0, 0, .14)";
      return Object.assign(Object.assign({}, commonVars$1), { iconColor: textColor3, textColor: "white", loadingColor: primaryColor, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColor, buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", buttonColor: "#FFF", railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}` });
    };
    const switchLight = {
      common: derived,
      self: self$8
    };
    const sizeVariables$2 = {
      thPaddingSmall: "6px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "6px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px"
    };
    const self$7 = (vars) => {
      const { dividerColor, cardColor, modalColor, popoverColor, tableHeaderColor, tableColorStriped, textColor1, textColor2, borderRadius, fontWeightStrong, lineHeight: lineHeight2, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
      return Object.assign(Object.assign({}, sizeVariables$2), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight: lineHeight2,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        tdColorStriped: composite(cardColor, tableColorStriped),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        tdTextColor: textColor2,
        thFontWeight: fontWeightStrong
      });
    };
    const tableDark = {
      name: "Table",
      common: derived$1,
      self: self$7
    };
    const sizeVariables$1 = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabGapSmallLineVertical: "8px",
      tabGapMediumLineVertical: "8px",
      tabGapLargeLineVertical: "8px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabPaddingVerticalSmallLine: "6px 12px",
      tabPaddingVerticalMediumLine: "8px 16px",
      tabPaddingVerticalLargeLine: "10px 20px",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabGapSmallBarVertical: "8px",
      tabGapMediumBarVertical: "8px",
      tabGapLargeBarVertical: "8px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabPaddingVerticalSmallBar: "6px 12px",
      tabPaddingVerticalMediumBar: "8px 16px",
      tabPaddingVerticalLargeBar: "10px 20px",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabGapSmallCardVertical: "4px",
      tabGapMediumCardVertical: "4px",
      tabGapLargeCardVertical: "4px",
      tabPaddingSmallCard: "8px 16px",
      tabPaddingMediumCard: "10px 20px",
      tabPaddingLargeCard: "12px 24px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabPaddingVerticalLargeSegment: "0 8px",
      tabPaddingVerticalSmallCard: "8px 12px",
      tabPaddingVerticalMediumCard: "10px 16px",
      tabPaddingVerticalLargeCard: "12px 20px",
      tabPaddingVerticalSmallSegment: "0 4px",
      tabPaddingVerticalMediumSegment: "0 6px",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      tabGapSmallSegmentVertical: "0",
      tabGapMediumSegmentVertical: "0",
      tabGapLargeSegmentVertical: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };
    const self$6 = (vars) => {
      const { textColor2, primaryColor, textColorDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, tabColor, baseColor, dividerColor, fontWeight, textColor1, borderRadius, fontSize: fontSize2, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, sizeVariables$1), {
        colorSegment: tabColor,
        tabFontSizeCard: fontSize2,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      });
    };
    const tabsDark = {
      name: "Tabs",
      common: derived$1,
      self(vars) {
        const commonSelf = self$6(vars);
        const { inputColor } = vars;
        commonSelf.colorSegment = inputColor;
        commonSelf.tabColorSegment = inputColor;
        return commonSelf;
      }
    };
    const self$5 = (vars) => {
      const { textColor1, textColor2, fontWeightStrong, fontSize: fontSize2 } = vars;
      return {
        fontSize: fontSize2,
        titleTextColor: textColor1,
        textColor: textColor2,
        titleFontWeight: fontWeightStrong
      };
    };
    const thingDark = {
      name: "Thing",
      common: derived$1,
      self: self$5
    };
    const sizeVariables = {
      titleMarginMedium: "0 0 6px 0",
      titleMarginLarge: "-2px 0 6px 0",
      titleFontSizeMedium: "14px",
      titleFontSizeLarge: "16px",
      iconSizeMedium: "14px",
      iconSizeLarge: "14px"
    };
    const timelineDark = {
      name: "Timeline",
      common: derived$1,
      self(vars) {
        const { textColor3, infoColorSuppl, errorColorSuppl, successColorSuppl, warningColorSuppl, textColor1, textColor2, railColor, fontWeightStrong, fontSize: fontSize2 } = vars;
        return Object.assign(Object.assign({}, sizeVariables), { contentFontSize: fontSize2, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColorSuppl}`, circleBorderError: `2px solid ${errorColorSuppl}`, circleBorderSuccess: `2px solid ${successColorSuppl}`, circleBorderWarning: `2px solid ${warningColorSuppl}`, iconColor: textColor3, iconColorInfo: infoColorSuppl, iconColorError: errorColorSuppl, iconColorSuccess: successColorSuppl, iconColorWarning: warningColorSuppl, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
      }
    };
    const commonVariables$1 = {
      extraFontSizeSmall: "12px",
      extraFontSizeMedium: "12px",
      extraFontSizeLarge: "14px",
      titleFontSizeSmall: "14px",
      titleFontSizeMedium: "16px",
      titleFontSizeLarge: "16px",
      closeSize: "20px",
      closeIconSize: "16px",
      headerHeightSmall: "44px",
      headerHeightMedium: "44px",
      headerHeightLarge: "50px"
    };
    const transferDark$1 = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, dividerColor } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        });
      }
    };
    const self$4 = (vars) => {
      const { borderRadiusSmall, hoverColor, pressedColor, primaryColor, textColor3, textColor2, textColorDisabled, fontSize: fontSize2 } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: "1.5",
        nodeHeight: "30px",
        nodeWrapperPadding: "3px 0",
        nodeBorderRadius: borderRadiusSmall,
        nodeColorHover: hoverColor,
        nodeColorPressed: pressedColor,
        nodeColorActive: changeColor(primaryColor, { alpha: 0.1 }),
        arrowColor: textColor3,
        nodeTextColor: textColor2,
        nodeTextColorDisabled: textColorDisabled,
        loadingColor: primaryColor,
        dropMarkColor: primaryColor
      };
    };
    const treeDark = {
      name: "Tree",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self(vars) {
        const { primaryColor } = vars;
        const commonSelf = self$4(vars);
        commonSelf.nodeColorActive = changeColor(primaryColor, { alpha: 0.15 });
        return commonSelf;
      }
    };
    const treeSelectDark = {
      name: "TreeSelect",
      common: derived$1,
      peers: {
        Tree: treeDark,
        Empty: emptyDark,
        InternalSelection: internalSelectionDark
      }
    };
    const commonVars = {
      headerFontSize1: "30px",
      headerFontSize2: "22px",
      headerFontSize3: "18px",
      headerFontSize4: "16px",
      headerFontSize5: "16px",
      headerFontSize6: "16px",
      headerMargin1: "28px 0 20px 0",
      headerMargin2: "28px 0 20px 0",
      headerMargin3: "28px 0 20px 0",
      headerMargin4: "28px 0 18px 0",
      headerMargin5: "28px 0 18px 0",
      headerMargin6: "28px 0 18px 0",
      headerPrefixWidth1: "16px",
      headerPrefixWidth2: "16px",
      headerPrefixWidth3: "12px",
      headerPrefixWidth4: "12px",
      headerPrefixWidth5: "12px",
      headerPrefixWidth6: "12px",
      headerBarWidth1: "4px",
      headerBarWidth2: "4px",
      headerBarWidth3: "3px",
      headerBarWidth4: "3px",
      headerBarWidth5: "3px",
      headerBarWidth6: "3px",
      pMargin: "16px 0 16px 0",
      liMargin: ".25em 0 0 0",
      olPadding: "0 0 0 2em",
      ulPadding: "0 0 0 2em"
    };
    const self$3 = (vars) => {
      const { primaryColor, textColor2, borderColor, lineHeight: lineHeight2, fontSize: fontSize2, borderRadiusSmall, dividerColor, fontWeightStrong, textColor1, textColor3, infoColor, warningColor, errorColor, successColor, codeColor } = vars;
      return Object.assign(Object.assign({}, commonVars), { aTextColor: primaryColor, blockquoteTextColor: textColor2, blockquotePrefixColor: borderColor, blockquoteLineHeight: lineHeight2, blockquoteFontSize: fontSize2, codeBorderRadius: borderRadiusSmall, liTextColor: textColor2, liLineHeight: lineHeight2, liFontSize: fontSize2, hrColor: dividerColor, headerFontWeight: fontWeightStrong, headerTextColor: textColor1, pTextColor: textColor2, pTextColor1Depth: textColor1, pTextColor2Depth: textColor2, pTextColor3Depth: textColor3, pLineHeight: lineHeight2, pFontSize: fontSize2, headerBarColor: primaryColor, headerBarColorPrimary: primaryColor, headerBarColorInfo: infoColor, headerBarColorError: errorColor, headerBarColorWarning: warningColor, headerBarColorSuccess: successColor, textColor: textColor2, textColor1Depth: textColor1, textColor2Depth: textColor2, textColor3Depth: textColor3, textColorPrimary: primaryColor, textColorInfo: infoColor, textColorSuccess: successColor, textColorWarning: warningColor, textColorError: errorColor, codeTextColor: textColor2, codeColor, codeBorder: "1px solid #0000" });
    };
    const typographyDark = {
      name: "Typography",
      common: derived$1,
      self: self$3
    };
    const self$2 = (vars) => {
      const { iconColor, primaryColor, errorColor, textColor2, successColor, opacityDisabled, actionColor, borderColor, hoverColor, lineHeight: lineHeight2, borderRadius, fontSize: fontSize2 } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        borderRadius,
        draggerColor: actionColor,
        draggerBorder: `1px dashed ${borderColor}`,
        draggerBorderHover: `1px dashed ${primaryColor}`,
        itemColorHover: hoverColor,
        itemColorHoverError: changeColor(errorColor, {
          alpha: 0.06
        }),
        itemTextColor: textColor2,
        itemTextColorError: errorColor,
        itemTextColorSuccess: successColor,
        itemIconColor: iconColor,
        itemDisabledOpacity: opacityDisabled,
        itemBorderImageCardError: `1px solid ${errorColor}`,
        itemBorderImageCard: `1px solid ${borderColor}`
      };
    };
    const uploadDark = {
      name: "Upload",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Progress: progressDark
      },
      self(vars) {
        const { errorColor } = vars;
        const commonSelf = self$2(vars);
        commonSelf.itemColorHoverError = changeColor(errorColor, {
          alpha: 0.09
        });
        return commonSelf;
      }
    };
    const watermarkDark = {
      name: "Watermark",
      common: derived$1,
      self(vars) {
        const { fontFamily: fontFamily2 } = vars;
        return {
          fontFamily: fontFamily2
        };
      }
    };
    const rowDark = {
      name: "Row",
      common: derived$1
    };
    const imageDark = {
      name: "Image",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      },
      self: (vars) => {
        const { textColor2 } = vars;
        return {
          toolbarIconColor: textColor2,
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
    };
    const commonVariables = {
      extraFontSize: "12px",
      width: "440px"
    };
    const transferDark = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const { iconColorDisabled, iconColor, fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, inputColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, hoverColor } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: "#0000",
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        });
      }
    };
    const skeletonDark = {
      name: "Skeleton",
      common: derived$1,
      self(vars) {
        const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
        return {
          color: "rgba(255, 255, 255, 0.12)",
          colorEnd: "rgba(255, 255, 255, 0.18)",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      }
    };
    const style = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE$1("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE$1("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE$1("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE$1("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE$1("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c("&:focus", [cE$1("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM$1("round", [cE$1("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE$1("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM$1("rubber-band", [cM$1("pressed", [cE$1("rail", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cE$1("rail", [c("&:active", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cM$1("active", [cM$1("pressed", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE$1("rail", [c("&:active", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM$1("active", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE$1("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE$1("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE$1("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM$1("active", [cE$1("rail", "background-color: var(--n-rail-color-active);")]), cM$1("loading", [cE$1("rail", `
 cursor: wait;
 `)]), cM$1("disabled", [cE$1("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
    const switchProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      loading: Boolean,
      defaultValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      round: {
        type: Boolean,
        default: true
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      railStyle: Function,
      rubberBand: {
        type: Boolean,
        default: true
      },
      /** @deprecated */
      onChange: [Function, Array]
    });
    let supportCssMax;
    const NSwitch = /* @__PURE__ */ defineComponent({
      name: "Switch",
      props: switchProps,
      setup(props) {
        if (supportCssMax === void 0) {
          if (typeof CSS !== "undefined") {
            if (typeof CSS.supports !== "undefined") {
              supportCssMax = CSS.supports("width", "max(1px)");
            } else {
              supportCssMax = false;
            }
          } else {
            supportCssMax = true;
          }
        }
        const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
        const themeRef = useTheme("Switch", "-switch", style, switchLight, props, mergedClsPrefixRef);
        const formItem = useFormItem(props);
        const { mergedSizeRef, mergedDisabledRef } = formItem;
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedRef = computed(() => {
          return mergedValueRef.value === props.checkedValue;
        });
        const pressedRef = ref(false);
        const focusedRef = ref(false);
        const mergedRailStyleRef = computed(() => {
          const { railStyle } = props;
          if (!railStyle)
            return void 0;
          return railStyle({ focused: focusedRef.value, checked: checkedRef.value });
        });
        function doUpdateValue(value) {
          const { "onUpdate:value": _onUpdateValue, onChange, onUpdateValue } = props;
          const { nTriggerFormInput, nTriggerFormChange } = formItem;
          if (_onUpdateValue)
            call(_onUpdateValue, value);
          if (onUpdateValue)
            call(onUpdateValue, value);
          if (onChange)
            call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doFocus() {
          const { nTriggerFormFocus } = formItem;
          nTriggerFormFocus();
        }
        function doBlur() {
          const { nTriggerFormBlur } = formItem;
          nTriggerFormBlur();
        }
        function handleClick() {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
        }
        function handleFocus() {
          focusedRef.value = true;
          doFocus();
        }
        function handleBlur() {
          focusedRef.value = false;
          doBlur();
          pressedRef.value = false;
        }
        function handleKeyup(e) {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (e.key === " ") {
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
            pressedRef.value = false;
          }
        }
        function handleKeydown(e) {
          if (props.loading || mergedDisabledRef.value)
            return;
          if (e.key === " ") {
            e.preventDefault();
            pressedRef.value = true;
          }
        }
        const cssVarsRef = computed(() => {
          const { value: size2 } = mergedSizeRef;
          const { self: { opacityDisabled, railColor, railColorActive, buttonBoxShadow, buttonColor, boxShadowFocus, loadingColor, textColor, iconColor, [createKey("buttonHeight", size2)]: buttonHeight, [createKey("buttonWidth", size2)]: buttonWidth, [createKey("buttonWidthPressed", size2)]: buttonWidthPressed, [createKey("railHeight", size2)]: railHeight, [createKey("railWidth", size2)]: railWidth, [createKey("railBorderRadius", size2)]: railBorderRadius, [createKey("buttonBorderRadius", size2)]: buttonBorderRadius }, common: { cubicBezierEaseInOut: cubicBezierEaseInOut2 } } = themeRef.value;
          let offset;
          let height;
          let width;
          if (supportCssMax) {
            offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
            height = `max(${railHeight}, ${buttonHeight})`;
            width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
          } else {
            offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
            height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
            width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
          }
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-color": buttonColor,
            "--n-button-width": buttonWidth,
            "--n-button-width-pressed": buttonWidthPressed,
            "--n-button-height": buttonHeight,
            "--n-height": height,
            "--n-offset": offset,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-border-radius": railBorderRadius,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-height": railHeight,
            "--n-rail-width": railWidth,
            "--n-width": width,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", computed(() => {
          return mergedSizeRef.value[0];
        }), cssVarsRef, props) : void 0;
        return {
          handleClick,
          handleBlur,
          handleFocus,
          handleKeyup,
          handleKeydown,
          mergedRailStyle: mergedRailStyleRef,
          pressed: pressedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          checked: checkedRef,
          mergedDisabled: mergedDisabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const { mergedClsPrefix, mergedDisabled, checked, mergedRailStyle, onRender, $slots } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const { checked: checkedSlot, unchecked: uncheckedSlot, icon: iconSlot, "checked-icon": checkedIconSlot, "unchecked-icon": uncheckedIconSlot } = $slots;
        const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
        return h(
          "div",
          { role: "switch", "aria-checked": checked, class: [
            `${mergedClsPrefix}-switch`,
            this.themeClass,
            hasIcon && `${mergedClsPrefix}-switch--icon`,
            checked && `${mergedClsPrefix}-switch--active`,
            mergedDisabled && `${mergedClsPrefix}-switch--disabled`,
            this.round && `${mergedClsPrefix}-switch--round`,
            this.loading && `${mergedClsPrefix}-switch--loading`,
            this.pressed && `${mergedClsPrefix}-switch--pressed`,
            this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`
          ], tabindex: !this.mergedDisabled ? 0 : void 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
          h(
            "div",
            { class: `${mergedClsPrefix}-switch__rail`, "aria-hidden": "true", style: mergedRailStyle },
            resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
              if (checkedSlotChildren || uncheckedSlotChildren) {
                return h(
                  "div",
                  { "aria-hidden": true, class: `${mergedClsPrefix}-switch__children-placeholder` },
                  h(
                    "div",
                    { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                    h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                    checkedSlotChildren
                  ),
                  h(
                    "div",
                    { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                    h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                    uncheckedSlotChildren
                  )
                );
              }
              return null;
            })),
            h(
              "div",
              { class: `${mergedClsPrefix}-switch__button` },
              resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
                return h(NIconSwitchTransition, null, {
                  default: () => this.loading ? h(NBaseLoading, { key: "loading", clsPrefix: mergedClsPrefix, strokeWidth: 20 }) : this.checked && (checkedIcon || icon) ? h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: checkedIcon ? "checked-icon" : "icon" }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: uncheckedIcon ? "unchecked-icon" : "icon" }, uncheckedIcon || icon) : null
                });
              }))),
              resolveWrappedSlot(checkedSlot, (children) => children && h("div", { key: "checked", class: `${mergedClsPrefix}-switch__checked` }, children)),
              resolveWrappedSlot(uncheckedSlot, (children) => children && h("div", { key: "unchecked", class: `${mergedClsPrefix}-switch__unchecked` }, children))
            )
          )
        );
      }
    });
    const self$1 = () => ({});
    const equationDark = {
      name: "Equation",
      common: derived$1,
      self: self$1
    };
    const darkTheme = {
      name: "dark",
      common: derived$1,
      Alert: alertDark,
      Anchor: anchorDark,
      AutoComplete: autoCompleteDark,
      Avatar: avatarDark,
      AvatarGroup: avatarGroupDark,
      BackTop: backTopDark,
      Badge: badgeDark,
      Breadcrumb: breadcrumbDark,
      Button: buttonDark,
      ButtonGroup: buttonGroupDark,
      Calendar: calendarDark,
      Card: cardDark,
      Carousel: carouselDark,
      Cascader: cascaderDark,
      Checkbox: checkboxDark,
      Code: codeDark,
      Collapse: collapseDark,
      CollapseTransition: collapseTransitionDark,
      ColorPicker: colorPickerDark,
      DataTable: dataTableDark,
      DatePicker: datePickerDark,
      Descriptions: descriptionsDark,
      Dialog: dialogDark,
      Divider: dividerDark,
      Drawer: drawerDark,
      Dropdown: dropdownDark,
      DynamicInput: dynamicInputDark,
      DynamicTags: dynamicTagsDark,
      Element: elementDark,
      Empty: emptyDark,
      Ellipsis: ellipsisDark,
      Equation: equationDark,
      Form: formItemDark,
      GradientText: gradientTextDark,
      Icon: iconDark$1,
      IconWrapper: iconDark,
      Image: imageDark,
      Input: inputDark,
      InputNumber: inputNumberDark,
      LegacyTransfer: transferDark,
      Layout: layoutDark,
      List: listDark$1,
      LoadingBar: loadingBarDark,
      Log: logDark,
      Menu: menuDark,
      Mention: listDark,
      Message: messageDark,
      Modal: modalDark,
      Notification: notificationDark,
      PageHeader: pageHeaderDark,
      Pagination: paginationDark,
      Popconfirm: popconfirmDark,
      Popover: popoverDark,
      Popselect: popselect,
      Progress: progressDark,
      Radio: radioDark,
      Rate: rateDark,
      Result: resultDark,
      Row: rowDark,
      Scrollbar: scrollbarDark,
      Select: selectDark,
      Skeleton: skeletonDark,
      Slider: sliderDark,
      Space: spaceDark,
      Spin: spinDark,
      Statistic: statisticDark,
      Steps: stepsDark,
      Switch: switchDark,
      Table: tableDark,
      Tabs: tabsDark,
      Tag: tagDark,
      Thing: thingDark,
      TimePicker: timePickerDark,
      Timeline: timelineDark,
      Tooltip: tooltipDark,
      Transfer: transferDark$1,
      Tree: treeDark,
      TreeSelect: treeSelectDark,
      Typography: typographyDark,
      Upload: uploadDark,
      Watermark: watermarkDark
    };
    const _imports_0 = "/logo.png";
    var Wb = Object.defineProperty;
    var qb = (n3, e, t) => e in n3 ? Wb(n3, e, { enumerable: true, configurable: true, writable: true, value: t }) : n3[e] = t;
    var Ge = (n3, e, t) => qb(n3, typeof e != "symbol" ? e + "" : e, t);
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function At(n3) {
      this.content = n3;
    }
    At.prototype = {
      constructor: At,
      find: function(n3) {
        for (var e = 0; e < this.content.length; e += 2)
          if (this.content[e] === n3) return e;
        return -1;
      },
      // :: (string)  ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(n3) {
        var e = this.find(n3);
        return e == -1 ? void 0 : this.content[e + 1];
      },
      // :: (string, any, ?string)  OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(n3, e, t) {
        var r = t && t != n3 ? this.remove(t) : this, o = r.find(n3), i = r.content.slice();
        return o == -1 ? i.push(t || n3, e) : (i[o + 1] = e, t && (i[o] = t)), new At(i);
      },
      // :: (string)  OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(n3) {
        var e = this.find(n3);
        if (e == -1) return this;
        var t = this.content.slice();
        return t.splice(e, 2), new At(t);
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(n3, e) {
        return new At([n3, e].concat(this.remove(n3).content));
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(n3, e) {
        var t = this.remove(n3).content.slice();
        return t.push(n3, e), new At(t);
      },
      // :: (string, string, any)  OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(n3, e, t) {
        var r = this.remove(e), o = r.content.slice(), i = r.find(n3);
        return o.splice(i == -1 ? o.length : i, 0, e, t), new At(o);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(n3) {
        for (var e = 0; e < this.content.length; e += 2)
          n3(this.content[e], this.content[e + 1]);
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(n3) {
        return n3 = At.from(n3), n3.size ? new At(n3.content.concat(this.subtract(n3).content)) : this;
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(n3) {
        return n3 = At.from(n3), n3.size ? new At(this.subtract(n3).content.concat(n3.content)) : this;
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(n3) {
        var e = this;
        n3 = At.from(n3);
        for (var t = 0; t < n3.content.length; t += 2)
          e = e.remove(n3.content[t]);
        return e;
      },
      // :: ()  Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var n3 = {};
        return this.forEach(function(e, t) {
          n3[e] = t;
        }), n3;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    At.from = function(n3) {
      if (n3 instanceof At) return n3;
      var e = [];
      if (n3) for (var t in n3) e.push(t, n3[t]);
      return new At(e);
    };
    function Ff(n3, e, t) {
      for (let r = 0; ; r++) {
        if (r == n3.childCount || r == e.childCount)
          return n3.childCount == e.childCount ? null : t;
        let o = n3.child(r), i = e.child(r);
        if (o == i) {
          t += o.nodeSize;
          continue;
        }
        if (!o.sameMarkup(i))
          return t;
        if (o.isText && o.text != i.text) {
          for (let s = 0; o.text[s] == i.text[s]; s++)
            t++;
          return t;
        }
        if (o.content.size || i.content.size) {
          let s = Ff(o.content, i.content, t + 1);
          if (s != null)
            return s;
        }
        t += o.nodeSize;
      }
    }
    function zf(n3, e, t, r) {
      for (let o = n3.childCount, i = e.childCount; ; ) {
        if (o == 0 || i == 0)
          return o == i ? null : { a: t, b: r };
        let s = n3.child(--o), a = e.child(--i), l = s.nodeSize;
        if (s == a) {
          t -= l, r -= l;
          continue;
        }
        if (!s.sameMarkup(a))
          return { a: t, b: r };
        if (s.isText && s.text != a.text) {
          let c2 = 0, u = Math.min(s.text.length, a.text.length);
          for (; c2 < u && s.text[s.text.length - c2 - 1] == a.text[a.text.length - c2 - 1]; )
            c2++, t--, r--;
          return { a: t, b: r };
        }
        if (s.content.size || a.content.size) {
          let c2 = zf(s.content, a.content, t - 1, r - 1);
          if (c2)
            return c2;
        }
        t -= l, r -= l;
      }
    }
    class O {
      /**
      @internal
      */
      constructor(e, t) {
        if (this.content = e, this.size = t || 0, t == null)
          for (let r = 0; r < e.length; r++)
            this.size += e[r].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(e, t, r, o = 0, i) {
        for (let s = 0, a = 0; a < t; s++) {
          let l = this.content[s], c2 = a + l.nodeSize;
          if (c2 > e && r(l, o + a, i || null, s) !== false && l.content.size) {
            let u = a + 1;
            l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, t - u), r, o + u);
          }
          a = c2;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(e) {
        this.nodesBetween(0, this.size, e);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(e, t, r, o) {
        let i = "", s = true;
        return this.nodesBetween(e, t, (a, l) => {
          let c2 = a.isText ? a.text.slice(Math.max(e, l) - l, t - l) : a.isLeaf ? o ? typeof o == "function" ? o(a) : o : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
          a.isBlock && (a.isLeaf && c2 || a.isTextblock) && r && (s ? s = false : i += r), i += c2;
        }, 0), i;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(e) {
        if (!e.size)
          return this;
        if (!this.size)
          return e;
        let t = this.lastChild, r = e.firstChild, o = this.content.slice(), i = 0;
        for (t.isText && t.sameMarkup(r) && (o[o.length - 1] = t.withText(t.text + r.text), i = 1); i < e.content.length; i++)
          o.push(e.content[i]);
        return new O(o, this.size + e.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(e, t = this.size) {
        if (e == 0 && t == this.size)
          return this;
        let r = [], o = 0;
        if (t > e)
          for (let i = 0, s = 0; s < t; i++) {
            let a = this.content[i], l = s + a.nodeSize;
            l > e && ((s < e || l > t) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, t - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, t - s - 1))), r.push(a), o += a.nodeSize), s = l;
          }
        return new O(r, o);
      }
      /**
      @internal
      */
      cutByIndex(e, t) {
        return e == t ? O.empty : e == 0 && t == this.content.length ? this : new O(this.content.slice(e, t));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(e, t) {
        let r = this.content[e];
        if (r == t)
          return this;
        let o = this.content.slice(), i = this.size + t.nodeSize - r.nodeSize;
        return o[e] = t, new O(o, i);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(e) {
        return new O([e].concat(this.content), this.size + e.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(e) {
        return new O(this.content.concat(e), this.size + e.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(e) {
        if (this.content.length != e.content.length)
          return false;
        for (let t = 0; t < this.content.length; t++)
          if (!this.content[t].eq(e.content[t]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(e) {
        let t = this.content[e];
        if (!t)
          throw new RangeError("Index " + e + " out of range for " + this);
        return t;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content[e] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        for (let t = 0, r = 0; t < this.content.length; t++) {
          let o = this.content[t];
          e(o, r, t), r += o.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(e, t = 0) {
        return Ff(this, e, t);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(e, t = this.size, r = e.size) {
        return zf(this, e, t, r);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(e, t = -1) {
        if (e == 0)
          return ms(0, e);
        if (e == this.size)
          return ms(this.content.length, e);
        if (e > this.size || e < 0)
          throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let r = 0, o = 0; ; r++) {
          let i = this.child(r), s = o + i.nodeSize;
          if (s >= e)
            return s == e || t > 0 ? ms(r + 1, s) : ms(r, o);
          o = s;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((e) => e.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(e, t) {
        if (!t)
          return O.empty;
        if (!Array.isArray(t))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new O(t.map(e.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(e) {
        if (!e.length)
          return O.empty;
        let t, r = 0;
        for (let o = 0; o < e.length; o++) {
          let i = e[o];
          r += i.nodeSize, o && i.isText && e[o - 1].sameMarkup(i) ? (t || (t = e.slice(0, o)), t[t.length - 1] = i.withText(t[t.length - 1].text + i.text)) : t && t.push(i);
        }
        return new O(t || e, r);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(e) {
        if (!e)
          return O.empty;
        if (e instanceof O)
          return e;
        if (Array.isArray(e))
          return this.fromArray(e);
        if (e.attrs)
          return new O([e], e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }
    O.empty = new O([], 0);
    const yl = { index: 0, offset: 0 };
    function ms(n3, e) {
      return yl.index = n3, yl.offset = e, yl;
    }
    function Qs(n3, e) {
      if (n3 === e)
        return true;
      if (!(n3 && typeof n3 == "object") || !(e && typeof e == "object"))
        return false;
      let t = Array.isArray(n3);
      if (Array.isArray(e) != t)
        return false;
      if (t) {
        if (n3.length != e.length)
          return false;
        for (let r = 0; r < n3.length; r++)
          if (!Qs(n3[r], e[r]))
            return false;
      } else {
        for (let r in n3)
          if (!(r in e) || !Qs(n3[r], e[r]))
            return false;
        for (let r in e)
          if (!(r in n3))
            return false;
      }
      return true;
    }
    let Ye = class oc {
      /**
      @internal
      */
      constructor(e, t) {
        this.type = e, this.attrs = t;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(e) {
        let t, r = false;
        for (let o = 0; o < e.length; o++) {
          let i = e[o];
          if (this.eq(i))
            return e;
          if (this.type.excludes(i.type))
            t || (t = e.slice(0, o));
          else {
            if (i.type.excludes(this.type))
              return e;
            !r && i.type.rank > this.type.rank && (t || (t = e.slice(0, o)), t.push(this), r = true), t && t.push(i);
          }
        }
        return t || (t = e.slice()), r || t.push(this), t;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(e) {
        for (let t = 0; t < e.length; t++)
          if (this.eq(e[t]))
            return e.slice(0, t).concat(e.slice(t + 1));
        return e;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(e) {
        for (let t = 0; t < e.length; t++)
          if (this.eq(e[t]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(e) {
        return this == e || this.type == e.type && Qs(this.attrs, e.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let t in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return e;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(e, t) {
        if (!t)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let r = e.marks[t.type];
        if (!r)
          throw new RangeError(`There is no mark type ${t.type} in this schema`);
        let o = r.create(t.attrs);
        return r.checkAttrs(o.attrs), o;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(e, t) {
        if (e == t)
          return true;
        if (e.length != t.length)
          return false;
        for (let r = 0; r < e.length; r++)
          if (!e[r].eq(t[r]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
          return oc.none;
        if (e instanceof oc)
          return [e];
        let t = e.slice();
        return t.sort((r, o) => r.type.rank - o.type.rank), t;
      }
    };
    Ye.none = [];
    class Ai extends Error {
    }
    class I {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragmenti.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(e, t, r) {
        this.content = e, this.openStart = t, this.openEnd = r;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(e, t) {
        let r = Uf(this.content, e + this.openStart, t);
        return r && new I(r, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(e, t) {
        return new I(Hf(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let e = { content: this.content.toJSON() };
        return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(e, t) {
        if (!t)
          return I.empty;
        let r = t.openStart || 0, o = t.openEnd || 0;
        if (typeof r != "number" || typeof o != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new I(O.fromJSON(e, t.content), r, o);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(e, t = true) {
        let r = 0, o = 0;
        for (let i = e.firstChild; i && !i.isLeaf && (t || !i.type.spec.isolating); i = i.firstChild)
          r++;
        for (let i = e.lastChild; i && !i.isLeaf && (t || !i.type.spec.isolating); i = i.lastChild)
          o++;
        return new I(e, r, o);
      }
    }
    I.empty = new I(O.empty, 0, 0);
    function Hf(n3, e, t) {
      let { index: r, offset: o } = n3.findIndex(e), i = n3.maybeChild(r), { index: s, offset: a } = n3.findIndex(t);
      if (o == e || i.isText) {
        if (a != t && !n3.child(s).isText)
          throw new RangeError("Removing non-flat range");
        return n3.cut(0, e).append(n3.cut(t));
      }
      if (r != s)
        throw new RangeError("Removing non-flat range");
      return n3.replaceChild(r, i.copy(Hf(i.content, e - o - 1, t - o - 1)));
    }
    function Uf(n3, e, t, r) {
      let { index: o, offset: i } = n3.findIndex(e), s = n3.maybeChild(o);
      if (i == e || s.isText)
        return n3.cut(0, e).append(t).append(n3.cut(e));
      let a = Uf(s.content, e - i - 1, t);
      return a && n3.replaceChild(o, s.copy(a));
    }
    function ty(n3, e, t) {
      if (t.openStart > n3.depth)
        throw new Ai("Inserted content deeper than insertion position");
      if (n3.depth - t.openStart != e.depth - t.openEnd)
        throw new Ai("Inconsistent open depths");
      return Vf(n3, e, t, 0);
    }
    function Vf(n3, e, t, r) {
      let o = n3.index(r), i = n3.node(r);
      if (o == e.index(r) && r < n3.depth - t.openStart) {
        let s = Vf(n3, e, t, r + 1);
        return i.copy(i.content.replaceChild(o, s));
      } else if (t.content.size)
        if (!t.openStart && !t.openEnd && n3.depth == r && e.depth == r) {
          let s = n3.parent, a = s.content;
          return no(s, a.cut(0, n3.parentOffset).append(t.content).append(a.cut(e.parentOffset)));
        } else {
          let { start: s, end: a } = ny(t, n3);
          return no(i, qf(n3, s, a, e, r));
        }
      else return no(i, ea(n3, e, r));
    }
    function Wf(n3, e) {
      if (!e.type.compatibleContent(n3.type))
        throw new Ai("Cannot join " + e.type.name + " onto " + n3.type.name);
    }
    function ic(n3, e, t) {
      let r = n3.node(t);
      return Wf(r, e.node(t)), r;
    }
    function to(n3, e) {
      let t = e.length - 1;
      t >= 0 && n3.isText && n3.sameMarkup(e[t]) ? e[t] = n3.withText(e[t].text + n3.text) : e.push(n3);
    }
    function vi(n3, e, t, r) {
      let o = (e || n3).node(t), i = 0, s = e ? e.index(t) : o.childCount;
      n3 && (i = n3.index(t), n3.depth > t ? i++ : n3.textOffset && (to(n3.nodeAfter, r), i++));
      for (let a = i; a < s; a++)
        to(o.child(a), r);
      e && e.depth == t && e.textOffset && to(e.nodeBefore, r);
    }
    function no(n3, e) {
      return n3.type.checkContent(e), n3.copy(e);
    }
    function qf(n3, e, t, r, o) {
      let i = n3.depth > o && ic(n3, e, o + 1), s = r.depth > o && ic(t, r, o + 1), a = [];
      return vi(null, n3, o, a), i && s && e.index(o) == t.index(o) ? (Wf(i, s), to(no(i, qf(n3, e, t, r, o + 1)), a)) : (i && to(no(i, ea(n3, e, o + 1)), a), vi(e, t, o, a), s && to(no(s, ea(t, r, o + 1)), a)), vi(r, null, o, a), new O(a);
    }
    function ea(n3, e, t) {
      let r = [];
      if (vi(null, n3, t, r), n3.depth > t) {
        let o = ic(n3, e, t + 1);
        to(no(o, ea(n3, e, t + 1)), r);
      }
      return vi(e, null, t, r), new O(r);
    }
    function ny(n3, e) {
      let t = e.depth - n3.openStart, o = e.node(t).copy(n3.content);
      for (let i = t - 1; i >= 0; i--)
        o = e.node(i).copy(O.from(o));
      return {
        start: o.resolveNoCache(n3.openStart + t),
        end: o.resolveNoCache(o.content.size - n3.openEnd - t)
      };
    }
    class Ri {
      /**
      @internal
      */
      constructor(e, t, r) {
        this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parenttext nodes are flat in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(e) {
        return this.path[this.resolveDepth(e) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(e) {
        return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(e) {
        return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(e) {
        return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(e) {
        if (e = this.resolveDepth(e), !e)
          throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let e = this.parent, t = this.index(this.depth);
        if (t == e.childCount)
          return null;
        let r = this.pos - this.path[this.path.length - 1], o = e.child(t);
        return r ? e.child(t).cut(r) : o;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
        return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(e, t) {
        t = this.resolveDepth(t);
        let r = this.path[t * 3], o = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
        for (let i = 0; i < e; i++)
          o += r.child(i).nodeSize;
        return o;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let e = this.parent, t = this.index();
        if (e.content.size == 0)
          return Ye.none;
        if (this.textOffset)
          return e.child(t).marks;
        let r = e.maybeChild(t - 1), o = e.maybeChild(t);
        if (!r) {
          let a = r;
          r = o, o = a;
        }
        let i = r.marks;
        for (var s = 0; s < i.length; s++)
          i[s].type.spec.inclusive === false && (!o || !i[s].isInSet(o.marks)) && (i = i[s--].removeFromSet(i));
        return i;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross(e) {
        let t = this.parent.maybeChild(this.index());
        if (!t || !t.isInline)
          return null;
        let r = t.marks, o = e.parent.maybeChild(e.index());
        for (var i = 0; i < r.length; i++)
          r[i].type.spec.inclusive === false && (!o || !r[i].isInSet(o.marks)) && (r = r[i--].removeFromSet(r));
        return r;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(e) {
        for (let t = this.depth; t > 0; t--)
          if (this.start(t) <= e && this.end(t) >= e)
            return t;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(e = this, t) {
        if (e.pos < this.pos)
          return e.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
          if (e.pos <= this.end(r) && (!t || t(this.node(r))))
            return new ta(this, e, r);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(e) {
        return e.pos > this.pos ? e : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(e) {
        return e.pos < this.pos ? e : this;
      }
      /**
      @internal
      */
      toString() {
        let e = "";
        for (let t = 1; t <= this.depth; t++)
          e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
        return e + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(e, t) {
        if (!(t >= 0 && t <= e.content.size))
          throw new RangeError("Position " + t + " out of range");
        let r = [], o = 0, i = t;
        for (let s = e; ; ) {
          let { index: a, offset: l } = s.content.findIndex(i), c2 = i - l;
          if (r.push(s, a, o + l), !c2 || (s = s.child(a), s.isText))
            break;
          i = c2 - 1, o += l + 1;
        }
        return new Ri(t, r, i);
      }
      /**
      @internal
      */
      static resolveCached(e, t) {
        let r = ud.get(e);
        if (r)
          for (let i = 0; i < r.elts.length; i++) {
            let s = r.elts[i];
            if (s.pos == t)
              return s;
          }
        else
          ud.set(e, r = new ry());
        let o = r.elts[r.i] = Ri.resolve(e, t);
        return r.i = (r.i + 1) % oy, o;
      }
    }
    class ry {
      constructor() {
        this.elts = [], this.i = 0;
      }
    }
    const oy = 12, ud = /* @__PURE__ */ new WeakMap();
    class ta {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor(e, t, r) {
        this.$from = e, this.$to = t, this.depth = r;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    }
    const iy = /* @__PURE__ */ Object.create(null);
    let Dr = class sc {
      /**
      @internal
      */
      constructor(e, t, r, o = Ye.none) {
        this.type = e, this.attrs = t, this.marks = o, this.content = r || O.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(e) {
        return this.content.child(e);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content.maybeChild(e);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        this.content.forEach(e);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(e, t, r, o = 0) {
        this.content.nodesBetween(e, t, r, o, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(e) {
        this.nodesBetween(0, this.content.size, e);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(e, t, r, o) {
        return this.content.textBetween(e, t, r, o);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(e, t, r) {
        return this.type == e && Qs(this.attrs, t || e.defaultAttrs || iy) && Ye.sameSet(this.marks, r || Ye.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(e = null) {
        return e == this.content ? this : new sc(this.type, this.attrs, e, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(e) {
        return e == this.marks ? this : new sc(this.type, this.attrs, this.content, e);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(e, t = this.content.size) {
        return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(e, t = this.content.size, r = false) {
        if (e == t)
          return I.empty;
        let o = this.resolve(e), i = this.resolve(t), s = r ? 0 : o.sharedDepth(t), a = o.start(s), c2 = o.node(s).content.cut(o.pos - a, i.pos - a);
        return new I(c2, o.depth - s, i.depth - s);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(e, t, r) {
        return ty(this.resolve(e), this.resolve(t), r);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(e) {
        for (let t = this; ; ) {
          let { index: r, offset: o } = t.content.findIndex(e);
          if (t = t.maybeChild(r), !t)
            return null;
          if (o == e || t.isText)
            return t;
          e -= o + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(e) {
        let { index: t, offset: r } = this.content.findIndex(e);
        return { node: this.content.maybeChild(t), index: t, offset: r };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(e) {
        if (e == 0)
          return { node: null, index: 0, offset: 0 };
        let { index: t, offset: r } = this.content.findIndex(e);
        if (r < e)
          return { node: this.content.child(t), index: t, offset: r };
        let o = this.content.child(t - 1);
        return { node: o, index: t - 1, offset: r - o.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(e) {
        return Ri.resolveCached(this, e);
      }
      /**
      @internal
      */
      resolveNoCache(e) {
        return Ri.resolve(this, e);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(e, t, r) {
        let o = false;
        return t > e && this.nodesBetween(e, t, (i) => (r.isInSet(i.marks) && (o = true), !o)), o;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Kf(this.marks, e);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(e) {
        let t = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!t)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return t;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(e, t, r = O.empty, o = 0, i = r.childCount) {
        let s = this.contentMatchAt(e).matchFragment(r, o, i), a = s && s.matchFragment(this.content, t);
        if (!a || !a.validEnd)
          return false;
        for (let l = o; l < i; l++)
          if (!this.type.allowsMarks(r.child(l).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(e, t, r, o) {
        if (o && !this.type.allowsMarks(o))
          return false;
        let i = this.contentMatchAt(e).matchType(r), s = i && i.matchFragment(this.content, t);
        return s ? s.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
        let e = Ye.none;
        for (let t = 0; t < this.marks.length; t++) {
          let r = this.marks[t];
          r.type.checkAttrs(r.attrs), e = r.addToSet(e);
        }
        if (!Ye.sameSet(e, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
        this.content.forEach((t) => t.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let t in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(e, t) {
        if (!t)
          throw new RangeError("Invalid input for Node.fromJSON");
        let r;
        if (t.marks) {
          if (!Array.isArray(t.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          r = t.marks.map(e.markFromJSON);
        }
        if (t.type == "text") {
          if (typeof t.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return e.text(t.text, r);
        }
        let o = O.fromJSON(e, t.content), i = e.nodeType(t.type).create(t.attrs, o, r);
        return i.type.checkAttrs(i.attrs), i;
      }
    };
    Dr.prototype.text = void 0;
    class na extends Dr {
      /**
      @internal
      */
      constructor(e, t, r, o) {
        if (super(e, t, null, o), !r)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = r;
      }
      toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Kf(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(e, t) {
        return this.text.slice(e, t);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(e) {
        return e == this.marks ? this : new na(this.type, this.attrs, this.text, e);
      }
      withText(e) {
        return e == this.text ? this : new na(this.type, this.attrs, e, this.marks);
      }
      cut(e = 0, t = this.text.length) {
        return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
      }
      eq(e) {
        return this.sameMarkup(e) && this.text == e.text;
      }
      toJSON() {
        let e = super.toJSON();
        return e.text = this.text, e;
      }
    }
    function Kf(n3, e) {
      for (let t = n3.length - 1; t >= 0; t--)
        e = n3[t].type.name + "(" + e + ")";
      return e;
    }
    class co {
      /**
      @internal
      */
      constructor(e) {
        this.validEnd = e, this.next = [], this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(e, t) {
        let r = new sy(e, t);
        if (r.next == null)
          return co.empty;
        let o = Gf(r);
        r.next && r.err("Unexpected trailing text");
        let i = fy(py(o));
        return hy(i, r), i;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(e) {
        for (let t = 0; t < this.next.length; t++)
          if (this.next[t].type == e)
            return this.next[t].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(e, t = 0, r = e.childCount) {
        let o = this;
        for (let i = t; o && i < r; i++)
          o = o.matchType(e.child(i).type);
        return o;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
          let { type: t } = this.next[e];
          if (!(t.isText || t.hasRequiredAttrs()))
            return t;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(e) {
        for (let t = 0; t < this.next.length; t++)
          for (let r = 0; r < e.next.length; r++)
            if (this.next[t].type == e.next[r].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(e, t = false, r = 0) {
        let o = [this];
        function i(s, a) {
          let l = s.matchFragment(e, r);
          if (l && (!t || l.validEnd))
            return O.from(a.map((c2) => c2.createAndFill()));
          for (let c2 = 0; c2 < s.next.length; c2++) {
            let { type: u, next: d } = s.next[c2];
            if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(d) == -1) {
              o.push(d);
              let p2 = i(d, a.concat(u));
              if (p2)
                return p2;
            }
          }
          return null;
        }
        return i(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
          if (this.wrapCache[r] == e)
            return this.wrapCache[r + 1];
        let t = this.computeWrapping(e);
        return this.wrapCache.push(e, t), t;
      }
      /**
      @internal
      */
      computeWrapping(e) {
        let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
        for (; r.length; ) {
          let o = r.shift(), i = o.match;
          if (i.matchType(e)) {
            let s = [];
            for (let a = o; a.type; a = a.via)
              s.push(a.type);
            return s.reverse();
          }
          for (let s = 0; s < i.next.length; s++) {
            let { type: a, next: l } = i.next[s];
            !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in t) && (!o.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: o }), t[a.name] = true);
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(e) {
        if (e >= this.next.length)
          throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e];
      }
      /**
      @internal
      */
      toString() {
        let e = [];
        function t(r) {
          e.push(r);
          for (let o = 0; o < r.next.length; o++)
            e.indexOf(r.next[o].next) == -1 && t(r.next[o].next);
        }
        return t(this), e.map((r, o) => {
          let i = o + (r.validEnd ? "*" : " ") + " ";
          for (let s = 0; s < r.next.length; s++)
            i += (s ? ", " : "") + r.next[s].type.name + "->" + e.indexOf(r.next[s].next);
          return i;
        }).join(`
`);
      }
    }
    co.empty = new co(true);
    class sy {
      constructor(e, t) {
        this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(e) {
        return this.next == e && (this.pos++ || true);
      }
      err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')");
      }
    }
    function Gf(n3) {
      let e = [];
      do
        e.push(ay(n3));
      while (n3.eat("|"));
      return e.length == 1 ? e[0] : { type: "choice", exprs: e };
    }
    function ay(n3) {
      let e = [];
      do
        e.push(ly(n3));
      while (n3.next && n3.next != ")" && n3.next != "|");
      return e.length == 1 ? e[0] : { type: "seq", exprs: e };
    }
    function ly(n3) {
      let e = dy(n3);
      for (; ; )
        if (n3.eat("+"))
          e = { type: "plus", expr: e };
        else if (n3.eat("*"))
          e = { type: "star", expr: e };
        else if (n3.eat("?"))
          e = { type: "opt", expr: e };
        else if (n3.eat("{"))
          e = cy(n3, e);
        else
          break;
      return e;
    }
    function dd(n3) {
      /\D/.test(n3.next) && n3.err("Expected number, got '" + n3.next + "'");
      let e = Number(n3.next);
      return n3.pos++, e;
    }
    function cy(n3, e) {
      let t = dd(n3), r = t;
      return n3.eat(",") && (n3.next != "}" ? r = dd(n3) : r = -1), n3.eat("}") || n3.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
    }
    function uy(n3, e) {
      let t = n3.nodeTypes, r = t[e];
      if (r)
        return [r];
      let o = [];
      for (let i in t) {
        let s = t[i];
        s.isInGroup(e) && o.push(s);
      }
      return o.length == 0 && n3.err("No node type or group '" + e + "' found"), o;
    }
    function dy(n3) {
      if (n3.eat("(")) {
        let e = Gf(n3);
        return n3.eat(")") || n3.err("Missing closing paren"), e;
      } else if (/\W/.test(n3.next))
        n3.err("Unexpected token '" + n3.next + "'");
      else {
        let e = uy(n3, n3.next).map((t) => (n3.inline == null ? n3.inline = t.isInline : n3.inline != t.isInline && n3.err("Mixing inline and block content"), { type: "name", value: t }));
        return n3.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
      }
    }
    function py(n3) {
      let e = [[]];
      return o(i(n3, 0), t()), e;
      function t() {
        return e.push([]) - 1;
      }
      function r(s, a, l) {
        let c2 = { term: l, to: a };
        return e[s].push(c2), c2;
      }
      function o(s, a) {
        s.forEach((l) => l.to = a);
      }
      function i(s, a) {
        if (s.type == "choice")
          return s.exprs.reduce((l, c2) => l.concat(i(c2, a)), []);
        if (s.type == "seq")
          for (let l = 0; ; l++) {
            let c2 = i(s.exprs[l], a);
            if (l == s.exprs.length - 1)
              return c2;
            o(c2, a = t());
          }
        else if (s.type == "star") {
          let l = t();
          return r(a, l), o(i(s.expr, l), l), [r(l)];
        } else if (s.type == "plus") {
          let l = t();
          return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)];
        } else {
          if (s.type == "opt")
            return [r(a)].concat(i(s.expr, a));
          if (s.type == "range") {
            let l = a;
            for (let c2 = 0; c2 < s.min; c2++) {
              let u = t();
              o(i(s.expr, l), u), l = u;
            }
            if (s.max == -1)
              o(i(s.expr, l), l);
            else
              for (let c2 = s.min; c2 < s.max; c2++) {
                let u = t();
                r(l, u), o(i(s.expr, l), u), l = u;
              }
            return [r(l)];
          } else {
            if (s.type == "name")
              return [r(a, void 0, s.value)];
            throw new Error("Unknown expr type");
          }
        }
      }
    }
    function jf(n3, e) {
      return e - n3;
    }
    function pd(n3, e) {
      let t = [];
      return r(e), t.sort(jf);
      function r(o) {
        let i = n3[o];
        if (i.length == 1 && !i[0].term)
          return r(i[0].to);
        t.push(o);
        for (let s = 0; s < i.length; s++) {
          let { term: a, to: l } = i[s];
          !a && t.indexOf(l) == -1 && r(l);
        }
      }
    }
    function fy(n3) {
      let e = /* @__PURE__ */ Object.create(null);
      return t(pd(n3, 0));
      function t(r) {
        let o = [];
        r.forEach((s) => {
          n3[s].forEach(({ term: a, to: l }) => {
            if (!a)
              return;
            let c2;
            for (let u = 0; u < o.length; u++)
              o[u][0] == a && (c2 = o[u][1]);
            pd(n3, l).forEach((u) => {
              c2 || o.push([a, c2 = []]), c2.indexOf(u) == -1 && c2.push(u);
            });
          });
        });
        let i = e[r.join(",")] = new co(r.indexOf(n3.length - 1) > -1);
        for (let s = 0; s < o.length; s++) {
          let a = o[s][1].sort(jf);
          i.next.push({ type: o[s][0], next: e[a.join(",")] || t(a) });
        }
        return i;
      }
    }
    function hy(n3, e) {
      for (let t = 0, r = [n3]; t < r.length; t++) {
        let o = r[t], i = !o.validEnd, s = [];
        for (let a = 0; a < o.next.length; a++) {
          let { type: l, next: c2 } = o.next[a];
          s.push(l.name), i && !(l.isText || l.hasRequiredAttrs()) && (i = false), r.indexOf(c2) == -1 && r.push(c2);
        }
        i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function Jf(n3) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let t in n3) {
        let r = n3[t];
        if (!r.hasDefault)
          return null;
        e[t] = r.default;
      }
      return e;
    }
    function Yf(n3, e) {
      let t = /* @__PURE__ */ Object.create(null);
      for (let r in n3) {
        let o = e && e[r];
        if (o === void 0) {
          let i = n3[r];
          if (i.hasDefault)
            o = i.default;
          else
            throw new RangeError("No value supplied for attribute " + r);
        }
        t[r] = o;
      }
      return t;
    }
    function Xf(n3, e, t, r) {
      for (let o in e)
        if (!(o in n3))
          throw new RangeError(`Unsupported attribute ${o} for ${t} of type ${o}`);
      for (let o in n3) {
        let i = n3[o];
        i.validate && i.validate(e[o]);
      }
    }
    function Zf(n3, e) {
      let t = /* @__PURE__ */ Object.create(null);
      if (e)
        for (let r in e)
          t[r] = new gy(n3, r, e[r]);
      return t;
    }
    let fd = class Qf {
      /**
      @internal
      */
      constructor(e, t, r) {
        this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = Zf(e, r.attrs), this.defaultAttrs = Jf(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == co.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(e) {
        return this.groups.indexOf(e) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let e in this.attrs)
          if (this.attrs[e].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : Yf(this.attrs, e);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(e = null, t, r) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Dr(this, this.computeAttrs(e), O.from(t), Ye.setFrom(r));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(e = null, t, r) {
        return t = O.from(t), this.checkContent(t), new Dr(this, this.computeAttrs(e), t, Ye.setFrom(r));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(e = null, t, r) {
        if (e = this.computeAttrs(e), t = O.from(t), t.size) {
          let s = this.contentMatch.fillBefore(t);
          if (!s)
            return null;
          t = s.append(t);
        }
        let o = this.contentMatch.matchFragment(t), i = o && o.fillBefore(O.empty, true);
        return i ? new Dr(this, e, t.append(i), Ye.setFrom(r)) : null;
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(e) {
        let t = this.contentMatch.matchFragment(e);
        if (!t || !t.validEnd)
          return false;
        for (let r = 0; r < e.childCount; r++)
          if (!this.allowsMarks(e.child(r).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(e) {
        if (!this.validContent(e))
          throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Xf(this.attrs, e, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(e) {
        if (this.markSet == null)
          return true;
        for (let t = 0; t < e.length; t++)
          if (!this.allowsMarkType(e[t].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(e) {
        if (this.markSet == null)
          return e;
        let t;
        for (let r = 0; r < e.length; r++)
          this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
        return t ? t.length ? t : Ye.none : e;
      }
      /**
      @internal
      */
      static compile(e, t) {
        let r = /* @__PURE__ */ Object.create(null);
        e.forEach((i, s) => r[i] = new Qf(i, t, s));
        let o = t.spec.topNode || "doc";
        if (!r[o])
          throw new RangeError("Schema is missing its top node type ('" + o + "')");
        if (!r.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let i in r.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return r;
      }
    };
    function my(n3, e, t) {
      let r = t.split("|");
      return (o) => {
        let i = o === null ? "null" : typeof o;
        if (r.indexOf(i) < 0)
          throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n3}, got ${i}`);
      };
    }
    class gy {
      constructor(e, t, r) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? my(e, t, r.validate) : r.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    }
    class Zi {
      /**
      @internal
      */
      constructor(e, t, r, o) {
        this.name = e, this.rank = t, this.schema = r, this.spec = o, this.attrs = Zf(e, o.attrs), this.excluded = null;
        let i = Jf(this.attrs);
        this.instance = i ? new Ye(this, i) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(e = null) {
        return !e && this.instance ? this.instance : new Ye(this, Yf(this.attrs, e));
      }
      /**
      @internal
      */
      static compile(e, t) {
        let r = /* @__PURE__ */ Object.create(null), o = 0;
        return e.forEach((i, s) => r[i] = new Zi(i, o++, t, s)), r;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(e) {
        for (var t = 0; t < e.length; t++)
          e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
        return e;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(e) {
        for (let t = 0; t < e.length; t++)
          if (e[t].type == this)
            return e[t];
      }
      /**
      @internal
      */
      checkAttrs(e) {
        Xf(this.attrs, e, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(e) {
        return this.excluded.indexOf(e) > -1;
      }
    }
    class eh {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(e) {
        this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
        let t = this.spec = {};
        for (let o in e)
          t[o] = e[o];
        t.nodes = At.from(e.nodes), t.marks = At.from(e.marks || {}), this.nodes = fd.compile(this.spec.nodes, this), this.marks = Zi.compile(this.spec.marks, this);
        let r = /* @__PURE__ */ Object.create(null);
        for (let o in this.nodes) {
          if (o in this.marks)
            throw new RangeError(o + " can not be both a node and a mark");
          let i = this.nodes[o], s = i.spec.content || "", a = i.spec.marks;
          if (i.contentMatch = r[s] || (r[s] = co.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!i.isInline || !i.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = i;
          }
          i.markSet = a == "_" ? null : a ? hd(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null;
        }
        for (let o in this.marks) {
          let i = this.marks[o], s = i.spec.excludes;
          i.excluded = s == null ? [i] : s == "" ? [] : hd(this, s.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(e, t = null, r, o) {
        if (typeof e == "string")
          e = this.nodeType(e);
        else if (e instanceof fd) {
          if (e.schema != this)
            throw new RangeError("Node type from different schema used (" + e.name + ")");
        } else throw new RangeError("Invalid node type: " + e);
        return e.createChecked(t, r, o);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(e, t) {
        let r = this.nodes.text;
        return new na(r, r.defaultAttrs, e, Ye.setFrom(t));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(e, t) {
        return typeof e == "string" && (e = this.marks[e]), e.create(t);
      }
      /**
      Deserialize a node from its JSON representation. This method is
      bound.
      */
      nodeFromJSON(e) {
        return Dr.fromJSON(this, e);
      }
      /**
      Deserialize a mark from its JSON representation. This method is
      bound.
      */
      markFromJSON(e) {
        return Ye.fromJSON(this, e);
      }
      /**
      @internal
      */
      nodeType(e) {
        let t = this.nodes[e];
        if (!t)
          throw new RangeError("Unknown node type: " + e);
        return t;
      }
    }
    function hd(n3, e) {
      let t = [];
      for (let r = 0; r < e.length; r++) {
        let o = e[r], i = n3.marks[o], s = i;
        if (i)
          t.push(i);
        else
          for (let a in n3.marks) {
            let l = n3.marks[a];
            (o == "_" || l.spec.group && l.spec.group.split(" ").indexOf(o) > -1) && t.push(s = l);
          }
        if (!s)
          throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
      }
      return t;
    }
    function by(n3) {
      return n3.tag != null;
    }
    function yy(n3) {
      return n3.style != null;
    }
    class Lr {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(e, t) {
        this.schema = e, this.rules = t, this.tags = [], this.styles = [];
        let r = this.matchedStyles = [];
        t.forEach((o) => {
          if (by(o))
            this.tags.push(o);
          else if (yy(o)) {
            let i = /[^=]*/.exec(o.style)[0];
            r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
          }
        }), this.normalizeLists = !this.tags.some((o) => {
          if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
            return false;
          let i = e.nodes[o.node];
          return i.contentMatch.matchType(i);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(e, t = {}) {
        let r = new gd(this, t, false);
        return r.addAll(e, Ye.none, t.from, t.to), r.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(e, t = {}) {
        let r = new gd(this, t, true);
        return r.addAll(e, Ye.none, t.from, t.to), I.maxOpen(r.finish());
      }
      /**
      @internal
      */
      matchTag(e, t, r) {
        for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
          let i = this.tags[o];
          if (ky(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || t.matchesContext(i.context))) {
            if (i.getAttrs) {
              let s = i.getAttrs(e);
              if (s === false)
                continue;
              i.attrs = s || void 0;
            }
            return i;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(e, t, r, o) {
        for (let i = o ? this.styles.indexOf(o) + 1 : 0; i < this.styles.length; i++) {
          let s = this.styles[i], a = s.style;
          if (!(a.indexOf(e) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
            if (s.getAttrs) {
              let l = s.getAttrs(t);
              if (l === false)
                continue;
              s.attrs = l || void 0;
            }
            return s;
          }
        }
      }
      /**
      @internal
      */
      static schemaRules(e) {
        let t = [];
        function r(o) {
          let i = o.priority == null ? 50 : o.priority, s = 0;
          for (; s < t.length; s++) {
            let a = t[s];
            if ((a.priority == null ? 50 : a.priority) < i)
              break;
          }
          t.splice(s, 0, o);
        }
        for (let o in e.marks) {
          let i = e.marks[o].spec.parseDOM;
          i && i.forEach((s) => {
            r(s = bd(s)), s.mark || s.ignore || s.clearMark || (s.mark = o);
          });
        }
        for (let o in e.nodes) {
          let i = e.nodes[o].spec.parseDOM;
          i && i.forEach((s) => {
            r(s = bd(s)), s.node || s.ignore || s.mark || (s.node = o);
          });
        }
        return t;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new Lr(e, Lr.schemaRules(e)));
      }
    }
    const th = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    }, vy = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    }, nh = { ol: true, ul: true }, Ii = 1, ac = 2, Fs = 4;
    function md(n3, e, t) {
      return e != null ? (e ? Ii : 0) | (e === "full" ? ac : 0) : n3 && n3.whitespace == "pre" ? Ii | ac : t & -5;
    }
    class gs {
      constructor(e, t, r, o, i, s) {
        this.type = e, this.attrs = t, this.marks = r, this.solid = o, this.options = s, this.content = [], this.activeMarks = Ye.none, this.match = i || (s & Fs ? null : e.contentMatch);
      }
      findWrapping(e) {
        if (!this.match) {
          if (!this.type)
            return [];
          let t = this.type.contentMatch.fillBefore(O.from(e));
          if (t)
            this.match = this.type.contentMatch.matchFragment(t);
          else {
            let r = this.type.contentMatch, o;
            return (o = r.findWrapping(e.type)) ? (this.match = r, o) : null;
          }
        }
        return this.match.findWrapping(e.type);
      }
      finish(e) {
        if (!(this.options & Ii)) {
          let r = this.content[this.content.length - 1], o;
          if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
            let i = r;
            r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - o[0].length));
          }
        }
        let t = O.from(this.content);
        return !e && this.match && (t = t.append(this.match.fillBefore(O.empty, true))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
      }
      inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !th.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
      }
    }
    class gd {
      constructor(e, t, r) {
        this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = false;
        let o = t.topNode, i, s = md(null, t.preserveWhitespace, 0) | (r ? Fs : 0);
        o ? i = new gs(o.type, o.attrs, Ye.none, true, t.topMatch || o.type.contentMatch, s) : r ? i = new gs(null, null, Ye.none, true, null, s) : i = new gs(e.schema.topNodeType, null, Ye.none, true, null, s), this.nodes = [i], this.find = t.findPositions, this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(e, t) {
        e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
      }
      addTextNode(e, t) {
        let r = e.nodeValue, o = this.top, i = o.options & ac ? "full" : this.localPreserveWS || (o.options & Ii) > 0;
        if (i === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
          if (i)
            i !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
          else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
            let s = o.content[o.content.length - 1], a = e.previousSibling;
            (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1));
          }
          r && this.insertNode(this.parser.schema.text(r), t), this.findInText(e);
        } else
          this.findInside(e);
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(e, t, r) {
        let o = this.localPreserveWS, i = this.top;
        (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
        let s = e.nodeName.toLowerCase(), a;
        nh.hasOwnProperty(s) && this.parser.normalizeLists && wy(e);
        let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
        e: if (l ? l.ignore : vy.hasOwnProperty(s))
          this.findInside(e), this.ignoreFallback(e, t);
        else if (!l || l.skip || l.closeParent) {
          l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
          let c2, u = this.needsBlock;
          if (th.hasOwnProperty(s))
            i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c2 = true, i.type || (this.needsBlock = true);
          else if (!e.firstChild) {
            this.leafFallback(e, t);
            break e;
          }
          let d = l && l.skip ? t : this.readStyles(e, t);
          d && this.addAll(e, d), c2 && this.sync(i), this.needsBlock = u;
        } else {
          let c2 = this.readStyles(e, t);
          c2 && this.addElementByRule(e, l, c2, l.consuming === false ? a : void 0);
        }
        this.localPreserveWS = o;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(e, t) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
      }
      // Called for ignored nodes
      ignoreFallback(e, t) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(e, t) {
        let r = e.style;
        if (r && r.length)
          for (let o = 0; o < this.parser.matchedStyles.length; o++) {
            let i = this.parser.matchedStyles[o], s = r.getPropertyValue(i);
            if (s)
              for (let a = void 0; ; ) {
                let l = this.parser.matchStyle(i, s, this, a);
                if (!l)
                  break;
                if (l.ignore)
                  return null;
                if (l.clearMark ? t = t.filter((c2) => !l.clearMark(c2)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === false)
                  a = l;
                else
                  break;
              }
          }
        return t;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(e, t, r, o) {
        let i, s;
        if (t.node)
          if (s = this.parser.schema.nodes[t.node], s.isLeaf)
            this.insertNode(s.create(t.attrs), r) || this.leafFallback(e, r);
          else {
            let l = this.enter(s, t.attrs || null, r, t.preserveWhitespace);
            l && (i = true, r = l);
          }
        else {
          let l = this.parser.schema.marks[t.mark];
          r = r.concat(l.create(t.attrs));
        }
        let a = this.top;
        if (s && s.isLeaf)
          this.findInside(e);
        else if (o)
          this.addElement(e, r, o);
        else if (t.getContent)
          this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r));
        else {
          let l = e;
          typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, true), this.addAll(l, r), this.findAround(e, l, false);
        }
        i && this.sync(a) && this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(e, t, r, o) {
        let i = r || 0;
        for (let s = r ? e.childNodes[r] : e.firstChild, a = o == null ? null : e.childNodes[o]; s != a; s = s.nextSibling, ++i)
          this.findAtPoint(e, i), this.addDOM(s, t);
        this.findAtPoint(e, i);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(e, t) {
        let r, o;
        for (let i = this.open; i >= 0; i--) {
          let s = this.nodes[i], a = s.findWrapping(e);
          if (a && (!r || r.length > a.length) && (r = a, o = s, !a.length) || s.solid)
            break;
        }
        if (!r)
          return null;
        this.sync(o);
        for (let i = 0; i < r.length; i++)
          t = this.enterInner(r[i], null, t, false);
        return t;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(e, t) {
        if (e.isInline && this.needsBlock && !this.top.type) {
          let o = this.textblockFromContext();
          o && (t = this.enterInner(o, null, t));
        }
        let r = this.findPlace(e, t);
        if (r) {
          this.closeExtra();
          let o = this.top;
          o.match && (o.match = o.match.matchType(e.type));
          let i = Ye.none;
          for (let s of r.concat(e.marks))
            (o.type ? o.type.allowsMarkType(s.type) : yd(s.type, e.type)) && (i = s.addToSet(i));
          return o.content.push(e.mark(i)), true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(e, t, r, o) {
        let i = this.findPlace(e.create(t), r);
        return i && (i = this.enterInner(e, t, r, true, o)), i;
      }
      // Open a node of the given type
      enterInner(e, t, r, o = false, i) {
        this.closeExtra();
        let s = this.top;
        s.match = s.match && s.match.matchType(e);
        let a = md(e, i, s.options);
        s.options & Fs && s.content.length == 0 && (a |= Fs);
        let l = Ye.none;
        return r = r.filter((c2) => (s.type ? s.type.allowsMarkType(c2.type) : yd(c2.type, e)) ? (l = c2.addToSet(l), false) : true), this.nodes.push(new gs(e, t, l, o, null, a)), this.open++, r;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(e = false) {
        let t = this.nodes.length - 1;
        if (t > this.open) {
          for (; t > this.open; t--)
            this.nodes[t - 1].content.push(this.nodes[t].finish(e));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(e) {
        for (let t = this.open; t >= 0; t--) {
          if (this.nodes[t] == e)
            return this.open = t, true;
          this.localPreserveWS && (this.nodes[t].options |= Ii);
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let t = this.open; t >= 0; t--) {
          let r = this.nodes[t].content;
          for (let o = r.length - 1; o >= 0; o--)
            e += r[o].nodeSize;
          t && e++;
        }
        return e;
      }
      findAtPoint(e, t) {
        if (this.find)
          for (let r = 0; r < this.find.length; r++)
            this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
      }
      findInside(e) {
        if (this.find)
          for (let t = 0; t < this.find.length; t++)
            this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
      }
      findAround(e, t, r) {
        if (e != t && this.find)
          for (let o = 0; o < this.find.length; o++)
            this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && t.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos);
      }
      findInText(e) {
        if (this.find)
          for (let t = 0; t < this.find.length; t++)
            this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
      }
      // Determines whether the given context string matches this context.
      matchesContext(e) {
        if (e.indexOf("|") > -1)
          return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let t = e.split("/"), r = this.options.context, o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1), s = (a, l) => {
          for (; a >= 0; a--) {
            let c2 = t[a];
            if (c2 == "") {
              if (a == t.length - 1 || a == 0)
                continue;
              for (; l >= i; l--)
                if (s(a - 1, l))
                  return true;
              return false;
            } else {
              let u = l > 0 || l == 0 && o ? this.nodes[l].type : r && l >= i ? r.node(l - i).type : null;
              if (!u || u.name != c2 && !u.isInGroup(c2))
                return false;
              l--;
            }
          }
          return true;
        };
        return s(t.length - 1, this.open);
      }
      textblockFromContext() {
        let e = this.options.context;
        if (e)
          for (let t = e.depth; t >= 0; t--) {
            let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
            if (r && r.isTextblock && r.defaultAttrs)
              return r;
          }
        for (let t in this.parser.schema.nodes) {
          let r = this.parser.schema.nodes[t];
          if (r.isTextblock && r.defaultAttrs)
            return r;
        }
      }
    }
    function wy(n3) {
      for (let e = n3.firstChild, t = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && nh.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
      }
    }
    function ky(n3, e) {
      return (n3.matches || n3.msMatchesSelector || n3.webkitMatchesSelector || n3.mozMatchesSelector).call(n3, e);
    }
    function bd(n3) {
      let e = {};
      for (let t in n3)
        e[t] = n3[t];
      return e;
    }
    function yd(n3, e) {
      let t = e.schema.nodes;
      for (let r in t) {
        let o = t[r];
        if (!o.allowsMarkType(n3))
          continue;
        let i = [], s = (a) => {
          i.push(a);
          for (let l = 0; l < a.edgeCount; l++) {
            let { type: c2, next: u } = a.edge(l);
            if (c2 == e || i.indexOf(u) < 0 && s(u))
              return true;
          }
        };
        if (s(o.contentMatch))
          return true;
      }
    }
    class yo {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(e, t) {
        this.nodes = e, this.marks = t;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(e, t = {}, r) {
        r || (r = vl(t).createDocumentFragment());
        let o = r, i = [];
        return e.forEach((s) => {
          if (i.length || s.marks.length) {
            let a = 0, l = 0;
            for (; a < i.length && l < s.marks.length; ) {
              let c2 = s.marks[l];
              if (!this.marks[c2.type.name]) {
                l++;
                continue;
              }
              if (!c2.eq(i[a][0]) || c2.type.spec.spanning === false)
                break;
              a++, l++;
            }
            for (; a < i.length; )
              o = i.pop()[1];
            for (; l < s.marks.length; ) {
              let c2 = s.marks[l++], u = this.serializeMark(c2, s.isInline, t);
              u && (i.push([c2, o]), o.appendChild(u.dom), o = u.contentDOM || u.dom);
            }
          }
          o.appendChild(this.serializeNodeInner(s, t));
        }), r;
      }
      /**
      @internal
      */
      serializeNodeInner(e, t) {
        let { dom: r, contentDOM: o } = zs(vl(t), this.nodes[e.type.name](e), null, e.attrs);
        if (o) {
          if (e.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(e.content, t, o);
        }
        return r;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(e, t = {}) {
        let r = this.serializeNodeInner(e, t);
        for (let o = e.marks.length - 1; o >= 0; o--) {
          let i = this.serializeMark(e.marks[o], e.isInline, t);
          i && ((i.contentDOM || i.dom).appendChild(r), r = i.dom);
        }
        return r;
      }
      /**
      @internal
      */
      serializeMark(e, t, r = {}) {
        let o = this.marks[e.type.name];
        return o && zs(vl(r), o(e, t), null, e.attrs);
      }
      static renderSpec(e, t, r = null, o) {
        return zs(e, t, r, o);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new yo(this.nodesFromSchema(e), this.marksFromSchema(e)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(e) {
        let t = vd(e.nodes);
        return t.text || (t.text = (r) => r.text), t;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(e) {
        return vd(e.marks);
      }
    }
    function vd(n3) {
      let e = {};
      for (let t in n3) {
        let r = n3[t].spec.toDOM;
        r && (e[t] = r);
      }
      return e;
    }
    function vl(n3) {
      return n3.document || window.document;
    }
    const wd = /* @__PURE__ */ new WeakMap();
    function Ey(n3) {
      let e = wd.get(n3);
      return e === void 0 && wd.set(n3, e = _y(n3)), e;
    }
    function _y(n3) {
      let e = null;
      function t(r) {
        if (r && typeof r == "object")
          if (Array.isArray(r))
            if (typeof r[0] == "string")
              e || (e = []), e.push(r);
            else
              for (let o = 0; o < r.length; o++)
                t(r[o]);
          else
            for (let o in r)
              t(r[o]);
      }
      return t(n3), e;
    }
    function zs(n3, e, t, r) {
      if (typeof e == "string")
        return { dom: n3.createTextNode(e) };
      if (e.nodeType != null)
        return { dom: e };
      if (e.dom && e.dom.nodeType != null)
        return e;
      let o = e[0], i;
      if (typeof o != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (r && (i = Ey(r)) && i.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let s = o.indexOf(" ");
      s > 0 && (t = o.slice(0, s), o = o.slice(s + 1));
      let a, l = t ? n3.createElementNS(t, o) : n3.createElement(o), c2 = e[1], u = 1;
      if (c2 && typeof c2 == "object" && c2.nodeType == null && !Array.isArray(c2)) {
        u = 2;
        for (let d in c2)
          if (c2[d] != null) {
            let p2 = d.indexOf(" ");
            p2 > 0 ? l.setAttributeNS(d.slice(0, p2), d.slice(p2 + 1), c2[d]) : l.setAttribute(d, c2[d]);
          }
      }
      for (let d = u; d < e.length; d++) {
        let p2 = e[d];
        if (p2 === 0) {
          if (d < e.length - 1 || d > u)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom: l, contentDOM: l };
        } else {
          let { dom: f, contentDOM: h2 } = zs(n3, p2, t, r);
          if (l.appendChild(f), h2) {
            if (a)
              throw new RangeError("Multiple content holes");
            a = h2;
          }
        }
      }
      return { dom: l, contentDOM: a };
    }
    const rh = 65535, oh = Math.pow(2, 16);
    function Sy(n3, e) {
      return n3 + e * oh;
    }
    function kd(n3) {
      return n3 & rh;
    }
    function Cy(n3) {
      return (n3 - (n3 & rh)) / oh;
    }
    const ih = 1, sh = 2, Hs = 4, ah = 8;
    let lc = class {
      /**
      @internal
      */
      constructor(e, t, r) {
        this.pos = e, this.delInfo = t, this.recover = r;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & ah) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (ih | Hs)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (sh | Hs)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & Hs) > 0;
      }
    }, uo = class xo {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(e, t = false) {
        if (this.ranges = e, this.inverted = t, !e.length && xo.empty)
          return xo.empty;
      }
      /**
      @internal
      */
      recover(e) {
        let t = 0, r = kd(e);
        if (!this.inverted)
          for (let o = 0; o < r; o++)
            t += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
        return this.ranges[r * 3] + t + Cy(e);
      }
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      map(e, t = 1) {
        return this._map(e, t, true);
      }
      /**
      @internal
      */
      _map(e, t, r) {
        let o = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? o : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = this.ranges[a + s], d = l + c2;
          if (e <= d) {
            let p2 = c2 ? e == l ? -1 : e == d ? 1 : t : t, f = l + o + (p2 < 0 ? 0 : u);
            if (r)
              return f;
            let h2 = e == (t < 0 ? l : d) ? null : Sy(a / 3, e - l), m = e == l ? sh : e == d ? ih : Hs;
            return (t < 0 ? e != l : e != d) && (m |= ah), new lc(f, m, h2);
          }
          o += u - c2;
        }
        return r ? e + o : new lc(e + o, 0, null);
      }
      /**
      @internal
      */
      touches(e, t) {
        let r = 0, o = kd(t), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? r : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = l + c2;
          if (e <= u && a == o * 3)
            return true;
          r += this.ranges[a + s] - c2;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(e) {
        let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
          let s = this.ranges[o], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c2 = this.ranges[o + t], u = this.ranges[o + r];
          e(a, a + c2, l, l + u), i += u - c2;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new xo(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(e) {
        return e == 0 ? xo.empty : new xo(e < 0 ? [0, -e, 0] : [0, 0, e]);
      }
    };
    uo.empty = new uo([]);
    let xy = class Us {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(e = [], t, r = 0, o = e.length) {
        this.maps = e, this.mirror = t, this.from = r, this.to = o;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(e = 0, t = this.maps.length) {
        return new Us(this.maps, this.mirror, e, t);
      }
      /**
      @internal
      */
      copy() {
        return new Us(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(e, t) {
        this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(e) {
        for (let t = 0, r = this.maps.length; t < e.maps.length; t++) {
          let o = e.getMirror(t);
          this.appendMap(e.maps[t], o != null && o < t ? r + o : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(e) {
        if (this.mirror) {
          for (let t = 0; t < this.mirror.length; t++)
            if (this.mirror[t] == e)
              return this.mirror[t + (t % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(e, t) {
        this.mirror || (this.mirror = []), this.mirror.push(e, t);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(e) {
        for (let t = e.maps.length - 1, r = this.maps.length + e.maps.length; t >= 0; t--) {
          let o = e.getMirror(t);
          this.appendMap(e.maps[t].invert(), o != null && o > t ? r - o - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let e = new Us();
        return e.appendMappingInverted(this), e;
      }
      /**
      Map a position through this mapping.
      */
      map(e, t = 1) {
        if (this.mirror)
          return this._map(e, t, true);
        for (let r = this.from; r < this.to; r++)
          e = this.maps[r].map(e, t);
        return e;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      /**
      @internal
      */
      _map(e, t, r) {
        let o = 0;
        for (let i = this.from; i < this.to; i++) {
          let s = this.maps[i], a = s.mapResult(e, t);
          if (a.recover != null) {
            let l = this.getMirror(i);
            if (l != null && l > i && l < this.to) {
              i = l, e = this.maps[l].recover(a.recover);
              continue;
            }
          }
          o |= a.delInfo, e = a.pos;
        }
        return r ? e : new lc(e, o, null);
      }
    };
    const wl = /* @__PURE__ */ Object.create(null);
    let Ut = class {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return uo.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(e) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(e, t) {
        if (!t || !t.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let r = wl[t.stepType];
        if (!r)
          throw new RangeError(`No step type ${t.stepType} defined`);
        return r.fromJSON(e, t);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(e, t) {
        if (e in wl)
          throw new RangeError("Duplicate use of step JSON ID " + e);
        return wl[e] = t, t.prototype.jsonID = e, t;
      }
    }, Jt = class li {
      /**
      @internal
      */
      constructor(e, t) {
        this.doc = e, this.failed = t;
      }
      /**
      Create a successful step result.
      */
      static ok(e) {
        return new li(e, null);
      }
      /**
      Create a failed step result.
      */
      static fail(e) {
        return new li(null, e);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(e, t, r, o) {
        try {
          return li.ok(e.replace(t, r, o));
        } catch (i) {
          if (i instanceof Ai)
            return li.fail(i.message);
          throw i;
        }
      }
    };
    function Jc(n3, e, t) {
      let r = [];
      for (let o = 0; o < n3.childCount; o++) {
        let i = n3.child(o);
        i.content.size && (i = i.copy(Jc(i.content, e, i))), i.isInline && (i = e(i, t, o)), r.push(i);
      }
      return O.fromArray(r);
    }
    let Yc = class ci extends Ut {
      /**
      Create a mark step.
      */
      constructor(e, t, r) {
        super(), this.from = e, this.to = t, this.mark = r;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), i = new I(Jc(t.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), t.openStart, t.openEnd);
        return Jt.fromReplace(e, this.from, this.to, i);
      }
      invert() {
        return new Qi(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deleted && r.deleted || t.pos >= r.pos ? null : new ci(t.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof ci && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ci(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new ci(t.from, t.to, e.markFromJSON(t.mark));
      }
    };
    Ut.jsonID("addMark", Yc);
    let Qi = class ui extends Ut {
      /**
      Create a mark-removing step.
      */
      constructor(e, t, r) {
        super(), this.from = e, this.to = t, this.mark = r;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), r = new I(Jc(t.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), t.openStart, t.openEnd);
        return Jt.fromReplace(e, this.from, this.to, r);
      }
      invert() {
        return new Yc(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deleted && r.deleted || t.pos >= r.pos ? null : new ui(t.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof ui && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ui(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new ui(t.from, t.to, e.markFromJSON(t.mark));
      }
    };
    Ut.jsonID("removeMark", Qi);
    let Xc = class di extends Ut {
      /**
      Create a node mark step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return Jt.fail("No node at mark step's position");
        let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
        return Jt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(r), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        if (t) {
          let r = this.mark.addToSet(t.marks);
          if (r.length == t.marks.length) {
            for (let o = 0; o < t.marks.length; o++)
              if (!t.marks[o].isInSet(r))
                return new di(this.pos, t.marks[o]);
            return new di(this.pos, this.mark);
          }
        }
        return new Zc(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new di(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new di(t.pos, e.markFromJSON(t.mark));
      }
    };
    Ut.jsonID("addNodeMark", Xc);
    let Zc = class cc extends Ut {
      /**
      Create a mark-removing step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return Jt.fail("No node at mark step's position");
        let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
        return Jt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(r), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        return !t || !this.mark.isInSet(t.marks) ? this : new Xc(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new cc(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new cc(t.pos, e.markFromJSON(t.mark));
      }
    };
    Ut.jsonID("removeNodeMark", Zc);
    let mr = class jr extends Ut {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(e, t, r, o = false) {
        super(), this.from = e, this.to = t, this.slice = r, this.structure = o;
      }
      apply(e) {
        return this.structure && uc(e, this.from, this.to) ? Jt.fail("Structure replace would overwrite content") : Jt.fromReplace(e, this.from, this.to, this.slice);
      }
      getMap() {
        return new uo([this.from, this.to - this.from, this.slice.size]);
      }
      invert(e) {
        return new jr(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deletedAcross && r.deletedAcross ? null : new jr(t.pos, Math.max(t.pos, r.pos), this.slice);
      }
      merge(e) {
        if (!(e instanceof jr) || e.structure || this.structure)
          return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
          let t = this.slice.size + e.slice.size == 0 ? I.empty : new I(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
          return new jr(this.from, this.to + (e.to - e.from), t, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
          let t = this.slice.size + e.slice.size == 0 ? I.empty : new I(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
          return new jr(e.from, this.to, t, this.structure);
        } else
          return null;
      }
      toJSON() {
        let e = { stepType: "replace", from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new jr(t.from, t.to, I.fromJSON(e, t.slice), !!t.structure);
      }
    };
    Ut.jsonID("replace", mr);
    let vo = class Vs extends Ut {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(e, t, r, o, i, s, a = false) {
        super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = o, this.slice = i, this.insert = s, this.structure = a;
      }
      apply(e) {
        if (this.structure && (uc(e, this.from, this.gapFrom) || uc(e, this.gapTo, this.to)))
          return Jt.fail("Structure gap-replace would overwrite content");
        let t = e.slice(this.gapFrom, this.gapTo);
        if (t.openStart || t.openEnd)
          return Jt.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, t.content);
        return r ? Jt.fromReplace(e, this.from, this.to, r) : Jt.fail("Content does not fit in gap");
      }
      getMap() {
        return new uo([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(e) {
        let t = this.gapTo - this.gapFrom;
        return new Vs(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = e.map(this.gapFrom, -1), i = e.map(this.gapTo, 1);
        return t.deletedAcross && r.deletedAcross || o < t.pos || i > r.pos ? null : new Vs(t.pos, r.pos, o, i, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let e = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new Vs(t.from, t.to, t.gapFrom, t.gapTo, I.fromJSON(e, t.slice), t.insert, !!t.structure);
      }
    };
    Ut.jsonID("replaceAround", vo);
    function uc(n3, e, t) {
      let r = n3.resolve(e), o = t - e, i = r.depth;
      for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
        i--, o--;
      if (o > 0) {
        let s = r.node(i).maybeChild(r.indexAfter(i));
        for (; o > 0; ) {
          if (!s || s.isLeaf)
            return true;
          s = s.firstChild, o--;
        }
      }
      return false;
    }
    function Ty(n3, e, t, r) {
      let o = [], i = [], s, a;
      n3.doc.nodesBetween(e, t, (l, c2, u) => {
        if (!l.isInline)
          return;
        let d = l.marks;
        if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
          let p2 = Math.max(c2, e), f = Math.min(c2 + l.nodeSize, t), h2 = r.addToSet(d);
          for (let m = 0; m < d.length; m++)
            d[m].isInSet(h2) || (s && s.to == p2 && s.mark.eq(d[m]) ? s.to = f : o.push(s = new Qi(p2, f, d[m])));
          a && a.to == p2 ? a.to = f : i.push(a = new Yc(p2, f, r));
        }
      }), o.forEach((l) => n3.step(l)), i.forEach((l) => n3.step(l));
    }
    function Oy(n3, e, t, r) {
      let o = [], i = 0;
      n3.doc.nodesBetween(e, t, (s, a) => {
        if (!s.isInline)
          return;
        i++;
        let l = null;
        if (r instanceof Zi) {
          let c2 = s.marks, u;
          for (; u = r.isInSet(c2); )
            (l || (l = [])).push(u), c2 = u.removeFromSet(c2);
        } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
        if (l && l.length) {
          let c2 = Math.min(a + s.nodeSize, t);
          for (let u = 0; u < l.length; u++) {
            let d = l[u], p2;
            for (let f = 0; f < o.length; f++) {
              let h2 = o[f];
              h2.step == i - 1 && d.eq(o[f].style) && (p2 = h2);
            }
            p2 ? (p2.to = c2, p2.step = i) : o.push({ style: d, from: Math.max(a, e), to: c2, step: i });
          }
        }
      }), o.forEach((s) => n3.step(new Qi(s.from, s.to, s.style)));
    }
    function Ny(n3, e, t, r = t.contentMatch) {
      let o = n3.doc.nodeAt(e), i = [], s = e + 1;
      for (let a = 0; a < o.childCount; a++) {
        let l = o.child(a), c2 = s + l.nodeSize, u = r.matchType(l.type);
        if (!u)
          i.push(new mr(s, c2, I.empty));
        else {
          r = u;
          for (let d = 0; d < l.marks.length; d++)
            t.allowsMarkType(l.marks[d].type) || n3.step(new Qi(s, c2, l.marks[d]));
          if (l.isText && !t.spec.code) {
            let d, p2 = /\r?\n|\r/g, f;
            for (; d = p2.exec(l.text); )
              f || (f = new I(O.from(t.schema.text(" ", t.allowedMarks(l.marks))), 0, 0)), i.push(new mr(s + d.index, s + d.index + d[0].length, f));
          }
        }
        s = c2;
      }
      if (!r.validEnd) {
        let a = r.fillBefore(O.empty, true);
        n3.replace(s, s, new I(a, 0, 0));
      }
      for (let a = i.length - 1; a >= 0; a--)
        n3.step(i[a]);
    }
    function My(n3, e, t) {
      let { $from: r, $to: o, depth: i } = e, s = r.before(i + 1), a = o.after(i + 1), l = s, c2 = a, u = O.empty, d = 0;
      for (let h2 = i, m = false; h2 > t; h2--)
        m || r.index(h2) > 0 ? (m = true, u = O.from(r.node(h2).copy(u)), d++) : l--;
      let p2 = O.empty, f = 0;
      for (let h2 = i, m = false; h2 > t; h2--)
        m || o.after(h2 + 1) < o.end(h2) ? (m = true, p2 = O.from(o.node(h2).copy(p2)), f++) : c2++;
      n3.step(new vo(l, c2, s, a, new I(u.append(p2), d, f), u.size - d, true));
    }
    function Ay(n3, e, t) {
      let r = O.empty;
      for (let s = t.length - 1; s >= 0; s--) {
        if (r.size) {
          let a = t[s].type.contentMatch.matchFragment(r);
          if (!a || !a.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        r = O.from(t[s].type.create(t[s].attrs, r));
      }
      let o = e.start, i = e.end;
      n3.step(new vo(o, i, o, i, new I(r, 0, 0), t.length, true));
    }
    function Ry(n3, e, t, r, o) {
      if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let i = n3.steps.length;
      n3.doc.nodesBetween(e, t, (s, a) => {
        if (s.isTextblock && !s.hasMarkup(r, o) && Iy(n3.doc, n3.mapping.slice(i).map(a), r)) {
          n3.clearIncompatible(n3.mapping.slice(i).map(a, 1), r);
          let l = n3.mapping.slice(i), c2 = l.map(a, 1), u = l.map(a + s.nodeSize, 1);
          return n3.step(new vo(c2, u, c2 + 1, u - 1, new I(O.from(r.create(o, null, s.marks)), 0, 0), 1, true)), false;
        }
      });
    }
    function Iy(n3, e, t) {
      let r = n3.resolve(e), o = r.index();
      return r.parent.canReplaceWith(o, o + 1, t);
    }
    function Dy(n3, e, t, r, o) {
      let i = n3.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at given position");
      t || (t = i.type);
      let s = t.create(r, null, o || i.marks);
      if (i.isLeaf)
        return n3.replaceWith(e, e + i.nodeSize, s);
      if (!t.validContent(i.content))
        throw new RangeError("Invalid content for node type " + t.name);
      n3.step(new vo(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new I(O.from(s), 0, 0), 1, true));
    }
    function Ly(n3, e, t = 1, r) {
      let o = n3.doc.resolve(e), i = O.empty, s = O.empty;
      for (let a = o.depth, l = o.depth - t, c2 = t - 1; a > l; a--, c2--) {
        i = O.from(o.node(a).copy(i));
        let u = r && r[c2];
        s = O.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s));
      }
      n3.step(new mr(e, e, new I(i.append(s), t, t), true));
    }
    function By(n3, e, t) {
      let r = new mr(e - t, e + t, I.empty, true);
      n3.step(r);
    }
    function Py(n3, e, t) {
      let r = n3.resolve(e);
      if (r.parent.canReplaceWith(r.index(), r.index(), t))
        return e;
      if (r.parentOffset == 0)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.index(o);
          if (r.node(o).canReplaceWith(i, i, t))
            return r.before(o + 1);
          if (i > 0)
            return null;
        }
      if (r.parentOffset == r.parent.content.size)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.indexAfter(o);
          if (r.node(o).canReplaceWith(i, i, t))
            return r.after(o + 1);
          if (i < r.node(o).childCount)
            return null;
        }
      return null;
    }
    function $y(n3, e, t) {
      let r = n3.resolve(e);
      if (!t.content.size)
        return e;
      let o = t.content;
      for (let i = 0; i < t.openStart; i++)
        o = o.firstChild.content;
      for (let i = 1; i <= (t.openStart == 0 && t.size ? 2 : 1); i++)
        for (let s = r.depth; s >= 0; s--) {
          let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), c2 = r.node(s), u = false;
          if (i == 1)
            u = c2.canReplace(l, l, o);
          else {
            let d = c2.contentMatchAt(l).findWrapping(o.firstChild.type);
            u = d && c2.canReplaceWith(l, l, d[0]);
          }
          if (u)
            return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
        }
      return null;
    }
    function Fy(n3, e, t = e, r = I.empty) {
      if (e == t && !r.size)
        return null;
      let o = n3.resolve(e), i = n3.resolve(t);
      return lh(o, i, r) ? new mr(e, t, r) : new zy(o, i, r).fit();
    }
    function lh(n3, e, t) {
      return !t.openStart && !t.openEnd && n3.start() == e.start() && n3.parent.canReplace(n3.index(), e.index(), t.content);
    }
    let zy = class {
      constructor(e, t, r) {
        this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = O.empty;
        for (let o = 0; o <= e.depth; o++) {
          let i = e.node(o);
          this.frontier.push({
            type: i.type,
            match: i.contentMatchAt(e.indexAfter(o))
          });
        }
        for (let o = e.depth; o > 0; o--)
          this.placed = O.from(e.node(o).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        for (; this.unplaced.size; ) {
          let c2 = this.findFittable();
          c2 ? this.placeNodes(c2) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!o)
          return null;
        let i = this.placed, s = r.depth, a = o.depth;
        for (; s && a && i.childCount == 1; )
          i = i.firstChild.content, s--, a--;
        let l = new I(i, s, a);
        return e > -1 ? new vo(r.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || r.pos != this.$to.pos ? new mr(r.pos, o.pos, l) : null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let e = this.unplaced.openStart;
        for (let t = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
          let i = t.firstChild;
          if (t.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
            e = r;
            break;
          }
          t = i.content;
        }
        for (let t = 1; t <= 2; t++)
          for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
            let o, i = null;
            r ? (i = kl(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
            let s = o.firstChild;
            for (let a = this.depth; a >= 0; a--) {
              let { type: l, match: c2 } = this.frontier[a], u, d = null;
              if (t == 1 && (s ? c2.matchType(s.type) || (d = c2.fillBefore(O.from(s), false)) : i && l.compatibleContent(i.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, inject: d };
              if (t == 2 && s && (u = c2.findWrapping(s.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, wrap: u };
              if (i && c2.matchType(i.type))
                break;
            }
          }
      }
      openMore() {
        let { content: e, openStart: t, openEnd: r } = this.unplaced, o = kl(e, t);
        return !o.childCount || o.firstChild.isLeaf ? false : (this.unplaced = new I(e, t + 1, Math.max(r, o.size + t >= e.size - r ? t + 1 : 0)), true);
      }
      dropNode() {
        let { content: e, openStart: t, openEnd: r } = this.unplaced, o = kl(e, t);
        if (o.childCount <= 1 && t > 0) {
          let i = e.size - t <= t + o.size;
          this.unplaced = new I(pi(e, t - 1, 1), t - 1, i ? t - 1 : r);
        } else
          this.unplaced = new I(pi(e, t, 1), t, r);
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: o, wrap: i }) {
        for (; this.depth > t; )
          this.closeFrontierNode();
        if (i)
          for (let m = 0; m < i.length; m++)
            this.openFrontierNode(i[m]);
        let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - e, c2 = 0, u = [], { match: d, type: p2 } = this.frontier[t];
        if (o) {
          for (let m = 0; m < o.childCount; m++)
            u.push(o.child(m));
          d = d.matchFragment(o);
        }
        let f = a.size + e - (s.content.size - s.openEnd);
        for (; c2 < a.childCount; ) {
          let m = a.child(c2), g = d.matchType(m.type);
          if (!g)
            break;
          c2++, (c2 > 1 || l == 0 || m.content.size) && (d = g, u.push(ch(m.mark(p2.allowedMarks(m.marks)), c2 == 1 ? l : 0, c2 == a.childCount ? f : -1)));
        }
        let h2 = c2 == a.childCount;
        h2 || (f = -1), this.placed = fi(this.placed, t, O.from(u)), this.frontier[t].match = d, h2 && f < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let m = 0, g = a; m < f; m++) {
          let b = g.lastChild;
          this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
        }
        this.unplaced = h2 ? e == 0 ? I.empty : new I(pi(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1) : new I(pi(s.content, e, c2), s.openStart, s.openEnd);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let e = this.frontier[this.depth], t;
        if (!e.type.isTextblock || !El(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
          return -1;
        let { depth: r } = this.$to, o = this.$to.after(r);
        for (; r > 1 && o == this.$to.end(--r); )
          ++o;
        return o;
      }
      findCloseLevel(e) {
        e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
          let { match: r, type: o } = this.frontier[t], i = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), s = El(e, t, o, r, i);
          if (s) {
            for (let a = t - 1; a >= 0; a--) {
              let { match: l, type: c2 } = this.frontier[a], u = El(e, a, c2, l, true);
              if (!u || u.childCount)
                continue e;
            }
            return { depth: t, fit: s, move: i ? e.doc.resolve(e.after(t + 1)) : e };
          }
        }
      }
      close(e) {
        let t = this.findCloseLevel(e);
        if (!t)
          return null;
        for (; this.depth > t.depth; )
          this.closeFrontierNode();
        t.fit.childCount && (this.placed = fi(this.placed, t.depth, t.fit)), e = t.move;
        for (let r = t.depth + 1; r <= e.depth; r++) {
          let o = e.node(r), i = o.type.contentMatch.fillBefore(o.content, true, e.index(r));
          this.openFrontierNode(o.type, o.attrs, i);
        }
        return e;
      }
      openFrontierNode(e, t = null, r) {
        let o = this.frontier[this.depth];
        o.match = o.match.matchType(e), this.placed = fi(this.placed, this.depth, O.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
      }
      closeFrontierNode() {
        let t = this.frontier.pop().match.fillBefore(O.empty, true);
        t.childCount && (this.placed = fi(this.placed, this.frontier.length, t));
      }
    };
    function pi(n3, e, t) {
      return e == 0 ? n3.cutByIndex(t, n3.childCount) : n3.replaceChild(0, n3.firstChild.copy(pi(n3.firstChild.content, e - 1, t)));
    }
    function fi(n3, e, t) {
      return e == 0 ? n3.append(t) : n3.replaceChild(n3.childCount - 1, n3.lastChild.copy(fi(n3.lastChild.content, e - 1, t)));
    }
    function kl(n3, e) {
      for (let t = 0; t < e; t++)
        n3 = n3.firstChild.content;
      return n3;
    }
    function ch(n3, e, t) {
      if (e <= 0)
        return n3;
      let r = n3.content;
      return e > 1 && (r = r.replaceChild(0, ch(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n3.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n3.type.contentMatch.matchFragment(r).fillBefore(O.empty, true)))), n3.copy(r);
    }
    function El(n3, e, t, r, o) {
      let i = n3.node(e), s = o ? n3.indexAfter(e) : n3.index(e);
      if (s == i.childCount && !t.compatibleContent(i.type))
        return null;
      let a = r.fillBefore(i.content, true, s);
      return a && !Hy(t, i.content, s) ? a : null;
    }
    function Hy(n3, e, t) {
      for (let r = t; r < e.childCount; r++)
        if (!n3.allowsMarks(e.child(r).marks))
          return true;
      return false;
    }
    function Uy(n3) {
      return n3.spec.defining || n3.spec.definingForContent;
    }
    function Vy(n3, e, t, r) {
      if (!r.size)
        return n3.deleteRange(e, t);
      let o = n3.doc.resolve(e), i = n3.doc.resolve(t);
      if (lh(o, i, r))
        return n3.step(new mr(e, t, r));
      let s = dh(o, n3.doc.resolve(t));
      s[s.length - 1] == 0 && s.pop();
      let a = -(o.depth + 1);
      s.unshift(a);
      for (let p2 = o.depth, f = o.pos - 1; p2 > 0; p2--, f--) {
        let h2 = o.node(p2).type.spec;
        if (h2.defining || h2.definingAsContext || h2.isolating)
          break;
        s.indexOf(p2) > -1 ? a = p2 : o.before(p2) == f && s.splice(1, 0, -p2);
      }
      let l = s.indexOf(a), c2 = [], u = r.openStart;
      for (let p2 = r.content, f = 0; ; f++) {
        let h2 = p2.firstChild;
        if (c2.push(h2), f == r.openStart)
          break;
        p2 = h2.content;
      }
      for (let p2 = u - 1; p2 >= 0; p2--) {
        let f = c2[p2], h2 = Uy(f.type);
        if (h2 && !f.sameMarkup(o.node(Math.abs(a) - 1)))
          u = p2;
        else if (h2 || !f.type.isTextblock)
          break;
      }
      for (let p2 = r.openStart; p2 >= 0; p2--) {
        let f = (p2 + u + 1) % (r.openStart + 1), h2 = c2[f];
        if (h2)
          for (let m = 0; m < s.length; m++) {
            let g = s[(m + l) % s.length], b = true;
            g < 0 && (b = false, g = -g);
            let w = o.node(g - 1), _ = o.index(g - 1);
            if (w.canReplaceWith(_, _, h2.type, h2.marks))
              return n3.replace(o.before(g), b ? i.after(g) : t, new I(uh(r.content, 0, r.openStart, f), f, r.openEnd));
          }
      }
      let d = n3.steps.length;
      for (let p2 = s.length - 1; p2 >= 0 && (n3.replace(e, t, r), !(n3.steps.length > d)); p2--) {
        let f = s[p2];
        f < 0 || (e = o.before(f), t = i.after(f));
      }
    }
    function uh(n3, e, t, r, o) {
      if (e < t) {
        let i = n3.firstChild;
        n3 = n3.replaceChild(0, i.copy(uh(i.content, e + 1, t, r, i)));
      }
      if (e > r) {
        let i = o.contentMatchAt(0), s = i.fillBefore(n3).append(n3);
        n3 = s.append(i.matchFragment(s).fillBefore(O.empty, true));
      }
      return n3;
    }
    function Wy(n3, e, t, r) {
      if (!r.isInline && e == t && n3.doc.resolve(e).parent.content.size) {
        let o = Py(n3.doc, e, r.type);
        o != null && (e = t = o);
      }
      n3.replaceRange(e, t, new I(O.from(r), 0, 0));
    }
    function qy(n3, e, t) {
      let r = n3.doc.resolve(e), o = n3.doc.resolve(t), i = dh(r, o);
      for (let s = 0; s < i.length; s++) {
        let a = i[s], l = s == i.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
          return n3.delete(r.start(a), o.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1))))
          return n3.delete(r.before(a), o.after(a));
      }
      for (let s = 1; s <= r.depth && s <= o.depth; s++)
        if (e - r.start(s) == r.depth - s && t > r.end(s) && o.end(s) - t != o.depth - s)
          return n3.delete(r.before(s), t);
      n3.delete(e, t);
    }
    function dh(n3, e) {
      let t = [], r = Math.min(n3.depth, e.depth);
      for (let o = r; o >= 0; o--) {
        let i = n3.start(o);
        if (i < n3.pos - (n3.depth - o) || e.end(o) > e.pos + (e.depth - o) || n3.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
          break;
        (i == e.start(o) || o == n3.depth && o == e.depth && n3.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == i - 1) && t.push(o);
      }
      return t;
    }
    let ph = class Ws extends Ut {
      /**
      Construct an attribute step.
      */
      constructor(e, t, r) {
        super(), this.pos = e, this.attr = t, this.value = r;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return Jt.fail("No node at attribute step's position");
        let r = /* @__PURE__ */ Object.create(null);
        for (let i in t.attrs)
          r[i] = t.attrs[i];
        r[this.attr] = this.value;
        let o = t.type.create(r, null, t.marks);
        return Jt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(o), 0, t.isLeaf ? 0 : 1));
      }
      getMap() {
        return uo.empty;
      }
      invert(e) {
        return new Ws(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new Ws(t.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.pos != "number" || typeof t.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Ws(t.pos, t.attr, t.value);
      }
    };
    Ut.jsonID("attr", ph);
    let fh = class dc extends Ut {
      /**
      Construct an attribute step.
      */
      constructor(e, t) {
        super(), this.attr = e, this.value = t;
      }
      apply(e) {
        let t = /* @__PURE__ */ Object.create(null);
        for (let o in e.attrs)
          t[o] = e.attrs[o];
        t[this.attr] = this.value;
        let r = e.type.create(t, e.content, e.marks);
        return Jt.ok(r);
      }
      getMap() {
        return uo.empty;
      }
      invert(e) {
        return new dc(this.attr, e.attrs[this.attr]);
      }
      map(e) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new dc(t.attr, t.value);
      }
    };
    Ut.jsonID("docAttr", fh);
    let Fo = class extends Error {
    };
    Fo = function n(e) {
      let t = Error.call(this, e);
      return t.__proto__ = n.prototype, t;
    };
    Fo.prototype = Object.create(Error.prototype);
    Fo.prototype.constructor = Fo;
    Fo.prototype.name = "TransformError";
    let Ky = class {
      /**
      Create a transform that starts with the given document.
      */
      constructor(e) {
        this.doc = e, this.steps = [], this.docs = [], this.mapping = new xy();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(e) {
        let t = this.maybeStep(e);
        if (t.failed)
          throw new Fo(t.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(e) {
        let t = e.apply(this.doc);
        return t.failed || this.addStep(e, t.doc), t;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(e, t) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(e, t = e, r = I.empty) {
        let o = Fy(this.doc, e, t, r);
        return o && this.step(o), this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(e, t, r) {
        return this.replace(e, t, new I(O.from(r), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(e, t) {
        return this.replace(e, t, I.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(e, t) {
        return this.replaceWith(e, e, t);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(e, t, r) {
        return Vy(this, e, t, r), this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(e, t, r) {
        return Wy(this, e, t, r), this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(e, t) {
        return qy(this, e, t), this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(e, t) {
        return My(this, e, t), this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(e, t = 1) {
        return By(this, e, t), this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(e, t) {
        return Ay(this, e, t), this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(e, t = e, r, o = null) {
        return Ry(this, e, t, r, o), this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(e, t, r = null, o) {
        return Dy(this, e, t, r, o), this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(e, t, r) {
        return this.step(new ph(e, t, r)), this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(e, t) {
        return this.step(new fh(e, t)), this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(e, t) {
        return this.step(new Xc(e, t)), this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(e, t) {
        if (!(t instanceof Ye)) {
          let r = this.doc.nodeAt(e);
          if (!r)
            throw new RangeError("No node at position " + e);
          if (t = t.isInSet(r.marks), !t)
            return this;
        }
        return this.step(new Zc(e, t)), this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split.
      */
      split(e, t = 1, r) {
        return Ly(this, e, t, r), this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(e, t, r) {
        return Ty(this, e, t, r), this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(e, t, r) {
        return Oy(this, e, t, r), this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(e, t, r) {
        return Ny(this, e, t, r), this;
      }
    };
    const _l = /* @__PURE__ */ Object.create(null);
    class ue {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor(e, t, r) {
        this.$anchor = e, this.$head = t, this.ranges = r || [new hh(e.min(t), e.max(t))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let e = this.ranges;
        for (let t = 0; t < e.length; t++)
          if (e[t].$from.pos != e[t].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(e, t = I.empty) {
        let r = t.content.lastChild, o = null;
        for (let a = 0; a < t.openEnd; a++)
          o = r, r = r.lastChild;
        let i = e.steps.length, s = this.ranges;
        for (let a = 0; a < s.length; a++) {
          let { $from: l, $to: c2 } = s[a], u = e.mapping.slice(i);
          e.replaceRange(u.map(l.pos), u.map(c2.pos), a ? I.empty : t), a == 0 && Sd(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(e, t) {
        let r = e.steps.length, o = this.ranges;
        for (let i = 0; i < o.length; i++) {
          let { $from: s, $to: a } = o[i], l = e.mapping.slice(r), c2 = l.map(s.pos), u = l.map(a.pos);
          i ? e.deleteRange(c2, u) : (e.replaceRangeWith(c2, u, t), Sd(e, r, t.isInline ? -1 : 1));
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom(e, t, r = false) {
        let o = e.parent.inlineContent ? new ie(e) : To(e.node(0), e.parent, e.pos, e.index(), t, r);
        if (o)
          return o;
        for (let i = e.depth - 1; i >= 0; i--) {
          let s = t < 0 ? To(e.node(0), e.node(i), e.before(i + 1), e.index(i), t, r) : To(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, t, r);
          if (s)
            return s;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near(e, t = 1) {
        return this.findFrom(e, t) || this.findFrom(e, -t) || new hn(e.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(e) {
        return To(e, e, 0, 0, 1) || new hn(e);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(e) {
        return To(e, e, e.content.size, e.childCount, -1) || new hn(e);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(e, t) {
        if (!t || !t.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let r = _l[t.type];
        if (!r)
          throw new RangeError(`No selection type ${t.type} defined`);
        return r.fromJSON(e, t);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(e, t) {
        if (e in _l)
          throw new RangeError("Duplicate use of selection JSON ID " + e);
        return _l[e] = t, t.prototype.jsonID = e, t;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return ie.between(this.$anchor, this.$head).getBookmark();
      }
    }
    ue.prototype.visible = true;
    class hh {
      /**
      Create a range.
      */
      constructor(e, t) {
        this.$from = e, this.$to = t;
      }
    }
    let Ed = false;
    function _d(n3) {
      !Ed && !n3.parent.inlineContent && (Ed = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n3.parent.type.name + ")"));
    }
    class ie extends ue {
      /**
      Construct a text selection between the given points.
      */
      constructor(e, t = e) {
        _d(e), _d(t), super(e, t);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(e, t) {
        let r = e.resolve(t.map(this.head));
        if (!r.parent.inlineContent)
          return ue.near(r);
        let o = e.resolve(t.map(this.anchor));
        return new ie(o.parent.inlineContent ? o : r, r);
      }
      replace(e, t = I.empty) {
        if (super.replace(e, t), t == I.empty) {
          let r = this.$from.marksAcross(this.$to);
          r && e.ensureMarks(r);
        }
      }
      eq(e) {
        return e instanceof ie && e.anchor == this.anchor && e.head == this.head;
      }
      getBookmark() {
        return new Ga(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.anchor != "number" || typeof t.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new ie(e.resolve(t.anchor), e.resolve(t.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(e, t, r = t) {
        let o = e.resolve(t);
        return new this(o, r == t ? o : e.resolve(r));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between(e, t, r) {
        let o = e.pos - t.pos;
        if ((!r || o) && (r = o >= 0 ? 1 : -1), !t.parent.inlineContent) {
          let i = ue.findFrom(t, r, true) || ue.findFrom(t, -r, true);
          if (i)
            t = i.$head;
          else
            return ue.near(t, r);
        }
        return e.parent.inlineContent || (o == 0 ? e = t : (e = (ue.findFrom(e, -r, true) || ue.findFrom(e, r, true)).$anchor, e.pos < t.pos != o < 0 && (e = t))), new ie(e, t);
      }
    }
    ue.jsonID("text", ie);
    class Ga {
      constructor(e, t) {
        this.anchor = e, this.head = t;
      }
      map(e) {
        return new Ga(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        return ie.between(e.resolve(this.anchor), e.resolve(this.head));
      }
    }
    class ne extends ue {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor(e) {
        let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
        super(e, r), this.node = t;
      }
      map(e, t) {
        let { deleted: r, pos: o } = t.mapResult(this.anchor), i = e.resolve(o);
        return r ? ue.near(i) : new ne(i);
      }
      content() {
        return new I(O.from(this.node), 0, 0);
      }
      eq(e) {
        return e instanceof ne && e.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new Qc(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new ne(e.resolve(t.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(e, t) {
        return new ne(e.resolve(t));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== false;
      }
    }
    ne.prototype.visible = false;
    ue.jsonID("node", ne);
    class Qc {
      constructor(e) {
        this.anchor = e;
      }
      map(e) {
        let { deleted: t, pos: r } = e.mapResult(this.anchor);
        return t ? new Ga(r, r) : new Qc(r);
      }
      resolve(e) {
        let t = e.resolve(this.anchor), r = t.nodeAfter;
        return r && ne.isSelectable(r) ? new ne(t) : ue.near(t);
      }
    }
    class hn extends ue {
      /**
      Create an all-selection over the given document.
      */
      constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size));
      }
      replace(e, t = I.empty) {
        if (t == I.empty) {
          e.delete(0, e.doc.content.size);
          let r = ue.atStart(e.doc);
          r.eq(e.selection) || e.setSelection(r);
        } else
          super.replace(e, t);
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(e) {
        return new hn(e);
      }
      map(e) {
        return new hn(e);
      }
      eq(e) {
        return e instanceof hn;
      }
      getBookmark() {
        return Gy;
      }
    }
    ue.jsonID("all", hn);
    const Gy = {
      map() {
        return this;
      },
      resolve(n3) {
        return new hn(n3);
      }
    };
    function To(n3, e, t, r, o, i = false) {
      if (e.inlineContent)
        return ie.create(n3, t);
      for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < e.childCount : s >= 0; s += o) {
        let a = e.child(s);
        if (a.isAtom) {
          if (!i && ne.isSelectable(a))
            return ne.create(n3, t - (o < 0 ? a.nodeSize : 0));
        } else {
          let l = To(n3, a, t + o, o < 0 ? a.childCount : 0, o, i);
          if (l)
            return l;
        }
        t += a.nodeSize * o;
      }
      return null;
    }
    function Sd(n3, e, t) {
      let r = n3.steps.length - 1;
      if (r < e)
        return;
      let o = n3.steps[r];
      if (!(o instanceof mr || o instanceof vo))
        return;
      let i = n3.mapping.maps[r], s;
      i.forEach((a, l, c2, u) => {
        s == null && (s = u);
      }), n3.setSelection(ue.near(n3.doc.resolve(s), t));
    }
    const Cd = 1, xd = 2, Td = 4;
    class jy extends Ky {
      /**
      @internal
      */
      constructor(e) {
        super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(e) {
        if (e.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Cd) & -3, this.storedMarks = null, this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & Cd) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(e) {
        return this.storedMarks = e, this.updated |= xd, this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(e) {
        return Ye.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & xd) > 0;
      }
      /**
      @internal
      */
      addStep(e, t) {
        super.addStep(e, t), this.updated = this.updated & -3, this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(e) {
        return this.time = e, this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(e) {
        return this.selection.replace(this, e), this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(e, t = true) {
        let r = this.selection;
        return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Ye.none))), r.replaceWith(this, e), this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        return this.selection.replace(this), this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(e, t, r) {
        let o = this.doc.type.schema;
        if (t == null)
          return e ? this.replaceSelectionWith(o.text(e), true) : this.deleteSelection();
        {
          if (r == null && (r = t), r = r ?? t, !e)
            return this.deleteRange(t, r);
          let i = this.storedMarks;
          if (!i) {
            let s = this.doc.resolve(t);
            i = r == t ? s.marks() : s.marksAcross(this.doc.resolve(r));
          }
          return this.replaceRangeWith(t, r, o.text(e, i)), this.selection.empty || this.setSelection(ue.near(this.selection.$to)), this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(e, t) {
        return this.meta[typeof e == "string" ? e : e.key] = t, this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let e in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        return this.updated |= Td, this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & Td) > 0;
      }
    }
    function Od(n3, e) {
      return !e || !n3 ? n3 : n3.bind(e);
    }
    class hi {
      constructor(e, t, r) {
        this.name = e, this.init = Od(t.init, r), this.apply = Od(t.apply, r);
      }
    }
    const Jy = [
      new hi("doc", {
        init(n3) {
          return n3.doc || n3.schema.topNodeType.createAndFill();
        },
        apply(n3) {
          return n3.doc;
        }
      }),
      new hi("selection", {
        init(n3, e) {
          return n3.selection || ue.atStart(e.doc);
        },
        apply(n3) {
          return n3.selection;
        }
      }),
      new hi("storedMarks", {
        init(n3) {
          return n3.storedMarks || null;
        },
        apply(n3, e, t, r) {
          return r.selection.$cursor ? n3.storedMarks : null;
        }
      }),
      new hi("scrollToSelection", {
        init() {
          return 0;
        },
        apply(n3, e) {
          return n3.scrolledIntoView ? e + 1 : e;
        }
      })
    ];
    class Sl {
      constructor(e, t) {
        this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Jy.slice(), t && t.forEach((r) => {
          if (this.pluginsByKey[r.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
          this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new hi(r.key, r.spec.state, r));
        });
      }
    }
    class Io {
      /**
      @internal
      */
      constructor(e) {
        this.config = e;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(e) {
        return this.applyTransaction(e).state;
      }
      /**
      @internal
      */
      filterTransaction(e, t = -1) {
        for (let r = 0; r < this.config.plugins.length; r++)
          if (r != t) {
            let o = this.config.plugins[r];
            if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(e) {
        if (!this.filterTransaction(e))
          return { state: this, transactions: [] };
        let t = [e], r = this.applyInner(e), o = null;
        for (; ; ) {
          let i = false;
          for (let s = 0; s < this.config.plugins.length; s++) {
            let a = this.config.plugins[s];
            if (a.spec.appendTransaction) {
              let l = o ? o[s].n : 0, c2 = o ? o[s].state : this, u = l < t.length && a.spec.appendTransaction.call(a, l ? t.slice(l) : t, c2, r);
              if (u && r.filterTransaction(u, s)) {
                if (u.setMeta("appendedTransaction", e), !o) {
                  o = [];
                  for (let d = 0; d < this.config.plugins.length; d++)
                    o.push(d < s ? { state: r, n: t.length } : { state: this, n: 0 });
                }
                t.push(u), r = r.applyInner(u), i = true;
              }
              o && (o[s] = { state: r, n: t.length });
            }
          }
          if (!i)
            return { state: r, transactions: t };
        }
      }
      /**
      @internal
      */
      applyInner(e) {
        if (!e.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let t = new Io(this.config), r = this.config.fields;
        for (let o = 0; o < r.length; o++) {
          let i = r[o];
          t[i.name] = i.apply(e, this[i.name], this, t);
        }
        return t;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new jy(this);
      }
      /**
      Create a new state.
      */
      static create(e) {
        let t = new Sl(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Io(t);
        for (let o = 0; o < t.fields.length; o++)
          r[t.fields[o].name] = t.fields[o].init(e, r);
        return r;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(e) {
        let t = new Sl(this.schema, e.plugins), r = t.fields, o = new Io(t);
        for (let i = 0; i < r.length; i++) {
          let s = r[i].name;
          o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
        }
        return o;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(e) {
        let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
          for (let r in e) {
            if (r == "doc" || r == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let o = e[r], i = o.spec.state;
            i && i.toJSON && (t[r] = i.toJSON.call(o, this[o.key]));
          }
        return t;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(e, t, r) {
        if (!t)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
          throw new RangeError("Required config field 'schema' missing");
        let o = new Sl(e.schema, e.plugins), i = new Io(o);
        return o.fields.forEach((s) => {
          if (s.name == "doc")
            i.doc = Dr.fromJSON(e.schema, t.doc);
          else if (s.name == "selection")
            i.selection = ue.fromJSON(i.doc, t.selection);
          else if (s.name == "storedMarks")
            t.storedMarks && (i.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
          else {
            if (r)
              for (let a in r) {
                let l = r[a], c2 = l.spec.state;
                if (l.key == s.name && c2 && c2.fromJSON && Object.prototype.hasOwnProperty.call(t, a)) {
                  i[s.name] = c2.fromJSON.call(l, e, t[a], i);
                  return;
                }
              }
            i[s.name] = s.init(e, i);
          }
        }), i;
      }
    }
    function mh(n3, e, t) {
      for (let r in n3) {
        let o = n3[r];
        o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = mh(o, e, {})), t[r] = o;
      }
      return t;
    }
    class Ue {
      /**
      Create a plugin.
      */
      constructor(e) {
        this.spec = e, this.props = {}, e.props && mh(e.props, this, this.props), this.key = e.key ? e.key.key : gh("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const Cl = /* @__PURE__ */ Object.create(null);
    function gh(n3) {
      return n3 in Cl ? n3 + "$" + ++Cl[n3] : (Cl[n3] = 0, n3 + "$");
    }
    class Ze {
      /**
      Create a plugin key.
      */
      constructor(e = "key") {
        this.key = gh(e);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(e) {
        return e.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const bh = 65535, yh = Math.pow(2, 16);
    function Yy(n3, e) {
      return n3 + e * yh;
    }
    function Nd(n3) {
      return n3 & bh;
    }
    function Xy(n3) {
      return (n3 - (n3 & bh)) / yh;
    }
    const vh = 1, wh = 2, qs = 4, kh = 8;
    class pc {
      /**
      @internal
      */
      constructor(e, t, r) {
        this.pos = e, this.delInfo = t, this.recover = r;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & kh) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (vh | qs)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (wh | qs)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & qs) > 0;
      }
    }
    class dn {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(e, t = false) {
        if (this.ranges = e, this.inverted = t, !e.length && dn.empty)
          return dn.empty;
      }
      /**
      @internal
      */
      recover(e) {
        let t = 0, r = Nd(e);
        if (!this.inverted)
          for (let o = 0; o < r; o++)
            t += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
        return this.ranges[r * 3] + t + Xy(e);
      }
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      map(e, t = 1) {
        return this._map(e, t, true);
      }
      /**
      @internal
      */
      _map(e, t, r) {
        let o = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? o : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = this.ranges[a + s], d = l + c2;
          if (e <= d) {
            let p2 = c2 ? e == l ? -1 : e == d ? 1 : t : t, f = l + o + (p2 < 0 ? 0 : u);
            if (r)
              return f;
            let h2 = e == (t < 0 ? l : d) ? null : Yy(a / 3, e - l), m = e == l ? wh : e == d ? vh : qs;
            return (t < 0 ? e != l : e != d) && (m |= kh), new pc(f, m, h2);
          }
          o += u - c2;
        }
        return r ? e + o : new pc(e + o, 0, null);
      }
      /**
      @internal
      */
      touches(e, t) {
        let r = 0, o = Nd(t), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? r : 0);
          if (l > e)
            break;
          let c2 = this.ranges[a + i], u = l + c2;
          if (e <= u && a == o * 3)
            return true;
          r += this.ranges[a + s] - c2;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(e) {
        let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
          let s = this.ranges[o], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c2 = this.ranges[o + t], u = this.ranges[o + r];
          e(a, a + c2, l, l + u), i += u - c2;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new dn(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(e) {
        return e == 0 ? dn.empty : new dn(e < 0 ? [0, -e, 0] : [0, 0, e]);
      }
    }
    dn.empty = new dn([]);
    class Bo {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(e = [], t, r = 0, o = e.length) {
        this.maps = e, this.mirror = t, this.from = r, this.to = o;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(e = 0, t = this.maps.length) {
        return new Bo(this.maps, this.mirror, e, t);
      }
      /**
      @internal
      */
      copy() {
        return new Bo(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(e, t) {
        this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(e) {
        for (let t = 0, r = this.maps.length; t < e.maps.length; t++) {
          let o = e.getMirror(t);
          this.appendMap(e.maps[t], o != null && o < t ? r + o : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(e) {
        if (this.mirror) {
          for (let t = 0; t < this.mirror.length; t++)
            if (this.mirror[t] == e)
              return this.mirror[t + (t % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(e, t) {
        this.mirror || (this.mirror = []), this.mirror.push(e, t);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(e) {
        for (let t = e.maps.length - 1, r = this.maps.length + e.maps.length; t >= 0; t--) {
          let o = e.getMirror(t);
          this.appendMap(e.maps[t].invert(), o != null && o > t ? r - o - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let e = new Bo();
        return e.appendMappingInverted(this), e;
      }
      /**
      Map a position through this mapping.
      */
      map(e, t = 1) {
        if (this.mirror)
          return this._map(e, t, true);
        for (let r = this.from; r < this.to; r++)
          e = this.maps[r].map(e, t);
        return e;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      /**
      @internal
      */
      _map(e, t, r) {
        let o = 0;
        for (let i = this.from; i < this.to; i++) {
          let s = this.maps[i], a = s.mapResult(e, t);
          if (a.recover != null) {
            let l = this.getMirror(i);
            if (l != null && l > i && l < this.to) {
              i = l, e = this.maps[l].recover(a.recover);
              continue;
            }
          }
          o |= a.delInfo, e = a.pos;
        }
        return r ? e : new pc(e, o, null);
      }
    }
    const xl = /* @__PURE__ */ Object.create(null);
    class Vt {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return dn.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(e) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(e, t) {
        if (!t || !t.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let r = xl[t.stepType];
        if (!r)
          throw new RangeError(`No step type ${t.stepType} defined`);
        return r.fromJSON(e, t);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(e, t) {
        if (e in xl)
          throw new RangeError("Duplicate use of step JSON ID " + e);
        return xl[e] = t, t.prototype.jsonID = e, t;
      }
    }
    class yt {
      /**
      @internal
      */
      constructor(e, t) {
        this.doc = e, this.failed = t;
      }
      /**
      Create a successful step result.
      */
      static ok(e) {
        return new yt(e, null);
      }
      /**
      Create a failed step result.
      */
      static fail(e) {
        return new yt(null, e);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(e, t, r, o) {
        try {
          return yt.ok(e.replace(t, r, o));
        } catch (i) {
          if (i instanceof Ai)
            return yt.fail(i.message);
          throw i;
        }
      }
    }
    function eu(n3, e, t) {
      let r = [];
      for (let o = 0; o < n3.childCount; o++) {
        let i = n3.child(o);
        i.content.size && (i = i.copy(eu(i.content, e, i))), i.isInline && (i = e(i, t, o)), r.push(i);
      }
      return O.fromArray(r);
    }
    class Mr extends Vt {
      /**
      Create a mark step.
      */
      constructor(e, t, r) {
        super(), this.from = e, this.to = t, this.mark = r;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), i = new I(eu(t.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), t.openStart, t.openEnd);
        return yt.fromReplace(e, this.from, this.to, i);
      }
      invert() {
        return new Gn(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deleted && r.deleted || t.pos >= r.pos ? null : new Mr(t.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof Mr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Mr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new Mr(t.from, t.to, e.markFromJSON(t.mark));
      }
    }
    Vt.jsonID("addMark", Mr);
    class Gn extends Vt {
      /**
      Create a mark-removing step.
      */
      constructor(e, t, r) {
        super(), this.from = e, this.to = t, this.mark = r;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), r = new I(eu(t.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), t.openStart, t.openEnd);
        return yt.fromReplace(e, this.from, this.to, r);
      }
      invert() {
        return new Mr(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deleted && r.deleted || t.pos >= r.pos ? null : new Gn(t.pos, r.pos, this.mark);
      }
      merge(e) {
        return e instanceof Gn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Gn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new Gn(t.from, t.to, e.markFromJSON(t.mark));
      }
    }
    Vt.jsonID("removeMark", Gn);
    class Ar extends Vt {
      /**
      Create a node mark step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return yt.fail("No node at mark step's position");
        let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
        return yt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(r), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        if (t) {
          let r = this.mark.addToSet(t.marks);
          if (r.length == t.marks.length) {
            for (let o = 0; o < t.marks.length; o++)
              if (!t.marks[o].isInSet(r))
                return new Ar(this.pos, t.marks[o]);
            return new Ar(this.pos, this.mark);
          }
        }
        return new zo(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new Ar(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new Ar(t.pos, e.markFromJSON(t.mark));
      }
    }
    Vt.jsonID("addNodeMark", Ar);
    class zo extends Vt {
      /**
      Create a mark-removing step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return yt.fail("No node at mark step's position");
        let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
        return yt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(r), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        return !t || !this.mark.isInSet(t.marks) ? this : new Ar(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new zo(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new zo(t.pos, e.markFromJSON(t.mark));
      }
    }
    Vt.jsonID("removeNodeMark", zo);
    class Rt extends Vt {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(e, t, r, o = false) {
        super(), this.from = e, this.to = t, this.slice = r, this.structure = o;
      }
      apply(e) {
        return this.structure && fc(e, this.from, this.to) ? yt.fail("Structure replace would overwrite content") : yt.fromReplace(e, this.from, this.to, this.slice);
      }
      getMap() {
        return new dn([this.from, this.to - this.from, this.slice.size]);
      }
      invert(e) {
        return new Rt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
        return t.deletedAcross && r.deletedAcross ? null : new Rt(t.pos, Math.max(t.pos, r.pos), this.slice);
      }
      merge(e) {
        if (!(e instanceof Rt) || e.structure || this.structure)
          return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
          let t = this.slice.size + e.slice.size == 0 ? I.empty : new I(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
          return new Rt(this.from, this.to + (e.to - e.from), t, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
          let t = this.slice.size + e.slice.size == 0 ? I.empty : new I(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
          return new Rt(e.from, this.to, t, this.structure);
        } else
          return null;
      }
      toJSON() {
        let e = { stepType: "replace", from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new Rt(t.from, t.to, I.fromJSON(e, t.slice), !!t.structure);
      }
    }
    Vt.jsonID("replace", Rt);
    class Bt extends Vt {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(e, t, r, o, i, s, a = false) {
        super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = o, this.slice = i, this.insert = s, this.structure = a;
      }
      apply(e) {
        if (this.structure && (fc(e, this.from, this.gapFrom) || fc(e, this.gapTo, this.to)))
          return yt.fail("Structure gap-replace would overwrite content");
        let t = e.slice(this.gapFrom, this.gapTo);
        if (t.openStart || t.openEnd)
          return yt.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, t.content);
        return r ? yt.fromReplace(e, this.from, this.to, r) : yt.fail("Content does not fit in gap");
      }
      getMap() {
        return new dn([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(e) {
        let t = this.gapTo - this.gapFrom;
        return new Bt(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
        return t.deletedAcross && r.deletedAcross || o < t.pos || i > r.pos ? null : new Bt(t.pos, r.pos, o, i, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let e = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new Bt(t.from, t.to, t.gapFrom, t.gapTo, I.fromJSON(e, t.slice), t.insert, !!t.structure);
      }
    }
    Vt.jsonID("replaceAround", Bt);
    function fc(n3, e, t) {
      let r = n3.resolve(e), o = t - e, i = r.depth;
      for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
        i--, o--;
      if (o > 0) {
        let s = r.node(i).maybeChild(r.indexAfter(i));
        for (; o > 0; ) {
          if (!s || s.isLeaf)
            return true;
          s = s.firstChild, o--;
        }
      }
      return false;
    }
    function Zy(n3, e, t, r) {
      let o = [], i = [], s, a;
      n3.doc.nodesBetween(e, t, (l, c2, u) => {
        if (!l.isInline)
          return;
        let d = l.marks;
        if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
          let p2 = Math.max(c2, e), f = Math.min(c2 + l.nodeSize, t), h2 = r.addToSet(d);
          for (let m = 0; m < d.length; m++)
            d[m].isInSet(h2) || (s && s.to == p2 && s.mark.eq(d[m]) ? s.to = f : o.push(s = new Gn(p2, f, d[m])));
          a && a.to == p2 ? a.to = f : i.push(a = new Mr(p2, f, r));
        }
      }), o.forEach((l) => n3.step(l)), i.forEach((l) => n3.step(l));
    }
    function Qy(n3, e, t, r) {
      let o = [], i = 0;
      n3.doc.nodesBetween(e, t, (s, a) => {
        if (!s.isInline)
          return;
        i++;
        let l = null;
        if (r instanceof Zi) {
          let c2 = s.marks, u;
          for (; u = r.isInSet(c2); )
            (l || (l = [])).push(u), c2 = u.removeFromSet(c2);
        } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
        if (l && l.length) {
          let c2 = Math.min(a + s.nodeSize, t);
          for (let u = 0; u < l.length; u++) {
            let d = l[u], p2;
            for (let f = 0; f < o.length; f++) {
              let h2 = o[f];
              h2.step == i - 1 && d.eq(o[f].style) && (p2 = h2);
            }
            p2 ? (p2.to = c2, p2.step = i) : o.push({ style: d, from: Math.max(a, e), to: c2, step: i });
          }
        }
      }), o.forEach((s) => n3.step(new Gn(s.from, s.to, s.style)));
    }
    function tu(n3, e, t, r = t.contentMatch, o = true) {
      let i = n3.doc.nodeAt(e), s = [], a = e + 1;
      for (let l = 0; l < i.childCount; l++) {
        let c2 = i.child(l), u = a + c2.nodeSize, d = r.matchType(c2.type);
        if (!d)
          s.push(new Rt(a, u, I.empty));
        else {
          r = d;
          for (let p2 = 0; p2 < c2.marks.length; p2++)
            t.allowsMarkType(c2.marks[p2].type) || n3.step(new Gn(a, u, c2.marks[p2]));
          if (o && c2.isText && t.whitespace != "pre") {
            let p2, f = /\r?\n|\r/g, h2;
            for (; p2 = f.exec(c2.text); )
              h2 || (h2 = new I(O.from(t.schema.text(" ", t.allowedMarks(c2.marks))), 0, 0)), s.push(new Rt(a + p2.index, a + p2.index + p2[0].length, h2));
          }
        }
        a = u;
      }
      if (!r.validEnd) {
        let l = r.fillBefore(O.empty, true);
        n3.replace(a, a, new I(l, 0, 0));
      }
      for (let l = s.length - 1; l >= 0; l--)
        n3.step(s[l]);
    }
    function ev(n3, e, t) {
      return (e == 0 || n3.canReplace(e, n3.childCount)) && (t == n3.childCount || n3.canReplace(0, t));
    }
    function Xo(n3) {
      let t = n3.parent.content.cutByIndex(n3.startIndex, n3.endIndex);
      for (let r = n3.depth; ; --r) {
        let o = n3.$from.node(r), i = n3.$from.index(r), s = n3.$to.indexAfter(r);
        if (r < n3.depth && o.canReplace(i, s, t))
          return r;
        if (r == 0 || o.type.spec.isolating || !ev(o, i, s))
          break;
      }
      return null;
    }
    function tv(n3, e, t) {
      let { $from: r, $to: o, depth: i } = e, s = r.before(i + 1), a = o.after(i + 1), l = s, c2 = a, u = O.empty, d = 0;
      for (let h2 = i, m = false; h2 > t; h2--)
        m || r.index(h2) > 0 ? (m = true, u = O.from(r.node(h2).copy(u)), d++) : l--;
      let p2 = O.empty, f = 0;
      for (let h2 = i, m = false; h2 > t; h2--)
        m || o.after(h2 + 1) < o.end(h2) ? (m = true, p2 = O.from(o.node(h2).copy(p2)), f++) : c2++;
      n3.step(new Bt(l, c2, s, a, new I(u.append(p2), d, f), u.size - d, true));
    }
    function nu(n3, e, t = null, r = n3) {
      let o = nv(n3, e), i = o && rv(r, e);
      return i ? o.map(Md).concat({ type: e, attrs: t }).concat(i.map(Md)) : null;
    }
    function Md(n3) {
      return { type: n3, attrs: null };
    }
    function nv(n3, e) {
      let { parent: t, startIndex: r, endIndex: o } = n3, i = t.contentMatchAt(r).findWrapping(e);
      if (!i)
        return null;
      let s = i.length ? i[0] : e;
      return t.canReplaceWith(r, o, s) ? i : null;
    }
    function rv(n3, e) {
      let { parent: t, startIndex: r, endIndex: o } = n3, i = t.child(r), s = e.contentMatch.findWrapping(i.type);
      if (!s)
        return null;
      let l = (s.length ? s[s.length - 1] : e).contentMatch;
      for (let c2 = r; l && c2 < o; c2++)
        l = l.matchType(t.child(c2).type);
      return !l || !l.validEnd ? null : s;
    }
    function ov(n3, e, t) {
      let r = O.empty;
      for (let s = t.length - 1; s >= 0; s--) {
        if (r.size) {
          let a = t[s].type.contentMatch.matchFragment(r);
          if (!a || !a.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        r = O.from(t[s].type.create(t[s].attrs, r));
      }
      let o = e.start, i = e.end;
      n3.step(new Bt(o, i, o, i, new I(r, 0, 0), t.length, true));
    }
    function iv(n3, e, t, r, o) {
      if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let i = n3.steps.length;
      n3.doc.nodesBetween(e, t, (s, a) => {
        let l = typeof o == "function" ? o(s) : o;
        if (s.isTextblock && !s.hasMarkup(r, l) && sv(n3.doc, n3.mapping.slice(i).map(a), r)) {
          let c2 = null;
          if (r.schema.linebreakReplacement) {
            let f = r.whitespace == "pre", h2 = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
            f && !h2 ? c2 = false : !f && h2 && (c2 = true);
          }
          c2 === false && _h(n3, s, a, i), tu(n3, n3.mapping.slice(i).map(a, 1), r, void 0, c2 === null);
          let u = n3.mapping.slice(i), d = u.map(a, 1), p2 = u.map(a + s.nodeSize, 1);
          return n3.step(new Bt(d, p2, d + 1, p2 - 1, new I(O.from(r.create(l, null, s.marks)), 0, 0), 1, true)), c2 === true && Eh(n3, s, a, i), false;
        }
      });
    }
    function Eh(n3, e, t, r) {
      e.forEach((o, i) => {
        if (o.isText) {
          let s, a = /\r?\n|\r/g;
          for (; s = a.exec(o.text); ) {
            let l = n3.mapping.slice(r).map(t + 1 + i + s.index);
            n3.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function _h(n3, e, t, r) {
      e.forEach((o, i) => {
        if (o.type == o.type.schema.linebreakReplacement) {
          let s = n3.mapping.slice(r).map(t + 1 + i);
          n3.replaceWith(s, s + 1, e.type.schema.text(`
`));
        }
      });
    }
    function sv(n3, e, t) {
      let r = n3.resolve(e), o = r.index();
      return r.parent.canReplaceWith(o, o + 1, t);
    }
    function av(n3, e, t, r, o) {
      let i = n3.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at given position");
      t || (t = i.type);
      let s = t.create(r, null, o || i.marks);
      if (i.isLeaf)
        return n3.replaceWith(e, e + i.nodeSize, s);
      if (!t.validContent(i.content))
        throw new RangeError("Invalid content for node type " + t.name);
      n3.step(new Bt(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new I(O.from(s), 0, 0), 1, true));
    }
    function pr(n3, e, t = 1, r) {
      let o = n3.resolve(e), i = o.depth - t, s = r && r[r.length - 1] || o.parent;
      if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
        return false;
      for (let c2 = o.depth - 1, u = t - 2; c2 > i; c2--, u--) {
        let d = o.node(c2), p2 = o.index(c2);
        if (d.type.spec.isolating)
          return false;
        let f = d.content.cutByIndex(p2, d.childCount), h2 = r && r[u + 1];
        h2 && (f = f.replaceChild(0, h2.type.create(h2.attrs)));
        let m = r && r[u] || d;
        if (!d.canReplace(p2 + 1, d.childCount) || !m.type.validContent(f))
          return false;
      }
      let a = o.indexAfter(i), l = r && r[0];
      return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
    }
    function lv(n3, e, t = 1, r) {
      let o = n3.doc.resolve(e), i = O.empty, s = O.empty;
      for (let a = o.depth, l = o.depth - t, c2 = t - 1; a > l; a--, c2--) {
        i = O.from(o.node(a).copy(i));
        let u = r && r[c2];
        s = O.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s));
      }
      n3.step(new Rt(e, e, new I(i.append(s), t, t), true));
    }
    function Ur(n3, e) {
      let t = n3.resolve(e), r = t.index();
      return Sh(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
    }
    function cv(n3, e) {
      e.content.size || n3.type.compatibleContent(e.type);
      let t = n3.contentMatchAt(n3.childCount), { linebreakReplacement: r } = n3.type.schema;
      for (let o = 0; o < e.childCount; o++) {
        let i = e.child(o), s = i.type == r ? n3.type.schema.nodes.text : i.type;
        if (t = t.matchType(s), !t || !n3.type.allowsMarks(i.marks))
          return false;
      }
      return t.validEnd;
    }
    function Sh(n3, e) {
      return !!(n3 && e && !n3.isLeaf && cv(n3, e));
    }
    function ja(n3, e, t = -1) {
      let r = n3.resolve(e);
      for (let o = r.depth; ; o--) {
        let i, s, a = r.index(o);
        if (o == r.depth ? (i = r.nodeBefore, s = r.nodeAfter) : t > 0 ? (i = r.node(o + 1), a++, s = r.node(o).maybeChild(a)) : (i = r.node(o).maybeChild(a - 1), s = r.node(o + 1)), i && !i.isTextblock && Sh(i, s) && r.node(o).canReplace(a, a + 1))
          return e;
        if (o == 0)
          break;
        e = t < 0 ? r.before(o) : r.after(o);
      }
    }
    function uv(n3, e, t) {
      let r = null, { linebreakReplacement: o } = n3.doc.type.schema, i = n3.doc.resolve(e - t), s = i.node().type;
      if (o && s.inlineContent) {
        let u = s.whitespace == "pre", d = !!s.contentMatch.matchType(o);
        u && !d ? r = false : !u && d && (r = true);
      }
      let a = n3.steps.length;
      if (r === false) {
        let u = n3.doc.resolve(e + t);
        _h(n3, u.node(), u.before(), a);
      }
      s.inlineContent && tu(n3, e + t - 1, s, i.node().contentMatchAt(i.index()), r == null);
      let l = n3.mapping.slice(a), c2 = l.map(e - t);
      if (n3.step(new Rt(c2, l.map(e + t, -1), I.empty, true)), r === true) {
        let u = n3.doc.resolve(c2);
        Eh(n3, u.node(), u.before(), n3.steps.length);
      }
      return n3;
    }
    function dv(n3, e, t) {
      let r = n3.resolve(e);
      if (r.parent.canReplaceWith(r.index(), r.index(), t))
        return e;
      if (r.parentOffset == 0)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.index(o);
          if (r.node(o).canReplaceWith(i, i, t))
            return r.before(o + 1);
          if (i > 0)
            return null;
        }
      if (r.parentOffset == r.parent.content.size)
        for (let o = r.depth - 1; o >= 0; o--) {
          let i = r.indexAfter(o);
          if (r.node(o).canReplaceWith(i, i, t))
            return r.after(o + 1);
          if (i < r.node(o).childCount)
            return null;
        }
      return null;
    }
    function pv(n3, e, t) {
      let r = n3.resolve(e);
      if (!t.content.size)
        return e;
      let o = t.content;
      for (let i = 0; i < t.openStart; i++)
        o = o.firstChild.content;
      for (let i = 1; i <= (t.openStart == 0 && t.size ? 2 : 1); i++)
        for (let s = r.depth; s >= 0; s--) {
          let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), c2 = r.node(s), u = false;
          if (i == 1)
            u = c2.canReplace(l, l, o);
          else {
            let d = c2.contentMatchAt(l).findWrapping(o.firstChild.type);
            u = d && c2.canReplaceWith(l, l, d[0]);
          }
          if (u)
            return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
        }
      return null;
    }
    function Ja(n3, e, t = e, r = I.empty) {
      if (e == t && !r.size)
        return null;
      let o = n3.resolve(e), i = n3.resolve(t);
      return Ch(o, i, r) ? new Rt(e, t, r) : new fv(o, i, r).fit();
    }
    function Ch(n3, e, t) {
      return !t.openStart && !t.openEnd && n3.start() == e.start() && n3.parent.canReplace(n3.index(), e.index(), t.content);
    }
    class fv {
      constructor(e, t, r) {
        this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = O.empty;
        for (let o = 0; o <= e.depth; o++) {
          let i = e.node(o);
          this.frontier.push({
            type: i.type,
            match: i.contentMatchAt(e.indexAfter(o))
          });
        }
        for (let o = e.depth; o > 0; o--)
          this.placed = O.from(e.node(o).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        for (; this.unplaced.size; ) {
          let c2 = this.findFittable();
          c2 ? this.placeNodes(c2) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!o)
          return null;
        let i = this.placed, s = r.depth, a = o.depth;
        for (; s && a && i.childCount == 1; )
          i = i.firstChild.content, s--, a--;
        let l = new I(i, s, a);
        return e > -1 ? new Bt(r.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || r.pos != this.$to.pos ? new Rt(r.pos, o.pos, l) : null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let e = this.unplaced.openStart;
        for (let t = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
          let i = t.firstChild;
          if (t.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
            e = r;
            break;
          }
          t = i.content;
        }
        for (let t = 1; t <= 2; t++)
          for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
            let o, i = null;
            r ? (i = Tl(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
            let s = o.firstChild;
            for (let a = this.depth; a >= 0; a--) {
              let { type: l, match: c2 } = this.frontier[a], u, d = null;
              if (t == 1 && (s ? c2.matchType(s.type) || (d = c2.fillBefore(O.from(s), false)) : i && l.compatibleContent(i.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, inject: d };
              if (t == 2 && s && (u = c2.findWrapping(s.type)))
                return { sliceDepth: r, frontierDepth: a, parent: i, wrap: u };
              if (i && c2.matchType(i.type))
                break;
            }
          }
      }
      openMore() {
        let { content: e, openStart: t, openEnd: r } = this.unplaced, o = Tl(e, t);
        return !o.childCount || o.firstChild.isLeaf ? false : (this.unplaced = new I(e, t + 1, Math.max(r, o.size + t >= e.size - r ? t + 1 : 0)), true);
      }
      dropNode() {
        let { content: e, openStart: t, openEnd: r } = this.unplaced, o = Tl(e, t);
        if (o.childCount <= 1 && t > 0) {
          let i = e.size - t <= t + o.size;
          this.unplaced = new I(mi(e, t - 1, 1), t - 1, i ? t - 1 : r);
        } else
          this.unplaced = new I(mi(e, t, 1), t, r);
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: o, wrap: i }) {
        for (; this.depth > t; )
          this.closeFrontierNode();
        if (i)
          for (let m = 0; m < i.length; m++)
            this.openFrontierNode(i[m]);
        let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - e, c2 = 0, u = [], { match: d, type: p2 } = this.frontier[t];
        if (o) {
          for (let m = 0; m < o.childCount; m++)
            u.push(o.child(m));
          d = d.matchFragment(o);
        }
        let f = a.size + e - (s.content.size - s.openEnd);
        for (; c2 < a.childCount; ) {
          let m = a.child(c2), g = d.matchType(m.type);
          if (!g)
            break;
          c2++, (c2 > 1 || l == 0 || m.content.size) && (d = g, u.push(xh(m.mark(p2.allowedMarks(m.marks)), c2 == 1 ? l : 0, c2 == a.childCount ? f : -1)));
        }
        let h2 = c2 == a.childCount;
        h2 || (f = -1), this.placed = gi(this.placed, t, O.from(u)), this.frontier[t].match = d, h2 && f < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let m = 0, g = a; m < f; m++) {
          let b = g.lastChild;
          this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
        }
        this.unplaced = h2 ? e == 0 ? I.empty : new I(mi(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1) : new I(mi(s.content, e, c2), s.openStart, s.openEnd);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let e = this.frontier[this.depth], t;
        if (!e.type.isTextblock || !Ol(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
          return -1;
        let { depth: r } = this.$to, o = this.$to.after(r);
        for (; r > 1 && o == this.$to.end(--r); )
          ++o;
        return o;
      }
      findCloseLevel(e) {
        e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
          let { match: r, type: o } = this.frontier[t], i = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), s = Ol(e, t, o, r, i);
          if (s) {
            for (let a = t - 1; a >= 0; a--) {
              let { match: l, type: c2 } = this.frontier[a], u = Ol(e, a, c2, l, true);
              if (!u || u.childCount)
                continue e;
            }
            return { depth: t, fit: s, move: i ? e.doc.resolve(e.after(t + 1)) : e };
          }
        }
      }
      close(e) {
        let t = this.findCloseLevel(e);
        if (!t)
          return null;
        for (; this.depth > t.depth; )
          this.closeFrontierNode();
        t.fit.childCount && (this.placed = gi(this.placed, t.depth, t.fit)), e = t.move;
        for (let r = t.depth + 1; r <= e.depth; r++) {
          let o = e.node(r), i = o.type.contentMatch.fillBefore(o.content, true, e.index(r));
          this.openFrontierNode(o.type, o.attrs, i);
        }
        return e;
      }
      openFrontierNode(e, t = null, r) {
        let o = this.frontier[this.depth];
        o.match = o.match.matchType(e), this.placed = gi(this.placed, this.depth, O.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
      }
      closeFrontierNode() {
        let t = this.frontier.pop().match.fillBefore(O.empty, true);
        t.childCount && (this.placed = gi(this.placed, this.frontier.length, t));
      }
    }
    function mi(n3, e, t) {
      return e == 0 ? n3.cutByIndex(t, n3.childCount) : n3.replaceChild(0, n3.firstChild.copy(mi(n3.firstChild.content, e - 1, t)));
    }
    function gi(n3, e, t) {
      return e == 0 ? n3.append(t) : n3.replaceChild(n3.childCount - 1, n3.lastChild.copy(gi(n3.lastChild.content, e - 1, t)));
    }
    function Tl(n3, e) {
      for (let t = 0; t < e; t++)
        n3 = n3.firstChild.content;
      return n3;
    }
    function xh(n3, e, t) {
      if (e <= 0)
        return n3;
      let r = n3.content;
      return e > 1 && (r = r.replaceChild(0, xh(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n3.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n3.type.contentMatch.matchFragment(r).fillBefore(O.empty, true)))), n3.copy(r);
    }
    function Ol(n3, e, t, r, o) {
      let i = n3.node(e), s = o ? n3.indexAfter(e) : n3.index(e);
      if (s == i.childCount && !t.compatibleContent(i.type))
        return null;
      let a = r.fillBefore(i.content, true, s);
      return a && !hv(t, i.content, s) ? a : null;
    }
    function hv(n3, e, t) {
      for (let r = t; r < e.childCount; r++)
        if (!n3.allowsMarks(e.child(r).marks))
          return true;
      return false;
    }
    function mv(n3) {
      return n3.spec.defining || n3.spec.definingForContent;
    }
    function gv(n3, e, t, r) {
      if (!r.size)
        return n3.deleteRange(e, t);
      let o = n3.doc.resolve(e), i = n3.doc.resolve(t);
      if (Ch(o, i, r))
        return n3.step(new Rt(e, t, r));
      let s = Oh(o, n3.doc.resolve(t));
      s[s.length - 1] == 0 && s.pop();
      let a = -(o.depth + 1);
      s.unshift(a);
      for (let p2 = o.depth, f = o.pos - 1; p2 > 0; p2--, f--) {
        let h2 = o.node(p2).type.spec;
        if (h2.defining || h2.definingAsContext || h2.isolating)
          break;
        s.indexOf(p2) > -1 ? a = p2 : o.before(p2) == f && s.splice(1, 0, -p2);
      }
      let l = s.indexOf(a), c2 = [], u = r.openStart;
      for (let p2 = r.content, f = 0; ; f++) {
        let h2 = p2.firstChild;
        if (c2.push(h2), f == r.openStart)
          break;
        p2 = h2.content;
      }
      for (let p2 = u - 1; p2 >= 0; p2--) {
        let f = c2[p2], h2 = mv(f.type);
        if (h2 && !f.sameMarkup(o.node(Math.abs(a) - 1)))
          u = p2;
        else if (h2 || !f.type.isTextblock)
          break;
      }
      for (let p2 = r.openStart; p2 >= 0; p2--) {
        let f = (p2 + u + 1) % (r.openStart + 1), h2 = c2[f];
        if (h2)
          for (let m = 0; m < s.length; m++) {
            let g = s[(m + l) % s.length], b = true;
            g < 0 && (b = false, g = -g);
            let w = o.node(g - 1), _ = o.index(g - 1);
            if (w.canReplaceWith(_, _, h2.type, h2.marks))
              return n3.replace(o.before(g), b ? i.after(g) : t, new I(Th(r.content, 0, r.openStart, f), f, r.openEnd));
          }
      }
      let d = n3.steps.length;
      for (let p2 = s.length - 1; p2 >= 0 && (n3.replace(e, t, r), !(n3.steps.length > d)); p2--) {
        let f = s[p2];
        f < 0 || (e = o.before(f), t = i.after(f));
      }
    }
    function Th(n3, e, t, r, o) {
      if (e < t) {
        let i = n3.firstChild;
        n3 = n3.replaceChild(0, i.copy(Th(i.content, e + 1, t, r, i)));
      }
      if (e > r) {
        let i = o.contentMatchAt(0), s = i.fillBefore(n3).append(n3);
        n3 = s.append(i.matchFragment(s).fillBefore(O.empty, true));
      }
      return n3;
    }
    function bv(n3, e, t, r) {
      if (!r.isInline && e == t && n3.doc.resolve(e).parent.content.size) {
        let o = dv(n3.doc, e, r.type);
        o != null && (e = t = o);
      }
      n3.replaceRange(e, t, new I(O.from(r), 0, 0));
    }
    function yv(n3, e, t) {
      let r = n3.doc.resolve(e), o = n3.doc.resolve(t), i = Oh(r, o);
      for (let s = 0; s < i.length; s++) {
        let a = i[s], l = s == i.length - 1;
        if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
          return n3.delete(r.start(a), o.end(a));
        if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1))))
          return n3.delete(r.before(a), o.after(a));
      }
      for (let s = 1; s <= r.depth && s <= o.depth; s++)
        if (e - r.start(s) == r.depth - s && t > r.end(s) && o.end(s) - t != o.depth - s && r.start(s - 1) == o.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1)))
          return n3.delete(r.before(s), t);
      n3.delete(e, t);
    }
    function Oh(n3, e) {
      let t = [], r = Math.min(n3.depth, e.depth);
      for (let o = r; o >= 0; o--) {
        let i = n3.start(o);
        if (i < n3.pos - (n3.depth - o) || e.end(o) > e.pos + (e.depth - o) || n3.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
          break;
        (i == e.start(o) || o == n3.depth && o == e.depth && n3.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == i - 1) && t.push(o);
      }
      return t;
    }
    class Po extends Vt {
      /**
      Construct an attribute step.
      */
      constructor(e, t, r) {
        super(), this.pos = e, this.attr = t, this.value = r;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return yt.fail("No node at attribute step's position");
        let r = /* @__PURE__ */ Object.create(null);
        for (let i in t.attrs)
          r[i] = t.attrs[i];
        r[this.attr] = this.value;
        let o = t.type.create(r, null, t.marks);
        return yt.fromReplace(e, this.pos, this.pos + 1, new I(O.from(o), 0, t.isLeaf ? 0 : 1));
      }
      getMap() {
        return dn.empty;
      }
      invert(e) {
        return new Po(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new Po(t.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.pos != "number" || typeof t.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Po(t.pos, t.attr, t.value);
      }
    }
    Vt.jsonID("attr", Po);
    class Di extends Vt {
      /**
      Construct an attribute step.
      */
      constructor(e, t) {
        super(), this.attr = e, this.value = t;
      }
      apply(e) {
        let t = /* @__PURE__ */ Object.create(null);
        for (let o in e.attrs)
          t[o] = e.attrs[o];
        t[this.attr] = this.value;
        let r = e.type.create(t, e.content, e.marks);
        return yt.ok(r);
      }
      getMap() {
        return dn.empty;
      }
      invert(e) {
        return new Di(this.attr, e.attrs[this.attr]);
      }
      map(e) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new Di(t.attr, t.value);
      }
    }
    Vt.jsonID("docAttr", Di);
    let Ho = class extends Error {
    };
    Ho = function n2(e) {
      let t = Error.call(this, e);
      return t.__proto__ = n2.prototype, t;
    };
    Ho.prototype = Object.create(Error.prototype);
    Ho.prototype.constructor = Ho;
    Ho.prototype.name = "TransformError";
    class Nh {
      /**
      Create a transform that starts with the given document.
      */
      constructor(e) {
        this.doc = e, this.steps = [], this.docs = [], this.mapping = new Bo();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(e) {
        let t = this.maybeStep(e);
        if (t.failed)
          throw new Ho(t.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(e) {
        let t = e.apply(this.doc);
        return t.failed || this.addStep(e, t.doc), t;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(e, t) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(e, t = e, r = I.empty) {
        let o = Ja(this.doc, e, t, r);
        return o && this.step(o), this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(e, t, r) {
        return this.replace(e, t, new I(O.from(r), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(e, t) {
        return this.replace(e, t, I.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(e, t) {
        return this.replaceWith(e, e, t);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(e, t, r) {
        return gv(this, e, t, r), this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(e, t, r) {
        return bv(this, e, t, r), this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(e, t) {
        return yv(this, e, t), this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(e, t) {
        return tv(this, e, t), this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(e, t = 1) {
        return uv(this, e, t), this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(e, t) {
        return ov(this, e, t), this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(e, t = e, r, o = null) {
        return iv(this, e, t, r, o), this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(e, t, r = null, o) {
        return av(this, e, t, r, o), this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(e, t, r) {
        return this.step(new Po(e, t, r)), this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(e, t) {
        return this.step(new Di(e, t)), this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(e, t) {
        return this.step(new Ar(e, t)), this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(e, t) {
        if (!(t instanceof Ye)) {
          let r = this.doc.nodeAt(e);
          if (!r)
            throw new RangeError("No node at position " + e);
          if (t = t.isInSet(r.marks), !t)
            return this;
        }
        return this.step(new zo(e, t)), this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split.
      */
      split(e, t = 1, r) {
        return lv(this, e, t, r), this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(e, t, r) {
        return Zy(this, e, t, r), this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(e, t, r) {
        return Qy(this, e, t, r), this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(e, t, r) {
        return tu(this, e, t, r), this;
      }
    }
    const It = function(n3) {
      for (var e = 0; ; e++)
        if (n3 = n3.previousSibling, !n3)
          return e;
    }, Li = function(n3) {
      let e = n3.assignedSlot || n3.parentNode;
      return e && e.nodeType == 11 ? e.host : e;
    };
    let hc = null;
    const lr = function(n3, e, t) {
      let r = hc || (hc = document.createRange());
      return r.setEnd(n3, t ?? n3.nodeValue.length), r.setStart(n3, e || 0), r;
    }, vv = function() {
      hc = null;
    }, po = function(n3, e, t, r) {
      return t && (Ad(n3, e, t, r, -1) || Ad(n3, e, t, r, 1));
    }, wv = /^(img|br|input|textarea|hr)$/i;
    function Ad(n3, e, t, r, o) {
      for (; ; ) {
        if (n3 == t && e == r)
          return true;
        if (e == (o < 0 ? 0 : kn(n3))) {
          let i = n3.parentNode;
          if (!i || i.nodeType != 1 || es(n3) || wv.test(n3.nodeName) || n3.contentEditable == "false")
            return false;
          e = It(n3) + (o < 0 ? 0 : 1), n3 = i;
        } else if (n3.nodeType == 1) {
          if (n3 = n3.childNodes[e + (o < 0 ? -1 : 0)], n3.contentEditable == "false")
            return false;
          e = o < 0 ? kn(n3) : 0;
        } else
          return false;
      }
    }
    function kn(n3) {
      return n3.nodeType == 3 ? n3.nodeValue.length : n3.childNodes.length;
    }
    function kv(n3, e) {
      for (; ; ) {
        if (n3.nodeType == 3 && e)
          return n3;
        if (n3.nodeType == 1 && e > 0) {
          if (n3.contentEditable == "false")
            return null;
          n3 = n3.childNodes[e - 1], e = kn(n3);
        } else if (n3.parentNode && !es(n3))
          e = It(n3), n3 = n3.parentNode;
        else
          return null;
      }
    }
    function Ev(n3, e) {
      for (; ; ) {
        if (n3.nodeType == 3 && e < n3.nodeValue.length)
          return n3;
        if (n3.nodeType == 1 && e < n3.childNodes.length) {
          if (n3.contentEditable == "false")
            return null;
          n3 = n3.childNodes[e], e = 0;
        } else if (n3.parentNode && !es(n3))
          e = It(n3) + 1, n3 = n3.parentNode;
        else
          return null;
      }
    }
    function _v(n3, e, t) {
      for (let r = e == 0, o = e == kn(n3); r || o; ) {
        if (n3 == t)
          return true;
        let i = It(n3);
        if (n3 = n3.parentNode, !n3)
          return false;
        r = r && i == 0, o = o && i == kn(n3);
      }
    }
    function es(n3) {
      let e;
      for (let t = n3; t && !(e = t.pmViewDesc); t = t.parentNode)
        ;
      return e && e.node && e.node.isBlock && (e.dom == n3 || e.contentDOM == n3);
    }
    const Ya = function(n3) {
      return n3.focusNode && po(n3.focusNode, n3.focusOffset, n3.anchorNode, n3.anchorOffset);
    };
    function Yr(n3, e) {
      let t = document.createEvent("Event");
      return t.initEvent("keydown", true, true), t.keyCode = n3, t.key = t.code = e, t;
    }
    function Sv(n3) {
      let e = n3.activeElement;
      for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
      return e;
    }
    function Cv(n3, e, t) {
      if (n3.caretPositionFromPoint)
        try {
          let r = n3.caretPositionFromPoint(e, t);
          if (r)
            return { node: r.offsetNode, offset: Math.min(kn(r.offsetNode), r.offset) };
        } catch {
        }
      if (n3.caretRangeFromPoint) {
        let r = n3.caretRangeFromPoint(e, t);
        if (r)
          return { node: r.startContainer, offset: Math.min(kn(r.startContainer), r.startOffset) };
      }
    }
    const Yn = typeof navigator < "u" ? navigator : null, Rd = typeof document < "u" ? document : null, Vr = Yn && Yn.userAgent || "", mc = /Edge\/(\d+)/.exec(Vr), Mh = /MSIE \d/.exec(Vr), gc = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Vr), nn = !!(Mh || gc || mc), Br = Mh ? document.documentMode : gc ? +gc[1] : mc ? +mc[1] : 0, Ln = !nn && /gecko\/(\d+)/i.test(Vr);
    Ln && +(/Firefox\/(\d+)/.exec(Vr) || [0, 0])[1];
    const bc = !nn && /Chrome\/(\d+)/.exec(Vr), zt = !!bc, Ah = bc ? +bc[1] : 0, Yt = !nn && !!Yn && /Apple Computer/.test(Yn.vendor), Uo = Yt && (/Mobile\/\w+/.test(Vr) || !!Yn && Yn.maxTouchPoints > 2), wn = Uo || (Yn ? /Mac/.test(Yn.platform) : false), xv = Yn ? /Win/.test(Yn.platform) : false, ur = /Android \d/.test(Vr), ts = !!Rd && "webkitFontSmoothing" in Rd.documentElement.style, Tv = ts ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function Ov(n3) {
      let e = n3.defaultView && n3.defaultView.visualViewport;
      return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
      } : {
        left: 0,
        right: n3.documentElement.clientWidth,
        top: 0,
        bottom: n3.documentElement.clientHeight
      };
    }
    function rr(n3, e) {
      return typeof n3 == "number" ? n3 : n3[e];
    }
    function Nv(n3) {
      let e = n3.getBoundingClientRect(), t = e.width / n3.offsetWidth || 1, r = e.height / n3.offsetHeight || 1;
      return {
        left: e.left,
        right: e.left + n3.clientWidth * t,
        top: e.top,
        bottom: e.top + n3.clientHeight * r
      };
    }
    function Id(n3, e, t) {
      let r = n3.someProp("scrollThreshold") || 0, o = n3.someProp("scrollMargin") || 5, i = n3.dom.ownerDocument;
      for (let s = t || n3.dom; s; s = Li(s)) {
        if (s.nodeType != 1)
          continue;
        let a = s, l = a == i.body, c2 = l ? Ov(i) : Nv(a), u = 0, d = 0;
        if (e.top < c2.top + rr(r, "top") ? d = -(c2.top - e.top + rr(o, "top")) : e.bottom > c2.bottom - rr(r, "bottom") && (d = e.bottom - e.top > c2.bottom - c2.top ? e.top + rr(o, "top") - c2.top : e.bottom - c2.bottom + rr(o, "bottom")), e.left < c2.left + rr(r, "left") ? u = -(c2.left - e.left + rr(o, "left")) : e.right > c2.right - rr(r, "right") && (u = e.right - c2.right + rr(o, "right")), u || d)
          if (l)
            i.defaultView.scrollBy(u, d);
          else {
            let p2 = a.scrollLeft, f = a.scrollTop;
            d && (a.scrollTop += d), u && (a.scrollLeft += u);
            let h2 = a.scrollLeft - p2, m = a.scrollTop - f;
            e = { left: e.left - h2, top: e.top - m, right: e.right - h2, bottom: e.bottom - m };
          }
        if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
          break;
      }
    }
    function Mv(n3) {
      let e = n3.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, o;
      for (let i = (e.left + e.right) / 2, s = t + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
        let a = n3.root.elementFromPoint(i, s);
        if (!a || a == n3.dom || !n3.dom.contains(a))
          continue;
        let l = a.getBoundingClientRect();
        if (l.top >= t - 20) {
          r = a, o = l.top;
          break;
        }
      }
      return { refDOM: r, refTop: o, stack: Rh(n3.dom) };
    }
    function Rh(n3) {
      let e = [], t = n3.ownerDocument;
      for (let r = n3; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n3 != t); r = Li(r))
        ;
      return e;
    }
    function Av({ refDOM: n3, refTop: e, stack: t }) {
      let r = n3 ? n3.getBoundingClientRect().top : 0;
      Ih(t, r == 0 ? 0 : r - e);
    }
    function Ih(n3, e) {
      for (let t = 0; t < n3.length; t++) {
        let { dom: r, top: o, left: i } = n3[t];
        r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != i && (r.scrollLeft = i);
      }
    }
    let Eo = null;
    function Rv(n3) {
      if (n3.setActive)
        return n3.setActive();
      if (Eo)
        return n3.focus(Eo);
      let e = Rh(n3);
      n3.focus(Eo == null ? {
        get preventScroll() {
          return Eo = { preventScroll: true }, true;
        }
      } : void 0), Eo || (Eo = false, Ih(e, 0));
    }
    function Dh(n3, e) {
      let t, r = 2e8, o, i = 0, s = e.top, a = e.top, l, c2;
      for (let u = n3.firstChild, d = 0; u; u = u.nextSibling, d++) {
        let p2;
        if (u.nodeType == 1)
          p2 = u.getClientRects();
        else if (u.nodeType == 3)
          p2 = lr(u).getClientRects();
        else
          continue;
        for (let f = 0; f < p2.length; f++) {
          let h2 = p2[f];
          if (h2.top <= s && h2.bottom >= a) {
            s = Math.max(h2.bottom, s), a = Math.min(h2.top, a);
            let m = h2.left > e.left ? h2.left - e.left : h2.right < e.left ? e.left - h2.right : 0;
            if (m < r) {
              t = u, r = m, o = m && t.nodeType == 3 ? {
                left: h2.right < e.left ? h2.right : h2.left,
                top: e.top
              } : e, u.nodeType == 1 && m && (i = d + (e.left >= (h2.left + h2.right) / 2 ? 1 : 0));
              continue;
            }
          } else h2.top > e.top && !l && h2.left <= e.left && h2.right >= e.left && (l = u, c2 = { left: Math.max(h2.left, Math.min(h2.right, e.left)), top: h2.top });
          !t && (e.left >= h2.right && e.top >= h2.top || e.left >= h2.left && e.top >= h2.bottom) && (i = d + 1);
        }
      }
      return !t && l && (t = l, o = c2, r = 0), t && t.nodeType == 3 ? Iv(t, o) : !t || r && t.nodeType == 1 ? { node: n3, offset: i } : Dh(t, o);
    }
    function Iv(n3, e) {
      let t = n3.nodeValue.length, r = document.createRange();
      for (let o = 0; o < t; o++) {
        r.setEnd(n3, o + 1), r.setStart(n3, o);
        let i = _r(r, 1);
        if (i.top != i.bottom && ru(e, i))
          return { node: n3, offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
      }
      return { node: n3, offset: 0 };
    }
    function ru(n3, e) {
      return n3.left >= e.left - 1 && n3.left <= e.right + 1 && n3.top >= e.top - 1 && n3.top <= e.bottom + 1;
    }
    function Dv(n3, e) {
      let t = n3.parentNode;
      return t && /^li$/i.test(t.nodeName) && e.left < n3.getBoundingClientRect().left ? t : n3;
    }
    function Lv(n3, e, t) {
      let { node: r, offset: o } = Dh(e, t), i = -1;
      if (r.nodeType == 1 && !r.firstChild) {
        let s = r.getBoundingClientRect();
        i = s.left != s.right && t.left > (s.left + s.right) / 2 ? 1 : -1;
      }
      return n3.docView.posFromDOM(r, o, i);
    }
    function Bv(n3, e, t, r) {
      let o = -1;
      for (let i = e, s = false; i != n3.dom; ) {
        let a = n3.docView.nearestDesc(i, true), l;
        if (!a)
          return null;
        if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
        ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > r.left || l.top > r.top ? o = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (o = a.posAfter), s = true), !a.contentDOM && o < 0 && !a.node.isText))
          return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
        i = a.dom.parentNode;
      }
      return o > -1 ? o : n3.docView.posFromDOM(e, t, -1);
    }
    function Lh(n3, e, t) {
      let r = n3.childNodes.length;
      if (r && t.top < t.bottom)
        for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), i = o; ; ) {
          let s = n3.childNodes[i];
          if (s.nodeType == 1) {
            let a = s.getClientRects();
            for (let l = 0; l < a.length; l++) {
              let c2 = a[l];
              if (ru(e, c2))
                return Lh(s, e, c2);
            }
          }
          if ((i = (i + 1) % r) == o)
            break;
        }
      return n3;
    }
    function Pv(n3, e) {
      let t = n3.dom.ownerDocument, r, o = 0, i = Cv(t, e.left, e.top);
      i && ({ node: r, offset: o } = i);
      let s = (n3.root.elementFromPoint ? n3.root : t).elementFromPoint(e.left, e.top), a;
      if (!s || !n3.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
        let c2 = n3.dom.getBoundingClientRect();
        if (!ru(e, c2) || (s = Lh(n3.dom, e, c2), !s))
          return null;
      }
      if (Yt)
        for (let c2 = s; r && c2; c2 = Li(c2))
          c2.draggable && (r = void 0);
      if (s = Dv(s, e), r) {
        if (Ln && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
          let u = r.childNodes[o], d;
          u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && o++;
        }
        let c2;
        ts && o && r.nodeType == 1 && (c2 = r.childNodes[o - 1]).nodeType == 1 && c2.contentEditable == "false" && c2.getBoundingClientRect().top >= e.top && o--, r == n3.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = n3.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (a = Bv(n3, r, o, e));
      }
      a == null && (a = Lv(n3, s, e));
      let l = n3.docView.nearestDesc(s, true);
      return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
    }
    function Dd(n3) {
      return n3.top < n3.bottom || n3.left < n3.right;
    }
    function _r(n3, e) {
      let t = n3.getClientRects();
      if (t.length) {
        let r = t[e < 0 ? 0 : t.length - 1];
        if (Dd(r))
          return r;
      }
      return Array.prototype.find.call(t, Dd) || n3.getBoundingClientRect();
    }
    const $v = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function Bh(n3, e, t) {
      let { node: r, offset: o, atom: i } = n3.docView.domFromPos(e, t < 0 ? -1 : 1), s = ts || Ln;
      if (r.nodeType == 3)
        if (s && ($v.test(r.nodeValue) || (t < 0 ? !o : o == r.nodeValue.length))) {
          let l = _r(lr(r, o, o), t);
          if (Ln && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
            let c2 = _r(lr(r, o - 1, o - 1), -1);
            if (c2.top == l.top) {
              let u = _r(lr(r, o, o + 1), -1);
              if (u.top != l.top)
                return oi(u, u.left < c2.left);
            }
          }
          return l;
        } else {
          let l = o, c2 = o, u = t < 0 ? 1 : -1;
          return t < 0 && !o ? (c2++, u = -1) : t >= 0 && o == r.nodeValue.length ? (l--, u = 1) : t < 0 ? l-- : c2++, oi(_r(lr(r, l, c2), u), u < 0);
        }
      if (!n3.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
        if (i == null && o && (t < 0 || o == kn(r))) {
          let l = r.childNodes[o - 1];
          if (l.nodeType == 1)
            return Nl(l.getBoundingClientRect(), false);
        }
        if (i == null && o < kn(r)) {
          let l = r.childNodes[o];
          if (l.nodeType == 1)
            return Nl(l.getBoundingClientRect(), true);
        }
        return Nl(r.getBoundingClientRect(), t >= 0);
      }
      if (i == null && o && (t < 0 || o == kn(r))) {
        let l = r.childNodes[o - 1], c2 = l.nodeType == 3 ? lr(l, kn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
        if (c2)
          return oi(_r(c2, 1), false);
      }
      if (i == null && o < kn(r)) {
        let l = r.childNodes[o];
        for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
          l = l.nextSibling;
        let c2 = l ? l.nodeType == 3 ? lr(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
        if (c2)
          return oi(_r(c2, -1), true);
      }
      return oi(_r(r.nodeType == 3 ? lr(r) : r, -t), t >= 0);
    }
    function oi(n3, e) {
      if (n3.width == 0)
        return n3;
      let t = e ? n3.left : n3.right;
      return { top: n3.top, bottom: n3.bottom, left: t, right: t };
    }
    function Nl(n3, e) {
      if (n3.height == 0)
        return n3;
      let t = e ? n3.top : n3.bottom;
      return { top: t, bottom: t, left: n3.left, right: n3.right };
    }
    function Ph(n3, e, t) {
      let r = n3.state, o = n3.root.activeElement;
      r != e && n3.updateState(e), o != n3.dom && n3.focus();
      try {
        return t();
      } finally {
        r != e && n3.updateState(r), o != n3.dom && o && o.focus();
      }
    }
    function Fv(n3, e, t) {
      let r = e.selection, o = t == "up" ? r.$from : r.$to;
      return Ph(n3, e, () => {
        let { node: i } = n3.docView.domFromPos(o.pos, t == "up" ? -1 : 1);
        for (; ; ) {
          let a = n3.docView.nearestDesc(i, true);
          if (!a)
            break;
          if (a.node.isBlock) {
            i = a.contentDOM || a.dom;
            break;
          }
          i = a.dom.parentNode;
        }
        let s = Bh(n3, o.pos, 1);
        for (let a = i.firstChild; a; a = a.nextSibling) {
          let l;
          if (a.nodeType == 1)
            l = a.getClientRects();
          else if (a.nodeType == 3)
            l = lr(a, 0, a.nodeValue.length).getClientRects();
          else
            continue;
          for (let c2 = 0; c2 < l.length; c2++) {
            let u = l[c2];
            if (u.bottom > u.top + 1 && (t == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    const zv = /[\u0590-\u08ac]/;
    function Hv(n3, e, t) {
      let { $head: r } = e.selection;
      if (!r.parent.isTextblock)
        return false;
      let o = r.parentOffset, i = !o, s = o == r.parent.content.size, a = n3.domSelection();
      return a ? !zv.test(r.parent.textContent) || !a.modify ? t == "left" || t == "backward" ? i : s : Ph(n3, e, () => {
        let { focusNode: l, focusOffset: c2, anchorNode: u, anchorOffset: d } = n3.domSelectionRange(), p2 = a.caretBidiLevel;
        a.modify("move", t, "character");
        let f = r.depth ? n3.docView.domAfterPos(r.before()) : n3.dom, { focusNode: h2, focusOffset: m } = n3.domSelectionRange(), g = h2 && !f.contains(h2.nodeType == 1 ? h2 : h2.parentNode) || l == h2 && c2 == m;
        try {
          a.collapse(u, d), l && (l != u || c2 != d) && a.extend && a.extend(l, c2);
        } catch {
        }
        return p2 != null && (a.caretBidiLevel = p2), g;
      }) : r.pos == r.start() || r.pos == r.end();
    }
    let Ld = null, Bd = null, Pd = false;
    function Uv(n3, e, t) {
      return Ld == e && Bd == t ? Pd : (Ld = e, Bd = t, Pd = t == "up" || t == "down" ? Fv(n3, e, t) : Hv(n3, e, t));
    }
    const _n = 0, $d = 1, Zr = 2, Xn = 3;
    class ns {
      constructor(e, t, r, o) {
        this.parent = e, this.children = t, this.dom = r, this.contentDOM = o, this.dirty = _n, r.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(e) {
        return false;
      }
      matchesMark(e) {
        return false;
      }
      matchesNode(e, t, r) {
        return false;
      }
      matchesHack(e) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(e) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let e = 0;
        for (let t = 0; t < this.children.length; t++)
          e += this.children[t].size;
        return e;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
          this.children[e].destroy();
      }
      posBeforeChild(e) {
        for (let t = 0, r = this.posAtStart; ; t++) {
          let o = this.children[t];
          if (o == e)
            return r;
          r += o.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(e, t, r) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
          if (r < 0) {
            let i, s;
            if (e == this.contentDOM)
              i = e.childNodes[t - 1];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              i = e.previousSibling;
            }
            for (; i && !((s = i.pmViewDesc) && s.parent == this); )
              i = i.previousSibling;
            return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
          } else {
            let i, s;
            if (e == this.contentDOM)
              i = e.childNodes[t];
            else {
              for (; e.parentNode != this.contentDOM; )
                e = e.parentNode;
              i = e.nextSibling;
            }
            for (; i && !((s = i.pmViewDesc) && s.parent == this); )
              i = i.nextSibling;
            return i ? this.posBeforeChild(s) : this.posAtEnd;
          }
        let o;
        if (e == this.dom && this.contentDOM)
          o = t > It(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          o = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (t == 0)
            for (let i = e; ; i = i.parentNode) {
              if (i == this.dom) {
                o = false;
                break;
              }
              if (i.previousSibling)
                break;
            }
          if (o == null && t == e.childNodes.length)
            for (let i = e; ; i = i.parentNode) {
              if (i == this.dom) {
                o = true;
                break;
              }
              if (i.nextSibling)
                break;
            }
        }
        return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(e, t = false) {
        for (let r = true, o = e; o; o = o.parentNode) {
          let i = this.getDesc(o), s;
          if (i && (!t || i.node))
            if (r && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
              r = false;
            else
              return i;
        }
      }
      getDesc(e) {
        let t = e.pmViewDesc;
        for (let r = t; r; r = r.parent)
          if (r == this)
            return t;
      }
      posFromDOM(e, t, r) {
        for (let o = e; o; o = o.parentNode) {
          let i = this.getDesc(o);
          if (i)
            return i.localPosFromDOM(e, t, r);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(e) {
        for (let t = 0, r = 0; t < this.children.length; t++) {
          let o = this.children[t], i = r + o.size;
          if (r == e && i != r) {
            for (; !o.border && o.children.length; )
              for (let s = 0; s < o.children.length; s++) {
                let a = o.children[s];
                if (a.size) {
                  o = a;
                  break;
                }
              }
            return o;
          }
          if (e < i)
            return o.descAt(e - r - o.border);
          r = i;
        }
      }
      domFromPos(e, t) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: e + 1 };
        let r = 0, o = 0;
        for (let i = 0; r < this.children.length; r++) {
          let s = this.children[r], a = i + s.size;
          if (a > e || s instanceof Fh) {
            o = e - i;
            break;
          }
          i = a;
        }
        if (o)
          return this.children[r].domFromPos(o - this.children[r].border, t);
        for (let i; r && !(i = this.children[r - 1]).size && i instanceof $h && i.side >= 0; r--)
          ;
        if (t <= 0) {
          let i, s = true;
          for (; i = r ? this.children[r - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); r--, s = false)
            ;
          return i && t && s && !i.border && !i.domAtom ? i.domFromPos(i.size, t) : { node: this.contentDOM, offset: i ? It(i.dom) + 1 : 0 };
        } else {
          let i, s = true;
          for (; i = r < this.children.length ? this.children[r] : null, !(!i || i.dom.parentNode == this.contentDOM); r++, s = false)
            ;
          return i && s && !i.border && !i.domAtom ? i.domFromPos(0, t) : { node: this.contentDOM, offset: i ? It(i.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(e, t, r = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let o = -1, i = -1;
        for (let s = r, a = 0; ; a++) {
          let l = this.children[a], c2 = s + l.size;
          if (o == -1 && e <= c2) {
            let u = s + l.border;
            if (e >= u && t <= c2 - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
              return l.parseRange(e, t, u);
            e = s;
            for (let d = a; d > 0; d--) {
              let p2 = this.children[d - 1];
              if (p2.size && p2.dom.parentNode == this.contentDOM && !p2.emptyChildAt(1)) {
                o = It(p2.dom) + 1;
                break;
              }
              e -= p2.size;
            }
            o == -1 && (o = 0);
          }
          if (o > -1 && (c2 > t || a == this.children.length - 1)) {
            t = c2;
            for (let u = a + 1; u < this.children.length; u++) {
              let d = this.children[u];
              if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
                i = It(d.dom);
                break;
              }
              t += d.size;
            }
            i == -1 && (i = this.contentDOM.childNodes.length);
            break;
          }
          s = c2;
        }
        return { node: this.contentDOM, from: e, to: t, fromOffset: o, toOffset: i };
      }
      emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let t = this.children[e < 0 ? 0 : this.children.length - 1];
        return t.size == 0 || t.emptyChildAt(e);
      }
      domAfterPos(e) {
        let { node: t, offset: r } = this.domFromPos(e, 0);
        if (t.nodeType != 1 || r == t.childNodes.length)
          throw new RangeError("No node after pos " + e);
        return t.childNodes[r];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(e, t, r, o = false) {
        let i = Math.min(e, t), s = Math.max(e, t);
        for (let f = 0, h2 = 0; f < this.children.length; f++) {
          let m = this.children[f], g = h2 + m.size;
          if (i > h2 && s < g)
            return m.setSelection(e - h2 - m.border, t - h2 - m.border, r, o);
          h2 = g;
        }
        let a = this.domFromPos(e, e ? -1 : 1), l = t == e ? a : this.domFromPos(t, t ? -1 : 1), c2 = r.root.getSelection(), u = r.domSelectionRange(), d = false;
        if ((Ln || Yt) && e == t) {
          let { node: f, offset: h2 } = a;
          if (f.nodeType == 3) {
            if (d = !!(h2 && f.nodeValue[h2 - 1] == `
`), d && h2 == f.nodeValue.length)
              for (let m = f, g; m; m = m.parentNode) {
                if (g = m.nextSibling) {
                  g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: It(g) + 1 });
                  break;
                }
                let b = m.pmViewDesc;
                if (b && b.node && b.node.isBlock)
                  break;
              }
          } else {
            let m = f.childNodes[h2 - 1];
            d = m && (m.nodeName == "BR" || m.contentEditable == "false");
          }
        }
        if (Ln && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
          let f = u.focusNode.childNodes[u.focusOffset];
          f && f.contentEditable == "false" && (o = true);
        }
        if (!(o || d && Yt) && po(a.node, a.offset, u.anchorNode, u.anchorOffset) && po(l.node, l.offset, u.focusNode, u.focusOffset))
          return;
        let p2 = false;
        if ((c2.extend || e == t) && !d) {
          c2.collapse(a.node, a.offset);
          try {
            e != t && c2.extend(l.node, l.offset), p2 = true;
          } catch {
          }
        }
        if (!p2) {
          if (e > t) {
            let h2 = a;
            a = l, l = h2;
          }
          let f = document.createRange();
          f.setEnd(l.node, l.offset), f.setStart(a.node, a.offset), c2.removeAllRanges(), c2.addRange(f);
        }
      }
      ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(e, t) {
        for (let r = 0, o = 0; o < this.children.length; o++) {
          let i = this.children[o], s = r + i.size;
          if (r == s ? e <= s && t >= r : e < s && t > r) {
            let a = r + i.border, l = s - i.border;
            if (e >= a && t <= l) {
              this.dirty = e == r || t == s ? Zr : $d, e == a && t == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = Xn : i.markDirty(e - a, t - a);
              return;
            } else
              i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? Zr : Xn;
          }
          r = s;
        }
        this.dirty = Zr;
      }
      markParentsDirty() {
        let e = 1;
        for (let t = this.parent; t; t = t.parent, e++) {
          let r = e == 1 ? Zr : $d;
          t.dirty < r && (t.dirty = r);
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      isText(e) {
        return false;
      }
    }
    class $h extends ns {
      constructor(e, t, r, o) {
        let i, s = t.type.toDOM;
        if (typeof s == "function" && (s = s(r, () => {
          if (!i)
            return o;
          if (i.parent)
            return i.parent.posBeforeChild(i);
        })), !t.type.spec.raw) {
          if (s.nodeType != 1) {
            let a = document.createElement("span");
            a.appendChild(s), s = a;
          }
          s.contentEditable = "false", s.classList.add("ProseMirror-widget");
        }
        super(e, [], s, null), this.widget = t, this.widget = t, i = this;
      }
      matchesWidget(e) {
        return this.dirty == _n && e.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(e) {
        let t = this.widget.spec.stopEvent;
        return t ? t(e) : false;
      }
      ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom), super.destroy();
      }
      get domAtom() {
        return true;
      }
      get side() {
        return this.widget.type.side;
      }
    }
    class Vv extends ns {
      constructor(e, t, r, o) {
        super(e, [], t, null), this.textDOM = r, this.text = o;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(e, t) {
        return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
      }
      domFromPos(e) {
        return { node: this.textDOM, offset: e };
      }
      ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue;
      }
    }
    class fo extends ns {
      constructor(e, t, r, o, i) {
        super(e, [], r, o), this.mark = t, this.spec = i;
      }
      static create(e, t, r, o) {
        let i = o.nodeViews[t.type.name], s = i && i(t, o, r);
        return (!s || !s.dom) && (s = yo.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new fo(e, t, s.dom, s.contentDOM || s.dom, s);
      }
      parseRule() {
        return this.dirty & Xn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(e) {
        return this.dirty != Xn && this.mark.eq(e);
      }
      markDirty(e, t) {
        if (super.markDirty(e, t), this.dirty != _n) {
          let r = this.parent;
          for (; !r.node; )
            r = r.parent;
          r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = _n;
        }
      }
      slice(e, t, r) {
        let o = fo.create(this.parent, this.mark, true, r), i = this.children, s = this.size;
        t < s && (i = vc(i, t, s, r)), e > 0 && (i = vc(i, 0, e, r));
        for (let a = 0; a < i.length; a++)
          i[a].parent = o;
        return o.children = i, o;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
    }
    class Pr extends ns {
      constructor(e, t, r, o, i, s, a, l, c2) {
        super(e, [], i, s), this.node = t, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = a;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(e, t, r, o, i, s) {
        let a = i.nodeViews[t.type.name], l, c2 = a && a(t, i, () => {
          if (!l)
            return s;
          if (l.parent)
            return l.parent.posBeforeChild(l);
        }, r, o), u = c2 && c2.dom, d = c2 && c2.contentDOM;
        if (t.isText) {
          if (!u)
            u = document.createTextNode(t.text);
          else if (u.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else u || ({ dom: u, contentDOM: d } = yo.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
        !d && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = true));
        let p2 = u;
        return u = Uh(u, r, t), c2 ? l = new Wv(e, t, r, o, u, d || null, p2, c2, i, s + 1) : t.isText ? new Xa(e, t, r, o, u, p2, i) : new Pr(e, t, r, o, u, d || null, p2, i, s + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let e = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
          e.getContent = () => this.node.content;
        else if (!this.contentLost)
          e.contentElement = this.contentDOM;
        else {
          for (let t = this.children.length - 1; t >= 0; t--) {
            let r = this.children[t];
            if (this.dom.contains(r.dom.parentNode)) {
              e.contentElement = r.dom.parentNode;
              break;
            }
          }
          e.contentElement || (e.getContent = () => O.empty);
        }
        return e;
      }
      matchesNode(e, t, r) {
        return this.dirty == _n && e.eq(this.node) && ra(t, this.outerDeco) && r.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(e, t) {
        let r = this.node.inlineContent, o = t, i = e.composing ? this.localCompositionInfo(e, t) : null, s = i && i.pos > -1 ? i : null, a = i && i.pos < 0, l = new Kv(this, s && s.node, e);
        Jv(this.node, this.innerDeco, (c2, u, d) => {
          c2.spec.marks ? l.syncToMarks(c2.spec.marks, r, e) : c2.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Ye.none : this.node.child(u).marks, r, e), l.placeWidget(c2, e, o);
        }, (c2, u, d, p2) => {
          l.syncToMarks(c2.marks, r, e);
          let f;
          l.findNodeMatch(c2, u, d, p2) || a && e.state.selection.from > o && e.state.selection.to < o + c2.nodeSize && (f = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c2, u, d, f, e) || l.updateNextNode(c2, u, d, e, p2, o) || l.addNode(c2, u, d, e, o), o += c2.nodeSize;
        }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Zr) && (s && this.protectLocalComposition(e, s), zh(this.contentDOM, this.children, e), Uo && Yv(this.dom));
      }
      localCompositionInfo(e, t) {
        let { from: r, to: o } = e.state.selection;
        if (!(e.state.selection instanceof ie) || r < t || o > t + this.node.content.size)
          return null;
        let i = e.input.compositionNode;
        if (!i || !this.dom.contains(i.parentNode))
          return null;
        if (this.node.inlineContent) {
          let s = i.nodeValue, a = Xv(this.node.content, s, r - t, o - t);
          return a < 0 ? null : { node: i, pos: a, text: s };
        } else
          return { node: i, pos: -1, text: "" };
      }
      protectLocalComposition(e, { node: t, pos: r, text: o }) {
        if (this.getDesc(t))
          return;
        let i = t;
        for (; i.parentNode != this.contentDOM; i = i.parentNode) {
          for (; i.previousSibling; )
            i.parentNode.removeChild(i.previousSibling);
          for (; i.nextSibling; )
            i.parentNode.removeChild(i.nextSibling);
          i.pmViewDesc && (i.pmViewDesc = void 0);
        }
        let s = new Vv(this, i, t, o);
        e.input.compositionNodes.push(s), this.children = vc(this.children, r, r + o.length, e, s);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(e, t, r, o) {
        return this.dirty == Xn || !e.sameMarkup(this.node) ? false : (this.updateInner(e, t, r, o), true);
      }
      updateInner(e, t, r, o) {
        this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = _n;
      }
      updateOuterDeco(e) {
        if (ra(e, this.outerDeco))
          return;
        let t = this.nodeDOM.nodeType != 1, r = this.dom;
        this.dom = Hh(this.dom, this.nodeDOM, yc(this.outerDeco, this.node, t), yc(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
      }
      // Mark this node as being the selected node.
      selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
      }
      // Remove selected node marking from this node.
      deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
      }
      get domAtom() {
        return this.node.isAtom;
      }
    }
    function Fd(n3, e, t, r, o) {
      Uh(r, e, n3);
      let i = new Pr(void 0, n3, e, t, r, r, r, o, 0);
      return i.contentDOM && i.updateChildren(o, 0), i;
    }
    class Xa extends Pr {
      constructor(e, t, r, o, i, s, a) {
        super(e, t, r, o, i, null, s, a, 0);
      }
      parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco; )
          e = e.parentNode;
        return { skip: e || true };
      }
      update(e, t, r, o) {
        return this.dirty == Xn || this.dirty != _n && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(t), (this.dirty != _n || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = _n, true);
      }
      inParent() {
        let e = this.parent.contentDOM;
        for (let t = this.nodeDOM; t; t = t.parentNode)
          if (t == e)
            return true;
        return false;
      }
      domFromPos(e) {
        return { node: this.nodeDOM, offset: e };
      }
      localPosFromDOM(e, t, r) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
      }
      ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection";
      }
      slice(e, t, r) {
        let o = this.node.cut(e, t), i = document.createTextNode(o.text);
        return new Xa(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
      }
      markDirty(e, t) {
        super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Xn);
      }
      get domAtom() {
        return false;
      }
      isText(e) {
        return this.node.text == e;
      }
    }
    class Fh extends ns {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(e) {
        return this.dirty == _n && this.dom.nodeName == e;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    }
    class Wv extends Pr {
      constructor(e, t, r, o, i, s, a, l, c2, u) {
        super(e, t, r, o, i, s, a, c2, u), this.spec = l;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(e, t, r, o) {
        if (this.dirty == Xn)
          return false;
        if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
          let i = this.spec.update(e, t, r);
          return i && this.updateInner(e, t, r, o), i;
        } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, t, r, o);
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(e, t, r, o) {
        this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, o);
      }
      destroy() {
        this.spec.destroy && this.spec.destroy(), super.destroy();
      }
      stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
      }
      ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
      }
    }
    function zh(n3, e, t) {
      let r = n3.firstChild, o = false;
      for (let i = 0; i < e.length; i++) {
        let s = e[i], a = s.dom;
        if (a.parentNode == n3) {
          for (; a != r; )
            r = zd(r), o = true;
          r = r.nextSibling;
        } else
          o = true, n3.insertBefore(a, r);
        if (s instanceof fo) {
          let l = r ? r.previousSibling : n3.lastChild;
          zh(s.contentDOM, s.children, t), r = l ? l.nextSibling : n3.firstChild;
        }
      }
      for (; r; )
        r = zd(r), o = true;
      o && t.trackWrites == n3 && (t.trackWrites = null);
    }
    const wi = function(n3) {
      n3 && (this.nodeName = n3);
    };
    wi.prototype = /* @__PURE__ */ Object.create(null);
    const Qr = [new wi()];
    function yc(n3, e, t) {
      if (n3.length == 0)
        return Qr;
      let r = t ? Qr[0] : new wi(), o = [r];
      for (let i = 0; i < n3.length; i++) {
        let s = n3[i].type.attrs;
        if (s) {
          s.nodeName && o.push(r = new wi(s.nodeName));
          for (let a in s) {
            let l = s[a];
            l != null && (t && o.length == 1 && o.push(r = new wi(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
          }
        }
      }
      return o;
    }
    function Hh(n3, e, t, r) {
      if (t == Qr && r == Qr)
        return e;
      let o = e;
      for (let i = 0; i < r.length; i++) {
        let s = r[i], a = t[i];
        if (i) {
          let l;
          a && a.nodeName == s.nodeName && o != n3 && (l = o.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = true, l.appendChild(o), a = Qr[0]), o = l;
        }
        qv(o, a || Qr[0], s);
      }
      return o;
    }
    function qv(n3, e, t) {
      for (let r in e)
        r != "class" && r != "style" && r != "nodeName" && !(r in t) && n3.removeAttribute(r);
      for (let r in t)
        r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n3.setAttribute(r, t[r]);
      if (e.class != t.class) {
        let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = t.class ? t.class.split(" ").filter(Boolean) : [];
        for (let i = 0; i < r.length; i++)
          o.indexOf(r[i]) == -1 && n3.classList.remove(r[i]);
        for (let i = 0; i < o.length; i++)
          r.indexOf(o[i]) == -1 && n3.classList.add(o[i]);
        n3.classList.length == 0 && n3.removeAttribute("class");
      }
      if (e.style != t.style) {
        if (e.style) {
          let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
          for (; o = r.exec(e.style); )
            n3.style.removeProperty(o[1]);
        }
        t.style && (n3.style.cssText += t.style);
      }
    }
    function Uh(n3, e, t) {
      return Hh(n3, n3, Qr, yc(e, t, n3.nodeType != 1));
    }
    function ra(n3, e) {
      if (n3.length != e.length)
        return false;
      for (let t = 0; t < n3.length; t++)
        if (!n3[t].type.eq(e[t].type))
          return false;
      return true;
    }
    function zd(n3) {
      let e = n3.nextSibling;
      return n3.parentNode.removeChild(n3), e;
    }
    class Kv {
      constructor(e, t, r) {
        this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = Gv(e.node.content, e);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(e, t) {
        if (e != t) {
          for (let r = e; r < t; r++)
            this.top.children[r].destroy();
          this.top.children.splice(e, t - e), this.changed = true;
        }
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(e, t, r) {
        let o = 0, i = this.stack.length >> 1, s = Math.min(i, e.length);
        for (; o < s && (o == i - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== false; )
          o++;
        for (; o < i; )
          this.destroyRest(), this.top.dirty = _n, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
        for (; i < e.length; ) {
          this.stack.push(this.top, this.index + 1);
          let a = -1;
          for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
            let c2 = this.top.children[l];
            if (c2.matchesMark(e[i]) && !this.isLocked(c2.dom)) {
              a = l;
              break;
            }
          }
          if (a > -1)
            a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
          else {
            let l = fo.create(this.top, e[i], t, r);
            this.top.children.splice(this.index, 0, l), this.top = l, this.changed = true;
          }
          this.index = 0, i++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(e, t, r, o) {
        let i = -1, s;
        if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(e, t, r))
          i = this.top.children.indexOf(s, this.index);
        else
          for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
            let c2 = this.top.children[a];
            if (c2.matchesNode(e, t, r) && !this.preMatch.matched.has(c2)) {
              i = a;
              break;
            }
          }
        return i < 0 ? false : (this.destroyBetween(this.index, i), this.index++, true);
      }
      updateNodeAt(e, t, r, o, i) {
        let s = this.top.children[o];
        return s.dirty == Xn && s.dom == s.contentDOM && (s.dirty = Zr), s.update(e, t, r, i) ? (this.destroyBetween(this.index, o), this.index++, true) : false;
      }
      findIndexWithChild(e) {
        for (; ; ) {
          let t = e.parentNode;
          if (!t)
            return -1;
          if (t == this.top.contentDOM) {
            let r = e.pmViewDesc;
            if (r) {
              for (let o = this.index; o < this.top.children.length; o++)
                if (this.top.children[o] == r)
                  return o;
            }
            return -1;
          }
          e = t;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(e, t, r, o, i, s) {
        for (let a = this.index; a < this.top.children.length; a++) {
          let l = this.top.children[a];
          if (l instanceof Pr) {
            let c2 = this.preMatch.matched.get(l);
            if (c2 != null && c2 != i)
              return false;
            let u = l.dom, d, p2 = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Xn && ra(t, l.outerDeco));
            if (!p2 && l.update(e, t, r, o))
              return this.destroyBetween(this.index, a), l.dom != u && (this.changed = true), this.index++, true;
            if (!p2 && (d = this.recreateWrapper(l, e, t, r, o, s)))
              return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Zr, d.updateChildren(o, s + 1), d.dirty = _n), this.changed = true, this.index++, true;
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(e, t, r, o, i, s) {
        if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !ra(r, e.outerDeco) || !o.eq(e.innerDeco))
          return null;
        let a = Pr.create(this.top, t, r, o, i, s);
        if (a.contentDOM) {
          a.children = e.children, e.children = [];
          for (let l of a.children)
            l.parent = a;
        }
        return e.destroy(), a;
      }
      // Insert the node as a newly created node desc.
      addNode(e, t, r, o, i) {
        let s = Pr.create(this.top, e, t, r, o, i);
        s.contentDOM && s.updateChildren(o, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = true;
      }
      placeWidget(e, t, r) {
        let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
          this.index++;
        else {
          let i = new $h(this.top, e, t, r);
          this.top.children.splice(this.index++, 0, i), this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let e = this.top.children[this.index - 1], t = this.top;
        for (; e instanceof fo; )
          t = e, e = t.children[t.children.length - 1];
        (!e || // Empty textblock
        !(e instanceof Xa) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Yt || zt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
      }
      addHackNode(e, t) {
        if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
          this.index++;
        else {
          let r = document.createElement(e);
          e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
          let o = new Fh(this.top, [], r, null);
          t != this.top ? t.children.push(o) : t.children.splice(this.index++, 0, o), this.changed = true;
        }
      }
      isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
      }
    }
    function Gv(n3, e) {
      let t = e, r = t.children.length, o = n3.childCount, i = /* @__PURE__ */ new Map(), s = [];
      e: for (; o > 0; ) {
        let a;
        for (; ; )
          if (r) {
            let c2 = t.children[r - 1];
            if (c2 instanceof fo)
              t = c2, r = c2.children.length;
            else {
              a = c2, r--;
              break;
            }
          } else {
            if (t == e)
              break e;
            r = t.parent.children.indexOf(t), t = t.parent;
          }
        let l = a.node;
        if (l) {
          if (l != n3.child(o - 1))
            break;
          --o, i.set(a, o), s.push(a);
        }
      }
      return { index: o, matched: i, matches: s.reverse() };
    }
    function jv(n3, e) {
      return n3.type.side - e.type.side;
    }
    function Jv(n3, e, t, r) {
      let o = e.locals(n3), i = 0;
      if (o.length == 0) {
        for (let c2 = 0; c2 < n3.childCount; c2++) {
          let u = n3.child(c2);
          r(u, o, e.forChild(i, u), c2), i += u.nodeSize;
        }
        return;
      }
      let s = 0, a = [], l = null;
      for (let c2 = 0; ; ) {
        let u, d;
        for (; s < o.length && o[s].to == i; ) {
          let g = o[s++];
          g.widget && (u ? (d || (d = [u])).push(g) : u = g);
        }
        if (u)
          if (d) {
            d.sort(jv);
            for (let g = 0; g < d.length; g++)
              t(d[g], c2, !!l);
          } else
            t(u, c2, !!l);
        let p2, f;
        if (l)
          f = -1, p2 = l, l = null;
        else if (c2 < n3.childCount)
          f = c2, p2 = n3.child(c2++);
        else
          break;
        for (let g = 0; g < a.length; g++)
          a[g].to <= i && a.splice(g--, 1);
        for (; s < o.length && o[s].from <= i && o[s].to > i; )
          a.push(o[s++]);
        let h2 = i + p2.nodeSize;
        if (p2.isText) {
          let g = h2;
          s < o.length && o[s].from < g && (g = o[s].from);
          for (let b = 0; b < a.length; b++)
            a[b].to < g && (g = a[b].to);
          g < h2 && (l = p2.cut(g - i), p2 = p2.cut(0, g - i), h2 = g, f = -1);
        } else
          for (; s < o.length && o[s].to < h2; )
            s++;
        let m = p2.isInline && !p2.isLeaf ? a.filter((g) => !g.inline) : a.slice();
        r(p2, m, e.forChild(i, p2), f), i = h2;
      }
    }
    function Yv(n3) {
      if (n3.nodeName == "UL" || n3.nodeName == "OL") {
        let e = n3.style.cssText;
        n3.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n3).listStyle, n3.style.cssText = e;
      }
    }
    function Xv(n3, e, t, r) {
      for (let o = 0, i = 0; o < n3.childCount && i <= r; ) {
        let s = n3.child(o++), a = i;
        if (i += s.nodeSize, !s.isText)
          continue;
        let l = s.text;
        for (; o < n3.childCount; ) {
          let c2 = n3.child(o++);
          if (i += c2.nodeSize, !c2.isText)
            break;
          l += c2.text;
        }
        if (i >= t) {
          if (i >= r && l.slice(r - e.length - a, r - a) == e)
            return r - e.length;
          let c2 = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
          if (c2 >= 0 && c2 + e.length + a >= t)
            return a + c2;
          if (t == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
            return r;
        }
      }
      return -1;
    }
    function vc(n3, e, t, r, o) {
      let i = [];
      for (let s = 0, a = 0; s < n3.length; s++) {
        let l = n3[s], c2 = a, u = a += l.size;
        c2 >= t || u <= e ? i.push(l) : (c2 < e && i.push(l.slice(0, e - c2, r)), o && (i.push(o), o = void 0), u > t && i.push(l.slice(t - c2, l.size, r)));
      }
      return i;
    }
    function ou(n3, e = null) {
      let t = n3.domSelectionRange(), r = n3.state.doc;
      if (!t.focusNode)
        return null;
      let o = n3.docView.nearestDesc(t.focusNode), i = o && o.size == 0, s = n3.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
      if (s < 0)
        return null;
      let a = r.resolve(s), l, c2;
      if (Ya(t)) {
        for (l = s; o && !o.node; )
          o = o.parent;
        let d = o.node;
        if (o && d.isAtom && ne.isSelectable(d) && o.parent && !(d.isInline && _v(t.focusNode, t.focusOffset, o.dom))) {
          let p2 = o.posBefore;
          c2 = new ne(s == p2 ? a : r.resolve(p2));
        }
      } else {
        if (t instanceof n3.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
          let d = s, p2 = s;
          for (let f = 0; f < t.rangeCount; f++) {
            let h2 = t.getRangeAt(f);
            d = Math.min(d, n3.docView.posFromDOM(h2.startContainer, h2.startOffset, 1)), p2 = Math.max(p2, n3.docView.posFromDOM(h2.endContainer, h2.endOffset, -1));
          }
          if (d < 0)
            return null;
          [l, s] = p2 == n3.state.selection.anchor ? [p2, d] : [d, p2], a = r.resolve(s);
        } else
          l = n3.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
        if (l < 0)
          return null;
      }
      let u = r.resolve(l);
      if (!c2) {
        let d = e == "pointer" || n3.state.selection.head < a.pos && !i ? 1 : -1;
        c2 = iu(n3, u, a, d);
      }
      return c2;
    }
    function Vh(n3) {
      return n3.editable ? n3.hasFocus() : qh(n3) && document.activeElement && document.activeElement.contains(n3.dom);
    }
    function fr(n3, e = false) {
      let t = n3.state.selection;
      if (Wh(n3, t), !!Vh(n3)) {
        if (!e && n3.input.mouseDown && n3.input.mouseDown.allowDefault && zt) {
          let r = n3.domSelectionRange(), o = n3.domObserver.currentSelection;
          if (r.anchorNode && o.anchorNode && po(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
            n3.input.mouseDown.delayedSelectionSync = true, n3.domObserver.setCurSelection();
            return;
          }
        }
        if (n3.domObserver.disconnectSelection(), n3.cursorWrapper)
          Qv(n3);
        else {
          let { anchor: r, head: o } = t, i, s;
          Hd && !(t instanceof ie) && (t.$from.parent.inlineContent || (i = Ud(n3, t.from)), !t.empty && !t.$from.parent.inlineContent && (s = Ud(n3, t.to))), n3.docView.setSelection(r, o, n3, e), Hd && (i && Vd(i), s && Vd(s)), t.visible ? n3.dom.classList.remove("ProseMirror-hideselection") : (n3.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Zv(n3));
        }
        n3.domObserver.setCurSelection(), n3.domObserver.connectSelection();
      }
    }
    const Hd = Yt || zt && Ah < 63;
    function Ud(n3, e) {
      let { node: t, offset: r } = n3.docView.domFromPos(e, 0), o = r < t.childNodes.length ? t.childNodes[r] : null, i = r ? t.childNodes[r - 1] : null;
      if (Yt && o && o.contentEditable == "false")
        return Ml(o);
      if ((!o || o.contentEditable == "false") && (!i || i.contentEditable == "false")) {
        if (o)
          return Ml(o);
        if (i)
          return Ml(i);
      }
    }
    function Ml(n3) {
      return n3.contentEditable = "true", Yt && n3.draggable && (n3.draggable = false, n3.wasDraggable = true), n3;
    }
    function Vd(n3) {
      n3.contentEditable = "false", n3.wasDraggable && (n3.draggable = true, n3.wasDraggable = null);
    }
    function Zv(n3) {
      let e = n3.dom.ownerDocument;
      e.removeEventListener("selectionchange", n3.input.hideSelectionGuard);
      let t = n3.domSelectionRange(), r = t.anchorNode, o = t.anchorOffset;
      e.addEventListener("selectionchange", n3.input.hideSelectionGuard = () => {
        (t.anchorNode != r || t.anchorOffset != o) && (e.removeEventListener("selectionchange", n3.input.hideSelectionGuard), setTimeout(() => {
          (!Vh(n3) || n3.state.selection.visible) && n3.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
      });
    }
    function Qv(n3) {
      let e = n3.domSelection(), t = document.createRange();
      if (!e)
        return;
      let r = n3.cursorWrapper.dom, o = r.nodeName == "IMG";
      o ? t.setStart(r.parentNode, It(r) + 1) : t.setStart(r, 0), t.collapse(true), e.removeAllRanges(), e.addRange(t), !o && !n3.state.selection.visible && nn && Br <= 11 && (r.disabled = true, r.disabled = false);
    }
    function Wh(n3, e) {
      if (e instanceof ne) {
        let t = n3.docView.descAt(e.from);
        t != n3.lastSelectedViewDesc && (Wd(n3), t && t.selectNode(), n3.lastSelectedViewDesc = t);
      } else
        Wd(n3);
    }
    function Wd(n3) {
      n3.lastSelectedViewDesc && (n3.lastSelectedViewDesc.parent && n3.lastSelectedViewDesc.deselectNode(), n3.lastSelectedViewDesc = void 0);
    }
    function iu(n3, e, t, r) {
      return n3.someProp("createSelectionBetween", (o) => o(n3, e, t)) || ie.between(e, t, r);
    }
    function qd(n3) {
      return n3.editable && !n3.hasFocus() ? false : qh(n3);
    }
    function qh(n3) {
      let e = n3.domSelectionRange();
      if (!e.anchorNode)
        return false;
      try {
        return n3.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n3.editable || n3.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
      } catch {
        return false;
      }
    }
    function e0(n3) {
      let e = n3.docView.domFromPos(n3.state.selection.anchor, 0), t = n3.domSelectionRange();
      return po(e.node, e.offset, t.anchorNode, t.anchorOffset);
    }
    function wc(n3, e) {
      let { $anchor: t, $head: r } = n3.selection, o = e > 0 ? t.max(r) : t.min(r), i = o.parent.inlineContent ? o.depth ? n3.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
      return i && ue.findFrom(i, e);
    }
    function Sr(n3, e) {
      return n3.dispatch(n3.state.tr.setSelection(e).scrollIntoView()), true;
    }
    function Kd(n3, e, t) {
      let r = n3.state.selection;
      if (r instanceof ie)
        if (t.indexOf("s") > -1) {
          let { $head: o } = r, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
          if (!i || i.isText || !i.isLeaf)
            return false;
          let s = n3.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
          return Sr(n3, new ie(r.$anchor, s));
        } else if (r.empty) {
          if (n3.endOfTextblock(e > 0 ? "forward" : "backward")) {
            let o = wc(n3.state, e);
            return o && o instanceof ne ? Sr(n3, o) : false;
          } else if (!(wn && t.indexOf("m") > -1)) {
            let o = r.$head, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, s;
            if (!i || i.isText)
              return false;
            let a = e < 0 ? o.pos - i.nodeSize : o.pos;
            return i.isAtom || (s = n3.docView.descAt(a)) && !s.contentDOM ? ne.isSelectable(i) ? Sr(n3, new ne(e < 0 ? n3.state.doc.resolve(o.pos - i.nodeSize) : o)) : ts ? Sr(n3, new ie(n3.state.doc.resolve(e < 0 ? a : a + i.nodeSize))) : false : false;
          }
        } else return false;
      else {
        if (r instanceof ne && r.node.isInline)
          return Sr(n3, new ie(e > 0 ? r.$to : r.$from));
        {
          let o = wc(n3.state, e);
          return o ? Sr(n3, o) : false;
        }
      }
    }
    function oa(n3) {
      return n3.nodeType == 3 ? n3.nodeValue.length : n3.childNodes.length;
    }
    function ki(n3, e) {
      let t = n3.pmViewDesc;
      return t && t.size == 0 && (e < 0 || n3.nextSibling || n3.nodeName != "BR");
    }
    function _o(n3, e) {
      return e < 0 ? t0(n3) : n0(n3);
    }
    function t0(n3) {
      let e = n3.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
      if (!t)
        return;
      let o, i, s = false;
      for (Ln && t.nodeType == 1 && r < oa(t) && ki(t.childNodes[r], -1) && (s = true); ; )
        if (r > 0) {
          if (t.nodeType != 1)
            break;
          {
            let a = t.childNodes[r - 1];
            if (ki(a, -1))
              o = t, i = --r;
            else if (a.nodeType == 3)
              t = a, r = t.nodeValue.length;
            else
              break;
          }
        } else {
          if (Kh(t))
            break;
          {
            let a = t.previousSibling;
            for (; a && ki(a, -1); )
              o = t.parentNode, i = It(a), a = a.previousSibling;
            if (a)
              t = a, r = oa(t);
            else {
              if (t = t.parentNode, t == n3.dom)
                break;
              r = 0;
            }
          }
        }
      s ? kc(n3, t, r) : o && kc(n3, o, i);
    }
    function n0(n3) {
      let e = n3.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
      if (!t)
        return;
      let o = oa(t), i, s;
      for (; ; )
        if (r < o) {
          if (t.nodeType != 1)
            break;
          let a = t.childNodes[r];
          if (ki(a, 1))
            i = t, s = ++r;
          else
            break;
        } else {
          if (Kh(t))
            break;
          {
            let a = t.nextSibling;
            for (; a && ki(a, 1); )
              i = a.parentNode, s = It(a) + 1, a = a.nextSibling;
            if (a)
              t = a, r = 0, o = oa(t);
            else {
              if (t = t.parentNode, t == n3.dom)
                break;
              r = o = 0;
            }
          }
        }
      i && kc(n3, i, s);
    }
    function Kh(n3) {
      let e = n3.pmViewDesc;
      return e && e.node && e.node.isBlock;
    }
    function r0(n3, e) {
      for (; n3 && e == n3.childNodes.length && !es(n3); )
        e = It(n3) + 1, n3 = n3.parentNode;
      for (; n3 && e < n3.childNodes.length; ) {
        let t = n3.childNodes[e];
        if (t.nodeType == 3)
          return t;
        if (t.nodeType == 1 && t.contentEditable == "false")
          break;
        n3 = t, e = 0;
      }
    }
    function o0(n3, e) {
      for (; n3 && !e && !es(n3); )
        e = It(n3), n3 = n3.parentNode;
      for (; n3 && e; ) {
        let t = n3.childNodes[e - 1];
        if (t.nodeType == 3)
          return t;
        if (t.nodeType == 1 && t.contentEditable == "false")
          break;
        n3 = t, e = n3.childNodes.length;
      }
    }
    function kc(n3, e, t) {
      if (e.nodeType != 3) {
        let i, s;
        (s = r0(e, t)) ? (e = s, t = 0) : (i = o0(e, t)) && (e = i, t = i.nodeValue.length);
      }
      let r = n3.domSelection();
      if (!r)
        return;
      if (Ya(r)) {
        let i = document.createRange();
        i.setEnd(e, t), i.setStart(e, t), r.removeAllRanges(), r.addRange(i);
      } else r.extend && r.extend(e, t);
      n3.domObserver.setCurSelection();
      let { state: o } = n3;
      setTimeout(() => {
        n3.state == o && fr(n3);
      }, 50);
    }
    function Gd(n3, e) {
      let t = n3.state.doc.resolve(e);
      if (!(zt || xv) && t.parent.inlineContent) {
        let o = n3.coordsAtPos(e);
        if (e > t.start()) {
          let i = n3.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
          if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
            return i.left < o.left ? "ltr" : "rtl";
        }
        if (e < t.end()) {
          let i = n3.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
          if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
            return i.left > o.left ? "ltr" : "rtl";
        }
      }
      return getComputedStyle(n3.dom).direction == "rtl" ? "rtl" : "ltr";
    }
    function jd(n3, e, t) {
      let r = n3.state.selection;
      if (r instanceof ie && !r.empty || t.indexOf("s") > -1 || wn && t.indexOf("m") > -1)
        return false;
      let { $from: o, $to: i } = r;
      if (!o.parent.inlineContent || n3.endOfTextblock(e < 0 ? "up" : "down")) {
        let s = wc(n3.state, e);
        if (s && s instanceof ne)
          return Sr(n3, s);
      }
      if (!o.parent.inlineContent) {
        let s = e < 0 ? o : i, a = r instanceof hn ? ue.near(s, e) : ue.findFrom(s, e);
        return a ? Sr(n3, a) : false;
      }
      return false;
    }
    function Jd(n3, e) {
      if (!(n3.state.selection instanceof ie))
        return true;
      let { $head: t, $anchor: r, empty: o } = n3.state.selection;
      if (!t.sameParent(r))
        return true;
      if (!o)
        return false;
      if (n3.endOfTextblock(e > 0 ? "forward" : "backward"))
        return true;
      let i = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
      if (i && !i.isText) {
        let s = n3.state.tr;
        return e < 0 ? s.delete(t.pos - i.nodeSize, t.pos) : s.delete(t.pos, t.pos + i.nodeSize), n3.dispatch(s), true;
      }
      return false;
    }
    function Yd(n3, e, t) {
      n3.domObserver.stop(), e.contentEditable = t, n3.domObserver.start();
    }
    function i0(n3) {
      if (!Yt || n3.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode: e, focusOffset: t } = n3.domSelectionRange();
      if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let r = e.firstChild;
        Yd(n3, r, "true"), setTimeout(() => Yd(n3, r, "false"), 20);
      }
      return false;
    }
    function s0(n3) {
      let e = "";
      return n3.ctrlKey && (e += "c"), n3.metaKey && (e += "m"), n3.altKey && (e += "a"), n3.shiftKey && (e += "s"), e;
    }
    function a0(n3, e) {
      let t = e.keyCode, r = s0(e);
      if (t == 8 || wn && t == 72 && r == "c")
        return Jd(n3, -1) || _o(n3, -1);
      if (t == 46 && !e.shiftKey || wn && t == 68 && r == "c")
        return Jd(n3, 1) || _o(n3, 1);
      if (t == 13 || t == 27)
        return true;
      if (t == 37 || wn && t == 66 && r == "c") {
        let o = t == 37 ? Gd(n3, n3.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return Kd(n3, o, r) || _o(n3, o);
      } else if (t == 39 || wn && t == 70 && r == "c") {
        let o = t == 39 ? Gd(n3, n3.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return Kd(n3, o, r) || _o(n3, o);
      } else {
        if (t == 38 || wn && t == 80 && r == "c")
          return jd(n3, -1, r) || _o(n3, -1);
        if (t == 40 || wn && t == 78 && r == "c")
          return i0(n3) || jd(n3, 1, r) || _o(n3, 1);
        if (r == (wn ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
          return true;
      }
      return false;
    }
    function su(n3, e) {
      n3.someProp("transformCopied", (f) => {
        e = f(e, n3);
      });
      let t = [], { content: r, openStart: o, openEnd: i } = e;
      for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        o--, i--;
        let f = r.firstChild;
        t.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null), r = f.content;
      }
      let s = n3.someProp("clipboardSerializer") || yo.fromSchema(n3.state.schema), a = Zh(), l = a.createElement("div");
      l.appendChild(s.serializeFragment(r, { document: a }));
      let c2 = l.firstChild, u, d = 0;
      for (; c2 && c2.nodeType == 1 && (u = Xh[c2.nodeName.toLowerCase()]); ) {
        for (let f = u.length - 1; f >= 0; f--) {
          let h2 = a.createElement(u[f]);
          for (; l.firstChild; )
            h2.appendChild(l.firstChild);
          l.appendChild(h2), d++;
        }
        c2 = l.firstChild;
      }
      c2 && c2.nodeType == 1 && c2.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`);
      let p2 = n3.someProp("clipboardTextSerializer", (f) => f(e, n3)) || e.content.textBetween(0, e.content.size, `

`);
      return { dom: l, text: p2, slice: e };
    }
    function Gh(n3, e, t, r, o) {
      let i = o.parent.type.spec.code, s, a;
      if (!t && !e)
        return null;
      let l = e && (r || i || !t);
      if (l) {
        if (n3.someProp("transformPastedText", (p2) => {
          e = p2(e, i || r, n3);
        }), i)
          return e ? new I(O.from(n3.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : I.empty;
        let d = n3.someProp("clipboardTextParser", (p2) => p2(e, o, r, n3));
        if (d)
          a = d;
        else {
          let p2 = o.marks(), { schema: f } = n3.state, h2 = yo.fromSchema(f);
          s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
            let g = s.appendChild(document.createElement("p"));
            m && g.appendChild(h2.serializeNode(f.text(m, p2)));
          });
        }
      } else
        n3.someProp("transformPastedHTML", (d) => {
          t = d(t, n3);
        }), s = d0(t), ts && p0(s);
      let c2 = s && s.querySelector("[data-pm-slice]"), u = c2 && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c2.getAttribute("data-pm-slice") || "");
      if (u && u[3])
        for (let d = +u[3]; d > 0; d--) {
          let p2 = s.firstChild;
          for (; p2 && p2.nodeType != 1; )
            p2 = p2.nextSibling;
          if (!p2)
            break;
          s = p2;
        }
      if (a || (a = (n3.someProp("clipboardParser") || n3.someProp("domParser") || Lr.fromSchema(n3.state.schema)).parseSlice(s, {
        preserveWhitespace: !!(l || u),
        context: o,
        ruleFromNode(p2) {
          return p2.nodeName == "BR" && !p2.nextSibling && p2.parentNode && !l0.test(p2.parentNode.nodeName) ? { ignore: true } : null;
        }
      })), u)
        a = f0(Xd(a, +u[1], +u[2]), u[4]);
      else if (a = I.maxOpen(c0(a.content, o), true), a.openStart || a.openEnd) {
        let d = 0, p2 = 0;
        for (let f = a.content.firstChild; d < a.openStart && !f.type.spec.isolating; d++, f = f.firstChild)
          ;
        for (let f = a.content.lastChild; p2 < a.openEnd && !f.type.spec.isolating; p2++, f = f.lastChild)
          ;
        a = Xd(a, d, p2);
      }
      return n3.someProp("transformPasted", (d) => {
        a = d(a, n3);
      }), a;
    }
    const l0 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function c0(n3, e) {
      if (n3.childCount < 2)
        return n3;
      for (let t = e.depth; t >= 0; t--) {
        let o = e.node(t).contentMatchAt(e.index(t)), i, s = [];
        if (n3.forEach((a) => {
          if (!s)
            return;
          let l = o.findWrapping(a.type), c2;
          if (!l)
            return s = null;
          if (c2 = s.length && i.length && Jh(l, i, a, s[s.length - 1], 0))
            s[s.length - 1] = c2;
          else {
            s.length && (s[s.length - 1] = Yh(s[s.length - 1], i.length));
            let u = jh(a, l);
            s.push(u), o = o.matchType(u.type), i = l;
          }
        }), s)
          return O.from(s);
      }
      return n3;
    }
    function jh(n3, e, t = 0) {
      for (let r = e.length - 1; r >= t; r--)
        n3 = e[r].create(null, O.from(n3));
      return n3;
    }
    function Jh(n3, e, t, r, o) {
      if (o < n3.length && o < e.length && n3[o] == e[o]) {
        let i = Jh(n3, e, t, r.lastChild, o + 1);
        if (i)
          return r.copy(r.content.replaceChild(r.childCount - 1, i));
        if (r.contentMatchAt(r.childCount).matchType(o == n3.length - 1 ? t.type : n3[o + 1]))
          return r.copy(r.content.append(O.from(jh(t, n3, o + 1))));
      }
    }
    function Yh(n3, e) {
      if (e == 0)
        return n3;
      let t = n3.content.replaceChild(n3.childCount - 1, Yh(n3.lastChild, e - 1)), r = n3.contentMatchAt(n3.childCount).fillBefore(O.empty, true);
      return n3.copy(t.append(r));
    }
    function Ec(n3, e, t, r, o, i) {
      let s = e < 0 ? n3.firstChild : n3.lastChild, a = s.content;
      return n3.childCount > 1 && (i = 0), o < r - 1 && (a = Ec(a, e, t, r, o + 1, i)), o >= t && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(O.empty, true))), n3.replaceChild(e < 0 ? 0 : n3.childCount - 1, s.copy(a));
    }
    function Xd(n3, e, t) {
      return e < n3.openStart && (n3 = new I(Ec(n3.content, -1, e, n3.openStart, 0, n3.openEnd), e, n3.openEnd)), t < n3.openEnd && (n3 = new I(Ec(n3.content, 1, t, n3.openEnd, 0, 0), n3.openStart, t)), n3;
    }
    const Xh = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    let Zd = null;
    function Zh() {
      return Zd || (Zd = document.implementation.createHTMLDocument("title"));
    }
    let Al = null;
    function u0(n3) {
      let e = window.trustedTypes;
      return e ? (Al || (Al = e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), Al.createHTML(n3)) : n3;
    }
    function d0(n3) {
      let e = /^(\s*<meta [^>]*>)*/.exec(n3);
      e && (n3 = n3.slice(e[0].length));
      let t = Zh().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n3), o;
      if ((o = r && Xh[r[1].toLowerCase()]) && (n3 = o.map((i) => "<" + i + ">").join("") + n3 + o.map((i) => "</" + i + ">").reverse().join("")), t.innerHTML = u0(n3), o)
        for (let i = 0; i < o.length; i++)
          t = t.querySelector(o[i]) || t;
      return t;
    }
    function p0(n3) {
      let e = n3.querySelectorAll(zt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let t = 0; t < e.length; t++) {
        let r = e[t];
        r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(n3.ownerDocument.createTextNode(" "), r);
      }
    }
    function f0(n3, e) {
      if (!n3.size)
        return n3;
      let t = n3.content.firstChild.type.schema, r;
      try {
        r = JSON.parse(e);
      } catch {
        return n3;
      }
      let { content: o, openStart: i, openEnd: s } = n3;
      for (let a = r.length - 2; a >= 0; a -= 2) {
        let l = t.nodes[r[a]];
        if (!l || l.hasRequiredAttrs())
          break;
        o = O.from(l.create(r[a + 1], o)), i++, s++;
      }
      return new I(o, i, s);
    }
    const Xt = {}, Zt = {}, h0 = { touchstart: true, touchmove: true };
    class m0 {
      constructor() {
        this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
      }
    }
    function g0(n3) {
      for (let e in Xt) {
        let t = Xt[e];
        n3.dom.addEventListener(e, n3.input.eventHandlers[e] = (r) => {
          y0(n3, r) && !au(n3, r) && (n3.editable || !(r.type in Zt)) && t(n3, r);
        }, h0[e] ? { passive: true } : void 0);
      }
      Yt && n3.dom.addEventListener("input", () => null), _c(n3);
    }
    function Rr(n3, e) {
      n3.input.lastSelectionOrigin = e, n3.input.lastSelectionTime = Date.now();
    }
    function b0(n3) {
      n3.domObserver.stop();
      for (let e in n3.input.eventHandlers)
        n3.dom.removeEventListener(e, n3.input.eventHandlers[e]);
      clearTimeout(n3.input.composingTimeout), clearTimeout(n3.input.lastIOSEnterFallbackTimeout);
    }
    function _c(n3) {
      n3.someProp("handleDOMEvents", (e) => {
        for (let t in e)
          n3.input.eventHandlers[t] || n3.dom.addEventListener(t, n3.input.eventHandlers[t] = (r) => au(n3, r));
      });
    }
    function au(n3, e) {
      return n3.someProp("handleDOMEvents", (t) => {
        let r = t[e.type];
        return r ? r(n3, e) || e.defaultPrevented : false;
      });
    }
    function y0(n3, e) {
      if (!e.bubbles)
        return true;
      if (e.defaultPrevented)
        return false;
      for (let t = e.target; t != n3.dom; t = t.parentNode)
        if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
          return false;
      return true;
    }
    function v0(n3, e) {
      !au(n3, e) && Xt[e.type] && (n3.editable || !(e.type in Zt)) && Xt[e.type](n3, e);
    }
    Zt.keydown = (n3, e) => {
      let t = e;
      if (n3.input.shiftKey = t.keyCode == 16 || t.shiftKey, !em(n3, t) && (n3.input.lastKeyCode = t.keyCode, n3.input.lastKeyCodeTime = Date.now(), !(ur && zt && t.keyCode == 13)))
        if (t.keyCode != 229 && n3.domObserver.forceFlush(), Uo && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
          let r = Date.now();
          n3.input.lastIOSEnter = r, n3.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            n3.input.lastIOSEnter == r && (n3.someProp("handleKeyDown", (o) => o(n3, Yr(13, "Enter"))), n3.input.lastIOSEnter = 0);
          }, 200);
        } else n3.someProp("handleKeyDown", (r) => r(n3, t)) || a0(n3, t) ? t.preventDefault() : Rr(n3, "key");
    };
    Zt.keyup = (n3, e) => {
      e.keyCode == 16 && (n3.input.shiftKey = false);
    };
    Zt.keypress = (n3, e) => {
      let t = e;
      if (em(n3, t) || !t.charCode || t.ctrlKey && !t.altKey || wn && t.metaKey)
        return;
      if (n3.someProp("handleKeyPress", (o) => o(n3, t))) {
        t.preventDefault();
        return;
      }
      let r = n3.state.selection;
      if (!(r instanceof ie) || !r.$from.sameParent(r.$to)) {
        let o = String.fromCharCode(t.charCode);
        !/[\r\n]/.test(o) && !n3.someProp("handleTextInput", (i) => i(n3, r.$from.pos, r.$to.pos, o)) && n3.dispatch(n3.state.tr.insertText(o).scrollIntoView()), t.preventDefault();
      }
    };
    function Za(n3) {
      return { left: n3.clientX, top: n3.clientY };
    }
    function w0(n3, e) {
      let t = e.x - n3.clientX, r = e.y - n3.clientY;
      return t * t + r * r < 100;
    }
    function lu(n3, e, t, r, o) {
      if (r == -1)
        return false;
      let i = n3.state.doc.resolve(r);
      for (let s = i.depth + 1; s > 0; s--)
        if (n3.someProp(e, (a) => s > i.depth ? a(n3, t, i.nodeAfter, i.before(s), o, true) : a(n3, t, i.node(s), i.before(s), o, false)))
          return true;
      return false;
    }
    function $o(n3, e, t) {
      if (n3.focused || n3.focus(), n3.state.selection.eq(e))
        return;
      let r = n3.state.tr.setSelection(e);
      r.setMeta("pointer", true), n3.dispatch(r);
    }
    function k0(n3, e) {
      if (e == -1)
        return false;
      let t = n3.state.doc.resolve(e), r = t.nodeAfter;
      return r && r.isAtom && ne.isSelectable(r) ? ($o(n3, new ne(t)), true) : false;
    }
    function E0(n3, e) {
      if (e == -1)
        return false;
      let t = n3.state.selection, r, o;
      t instanceof ne && (r = t.node);
      let i = n3.state.doc.resolve(e);
      for (let s = i.depth + 1; s > 0; s--) {
        let a = s > i.depth ? i.nodeAfter : i.node(s);
        if (ne.isSelectable(a)) {
          r && t.$from.depth > 0 && s >= t.$from.depth && i.before(t.$from.depth + 1) == t.$from.pos ? o = i.before(t.$from.depth) : o = i.before(s);
          break;
        }
      }
      return o != null ? ($o(n3, ne.create(n3.state.doc, o)), true) : false;
    }
    function _0(n3, e, t, r, o) {
      return lu(n3, "handleClickOn", e, t, r) || n3.someProp("handleClick", (i) => i(n3, e, r)) || (o ? E0(n3, t) : k0(n3, t));
    }
    function S0(n3, e, t, r) {
      return lu(n3, "handleDoubleClickOn", e, t, r) || n3.someProp("handleDoubleClick", (o) => o(n3, e, r));
    }
    function C0(n3, e, t, r) {
      return lu(n3, "handleTripleClickOn", e, t, r) || n3.someProp("handleTripleClick", (o) => o(n3, e, r)) || x0(n3, t, r);
    }
    function x0(n3, e, t) {
      if (t.button != 0)
        return false;
      let r = n3.state.doc;
      if (e == -1)
        return r.inlineContent ? ($o(n3, ie.create(r, 0, r.content.size)), true) : false;
      let o = r.resolve(e);
      for (let i = o.depth + 1; i > 0; i--) {
        let s = i > o.depth ? o.nodeAfter : o.node(i), a = o.before(i);
        if (s.inlineContent)
          $o(n3, ie.create(r, a + 1, a + 1 + s.content.size));
        else if (ne.isSelectable(s))
          $o(n3, ne.create(r, a));
        else
          continue;
        return true;
      }
    }
    function cu(n3) {
      return ia(n3);
    }
    const Qh = wn ? "metaKey" : "ctrlKey";
    Xt.mousedown = (n3, e) => {
      let t = e;
      n3.input.shiftKey = t.shiftKey;
      let r = cu(n3), o = Date.now(), i = "singleClick";
      o - n3.input.lastClick.time < 500 && w0(t, n3.input.lastClick) && !t[Qh] && (n3.input.lastClick.type == "singleClick" ? i = "doubleClick" : n3.input.lastClick.type == "doubleClick" && (i = "tripleClick")), n3.input.lastClick = { time: o, x: t.clientX, y: t.clientY, type: i };
      let s = n3.posAtCoords(Za(t));
      s && (i == "singleClick" ? (n3.input.mouseDown && n3.input.mouseDown.done(), n3.input.mouseDown = new T0(n3, s, t, !!r)) : (i == "doubleClick" ? S0 : C0)(n3, s.pos, s.inside, t) ? t.preventDefault() : Rr(n3, "pointer"));
    };
    class T0 {
      constructor(e, t, r, o) {
        this.view = e, this.pos = t, this.event = r, this.flushed = o, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[Qh], this.allowDefault = r.shiftKey;
        let i, s;
        if (t.inside > -1)
          i = e.state.doc.nodeAt(t.inside), s = t.inside;
        else {
          let u = e.state.doc.resolve(t.pos);
          i = u.parent, s = u.depth ? u.before() : 0;
        }
        const a = o ? null : r.target, l = a ? e.docView.nearestDesc(a, true) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let { selection: c2 } = e.state;
        (r.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== false || c2 instanceof ne && c2.from <= s && c2.to > s) && (this.mightDrag = {
          node: i,
          pos: s,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && Ln && !this.target.hasAttribute("contentEditable"))
        }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
          this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
        }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Rr(e, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => fr(this.view)), this.view.input.mouseDown = null;
      }
      up(e) {
        if (this.done(), !this.view.dom.contains(e.target))
          return;
        let t = this.pos;
        this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Za(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Rr(this.view, "pointer") : _0(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        Yt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        zt && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? ($o(this.view, ue.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Rr(this.view, "pointer");
      }
      move(e) {
        this.updateAllowDefault(e), Rr(this.view, "pointer"), e.buttons == 0 && this.done();
      }
      updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
      }
    }
    Xt.touchstart = (n3) => {
      n3.input.lastTouch = Date.now(), cu(n3), Rr(n3, "pointer");
    };
    Xt.touchmove = (n3) => {
      n3.input.lastTouch = Date.now(), Rr(n3, "pointer");
    };
    Xt.contextmenu = (n3) => cu(n3);
    function em(n3, e) {
      return n3.composing ? true : Yt && Math.abs(e.timeStamp - n3.input.compositionEndedAt) < 500 ? (n3.input.compositionEndedAt = -2e8, true) : false;
    }
    const O0 = ur ? 5e3 : -1;
    Zt.compositionstart = Zt.compositionupdate = (n3) => {
      if (!n3.composing) {
        n3.domObserver.flush();
        let { state: e } = n3, t = e.selection.$to;
        if (e.selection instanceof ie && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === false)))
          n3.markCursor = n3.state.storedMarks || t.marks(), ia(n3, true), n3.markCursor = null;
        else if (ia(n3, !e.selection.empty), Ln && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
          let r = n3.domSelectionRange();
          for (let o = r.focusNode, i = r.focusOffset; o && o.nodeType == 1 && i != 0; ) {
            let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
            if (!s)
              break;
            if (s.nodeType == 3) {
              let a = n3.domSelection();
              a && a.collapse(s, s.nodeValue.length);
              break;
            } else
              o = s, i = -1;
          }
        }
        n3.input.composing = true;
      }
      tm(n3, O0);
    };
    Zt.compositionend = (n3, e) => {
      n3.composing && (n3.input.composing = false, n3.input.compositionEndedAt = e.timeStamp, n3.input.compositionPendingChanges = n3.domObserver.pendingRecords().length ? n3.input.compositionID : 0, n3.input.compositionNode = null, n3.input.compositionPendingChanges && Promise.resolve().then(() => n3.domObserver.flush()), n3.input.compositionID++, tm(n3, 20));
    };
    function tm(n3, e) {
      clearTimeout(n3.input.composingTimeout), e > -1 && (n3.input.composingTimeout = setTimeout(() => ia(n3), e));
    }
    function nm(n3) {
      for (n3.composing && (n3.input.composing = false, n3.input.compositionEndedAt = M0()); n3.input.compositionNodes.length > 0; )
        n3.input.compositionNodes.pop().markParentsDirty();
    }
    function N0(n3) {
      let e = n3.domSelectionRange();
      if (!e.focusNode)
        return null;
      let t = kv(e.focusNode, e.focusOffset), r = Ev(e.focusNode, e.focusOffset);
      if (t && r && t != r) {
        let o = r.pmViewDesc, i = n3.domObserver.lastChangedTextNode;
        if (t == i || r == i)
          return i;
        if (!o || !o.isText(r.nodeValue))
          return r;
        if (n3.input.compositionNode == r) {
          let s = t.pmViewDesc;
          if (!(!s || !s.isText(t.nodeValue)))
            return r;
        }
      }
      return t || r;
    }
    function M0() {
      let n3 = document.createEvent("Event");
      return n3.initEvent("event", true, true), n3.timeStamp;
    }
    function ia(n3, e = false) {
      if (!(ur && n3.domObserver.flushingSoon >= 0)) {
        if (n3.domObserver.forceFlush(), nm(n3), e || n3.docView && n3.docView.dirty) {
          let t = ou(n3);
          return t && !t.eq(n3.state.selection) ? n3.dispatch(n3.state.tr.setSelection(t)) : (n3.markCursor || e) && !n3.state.selection.empty ? n3.dispatch(n3.state.tr.deleteSelection()) : n3.updateState(n3.state), true;
        }
        return false;
      }
    }
    function A0(n3, e) {
      if (!n3.dom.parentNode)
        return;
      let t = n3.dom.parentNode.appendChild(document.createElement("div"));
      t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let r = getSelection(), o = document.createRange();
      o.selectNodeContents(e), n3.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
        t.parentNode && t.parentNode.removeChild(t), n3.focus();
      }, 50);
    }
    const Bi = nn && Br < 15 || Uo && Tv < 604;
    Xt.copy = Zt.cut = (n3, e) => {
      let t = e, r = n3.state.selection, o = t.type == "cut";
      if (r.empty)
        return;
      let i = Bi ? null : t.clipboardData, s = r.content(), { dom: a, text: l } = su(n3, s);
      i ? (t.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : A0(n3, a), o && n3.dispatch(n3.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function R0(n3) {
      return n3.openStart == 0 && n3.openEnd == 0 && n3.content.childCount == 1 ? n3.content.firstChild : null;
    }
    function I0(n3, e) {
      if (!n3.dom.parentNode)
        return;
      let t = n3.input.shiftKey || n3.state.selection.$from.parent.type.spec.code, r = n3.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
      t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
      let o = n3.input.shiftKey && n3.input.lastKeyCode != 45;
      setTimeout(() => {
        n3.focus(), r.parentNode && r.parentNode.removeChild(r), t ? Pi(n3, r.value, null, o, e) : Pi(n3, r.textContent, r.innerHTML, o, e);
      }, 50);
    }
    function Pi(n3, e, t, r, o) {
      let i = Gh(n3, e, t, r, n3.state.selection.$from);
      if (n3.someProp("handlePaste", (l) => l(n3, o, i || I.empty)))
        return true;
      if (!i)
        return false;
      let s = R0(i), a = s ? n3.state.tr.replaceSelectionWith(s, r) : n3.state.tr.replaceSelection(i);
      return n3.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
    }
    function rm(n3) {
      let e = n3.getData("text/plain") || n3.getData("Text");
      if (e)
        return e;
      let t = n3.getData("text/uri-list");
      return t ? t.replace(/\r?\n/g, " ") : "";
    }
    Zt.paste = (n3, e) => {
      let t = e;
      if (n3.composing && !ur)
        return;
      let r = Bi ? null : t.clipboardData, o = n3.input.shiftKey && n3.input.lastKeyCode != 45;
      r && Pi(n3, rm(r), r.getData("text/html"), o, t) ? t.preventDefault() : I0(n3, t);
    };
    class om {
      constructor(e, t, r) {
        this.slice = e, this.move = t, this.node = r;
      }
    }
    const im = wn ? "altKey" : "ctrlKey";
    Xt.dragstart = (n3, e) => {
      let t = e, r = n3.input.mouseDown;
      if (r && r.done(), !t.dataTransfer)
        return;
      let o = n3.state.selection, i = o.empty ? null : n3.posAtCoords(Za(t)), s;
      if (!(i && i.pos >= o.from && i.pos <= (o instanceof ne ? o.to - 1 : o.to))) {
        if (r && r.mightDrag)
          s = ne.create(n3.state.doc, r.mightDrag.pos);
        else if (t.target && t.target.nodeType == 1) {
          let d = n3.docView.nearestDesc(t.target, true);
          d && d.node.type.spec.draggable && d != n3.docView && (s = ne.create(n3.state.doc, d.posBefore));
        }
      }
      let a = (s || n3.state.selection).content(), { dom: l, text: c2, slice: u } = su(n3, a);
      (!t.dataTransfer.files.length || !zt || Ah > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Bi ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Bi || t.dataTransfer.setData("text/plain", c2), n3.dragging = new om(u, !t[im], s);
    };
    Xt.dragend = (n3) => {
      let e = n3.dragging;
      window.setTimeout(() => {
        n3.dragging == e && (n3.dragging = null);
      }, 50);
    };
    Zt.dragover = Zt.dragenter = (n3, e) => e.preventDefault();
    Zt.drop = (n3, e) => {
      let t = e, r = n3.dragging;
      if (n3.dragging = null, !t.dataTransfer)
        return;
      let o = n3.posAtCoords(Za(t));
      if (!o)
        return;
      let i = n3.state.doc.resolve(o.pos), s = r && r.slice;
      s ? n3.someProp("transformPasted", (h2) => {
        s = h2(s, n3);
      }) : s = Gh(n3, rm(t.dataTransfer), Bi ? null : t.dataTransfer.getData("text/html"), false, i);
      let a = !!(r && !t[im]);
      if (n3.someProp("handleDrop", (h2) => h2(n3, t, s || I.empty, a))) {
        t.preventDefault();
        return;
      }
      if (!s)
        return;
      t.preventDefault();
      let l = s ? pv(n3.state.doc, i.pos, s) : i.pos;
      l == null && (l = i.pos);
      let c2 = n3.state.tr;
      if (a) {
        let { node: h2 } = r;
        h2 ? h2.replace(c2) : c2.deleteSelection();
      }
      let u = c2.mapping.map(l), d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, p2 = c2.doc;
      if (d ? c2.replaceRangeWith(u, u, s.content.firstChild) : c2.replaceRange(u, u, s), c2.doc.eq(p2))
        return;
      let f = c2.doc.resolve(u);
      if (d && ne.isSelectable(s.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(s.content.firstChild))
        c2.setSelection(new ne(f));
      else {
        let h2 = c2.mapping.map(l);
        c2.mapping.maps[c2.mapping.maps.length - 1].forEach((m, g, b, w) => h2 = w), c2.setSelection(iu(n3, f, c2.doc.resolve(h2)));
      }
      n3.focus(), n3.dispatch(c2.setMeta("uiEvent", "drop"));
    };
    Xt.focus = (n3) => {
      n3.input.lastFocus = Date.now(), n3.focused || (n3.domObserver.stop(), n3.dom.classList.add("ProseMirror-focused"), n3.domObserver.start(), n3.focused = true, setTimeout(() => {
        n3.docView && n3.hasFocus() && !n3.domObserver.currentSelection.eq(n3.domSelectionRange()) && fr(n3);
      }, 20));
    };
    Xt.blur = (n3, e) => {
      let t = e;
      n3.focused && (n3.domObserver.stop(), n3.dom.classList.remove("ProseMirror-focused"), n3.domObserver.start(), t.relatedTarget && n3.dom.contains(t.relatedTarget) && n3.domObserver.currentSelection.clear(), n3.focused = false);
    };
    Xt.beforeinput = (n3, e) => {
      if (zt && ur && e.inputType == "deleteContentBackward") {
        n3.domObserver.flushSoon();
        let { domChangeCount: r } = n3.input;
        setTimeout(() => {
          if (n3.input.domChangeCount != r || (n3.dom.blur(), n3.focus(), n3.someProp("handleKeyDown", (i) => i(n3, Yr(8, "Backspace")))))
            return;
          let { $cursor: o } = n3.state.selection;
          o && o.pos > 0 && n3.dispatch(n3.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let n3 in Zt)
      Xt[n3] = Zt[n3];
    function $i(n3, e) {
      if (n3 == e)
        return true;
      for (let t in n3)
        if (n3[t] !== e[t])
          return false;
      for (let t in e)
        if (!(t in n3))
          return false;
      return true;
    }
    class sa {
      constructor(e, t) {
        this.toDOM = e, this.spec = t || ro, this.side = this.spec.side || 0;
      }
      map(e, t, r, o) {
        let { pos: i, deleted: s } = e.mapResult(t.from + o, this.side < 0 ? -1 : 1);
        return s ? null : new ht(i - r, i - r, this);
      }
      valid() {
        return true;
      }
      eq(e) {
        return this == e || e instanceof sa && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && $i(this.spec, e.spec));
      }
      destroy(e) {
        this.spec.destroy && this.spec.destroy(e);
      }
    }
    class $r {
      constructor(e, t) {
        this.attrs = e, this.spec = t || ro;
      }
      map(e, t, r, o) {
        let i = e.map(t.from + o, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(t.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
        return i >= s ? null : new ht(i, s, this);
      }
      valid(e, t) {
        return t.from < t.to;
      }
      eq(e) {
        return this == e || e instanceof $r && $i(this.attrs, e.attrs) && $i(this.spec, e.spec);
      }
      static is(e) {
        return e.type instanceof $r;
      }
      destroy() {
      }
    }
    class uu {
      constructor(e, t) {
        this.attrs = e, this.spec = t || ro;
      }
      map(e, t, r, o) {
        let i = e.mapResult(t.from + o, 1);
        if (i.deleted)
          return null;
        let s = e.mapResult(t.to + o, -1);
        return s.deleted || s.pos <= i.pos ? null : new ht(i.pos - r, s.pos - r, this);
      }
      valid(e, t) {
        let { index: r, offset: o } = e.content.findIndex(t.from), i;
        return o == t.from && !(i = e.child(r)).isText && o + i.nodeSize == t.to;
      }
      eq(e) {
        return this == e || e instanceof uu && $i(this.attrs, e.attrs) && $i(this.spec, e.spec);
      }
      destroy() {
      }
    }
    class ht {
      /**
      @internal
      */
      constructor(e, t, r) {
        this.from = e, this.to = t, this.type = r;
      }
      /**
      @internal
      */
      copy(e, t) {
        return new ht(e, t, this.type);
      }
      /**
      @internal
      */
      eq(e, t = 0) {
        return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
      }
      /**
      @internal
      */
      map(e, t, r) {
        return this.type.map(e, this, t, r);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(e, t, r) {
        return new ht(e, e, new sa(t, r));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(e, t, r, o) {
        return new ht(e, t, new $r(r, o));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(e, t, r, o) {
        return new ht(e, t, new uu(r, o));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof $r;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof sa;
      }
    }
    const Oo = [], ro = {};
    class He {
      /**
      @internal
      */
      constructor(e, t) {
        this.local = e.length ? e : Oo, this.children = t.length ? t : Oo;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(e, t) {
        return t.length ? aa(t, e, 0, ro) : Ft;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(e, t, r) {
        let o = [];
        return this.findInner(e ?? 0, t ?? 1e9, o, 0, r), o;
      }
      findInner(e, t, r, o, i) {
        for (let s = 0; s < this.local.length; s++) {
          let a = this.local[s];
          a.from <= t && a.to >= e && (!i || i(a.spec)) && r.push(a.copy(a.from + o, a.to + o));
        }
        for (let s = 0; s < this.children.length; s += 3)
          if (this.children[s] < t && this.children[s + 1] > e) {
            let a = this.children[s] + 1;
            this.children[s + 2].findInner(e - a, t - a, r, o + a, i);
          }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(e, t, r) {
        return this == Ft || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || ro);
      }
      /**
      @internal
      */
      mapInner(e, t, r, o, i) {
        let s;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a].map(e, r, o);
          l && l.type.valid(t, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec);
        }
        return this.children.length ? D0(this.children, s || [], e, t, r, o, i) : s ? new He(s.sort(oo), Oo) : Ft;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(e, t) {
        return t.length ? this == Ft ? He.create(e, t) : this.addInner(e, t, 0) : this;
      }
      addInner(e, t, r) {
        let o, i = 0;
        e.forEach((a, l) => {
          let c2 = l + r, u;
          if (u = am(t, a, c2)) {
            for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
              i += 3;
            o[i] == l ? o[i + 2] = o[i + 2].addInner(a, u, c2 + 1) : o.splice(i, 0, l, l + a.nodeSize, aa(u, a, c2 + 1, ro)), i += 3;
          }
        });
        let s = sm(i ? lm(t) : t, -r);
        for (let a = 0; a < s.length; a++)
          s[a].type.valid(e, s[a]) || s.splice(a--, 1);
        return new He(s.length ? this.local.concat(s).sort(oo) : this.local, o || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(e) {
        return e.length == 0 || this == Ft ? this : this.removeInner(e, 0);
      }
      removeInner(e, t) {
        let r = this.children, o = this.local;
        for (let i = 0; i < r.length; i += 3) {
          let s, a = r[i] + t, l = r[i + 1] + t;
          for (let u = 0, d; u < e.length; u++)
            (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (s || (s = [])).push(d));
          if (!s)
            continue;
          r == this.children && (r = this.children.slice());
          let c2 = r[i + 2].removeInner(s, a + 1);
          c2 != Ft ? r[i + 2] = c2 : (r.splice(i, 3), i -= 3);
        }
        if (o.length) {
          for (let i = 0, s; i < e.length; i++)
            if (s = e[i])
              for (let a = 0; a < o.length; a++)
                o[a].eq(s, t) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
        }
        return r == this.children && o == this.local ? this : o.length || r.length ? new He(o, r) : Ft;
      }
      forChild(e, t) {
        if (this == Ft)
          return this;
        if (t.isLeaf)
          return He.empty;
        let r, o;
        for (let a = 0; a < this.children.length; a += 3)
          if (this.children[a] >= e) {
            this.children[a] == e && (r = this.children[a + 2]);
            break;
          }
        let i = e + 1, s = i + t.content.size;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a];
          if (l.from < s && l.to > i && l.type instanceof $r) {
            let c2 = Math.max(i, l.from) - i, u = Math.min(s, l.to) - i;
            c2 < u && (o || (o = [])).push(l.copy(c2, u));
          }
        }
        if (o) {
          let a = new He(o.sort(oo), Oo);
          return r ? new Tr([a, r]) : a;
        }
        return r || Ft;
      }
      /**
      @internal
      */
      eq(e) {
        if (this == e)
          return true;
        if (!(e instanceof He) || this.local.length != e.local.length || this.children.length != e.children.length)
          return false;
        for (let t = 0; t < this.local.length; t++)
          if (!this.local[t].eq(e.local[t]))
            return false;
        for (let t = 0; t < this.children.length; t += 3)
          if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(e) {
        return du(this.localsInner(e));
      }
      /**
      @internal
      */
      localsInner(e) {
        if (this == Ft)
          return Oo;
        if (e.inlineContent || !this.local.some($r.is))
          return this.local;
        let t = [];
        for (let r = 0; r < this.local.length; r++)
          this.local[r].type instanceof $r || t.push(this.local[r]);
        return t;
      }
      forEachSet(e) {
        e(this);
      }
    }
    He.empty = new He([], []);
    He.removeOverlap = du;
    const Ft = He.empty;
    class Tr {
      constructor(e) {
        this.members = e;
      }
      map(e, t) {
        const r = this.members.map((o) => o.map(e, t, ro));
        return Tr.from(r);
      }
      forChild(e, t) {
        if (t.isLeaf)
          return He.empty;
        let r = [];
        for (let o = 0; o < this.members.length; o++) {
          let i = this.members[o].forChild(e, t);
          i != Ft && (i instanceof Tr ? r = r.concat(i.members) : r.push(i));
        }
        return Tr.from(r);
      }
      eq(e) {
        if (!(e instanceof Tr) || e.members.length != this.members.length)
          return false;
        for (let t = 0; t < this.members.length; t++)
          if (!this.members[t].eq(e.members[t]))
            return false;
        return true;
      }
      locals(e) {
        let t, r = true;
        for (let o = 0; o < this.members.length; o++) {
          let i = this.members[o].localsInner(e);
          if (i.length)
            if (!t)
              t = i;
            else {
              r && (t = t.slice(), r = false);
              for (let s = 0; s < i.length; s++)
                t.push(i[s]);
            }
        }
        return t ? du(r ? t : t.sort(oo)) : Oo;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(e) {
        switch (e.length) {
          case 0:
            return Ft;
          case 1:
            return e[0];
          default:
            return new Tr(e.every((t) => t instanceof He) ? e : e.reduce((t, r) => t.concat(r instanceof He ? r : r.members), []));
        }
      }
      forEachSet(e) {
        for (let t = 0; t < this.members.length; t++)
          this.members[t].forEachSet(e);
      }
    }
    function D0(n3, e, t, r, o, i, s) {
      let a = n3.slice();
      for (let c2 = 0, u = i; c2 < t.maps.length; c2++) {
        let d = 0;
        t.maps[c2].forEach((p2, f, h2, m) => {
          let g = m - h2 - (f - p2);
          for (let b = 0; b < a.length; b += 3) {
            let w = a[b + 1];
            if (w < 0 || p2 > w + u - d)
              continue;
            let _ = a[b] + u - d;
            f >= _ ? a[b + 1] = p2 <= _ ? -2 : -1 : p2 >= u && g && (a[b] += g, a[b + 1] += g);
          }
          d += g;
        }), u = t.maps[c2].map(u, -1);
      }
      let l = false;
      for (let c2 = 0; c2 < a.length; c2 += 3)
        if (a[c2 + 1] < 0) {
          if (a[c2 + 1] == -2) {
            l = true, a[c2 + 1] = -1;
            continue;
          }
          let u = t.map(n3[c2] + i), d = u - o;
          if (d < 0 || d >= r.content.size) {
            l = true;
            continue;
          }
          let p2 = t.map(n3[c2 + 1] + i, -1), f = p2 - o, { index: h2, offset: m } = r.content.findIndex(d), g = r.maybeChild(h2);
          if (g && m == d && m + g.nodeSize == f) {
            let b = a[c2 + 2].mapInner(t, g, u + 1, n3[c2] + i + 1, s);
            b != Ft ? (a[c2] = d, a[c2 + 1] = f, a[c2 + 2] = b) : (a[c2 + 1] = -2, l = true);
          } else
            l = true;
        }
      if (l) {
        let c2 = L0(a, n3, e, t, o, i, s), u = aa(c2, r, 0, s);
        e = u.local;
        for (let d = 0; d < a.length; d += 3)
          a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
        for (let d = 0, p2 = 0; d < u.children.length; d += 3) {
          let f = u.children[d];
          for (; p2 < a.length && a[p2] < f; )
            p2 += 3;
          a.splice(p2, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
        }
      }
      return new He(e.sort(oo), a);
    }
    function sm(n3, e) {
      if (!e || !n3.length)
        return n3;
      let t = [];
      for (let r = 0; r < n3.length; r++) {
        let o = n3[r];
        t.push(new ht(o.from + e, o.to + e, o.type));
      }
      return t;
    }
    function L0(n3, e, t, r, o, i, s) {
      function a(l, c2) {
        for (let u = 0; u < l.local.length; u++) {
          let d = l.local[u].map(r, o, c2);
          d ? t.push(d) : s.onRemove && s.onRemove(l.local[u].spec);
        }
        for (let u = 0; u < l.children.length; u += 3)
          a(l.children[u + 2], l.children[u] + c2 + 1);
      }
      for (let l = 0; l < n3.length; l += 3)
        n3[l + 1] == -1 && a(n3[l + 2], e[l] + i + 1);
      return t;
    }
    function am(n3, e, t) {
      if (e.isLeaf)
        return null;
      let r = t + e.nodeSize, o = null;
      for (let i = 0, s; i < n3.length; i++)
        (s = n3[i]) && s.from > t && s.to < r && ((o || (o = [])).push(s), n3[i] = null);
      return o;
    }
    function lm(n3) {
      let e = [];
      for (let t = 0; t < n3.length; t++)
        n3[t] != null && e.push(n3[t]);
      return e;
    }
    function aa(n3, e, t, r) {
      let o = [], i = false;
      e.forEach((a, l) => {
        let c2 = am(n3, a, l + t);
        if (c2) {
          i = true;
          let u = aa(c2, a, t + l + 1, r);
          u != Ft && o.push(l, l + a.nodeSize, u);
        }
      });
      let s = sm(i ? lm(n3) : n3, -t).sort(oo);
      for (let a = 0; a < s.length; a++)
        s[a].type.valid(e, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
      return s.length || o.length ? new He(s, o) : Ft;
    }
    function oo(n3, e) {
      return n3.from - e.from || n3.to - e.to;
    }
    function du(n3) {
      let e = n3;
      for (let t = 0; t < e.length - 1; t++) {
        let r = e[t];
        if (r.from != r.to)
          for (let o = t + 1; o < e.length; o++) {
            let i = e[o];
            if (i.from == r.from) {
              i.to != r.to && (e == n3 && (e = n3.slice()), e[o] = i.copy(i.from, r.to), Qd(e, o + 1, i.copy(r.to, i.to)));
              continue;
            } else {
              i.from < r.to && (e == n3 && (e = n3.slice()), e[t] = r.copy(r.from, i.from), Qd(e, o, r.copy(i.from, r.to)));
              break;
            }
          }
      }
      return e;
    }
    function Qd(n3, e, t) {
      for (; e < n3.length && oo(t, n3[e]) > 0; )
        e++;
      n3.splice(e, 0, t);
    }
    function Rl(n3) {
      let e = [];
      return n3.someProp("decorations", (t) => {
        let r = t(n3.state);
        r && r != Ft && e.push(r);
      }), n3.cursorWrapper && e.push(He.create(n3.state.doc, [n3.cursorWrapper.deco])), Tr.from(e);
    }
    const B0 = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    }, P0 = nn && Br <= 11;
    class $0 {
      constructor() {
        this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
      }
      set(e) {
        this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
      }
    }
    class F0 {
      constructor(e, t) {
        this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new $0(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
          for (let o = 0; o < r.length; o++)
            this.queue.push(r[o]);
          nn && Br <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush();
        }), P0 && (this.onCharData = (r) => {
          this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
        }), this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1, this.flush();
        }, 20));
      }
      forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
      start() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, B0)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let e = this.observer.takeRecords();
          if (e.length) {
            for (let t = 0; t < e.length; t++)
              this.queue.push(e[t]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (qd(this.view)) {
          if (this.suppressingSelectionUpdates)
            return fr(this.view);
          if (nn && Br <= 11 && !this.view.state.selection.empty) {
            let e = this.view.domSelectionRange();
            if (e.focusNode && po(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(e) {
        if (!e.focusNode)
          return true;
        let t = /* @__PURE__ */ new Set(), r;
        for (let i = e.focusNode; i; i = Li(i))
          t.add(i);
        for (let i = e.anchorNode; i; i = Li(i))
          if (t.has(i)) {
            r = i;
            break;
          }
        let o = r && this.view.docView.nearestDesc(r);
        if (o && o.ignoreMutation({
          type: "selection",
          target: r.nodeType == 3 ? r.parentNode : r
        }))
          return this.setCurSelection(), true;
      }
      pendingRecords() {
        if (this.observer)
          for (let e of this.observer.takeRecords())
            this.queue.push(e);
        return this.queue;
      }
      flush() {
        let { view: e } = this;
        if (!e.docView || this.flushingSoon > -1)
          return;
        let t = this.pendingRecords();
        t.length && (this.queue = []);
        let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && qd(e) && !this.ignoreSelectionChange(r), i = -1, s = -1, a = false, l = [];
        if (e.editable)
          for (let u = 0; u < t.length; u++) {
            let d = this.registerMutation(t[u], l);
            d && (i = i < 0 ? d.from : Math.min(d.from, i), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (a = true));
          }
        if (Ln && l.length) {
          let u = l.filter((d) => d.nodeName == "BR");
          if (u.length == 2) {
            let [d, p2] = u;
            d.parentNode && d.parentNode.parentNode == p2.parentNode ? p2.remove() : d.remove();
          } else {
            let { focusNode: d } = this.currentSelection;
            for (let p2 of u) {
              let f = p2.parentNode;
              f && f.nodeName == "LI" && (!d || U0(e, d) != f) && p2.remove();
            }
          }
        }
        let c2 = null;
        i < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Ya(r) && (c2 = ou(e)) && c2.eq(ue.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, fr(e), this.currentSelection.set(r)) : (i > -1 || o) && (i > -1 && (e.docView.markDirty(i, s), z0(e)), this.handleDOMChange(i, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || fr(e), this.currentSelection.set(r));
      }
      registerMutation(e, t) {
        if (t.indexOf(e.target) > -1)
          return null;
        let r = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
          return null;
        if (e.type == "childList") {
          for (let u = 0; u < e.addedNodes.length; u++) {
            let d = e.addedNodes[u];
            t.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
          }
          if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
            return { from: r.posBefore, to: r.posAfter };
          let o = e.previousSibling, i = e.nextSibling;
          if (nn && Br <= 11 && e.addedNodes.length)
            for (let u = 0; u < e.addedNodes.length; u++) {
              let { previousSibling: d, nextSibling: p2 } = e.addedNodes[u];
              (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (o = d), (!p2 || Array.prototype.indexOf.call(e.addedNodes, p2) < 0) && (i = p2);
            }
          let s = o && o.parentNode == e.target ? It(o) + 1 : 0, a = r.localPosFromDOM(e.target, s, -1), l = i && i.parentNode == e.target ? It(i) : e.target.childNodes.length, c2 = r.localPosFromDOM(e.target, l, 1);
          return { from: a, to: c2 };
        } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
          from: r.posAtStart,
          to: r.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: e.target.nodeValue == e.oldValue
        });
      }
    }
    let ep = /* @__PURE__ */ new WeakMap(), tp = false;
    function z0(n3) {
      if (!ep.has(n3) && (ep.set(n3, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n3.dom).whiteSpace) !== -1)) {
        if (n3.requiresGeckoHackNode = Ln, tp)
          return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), tp = true;
      }
    }
    function np(n3, e) {
      let t = e.startContainer, r = e.startOffset, o = e.endContainer, i = e.endOffset, s = n3.domAtPos(n3.state.selection.anchor);
      return po(s.node, s.offset, o, i) && ([t, r, o, i] = [o, i, t, r]), { anchorNode: t, anchorOffset: r, focusNode: o, focusOffset: i };
    }
    function H0(n3, e) {
      if (e.getComposedRanges) {
        let o = e.getComposedRanges(n3.root)[0];
        if (o)
          return np(n3, o);
      }
      let t;
      function r(o) {
        o.preventDefault(), o.stopImmediatePropagation(), t = o.getTargetRanges()[0];
      }
      return n3.dom.addEventListener("beforeinput", r, true), document.execCommand("indent"), n3.dom.removeEventListener("beforeinput", r, true), t ? np(n3, t) : null;
    }
    function U0(n3, e) {
      for (let t = e.parentNode; t && t != n3.dom; t = t.parentNode) {
        let r = n3.docView.nearestDesc(t, true);
        if (r && r.node.isBlock)
          return t;
      }
      return null;
    }
    function V0(n3, e, t) {
      let { node: r, fromOffset: o, toOffset: i, from: s, to: a } = n3.docView.parseRange(e, t), l = n3.domSelectionRange(), c2, u = l.anchorNode;
      if (u && n3.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c2 = [{ node: u, offset: l.anchorOffset }], Ya(l) || c2.push({ node: l.focusNode, offset: l.focusOffset })), zt && n3.input.lastKeyCode === 8)
        for (let g = i; g > o; g--) {
          let b = r.childNodes[g - 1], w = b.pmViewDesc;
          if (b.nodeName == "BR" && !w) {
            i = g;
            break;
          }
          if (!w || w.size)
            break;
        }
      let d = n3.state.doc, p2 = n3.someProp("domParser") || Lr.fromSchema(n3.state.schema), f = d.resolve(s), h2 = null, m = p2.parse(r, {
        topNode: f.parent,
        topMatch: f.parent.contentMatchAt(f.index()),
        topOpen: true,
        from: o,
        to: i,
        preserveWhitespace: f.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: c2,
        ruleFromNode: W0,
        context: f
      });
      if (c2 && c2[0].pos != null) {
        let g = c2[0].pos, b = c2[1] && c2[1].pos;
        b == null && (b = g), h2 = { anchor: g + s, head: b + s };
      }
      return { doc: m, sel: h2, from: s, to: a };
    }
    function W0(n3) {
      let e = n3.pmViewDesc;
      if (e)
        return e.parseRule();
      if (n3.nodeName == "BR" && n3.parentNode) {
        if (Yt && /^(ul|ol)$/i.test(n3.parentNode.nodeName)) {
          let t = document.createElement("div");
          return t.appendChild(document.createElement("li")), { skip: t };
        } else if (n3.parentNode.lastChild == n3 || Yt && /^(tr|table)$/i.test(n3.parentNode.nodeName))
          return { ignore: true };
      } else if (n3.nodeName == "IMG" && n3.getAttribute("mark-placeholder"))
        return { ignore: true };
      return null;
    }
    const q0 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function K0(n3, e, t, r, o) {
      let i = n3.input.compositionPendingChanges || (n3.composing ? n3.input.compositionID : 0);
      if (n3.input.compositionPendingChanges = 0, e < 0) {
        let B = n3.input.lastSelectionTime > Date.now() - 50 ? n3.input.lastSelectionOrigin : null, q = ou(n3, B);
        if (q && !n3.state.selection.eq(q)) {
          if (zt && ur && n3.input.lastKeyCode === 13 && Date.now() - 100 < n3.input.lastKeyCodeTime && n3.someProp("handleKeyDown", (de) => de(n3, Yr(13, "Enter"))))
            return;
          let oe = n3.state.tr.setSelection(q);
          B == "pointer" ? oe.setMeta("pointer", true) : B == "key" && oe.scrollIntoView(), i && oe.setMeta("composition", i), n3.dispatch(oe);
        }
        return;
      }
      let s = n3.state.doc.resolve(e), a = s.sharedDepth(t);
      e = s.before(a + 1), t = n3.state.doc.resolve(t).after(a + 1);
      let l = n3.state.selection, c2 = V0(n3, e, t), u = n3.state.doc, d = u.slice(c2.from, c2.to), p2, f;
      n3.input.lastKeyCode === 8 && Date.now() - 100 < n3.input.lastKeyCodeTime ? (p2 = n3.state.selection.to, f = "end") : (p2 = n3.state.selection.from, f = "start"), n3.input.lastKeyCode = null;
      let h2 = J0(d.content, c2.doc.content, c2.from, p2, f);
      if (h2 && n3.input.domChangeCount++, (Uo && n3.input.lastIOSEnter > Date.now() - 225 || ur) && o.some((B) => B.nodeType == 1 && !q0.test(B.nodeName)) && (!h2 || h2.endA >= h2.endB) && n3.someProp("handleKeyDown", (B) => B(n3, Yr(13, "Enter")))) {
        n3.input.lastIOSEnter = 0;
        return;
      }
      if (!h2)
        if (r && l instanceof ie && !l.empty && l.$head.sameParent(l.$anchor) && !n3.composing && !(c2.sel && c2.sel.anchor != c2.sel.head))
          h2 = { start: l.from, endA: l.to, endB: l.to };
        else {
          if (c2.sel) {
            let B = rp(n3, n3.state.doc, c2.sel);
            if (B && !B.eq(n3.state.selection)) {
              let q = n3.state.tr.setSelection(B);
              i && q.setMeta("composition", i), n3.dispatch(q);
            }
          }
          return;
        }
      n3.state.selection.from < n3.state.selection.to && h2.start == h2.endB && n3.state.selection instanceof ie && (h2.start > n3.state.selection.from && h2.start <= n3.state.selection.from + 2 && n3.state.selection.from >= c2.from ? h2.start = n3.state.selection.from : h2.endA < n3.state.selection.to && h2.endA >= n3.state.selection.to - 2 && n3.state.selection.to <= c2.to && (h2.endB += n3.state.selection.to - h2.endA, h2.endA = n3.state.selection.to)), nn && Br <= 11 && h2.endB == h2.start + 1 && h2.endA == h2.start && h2.start > c2.from && c2.doc.textBetween(h2.start - c2.from - 1, h2.start - c2.from + 1) == " " && (h2.start--, h2.endA--, h2.endB--);
      let m = c2.doc.resolveNoCache(h2.start - c2.from), g = c2.doc.resolveNoCache(h2.endB - c2.from), b = u.resolve(h2.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= h2.endA, _;
      if ((Uo && n3.input.lastIOSEnter > Date.now() - 225 && (!w || o.some((B) => B.nodeName == "DIV" || B.nodeName == "P")) || !w && m.pos < c2.doc.content.size && !m.sameParent(g) && (_ = ue.findFrom(c2.doc.resolve(m.pos + 1), 1, true)) && _.head == g.pos) && n3.someProp("handleKeyDown", (B) => B(n3, Yr(13, "Enter")))) {
        n3.input.lastIOSEnter = 0;
        return;
      }
      if (n3.state.selection.anchor > h2.start && j0(u, h2.start, h2.endA, m, g) && n3.someProp("handleKeyDown", (B) => B(n3, Yr(8, "Backspace")))) {
        ur && zt && n3.domObserver.suppressSelectionUpdates();
        return;
      }
      zt && h2.endB == h2.start && (n3.input.lastChromeDelete = Date.now()), ur && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c2.sel && c2.sel.anchor == c2.sel.head && c2.sel.head == h2.endA && (h2.endB -= 2, g = c2.doc.resolveNoCache(h2.endB - c2.from), setTimeout(() => {
        n3.someProp("handleKeyDown", function(B) {
          return B(n3, Yr(13, "Enter"));
        });
      }, 20));
      let v = h2.start, T = h2.endA, S, z, U;
      if (w) {
        if (m.pos == g.pos)
          nn && Br <= 11 && m.parentOffset == 0 && (n3.domObserver.suppressSelectionUpdates(), setTimeout(() => fr(n3), 20)), S = n3.state.tr.delete(v, T), z = u.resolve(h2.start).marksAcross(u.resolve(h2.endA));
        else if (
          // Adding or removing a mark
          h2.endA == h2.endB && (U = G0(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, h2.endA - b.start())))
        )
          S = n3.state.tr, U.type == "add" ? S.addMark(v, T, U.mark) : S.removeMark(v, T, U.mark);
        else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
          let B = m.parent.textBetween(m.parentOffset, g.parentOffset);
          if (n3.someProp("handleTextInput", (q) => q(n3, v, T, B)))
            return;
          S = n3.state.tr.insertText(B, v, T);
        }
      }
      if (S || (S = n3.state.tr.replace(v, T, c2.doc.slice(h2.start - c2.from, h2.endB - c2.from))), c2.sel) {
        let B = rp(n3, S.doc, c2.sel);
        B && !(zt && n3.composing && B.empty && (h2.start != h2.endB || n3.input.lastChromeDelete < Date.now() - 100) && (B.head == v || B.head == S.mapping.map(T) - 1) || nn && B.empty && B.head == v) && S.setSelection(B);
      }
      z && S.ensureMarks(z), i && S.setMeta("composition", i), n3.dispatch(S.scrollIntoView());
    }
    function rp(n3, e, t) {
      return Math.max(t.anchor, t.head) > e.content.size ? null : iu(n3, e.resolve(t.anchor), e.resolve(t.head));
    }
    function G0(n3, e) {
      let t = n3.firstChild.marks, r = e.firstChild.marks, o = t, i = r, s, a, l;
      for (let u = 0; u < r.length; u++)
        o = r[u].removeFromSet(o);
      for (let u = 0; u < t.length; u++)
        i = t[u].removeFromSet(i);
      if (o.length == 1 && i.length == 0)
        a = o[0], s = "add", l = (u) => u.mark(a.addToSet(u.marks));
      else if (o.length == 0 && i.length == 1)
        a = i[0], s = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
      else
        return null;
      let c2 = [];
      for (let u = 0; u < e.childCount; u++)
        c2.push(l(e.child(u)));
      if (O.from(c2).eq(n3))
        return { mark: a, type: s };
    }
    function j0(n3, e, t, r, o) {
      if (
        // The content must have shrunk
        t - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
        Il(r, true, false) < o.pos
      )
        return false;
      let i = n3.resolve(e);
      if (!r.parent.isTextblock) {
        let a = i.nodeAfter;
        return a != null && t == e + a.nodeSize;
      }
      if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
        return false;
      let s = n3.resolve(Il(i, true, true));
      return !s.parent.isTextblock || s.pos > t || Il(s, true, false) < t ? false : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
    }
    function Il(n3, e, t) {
      let r = n3.depth, o = e ? n3.end() : n3.pos;
      for (; r > 0 && (e || n3.indexAfter(r) == n3.node(r).childCount); )
        r--, o++, e = false;
      if (t) {
        let i = n3.node(r).maybeChild(n3.indexAfter(r));
        for (; i && !i.isLeaf; )
          i = i.firstChild, o++;
      }
      return o;
    }
    function J0(n3, e, t, r, o) {
      let i = n3.findDiffStart(e, t);
      if (i == null)
        return null;
      let { a: s, b: a } = n3.findDiffEnd(e, t + n3.size, t + e.size);
      if (o == "end") {
        let l = Math.max(0, i - Math.min(s, a));
        r -= s + l - i;
      }
      if (s < i && n3.size < e.size) {
        let l = r <= i && r >= s ? i - r : 0;
        i -= l, i && i < e.size && op(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), a = i + (a - s), s = i;
      } else if (a < i) {
        let l = r <= i && r >= a ? i - r : 0;
        i -= l, i && i < n3.size && op(n3.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), s = i + (s - a), a = i;
      }
      return { start: i, endA: s, endB: a };
    }
    function op(n3) {
      if (n3.length != 2)
        return false;
      let e = n3.charCodeAt(0), t = n3.charCodeAt(1);
      return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
    }
    class Y0 {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(e, t) {
        this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new m0(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(cp), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = ap(this), sp(this), this.nodeViews = lp(this), this.docView = Fd(this.state.doc, ip(this), Rl(this), this.dom, this), this.domObserver = new F0(this, (r, o, i, s) => K0(this, r, o, i, s)), this.domObserver.start(), g0(this), this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let e = this._props;
          this._props = {};
          for (let t in e)
            this._props[t] = e[t];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && _c(this);
        let t = this._props;
        this._props = e, e.plugins && (e.plugins.forEach(cp), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(e) {
        let t = {};
        for (let r in this._props)
          t[r] = this._props[r];
        t.state = this.state;
        for (let r in e)
          t[r] = e[r];
        this.update(t);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(e) {
        this.updateStateInner(e, this._props);
      }
      updateStateInner(e, t) {
        var r;
        let o = this.state, i = false, s = false;
        e.storedMarks && this.composing && (nm(this), s = true), this.state = e;
        let a = o.plugins != e.plugins || this._props.plugins != t.plugins;
        if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
          let f = lp(this);
          Z0(f, this.nodeViews) && (this.nodeViews = f, i = true);
        }
        (a || t.handleDOMEvents != this._props.handleDOMEvents) && _c(this), this.editable = ap(this), sp(this);
        let l = Rl(this), c2 = ip(this), u = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", d = i || !this.docView.matchesNode(e.doc, c2, l);
        (d || !e.selection.eq(o.selection)) && (s = true);
        let p2 = u == "preserve" && s && this.dom.style.overflowAnchor == null && Mv(this);
        if (s) {
          this.domObserver.stop();
          let f = d && (nn || zt) && !this.composing && !o.selection.empty && !e.selection.empty && X0(o.selection, e.selection);
          if (d) {
            let h2 = zt ? this.trackWrites = this.domSelectionRange().focusNode : null;
            this.composing && (this.input.compositionNode = N0(this)), (i || !this.docView.update(e.doc, c2, l, this)) && (this.docView.updateOuterDeco(c2), this.docView.destroy(), this.docView = Fd(e.doc, c2, l, this.dom, this)), h2 && !this.trackWrites && (f = true);
          }
          f || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && e0(this)) ? fr(this, f) : (Wh(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : p2 && Av(p2);
      }
      /**
      @internal
      */
      scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
          if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof ne) {
            let t = this.docView.domAfterPos(this.state.selection.from);
            t.nodeType == 1 && Id(this, t.getBoundingClientRect(), e);
          } else
            Id(this, this.coordsAtPos(this.state.selection.head, 1), e);
        }
      }
      destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop(); )
          e.destroy && e.destroy();
      }
      updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (let t = 0; t < this.directPlugins.length; t++) {
            let r = this.directPlugins[t];
            r.spec.view && this.pluginViews.push(r.spec.view(this));
          }
          for (let t = 0; t < this.state.plugins.length; t++) {
            let r = this.state.plugins[t];
            r.spec.view && this.pluginViews.push(r.spec.view(this));
          }
        } else
          for (let t = 0; t < this.pluginViews.length; t++) {
            let r = this.pluginViews[t];
            r.update && r.update(this, e);
          }
      }
      updateDraggedNode(e, t) {
        let r = e.node, o = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
          o = r.from;
        else {
          let i = r.from + (this.state.doc.content.size - t.doc.content.size);
          (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
        }
        this.dragging = new om(e.slice, e.move, o < 0 ? void 0 : ne.create(this.state.doc, o));
      }
      someProp(e, t) {
        let r = this._props && this._props[e], o;
        if (r != null && (o = t ? t(r) : r))
          return o;
        for (let s = 0; s < this.directPlugins.length; s++) {
          let a = this.directPlugins[s].props[e];
          if (a != null && (o = t ? t(a) : a))
            return o;
        }
        let i = this.state.plugins;
        if (i)
          for (let s = 0; s < i.length; s++) {
            let a = i[s].props[e];
            if (a != null && (o = t ? t(a) : a))
              return o;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (nn) {
          let e = this.root.activeElement;
          if (e == this.dom)
            return true;
          if (!e || !this.dom.contains(e))
            return false;
          for (; e && this.dom != e && this.dom.contains(e); ) {
            if (e.contentEditable == "false")
              return false;
            e = e.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop(), this.editable && Rv(this.dom), fr(this), this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let e = this._root;
        if (e == null) {
          for (let t = this.dom.parentNode; t; t = t.parentNode)
            if (t.nodeType == 9 || t.nodeType == 11 && t.host)
              return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
        }
        return e || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(e) {
        return Pv(this, e);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(e, t = 1) {
        return Bh(this, e, t);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(e, t = 0) {
        return this.docView.domFromPos(e, t);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(e) {
        let t = this.docView.descAt(e);
        return t ? t.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimesfor example when interpreting an event
      targetyou don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(e, t, r = -1) {
        let o = this.docView.posFromDOM(e, t, r);
        if (o == null)
          throw new RangeError("DOM position not inside the editor");
        return o;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(e, t) {
        return Uv(this, t || this.state, e);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(e, t) {
        return Pi(this, "", e, false, t || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(e, t) {
        return Pi(this, e, null, true, t || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(e) {
        return su(this, e);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        this.docView && (b0(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Rl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, vv());
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(e) {
        return v0(this, e);
      }
      /**
      Dispatch a transaction. Will call
      [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
      when given, and otherwise defaults to applying the transaction to
      the current state and calling
      [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
      This method is bound to the view instance, so that it can be
      easily passed around.
      */
      dispatch(e) {
        let t = this._props.dispatchTransaction;
        t ? t.call(this, e) : this.updateState(this.state.apply(e));
      }
      /**
      @internal
      */
      domSelectionRange() {
        let e = this.domSelection();
        return e ? Yt && this.root.nodeType === 11 && Sv(this.dom.ownerDocument) == this.dom && H0(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    }
    function ip(n3) {
      let e = /* @__PURE__ */ Object.create(null);
      return e.class = "ProseMirror", e.contenteditable = String(n3.editable), n3.someProp("attributes", (t) => {
        if (typeof t == "function" && (t = t(n3.state)), t)
          for (let r in t)
            r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
      }), e.translate || (e.translate = "no"), [ht.node(0, n3.state.doc.content.size, e)];
    }
    function sp(n3) {
      if (n3.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n3.cursorWrapper = { dom: e, deco: ht.widget(n3.state.selection.from, e, { raw: true, marks: n3.markCursor }) };
      } else
        n3.cursorWrapper = null;
    }
    function ap(n3) {
      return !n3.someProp("editable", (e) => e(n3.state) === false);
    }
    function X0(n3, e) {
      let t = Math.min(n3.$anchor.sharedDepth(n3.head), e.$anchor.sharedDepth(e.head));
      return n3.$anchor.start(t) != e.$anchor.start(t);
    }
    function lp(n3) {
      let e = /* @__PURE__ */ Object.create(null);
      function t(r) {
        for (let o in r)
          Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
      }
      return n3.someProp("nodeViews", t), n3.someProp("markViews", t), e;
    }
    function Z0(n3, e) {
      let t = 0, r = 0;
      for (let o in n3) {
        if (n3[o] != e[o])
          return true;
        t++;
      }
      for (let o in e)
        r++;
      return t != r;
    }
    function cp(n3) {
      if (n3.spec.state || n3.spec.filterTransaction || n3.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    var zr = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    }, la = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    }, Q0 = typeof navigator < "u" && /Mac/.test(navigator.platform), ew = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var Dt = 0; Dt < 10; Dt++) zr[48 + Dt] = zr[96 + Dt] = String(Dt);
    for (var Dt = 1; Dt <= 24; Dt++) zr[Dt + 111] = "F" + Dt;
    for (var Dt = 65; Dt <= 90; Dt++)
      zr[Dt] = String.fromCharCode(Dt + 32), la[Dt] = String.fromCharCode(Dt);
    for (var Dl in zr) la.hasOwnProperty(Dl) || (la[Dl] = zr[Dl]);
    function tw(n3) {
      var e = Q0 && n3.metaKey && n3.shiftKey && !n3.ctrlKey && !n3.altKey || ew && n3.shiftKey && n3.key && n3.key.length == 1 || n3.key == "Unidentified", t = !e && n3.key || (n3.shiftKey ? la : zr)[n3.keyCode] || n3.key || "Unidentified";
      return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
    }
    const nw = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function rw(n3) {
      let e = n3.split(/-(?!$)/), t = e[e.length - 1];
      t == "Space" && (t = " ");
      let r, o, i, s;
      for (let a = 0; a < e.length - 1; a++) {
        let l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          s = true;
        else if (/^a(lt)?$/i.test(l))
          r = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          o = true;
        else if (/^s(hift)?$/i.test(l))
          i = true;
        else if (/^mod$/i.test(l))
          nw ? s = true : o = true;
        else
          throw new Error("Unrecognized modifier name: " + l);
      }
      return r && (t = "Alt-" + t), o && (t = "Ctrl-" + t), s && (t = "Meta-" + t), i && (t = "Shift-" + t), t;
    }
    function ow(n3) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let t in n3)
        e[rw(t)] = n3[t];
      return e;
    }
    function Ll(n3, e, t = true) {
      return e.altKey && (n3 = "Alt-" + n3), e.ctrlKey && (n3 = "Ctrl-" + n3), e.metaKey && (n3 = "Meta-" + n3), t && e.shiftKey && (n3 = "Shift-" + n3), n3;
    }
    function iw(n3) {
      return new Ue({ props: { handleKeyDown: pu(n3) } });
    }
    function pu(n3) {
      let e = ow(n3);
      return function(t, r) {
        let o = tw(r), i, s = e[Ll(o, r)];
        if (s && s(t.state, t.dispatch, t))
          return true;
        if (o.length == 1 && o != " ") {
          if (r.shiftKey) {
            let a = e[Ll(o, r, false)];
            if (a && a(t.state, t.dispatch, t))
              return true;
          }
          if ((r.shiftKey || r.altKey || r.metaKey || o.charCodeAt(0) > 127) && (i = zr[r.keyCode]) && i != o) {
            let a = e[Ll(i, r)];
            if (a && a(t.state, t.dispatch, t))
              return true;
          }
        }
        return false;
      };
    }
    const fu = (n3, e) => n3.selection.empty ? false : (e && e(n3.tr.deleteSelection().scrollIntoView()), true);
    function cm(n3, e) {
      let { $cursor: t } = n3.selection;
      return !t || (e ? !e.endOfTextblock("backward", n3) : t.parentOffset > 0) ? null : t;
    }
    const um = (n3, e, t) => {
      let r = cm(n3, t);
      if (!r)
        return false;
      let o = hu(r);
      if (!o) {
        let s = r.blockRange(), a = s && Xo(s);
        return a == null ? false : (e && e(n3.tr.lift(s, a).scrollIntoView()), true);
      }
      let i = o.nodeBefore;
      if (vm(n3, o, e, -1))
        return true;
      if (r.parent.content.size == 0 && (Vo(i, "end") || ne.isSelectable(i)))
        for (let s = r.depth; ; s--) {
          let a = Ja(n3.doc, r.before(s), r.after(s), I.empty);
          if (a && a.slice.size < a.to - a.from) {
            if (e) {
              let l = n3.tr.step(a);
              l.setSelection(Vo(i, "end") ? ue.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1) : ne.create(l.doc, o.pos - i.nodeSize)), e(l.scrollIntoView());
            }
            return true;
          }
          if (s == 1 || r.node(s - 1).childCount > 1)
            break;
        }
      return i.isAtom && o.depth == r.depth - 1 ? (e && e(n3.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), true) : false;
    }, sw = (n3, e, t) => {
      let r = cm(n3, t);
      if (!r)
        return false;
      let o = hu(r);
      return o ? dm(n3, o, e) : false;
    }, aw = (n3, e, t) => {
      let r = fm(n3, t);
      if (!r)
        return false;
      let o = mu(r);
      return o ? dm(n3, o, e) : false;
    };
    function dm(n3, e, t) {
      let r = e.nodeBefore, o = r, i = e.pos - 1;
      for (; !o.isTextblock; i--) {
        if (o.type.spec.isolating)
          return false;
        let u = o.lastChild;
        if (!u)
          return false;
        o = u;
      }
      let s = e.nodeAfter, a = s, l = e.pos + 1;
      for (; !a.isTextblock; l++) {
        if (a.type.spec.isolating)
          return false;
        let u = a.firstChild;
        if (!u)
          return false;
        a = u;
      }
      let c2 = Ja(n3.doc, i, l, I.empty);
      if (!c2 || c2.from != i || c2 instanceof Rt && c2.slice.size >= l - i)
        return false;
      if (t) {
        let u = n3.tr.step(c2);
        u.setSelection(ie.create(u.doc, i)), t(u.scrollIntoView());
      }
      return true;
    }
    function Vo(n3, e, t = false) {
      for (let r = n3; r; r = e == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
          return true;
        if (t && r.childCount != 1)
          return false;
      }
      return false;
    }
    const pm = (n3, e, t) => {
      let { $head: r, empty: o } = n3.selection, i = r;
      if (!o)
        return false;
      if (r.parent.isTextblock) {
        if (t ? !t.endOfTextblock("backward", n3) : r.parentOffset > 0)
          return false;
        i = hu(r);
      }
      let s = i && i.nodeBefore;
      return !s || !ne.isSelectable(s) ? false : (e && e(n3.tr.setSelection(ne.create(n3.doc, i.pos - s.nodeSize)).scrollIntoView()), true);
    };
    function hu(n3) {
      if (!n3.parent.type.spec.isolating)
        for (let e = n3.depth - 1; e >= 0; e--) {
          if (n3.index(e) > 0)
            return n3.doc.resolve(n3.before(e + 1));
          if (n3.node(e).type.spec.isolating)
            break;
        }
      return null;
    }
    function fm(n3, e) {
      let { $cursor: t } = n3.selection;
      return !t || (e ? !e.endOfTextblock("forward", n3) : t.parentOffset < t.parent.content.size) ? null : t;
    }
    const hm = (n3, e, t) => {
      let r = fm(n3, t);
      if (!r)
        return false;
      let o = mu(r);
      if (!o)
        return false;
      let i = o.nodeAfter;
      if (vm(n3, o, e, 1))
        return true;
      if (r.parent.content.size == 0 && (Vo(i, "start") || ne.isSelectable(i))) {
        let s = Ja(n3.doc, r.before(), r.after(), I.empty);
        if (s && s.slice.size < s.to - s.from) {
          if (e) {
            let a = n3.tr.step(s);
            a.setSelection(Vo(i, "start") ? ue.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : ne.create(a.doc, a.mapping.map(o.pos))), e(a.scrollIntoView());
          }
          return true;
        }
      }
      return i.isAtom && o.depth == r.depth - 1 ? (e && e(n3.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), true) : false;
    }, mm = (n3, e, t) => {
      let { $head: r, empty: o } = n3.selection, i = r;
      if (!o)
        return false;
      if (r.parent.isTextblock) {
        if (t ? !t.endOfTextblock("forward", n3) : r.parentOffset < r.parent.content.size)
          return false;
        i = mu(r);
      }
      let s = i && i.nodeAfter;
      return !s || !ne.isSelectable(s) ? false : (e && e(n3.tr.setSelection(ne.create(n3.doc, i.pos)).scrollIntoView()), true);
    };
    function mu(n3) {
      if (!n3.parent.type.spec.isolating)
        for (let e = n3.depth - 1; e >= 0; e--) {
          let t = n3.node(e);
          if (n3.index(e) + 1 < t.childCount)
            return n3.doc.resolve(n3.after(e + 1));
          if (t.type.spec.isolating)
            break;
        }
      return null;
    }
    const lw = (n3, e) => {
      let t = n3.selection, r = t instanceof ne, o;
      if (r) {
        if (t.node.isTextblock || !Ur(n3.doc, t.from))
          return false;
        o = t.from;
      } else if (o = ja(n3.doc, t.from, -1), o == null)
        return false;
      if (e) {
        let i = n3.tr.join(o);
        r && i.setSelection(ne.create(i.doc, o - n3.doc.resolve(o).nodeBefore.nodeSize)), e(i.scrollIntoView());
      }
      return true;
    }, cw = (n3, e) => {
      let t = n3.selection, r;
      if (t instanceof ne) {
        if (t.node.isTextblock || !Ur(n3.doc, t.to))
          return false;
        r = t.to;
      } else if (r = ja(n3.doc, t.to, 1), r == null)
        return false;
      return e && e(n3.tr.join(r).scrollIntoView()), true;
    }, uw = (n3, e) => {
      let { $from: t, $to: r } = n3.selection, o = t.blockRange(r), i = o && Xo(o);
      return i == null ? false : (e && e(n3.tr.lift(o, i).scrollIntoView()), true);
    }, gm = (n3, e) => {
      let { $head: t, $anchor: r } = n3.selection;
      return !t.parent.type.spec.code || !t.sameParent(r) ? false : (e && e(n3.tr.insertText(`
`).scrollIntoView()), true);
    };
    function gu(n3) {
      for (let e = 0; e < n3.edgeCount; e++) {
        let { type: t } = n3.edge(e);
        if (t.isTextblock && !t.hasRequiredAttrs())
          return t;
      }
      return null;
    }
    const dw = (n3, e) => {
      let { $head: t, $anchor: r } = n3.selection;
      if (!t.parent.type.spec.code || !t.sameParent(r))
        return false;
      let o = t.node(-1), i = t.indexAfter(-1), s = gu(o.contentMatchAt(i));
      if (!s || !o.canReplaceWith(i, i, s))
        return false;
      if (e) {
        let a = t.after(), l = n3.tr.replaceWith(a, a, s.createAndFill());
        l.setSelection(ue.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
      }
      return true;
    }, bm = (n3, e) => {
      let t = n3.selection, { $from: r, $to: o } = t;
      if (t instanceof hn || r.parent.inlineContent || o.parent.inlineContent)
        return false;
      let i = gu(o.parent.contentMatchAt(o.indexAfter()));
      if (!i || !i.isTextblock)
        return false;
      if (e) {
        let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, a = n3.tr.insert(s, i.createAndFill());
        a.setSelection(ie.create(a.doc, s + 1)), e(a.scrollIntoView());
      }
      return true;
    }, ym = (n3, e) => {
      let { $cursor: t } = n3.selection;
      if (!t || t.parent.content.size)
        return false;
      if (t.depth > 1 && t.after() != t.end(-1)) {
        let i = t.before();
        if (pr(n3.doc, i))
          return e && e(n3.tr.split(i).scrollIntoView()), true;
      }
      let r = t.blockRange(), o = r && Xo(r);
      return o == null ? false : (e && e(n3.tr.lift(r, o).scrollIntoView()), true);
    };
    function pw(n3) {
      return (e, t) => {
        let { $from: r, $to: o } = e.selection;
        if (e.selection instanceof ne && e.selection.node.isBlock)
          return !r.parentOffset || !pr(e.doc, r.pos) ? false : (t && t(e.tr.split(r.pos).scrollIntoView()), true);
        if (!r.depth)
          return false;
        let i = [], s, a, l = false, c2 = false;
        for (let f = r.depth; ; f--)
          if (r.node(f).isBlock) {
            l = r.end(f) == r.pos + (r.depth - f), c2 = r.start(f) == r.pos - (r.depth - f), a = gu(r.node(f - 1).contentMatchAt(r.indexAfter(f - 1))), i.unshift(l && a ? { type: a } : null), s = f;
            break;
          } else {
            if (f == 1)
              return false;
            i.unshift(null);
          }
        let u = e.tr;
        (e.selection instanceof ie || e.selection instanceof hn) && u.deleteSelection();
        let d = u.mapping.map(r.pos), p2 = pr(u.doc, d, i.length, i);
        if (p2 || (i[0] = a ? { type: a } : null, p2 = pr(u.doc, d, i.length, i)), u.split(d, i.length, i), !l && c2 && r.node(s).type != a) {
          let f = u.mapping.map(r.before(s)), h2 = u.doc.resolve(f);
          a && r.node(s - 1).canReplaceWith(h2.index(), h2.index() + 1, a) && u.setNodeMarkup(u.mapping.map(r.before(s)), a);
        }
        return t && t(u.scrollIntoView()), true;
      };
    }
    const fw = pw(), hw = (n3, e) => {
      let { $from: t, to: r } = n3.selection, o, i = t.sharedDepth(r);
      return i == 0 ? false : (o = t.before(i), e && e(n3.tr.setSelection(ne.create(n3.doc, o))), true);
    };
    function mw(n3, e, t) {
      let r = e.nodeBefore, o = e.nodeAfter, i = e.index();
      return !r || !o || !r.type.compatibleContent(o.type) ? false : !r.content.size && e.parent.canReplace(i - 1, i) ? (t && t(n3.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || Ur(n3.doc, e.pos)) ? false : (t && t(n3.tr.join(e.pos).scrollIntoView()), true);
    }
    function vm(n3, e, t, r) {
      let o = e.nodeBefore, i = e.nodeAfter, s, a, l = o.type.spec.isolating || i.type.spec.isolating;
      if (!l && mw(n3, e, t))
        return true;
      let c2 = !l && e.parent.canReplace(e.index(), e.index() + 1);
      if (c2 && (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) && a.matchType(s[0] || i.type).validEnd) {
        if (t) {
          let f = e.pos + i.nodeSize, h2 = O.empty;
          for (let b = s.length - 1; b >= 0; b--)
            h2 = O.from(s[b].create(null, h2));
          h2 = O.from(o.copy(h2));
          let m = n3.tr.step(new Bt(e.pos - 1, f, e.pos, f, new I(h2, 1, 0), s.length, true)), g = m.doc.resolve(f + 2 * s.length);
          g.nodeAfter && g.nodeAfter.type == o.type && Ur(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView());
        }
        return true;
      }
      let u = i.type.spec.isolating || r > 0 && l ? null : ue.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), p2 = d && Xo(d);
      if (p2 != null && p2 >= e.depth)
        return t && t(n3.tr.lift(d, p2).scrollIntoView()), true;
      if (c2 && Vo(i, "start", true) && Vo(o, "end")) {
        let f = o, h2 = [];
        for (; h2.push(f), !f.isTextblock; )
          f = f.lastChild;
        let m = i, g = 1;
        for (; !m.isTextblock; m = m.firstChild)
          g++;
        if (f.canReplace(f.childCount, f.childCount, m.content)) {
          if (t) {
            let b = O.empty;
            for (let _ = h2.length - 1; _ >= 0; _--)
              b = O.from(h2[_].copy(b));
            let w = n3.tr.step(new Bt(e.pos - h2.length, e.pos + i.nodeSize, e.pos + g, e.pos + i.nodeSize - g, new I(b, h2.length, 0), 0, true));
            t(w.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function wm(n3) {
      return function(e, t) {
        let r = e.selection, o = n3 < 0 ? r.$from : r.$to, i = o.depth;
        for (; o.node(i).isInline; ) {
          if (!i)
            return false;
          i--;
        }
        return o.node(i).isTextblock ? (t && t(e.tr.setSelection(ie.create(e.doc, n3 < 0 ? o.start(i) : o.end(i)))), true) : false;
      };
    }
    const gw = wm(-1), bw = wm(1);
    function yw(n3, e = null) {
      return function(t, r) {
        let { $from: o, $to: i } = t.selection, s = o.blockRange(i), a = s && nu(s, n3, e);
        return a ? (r && r(t.tr.wrap(s, a).scrollIntoView()), true) : false;
      };
    }
    function up(n3, e = null) {
      return function(t, r) {
        let o = false;
        for (let i = 0; i < t.selection.ranges.length && !o; i++) {
          let { $from: { pos: s }, $to: { pos: a } } = t.selection.ranges[i];
          t.doc.nodesBetween(s, a, (l, c2) => {
            if (o)
              return false;
            if (!(!l.isTextblock || l.hasMarkup(n3, e)))
              if (l.type == n3)
                o = true;
              else {
                let u = t.doc.resolve(c2), d = u.index();
                o = u.parent.canReplaceWith(d, d + 1, n3);
              }
          });
        }
        if (!o)
          return false;
        if (r) {
          let i = t.tr;
          for (let s = 0; s < t.selection.ranges.length; s++) {
            let { $from: { pos: a }, $to: { pos: l } } = t.selection.ranges[s];
            i.setBlockType(a, l, n3, e);
          }
          r(i.scrollIntoView());
        }
        return true;
      };
    }
    function bu(...n3) {
      return function(e, t, r) {
        for (let o = 0; o < n3.length; o++)
          if (n3[o](e, t, r))
            return true;
        return false;
      };
    }
    bu(fu, um, pm);
    bu(fu, hm, mm);
    bu(gm, bm, ym, fw);
    typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
    function vw(n3, e = null) {
      return function(t, r) {
        let { $from: o, $to: i } = t.selection, s = o.blockRange(i);
        if (!s)
          return false;
        let a = r ? t.tr : null;
        return ww(a, s, n3, e) ? (r && r(a.scrollIntoView()), true) : false;
      };
    }
    function ww(n3, e, t, r = null) {
      let o = false, i = e, s = e.$from.doc;
      if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
        if (e.$from.index(e.depth - 1) == 0)
          return false;
        let l = s.resolve(e.start - 2);
        i = new ta(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new ta(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), o = true;
      }
      let a = nu(i, t, r, e);
      return a ? (n3 && kw(n3, e, a, o, t), true) : false;
    }
    function kw(n3, e, t, r, o) {
      let i = O.empty;
      for (let u = t.length - 1; u >= 0; u--)
        i = O.from(t[u].type.create(t[u].attrs, i));
      n3.step(new Bt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new I(i, 0, 0), t.length, true));
      let s = 0;
      for (let u = 0; u < t.length; u++)
        t[u].type == o && (s = u + 1);
      let a = t.length - s, l = e.start + t.length - (r ? 2 : 0), c2 = e.parent;
      for (let u = e.startIndex, d = e.endIndex, p2 = true; u < d; u++, p2 = false)
        !p2 && pr(n3.doc, l, a) && (n3.split(l, a), l += 2 * a), l += c2.child(u).nodeSize;
      return n3;
    }
    function Ew(n3) {
      return function(e, t) {
        let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == n3);
        return i ? t ? r.node(i.depth - 1).type == n3 ? _w(e, t, n3, i) : Sw(e, t, i) : true : false;
      };
    }
    function _w(n3, e, t, r) {
      let o = n3.tr, i = r.end, s = r.$to.end(r.depth);
      i < s && (o.step(new Bt(i - 1, s, i, s, new I(O.from(t.create(null, r.parent.copy())), 1, 0), 1, true)), r = new ta(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
      const a = Xo(r);
      if (a == null)
        return false;
      o.lift(r, a);
      let l = o.mapping.map(i, -1) - 1;
      return Ur(o.doc, l) && o.join(l), e(o.scrollIntoView()), true;
    }
    function Sw(n3, e, t) {
      let r = n3.tr, o = t.parent;
      for (let f = t.end, h2 = t.endIndex - 1, m = t.startIndex; h2 > m; h2--)
        f -= o.child(h2).nodeSize, r.delete(f - 1, f + 1);
      let i = r.doc.resolve(t.start), s = i.nodeAfter;
      if (r.mapping.map(t.end) != t.start + i.nodeAfter.nodeSize)
        return false;
      let a = t.startIndex == 0, l = t.endIndex == o.childCount, c2 = i.node(-1), u = i.index(-1);
      if (!c2.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? O.empty : O.from(o))))
        return false;
      let d = i.pos, p2 = d + s.nodeSize;
      return r.step(new Bt(d - (a ? 1 : 0), p2 + (l ? 1 : 0), d + 1, p2 - 1, new I((a ? O.empty : O.from(o.copy(O.empty))).append(l ? O.empty : O.from(o.copy(O.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), true;
    }
    function Cw(n3) {
      return function(e, t) {
        let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (c2) => c2.childCount > 0 && c2.firstChild.type == n3);
        if (!i)
          return false;
        let s = i.startIndex;
        if (s == 0)
          return false;
        let a = i.parent, l = a.child(s - 1);
        if (l.type != n3)
          return false;
        if (t) {
          let c2 = l.lastChild && l.lastChild.type == a.type, u = O.from(c2 ? n3.create() : null), d = new I(O.from(n3.create(null, O.from(a.type.create(null, u)))), c2 ? 3 : 1, 0), p2 = i.start, f = i.end;
          t(e.tr.step(new Bt(p2 - (c2 ? 3 : 1), f, p2, f, d, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    function Qa(n3) {
      const { state: e, transaction: t } = n3;
      let { selection: r } = t, { doc: o } = t, { storedMarks: i } = t;
      return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
          return i;
        },
        get selection() {
          return r;
        },
        get doc() {
          return o;
        },
        get tr() {
          return r = t.selection, o = t.doc, i = t.storedMarks, t;
        }
      };
    }
    class el {
      constructor(e) {
        this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands: e, editor: t, state: r } = this, { view: o } = t, { tr: i } = r, s = this.buildProps(i);
        return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
          const d = l(...u)(s);
          return !i.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(i), d;
        }]));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(e, t = true) {
        const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = [], l = !!e, c2 = e || i.tr, u = () => (!l && t && !c2.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c2), a.every((p2) => p2 === true)), d = {
          ...Object.fromEntries(Object.entries(r).map(([p2, f]) => [p2, (...m) => {
            const g = this.buildProps(c2, t), b = f(...m)(g);
            return a.push(b), d;
          }])),
          run: u
        };
        return d;
      }
      createCan(e) {
        const { rawCommands: t, state: r } = this, o = false, i = e || r.tr, s = this.buildProps(i, o);
        return {
          ...Object.fromEntries(Object.entries(t).map(([l, c2]) => [l, (...u) => c2(...u)({ ...s, dispatch: void 0 })])),
          chain: () => this.createChain(i, o)
        };
      }
      buildProps(e, t = true) {
        const { rawCommands: r, editor: o, state: i } = this, { view: s } = o, a = {
          tr: e,
          editor: o,
          view: s,
          state: Qa({
            state: i,
            transaction: e
          }),
          dispatch: t ? () => {
          } : void 0,
          chain: () => this.createChain(e, t),
          can: () => this.createCan(e),
          get commands() {
            return Object.fromEntries(Object.entries(r).map(([l, c2]) => [l, (...u) => c2(...u)(a)]));
          }
        };
        return a;
      }
    }
    class xw {
      constructor() {
        this.callbacks = {};
      }
      on(e, t) {
        return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
      }
      emit(e, ...t) {
        const r = this.callbacks[e];
        return r && r.forEach((o) => o.apply(this, t)), this;
      }
      off(e, t) {
        const r = this.callbacks[e];
        return r && (t ? this.callbacks[e] = r.filter((o) => o !== t) : delete this.callbacks[e]), this;
      }
      once(e, t) {
        const r = (...o) => {
          this.off(e, r), t.apply(this, o);
        };
        return this.on(e, r);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    }
    function Z(n3, e, t) {
      return n3.config[e] === void 0 && n3.parent ? Z(n3.parent, e, t) : typeof n3.config[e] == "function" ? n3.config[e].bind({
        ...t,
        parent: n3.parent ? Z(n3.parent, e, t) : null
      }) : n3.config[e];
    }
    function tl(n3) {
      const e = n3.filter((o) => o.type === "extension"), t = n3.filter((o) => o.type === "node"), r = n3.filter((o) => o.type === "mark");
      return {
        baseExtensions: e,
        nodeExtensions: t,
        markExtensions: r
      };
    }
    function km(n3) {
      const e = [], { nodeExtensions: t, markExtensions: r } = tl(n3), o = [...t, ...r], i = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      return n3.forEach((s) => {
        const a = {
          name: s.name,
          options: s.options,
          storage: s.storage,
          extensions: o
        }, l = Z(s, "addGlobalAttributes", a);
        if (!l)
          return;
        l().forEach((u) => {
          u.types.forEach((d) => {
            Object.entries(u.attributes).forEach(([p2, f]) => {
              e.push({
                type: d,
                name: p2,
                attribute: {
                  ...i,
                  ...f
                }
              });
            });
          });
        });
      }), o.forEach((s) => {
        const a = {
          name: s.name,
          options: s.options,
          storage: s.storage
        }, l = Z(s, "addAttributes", a);
        if (!l)
          return;
        const c2 = l();
        Object.entries(c2).forEach(([u, d]) => {
          const p2 = {
            ...i,
            ...d
          };
          typeof (p2 == null ? void 0 : p2.default) == "function" && (p2.default = p2.default()), p2 != null && p2.isRequired && (p2 == null ? void 0 : p2.default) === void 0 && delete p2.default, e.push({
            type: s.name,
            name: u,
            attribute: p2
          });
        });
      }), e;
    }
    function Ct(n3, e) {
      if (typeof n3 == "string") {
        if (!e.nodes[n3])
          throw Error(`There is no node type named '${n3}'. Maybe you forgot to add the extension?`);
        return e.nodes[n3];
      }
      return n3;
    }
    function $e(...n3) {
      return n3.filter((e) => !!e).reduce((e, t) => {
        const r = { ...e };
        return Object.entries(t).forEach(([o, i]) => {
          if (!r[o]) {
            r[o] = i;
            return;
          }
          if (o === "class") {
            const a = i ? String(i).split(" ") : [], l = r[o] ? r[o].split(" ") : [], c2 = a.filter((u) => !l.includes(u));
            r[o] = [...l, ...c2].join(" ");
          } else if (o === "style") {
            const a = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[o] ? r[o].split(";").map((u) => u.trim()).filter(Boolean) : [], c2 = /* @__PURE__ */ new Map();
            l.forEach((u) => {
              const [d, p2] = u.split(":").map((f) => f.trim());
              c2.set(d, p2);
            }), a.forEach((u) => {
              const [d, p2] = u.split(":").map((f) => f.trim());
              c2.set(d, p2);
            }), r[o] = Array.from(c2.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
          } else
            r[o] = i;
        }), r;
      }, {});
    }
    function Sc(n3, e) {
      return e.filter((t) => t.type === n3.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n3.attrs) || {} : {
        [t.name]: n3.attrs[t.name]
      }).reduce((t, r) => $e(t, r), {});
    }
    function Em(n3) {
      return typeof n3 == "function";
    }
    function Te(n3, e = void 0, ...t) {
      return Em(n3) ? e ? n3.bind(e)(...t) : n3(...t) : n3;
    }
    function Tw(n3 = {}) {
      return Object.keys(n3).length === 0 && n3.constructor === Object;
    }
    function Ow(n3) {
      return typeof n3 != "string" ? n3 : n3.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n3) : n3 === "true" ? true : n3 === "false" ? false : n3;
    }
    function dp(n3, e) {
      return "style" in n3 ? n3 : {
        ...n3,
        getAttrs: (t) => {
          const r = n3.getAttrs ? n3.getAttrs(t) : n3.attrs;
          if (r === false)
            return false;
          const o = e.reduce((i, s) => {
            const a = s.attribute.parseHTML ? s.attribute.parseHTML(t) : Ow(t.getAttribute(s.name));
            return a == null ? i : {
              ...i,
              [s.name]: a
            };
          }, {});
          return { ...r, ...o };
        }
      };
    }
    function pp(n3) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(n3).filter(([e, t]) => e === "attrs" && Tw(t) ? false : t != null)
      );
    }
    function Nw(n3, e) {
      var t;
      const r = km(n3), { nodeExtensions: o, markExtensions: i } = tl(n3), s = (t = o.find((c2) => Z(c2, "topNode"))) === null || t === void 0 ? void 0 : t.name, a = Object.fromEntries(o.map((c2) => {
        const u = r.filter((b) => b.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = n3.reduce((b, w) => {
          const _ = Z(w, "extendNodeSchema", d);
          return {
            ...b,
            ..._ ? _(c2) : {}
          };
        }, {}), f = pp({
          ...p2,
          content: Te(Z(c2, "content", d)),
          marks: Te(Z(c2, "marks", d)),
          group: Te(Z(c2, "group", d)),
          inline: Te(Z(c2, "inline", d)),
          atom: Te(Z(c2, "atom", d)),
          selectable: Te(Z(c2, "selectable", d)),
          draggable: Te(Z(c2, "draggable", d)),
          code: Te(Z(c2, "code", d)),
          whitespace: Te(Z(c2, "whitespace", d)),
          linebreakReplacement: Te(Z(c2, "linebreakReplacement", d)),
          defining: Te(Z(c2, "defining", d)),
          isolating: Te(Z(c2, "isolating", d)),
          attrs: Object.fromEntries(u.map((b) => {
            var w;
            return [b.name, { default: (w = b == null ? void 0 : b.attribute) === null || w === void 0 ? void 0 : w.default }];
          }))
        }), h2 = Te(Z(c2, "parseHTML", d));
        h2 && (f.parseDOM = h2.map((b) => dp(b, u)));
        const m = Z(c2, "renderHTML", d);
        m && (f.toDOM = (b) => m({
          node: b,
          HTMLAttributes: Sc(b, u)
        }));
        const g = Z(c2, "renderText", d);
        return g && (f.toText = g), [c2.name, f];
      })), l = Object.fromEntries(i.map((c2) => {
        const u = r.filter((g) => g.type === c2.name), d = {
          name: c2.name,
          options: c2.options,
          storage: c2.storage,
          editor: e
        }, p2 = n3.reduce((g, b) => {
          const w = Z(b, "extendMarkSchema", d);
          return {
            ...g,
            ...w ? w(c2) : {}
          };
        }, {}), f = pp({
          ...p2,
          inclusive: Te(Z(c2, "inclusive", d)),
          excludes: Te(Z(c2, "excludes", d)),
          group: Te(Z(c2, "group", d)),
          spanning: Te(Z(c2, "spanning", d)),
          code: Te(Z(c2, "code", d)),
          attrs: Object.fromEntries(u.map((g) => {
            var b;
            return [g.name, { default: (b = g == null ? void 0 : g.attribute) === null || b === void 0 ? void 0 : b.default }];
          }))
        }), h2 = Te(Z(c2, "parseHTML", d));
        h2 && (f.parseDOM = h2.map((g) => dp(g, u)));
        const m = Z(c2, "renderHTML", d);
        return m && (f.toDOM = (g) => m({
          mark: g,
          HTMLAttributes: Sc(g, u)
        })), [c2.name, f];
      }));
      return new eh({
        topNode: s,
        nodes: a,
        marks: l
      });
    }
    function Bl(n3, e) {
      return e.nodes[n3] || e.marks[n3] || null;
    }
    function fp(n3, e) {
      return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n3.name) : e;
    }
    function yu(n3, e) {
      const t = yo.fromSchema(e).serializeFragment(n3), o = document.implementation.createHTMLDocument().createElement("div");
      return o.appendChild(t), o.innerHTML;
    }
    const Mw = (n3, e = 500) => {
      let t = "";
      const r = n3.parentOffset;
      return n3.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, a) => {
        var l, c2;
        const u = ((c2 = (l = o.type.spec).toText) === null || c2 === void 0 ? void 0 : c2.call(l, {
          node: o,
          pos: i,
          parent: s,
          index: a
        })) || o.textContent || "%leaf%";
        t += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i));
      }), t;
    };
    function vu(n3) {
      return Object.prototype.toString.call(n3) === "[object RegExp]";
    }
    class rs {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const Aw = (n3, e) => {
      if (vu(e))
        return e.exec(n3);
      const t = e(n3);
      if (!t)
        return null;
      const r = [t.text];
      return r.index = t.index, r.input = n3, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r;
    };
    function bs(n3) {
      var e;
      const { editor: t, from: r, to: o, text: i, rules: s, plugin: a } = n3, { view: l } = t;
      if (l.composing)
        return false;
      const c2 = l.state.doc.resolve(r);
      if (
        // check for code node
        c2.parent.type.spec.code || !((e = c2.nodeBefore || c2.nodeAfter) === null || e === void 0) && e.marks.find((p2) => p2.type.spec.code)
      )
        return false;
      let u = false;
      const d = Mw(c2) + i;
      return s.forEach((p2) => {
        if (u)
          return;
        const f = Aw(d, p2.find);
        if (!f)
          return;
        const h2 = l.state.tr, m = Qa({
          state: l.state,
          transaction: h2
        }), g = {
          from: r - (f[0].length - i.length),
          to: o
        }, { commands: b, chain: w, can: _ } = new el({
          editor: t,
          state: m
        });
        p2.handler({
          state: m,
          range: g,
          match: f,
          commands: b,
          chain: w,
          can: _
        }) === null || !h2.steps.length || (h2.setMeta(a, {
          transform: h2,
          from: r,
          to: o,
          text: i
        }), l.dispatch(h2), u = true);
      }), u;
    }
    function Rw(n3) {
      const { editor: e, rules: t } = n3, r = new Ue({
        state: {
          init() {
            return null;
          },
          apply(o, i, s) {
            const a = o.getMeta(r);
            if (a)
              return a;
            const l = o.getMeta("applyInputRules");
            return !!l && setTimeout(() => {
              let { text: u } = l;
              typeof u == "string" ? u = u : u = yu(O.from(u), s.schema);
              const { from: d } = l, p2 = d + u.length;
              bs({
                editor: e,
                from: d,
                to: p2,
                text: u,
                rules: t,
                plugin: r
              });
            }), o.selectionSet || o.docChanged ? null : i;
          }
        },
        props: {
          handleTextInput(o, i, s, a) {
            return bs({
              editor: e,
              from: i,
              to: s,
              text: a,
              rules: t,
              plugin: r
            });
          },
          handleDOMEvents: {
            compositionend: (o) => (setTimeout(() => {
              const { $cursor: i } = o.state.selection;
              i && bs({
                editor: e,
                from: i.pos,
                to: i.pos,
                text: "",
                rules: t,
                plugin: r
              });
            }), false)
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(o, i) {
            if (i.key !== "Enter")
              return false;
            const { $cursor: s } = o.state.selection;
            return s ? bs({
              editor: e,
              from: s.pos,
              to: s.pos,
              text: `
`,
              rules: t,
              plugin: r
            }) : false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return r;
    }
    function Iw(n3) {
      return Object.prototype.toString.call(n3).slice(8, -1);
    }
    function ys(n3) {
      return Iw(n3) !== "Object" ? false : n3.constructor === Object && Object.getPrototypeOf(n3) === Object.prototype;
    }
    function nl(n3, e) {
      const t = { ...n3 };
      return ys(n3) && ys(e) && Object.keys(e).forEach((r) => {
        ys(e[r]) && ys(n3[r]) ? t[r] = nl(n3[r], e[r]) : t[r] = e[r];
      }), t;
    }
    class Cn {
      constructor(e = {}) {
        this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new Cn(e);
      }
      configure(e = {}) {
        const t = this.extend({
          ...this.config,
          addOptions: () => nl(this.options, e)
        });
        return t.name = this.name, t.parent = this.parent, t;
      }
      extend(e = {}) {
        const t = new Cn(e);
        return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Te(Z(t, "addOptions", {
          name: t.name
        })), t.storage = Te(Z(t, "addStorage", {
          name: t.name,
          options: t.options
        })), t;
      }
      static handleExit({ editor: e, mark: t }) {
        const { tr: r } = e.state, o = e.state.selection.$from;
        if (o.pos === o.end()) {
          const s = o.marks();
          if (!!!s.find((c2) => (c2 == null ? void 0 : c2.type.name) === t.name))
            return false;
          const l = s.find((c2) => (c2 == null ? void 0 : c2.type.name) === t.name);
          return l && r.removeStoredMark(l), r.insertText(" ", o.pos), e.view.dispatch(r), true;
        }
        return false;
      }
    }
    function Dw(n3) {
      return typeof n3 == "number";
    }
    class Lw {
      constructor(e) {
        this.find = e.find, this.handler = e.handler;
      }
    }
    const Bw = (n3, e, t) => {
      if (vu(e))
        return [...n3.matchAll(e)];
      const r = e(n3, t);
      return r ? r.map((o) => {
        const i = [o.text];
        return i.index = o.index, i.input = n3, i.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(o.replaceWith)), i;
      }) : [];
    };
    function Pw(n3) {
      const { editor: e, state: t, from: r, to: o, rule: i, pasteEvent: s, dropEvent: a } = n3, { commands: l, chain: c2, can: u } = new el({
        editor: e,
        state: t
      }), d = [];
      return t.doc.nodesBetween(r, o, (f, h2) => {
        if (!f.isTextblock || f.type.spec.code)
          return;
        const m = Math.max(r, h2), g = Math.min(o, h2 + f.content.size), b = f.textBetween(m - h2, g - h2, void 0, "");
        Bw(b, i.find, s).forEach((_) => {
          if (_.index === void 0)
            return;
          const v = m + _.index + 1, T = v + _[0].length, S = {
            from: t.tr.mapping.map(v),
            to: t.tr.mapping.map(T)
          }, z = i.handler({
            state: t,
            range: S,
            match: _,
            commands: l,
            chain: c2,
            can: u,
            pasteEvent: s,
            dropEvent: a
          });
          d.push(z);
        });
      }), d.every((f) => f !== null);
    }
    let vs = null;
    const $w = (n3) => {
      var e;
      const t = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n3), t;
    };
    function Fw(n3) {
      const { editor: e, rules: t } = n3;
      let r = null, o = false, i = false, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      const l = ({ state: u, from: d, to: p2, rule: f, pasteEvt: h2 }) => {
        const m = u.tr, g = Qa({
          state: u,
          transaction: m
        });
        if (!(!Pw({
          editor: e,
          state: g,
          from: Math.max(d - 1, 0),
          to: p2.b - 1,
          rule: f,
          pasteEvent: h2,
          dropEvent: a
        }) || !m.steps.length)) {
          try {
            a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
          } catch {
            a = null;
          }
          return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
        }
      };
      return t.map((u) => new Ue({
        // we register a global drag handler to track the current drag source element
        view(d) {
          const p2 = (h2) => {
            var m;
            r = !((m = d.dom.parentElement) === null || m === void 0) && m.contains(h2.target) ? d.dom.parentElement : null, r && (vs = e);
          }, f = () => {
            vs && (vs = null);
          };
          return window.addEventListener("dragstart", p2), window.addEventListener("dragend", f), {
            destroy() {
              window.removeEventListener("dragstart", p2), window.removeEventListener("dragend", f);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (d, p2) => {
              if (i = r === d.dom.parentElement, a = p2, !i) {
                const f = vs;
                f && setTimeout(() => {
                  const h2 = f.state.selection;
                  h2 && f.commands.deleteRange({ from: h2.from, to: h2.to });
                }, 10);
              }
              return false;
            },
            paste: (d, p2) => {
              var f;
              const h2 = (f = p2.clipboardData) === null || f === void 0 ? void 0 : f.getData("text/html");
              return s = p2, o = !!(h2 != null && h2.includes("data-pm-slice")), false;
            }
          }
        },
        appendTransaction: (d, p2, f) => {
          const h2 = d[0], m = h2.getMeta("uiEvent") === "paste" && !o, g = h2.getMeta("uiEvent") === "drop" && !i, b = h2.getMeta("applyPasteRules"), w = !!b;
          if (!m && !g && !w)
            return;
          if (w) {
            let { text: T } = b;
            typeof T == "string" ? T = T : T = yu(O.from(T), f.schema);
            const { from: S } = b, z = S + T.length, U = $w(T);
            return l({
              rule: u,
              state: f,
              from: S,
              to: { b: z },
              pasteEvt: U
            });
          }
          const _ = p2.doc.content.findDiffStart(f.doc.content), v = p2.doc.content.findDiffEnd(f.doc.content);
          if (!(!Dw(_) || !v || _ === v.b))
            return l({
              rule: u,
              state: f,
              from: _,
              to: v,
              pasteEvt: s
            });
        }
      }));
    }
    function zw(n3) {
      const e = n3.filter((t, r) => n3.indexOf(t) !== r);
      return Array.from(new Set(e));
    }
    class Do {
      constructor(e, t) {
        this.splittableMarks = [], this.editor = t, this.extensions = Do.resolve(e), this.schema = Nw(this.extensions, t), this.setupExtensions();
      }
      /**
       * Returns a flattened and sorted extension list while
       * also checking for duplicated extensions and warns the user.
       * @param extensions An array of Tiptap extensions
       * @returns An flattened and sorted array of Tiptap extensions
       */
      static resolve(e) {
        const t = Do.sort(Do.flatten(e)), r = zw(t.map((o) => o.name));
        return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((o) => `'${o}'`).join(", ")}]. This can lead to issues.`), t;
      }
      /**
       * Create a flattened array of extensions by traversing the `addExtensions` field.
       * @param extensions An array of Tiptap extensions
       * @returns A flattened array of Tiptap extensions
       */
      static flatten(e) {
        return e.map((t) => {
          const r = {
            name: t.name,
            options: t.options,
            storage: t.storage
          }, o = Z(t, "addExtensions", r);
          return o ? [t, ...this.flatten(o())] : t;
        }).flat(10);
      }
      /**
       * Sort extensions by priority.
       * @param extensions An array of Tiptap extensions
       * @returns A sorted array of Tiptap extensions by priority
       */
      static sort(e) {
        return e.sort((r, o) => {
          const i = Z(r, "priority") || 100, s = Z(o, "priority") || 100;
          return i > s ? -1 : i < s ? 1 : 0;
        });
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((e, t) => {
          const r = {
            name: t.name,
            options: t.options,
            storage: t.storage,
            editor: this.editor,
            type: Bl(t.name, this.schema)
          }, o = Z(t, "addCommands", r);
          return o ? {
            ...e,
            ...o()
          } : e;
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor: e } = this, t = Do.sort([...this.extensions].reverse()), r = [], o = [], i = t.map((s) => {
          const a = {
            name: s.name,
            options: s.options,
            storage: s.storage,
            editor: e,
            type: Bl(s.name, this.schema)
          }, l = [], c2 = Z(s, "addKeyboardShortcuts", a);
          let u = {};
          if (s.type === "mark" && Z(s, "exitable", a) && (u.ArrowRight = () => Cn.handleExit({ editor: e, mark: s })), c2) {
            const m = Object.fromEntries(Object.entries(c2()).map(([g, b]) => [g, () => b({ editor: e })]));
            u = { ...u, ...m };
          }
          const d = iw(u);
          l.push(d);
          const p2 = Z(s, "addInputRules", a);
          fp(s, e.options.enableInputRules) && p2 && r.push(...p2());
          const f = Z(s, "addPasteRules", a);
          fp(s, e.options.enablePasteRules) && f && o.push(...f());
          const h2 = Z(s, "addProseMirrorPlugins", a);
          if (h2) {
            const m = h2();
            l.push(...m);
          }
          return l;
        }).flat();
        return [
          Rw({
            editor: e,
            rules: r
          }),
          ...Fw({
            editor: e,
            rules: o
          }),
          ...i
        ];
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return km(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor: e } = this, { nodeExtensions: t } = tl(this.extensions);
        return Object.fromEntries(t.filter((r) => !!Z(r, "addNodeView")).map((r) => {
          const o = this.attributes.filter((l) => l.type === r.name), i = {
            name: r.name,
            options: r.options,
            storage: r.storage,
            editor: e,
            type: Ct(r.name, this.schema)
          }, s = Z(r, "addNodeView", i);
          if (!s)
            return [];
          const a = (l, c2, u, d, p2) => {
            const f = Sc(l, o);
            return s()({
              // pass-through
              node: l,
              view: c2,
              getPos: u,
              decorations: d,
              innerDecorations: p2,
              // tiptap-specific
              editor: e,
              extension: r,
              HTMLAttributes: f
            });
          };
          return [r.name, a];
        }));
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        this.extensions.forEach((e) => {
          var t;
          this.editor.extensionStorage[e.name] = e.storage;
          const r = {
            name: e.name,
            options: e.options,
            storage: e.storage,
            editor: this.editor,
            type: Bl(e.name, this.schema)
          };
          e.type === "mark" && (!((t = Te(Z(e, "keepOnSplit", r))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name);
          const o = Z(e, "onBeforeCreate", r), i = Z(e, "onCreate", r), s = Z(e, "onUpdate", r), a = Z(e, "onSelectionUpdate", r), l = Z(e, "onTransaction", r), c2 = Z(e, "onFocus", r), u = Z(e, "onBlur", r), d = Z(e, "onDestroy", r);
          o && this.editor.on("beforeCreate", o), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c2 && this.editor.on("focus", c2), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
        });
      }
    }
    class qe {
      constructor(e = {}) {
        this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new qe(e);
      }
      configure(e = {}) {
        const t = this.extend({
          ...this.config,
          addOptions: () => nl(this.options, e)
        });
        return t.name = this.name, t.parent = this.parent, t;
      }
      extend(e = {}) {
        const t = new qe({ ...this.config, ...e });
        return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Te(Z(t, "addOptions", {
          name: t.name
        })), t.storage = Te(Z(t, "addStorage", {
          name: t.name,
          options: t.options
        })), t;
      }
    }
    function _m(n3, e, t) {
      const { from: r, to: o } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = t || {};
      let a = "";
      return n3.nodesBetween(r, o, (l, c2, u, d) => {
        var p2;
        l.isBlock && c2 > r && (a += i);
        const f = s == null ? void 0 : s[l.type.name];
        if (f)
          return u && (a += f({
            node: l,
            pos: c2,
            parent: u,
            index: d,
            range: e
          })), false;
        l.isText && (a += (p2 = l == null ? void 0 : l.text) === null || p2 === void 0 ? void 0 : p2.slice(Math.max(r, c2) - c2, o - c2));
      }), a;
    }
    function wu(n3) {
      return Object.fromEntries(Object.entries(n3.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
    }
    const Hw = qe.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor: n3 } = this, { state: e, schema: t } = n3, { doc: r, selection: o } = e, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = wu(t);
                return _m(r, { from: s, to: a }, {
                  ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                  textSerializers: l
                });
              }
            }
          })
        ];
      }
    }), Uw = () => ({ editor: n3, view: e }) => (requestAnimationFrame(() => {
      var t;
      n3.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges());
    }), true), Vw = (n3 = false) => ({ commands: e }) => e.setContent("", n3), Ww = () => ({ state: n3, tr: e, dispatch: t }) => {
      const { selection: r } = e, { ranges: o } = r;
      return t && o.forEach(({ $from: i, $to: s }) => {
        n3.doc.nodesBetween(i.pos, s.pos, (a, l) => {
          if (a.type.isText)
            return;
          const { doc: c2, mapping: u } = e, d = c2.resolve(u.map(l)), p2 = c2.resolve(u.map(l + a.nodeSize)), f = d.blockRange(p2);
          if (!f)
            return;
          const h2 = Xo(f);
          if (a.type.isTextblock) {
            const { defaultType: m } = d.parent.contentMatchAt(d.index());
            e.setNodeMarkup(f.start, m);
          }
          (h2 || h2 === 0) && e.lift(f, h2);
        });
      }), true;
    }, qw = (n3) => (e) => n3(e), Kw = () => ({ state: n3, dispatch: e }) => bm(n3, e), Gw = (n3, e) => ({ editor: t, tr: r }) => {
      const { state: o } = t, i = o.doc.slice(n3.from, n3.to);
      r.deleteRange(n3.from, n3.to);
      const s = r.mapping.map(e);
      return r.insert(s, i.content), r.setSelection(new ie(r.doc.resolve(s - 1))), true;
    }, jw = () => ({ tr: n3, dispatch: e }) => {
      const { selection: t } = n3, r = t.$anchor.node();
      if (r.content.size > 0)
        return false;
      const o = n3.selection.$anchor;
      for (let i = o.depth; i > 0; i -= 1)
        if (o.node(i).type === r.type) {
          if (e) {
            const a = o.before(i), l = o.after(i);
            n3.delete(a, l).scrollIntoView();
          }
          return true;
        }
      return false;
    }, Jw = (n3) => ({ tr: e, state: t, dispatch: r }) => {
      const o = Ct(n3, t.schema), i = e.selection.$anchor;
      for (let s = i.depth; s > 0; s -= 1)
        if (i.node(s).type === o) {
          if (r) {
            const l = i.before(s), c2 = i.after(s);
            e.delete(l, c2).scrollIntoView();
          }
          return true;
        }
      return false;
    }, Yw = (n3) => ({ tr: e, dispatch: t }) => {
      const { from: r, to: o } = n3;
      return t && e.delete(r, o), true;
    }, Xw = () => ({ state: n3, dispatch: e }) => fu(n3, e), Zw = () => ({ commands: n3 }) => n3.keyboardShortcut("Enter"), Qw = () => ({ state: n3, dispatch: e }) => dw(n3, e);
    function ca(n3, e, t = { strict: true }) {
      const r = Object.keys(e);
      return r.length ? r.every((o) => t.strict ? e[o] === n3[o] : vu(e[o]) ? e[o].test(n3[o]) : e[o] === n3[o]) : true;
    }
    function Sm(n3, e, t = {}) {
      return n3.find((r) => r.type === e && ca(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(t).map((o) => [o, r.attrs[o]])),
        t
      ));
    }
    function hp(n3, e, t = {}) {
      return !!Sm(n3, e, t);
    }
    function Zo(n3, e, t) {
      var r;
      if (!n3 || !e)
        return;
      let o = n3.parent.childAfter(n3.parentOffset);
      if ((!o.node || !o.node.marks.some((u) => u.type === e)) && (o = n3.parent.childBefore(n3.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === e) || (t = t || ((r = o.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !Sm([...o.node.marks], e, t)))
        return;
      let s = o.index, a = n3.start() + o.offset, l = s + 1, c2 = a + o.node.nodeSize;
      for (; s > 0 && hp([...n3.parent.child(s - 1).marks], e, t); )
        s -= 1, a -= n3.parent.child(s).nodeSize;
      for (; l < n3.parent.childCount && hp([...n3.parent.child(l).marks], e, t); )
        c2 += n3.parent.child(l).nodeSize, l += 1;
      return {
        from: a,
        to: c2
      };
    }
    function Wr(n3, e) {
      if (typeof n3 == "string") {
        if (!e.marks[n3])
          throw Error(`There is no mark type named '${n3}'. Maybe you forgot to add the extension?`);
        return e.marks[n3];
      }
      return n3;
    }
    const ek = (n3, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
      const i = Wr(n3, r.schema), { doc: s, selection: a } = t, { $from: l, from: c2, to: u } = a;
      if (o) {
        const d = Zo(l, i, e);
        if (d && d.from <= c2 && d.to >= u) {
          const p2 = ie.create(s, d.from, d.to);
          t.setSelection(p2);
        }
      }
      return true;
    }, tk = (n3) => (e) => {
      const t = typeof n3 == "function" ? n3(e) : n3;
      for (let r = 0; r < t.length; r += 1)
        if (t[r](e))
          return true;
      return false;
    };
    function rl(n3) {
      return n3 instanceof ie;
    }
    function dr(n3 = 0, e = 0, t = 0) {
      return Math.min(Math.max(n3, e), t);
    }
    function Cm(n3, e = null) {
      if (!e)
        return null;
      const t = ue.atStart(n3), r = ue.atEnd(n3);
      if (e === "start" || e === true)
        return t;
      if (e === "end")
        return r;
      const o = t.from, i = r.to;
      return e === "all" ? ie.create(n3, dr(0, o, i), dr(n3.content.size, o, i)) : ie.create(n3, dr(e, o, i), dr(e, o, i));
    }
    function xm() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function ol() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    const nk = (n3 = null, e = {}) => ({ editor: t, view: r, tr: o, dispatch: i }) => {
      e = {
        scrollIntoView: true,
        ...e
      };
      const s = () => {
        (ol() || xm()) && r.dom.focus(), requestAnimationFrame(() => {
          t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
        });
      };
      if (r.hasFocus() && n3 === null || n3 === false)
        return true;
      if (i && n3 === null && !rl(t.state.selection))
        return s(), true;
      const a = Cm(o.doc, n3) || t.state.selection, l = t.state.selection.eq(a);
      return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), true;
    }, rk = (n3, e) => (t) => n3.every((r, o) => e(r, { ...t, index: o })), ok = (n3, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n3, e), Tm = (n3) => {
      const e = n3.childNodes;
      for (let t = e.length - 1; t >= 0; t -= 1) {
        const r = e[t];
        r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n3.removeChild(r) : r.nodeType === 1 && Tm(r);
      }
      return n3;
    };
    function ws(n3) {
      const e = `<body>${n3}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
      return Tm(t);
    }
    function ua(n3, e, t) {
      if (n3 instanceof Dr || n3 instanceof O)
        return n3;
      t = {
        slice: true,
        parseOptions: {},
        ...t
      };
      const r = typeof n3 == "object" && n3 !== null, o = typeof n3 == "string";
      if (r)
        try {
          if (Array.isArray(n3) && n3.length > 0)
            return O.fromArray(n3.map((a) => e.nodeFromJSON(a)));
          const s = e.nodeFromJSON(n3);
          return t.errorOnInvalidContent && s.check(), s;
        } catch (i) {
          if (t.errorOnInvalidContent)
            throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
          return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n3, "Error:", i), ua("", e, t);
        }
      if (o) {
        if (t.errorOnInvalidContent) {
          let s = false, a = "";
          const l = new eh({
            topNode: e.spec.topNode,
            marks: e.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: e.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (c2) => (s = true, a = typeof c2 == "string" ? c2 : c2.outerHTML, null)
                  }
                ]
              }
            })
          });
          if (t.slice ? Lr.fromSchema(l).parseSlice(ws(n3), t.parseOptions) : Lr.fromSchema(l).parse(ws(n3), t.parseOptions), t.errorOnInvalidContent && s)
            throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
        }
        const i = Lr.fromSchema(e);
        return t.slice ? i.parseSlice(ws(n3), t.parseOptions).content : i.parse(ws(n3), t.parseOptions);
      }
      return ua("", e, t);
    }
    function ik(n3, e, t) {
      const r = n3.steps.length - 1;
      if (r < e)
        return;
      const o = n3.steps[r];
      if (!(o instanceof Rt || o instanceof Bt))
        return;
      const i = n3.mapping.maps[r];
      let s = 0;
      i.forEach((a, l, c2, u) => {
        s === 0 && (s = u);
      }), n3.setSelection(ue.near(n3.doc.resolve(s), t));
    }
    const sk = (n3) => !("type" in n3), ak = (n3, e, t) => ({ tr: r, dispatch: o, editor: i }) => {
      var s;
      if (o) {
        t = {
          parseOptions: i.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false,
          ...t
        };
        let a;
        try {
          a = ua(e, i.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...t.parseOptions
            },
            errorOnInvalidContent: (s = t.errorOnInvalidContent) !== null && s !== void 0 ? s : i.options.enableContentCheck
          });
        } catch (h2) {
          return i.emit("contentError", {
            editor: i,
            error: h2,
            disableCollaboration: () => {
              i.storage.collaboration && (i.storage.collaboration.isDisabled = true);
            }
          }), false;
        }
        let { from: l, to: c2 } = typeof n3 == "number" ? { from: n3, to: n3 } : { from: n3.from, to: n3.to }, u = true, d = true;
        if ((sk(a) ? a : [a]).forEach((h2) => {
          h2.check(), u = u ? h2.isText && h2.marks.length === 0 : false, d = d ? h2.isBlock : false;
        }), l === c2 && d) {
          const { parent: h2 } = r.doc.resolve(l);
          h2.isTextblock && !h2.type.spec.code && !h2.childCount && (l -= 1, c2 += 1);
        }
        let f;
        if (u) {
          if (Array.isArray(e))
            f = e.map((h2) => h2.text || "").join("");
          else if (e instanceof O) {
            let h2 = "";
            e.forEach((m) => {
              m.text && (h2 += m.text);
            }), f = h2;
          } else typeof e == "object" && e && e.text ? f = e.text : f = e;
          r.insertText(f, l, c2);
        } else
          f = a, r.replaceWith(l, c2, f);
        t.updateSelection && ik(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: l, text: f }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: f });
      }
      return true;
    }, lk = () => ({ state: n3, dispatch: e }) => lw(n3, e), ck = () => ({ state: n3, dispatch: e }) => cw(n3, e), uk = () => ({ state: n3, dispatch: e }) => um(n3, e), dk = () => ({ state: n3, dispatch: e }) => hm(n3, e), pk = () => ({ state: n3, dispatch: e, tr: t }) => {
      try {
        const r = ja(n3.doc, n3.selection.$from.pos, -1);
        return r == null ? false : (t.join(r, 2), e && e(t), true);
      } catch {
        return false;
      }
    }, fk = () => ({ state: n3, dispatch: e, tr: t }) => {
      try {
        const r = ja(n3.doc, n3.selection.$from.pos, 1);
        return r == null ? false : (t.join(r, 2), e && e(t), true);
      } catch {
        return false;
      }
    }, hk = () => ({ state: n3, dispatch: e }) => sw(n3, e), mk = () => ({ state: n3, dispatch: e }) => aw(n3, e);
    function Om() {
      return typeof navigator < "u" ? /Mac/.test(navigator.platform) : false;
    }
    function gk(n3) {
      const e = n3.split(/-(?!$)/);
      let t = e[e.length - 1];
      t === "Space" && (t = " ");
      let r, o, i, s;
      for (let a = 0; a < e.length - 1; a += 1) {
        const l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          s = true;
        else if (/^a(lt)?$/i.test(l))
          r = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          o = true;
        else if (/^s(hift)?$/i.test(l))
          i = true;
        else if (/^mod$/i.test(l))
          ol() || Om() ? s = true : o = true;
        else
          throw new Error(`Unrecognized modifier name: ${l}`);
      }
      return r && (t = `Alt-${t}`), o && (t = `Ctrl-${t}`), s && (t = `Meta-${t}`), i && (t = `Shift-${t}`), t;
    }
    const bk = (n3) => ({ editor: e, view: t, tr: r, dispatch: o }) => {
      const i = gk(n3).split(/-(?!$)/), s = i.find((c2) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c2)), a = new KeyboardEvent("keydown", {
        key: s === "Space" ? " " : s,
        altKey: i.includes("Alt"),
        ctrlKey: i.includes("Ctrl"),
        metaKey: i.includes("Meta"),
        shiftKey: i.includes("Shift"),
        bubbles: true,
        cancelable: true
      }), l = e.captureTransaction(() => {
        t.someProp("handleKeyDown", (c2) => c2(t, a));
      });
      return l == null || l.steps.forEach((c2) => {
        const u = c2.map(r.mapping);
        u && o && r.maybeStep(u);
      }), true;
    };
    function Fi(n3, e, t = {}) {
      const { from: r, to: o, empty: i } = n3.selection, s = e ? Ct(e, n3.schema) : null, a = [];
      n3.doc.nodesBetween(r, o, (d, p2) => {
        if (d.isText)
          return;
        const f = Math.max(r, p2), h2 = Math.min(o, p2 + d.nodeSize);
        a.push({
          node: d,
          from: f,
          to: h2
        });
      });
      const l = o - r, c2 = a.filter((d) => s ? s.name === d.node.type.name : true).filter((d) => ca(d.node.attrs, t, { strict: false }));
      return i ? !!c2.length : c2.reduce((d, p2) => d + p2.to - p2.from, 0) >= l;
    }
    const yk = (n3, e = {}) => ({ state: t, dispatch: r }) => {
      const o = Ct(n3, t.schema);
      return Fi(t, o, e) ? uw(t, r) : false;
    }, vk = () => ({ state: n3, dispatch: e }) => ym(n3, e), wk = (n3) => ({ state: e, dispatch: t }) => {
      const r = Ct(n3, e.schema);
      return Ew(r)(e, t);
    }, kk = () => ({ state: n3, dispatch: e }) => gm(n3, e);
    function il(n3, e) {
      return e.nodes[n3] ? "node" : e.marks[n3] ? "mark" : null;
    }
    function mp(n3, e) {
      const t = typeof e == "string" ? [e] : e;
      return Object.keys(n3).reduce((r, o) => (t.includes(o) || (r[o] = n3[o]), r), {});
    }
    const Ek = (n3, e) => ({ tr: t, state: r, dispatch: o }) => {
      let i = null, s = null;
      const a = il(typeof n3 == "string" ? n3 : n3.name, r.schema);
      return a ? (a === "node" && (i = Ct(n3, r.schema)), a === "mark" && (s = Wr(n3, r.schema)), o && t.selection.ranges.forEach((l) => {
        r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c2, u) => {
          i && i === c2.type && t.setNodeMarkup(u, void 0, mp(c2.attrs, e)), s && c2.marks.length && c2.marks.forEach((d) => {
            s === d.type && t.addMark(u, u + c2.nodeSize, s.create(mp(d.attrs, e)));
          });
        });
      }), true) : false;
    }, _k = () => ({ tr: n3, dispatch: e }) => (e && n3.scrollIntoView(), true), Sk = () => ({ tr: n3, dispatch: e }) => {
      if (e) {
        const t = new hn(n3.doc);
        n3.setSelection(t);
      }
      return true;
    }, Ck = () => ({ state: n3, dispatch: e }) => pm(n3, e), xk = () => ({ state: n3, dispatch: e }) => mm(n3, e), Tk = () => ({ state: n3, dispatch: e }) => hw(n3, e), Ok = () => ({ state: n3, dispatch: e }) => bw(n3, e), Nk = () => ({ state: n3, dispatch: e }) => gw(n3, e);
    function Cc(n3, e, t = {}, r = {}) {
      return ua(n3, e, {
        slice: false,
        parseOptions: t,
        errorOnInvalidContent: r.errorOnInvalidContent
      });
    }
    const Mk = (n3, e = false, t = {}, r = {}) => ({ editor: o, tr: i, dispatch: s, commands: a }) => {
      var l, c2;
      const { doc: u } = i;
      if (t.preserveWhitespace !== "full") {
        const d = Cc(n3, o.schema, t, {
          errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : o.options.enableContentCheck
        });
        return s && i.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), true;
      }
      return s && i.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, n3, {
        parseOptions: t,
        errorOnInvalidContent: (c2 = r.errorOnInvalidContent) !== null && c2 !== void 0 ? c2 : o.options.enableContentCheck
      });
    };
    function Nm(n3, e) {
      const t = Wr(e, n3.schema), { from: r, to: o, empty: i } = n3.selection, s = [];
      i ? (n3.storedMarks && s.push(...n3.storedMarks), s.push(...n3.selection.$head.marks())) : n3.doc.nodesBetween(r, o, (l) => {
        s.push(...l.marks);
      });
      const a = s.find((l) => l.type.name === t.name);
      return a ? { ...a.attrs } : {};
    }
    function Ak(n3, e) {
      const t = new Nh(n3);
      return e.forEach((r) => {
        r.steps.forEach((o) => {
          t.step(o);
        });
      }), t;
    }
    function Rk(n3) {
      for (let e = 0; e < n3.edgeCount; e += 1) {
        const { type: t } = n3.edge(e);
        if (t.isTextblock && !t.hasRequiredAttrs())
          return t;
      }
      return null;
    }
    function xc(n3, e) {
      const t = [];
      return n3.descendants((r, o) => {
        e(r) && t.push({
          node: r,
          pos: o
        });
      }), t;
    }
    function Ik(n3, e, t) {
      const r = [];
      return n3.nodesBetween(e.from, e.to, (o, i) => {
        t(o) && r.push({
          node: o,
          pos: i
        });
      }), r;
    }
    function Mm(n3, e) {
      for (let t = n3.depth; t > 0; t -= 1) {
        const r = n3.node(t);
        if (e(r))
          return {
            pos: t > 0 ? n3.before(t) : 0,
            start: n3.start(t),
            depth: t,
            node: r
          };
      }
    }
    function ku(n3) {
      return (e) => Mm(e.$from, n3);
    }
    function Am(n3, e) {
      const t = {
        from: 0,
        to: n3.content.size
      };
      return _m(n3, t, e);
    }
    function Dk(n3, e) {
      const t = Ct(e, n3.schema), { from: r, to: o } = n3.selection, i = [];
      n3.doc.nodesBetween(r, o, (a) => {
        i.push(a);
      });
      const s = i.reverse().find((a) => a.type.name === t.name);
      return s ? { ...s.attrs } : {};
    }
    function Rm(n3, e) {
      const t = il(typeof e == "string" ? e : e.name, n3.schema);
      return t === "node" ? Dk(n3, e) : t === "mark" ? Nm(n3, e) : {};
    }
    function Lk(n3, e = JSON.stringify) {
      const t = {};
      return n3.filter((r) => {
        const o = e(r);
        return Object.prototype.hasOwnProperty.call(t, o) ? false : t[o] = true;
      });
    }
    function Bk(n3) {
      const e = Lk(n3);
      return e.length === 1 ? e : e.filter((t, r) => !e.filter((i, s) => s !== r).some((i) => t.oldRange.from >= i.oldRange.from && t.oldRange.to <= i.oldRange.to && t.newRange.from >= i.newRange.from && t.newRange.to <= i.newRange.to));
    }
    function Pk(n3) {
      const { mapping: e, steps: t } = n3, r = [];
      return e.maps.forEach((o, i) => {
        const s = [];
        if (o.ranges.length)
          o.forEach((a, l) => {
            s.push({ from: a, to: l });
          });
        else {
          const { from: a, to: l } = t[i];
          if (a === void 0 || l === void 0)
            return;
          s.push({ from: a, to: l });
        }
        s.forEach(({ from: a, to: l }) => {
          const c2 = e.slice(i).map(a, -1), u = e.slice(i).map(l), d = e.invert().map(c2, -1), p2 = e.invert().map(u);
          r.push({
            oldRange: {
              from: d,
              to: p2
            },
            newRange: {
              from: c2,
              to: u
            }
          });
        });
      }), Bk(r);
    }
    function Eu(n3, e, t) {
      const r = [];
      return n3 === e ? t.resolve(n3).marks().forEach((o) => {
        const i = t.resolve(n3), s = Zo(i, o.type);
        s && r.push({
          mark: o,
          ...s
        });
      }) : t.nodesBetween(n3, e, (o, i) => {
        !o || (o == null ? void 0 : o.nodeSize) === void 0 || r.push(...o.marks.map((s) => ({
          from: i,
          to: i + o.nodeSize,
          mark: s
        })));
      }), r;
    }
    function Ks(n3, e, t) {
      return Object.fromEntries(Object.entries(t).filter(([r]) => {
        const o = n3.find((i) => i.type === e && i.name === r);
        return o ? o.attribute.keepOnSplit : false;
      }));
    }
    function Tc(n3, e, t = {}) {
      const { empty: r, ranges: o } = n3.selection, i = e ? Wr(e, n3.schema) : null;
      if (r)
        return !!(n3.storedMarks || n3.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : true).find((d) => ca(d.attrs, t, { strict: false }));
      let s = 0;
      const a = [];
      if (o.forEach(({ $from: d, $to: p2 }) => {
        const f = d.pos, h2 = p2.pos;
        n3.doc.nodesBetween(f, h2, (m, g) => {
          if (!m.isText && !m.marks.length)
            return;
          const b = Math.max(f, g), w = Math.min(h2, g + m.nodeSize), _ = w - b;
          s += _, a.push(...m.marks.map((v) => ({
            mark: v,
            from: b,
            to: w
          })));
        });
      }), s === 0)
        return false;
      const l = a.filter((d) => i ? i.name === d.mark.type.name : true).filter((d) => ca(d.mark.attrs, t, { strict: false })).reduce((d, p2) => d + p2.to - p2.from, 0), c2 = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : true).reduce((d, p2) => d + p2.to - p2.from, 0);
      return (l > 0 ? l + c2 : l) >= s;
    }
    function $k(n3, e, t = {}) {
      if (!e)
        return Fi(n3, null, t) || Tc(n3, null, t);
      const r = il(e, n3.schema);
      return r === "node" ? Fi(n3, e, t) : r === "mark" ? Tc(n3, e, t) : false;
    }
    function gp(n3, e) {
      const { nodeExtensions: t } = tl(e), r = t.find((s) => s.name === n3);
      if (!r)
        return false;
      const o = {
        name: r.name,
        options: r.options,
        storage: r.storage
      }, i = Te(Z(r, "group", o));
      return typeof i != "string" ? false : i.split(" ").includes("list");
    }
    function _u(n3, { checkChildren: e = true, ignoreWhitespace: t = false } = {}) {
      var r;
      if (t) {
        if (n3.type.name === "hardBreak")
          return true;
        if (n3.isText)
          return /^\s*$/m.test((r = n3.text) !== null && r !== void 0 ? r : "");
      }
      if (n3.isText)
        return !n3.text;
      if (n3.isAtom || n3.isLeaf)
        return false;
      if (n3.content.childCount === 0)
        return true;
      if (e) {
        let o = true;
        return n3.content.forEach((i) => {
          o !== false && (_u(i, { ignoreWhitespace: t, checkChildren: e }) || (o = false));
        }), o;
      }
      return false;
    }
    function Im(n3) {
      return n3 instanceof ne;
    }
    function Dm(n3, e, t) {
      const o = n3.state.doc.content.size, i = dr(e, 0, o), s = dr(t, 0, o), a = n3.coordsAtPos(i), l = n3.coordsAtPos(s, -1), c2 = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), p2 = Math.max(a.right, l.right), f = p2 - d, h2 = u - c2, b = {
        top: c2,
        bottom: u,
        left: d,
        right: p2,
        width: f,
        height: h2,
        x: d,
        y: c2
      };
      return {
        ...b,
        toJSON: () => b
      };
    }
    function Fk(n3, e, t) {
      var r;
      const { selection: o } = e;
      let i = null;
      if (rl(o) && (i = o.$cursor), i) {
        const a = (r = n3.storedMarks) !== null && r !== void 0 ? r : i.marks();
        return !!t.isInSet(a) || !a.some((l) => l.type.excludes(t));
      }
      const { ranges: s } = o;
      return s.some(({ $from: a, $to: l }) => {
        let c2 = a.depth === 0 ? n3.doc.inlineContent && n3.doc.type.allowsMarkType(t) : false;
        return n3.doc.nodesBetween(a.pos, l.pos, (u, d, p2) => {
          if (c2)
            return false;
          if (u.isInline) {
            const f = !p2 || p2.type.allowsMarkType(t), h2 = !!t.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(t));
            c2 = f && h2;
          }
          return !c2;
        }), c2;
      });
    }
    const zk = (n3, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
      const { selection: i } = t, { empty: s, ranges: a } = i, l = Wr(n3, r.schema);
      if (o)
        if (s) {
          const c2 = Nm(r, l);
          t.addStoredMark(l.create({
            ...c2,
            ...e
          }));
        } else
          a.forEach((c2) => {
            const u = c2.$from.pos, d = c2.$to.pos;
            r.doc.nodesBetween(u, d, (p2, f) => {
              const h2 = Math.max(f, u), m = Math.min(f + p2.nodeSize, d);
              p2.marks.find((b) => b.type === l) ? p2.marks.forEach((b) => {
                l === b.type && t.addMark(h2, m, l.create({
                  ...b.attrs,
                  ...e
                }));
              }) : t.addMark(h2, m, l.create(e));
            });
          });
      return Fk(r, t, l);
    }, Hk = (n3, e) => ({ tr: t }) => (t.setMeta(n3, e), true), Uk = (n3, e = {}) => ({ state: t, dispatch: r, chain: o }) => {
      const i = Ct(n3, t.schema);
      let s;
      return t.selection.$anchor.sameParent(t.selection.$head) && (s = t.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: a }) => up(i, { ...s, ...e })(t) ? true : a.clearNodes()).command(({ state: a }) => up(i, { ...s, ...e })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), false);
    }, Vk = (n3) => ({ tr: e, dispatch: t }) => {
      if (t) {
        const { doc: r } = e, o = dr(n3, 0, r.content.size), i = ne.create(r, o);
        e.setSelection(i);
      }
      return true;
    }, Wk = (n3) => ({ tr: e, dispatch: t }) => {
      if (t) {
        const { doc: r } = e, { from: o, to: i } = typeof n3 == "number" ? { from: n3, to: n3 } : n3, s = ie.atStart(r).from, a = ie.atEnd(r).to, l = dr(o, s, a), c2 = dr(i, s, a), u = ie.create(r, l, c2);
        e.setSelection(u);
      }
      return true;
    }, qk = (n3) => ({ state: e, dispatch: t }) => {
      const r = Ct(n3, e.schema);
      return Cw(r)(e, t);
    };
    function bp(n3, e) {
      const t = n3.storedMarks || n3.selection.$to.parentOffset && n3.selection.$from.marks();
      if (t) {
        const r = t.filter((o) => e == null ? void 0 : e.includes(o.type.name));
        n3.tr.ensureMarks(r);
      }
    }
    const Kk = ({ keepMarks: n3 = true } = {}) => ({ tr: e, state: t, dispatch: r, editor: o }) => {
      const { selection: i, doc: s } = e, { $from: a, $to: l } = i, c2 = o.extensionManager.attributes, u = Ks(c2, a.node().type.name, a.node().attrs);
      if (i instanceof ne && i.node.isBlock)
        return !a.parentOffset || !pr(s, a.pos) ? false : (r && (n3 && bp(t, o.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), true);
      if (!a.parent.isBlock)
        return false;
      const d = l.parentOffset === l.parent.content.size, p2 = a.depth === 0 ? void 0 : Rk(a.node(-1).contentMatchAt(a.indexAfter(-1)));
      let f = d && p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0, h2 = pr(e.doc, e.mapping.map(a.pos), 1, f);
      if (!f && !h2 && pr(e.doc, e.mapping.map(a.pos), 1, p2 ? [{ type: p2 }] : void 0) && (h2 = true, f = p2 ? [
        {
          type: p2,
          attrs: u
        }
      ] : void 0), r) {
        if (h2 && (i instanceof ie && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, f), p2 && !d && !a.parentOffset && a.parent.type !== p2)) {
          const m = e.mapping.map(a.before()), g = e.doc.resolve(m);
          a.node(-1).canReplaceWith(g.index(), g.index() + 1, p2) && e.setNodeMarkup(e.mapping.map(a.before()), p2);
        }
        n3 && bp(t, o.extensionManager.splittableMarks), e.scrollIntoView();
      }
      return h2;
    }, Gk = (n3, e = {}) => ({ tr: t, state: r, dispatch: o, editor: i }) => {
      var s;
      const a = Ct(n3, r.schema), { $from: l, $to: c2 } = r.selection, u = r.selection.node;
      if (u && u.isBlock || l.depth < 2 || !l.sameParent(c2))
        return false;
      const d = l.node(-1);
      if (d.type !== a)
        return false;
      const p2 = i.extensionManager.attributes;
      if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
        if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
          return false;
        if (o) {
          let b = O.empty;
          const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
          for (let U = l.depth - w; U >= l.depth - 3; U -= 1)
            b = O.from(l.node(U).copy(b));
          const _ = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
            ...Ks(p2, l.node().type.name, l.node().attrs),
            ...e
          }, T = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(v)) || void 0;
          b = b.append(O.from(a.createAndFill(null, T) || void 0));
          const S = l.before(l.depth - (w - 1));
          t.replace(S, l.after(-_), new I(b, 4 - w, 0));
          let z = -1;
          t.doc.nodesBetween(S, t.doc.content.size, (U, B) => {
            if (z > -1)
              return false;
            U.isTextblock && U.content.size === 0 && (z = B + 1);
          }), z > -1 && t.setSelection(ie.near(t.doc.resolve(z))), t.scrollIntoView();
        }
        return true;
      }
      const f = c2.pos === l.end() ? d.contentMatchAt(0).defaultType : null, h2 = {
        ...Ks(p2, d.type.name, d.attrs),
        ...e
      }, m = {
        ...Ks(p2, l.node().type.name, l.node().attrs),
        ...e
      };
      t.delete(l.pos, c2.pos);
      const g = f ? [
        { type: a, attrs: h2 },
        { type: f, attrs: m }
      ] : [{ type: a, attrs: h2 }];
      if (!pr(t.doc, l.pos, 2))
        return false;
      if (o) {
        const { selection: b, storedMarks: w } = r, { splittableMarks: _ } = i.extensionManager, v = w || b.$to.parentOffset && b.$from.marks();
        if (t.split(l.pos, 2, g).scrollIntoView(), !v || !o)
          return true;
        const T = v.filter((S) => _.includes(S.type.name));
        t.ensureMarks(T);
      }
      return true;
    }, Pl = (n3, e) => {
      const t = ku((s) => s.type === e)(n3.selection);
      if (!t)
        return true;
      const r = n3.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
      if (r === void 0)
        return true;
      const o = n3.doc.nodeAt(r);
      return t.node.type === (o == null ? void 0 : o.type) && Ur(n3.doc, t.pos) && n3.join(t.pos), true;
    }, $l = (n3, e) => {
      const t = ku((s) => s.type === e)(n3.selection);
      if (!t)
        return true;
      const r = n3.doc.resolve(t.start).after(t.depth);
      if (r === void 0)
        return true;
      const o = n3.doc.nodeAt(r);
      return t.node.type === (o == null ? void 0 : o.type) && Ur(n3.doc, r) && n3.join(r), true;
    }, jk = (n3, e, t, r = {}) => ({ editor: o, tr: i, state: s, dispatch: a, chain: l, commands: c2, can: u }) => {
      const { extensions: d, splittableMarks: p2 } = o.extensionManager, f = Ct(n3, s.schema), h2 = Ct(e, s.schema), { selection: m, storedMarks: g } = s, { $from: b, $to: w } = m, _ = b.blockRange(w), v = g || m.$to.parentOffset && m.$from.marks();
      if (!_)
        return false;
      const T = ku((S) => gp(S.type.name, d))(m);
      if (_.depth >= 1 && T && _.depth - T.depth <= 1) {
        if (T.node.type === f)
          return c2.liftListItem(h2);
        if (gp(T.node.type.name, d) && f.validContent(T.node.content) && a)
          return l().command(() => (i.setNodeMarkup(T.pos, f), true)).command(() => Pl(i, f)).command(() => $l(i, f)).run();
      }
      return !t || !v || !a ? l().command(() => u().wrapInList(f, r) ? true : c2.clearNodes()).wrapInList(f, r).command(() => Pl(i, f)).command(() => $l(i, f)).run() : l().command(() => {
        const S = u().wrapInList(f, r), z = v.filter((U) => p2.includes(U.type.name));
        return i.ensureMarks(z), S ? true : c2.clearNodes();
      }).wrapInList(f, r).command(() => Pl(i, f)).command(() => $l(i, f)).run();
    }, Jk = (n3, e = {}, t = {}) => ({ state: r, commands: o }) => {
      const { extendEmptyMarkRange: i = false } = t, s = Wr(n3, r.schema);
      return Tc(r, s, e) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, e);
    }, Yk = (n3, e, t = {}) => ({ state: r, commands: o }) => {
      const i = Ct(n3, r.schema), s = Ct(e, r.schema), a = Fi(r, i, t);
      let l;
      return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? o.setNode(s, l) : o.setNode(i, { ...l, ...t });
    }, Xk = (n3, e = {}) => ({ state: t, commands: r }) => {
      const o = Ct(n3, t.schema);
      return Fi(t, o, e) ? r.lift(o) : r.wrapIn(o, e);
    }, Zk = () => ({ state: n3, dispatch: e }) => {
      const t = n3.plugins;
      for (let r = 0; r < t.length; r += 1) {
        const o = t[r];
        let i;
        if (o.spec.isInputRules && (i = o.getState(n3))) {
          if (e) {
            const s = n3.tr, a = i.transform;
            for (let l = a.steps.length - 1; l >= 0; l -= 1)
              s.step(a.steps[l].invert(a.docs[l]));
            if (i.text) {
              const l = s.doc.resolve(i.from).marks();
              s.replaceWith(i.from, i.to, n3.schema.text(i.text, l));
            } else
              s.delete(i.from, i.to);
          }
          return true;
        }
      }
      return false;
    }, Qk = () => ({ tr: n3, dispatch: e }) => {
      const { selection: t } = n3, { empty: r, ranges: o } = t;
      return r || e && o.forEach((i) => {
        n3.removeMark(i.$from.pos, i.$to.pos);
      }), true;
    }, eE = (n3, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
      var i;
      const { extendEmptyMarkRange: s = false } = e, { selection: a } = t, l = Wr(n3, r.schema), { $from: c2, empty: u, ranges: d } = a;
      if (!o)
        return true;
      if (u && s) {
        let { from: p2, to: f } = a;
        const h2 = (i = c2.marks().find((g) => g.type === l)) === null || i === void 0 ? void 0 : i.attrs, m = Zo(c2, l, h2);
        m && (p2 = m.from, f = m.to), t.removeMark(p2, f, l);
      } else
        d.forEach((p2) => {
          t.removeMark(p2.$from.pos, p2.$to.pos, l);
        });
      return t.removeStoredMark(l), true;
    }, tE = (n3, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
      let i = null, s = null;
      const a = il(typeof n3 == "string" ? n3 : n3.name, r.schema);
      return a ? (a === "node" && (i = Ct(n3, r.schema)), a === "mark" && (s = Wr(n3, r.schema)), o && t.selection.ranges.forEach((l) => {
        const c2 = l.$from.pos, u = l.$to.pos;
        let d, p2, f, h2;
        t.selection.empty ? r.doc.nodesBetween(c2, u, (m, g) => {
          i && i === m.type && (f = Math.max(g, c2), h2 = Math.min(g + m.nodeSize, u), d = g, p2 = m);
        }) : r.doc.nodesBetween(c2, u, (m, g) => {
          g < c2 && i && i === m.type && (f = Math.max(g, c2), h2 = Math.min(g + m.nodeSize, u), d = g, p2 = m), g >= c2 && g <= u && (i && i === m.type && t.setNodeMarkup(g, void 0, {
            ...m.attrs,
            ...e
          }), s && m.marks.length && m.marks.forEach((b) => {
            if (s === b.type) {
              const w = Math.max(g, c2), _ = Math.min(g + m.nodeSize, u);
              t.addMark(w, _, s.create({
                ...b.attrs,
                ...e
              }));
            }
          }));
        }), p2 && (d !== void 0 && t.setNodeMarkup(d, void 0, {
          ...p2.attrs,
          ...e
        }), s && p2.marks.length && p2.marks.forEach((m) => {
          s === m.type && t.addMark(f, h2, s.create({
            ...m.attrs,
            ...e
          }));
        }));
      }), true) : false;
    }, nE = (n3, e = {}) => ({ state: t, dispatch: r }) => {
      const o = Ct(n3, t.schema);
      return yw(o, e)(t, r);
    }, rE = (n3, e = {}) => ({ state: t, dispatch: r }) => {
      const o = Ct(n3, t.schema);
      return vw(o, e)(t, r);
    };
    var oE = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur: Uw,
      clearContent: Vw,
      clearNodes: Ww,
      command: qw,
      createParagraphNear: Kw,
      cut: Gw,
      deleteCurrentNode: jw,
      deleteNode: Jw,
      deleteRange: Yw,
      deleteSelection: Xw,
      enter: Zw,
      exitCode: Qw,
      extendMarkRange: ek,
      first: tk,
      focus: nk,
      forEach: rk,
      insertContent: ok,
      insertContentAt: ak,
      joinBackward: uk,
      joinDown: ck,
      joinForward: dk,
      joinItemBackward: pk,
      joinItemForward: fk,
      joinTextblockBackward: hk,
      joinTextblockForward: mk,
      joinUp: lk,
      keyboardShortcut: bk,
      lift: yk,
      liftEmptyBlock: vk,
      liftListItem: wk,
      newlineInCode: kk,
      resetAttributes: Ek,
      scrollIntoView: _k,
      selectAll: Sk,
      selectNodeBackward: Ck,
      selectNodeForward: xk,
      selectParentNode: Tk,
      selectTextblockEnd: Ok,
      selectTextblockStart: Nk,
      setContent: Mk,
      setMark: zk,
      setMeta: Hk,
      setNode: Uk,
      setNodeSelection: Vk,
      setTextSelection: Wk,
      sinkListItem: qk,
      splitBlock: Kk,
      splitListItem: Gk,
      toggleList: jk,
      toggleMark: Jk,
      toggleNode: Yk,
      toggleWrap: Xk,
      undoInputRule: Zk,
      unsetAllMarks: Qk,
      unsetMark: eE,
      updateAttributes: tE,
      wrapIn: nE,
      wrapInList: rE
    });
    const iE = qe.create({
      name: "commands",
      addCommands() {
        return {
          ...oE
        };
      }
    }), sE = qe.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("tiptapDrop"),
            props: {
              handleDrop: (n3, e, t, r) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice: t,
                  moved: r
                });
              }
            }
          })
        ];
      }
    }), aE = qe.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    }), lE = qe.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor: n3 } = this;
        return [
          new Ue({
            key: new Ze("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (e, t) => {
                  n3.isFocused = true;
                  const r = n3.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", false);
                  return e.dispatch(r), false;
                },
                blur: (e, t) => {
                  n3.isFocused = false;
                  const r = n3.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", false);
                  return e.dispatch(r), false;
                }
              }
            }
          })
        ];
      }
    }), cE = qe.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const n3 = () => this.editor.commands.first(({ commands: s }) => [
          () => s.undoInputRule(),
          // maybe convert first text block node to default node
          () => s.command(({ tr: a }) => {
            const { selection: l, doc: c2 } = a, { empty: u, $anchor: d } = l, { pos: p2, parent: f } = d, h2 = d.parent.isTextblock && p2 > 0 ? a.doc.resolve(p2 - 1) : d, m = h2.parent.type.spec.isolating, g = d.pos - d.parentOffset, b = m && h2.parent.childCount === 1 ? g === d.pos : ue.atStart(c2).from === p2;
            return !u || !f.type.isTextblock || f.textContent.length || !b || b && d.parent.type.name === "paragraph" ? false : s.clearNodes();
          }),
          () => s.deleteSelection(),
          () => s.joinBackward(),
          () => s.selectNodeBackward()
        ]), e = () => this.editor.commands.first(({ commands: s }) => [
          () => s.deleteSelection(),
          () => s.deleteCurrentNode(),
          () => s.joinForward(),
          () => s.selectNodeForward()
        ]), r = {
          Enter: () => this.editor.commands.first(({ commands: s }) => [
            () => s.newlineInCode(),
            () => s.createParagraphNear(),
            () => s.liftEmptyBlock(),
            () => s.splitBlock()
          ]),
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: n3,
          "Mod-Backspace": n3,
          "Shift-Backspace": n3,
          Delete: e,
          "Mod-Delete": e,
          "Mod-a": () => this.editor.commands.selectAll()
        }, o = {
          ...r
        }, i = {
          ...r,
          "Ctrl-h": n3,
          "Alt-Backspace": n3,
          "Ctrl-d": e,
          "Ctrl-Alt-Backspace": e,
          "Alt-Delete": e,
          "Alt-d": e,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return ol() || Om() ? i : o;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
          // with many other commands.
          new Ue({
            key: new Ze("clearDocument"),
            appendTransaction: (n3, e, t) => {
              if (n3.some((m) => m.getMeta("composition")))
                return;
              const r = n3.some((m) => m.docChanged) && !e.doc.eq(t.doc), o = n3.some((m) => m.getMeta("preventClearDocument"));
              if (!r || o)
                return;
              const { empty: i, from: s, to: a } = e.selection, l = ue.atStart(e.doc).from, c2 = ue.atEnd(e.doc).to;
              if (i || !(s === l && a === c2) || !_u(t.doc))
                return;
              const p2 = t.tr, f = Qa({
                state: t,
                transaction: p2
              }), { commands: h2 } = new el({
                editor: this.editor,
                state: f
              });
              if (h2.clearNodes(), !!p2.steps.length)
                return p2;
            }
          })
        ];
      }
    }), uE = qe.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("tiptapPaste"),
            props: {
              handlePaste: (n3, e, t) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice: t
                });
              }
            }
          })
        ];
      }
    }), dE = qe.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    class Xr {
      get name() {
        return this.node.type.name;
      }
      constructor(e, t, r = false, o = null) {
        this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = o;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var e;
        return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(e) {
        let t = this.from, r = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          t = this.from + 1, r = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from: t, to: r }, e);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0)
          return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
        return new Xr(t, this.editor);
      }
      get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Xr(e, this.editor);
      }
      get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Xr(e, this.editor);
      }
      get children() {
        const e = [];
        return this.node.content.forEach((t, r) => {
          const o = t.isBlock && !t.isTextblock, i = t.isAtom && !t.isText, s = this.pos + r + (i ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
          if (!o && a.depth <= this.depth)
            return;
          const l = new Xr(a, this.editor, o, o ? t : null);
          o && (l.actualDepth = this.depth + 1), e.push(new Xr(a, this.editor, o, o ? t : null));
        }), e;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null;
      }
      closest(e, t = {}) {
        let r = null, o = this.parent;
        for (; o && !r; ) {
          if (o.node.type.name === e)
            if (Object.keys(t).length > 0) {
              const i = o.node.attrs, s = Object.keys(t);
              for (let a = 0; a < s.length; a += 1) {
                const l = s[a];
                if (i[l] !== t[l])
                  break;
              }
            } else
              r = o;
          o = o.parent;
        }
        return r;
      }
      querySelector(e, t = {}) {
        return this.querySelectorAll(e, t, true)[0] || null;
      }
      querySelectorAll(e, t = {}, r = false) {
        let o = [];
        if (!this.children || this.children.length === 0)
          return o;
        const i = Object.keys(t);
        return this.children.forEach((s) => {
          r && o.length > 0 || (s.node.type.name === e && i.every((l) => t[l] === s.node.attrs[l]) && o.push(s), !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(e, t, r))));
        }), o;
      }
      setAttribute(e) {
        const { tr: t } = this.editor.state;
        t.setNodeMarkup(this.from, void 0, {
          ...this.node.attrs,
          ...e
        }), this.editor.view.dispatch(t);
      }
    }
    const pE = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    function fE(n3, e, t) {
      const r = document.querySelector("style[data-tiptap-style]");
      if (r !== null)
        return r;
      const o = document.createElement("style");
      return e && o.setAttribute("nonce", e), o.setAttribute("data-tiptap-style", ""), o.innerHTML = n3, document.getElementsByTagName("head")[0].appendChild(o), o;
    }
    let Qn = class extends xw {
      constructor(e = {}) {
        super(), this.isFocused = false, this.isInitialized = false, this.extensionStorage = {}, this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error: t }) => {
            throw t;
          },
          onPaste: () => null,
          onDrop: () => null
        }, this.isCapturingTransaction = false, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: r, moved: o }) => this.options.onDrop(t, r, o)), this.on("paste", ({ event: t, slice: r }) => this.options.onPaste(t, r)), window.setTimeout(() => {
          this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = true);
        }, 0);
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        this.options.injectCSS && document && (this.css = fE(pE, this.options.injectNonce));
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(e = {}) {
        this.options = {
          ...this.options,
          ...e
        }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(e, t = true) {
        this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr });
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
        return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(e, t) {
        const r = Em(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], o = this.state.reconfigure({ plugins: r });
        return this.view.updateState(o), o;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(e) {
        if (this.isDestroyed)
          return;
        const t = this.state.plugins;
        let r = t;
        if ([].concat(e).forEach((i) => {
          const s = typeof i == "string" ? `${i}$` : i.key;
          r = t.filter((a) => !a.key.startsWith(s));
        }), t.length === r.length)
          return;
        const o = this.state.reconfigure({
          plugins: r
        });
        return this.view.updateState(o), o;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var e, t;
        const o = [...this.options.enableCoreExtensions ? [
          aE,
          Hw.configure({
            blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator
          }),
          iE,
          lE,
          cE,
          dE,
          sE,
          uE
        ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== false : true) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i == null ? void 0 : i.type));
        this.extensionManager = new Do(o, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new el({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
        var e;
        let t;
        try {
          t = Cc(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
        } catch (s) {
          if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
            throw s;
          this.emit("contentError", {
            editor: this,
            error: s,
            disableCollaboration: () => {
              this.storage.collaboration && (this.storage.collaboration.isDisabled = true), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
            }
          }), t = Cc(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
        }
        const r = Cm(t, this.options.autofocus);
        this.view = new Y0(this.options.element, {
          ...this.options.editorProps,
          attributes: {
            // add `role="textbox"` to the editor element
            role: "textbox",
            ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
          },
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: Io.create({
            doc: t,
            selection: r || void 0
          })
        });
        const o = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(o), this.createNodeViews(), this.prependClass();
        const i = this.view.dom;
        i.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
        this.view.isDestroyed || this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
      }
      captureTransaction(e) {
        this.isCapturingTransaction = true, e(), this.isCapturingTransaction = false;
        const t = this.capturedTransaction;
        return this.capturedTransaction = null, t;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(e) {
        if (this.view.isDestroyed)
          return;
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = e;
            return;
          }
          e.steps.forEach((s) => {
            var a;
            return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
          });
          return;
        }
        const t = this.state.apply(e), r = !this.state.selection.eq(t.selection);
        this.emit("beforeTransaction", {
          editor: this,
          transaction: e,
          nextState: t
        }), this.view.updateState(t), this.emit("transaction", {
          editor: this,
          transaction: e
        }), r && this.emit("selectionUpdate", {
          editor: this,
          transaction: e
        });
        const o = e.getMeta("focus"), i = e.getMeta("blur");
        o && this.emit("focus", {
          editor: this,
          event: o.event,
          transaction: e
        }), i && this.emit("blur", {
          editor: this,
          event: i.event,
          transaction: e
        }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
          editor: this,
          transaction: e
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(e) {
        return Rm(this.state, e);
      }
      isActive(e, t) {
        const r = typeof e == "string" ? e : null, o = typeof e == "string" ? t : e;
        return $k(this.state, r, o);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return yu(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(e) {
        const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {};
        return Am(this.state.doc, {
          blockSeparator: t,
          textSerializers: {
            ...wu(this.schema),
            ...r
          }
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return _u(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       *
       * @deprecated
       */
      getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        if (this.emit("destroy"), this.view) {
          const e = this.view.dom;
          e && e.editor && delete e.editor, this.view.destroy();
        }
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView);
      }
      $node(e, t) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, t)) || null;
      }
      $nodes(e, t) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, t)) || null;
      }
      $pos(e) {
        const t = this.state.doc.resolve(e);
        return new Xr(t, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    };
    function ho(n3) {
      return new rs({
        find: n3.find,
        handler: ({ state: e, range: t, match: r }) => {
          const o = Te(n3.getAttributes, void 0, r);
          if (o === false || o === null)
            return null;
          const { tr: i } = e, s = r[r.length - 1], a = r[0];
          if (s) {
            const l = a.search(/\S/), c2 = t.from + a.indexOf(s), u = c2 + s.length;
            if (Eu(t.from, t.to, e.doc).filter((f) => f.mark.type.excluded.find((m) => m === n3.type && m !== f.mark.type)).filter((f) => f.to > c2).length)
              return null;
            u < t.to && i.delete(u, t.to), c2 > t.from && i.delete(t.from + l, c2);
            const p2 = t.from + l + s.length;
            i.addMark(t.from + l, p2, n3.type.create(o || {})), i.removeStoredMark(n3.type);
          }
        }
      });
    }
    function Su(n3) {
      return new rs({
        find: n3.find,
        handler: ({ state: e, range: t, match: r }) => {
          const o = Te(n3.getAttributes, void 0, r) || {}, { tr: i } = e, s = t.from;
          let a = t.to;
          const l = n3.type.create(o);
          if (r[1]) {
            const c2 = r[0].lastIndexOf(r[1]);
            let u = s + c2;
            u > a ? u = a : a = u + r[1].length;
            const d = r[0][r[0].length - 1];
            i.insertText(d, s + r[0].length - 1), i.replaceWith(u, a, l);
          } else if (r[0]) {
            const c2 = n3.type.isInline ? s : s - 1;
            i.insert(c2, n3.type.create(o)).delete(i.mapping.map(s), i.mapping.map(a));
          }
          i.scrollIntoView();
        }
      });
    }
    function Oc(n3) {
      return new rs({
        find: n3.find,
        handler: ({ state: e, range: t, match: r }) => {
          const o = e.doc.resolve(t.from), i = Te(n3.getAttributes, void 0, r) || {};
          if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), n3.type))
            return null;
          e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n3.type, i);
        }
      });
    }
    function pt(n3) {
      return new rs({
        find: n3.find,
        handler: ({ state: e, range: t, match: r }) => {
          let o = n3.replace, i = t.from;
          const s = t.to;
          if (r[1]) {
            const a = r[0].lastIndexOf(r[1]);
            o += r[0].slice(a + r[1].length), i += a;
            const l = i - s;
            l > 0 && (o = r[0].slice(a - l, a) + o, i = s);
          }
          e.tr.insertText(o, i, s);
        }
      });
    }
    function Wo(n3) {
      return new rs({
        find: n3.find,
        handler: ({ state: e, range: t, match: r, chain: o }) => {
          const i = Te(n3.getAttributes, void 0, r) || {}, s = e.tr.delete(t.from, t.to), l = s.doc.resolve(t.from).blockRange(), c2 = l && nu(l, n3.type, i);
          if (!c2)
            return null;
          if (s.wrap(l, c2), n3.keepMarks && n3.editor) {
            const { selection: d, storedMarks: p2 } = e, { splittableMarks: f } = n3.editor.extensionManager, h2 = p2 || d.$to.parentOffset && d.$from.marks();
            if (h2) {
              const m = h2.filter((g) => f.includes(g.type.name));
              s.ensureMarks(m);
            }
          }
          if (n3.keepAttributes) {
            const d = n3.type.name === "bulletList" || n3.type.name === "orderedList" ? "listItem" : "taskList";
            o().updateAttributes(d, i).run();
          }
          const u = s.doc.resolve(t.from - 1).nodeBefore;
          u && u.type === n3.type && Ur(s.doc, t.from - 1) && (!n3.joinPredicate || n3.joinPredicate(r, u)) && s.join(t.from - 1);
        }
      });
    }
    class st {
      constructor(e = {}) {
        this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
          name: this.name,
          defaultOptions: {}
        }, this.config = {
          ...this.config,
          ...e
        }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Te(Z(this, "addOptions", {
          name: this.name
        }))), this.storage = Te(Z(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(e = {}) {
        return new st(e);
      }
      configure(e = {}) {
        const t = this.extend({
          ...this.config,
          addOptions: () => nl(this.options, e)
        });
        return t.name = this.name, t.parent = this.parent, t;
      }
      extend(e = {}) {
        const t = new st(e);
        return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Te(Z(t, "addOptions", {
          name: t.name
        })), t.storage = Te(Z(t, "addStorage", {
          name: t.name,
          options: t.options
        })), t;
      }
    }
    class hE {
      constructor(e, t, r) {
        this.isDragging = false, this.component = e, this.editor = t.editor, this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...r
        }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount();
      }
      mount() {
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(e) {
        var t, r, o, i, s, a, l;
        const { view: c2 } = this.editor, u = e.target, d = u.nodeType === 3 ? (t = u.parentElement) === null || t === void 0 ? void 0 : t.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
        if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(u) || !d)
          return;
        let p2 = 0, f = 0;
        if (this.dom !== d) {
          const b = this.dom.getBoundingClientRect(), w = d.getBoundingClientRect(), _ = (o = e.offsetX) !== null && o !== void 0 ? o : (i = e.nativeEvent) === null || i === void 0 ? void 0 : i.offsetX, v = (s = e.offsetY) !== null && s !== void 0 ? s : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
          p2 = w.x - b.x + _, f = w.y - b.y + v;
        }
        (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, p2, f);
        const h2 = this.getPos();
        if (typeof h2 != "number")
          return;
        const m = ne.create(c2.state.doc, h2), g = c2.state.tr.setSelection(m);
        c2.dispatch(g);
      }
      stopEvent(e) {
        var t;
        if (!this.dom)
          return false;
        if (typeof this.options.stopEvent == "function")
          return this.options.stopEvent({ event: e });
        const r = e.target;
        if (!(this.dom.contains(r) && !(!((t = this.contentDOM) === null || t === void 0) && t.contains(r))))
          return false;
        const i = e.type.startsWith("drag"), s = e.type === "drop";
        if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !s && !i)
          return true;
        const { isEditable: l } = this.editor, { isDragging: c2 } = this, u = !!this.node.type.spec.draggable, d = ne.isSelectable(this.node), p2 = e.type === "copy", f = e.type === "paste", h2 = e.type === "cut", m = e.type === "mousedown";
        if (!u && d && i && e.target === this.dom && e.preventDefault(), u && i && !c2 && e.target === this.dom)
          return e.preventDefault(), false;
        if (u && l && !c2 && m) {
          const g = r.closest("[data-drag-handle]");
          g && (this.dom === g || this.dom.contains(g)) && (this.isDragging = true, document.addEventListener("dragend", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("drop", () => {
            this.isDragging = false;
          }, { once: true }), document.addEventListener("mouseup", () => {
            this.isDragging = false;
          }, { once: true }));
        }
        return !(c2 || s || p2 || f || h2 || m && d);
      }
      /**
       * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
       * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
       * @return `true` if it can safely be ignored.
       */
      ignoreMutation(e) {
        return !this.dom || !this.contentDOM ? true : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? true : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (ol() || xm()) && this.editor.isFocused && [
          ...Array.from(e.addedNodes),
          ...Array.from(e.removedNodes)
        ].every((r) => r.isContentEditable) ? false : this.contentDOM === e.target && e.type === "attributes" ? true : !this.contentDOM.contains(e.target);
      }
      /**
       * Update the attributes of the prosemirror node.
       */
      updateAttributes(e) {
        this.editor.commands.command(({ tr: t }) => {
          const r = this.getPos();
          return typeof r != "number" ? false : (t.setNodeMarkup(r, void 0, {
            ...this.node.attrs,
            ...e
          }), true);
        });
      }
      /**
       * Delete the node.
       */
      deleteNode() {
        const e = this.getPos();
        if (typeof e != "number")
          return;
        const t = e + this.node.nodeSize;
        this.editor.commands.deleteRange({ from: e, to: t });
      }
    }
    function Hr(n3) {
      return new Lw({
        find: n3.find,
        handler: ({ state: e, range: t, match: r, pasteEvent: o }) => {
          const i = Te(n3.getAttributes, void 0, r, o);
          if (i === false || i === null)
            return null;
          const { tr: s } = e, a = r[r.length - 1], l = r[0];
          let c2 = t.to;
          if (a) {
            const u = l.search(/\S/), d = t.from + l.indexOf(a), p2 = d + a.length;
            if (Eu(t.from, t.to, e.doc).filter((h2) => h2.mark.type.excluded.find((g) => g === n3.type && g !== h2.mark.type)).filter((h2) => h2.to > d).length)
              return null;
            p2 < t.to && s.delete(p2, t.to), d > t.from && s.delete(t.from + u, d), c2 = t.from + u + a.length, s.addMark(t.from + u, c2, n3.type.create(i || {})), s.removeStoredMark(n3.type);
          }
        }
      });
    }
    function mE(n3) {
      return n3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var rn = "top", xn = "bottom", Tn = "right", on = "left", Cu = "auto", is = [rn, xn, Tn, on], qo = "start", zi = "end", gE = "clippingParents", Lm = "viewport", ii = "popper", bE = "reference", yp = /* @__PURE__ */ is.reduce(function(n3, e) {
      return n3.concat([e + "-" + qo, e + "-" + zi]);
    }, []), Bm = /* @__PURE__ */ [].concat(is, [Cu]).reduce(function(n3, e) {
      return n3.concat([e, e + "-" + qo, e + "-" + zi]);
    }, []), yE = "beforeRead", vE = "read", wE = "afterRead", kE = "beforeMain", EE = "main", _E = "afterMain", SE = "beforeWrite", CE = "write", xE = "afterWrite", TE = [yE, vE, wE, kE, EE, _E, SE, CE, xE];
    function Zn(n3) {
      return n3 ? (n3.nodeName || "").toLowerCase() : null;
    }
    function mn(n3) {
      if (n3 == null)
        return window;
      if (n3.toString() !== "[object Window]") {
        var e = n3.ownerDocument;
        return e && e.defaultView || window;
      }
      return n3;
    }
    function mo(n3) {
      var e = mn(n3).Element;
      return n3 instanceof e || n3 instanceof Element;
    }
    function Sn(n3) {
      var e = mn(n3).HTMLElement;
      return n3 instanceof e || n3 instanceof HTMLElement;
    }
    function xu(n3) {
      if (typeof ShadowRoot > "u")
        return false;
      var e = mn(n3).ShadowRoot;
      return n3 instanceof e || n3 instanceof ShadowRoot;
    }
    function OE(n3) {
      var e = n3.state;
      Object.keys(e.elements).forEach(function(t) {
        var r = e.styles[t] || {}, o = e.attributes[t] || {}, i = e.elements[t];
        !Sn(i) || !Zn(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(s) {
          var a = o[s];
          a === false ? i.removeAttribute(s) : i.setAttribute(s, a === true ? "" : a);
        }));
      });
    }
    function NE(n3) {
      var e = n3.state, t = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o = e.elements[r], i = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), a = s.reduce(function(l, c2) {
            return l[c2] = "", l;
          }, {});
          !Sn(o) || !Zn(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function(l) {
            o.removeAttribute(l);
          }));
        });
      };
    }
    const Pm = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: OE,
      effect: NE,
      requires: ["computeStyles"]
    };
    function Jn(n3) {
      return n3.split("-")[0];
    }
    var io = Math.max, da = Math.min, Ko = Math.round;
    function Nc() {
      var n3 = navigator.userAgentData;
      return n3 != null && n3.brands && Array.isArray(n3.brands) ? n3.brands.map(function(e) {
        return e.brand + "/" + e.version;
      }).join(" ") : navigator.userAgent;
    }
    function $m() {
      return !/^((?!chrome|android).)*safari/i.test(Nc());
    }
    function Go(n3, e, t) {
      e === void 0 && (e = false), t === void 0 && (t = false);
      var r = n3.getBoundingClientRect(), o = 1, i = 1;
      e && Sn(n3) && (o = n3.offsetWidth > 0 && Ko(r.width) / n3.offsetWidth || 1, i = n3.offsetHeight > 0 && Ko(r.height) / n3.offsetHeight || 1);
      var s = mo(n3) ? mn(n3) : window, a = s.visualViewport, l = !$m() && t, c2 = (r.left + (l && a ? a.offsetLeft : 0)) / o, u = (r.top + (l && a ? a.offsetTop : 0)) / i, d = r.width / o, p2 = r.height / i;
      return {
        width: d,
        height: p2,
        top: u,
        right: c2 + d,
        bottom: u + p2,
        left: c2,
        x: c2,
        y: u
      };
    }
    function Tu(n3) {
      var e = Go(n3), t = n3.offsetWidth, r = n3.offsetHeight;
      return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: n3.offsetLeft,
        y: n3.offsetTop,
        width: t,
        height: r
      };
    }
    function Fm(n3, e) {
      var t = e.getRootNode && e.getRootNode();
      if (n3.contains(e))
        return true;
      if (t && xu(t)) {
        var r = e;
        do {
          if (r && n3.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function gr(n3) {
      return mn(n3).getComputedStyle(n3);
    }
    function ME(n3) {
      return ["table", "td", "th"].indexOf(Zn(n3)) >= 0;
    }
    function qr(n3) {
      return ((mo(n3) ? n3.ownerDocument : (
        // $FlowFixMe[prop-missing]
        n3.document
      )) || window.document).documentElement;
    }
    function sl(n3) {
      return Zn(n3) === "html" ? n3 : (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        n3.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        n3.parentNode || // DOM Element detected
        (xu(n3) ? n3.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        qr(n3)
      );
    }
    function vp(n3) {
      return !Sn(n3) || // https://github.com/popperjs/popper-core/issues/837
      gr(n3).position === "fixed" ? null : n3.offsetParent;
    }
    function AE(n3) {
      var e = /firefox/i.test(Nc()), t = /Trident/i.test(Nc());
      if (t && Sn(n3)) {
        var r = gr(n3);
        if (r.position === "fixed")
          return null;
      }
      var o = sl(n3);
      for (xu(o) && (o = o.host); Sn(o) && ["html", "body"].indexOf(Zn(o)) < 0; ) {
        var i = gr(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
          return o;
        o = o.parentNode;
      }
      return null;
    }
    function ss(n3) {
      for (var e = mn(n3), t = vp(n3); t && ME(t) && gr(t).position === "static"; )
        t = vp(t);
      return t && (Zn(t) === "html" || Zn(t) === "body" && gr(t).position === "static") ? e : t || AE(n3) || e;
    }
    function Ou(n3) {
      return ["top", "bottom"].indexOf(n3) >= 0 ? "x" : "y";
    }
    function Ei(n3, e, t) {
      return io(n3, da(e, t));
    }
    function RE(n3, e, t) {
      var r = Ei(n3, e, t);
      return r > t ? t : r;
    }
    function zm() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function Hm(n3) {
      return Object.assign({}, zm(), n3);
    }
    function Um(n3, e) {
      return e.reduce(function(t, r) {
        return t[r] = n3, t;
      }, {});
    }
    var IE = function(e, t) {
      return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
        placement: t.placement
      })) : e, Hm(typeof e != "number" ? e : Um(e, is));
    };
    function DE(n3) {
      var e, t = n3.state, r = n3.name, o = n3.options, i = t.elements.arrow, s = t.modifiersData.popperOffsets, a = Jn(t.placement), l = Ou(a), c2 = [on, Tn].indexOf(a) >= 0, u = c2 ? "height" : "width";
      if (!(!i || !s)) {
        var d = IE(o.padding, t), p2 = Tu(i), f = l === "y" ? rn : on, h2 = l === "y" ? xn : Tn, m = t.rects.reference[u] + t.rects.reference[l] - s[l] - t.rects.popper[u], g = s[l] - t.rects.reference[l], b = ss(i), w = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, _ = m / 2 - g / 2, v = d[f], T = w - p2[u] - d[h2], S = w / 2 - p2[u] / 2 + _, z = Ei(v, S, T), U = l;
        t.modifiersData[r] = (e = {}, e[U] = z, e.centerOffset = z - S, e);
      }
    }
    function LE(n3) {
      var e = n3.state, t = n3.options, r = t.element, o = r === void 0 ? "[data-popper-arrow]" : r;
      o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || Fm(e.elements.popper, o) && (e.elements.arrow = o));
    }
    const BE = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: DE,
      effect: LE,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function jo(n3) {
      return n3.split("-")[1];
    }
    var PE = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function $E(n3, e) {
      var t = n3.x, r = n3.y, o = e.devicePixelRatio || 1;
      return {
        x: Ko(t * o) / o || 0,
        y: Ko(r * o) / o || 0
      };
    }
    function wp(n3) {
      var e, t = n3.popper, r = n3.popperRect, o = n3.placement, i = n3.variation, s = n3.offsets, a = n3.position, l = n3.gpuAcceleration, c2 = n3.adaptive, u = n3.roundOffsets, d = n3.isFixed, p2 = s.x, f = p2 === void 0 ? 0 : p2, h2 = s.y, m = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({
        x: f,
        y: m
      }) : {
        x: f,
        y: m
      };
      f = g.x, m = g.y;
      var b = s.hasOwnProperty("x"), w = s.hasOwnProperty("y"), _ = on, v = rn, T = window;
      if (c2) {
        var S = ss(t), z = "clientHeight", U = "clientWidth";
        if (S === mn(t) && (S = qr(t), gr(S).position !== "static" && a === "absolute" && (z = "scrollHeight", U = "scrollWidth")), S = S, o === rn || (o === on || o === Tn) && i === zi) {
          v = xn;
          var B = d && S === T && T.visualViewport ? T.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            S[z]
          );
          m -= B - r.height, m *= l ? 1 : -1;
        }
        if (o === on || (o === rn || o === xn) && i === zi) {
          _ = Tn;
          var q = d && S === T && T.visualViewport ? T.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            S[U]
          );
          f -= q - r.width, f *= l ? 1 : -1;
        }
      }
      var oe = Object.assign({
        position: a
      }, c2 && PE), de = u === true ? $E({
        x: f,
        y: m
      }, mn(t)) : {
        x: f,
        y: m
      };
      if (f = de.x, m = de.y, l) {
        var ke;
        return Object.assign({}, oe, (ke = {}, ke[v] = w ? "0" : "", ke[_] = b ? "0" : "", ke.transform = (T.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", ke));
      }
      return Object.assign({}, oe, (e = {}, e[v] = w ? m + "px" : "", e[_] = b ? f + "px" : "", e.transform = "", e));
    }
    function FE(n3) {
      var e = n3.state, t = n3.options, r = t.gpuAcceleration, o = r === void 0 ? true : r, i = t.adaptive, s = i === void 0 ? true : i, a = t.roundOffsets, l = a === void 0 ? true : a, c2 = {
        placement: Jn(e.placement),
        variation: jo(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: o,
        isFixed: e.options.strategy === "fixed"
      };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, wp(Object.assign({}, c2, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: s,
        roundOffsets: l
      })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, wp(Object.assign({}, c2, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    }
    const zE = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: FE,
      data: {}
    };
    var ks = {
      passive: true
    };
    function HE(n3) {
      var e = n3.state, t = n3.instance, r = n3.options, o = r.scroll, i = o === void 0 ? true : o, s = r.resize, a = s === void 0 ? true : s, l = mn(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c2.forEach(function(u) {
        u.addEventListener("scroll", t.update, ks);
      }), a && l.addEventListener("resize", t.update, ks), function() {
        i && c2.forEach(function(u) {
          u.removeEventListener("scroll", t.update, ks);
        }), a && l.removeEventListener("resize", t.update, ks);
      };
    }
    const UE = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function() {
      },
      effect: HE,
      data: {}
    };
    var VE = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function Gs(n3) {
      return n3.replace(/left|right|bottom|top/g, function(e) {
        return VE[e];
      });
    }
    var WE = {
      start: "end",
      end: "start"
    };
    function kp(n3) {
      return n3.replace(/start|end/g, function(e) {
        return WE[e];
      });
    }
    function Nu(n3) {
      var e = mn(n3), t = e.pageXOffset, r = e.pageYOffset;
      return {
        scrollLeft: t,
        scrollTop: r
      };
    }
    function Mu(n3) {
      return Go(qr(n3)).left + Nu(n3).scrollLeft;
    }
    function qE(n3, e) {
      var t = mn(n3), r = qr(n3), o = t.visualViewport, i = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
      if (o) {
        i = o.width, s = o.height;
        var c2 = $m();
        (c2 || !c2 && e === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
      }
      return {
        width: i,
        height: s,
        x: a + Mu(n3),
        y: l
      };
    }
    function KE(n3) {
      var e, t = qr(n3), r = Nu(n3), o = (e = n3.ownerDocument) == null ? void 0 : e.body, i = io(t.scrollWidth, t.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = io(t.scrollHeight, t.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), a = -r.scrollLeft + Mu(n3), l = -r.scrollTop;
      return gr(o || t).direction === "rtl" && (a += io(t.clientWidth, o ? o.clientWidth : 0) - i), {
        width: i,
        height: s,
        x: a,
        y: l
      };
    }
    function Au(n3) {
      var e = gr(n3), t = e.overflow, r = e.overflowX, o = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(t + o + r);
    }
    function Vm(n3) {
      return ["html", "body", "#document"].indexOf(Zn(n3)) >= 0 ? n3.ownerDocument.body : Sn(n3) && Au(n3) ? n3 : Vm(sl(n3));
    }
    function _i(n3, e) {
      var t;
      e === void 0 && (e = []);
      var r = Vm(n3), o = r === ((t = n3.ownerDocument) == null ? void 0 : t.body), i = mn(r), s = o ? [i].concat(i.visualViewport || [], Au(r) ? r : []) : r, a = e.concat(s);
      return o ? a : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        a.concat(_i(sl(s)))
      );
    }
    function Mc(n3) {
      return Object.assign({}, n3, {
        left: n3.x,
        top: n3.y,
        right: n3.x + n3.width,
        bottom: n3.y + n3.height
      });
    }
    function GE(n3, e) {
      var t = Go(n3, false, e === "fixed");
      return t.top = t.top + n3.clientTop, t.left = t.left + n3.clientLeft, t.bottom = t.top + n3.clientHeight, t.right = t.left + n3.clientWidth, t.width = n3.clientWidth, t.height = n3.clientHeight, t.x = t.left, t.y = t.top, t;
    }
    function Ep(n3, e, t) {
      return e === Lm ? Mc(qE(n3, t)) : mo(e) ? GE(e, t) : Mc(KE(qr(n3)));
    }
    function jE(n3) {
      var e = _i(sl(n3)), t = ["absolute", "fixed"].indexOf(gr(n3).position) >= 0, r = t && Sn(n3) ? ss(n3) : n3;
      return mo(r) ? e.filter(function(o) {
        return mo(o) && Fm(o, r) && Zn(o) !== "body";
      }) : [];
    }
    function JE(n3, e, t, r) {
      var o = e === "clippingParents" ? jE(n3) : [].concat(e), i = [].concat(o, [t]), s = i[0], a = i.reduce(function(l, c2) {
        var u = Ep(n3, c2, r);
        return l.top = io(u.top, l.top), l.right = da(u.right, l.right), l.bottom = da(u.bottom, l.bottom), l.left = io(u.left, l.left), l;
      }, Ep(n3, s, r));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function Wm(n3) {
      var e = n3.reference, t = n3.element, r = n3.placement, o = r ? Jn(r) : null, i = r ? jo(r) : null, s = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
      switch (o) {
        case rn:
          l = {
            x: s,
            y: e.y - t.height
          };
          break;
        case xn:
          l = {
            x: s,
            y: e.y + e.height
          };
          break;
        case Tn:
          l = {
            x: e.x + e.width,
            y: a
          };
          break;
        case on:
          l = {
            x: e.x - t.width,
            y: a
          };
          break;
        default:
          l = {
            x: e.x,
            y: e.y
          };
      }
      var c2 = o ? Ou(o) : null;
      if (c2 != null) {
        var u = c2 === "y" ? "height" : "width";
        switch (i) {
          case qo:
            l[c2] = l[c2] - (e[u] / 2 - t[u] / 2);
            break;
          case zi:
            l[c2] = l[c2] + (e[u] / 2 - t[u] / 2);
            break;
        }
      }
      return l;
    }
    function Hi(n3, e) {
      e === void 0 && (e = {});
      var t = e, r = t.placement, o = r === void 0 ? n3.placement : r, i = t.strategy, s = i === void 0 ? n3.strategy : i, a = t.boundary, l = a === void 0 ? gE : a, c2 = t.rootBoundary, u = c2 === void 0 ? Lm : c2, d = t.elementContext, p2 = d === void 0 ? ii : d, f = t.altBoundary, h2 = f === void 0 ? false : f, m = t.padding, g = m === void 0 ? 0 : m, b = Hm(typeof g != "number" ? g : Um(g, is)), w = p2 === ii ? bE : ii, _ = n3.rects.popper, v = n3.elements[h2 ? w : p2], T = JE(mo(v) ? v : v.contextElement || qr(n3.elements.popper), l, u, s), S = Go(n3.elements.reference), z = Wm({
        reference: S,
        element: _,
        placement: o
      }), U = Mc(Object.assign({}, _, z)), B = p2 === ii ? U : S, q = {
        top: T.top - B.top + b.top,
        bottom: B.bottom - T.bottom + b.bottom,
        left: T.left - B.left + b.left,
        right: B.right - T.right + b.right
      }, oe = n3.modifiersData.offset;
      if (p2 === ii && oe) {
        var de = oe[o];
        Object.keys(q).forEach(function(ke) {
          var we = [Tn, xn].indexOf(ke) >= 0 ? 1 : -1, fe = [rn, xn].indexOf(ke) >= 0 ? "y" : "x";
          q[ke] += de[fe] * we;
        });
      }
      return q;
    }
    function YE(n3, e) {
      e === void 0 && (e = {});
      var t = e, r = t.placement, o = t.boundary, i = t.rootBoundary, s = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, c2 = l === void 0 ? Bm : l, u = jo(r), d = u ? a ? yp : yp.filter(function(h2) {
        return jo(h2) === u;
      }) : is, p2 = d.filter(function(h2) {
        return c2.indexOf(h2) >= 0;
      });
      p2.length === 0 && (p2 = d);
      var f = p2.reduce(function(h2, m) {
        return h2[m] = Hi(n3, {
          placement: m,
          boundary: o,
          rootBoundary: i,
          padding: s
        })[Jn(m)], h2;
      }, {});
      return Object.keys(f).sort(function(h2, m) {
        return f[h2] - f[m];
      });
    }
    function XE(n3) {
      if (Jn(n3) === Cu)
        return [];
      var e = Gs(n3);
      return [kp(n3), e, kp(e)];
    }
    function ZE(n3) {
      var e = n3.state, t = n3.options, r = n3.name;
      if (!e.modifiersData[r]._skip) {
        for (var o = t.mainAxis, i = o === void 0 ? true : o, s = t.altAxis, a = s === void 0 ? true : s, l = t.fallbackPlacements, c2 = t.padding, u = t.boundary, d = t.rootBoundary, p2 = t.altBoundary, f = t.flipVariations, h2 = f === void 0 ? true : f, m = t.allowedAutoPlacements, g = e.options.placement, b = Jn(g), w = b === g, _ = l || (w || !h2 ? [Gs(g)] : XE(g)), v = [g].concat(_).reduce(function(kt, ze) {
          return kt.concat(Jn(ze) === Cu ? YE(e, {
            placement: ze,
            boundary: u,
            rootBoundary: d,
            padding: c2,
            flipVariations: h2,
            allowedAutoPlacements: m
          }) : ze);
        }, []), T = e.rects.reference, S = e.rects.popper, z = /* @__PURE__ */ new Map(), U = true, B = v[0], q = 0; q < v.length; q++) {
          var oe = v[q], de = Jn(oe), ke = jo(oe) === qo, we = [rn, xn].indexOf(de) >= 0, fe = we ? "width" : "height", he = Hi(e, {
            placement: oe,
            boundary: u,
            rootBoundary: d,
            altBoundary: p2,
            padding: c2
          }), M = we ? ke ? Tn : on : ke ? xn : rn;
          T[fe] > S[fe] && (M = Gs(M));
          var L = Gs(M), J = [];
          if (i && J.push(he[de] <= 0), a && J.push(he[M] <= 0, he[L] <= 0), J.every(function(kt) {
            return kt;
          })) {
            B = oe, U = false;
            break;
          }
          z.set(oe, J);
        }
        if (U)
          for (var re = h2 ? 3 : 1, ce = function(ze) {
            var et = v.find(function(an) {
              var Tt = z.get(an);
              if (Tt)
                return Tt.slice(0, ze).every(function(gn) {
                  return gn;
                });
            });
            if (et)
              return B = et, "break";
          }, Se = re; Se > 0; Se--) {
            var Fe = ce(Se);
            if (Fe === "break") break;
          }
        e.placement !== B && (e.modifiersData[r]._skip = true, e.placement = B, e.reset = true);
      }
    }
    const QE = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: ZE,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function _p(n3, e, t) {
      return t === void 0 && (t = {
        x: 0,
        y: 0
      }), {
        top: n3.top - e.height - t.y,
        right: n3.right - e.width + t.x,
        bottom: n3.bottom - e.height + t.y,
        left: n3.left - e.width - t.x
      };
    }
    function Sp(n3) {
      return [rn, Tn, xn, on].some(function(e) {
        return n3[e] >= 0;
      });
    }
    function e_(n3) {
      var e = n3.state, t = n3.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, s = Hi(e, {
        elementContext: "reference"
      }), a = Hi(e, {
        altBoundary: true
      }), l = _p(s, r), c2 = _p(a, o, i), u = Sp(l), d = Sp(c2);
      e.modifiersData[t] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c2,
        isReferenceHidden: u,
        hasPopperEscaped: d
      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d
      });
    }
    const t_ = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: e_
    };
    function n_(n3, e, t) {
      var r = Jn(n3), o = [on, rn].indexOf(r) >= 0 ? -1 : 1, i = typeof t == "function" ? t(Object.assign({}, e, {
        placement: n3
      })) : t, s = i[0], a = i[1];
      return s = s || 0, a = (a || 0) * o, [on, Tn].indexOf(r) >= 0 ? {
        x: a,
        y: s
      } : {
        x: s,
        y: a
      };
    }
    function r_(n3) {
      var e = n3.state, t = n3.options, r = n3.name, o = t.offset, i = o === void 0 ? [0, 0] : o, s = Bm.reduce(function(u, d) {
        return u[d] = n_(d, e.rects, i), u;
      }, {}), a = s[e.placement], l = a.x, c2 = a.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = s;
    }
    const o_ = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: r_
    };
    function i_(n3) {
      var e = n3.state, t = n3.name;
      e.modifiersData[t] = Wm({
        reference: e.rects.reference,
        element: e.rects.popper,
        placement: e.placement
      });
    }
    const s_ = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: i_,
      data: {}
    };
    function a_(n3) {
      return n3 === "x" ? "y" : "x";
    }
    function l_(n3) {
      var e = n3.state, t = n3.options, r = n3.name, o = t.mainAxis, i = o === void 0 ? true : o, s = t.altAxis, a = s === void 0 ? false : s, l = t.boundary, c2 = t.rootBoundary, u = t.altBoundary, d = t.padding, p2 = t.tether, f = p2 === void 0 ? true : p2, h2 = t.tetherOffset, m = h2 === void 0 ? 0 : h2, g = Hi(e, {
        boundary: l,
        rootBoundary: c2,
        padding: d,
        altBoundary: u
      }), b = Jn(e.placement), w = jo(e.placement), _ = !w, v = Ou(b), T = a_(v), S = e.modifiersData.popperOffsets, z = e.rects.reference, U = e.rects.popper, B = typeof m == "function" ? m(Object.assign({}, e.rects, {
        placement: e.placement
      })) : m, q = typeof B == "number" ? {
        mainAxis: B,
        altAxis: B
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, B), oe = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, de = {
        x: 0,
        y: 0
      };
      if (S) {
        if (i) {
          var ke, we = v === "y" ? rn : on, fe = v === "y" ? xn : Tn, he = v === "y" ? "height" : "width", M = S[v], L = M + g[we], J = M - g[fe], re = f ? -U[he] / 2 : 0, ce = w === qo ? z[he] : U[he], Se = w === qo ? -U[he] : -z[he], Fe = e.elements.arrow, kt = f && Fe ? Tu(Fe) : {
            width: 0,
            height: 0
          }, ze = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : zm(), et = ze[we], an = ze[fe], Tt = Ei(0, z[he], kt[he]), gn = _ ? z[he] / 2 - re - Tt - et - q.mainAxis : ce - Tt - et - q.mainAxis, Ot = _ ? -z[he] / 2 + re + Tt + an + q.mainAxis : Se + Tt + an + q.mainAxis, bn = e.elements.arrow && ss(e.elements.arrow), Fn = bn ? v === "y" ? bn.clientTop || 0 : bn.clientLeft || 0 : 0, Mn = (ke = oe == null ? void 0 : oe[v]) != null ? ke : 0, ln = M + gn - Mn - Fn, An = M + Ot - Mn, ve = Ei(f ? da(L, ln) : L, M, f ? io(J, An) : J);
          S[v] = ve, de[v] = ve - M;
        }
        if (a) {
          var Qt, Pt = v === "x" ? rn : on, le = v === "x" ? xn : Tn, Wt = S[T], Ke = T === "y" ? "height" : "width", Re = Wt + g[Pt], qt = Wt - g[le], ft = [rn, on].indexOf(b) !== -1, Rn = (Qt = oe == null ? void 0 : oe[T]) != null ? Qt : 0, Kt = ft ? Re : Wt - z[Ke] - U[Ke] - Rn + q.altAxis, V = ft ? Wt + z[Ke] + U[Ke] - Rn - q.altAxis : qt, Y = f && ft ? RE(Kt, Wt, V) : Ei(f ? Kt : Re, Wt, f ? V : qt);
          S[T] = Y, de[T] = Y - Wt;
        }
        e.modifiersData[r] = de;
      }
    }
    const c_ = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: l_,
      requiresIfExists: ["offset"]
    };
    function u_(n3) {
      return {
        scrollLeft: n3.scrollLeft,
        scrollTop: n3.scrollTop
      };
    }
    function d_(n3) {
      return n3 === mn(n3) || !Sn(n3) ? Nu(n3) : u_(n3);
    }
    function p_(n3) {
      var e = n3.getBoundingClientRect(), t = Ko(e.width) / n3.offsetWidth || 1, r = Ko(e.height) / n3.offsetHeight || 1;
      return t !== 1 || r !== 1;
    }
    function f_(n3, e, t) {
      t === void 0 && (t = false);
      var r = Sn(e), o = Sn(e) && p_(e), i = qr(e), s = Go(n3, o, t), a = {
        scrollLeft: 0,
        scrollTop: 0
      }, l = {
        x: 0,
        y: 0
      };
      return (r || !r && !t) && ((Zn(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      Au(i)) && (a = d_(e)), Sn(e) ? (l = Go(e, true), l.x += e.clientLeft, l.y += e.clientTop) : i && (l.x = Mu(i))), {
        x: s.left + a.scrollLeft - l.x,
        y: s.top + a.scrollTop - l.y,
        width: s.width,
        height: s.height
      };
    }
    function h_(n3) {
      var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), r = [];
      n3.forEach(function(i) {
        e.set(i.name, i);
      });
      function o(i) {
        t.add(i.name);
        var s = [].concat(i.requires || [], i.requiresIfExists || []);
        s.forEach(function(a) {
          if (!t.has(a)) {
            var l = e.get(a);
            l && o(l);
          }
        }), r.push(i);
      }
      return n3.forEach(function(i) {
        t.has(i.name) || o(i);
      }), r;
    }
    function m_(n3) {
      var e = h_(n3);
      return TE.reduce(function(t, r) {
        return t.concat(e.filter(function(o) {
          return o.phase === r;
        }));
      }, []);
    }
    function g_(n3) {
      var e;
      return function() {
        return e || (e = new Promise(function(t) {
          Promise.resolve().then(function() {
            e = void 0, t(n3());
          });
        })), e;
      };
    }
    function b_(n3) {
      var e = n3.reduce(function(t, r) {
        var o = t[r.name];
        return t[r.name] = o ? Object.assign({}, o, r, {
          options: Object.assign({}, o.options, r.options),
          data: Object.assign({}, o.data, r.data)
        }) : r, t;
      }, {});
      return Object.keys(e).map(function(t) {
        return e[t];
      });
    }
    var Cp = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function xp() {
      for (var n3 = arguments.length, e = new Array(n3), t = 0; t < n3; t++)
        e[t] = arguments[t];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function y_(n3) {
      n3 === void 0 && (n3 = {});
      var e = n3, t = e.defaultModifiers, r = t === void 0 ? [] : t, o = e.defaultOptions, i = o === void 0 ? Cp : o;
      return function(a, l, c2) {
        c2 === void 0 && (c2 = i);
        var u = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, Cp, i),
          modifiersData: {},
          elements: {
            reference: a,
            popper: l
          },
          attributes: {},
          styles: {}
        }, d = [], p2 = false, f = {
          state: u,
          setOptions: function(b) {
            var w = typeof b == "function" ? b(u.options) : b;
            m(), u.options = Object.assign({}, i, u.options, w), u.scrollParents = {
              reference: mo(a) ? _i(a) : a.contextElement ? _i(a.contextElement) : [],
              popper: _i(l)
            };
            var _ = m_(b_([].concat(r, u.options.modifiers)));
            return u.orderedModifiers = _.filter(function(v) {
              return v.enabled;
            }), h2(), f.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function() {
            if (!p2) {
              var b = u.elements, w = b.reference, _ = b.popper;
              if (xp(w, _)) {
                u.rects = {
                  reference: f_(w, ss(_), u.options.strategy === "fixed"),
                  popper: Tu(_)
                }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(q) {
                  return u.modifiersData[q.name] = Object.assign({}, q.data);
                });
                for (var v = 0; v < u.orderedModifiers.length; v++) {
                  if (u.reset === true) {
                    u.reset = false, v = -1;
                    continue;
                  }
                  var T = u.orderedModifiers[v], S = T.fn, z = T.options, U = z === void 0 ? {} : z, B = T.name;
                  typeof S == "function" && (u = S({
                    state: u,
                    options: U,
                    name: B,
                    instance: f
                  }) || u);
                }
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: g_(function() {
            return new Promise(function(g) {
              f.forceUpdate(), g(u);
            });
          }),
          destroy: function() {
            m(), p2 = true;
          }
        };
        if (!xp(a, l))
          return f;
        f.setOptions(c2).then(function(g) {
          !p2 && c2.onFirstUpdate && c2.onFirstUpdate(g);
        });
        function h2() {
          u.orderedModifiers.forEach(function(g) {
            var b = g.name, w = g.options, _ = w === void 0 ? {} : w, v = g.effect;
            if (typeof v == "function") {
              var T = v({
                state: u,
                name: b,
                instance: f,
                options: _
              }), S = function() {
              };
              d.push(T || S);
            }
          });
        }
        function m() {
          d.forEach(function(g) {
            return g();
          }), d = [];
        }
        return f;
      };
    }
    var v_ = [UE, s_, zE, Pm, o_, QE, c_, BE, t_], w_ = /* @__PURE__ */ y_({
      defaultModifiers: v_
    }), k_ = "tippy-box", qm = "tippy-content", E_ = "tippy-backdrop", Km = "tippy-arrow", Gm = "tippy-svg-arrow", Jr = {
      passive: true,
      capture: true
    }, jm = function() {
      return document.body;
    };
    function Fl(n3, e, t) {
      if (Array.isArray(n3)) {
        var r = n3[e];
        return r ?? (Array.isArray(t) ? t[e] : t);
      }
      return n3;
    }
    function Ru(n3, e) {
      var t = {}.toString.call(n3);
      return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1;
    }
    function Jm(n3, e) {
      return typeof n3 == "function" ? n3.apply(void 0, e) : n3;
    }
    function Tp(n3, e) {
      if (e === 0)
        return n3;
      var t;
      return function(r) {
        clearTimeout(t), t = setTimeout(function() {
          n3(r);
        }, e);
      };
    }
    function C_(n3) {
      return n3.split(/\s+/).filter(Boolean);
    }
    function No(n3) {
      return [].concat(n3);
    }
    function Op(n3, e) {
      n3.indexOf(e) === -1 && n3.push(e);
    }
    function x_(n3) {
      return n3.filter(function(e, t) {
        return n3.indexOf(e) === t;
      });
    }
    function T_(n3) {
      return n3.split("-")[0];
    }
    function pa(n3) {
      return [].slice.call(n3);
    }
    function Np(n3) {
      return Object.keys(n3).reduce(function(e, t) {
        return n3[t] !== void 0 && (e[t] = n3[t]), e;
      }, {});
    }
    function Si() {
      return document.createElement("div");
    }
    function Ui(n3) {
      return ["Element", "Fragment"].some(function(e) {
        return Ru(n3, e);
      });
    }
    function O_(n3) {
      return Ru(n3, "NodeList");
    }
    function N_(n3) {
      return Ru(n3, "MouseEvent");
    }
    function M_(n3) {
      return !!(n3 && n3._tippy && n3._tippy.reference === n3);
    }
    function A_(n3) {
      return Ui(n3) ? [n3] : O_(n3) ? pa(n3) : Array.isArray(n3) ? n3 : pa(document.querySelectorAll(n3));
    }
    function zl(n3, e) {
      n3.forEach(function(t) {
        t && (t.style.transitionDuration = e + "ms");
      });
    }
    function Mp(n3, e) {
      n3.forEach(function(t) {
        t && t.setAttribute("data-state", e);
      });
    }
    function R_(n3) {
      var e, t = No(n3), r = t[0];
      return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
    }
    function I_(n3, e) {
      var t = e.clientX, r = e.clientY;
      return n3.every(function(o) {
        var i = o.popperRect, s = o.popperState, a = o.props, l = a.interactiveBorder, c2 = T_(s.placement), u = s.modifiersData.offset;
        if (!u)
          return true;
        var d = c2 === "bottom" ? u.top.y : 0, p2 = c2 === "top" ? u.bottom.y : 0, f = c2 === "right" ? u.left.x : 0, h2 = c2 === "left" ? u.right.x : 0, m = i.top - r + d > l, g = r - i.bottom - p2 > l, b = i.left - t + f > l, w = t - i.right - h2 > l;
        return m || g || b || w;
      });
    }
    function Hl(n3, e, t) {
      var r = e + "EventListener";
      ["transitionend", "webkitTransitionEnd"].forEach(function(o) {
        n3[r](o, t);
      });
    }
    function Ap(n3, e) {
      for (var t = e; t; ) {
        var r;
        if (n3.contains(t))
          return true;
        t = t.getRootNode == null || (r = t.getRootNode()) == null ? void 0 : r.host;
      }
      return false;
    }
    var Kn = {
      isTouch: false
    }, Rp = 0;
    function D_() {
      Kn.isTouch || (Kn.isTouch = true, window.performance && document.addEventListener("mousemove", Ym));
    }
    function Ym() {
      var n3 = performance.now();
      n3 - Rp < 20 && (Kn.isTouch = false, document.removeEventListener("mousemove", Ym)), Rp = n3;
    }
    function L_() {
      var n3 = document.activeElement;
      if (M_(n3)) {
        var e = n3._tippy;
        n3.blur && !e.state.isVisible && n3.blur();
      }
    }
    function B_() {
      document.addEventListener("touchstart", D_, Jr), window.addEventListener("blur", L_);
    }
    var P_ = typeof window < "u" && typeof document < "u", $_ = P_ ? (
      // @ts-ignore
      !!window.msCrypto
    ) : false;
    var Zm = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    }, U_ = {
      allowHTML: false,
      animation: "fade",
      arrow: true,
      content: "",
      inertia: false,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999
    }, pn = Object.assign({
      appendTo: jm,
      aria: {
        content: "auto",
        expanded: "auto"
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function() {
      },
      onBeforeUpdate: function() {
      },
      onCreate: function() {
      },
      onDestroy: function() {
      },
      onHidden: function() {
      },
      onHide: function() {
      },
      onMount: function() {
      },
      onShow: function() {
      },
      onShown: function() {
      },
      onTrigger: function() {
      },
      onUntrigger: function() {
      },
      onClickOutside: function() {
      },
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: "mouseenter focus",
      triggerTarget: null
    }, Zm, U_), V_ = Object.keys(pn), W_ = function(e) {
      var t = Object.keys(e);
      t.forEach(function(r) {
        pn[r] = e[r];
      });
    };
    function Qm(n3) {
      var e = n3.plugins || [], t = e.reduce(function(r, o) {
        var i = o.name, s = o.defaultValue;
        if (i) {
          var a;
          r[i] = n3[i] !== void 0 ? n3[i] : (a = pn[i]) != null ? a : s;
        }
        return r;
      }, {});
      return Object.assign({}, n3, t);
    }
    function q_(n3, e) {
      var t = e ? Object.keys(Qm(Object.assign({}, pn, {
        plugins: e
      }))) : V_, r = t.reduce(function(o, i) {
        var s = (n3.getAttribute("data-tippy-" + i) || "").trim();
        if (!s)
          return o;
        if (i === "content")
          o[i] = s;
        else
          try {
            o[i] = JSON.parse(s);
          } catch {
            o[i] = s;
          }
        return o;
      }, {});
      return r;
    }
    function Dp(n3, e) {
      var t = Object.assign({}, e, {
        content: Jm(e.content, [n3])
      }, e.ignoreAttributes ? {} : q_(n3, e.plugins));
      return t.aria = Object.assign({}, pn.aria, t.aria), t.aria = {
        expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded,
        content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content
      }, t;
    }
    var K_ = function() {
      return "innerHTML";
    };
    function Rc(n3, e) {
      n3[K_()] = e;
    }
    function Lp(n3) {
      var e = Si();
      return n3 === true ? e.className = Km : (e.className = Gm, Ui(n3) ? e.appendChild(n3) : Rc(e, n3)), e;
    }
    function Bp(n3, e) {
      Ui(e.content) ? (Rc(n3, ""), n3.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Rc(n3, e.content) : n3.textContent = e.content);
    }
    function Ic(n3) {
      var e = n3.firstElementChild, t = pa(e.children);
      return {
        box: e,
        content: t.find(function(r) {
          return r.classList.contains(qm);
        }),
        arrow: t.find(function(r) {
          return r.classList.contains(Km) || r.classList.contains(Gm);
        }),
        backdrop: t.find(function(r) {
          return r.classList.contains(E_);
        })
      };
    }
    function tg(n3) {
      var e = Si(), t = Si();
      t.className = k_, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1");
      var r = Si();
      r.className = qm, r.setAttribute("data-state", "hidden"), Bp(r, n3.props), e.appendChild(t), t.appendChild(r), o(n3.props, n3.props);
      function o(i, s) {
        var a = Ic(e), l = a.box, c2 = a.content, u = a.arrow;
        s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (i.content !== s.content || i.allowHTML !== s.allowHTML) && Bp(c2, n3.props), s.arrow ? u ? i.arrow !== s.arrow && (l.removeChild(u), l.appendChild(Lp(s.arrow))) : l.appendChild(Lp(s.arrow)) : u && l.removeChild(u);
      }
      return {
        popper: e,
        onUpdate: o
      };
    }
    tg.$$tippy = true;
    var G_ = 1, Es = [], Ul = [];
    function j_(n3, e) {
      var t = Dp(n3, Object.assign({}, pn, Qm(Np(e)))), r, o, i, s = false, a = false, l = false, c2 = false, u, d, p2, f = [], h2 = Tp(ln, t.interactiveDebounce), m, g = G_++, b = null, w = x_(t.plugins), _ = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      }, v = {
        // properties
        id: g,
        reference: n3,
        popper: Si(),
        popperInstance: b,
        props: t,
        state: _,
        plugins: w,
        // methods
        clearDelayTimeouts: Kt,
        setProps: V,
        setContent: Y,
        show: Ee,
        hide: Ie,
        hideWithInteractivity: gt,
        enable: ft,
        disable: Rn,
        unmount: cn,
        destroy: ti
      };
      if (!t.render)
        return v;
      var T = t.render(v), S = T.popper, z = T.onUpdate;
      S.setAttribute("data-tippy-root", ""), S.id = "tippy-" + v.id, v.popper = S, n3._tippy = v, S._tippy = v;
      var U = w.map(function(N) {
        return N.fn(v);
      }), B = n3.hasAttribute("aria-expanded");
      return bn(), re(), M(), L("onCreate", [v]), t.showOnCreate && Re(), S.addEventListener("mouseenter", function() {
        v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
      }), S.addEventListener("mouseleave", function() {
        v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && we().addEventListener("mousemove", h2);
      }), v;
      function q() {
        var N = v.props.touch;
        return Array.isArray(N) ? N : [N, 0];
      }
      function oe() {
        return q()[0] === "hold";
      }
      function de() {
        var N;
        return !!((N = v.props.render) != null && N.$$tippy);
      }
      function ke() {
        return m || n3;
      }
      function we() {
        var N = ke().parentNode;
        return N ? R_(N) : document;
      }
      function fe() {
        return Ic(S);
      }
      function he(N) {
        return v.state.isMounted && !v.state.isVisible || Kn.isTouch || u && u.type === "focus" ? 0 : Fl(v.props.delay, N ? 0 : 1, pn.delay);
      }
      function M(N) {
        N === void 0 && (N = false), S.style.pointerEvents = v.props.interactive && !N ? "" : "none", S.style.zIndex = "" + v.props.zIndex;
      }
      function L(N, Q, pe) {
        if (pe === void 0 && (pe = true), U.forEach(function(Me) {
          Me[N] && Me[N].apply(Me, Q);
        }), pe) {
          var Pe;
          (Pe = v.props)[N].apply(Pe, Q);
        }
      }
      function J() {
        var N = v.props.aria;
        if (N.content) {
          var Q = "aria-" + N.content, pe = S.id, Pe = No(v.props.triggerTarget || n3);
          Pe.forEach(function(Me) {
            var Et = Me.getAttribute(Q);
            if (v.state.isVisible)
              Me.setAttribute(Q, Et ? Et + " " + pe : pe);
            else {
              var Gt = Et && Et.replace(pe, "").trim();
              Gt ? Me.setAttribute(Q, Gt) : Me.removeAttribute(Q);
            }
          });
        }
      }
      function re() {
        if (!(B || !v.props.aria.expanded)) {
          var N = No(v.props.triggerTarget || n3);
          N.forEach(function(Q) {
            v.props.interactive ? Q.setAttribute("aria-expanded", v.state.isVisible && Q === ke() ? "true" : "false") : Q.removeAttribute("aria-expanded");
          });
        }
      }
      function ce() {
        we().removeEventListener("mousemove", h2), Es = Es.filter(function(N) {
          return N !== h2;
        });
      }
      function Se(N) {
        if (!(Kn.isTouch && (l || N.type === "mousedown"))) {
          var Q = N.composedPath && N.composedPath()[0] || N.target;
          if (!(v.props.interactive && Ap(S, Q))) {
            if (No(v.props.triggerTarget || n3).some(function(pe) {
              return Ap(pe, Q);
            })) {
              if (Kn.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
                return;
            } else
              L("onClickOutside", [v, N]);
            v.props.hideOnClick === true && (v.clearDelayTimeouts(), v.hide(), a = true, setTimeout(function() {
              a = false;
            }), v.state.isMounted || et());
          }
        }
      }
      function Fe() {
        l = true;
      }
      function kt() {
        l = false;
      }
      function ze() {
        var N = we();
        N.addEventListener("mousedown", Se, true), N.addEventListener("touchend", Se, Jr), N.addEventListener("touchstart", kt, Jr), N.addEventListener("touchmove", Fe, Jr);
      }
      function et() {
        var N = we();
        N.removeEventListener("mousedown", Se, true), N.removeEventListener("touchend", Se, Jr), N.removeEventListener("touchstart", kt, Jr), N.removeEventListener("touchmove", Fe, Jr);
      }
      function an(N, Q) {
        gn(N, function() {
          !v.state.isVisible && S.parentNode && S.parentNode.contains(S) && Q();
        });
      }
      function Tt(N, Q) {
        gn(N, Q);
      }
      function gn(N, Q) {
        var pe = fe().box;
        function Pe(Me) {
          Me.target === pe && (Hl(pe, "remove", Pe), Q());
        }
        if (N === 0)
          return Q();
        Hl(pe, "remove", d), Hl(pe, "add", Pe), d = Pe;
      }
      function Ot(N, Q, pe) {
        pe === void 0 && (pe = false);
        var Pe = No(v.props.triggerTarget || n3);
        Pe.forEach(function(Me) {
          Me.addEventListener(N, Q, pe), f.push({
            node: Me,
            eventType: N,
            handler: Q,
            options: pe
          });
        });
      }
      function bn() {
        oe() && (Ot("touchstart", Mn, {
          passive: true
        }), Ot("touchend", An, {
          passive: true
        })), C_(v.props.trigger).forEach(function(N) {
          if (N !== "manual")
            switch (Ot(N, Mn), N) {
              case "mouseenter":
                Ot("mouseleave", An);
                break;
              case "focus":
                Ot($_ ? "focusout" : "blur", ve);
                break;
              case "focusin":
                Ot("focusout", ve);
                break;
            }
        });
      }
      function Fn() {
        f.forEach(function(N) {
          var Q = N.node, pe = N.eventType, Pe = N.handler, Me = N.options;
          Q.removeEventListener(pe, Pe, Me);
        }), f = [];
      }
      function Mn(N) {
        var Q, pe = false;
        if (!(!v.state.isEnabled || Qt(N) || a)) {
          var Pe = ((Q = u) == null ? void 0 : Q.type) === "focus";
          u = N, m = N.currentTarget, re(), !v.state.isVisible && N_(N) && Es.forEach(function(Me) {
            return Me(N);
          }), N.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || s) && v.props.hideOnClick !== false && v.state.isVisible ? pe = true : Re(N), N.type === "click" && (s = !pe), pe && !Pe && qt(N);
        }
      }
      function ln(N) {
        var Q = N.target, pe = ke().contains(Q) || S.contains(Q);
        if (!(N.type === "mousemove" && pe)) {
          var Pe = Ke().concat(S).map(function(Me) {
            var Et, Gt = Me._tippy, vr = (Et = Gt.popperInstance) == null ? void 0 : Et.state;
            return vr ? {
              popperRect: Me.getBoundingClientRect(),
              popperState: vr,
              props: t
            } : null;
          }).filter(Boolean);
          I_(Pe, N) && (ce(), qt(N));
        }
      }
      function An(N) {
        var Q = Qt(N) || v.props.trigger.indexOf("click") >= 0 && s;
        if (!Q) {
          if (v.props.interactive) {
            v.hideWithInteractivity(N);
            return;
          }
          qt(N);
        }
      }
      function ve(N) {
        v.props.trigger.indexOf("focusin") < 0 && N.target !== ke() || v.props.interactive && N.relatedTarget && S.contains(N.relatedTarget) || qt(N);
      }
      function Qt(N) {
        return Kn.isTouch ? oe() !== N.type.indexOf("touch") >= 0 : false;
      }
      function Pt() {
        le();
        var N = v.props, Q = N.popperOptions, pe = N.placement, Pe = N.offset, Me = N.getReferenceClientRect, Et = N.moveTransition, Gt = de() ? Ic(S).arrow : null, vr = Me ? {
          getBoundingClientRect: Me,
          contextElement: Me.contextElement || ke()
        } : n3, ni = {
          name: "$$tippy",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function(R) {
            var W = R.state;
            if (de()) {
              var me = fe(), ot = me.box;
              ["placement", "reference-hidden", "escaped"].forEach(function(tt) {
                tt === "placement" ? ot.setAttribute("data-placement", W.placement) : W.attributes.popper["data-popper-" + tt] ? ot.setAttribute("data-" + tt, "") : ot.removeAttribute("data-" + tt);
              }), W.attributes.popper = {};
            }
          }
        }, en = [{
          name: "offset",
          options: {
            offset: Pe
          }
        }, {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: "flip",
          options: {
            padding: 5
          }
        }, {
          name: "computeStyles",
          options: {
            adaptive: !Et
          }
        }, ni];
        de() && Gt && en.push({
          name: "arrow",
          options: {
            element: Gt,
            padding: 3
          }
        }), en.push.apply(en, (Q == null ? void 0 : Q.modifiers) || []), v.popperInstance = w_(vr, S, Object.assign({}, Q, {
          placement: pe,
          onFirstUpdate: p2,
          modifiers: en
        }));
      }
      function le() {
        v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
      }
      function Wt() {
        var N = v.props.appendTo, Q, pe = ke();
        v.props.interactive && N === jm || N === "parent" ? Q = pe.parentNode : Q = Jm(N, [pe]), Q.contains(S) || Q.appendChild(S), v.state.isMounted = true, Pt();
      }
      function Ke() {
        return pa(S.querySelectorAll("[data-tippy-root]"));
      }
      function Re(N) {
        v.clearDelayTimeouts(), N && L("onTrigger", [v, N]), ze();
        var Q = he(true), pe = q(), Pe = pe[0], Me = pe[1];
        Kn.isTouch && Pe === "hold" && Me && (Q = Me), Q ? r = setTimeout(function() {
          v.show();
        }, Q) : v.show();
      }
      function qt(N) {
        if (v.clearDelayTimeouts(), L("onUntrigger", [v, N]), !v.state.isVisible) {
          et();
          return;
        }
        if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(N.type) >= 0 && s)) {
          var Q = he(false);
          Q ? o = setTimeout(function() {
            v.state.isVisible && v.hide();
          }, Q) : i = requestAnimationFrame(function() {
            v.hide();
          });
        }
      }
      function ft() {
        v.state.isEnabled = true;
      }
      function Rn() {
        v.hide(), v.state.isEnabled = false;
      }
      function Kt() {
        clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
      }
      function V(N) {
        if (!v.state.isDestroyed) {
          L("onBeforeUpdate", [v, N]), Fn();
          var Q = v.props, pe = Dp(n3, Object.assign({}, Q, Np(N), {
            ignoreAttributes: true
          }));
          v.props = pe, bn(), Q.interactiveDebounce !== pe.interactiveDebounce && (ce(), h2 = Tp(ln, pe.interactiveDebounce)), Q.triggerTarget && !pe.triggerTarget ? No(Q.triggerTarget).forEach(function(Pe) {
            Pe.removeAttribute("aria-expanded");
          }) : pe.triggerTarget && n3.removeAttribute("aria-expanded"), re(), M(), z && z(Q, pe), v.popperInstance && (Pt(), Ke().forEach(function(Pe) {
            requestAnimationFrame(Pe._tippy.popperInstance.forceUpdate);
          })), L("onAfterUpdate", [v, N]);
        }
      }
      function Y(N) {
        v.setProps({
          content: N
        });
      }
      function Ee() {
        var N = v.state.isVisible, Q = v.state.isDestroyed, pe = !v.state.isEnabled, Pe = Kn.isTouch && !v.props.touch, Me = Fl(v.props.duration, 0, pn.duration);
        if (!(N || Q || pe || Pe) && !ke().hasAttribute("disabled") && (L("onShow", [v], false), v.props.onShow(v) !== false)) {
          if (v.state.isVisible = true, de() && (S.style.visibility = "visible"), M(), ze(), v.state.isMounted || (S.style.transition = "none"), de()) {
            var Et = fe(), Gt = Et.box, vr = Et.content;
            zl([Gt, vr], 0);
          }
          p2 = function() {
            var en;
            if (!(!v.state.isVisible || c2)) {
              if (c2 = true, S.offsetHeight, S.style.transition = v.props.moveTransition, de() && v.props.animation) {
                var k = fe(), R = k.box, W = k.content;
                zl([R, W], Me), Mp([R, W], "visible");
              }
              J(), re(), Op(Ul, v), (en = v.popperInstance) == null || en.forceUpdate(), L("onMount", [v]), v.props.animation && de() && Tt(Me, function() {
                v.state.isShown = true, L("onShown", [v]);
              });
            }
          }, Wt();
        }
      }
      function Ie() {
        var N = !v.state.isVisible, Q = v.state.isDestroyed, pe = !v.state.isEnabled, Pe = Fl(v.props.duration, 1, pn.duration);
        if (!(N || Q || pe) && (L("onHide", [v], false), v.props.onHide(v) !== false)) {
          if (v.state.isVisible = false, v.state.isShown = false, c2 = false, s = false, de() && (S.style.visibility = "hidden"), ce(), et(), M(true), de()) {
            var Me = fe(), Et = Me.box, Gt = Me.content;
            v.props.animation && (zl([Et, Gt], Pe), Mp([Et, Gt], "hidden"));
          }
          J(), re(), v.props.animation ? de() && an(Pe, v.unmount) : v.unmount();
        }
      }
      function gt(N) {
        we().addEventListener("mousemove", h2), Op(Es, h2), h2(N);
      }
      function cn() {
        v.state.isVisible && v.hide(), v.state.isMounted && (le(), Ke().forEach(function(N) {
          N._tippy.unmount();
        }), S.parentNode && S.parentNode.removeChild(S), Ul = Ul.filter(function(N) {
          return N !== v;
        }), v.state.isMounted = false, L("onHidden", [v]));
      }
      function ti() {
        !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), Fn(), delete n3._tippy, v.state.isDestroyed = true, L("onDestroy", [v]));
      }
    }
    function er(n3, e) {
      e === void 0 && (e = {});
      var t = pn.plugins.concat(e.plugins || []);
      B_();
      var r = Object.assign({}, e, {
        plugins: t
      }), o = A_(n3);
      var a = o.reduce(function(l, c2) {
        var u = c2 && j_(c2, r);
        return u && l.push(u), l;
      }, []);
      return Ui(n3) ? a[0] : a;
    }
    er.defaultProps = pn;
    er.setDefaultProps = W_;
    er.currentInput = Kn;
    Object.assign({}, Pm, {
      effect: function(e) {
        var t = e.state, r = {
          popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow);
      }
    });
    er.setDefaultProps({
      render: tg
    });
    class J_ {
      constructor({ editor: e, element: t, view: r, tippyOptions: o = {}, updateDelay: i = 250, shouldShow: s }) {
        this.preventHide = false, this.shouldShow = ({ view: a, state: l, from: c2, to: u }) => {
          const { doc: d, selection: p2 } = l, { empty: f } = p2, h2 = !d.textBetween(c2, u).length && rl(l.selection), m = this.element.contains(document.activeElement);
          return !(!(a.hasFocus() || m) || f || h2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.dragstartHandler = () => {
          this.hide();
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: a }) => {
          var l;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (a) => {
          this.blurHandler({ event: a });
        }, this.handleDebouncedUpdate = (a, l) => {
          const c2 = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
          !c2 && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, c2, u, l);
          }, this.updateDelay));
        }, this.updateHandler = (a, l, c2, u) => {
          var d, p2, f;
          const { state: h2, composing: m } = a, { selection: g } = h2;
          if (m || !l && !c2)
            return;
          this.createTooltip();
          const { ranges: w } = g, _ = Math.min(...w.map((S) => S.$from.pos)), v = Math.max(...w.map((S) => S.$to.pos));
          if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
            editor: this.editor,
            element: this.element,
            view: a,
            state: h2,
            oldState: u,
            from: _,
            to: v
          }))) {
            this.hide();
            return;
          }
          (p2 = this.tippy) === null || p2 === void 0 || p2.setProps({
            getReferenceClientRect: ((f = this.tippyOptions) === null || f === void 0 ? void 0 : f.getReferenceClientRect) || (() => {
              if (Im(h2.selection)) {
                let S = a.nodeDOM(_);
                if (S) {
                  const z = S.dataset.nodeViewWrapper ? S : S.querySelector("[data-node-view-wrapper]");
                  if (z && (S = z.firstChild), S)
                    return S.getBoundingClientRect();
                }
              }
              return Dm(a, _, v);
            })
          }), this.show();
        }, this.editor = e, this.element = t, this.view = r, this.updateDelay = i, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = er(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "top",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, t) {
        const { state: r } = e, o = r.selection.from !== r.selection.to;
        if (this.updateDelay > 0 && o) {
          this.handleDebouncedUpdate(e, t);
          return;
        }
        const i = !(t != null && t.selection.eq(e.state.selection)), s = !(t != null && t.doc.eq(e.state.doc));
        this.updateHandler(e, i, s, t);
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, t;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const ng = (n3) => new Ue({
      key: typeof n3.pluginKey == "string" ? new Ze(n3.pluginKey) : n3.pluginKey,
      view: (e) => new J_({ view: e, ...n3 })
    });
    qe.create({
      name: "bubbleMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "bubbleMenu",
          updateDelay: void 0,
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          ng({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    class Y_ {
      getTextContent(e) {
        return Am(e, { textSerializers: wu(this.editor.schema) });
      }
      constructor({ editor: e, element: t, view: r, tippyOptions: o = {}, shouldShow: i }) {
        this.preventHide = false, this.shouldShow = ({ view: s, state: a }) => {
          const { selection: l } = a, { $anchor: c2, empty: u } = l, d = c2.depth === 1, p2 = c2.parent.isTextblock && !c2.parent.type.spec.code && !c2.parent.textContent && c2.parent.childCount === 0 && !this.getTextContent(c2.parent);
          return !(!s.hasFocus() || !u || !d || !p2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: s }) => {
          var a;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (s) => {
          this.blurHandler({ event: s });
        }, this.editor = e, this.element = t, this.view = r, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = er(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "right",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, t) {
        var r, o, i;
        const { state: s } = e, { doc: a, selection: l } = s, { from: c2, to: u } = l;
        if (t && t.doc.eq(a) && t.selection.eq(l))
          return;
        if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, {
          editor: this.editor,
          view: e,
          state: s,
          oldState: t
        }))) {
          this.hide();
          return;
        }
        (o = this.tippy) === null || o === void 0 || o.setProps({
          getReferenceClientRect: ((i = this.tippyOptions) === null || i === void 0 ? void 0 : i.getReferenceClientRect) || (() => Dm(e, c2, u))
        }), this.show();
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, t;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const rg = (n3) => new Ue({
      key: typeof n3.pluginKey == "string" ? new Ze(n3.pluginKey) : n3.pluginKey,
      view: (e) => new Y_({ view: e, ...n3 })
    });
    qe.create({
      name: "floatingMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "floatingMenu",
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          rg({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    const X_ = /* @__PURE__ */ defineComponent({
      name: "BubbleMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "bubbleMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(n3, { slots: e }) {
        const t = ref(null);
        return onMounted(() => {
          const { updateDelay: r, editor: o, pluginKey: i, shouldShow: s, tippyOptions: a } = n3;
          o.registerPlugin(ng({
            updateDelay: r,
            editor: o,
            element: t.value,
            pluginKey: i,
            shouldShow: s,
            tippyOptions: a
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: r, editor: o } = n3;
          o.unregisterPlugin(r);
        }), () => {
          var r;
          return h("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
        };
      }
    });
    function Pp(n3) {
      return customRef((e, t) => ({
        get() {
          return e(), n3;
        },
        set(r) {
          n3 = r, requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              t();
            });
          });
        }
      }));
    }
    class Z_ extends Qn {
      constructor(e = {}) {
        return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = Pp(this.view.state), this.reactiveExtensionStorage = Pp(this.extensionStorage), this.on("beforeTransaction", ({ nextState: t }) => {
          this.reactiveState.value = t, this.reactiveExtensionStorage.value = this.extensionStorage;
        }), markRaw(this);
      }
      get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state;
      }
      get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
      }
      /**
       * Register a ProseMirror plugin.
       */
      registerPlugin(e, t) {
        const r = super.registerPlugin(e, t);
        return this.reactiveState && (this.reactiveState.value = r), r;
      }
      /**
       * Unregister a ProseMirror plugin.
       */
      unregisterPlugin(e) {
        const t = super.unregisterPlugin(e);
        return this.reactiveState && t && (this.reactiveState.value = t), t;
      }
    }
    const Q_ = /* @__PURE__ */ defineComponent({
      name: "EditorContent",
      props: {
        editor: {
          default: null,
          type: Object
        }
      },
      setup(n3) {
        const e = ref(), t = getCurrentInstance();
        return watchEffect(() => {
          const r = n3.editor;
          r && r.options.element && e.value && nextTick(() => {
            if (!e.value || !r.options.element.firstChild)
              return;
            const o = unref(e.value);
            e.value.append(...r.options.element.childNodes), r.contentComponent = t.ctx._, t && (r.appContext = {
              ...t.appContext,
              // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
              // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
              // @ts-expect-error forward instance's 'provides' into appContext
              provides: t.provides
            }), r.setOptions({
              element: o
            }), r.createNodeViews();
          });
        }), onBeforeUnmount(() => {
          const r = n3.editor;
          r && (r.contentComponent = null, r.appContext = null);
        }), { rootEl: e };
      },
      render() {
        return h("div", {
          ref: (n3) => {
            this.rootEl = n3;
          }
        });
      }
    }), eS = /* @__PURE__ */ defineComponent({
      name: "FloatingMenu",
      props: {
        pluginKey: {
          // TODO: TypeScript breaks :(
          // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
          type: null,
          default: "floatingMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(n3, { slots: e }) {
        const t = ref(null);
        return onMounted(() => {
          const { pluginKey: r, editor: o, tippyOptions: i, shouldShow: s } = n3;
          o.registerPlugin(rg({
            pluginKey: r,
            editor: o,
            element: t.value,
            tippyOptions: i,
            shouldShow: s
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: r, editor: o } = n3;
          o.unregisterPlugin(r);
        }), () => {
          var r;
          return h("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e));
        };
      }
    }), br = /* @__PURE__ */ defineComponent({
      name: "NodeViewContent",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      render() {
        return h(this.as, {
          style: {
            whiteSpace: "pre-wrap"
          },
          "data-node-view-content": ""
        });
      }
    }), Iu = /* @__PURE__ */ defineComponent({
      name: "NodeViewWrapper",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      inject: ["onDragStart", "decorationClasses"],
      render() {
        var n3, e;
        return h(this.as, {
          // @ts-ignore
          class: this.decorationClasses,
          style: {
            whiteSpace: "normal"
          },
          "data-node-view-wrapper": "",
          // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
          onDragstart: this.onDragStart
        }, (e = (n3 = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n3));
      }
    }), tS = (n3 = {}) => {
      const e = shallowRef();
      return onMounted(() => {
        e.value = new Z_(n3);
      }), onBeforeUnmount(() => {
        var t, r, o;
        const i = (t = e.value) === null || t === void 0 ? void 0 : t.options.element, s = i == null ? void 0 : i.cloneNode(true);
        (r = i == null ? void 0 : i.parentNode) === null || r === void 0 || r.replaceChild(s, i), (o = e.value) === null || o === void 0 || o.destroy();
      }), e;
    };
    class og {
      constructor(e, { props: t = {}, editor: r }) {
        this.editor = r, this.component = markRaw(e), this.el = document.createElement("div"), this.props = reactive(t), this.renderedComponent = this.renderComponent();
      }
      get element() {
        return this.renderedComponent.el;
      }
      get ref() {
        var e, t, r, o;
        return !((t = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || t === void 0) && t.exposed ? this.renderedComponent.vNode.component.exposed : (o = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || o === void 0 ? void 0 : o.proxy;
      }
      renderComponent() {
        let e = h(this.component, this.props);
        return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && render$1(e, this.el), { vNode: e, destroy: () => {
          this.el && render$1(null, this.el), this.el = null, e = null;
        }, el: this.el ? this.el.firstElementChild : null };
      }
      updateProps(e = {}) {
        Object.entries(e).forEach(([t, r]) => {
          this.props[t] = r;
        }), this.renderComponent();
      }
      destroy() {
        this.renderedComponent.destroy();
      }
    }
    const xt = {
      editor: {
        type: Object,
        required: true
      },
      node: {
        type: Object,
        required: true
      },
      decorations: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        required: true
      },
      extension: {
        type: Object,
        required: true
      },
      getPos: {
        type: Function,
        required: true
      },
      updateAttributes: {
        type: Function,
        required: true
      },
      deleteNode: {
        type: Function,
        required: true
      },
      view: {
        type: Object,
        required: true
      },
      innerDecorations: {
        type: Object,
        required: true
      },
      HTMLAttributes: {
        type: Object,
        required: true
      }
    };
    class nS extends hE {
      mount() {
        const e = {
          editor: this.editor,
          node: this.node,
          decorations: this.decorations,
          innerDecorations: this.innerDecorations,
          view: this.view,
          selected: false,
          extension: this.extension,
          HTMLAttributes: this.HTMLAttributes,
          getPos: () => this.getPos(),
          updateAttributes: (o = {}) => this.updateAttributes(o),
          deleteNode: () => this.deleteNode()
        }, t = this.onDragStart.bind(this);
        this.decorationClasses = ref(this.getDecorationClasses());
        const r = /* @__PURE__ */ defineComponent({
          extends: { ...this.component },
          props: Object.keys(e),
          template: this.component.template,
          setup: (o) => {
            var i, s;
            return provide("onDragStart", t), provide("decorationClasses", this.decorationClasses), (s = (i = this.component).setup) === null || s === void 0 ? void 0 : s.call(i, o, {
              expose: () => {
              }
            });
          },
          // add support for scoped styles
          // @ts-ignore
          // eslint-disable-next-line
          __scopeId: this.component.__scopeId,
          // add support for CSS Modules
          // @ts-ignore
          // eslint-disable-next-line
          __cssModules: this.component.__cssModules,
          // add support for vue devtools
          // @ts-ignore
          // eslint-disable-next-line
          __name: this.component.__name,
          // @ts-ignore
          // eslint-disable-next-line
          __file: this.component.__file
        });
        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new og(r, {
          editor: this.editor,
          props: e
        });
      }
      /**
       * Return the DOM element.
       * This is the element that will be used to display the node view.
       */
      get dom() {
        if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
          throw Error("Please use the NodeViewWrapper component for your node view.");
        return this.renderer.element;
      }
      /**
       * Return the content DOM element.
       * This is the element that will be used to display the rich-text content of the node.
       */
      get contentDOM() {
        return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
      }
      /**
       * On editor selection update, check if the node is selected.
       * If it is, call `selectNode`, otherwise call `deselectNode`.
       */
      handleSelectionUpdate() {
        const { from: e, to: t } = this.editor.state.selection, r = this.getPos();
        if (typeof r == "number")
          if (e <= r && t >= r + this.node.nodeSize) {
            if (this.renderer.props.selected)
              return;
            this.selectNode();
          } else {
            if (!this.renderer.props.selected)
              return;
            this.deselectNode();
          }
      }
      /**
       * On update, update the React component.
       * To prevent unnecessary updates, the `update` option can be used.
       */
      update(e, t, r) {
        const o = (i) => {
          this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(i);
        };
        if (typeof this.options.update == "function") {
          const i = this.node, s = this.decorations, a = this.innerDecorations;
          return this.node = e, this.decorations = t, this.innerDecorations = r, this.options.update({
            oldNode: i,
            oldDecorations: s,
            newNode: e,
            newDecorations: t,
            oldInnerDecorations: a,
            innerDecorations: r,
            updateProps: () => o({ node: e, decorations: t, innerDecorations: r })
          });
        }
        return e.type !== this.node.type ? false : (e === this.node && this.decorations === t && this.innerDecorations === r || (this.node = e, this.decorations = t, this.innerDecorations = r, o({ node: e, decorations: t, innerDecorations: r })), true);
      }
      /**
       * Select the node.
       * Add the `selected` prop and the `ProseMirror-selectednode` class.
       */
      selectNode() {
        this.renderer.updateProps({
          selected: true
        }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
      }
      /**
       * Deselect the node.
       * Remove the `selected` prop and the `ProseMirror-selectednode` class.
       */
      deselectNode() {
        this.renderer.updateProps({
          selected: false
        }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
      }
      getDecorationClasses() {
        return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
      }
      destroy() {
        this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
      }
    }
    function Bn(n3, e) {
      return (t) => {
        if (!t.editor.contentComponent)
          return {};
        const r = typeof n3 == "function" && "__vccOpts" in n3 ? n3.__vccOpts : n3;
        return new nS(r, t, e);
      };
    }
    const rS = /^\s*>\s$/, ig = st.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["blockquote", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: n3 }) => n3.wrapIn(this.name),
          toggleBlockquote: () => ({ commands: n3 }) => n3.toggleWrap(this.name),
          unsetBlockquote: () => ({ commands: n3 }) => n3.lift(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          Wo({
            find: rS,
            type: this.type
          })
        ];
      }
    }), oS = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, iS = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, sS = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, aS = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, lS = Cn.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (n3) => n3.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (n3) => n3.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (n3) => /^(bold(er)?|[5-9]\d{2,})$/.test(n3) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["strong", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: n3 }) => n3.setMark(this.name),
          toggleBold: () => ({ commands: n3 }) => n3.toggleMark(this.name),
          unsetBold: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          ho({
            find: oS,
            type: this.type
          }),
          ho({
            find: sS,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Hr({
            find: iS,
            type: this.type
          }),
          Hr({
            find: aS,
            type: this.type
          })
        ];
      }
    }), cS = "listItem", $p = "textStyle", Fp = /^\s*([-+*])\s$/, uS = st.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["ul", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: n3, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(cS, this.editor.getAttributes($p)).run() : n3.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let n3 = Wo({
          find: Fp,
          type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (n3 = Wo({
          find: Fp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => this.editor.getAttributes($p),
          editor: this.editor
        })), [
          n3
        ];
      }
    }), dS = /(^|[^`])`([^`]+)`(?!`)/, pS = /(^|[^`])`([^`]+)`(?!`)/g, fS = Cn.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["code", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: n3 }) => n3.setMark(this.name),
          toggleCode: () => ({ commands: n3 }) => n3.toggleMark(this.name),
          unsetCode: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          ho({
            find: dS,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Hr({
            find: pS,
            type: this.type
          })
        ];
      }
    }), hS = /^```([a-z]+)?[\s\n]$/, mS = /^~~~([a-z]+)?[\s\n]$/, sg = st.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (n3) => {
              var e;
              const { languageClassPrefix: t } = this.options, i = [...((e = n3.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((s) => s.startsWith(t)).map((s) => s.replace(t, ""))[0];
              return i || null;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        return [
          "pre",
          $e(this.options.HTMLAttributes, e),
          [
            "code",
            {
              class: n3.attrs.language ? this.options.languageClassPrefix + n3.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (n3) => ({ commands: e }) => e.setNode(this.name, n3),
          toggleCodeBlock: (n3) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n3)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: n3, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
            return !n3 || e.parent.type.name !== this.name ? false : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
          },
          // exit node on triple enter
          Enter: ({ editor: n3 }) => {
            if (!this.options.exitOnTripleEnter)
              return false;
            const { state: e } = n3, { selection: t } = e, { $from: r, empty: o } = t;
            if (!o || r.parent.type !== this.type)
              return false;
            const i = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
            return !i || !s ? false : n3.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), true)).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor: n3 }) => {
            if (!this.options.exitOnArrowDown)
              return false;
            const { state: e } = n3, { selection: t, doc: r } = e, { $from: o, empty: i } = t;
            if (!i || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
              return false;
            const a = o.after();
            return a === void 0 ? false : r.nodeAt(a) ? n3.commands.command(({ tr: c2 }) => (c2.setSelection(ue.near(r.resolve(a))), true)) : n3.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          Oc({
            find: hS,
            type: this.type,
            getAttributes: (n3) => ({
              language: n3[1]
            })
          }),
          Oc({
            find: mS,
            type: this.type,
            getAttributes: (n3) => ({
              language: n3[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new Ue({
            key: new Ze("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (n3, e) => {
                if (!e.clipboardData || this.editor.isActive(this.type.name))
                  return false;
                const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), o = r ? JSON.parse(r) : void 0, i = o == null ? void 0 : o.mode;
                if (!t || !i)
                  return false;
                const { tr: s, schema: a } = n3.state, l = a.text(t.replace(/\r\n?/g, `
`));
                return s.replaceSelectionWith(this.type.create({ language: i }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(ie.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", true), n3.dispatch(s), true;
              }
            }
          })
        ];
      }
    }), gS = st.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    function bS(n3 = {}) {
      return new Ue({
        view(e) {
          return new yS(e, n3);
        }
      });
    }
    class yS {
      constructor(e, t) {
        var r;
        this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === false ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
          let i = (s) => {
            this[o](s);
          };
          return e.dom.addEventListener(o, i), { name: o, handler: i };
        });
      }
      destroy() {
        this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
      }
      update(e, t) {
        this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
      }
      setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
      }
      updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r;
        if (t) {
          let a = e.nodeBefore, l = e.nodeAfter;
          if (a || l) {
            let c2 = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
            if (c2) {
              let u = c2.getBoundingClientRect(), d = a ? u.bottom : u.top;
              a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
            }
          }
        }
        if (!r) {
          let a = this.editorView.coordsAtPos(this.cursorPos);
          r = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
        }
        let o = this.editorView.dom.offsetParent;
        this.element || (this.element = o.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
        let i, s;
        if (!o || o == document.body && getComputedStyle(o).position == "static")
          i = -pageXOffset, s = -pageYOffset;
        else {
          let a = o.getBoundingClientRect();
          i = a.left - o.scrollLeft, s = a.top - o.scrollTop;
        }
        this.element.style.left = r.left - i + "px", this.element.style.top = r.top - s + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
      }
      scheduleRemoval(e) {
        clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
      }
      dragover(e) {
        if (!this.editorView.editable)
          return;
        let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), o = r && r.type.spec.disableDropCursor, i = typeof o == "function" ? o(this.editorView, t, e) : o;
        if (t && !i) {
          let s = t.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let a = $y(this.editorView.state.doc, s, this.editorView.dragging.slice);
            a != null && (s = a);
          }
          this.setCursor(s), this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
      }
    }
    const vS = qe.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          bS(this.options)
        ];
      }
    });
    class ut extends ue {
      /**
      Create a gap cursor.
      */
      constructor(e) {
        super(e, e);
      }
      map(e, t) {
        let r = e.resolve(t.map(this.head));
        return ut.valid(r) ? new ut(r) : ue.near(r);
      }
      content() {
        return I.empty;
      }
      eq(e) {
        return e instanceof ut && e.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new ut(e.resolve(t.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new Du(this.anchor);
      }
      /**
      @internal
      */
      static valid(e) {
        let t = e.parent;
        if (t.isTextblock || !wS(e) || !kS(e))
          return false;
        let r = t.type.spec.allowGapCursor;
        if (r != null)
          return r;
        let o = t.contentMatchAt(e.index()).defaultType;
        return o && o.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom(e, t, r = false) {
        e: for (; ; ) {
          if (!r && ut.valid(e))
            return e;
          let o = e.pos, i = null;
          for (let s = e.depth; ; s--) {
            let a = e.node(s);
            if (t > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
              i = a.child(t > 0 ? e.indexAfter(s) : e.index(s) - 1);
              break;
            } else if (s == 0)
              return null;
            o += t;
            let l = e.doc.resolve(o);
            if (ut.valid(l))
              return l;
          }
          for (; ; ) {
            let s = t > 0 ? i.firstChild : i.lastChild;
            if (!s) {
              if (i.isAtom && !i.isText && !ne.isSelectable(i)) {
                e = e.doc.resolve(o + i.nodeSize * t), r = false;
                continue e;
              }
              break;
            }
            i = s, o += t;
            let a = e.doc.resolve(o);
            if (ut.valid(a))
              return a;
          }
          return null;
        }
      }
    }
    ut.prototype.visible = false;
    ut.findFrom = ut.findGapCursorFrom;
    ue.jsonID("gapcursor", ut);
    class Du {
      constructor(e) {
        this.pos = e;
      }
      map(e) {
        return new Du(e.map(this.pos));
      }
      resolve(e) {
        let t = e.resolve(this.pos);
        return ut.valid(t) ? new ut(t) : ue.near(t);
      }
    }
    function wS(n3) {
      for (let e = n3.depth; e >= 0; e--) {
        let t = n3.index(e), r = n3.node(e);
        if (t == 0) {
          if (r.type.spec.isolating)
            return true;
          continue;
        }
        for (let o = r.child(t - 1); ; o = o.lastChild) {
          if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
            return true;
          if (o.inlineContent)
            return false;
        }
      }
      return true;
    }
    function kS(n3) {
      for (let e = n3.depth; e >= 0; e--) {
        let t = n3.indexAfter(e), r = n3.node(e);
        if (t == r.childCount) {
          if (r.type.spec.isolating)
            return true;
          continue;
        }
        for (let o = r.child(t); ; o = o.firstChild) {
          if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
            return true;
          if (o.inlineContent)
            return false;
        }
      }
      return true;
    }
    function ES() {
      return new Ue({
        props: {
          decorations: xS,
          createSelectionBetween(n3, e, t) {
            return e.pos == t.pos && ut.valid(t) ? new ut(t) : null;
          },
          handleClick: SS,
          handleKeyDown: _S,
          handleDOMEvents: { beforeinput: CS }
        }
      });
    }
    const _S = pu({
      ArrowLeft: _s("horiz", -1),
      ArrowRight: _s("horiz", 1),
      ArrowUp: _s("vert", -1),
      ArrowDown: _s("vert", 1)
    });
    function _s(n3, e) {
      const t = n3 == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
      return function(r, o, i) {
        let s = r.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
        if (s instanceof ie) {
          if (!i.endOfTextblock(t) || a.depth == 0)
            return false;
          l = false, a = r.doc.resolve(e > 0 ? a.after() : a.before());
        }
        let c2 = ut.findGapCursorFrom(a, e, l);
        return c2 ? (o && o(r.tr.setSelection(new ut(c2))), true) : false;
      };
    }
    function SS(n3, e, t) {
      if (!n3 || !n3.editable)
        return false;
      let r = n3.state.doc.resolve(e);
      if (!ut.valid(r))
        return false;
      let o = n3.posAtCoords({ left: t.clientX, top: t.clientY });
      return o && o.inside > -1 && ne.isSelectable(n3.state.doc.nodeAt(o.inside)) ? false : (n3.dispatch(n3.state.tr.setSelection(new ut(r))), true);
    }
    function CS(n3, e) {
      if (e.inputType != "insertCompositionText" || !(n3.state.selection instanceof ut))
        return false;
      let { $from: t } = n3.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n3.state.schema.nodes.text);
      if (!r)
        return false;
      let o = O.empty;
      for (let s = r.length - 1; s >= 0; s--)
        o = O.from(r[s].createAndFill(null, o));
      let i = n3.state.tr.replace(t.pos, t.pos, new I(o, 0, 0));
      return i.setSelection(ie.near(i.doc.resolve(t.pos + 1))), n3.dispatch(i), false;
    }
    function xS(n3) {
      if (!(n3.selection instanceof ut))
        return null;
      let e = document.createElement("div");
      return e.className = "ProseMirror-gapcursor", He.create(n3.doc, [ht.widget(n3.selection.head, e, { key: "gapcursor" })]);
    }
    const TS = qe.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          ES()
        ];
      },
      extendNodeSchema(n3) {
        var e;
        const t = {
          name: n3.name,
          options: n3.options,
          storage: n3.storage
        };
        return {
          allowGapCursor: (e = Te(Z(n3, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
        };
      }
    }), OS = st.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["br", $e(this.options.HTMLAttributes, n3)];
      },
      renderText() {
        return `
`;
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: n3, chain: e, state: t, editor: r }) => n3.first([
            () => n3.exitCode(),
            () => n3.command(() => {
              const { selection: o, storedMarks: i } = t;
              if (o.$from.parent.type.spec.isolating)
                return false;
              const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = i || o.$to.parentOffset && o.$from.marks();
              return e().insertContent({ type: this.name }).command(({ tr: c2, dispatch: u }) => {
                if (u && l && s) {
                  const d = l.filter((p2) => a.includes(p2.type.name));
                  c2.ensureMarks(d);
                }
                return true;
              }).run();
            })
          ])
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    }), ag = st.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((n3) => ({
          tag: `h${n3}`,
          attrs: { level: n3 }
        }));
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        return [`h${this.options.levels.includes(n3.attrs.level) ? n3.attrs.level : this.options.levels[0]}`, $e(this.options.HTMLAttributes, e), 0];
      },
      addCommands() {
        return {
          setHeading: (n3) => ({ commands: e }) => this.options.levels.includes(n3.level) ? e.setNode(this.name, n3) : false,
          toggleHeading: (n3) => ({ commands: e }) => this.options.levels.includes(n3.level) ? e.toggleNode(this.name, "paragraph", n3) : false
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((n3, e) => ({
          ...n3,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((n3) => Oc({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n3}})\\s$`),
          type: this.type,
          getAttributes: {
            level: n3
          }
        }));
      }
    });
    var fa = 200, St = function() {
    };
    St.prototype.append = function(e) {
      return e.length ? (e = St.from(e), !this.length && e || e.length < fa && this.leafAppend(e) || this.length < fa && e.leafPrepend(this) || this.appendInner(e)) : this;
    };
    St.prototype.prepend = function(e) {
      return e.length ? St.from(e).append(this) : this;
    };
    St.prototype.appendInner = function(e) {
      return new NS(this, e);
    };
    St.prototype.slice = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? St.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
    };
    St.prototype.get = function(e) {
      if (!(e < 0 || e >= this.length))
        return this.getInner(e);
    };
    St.prototype.forEach = function(e, t, r) {
      t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
    };
    St.prototype.map = function(e, t, r) {
      t === void 0 && (t = 0), r === void 0 && (r = this.length);
      var o = [];
      return this.forEach(function(i, s) {
        return o.push(e(i, s));
      }, t, r), o;
    };
    St.from = function(e) {
      return e instanceof St ? e : e && e.length ? new lg(e) : St.empty;
    };
    var lg = /* @__PURE__ */ function(n3) {
      function e(r) {
        n3.call(this), this.values = r;
      }
      n3 && (e.__proto__ = n3), e.prototype = Object.create(n3 && n3.prototype), e.prototype.constructor = e;
      var t = { length: { configurable: true }, depth: { configurable: true } };
      return e.prototype.flatten = function() {
        return this.values;
      }, e.prototype.sliceInner = function(o, i) {
        return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
      }, e.prototype.getInner = function(o) {
        return this.values[o];
      }, e.prototype.forEachInner = function(o, i, s, a) {
        for (var l = i; l < s; l++)
          if (o(this.values[l], a + l) === false)
            return false;
      }, e.prototype.forEachInvertedInner = function(o, i, s, a) {
        for (var l = i - 1; l >= s; l--)
          if (o(this.values[l], a + l) === false)
            return false;
      }, e.prototype.leafAppend = function(o) {
        if (this.length + o.length <= fa)
          return new e(this.values.concat(o.flatten()));
      }, e.prototype.leafPrepend = function(o) {
        if (this.length + o.length <= fa)
          return new e(o.flatten().concat(this.values));
      }, t.length.get = function() {
        return this.values.length;
      }, t.depth.get = function() {
        return 0;
      }, Object.defineProperties(e.prototype, t), e;
    }(St);
    St.empty = new lg([]);
    var NS = /* @__PURE__ */ function(n3) {
      function e(t, r) {
        n3.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
      }
      return n3 && (e.__proto__ = n3), e.prototype = Object.create(n3 && n3.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten());
      }, e.prototype.getInner = function(r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
      }, e.prototype.forEachInner = function(r, o, i, s) {
        var a = this.left.length;
        if (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === false || i > a && this.right.forEachInner(r, Math.max(o - a, 0), Math.min(this.length, i) - a, s + a) === false)
          return false;
      }, e.prototype.forEachInvertedInner = function(r, o, i, s) {
        var a = this.left.length;
        if (o > a && this.right.forEachInvertedInner(r, o - a, Math.max(i, a) - a, s + a) === false || i < a && this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === false)
          return false;
      }, e.prototype.sliceInner = function(r, o) {
        if (r == 0 && o == this.length)
          return this;
        var i = this.left.length;
        return o <= i ? this.left.slice(r, o) : r >= i ? this.right.slice(r - i, o - i) : this.left.slice(r, i).append(this.right.slice(0, o - i));
      }, e.prototype.leafAppend = function(r) {
        var o = this.right.leafAppend(r);
        if (o)
          return new e(this.left, o);
      }, e.prototype.leafPrepend = function(r) {
        var o = this.left.leafPrepend(r);
        if (o)
          return new e(o, this.right);
      }, e.prototype.appendInner = function(r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
      }, e;
    }(St);
    const MS = 500;
    class Dn {
      constructor(e, t) {
        this.items = e, this.eventCount = t;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(e, t) {
        if (this.eventCount == 0)
          return null;
        let r = this.items.length;
        for (; ; r--)
          if (this.items.get(r - 1).selection) {
            --r;
            break;
          }
        let o, i;
        t && (o = this.remapping(r, this.items.length), i = o.maps.length);
        let s = e.tr, a, l, c2 = [], u = [];
        return this.items.forEach((d, p2) => {
          if (!d.step) {
            o || (o = this.remapping(r, p2 + 1), i = o.maps.length), i--, u.push(d);
            return;
          }
          if (o) {
            u.push(new Vn(d.map));
            let f = d.step.map(o.slice(i)), h2;
            f && s.maybeStep(f).doc && (h2 = s.mapping.maps[s.mapping.maps.length - 1], c2.push(new Vn(h2, void 0, void 0, c2.length + u.length))), i--, h2 && o.appendMap(h2, i);
          } else
            s.maybeStep(d.step);
          if (d.selection)
            return a = o ? d.selection.map(o.slice(i)) : d.selection, l = new Dn(this.items.slice(0, r).append(u.reverse().concat(c2)), this.eventCount - 1), false;
        }, this.items.length, 0), { remaining: l, transform: s, selection: a };
      }
      // Create a new branch with the given transform added.
      addTransform(e, t, r, o) {
        let i = [], s = this.eventCount, a = this.items, l = !o && a.length ? a.get(a.length - 1) : null;
        for (let u = 0; u < e.steps.length; u++) {
          let d = e.steps[u].invert(e.docs[u]), p2 = new Vn(e.mapping.maps[u], d, t), f;
          (f = l && l.merge(p2)) && (p2 = f, u ? i.pop() : a = a.slice(0, a.length - 1)), i.push(p2), t && (s++, t = void 0), o || (l = p2);
        }
        let c2 = s - r.depth;
        return c2 > RS && (a = AS(a, c2), s -= c2), new Dn(a.append(i), s);
      }
      remapping(e, t) {
        let r = new Bo();
        return this.items.forEach((o, i) => {
          let s = o.mirrorOffset != null && i - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
          r.appendMap(o.map, s);
        }, e, t), r;
      }
      addMaps(e) {
        return this.eventCount == 0 ? this : new Dn(this.items.append(e.map((t) => new Vn(t))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(e, t) {
        if (!this.eventCount)
          return this;
        let r = [], o = Math.max(0, this.items.length - t), i = e.mapping, s = e.steps.length, a = this.eventCount;
        this.items.forEach((p2) => {
          p2.selection && a--;
        }, o);
        let l = t;
        this.items.forEach((p2) => {
          let f = i.getMirror(--l);
          if (f == null)
            return;
          s = Math.min(s, f);
          let h2 = i.maps[f];
          if (p2.step) {
            let m = e.steps[f].invert(e.docs[f]), g = p2.selection && p2.selection.map(i.slice(l + 1, f));
            g && a++, r.push(new Vn(h2, m, g));
          } else
            r.push(new Vn(h2));
        }, o);
        let c2 = [];
        for (let p2 = t; p2 < s; p2++)
          c2.push(new Vn(i.maps[p2]));
        let u = this.items.slice(0, o).append(c2).append(r), d = new Dn(u, a);
        return d.emptyItemCount() > MS && (d = d.compress(this.items.length - r.length)), d;
      }
      emptyItemCount() {
        let e = 0;
        return this.items.forEach((t) => {
          t.step || e++;
        }), e;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(e = this.items.length) {
        let t = this.remapping(0, e), r = t.maps.length, o = [], i = 0;
        return this.items.forEach((s, a) => {
          if (a >= e)
            o.push(s), s.selection && i++;
          else if (s.step) {
            let l = s.step.map(t.slice(r)), c2 = l && l.getMap();
            if (r--, c2 && t.appendMap(c2, r), l) {
              let u = s.selection && s.selection.map(t.slice(r));
              u && i++;
              let d = new Vn(c2.invert(), l, u), p2, f = o.length - 1;
              (p2 = o.length && o[f].merge(d)) ? o[f] = p2 : o.push(d);
            }
          } else s.map && r--;
        }, this.items.length, 0), new Dn(St.from(o.reverse()), i);
      }
    }
    Dn.empty = new Dn(St.empty, 0);
    function AS(n3, e) {
      let t;
      return n3.forEach((r, o) => {
        if (r.selection && e-- == 0)
          return t = o, false;
      }), n3.slice(t);
    }
    class Vn {
      constructor(e, t, r, o) {
        this.map = e, this.step = t, this.selection = r, this.mirrorOffset = o;
      }
      merge(e) {
        if (this.step && e.step && !e.selection) {
          let t = e.step.merge(this.step);
          if (t)
            return new Vn(t.getMap().invert(), t, this.selection);
        }
      }
    }
    class Cr {
      constructor(e, t, r, o, i) {
        this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = o, this.prevComposition = i;
      }
    }
    const RS = 20;
    function IS(n3, e, t, r) {
      let o = t.getMeta(so), i;
      if (o)
        return o.historyState;
      t.getMeta(BS) && (n3 = new Cr(n3.done, n3.undone, null, 0, -1));
      let s = t.getMeta("appendedTransaction");
      if (t.steps.length == 0)
        return n3;
      if (s && s.getMeta(so))
        return s.getMeta(so).redo ? new Cr(n3.done.addTransform(t, void 0, r, js(e)), n3.undone, zp(t.mapping.maps), n3.prevTime, n3.prevComposition) : new Cr(n3.done, n3.undone.addTransform(t, void 0, r, js(e)), null, n3.prevTime, n3.prevComposition);
      if (t.getMeta("addToHistory") !== false && !(s && s.getMeta("addToHistory") === false)) {
        let a = t.getMeta("composition"), l = n3.prevTime == 0 || !s && n3.prevComposition != a && (n3.prevTime < (t.time || 0) - r.newGroupDelay || !DS(t, n3.prevRanges)), c2 = s ? Vl(n3.prevRanges, t.mapping) : zp(t.mapping.maps);
        return new Cr(n3.done.addTransform(t, l ? e.selection.getBookmark() : void 0, r, js(e)), Dn.empty, c2, t.time, a ?? n3.prevComposition);
      } else return (i = t.getMeta("rebased")) ? new Cr(n3.done.rebased(t, i), n3.undone.rebased(t, i), Vl(n3.prevRanges, t.mapping), n3.prevTime, n3.prevComposition) : new Cr(n3.done.addMaps(t.mapping.maps), n3.undone.addMaps(t.mapping.maps), Vl(n3.prevRanges, t.mapping), n3.prevTime, n3.prevComposition);
    }
    function DS(n3, e) {
      if (!e)
        return false;
      if (!n3.docChanged)
        return true;
      let t = false;
      return n3.mapping.maps[0].forEach((r, o) => {
        for (let i = 0; i < e.length; i += 2)
          r <= e[i + 1] && o >= e[i] && (t = true);
      }), t;
    }
    function zp(n3) {
      let e = [];
      for (let t = n3.length - 1; t >= 0 && e.length == 0; t--)
        n3[t].forEach((r, o, i, s) => e.push(i, s));
      return e;
    }
    function Vl(n3, e) {
      if (!n3)
        return null;
      let t = [];
      for (let r = 0; r < n3.length; r += 2) {
        let o = e.map(n3[r], 1), i = e.map(n3[r + 1], -1);
        o <= i && t.push(o, i);
      }
      return t;
    }
    function LS(n3, e, t) {
      let r = js(e), o = so.get(e).spec.config, i = (t ? n3.undone : n3.done).popEvent(e, r);
      if (!i)
        return null;
      let s = i.selection.resolve(i.transform.doc), a = (t ? n3.done : n3.undone).addTransform(i.transform, e.selection.getBookmark(), o, r), l = new Cr(t ? a : i.remaining, t ? i.remaining : a, null, 0, -1);
      return i.transform.setSelection(s).setMeta(so, { redo: t, historyState: l });
    }
    let Wl = false, Hp = null;
    function js(n3) {
      let e = n3.plugins;
      if (Hp != e) {
        Wl = false, Hp = e;
        for (let t = 0; t < e.length; t++)
          if (e[t].spec.historyPreserveItems) {
            Wl = true;
            break;
          }
      }
      return Wl;
    }
    const so = new Ze("history"), BS = new Ze("closeHistory");
    function PS(n3 = {}) {
      return n3 = {
        depth: n3.depth || 100,
        newGroupDelay: n3.newGroupDelay || 500
      }, new Ue({
        key: so,
        state: {
          init() {
            return new Cr(Dn.empty, Dn.empty, null, 0, -1);
          },
          apply(e, t, r) {
            return IS(t, r, e, n3);
          }
        },
        config: n3,
        props: {
          handleDOMEvents: {
            beforeinput(e, t) {
              let r = t.inputType, o = r == "historyUndo" ? ug : r == "historyRedo" ? dg : null;
              return o ? (t.preventDefault(), o(e.state, e.dispatch)) : false;
            }
          }
        }
      });
    }
    function cg(n3, e) {
      return (t, r) => {
        let o = so.getState(t);
        if (!o || (n3 ? o.undone : o.done).eventCount == 0)
          return false;
        if (r) {
          let i = LS(o, t, n3);
          i && r(i.scrollIntoView());
        }
        return true;
      };
    }
    const ug = cg(false), dg = cg(true), $S = qe.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state: n3, dispatch: e }) => ug(n3, e),
          redo: () => ({ state: n3, dispatch: e }) => dg(n3, e)
        };
      },
      addProseMirrorPlugins() {
        return [
          PS(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-": () => this.editor.commands.undo(),
          "Shift-Mod-": () => this.editor.commands.redo()
        };
      }
    }), pg = st.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["hr", $e(this.options.HTMLAttributes, n3)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain: n3, state: e }) => {
            const { selection: t } = e, { $from: r, $to: o } = t, i = n3();
            return r.parentOffset === 0 ? i.insertContentAt({
              from: Math.max(r.pos - 1, 0),
              to: o.pos
            }, {
              type: this.name
            }) : Im(t) ? i.insertContentAt(o.pos, {
              type: this.name
            }) : i.insertContent({ type: this.name }), i.command(({ tr: s, dispatch: a }) => {
              var l;
              if (a) {
                const { $to: c2 } = s.selection, u = c2.end();
                if (c2.nodeAfter)
                  c2.nodeAfter.isTextblock ? s.setSelection(ie.create(s.doc, c2.pos + 1)) : c2.nodeAfter.isBlock ? s.setSelection(ne.create(s.doc, c2.pos)) : s.setSelection(ie.create(s.doc, c2.pos));
                else {
                  const d = (l = c2.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                  d && (s.insert(u, d), s.setSelection(ie.create(s.doc, u + 1)));
                }
                s.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          Su({
            find: /^(?:---|-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    }), FS = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, zS = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, HS = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, US = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, VS = Cn.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (n3) => n3.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (n3) => n3.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["em", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: n3 }) => n3.setMark(this.name),
          toggleItalic: () => ({ commands: n3 }) => n3.toggleMark(this.name),
          unsetItalic: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          ho({
            find: FS,
            type: this.type
          }),
          ho({
            find: HS,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Hr({
            find: zS,
            type: this.type
          }),
          Hr({
            find: US,
            type: this.type
          })
        ];
      }
    }), WS = st.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["li", $e(this.options.HTMLAttributes, n3), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    }), qS = "listItem", Up = "textStyle", Vp = /^(\d+)\.\s$/, KS = st.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (n3) => n3.hasAttribute("start") ? parseInt(n3.getAttribute("start") || "", 10) : 1
          },
          type: {
            default: void 0,
            parseHTML: (n3) => n3.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        const { start: e, ...t } = n3;
        return e === 1 ? ["ol", $e(this.options.HTMLAttributes, t), 0] : ["ol", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: n3, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(qS, this.editor.getAttributes(Up)).run() : n3.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let n3 = Wo({
          find: Vp,
          type: this.type,
          getAttributes: (e) => ({ start: +e[1] }),
          joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (n3 = Wo({
          find: Vp,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Up) }),
          joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
          editor: this.editor
        })), [
          n3
        ];
      }
    }), fg = st.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["p", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: n3 }) => n3.setNode(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    }), GS = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, jS = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, JS = Cn.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (n3) => n3.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["s", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: n3 }) => n3.setMark(this.name),
          toggleStrike: () => ({ commands: n3 }) => n3.toggleMark(this.name),
          unsetStrike: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          ho({
            find: GS,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Hr({
            find: jS,
            type: this.type
          })
        ];
      }
    }), YS = st.create({
      name: "text",
      group: "inline"
    }), XS = qe.create({
      name: "starterKit",
      addExtensions() {
        var n3, e, t, r, o, i, s, a, l, c2, u, d, p2, f, h2, m, g, b;
        const w = [];
        return this.options.bold !== false && w.push(lS.configure((n3 = this.options) === null || n3 === void 0 ? void 0 : n3.bold)), this.options.blockquote !== false && w.push(ig.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && w.push(uS.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== false && w.push(fS.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)), this.options.codeBlock !== false && w.push(sg.configure((o = this.options) === null || o === void 0 ? void 0 : o.codeBlock)), this.options.document !== false && w.push(gS.configure((i = this.options) === null || i === void 0 ? void 0 : i.document)), this.options.dropcursor !== false && w.push(vS.configure((s = this.options) === null || s === void 0 ? void 0 : s.dropcursor)), this.options.gapcursor !== false && w.push(TS.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && w.push(OS.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== false && w.push(ag.configure((c2 = this.options) === null || c2 === void 0 ? void 0 : c2.heading)), this.options.history !== false && w.push($S.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== false && w.push(pg.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== false && w.push(VS.configure((p2 = this.options) === null || p2 === void 0 ? void 0 : p2.italic)), this.options.listItem !== false && w.push(WS.configure((f = this.options) === null || f === void 0 ? void 0 : f.listItem)), this.options.orderedList !== false && w.push(KS.configure((h2 = this.options) === null || h2 === void 0 ? void 0 : h2.orderedList)), this.options.paragraph !== false && w.push(fg.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== false && w.push(JS.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)), this.options.text !== false && w.push(YS.configure((b = this.options) === null || b === void 0 ? void 0 : b.text)), w;
      }
    }), ZS = (n3) => {
      if (!n3.children.length)
        return;
      const e = n3.querySelectorAll("span");
      e && e.forEach((t) => {
        var r, o;
        const i = t.getAttribute("style"), s = (o = (r = t.parentElement) === null || r === void 0 ? void 0 : r.closest("span")) === null || o === void 0 ? void 0 : o.getAttribute("style");
        t.setAttribute("style", `${s};${i}`);
      });
    }, QS = Cn.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return {
          HTMLAttributes: {},
          mergeNestedSpanStyles: false
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (n3) => n3.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && ZS(n3), {}) : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["span", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle: () => ({ tr: n3 }) => {
            const { selection: e } = n3;
            return n3.doc.nodesBetween(e.from, e.to, (t, r) => {
              if (t.isTextblock)
                return true;
              t.marks.filter((o) => o.type === this.type).some((o) => Object.values(o.attrs).some((i) => !!i)) || n3.removeMark(r, r + t.nodeSize, this.type);
            }), true;
          }
        };
      }
    }), ye = /* @__PURE__ */ defineComponent({
      __name: "OIcon",
      props: {
        name: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        small: {
          type: Boolean,
          default: false
        }
      },
      setup(n3) {
        return (e, t) => (openBlock(), createElementBlock("span", {
          class: normalizeClass(["o-icon", { small: n3.small }]),
          style: normalizeStyle({ color: n3.color })
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["yiitip-icon", `icon-${n3.name}`])
          }, null, 2)
        ], 6));
      }
    }), Wp = {
      isoName: "en-us",
      nativeName: "English (US)",
      diagram: {
        name: "Text Diagram",
        flow: "Flow Diagram",
        sequence: "Sequence Diagram",
        class: "Class Diagram",
        state: "State Diagram",
        gantt: "Gantt Diagram",
        tips: "Generation of diagram and chart from text in a similar manner as markdown"
      },
      editor: {
        add: "Add",
        addMore: "Add More",
        url: "URL",
        bold: "Bold",
        italic: "Italic",
        strikethrough: "Strikethrough",
        underline: "Underline",
        textFormat: "More text format",
        list: "List",
        unorderedList: "Unordered List",
        orderedList: "Ordered List",
        todoList: "Todo List",
        subscript: "Subscript",
        superscript: "Superscript",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Toggle Fullscreen",
        quote: "Quote",
        left: "Left align",
        center: "Center align",
        right: "Right align",
        justify: "Justify align",
        print: "Print",
        outdent: "Decrease indentation",
        indent: "Increase indentation",
        indentDropdown: "Indent",
        removeFormat: "Remove formatting",
        formatting: "Formatting",
        fontFamily: "Font Family",
        defaultFont: "Default Font",
        fontSize: "Font Size",
        align: "Align",
        hr: "Insert Horizontal Rule",
        undo: "Undo",
        redo: "Redo",
        heading: "Heading & Paragraph",
        heading1: "Heading 1",
        heading2: "Heading 2",
        heading3: "Heading 3",
        heading4: "Heading 4",
        heading5: "Heading 5",
        headings: "Headings",
        paragraph: "Paragraph",
        code: "Code",
        codeBlock: "Code Block",
        size1: "Very small",
        size2: "A bit small",
        size3: "Normal",
        size4: "Medium-large",
        size5: "Big",
        size6: "Very big",
        size7: "Maximum",
        viewSource: "View Source",
        textColor: "Text Color",
        highlightColor: "Highlight Color",
        default: "Default",
        lineHeight: "Line Height",
        blockquote: "Blockquote",
        table: "Table",
        photo: "Insert Photo",
        video: "Insert Video",
        formula: "Formula",
        inlineFormula: "Inline",
        blockFormula: "Block",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancel",
        color: "Color",
        edit: "Edit",
        link: "Link",
        linkAddress: "Link Address",
        ok: "Ok",
        preview: "Preview",
        template: "Template",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        replace: "Replace",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        more: "More",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Image Preferences",
        ratio: "Ratio",
        size: "Size",
        width: "Width",
        height: "Height",
        src: "Image Source",
        caption: "Caption",
        link: "Link",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, eC = {
      isoName: "pl",
      nativeName: "Polski",
      diagram: {
        name: "Schemat tekstowy",
        flow: "Schemat przepywu",
        sequence: "Schemat sekwencji",
        class: "Schemat klas",
        state: "Diagram stanu",
        gantt: "Diagram Gantta",
        tips: "Generowanie diagramu i wykresu z tekstu w podobny sposb jak markdown"
      },
      editor: {
        add: "Dodaj",
        addMore: "Dodaj wicej",
        url: "URL",
        bold: "Pogrubienie",
        italic: "Kursywa",
        strikethrough: "Przekrelenie",
        underline: "Podkrelenie",
        textFormat: "More text format",
        unorderedList: "Lista wypunktowana",
        orderedList: "Lista numerowana",
        list: "List",
        todoList: "Lista rzeczy do zrobienia",
        subscript: "Indeks dolny",
        superscript: "Indeks grny",
        hyperlink: "Hipercze",
        toggleFullscreen: "Przecz na tryb penoekranowy",
        quote: "Zacytuj",
        left: "Wyrwnaj do lewej",
        center: "Wyrwnaj do rodka",
        right: "Wyrwnaj do prawej",
        justify: "Wyjustuj",
        print: "Drukuj",
        outdent: "Zmniejsz wcicie",
        indent: "Zwiksz wcicie",
        indentDropdown: "Wcicie",
        removeFormat: "Usu formatowanie",
        formatting: "Formatowanie",
        fontFamily: "Nazwa czcionki",
        defaultFont: "Domylna czcionka",
        fontSize: "Rozmiar czcionki",
        align: "Wyrwnanie",
        hr: "Wstaw poziom lini",
        undo: "Cofnij",
        redo: "Przywr",
        heading: "Heading & Paragraph",
        heading1: "Nagwek 1",
        heading2: "Nagwek 2",
        heading3: "Nagwek 3",
        heading4: "Nagwek 4",
        heading5: "Nagwek 5",
        headings: "Nagwki",
        paragraph: "Paragraf",
        code: "Kod",
        codeBlock: "Blok kodu",
        size1: "Bardzo maa",
        size2: "Maa",
        size3: "Normalna",
        size4: "rednio-dua",
        size5: "Dua",
        size6: "Bardzo dua",
        size7: "Maksymalna",
        viewSource: "Poka rdo",
        textColor: "Kolor czcionki",
        highlightColor: "Kolor wyrnienia",
        default: "Dymylny",
        lineHeight: "Wysoko linii",
        blockquote: "Cytat",
        table: "Tabela",
        photo: "Wstaw obraz",
        video: "Insert Video",
        formula: "Formua",
        inlineFormula: "Formua w treci",
        blockFormula: "Blokowa formua",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Anuluj",
        edit: "Edycja",
        link: "cze",
        linkAddress: "Adres cza",
        ok: "Ok",
        preview: "Podgld",
        template: "Szablon",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferencje obrazu",
        ratio: "Ratio",
        size: "Rozmiar",
        width: "Szeroko",
        height: "Wysoko",
        src: "rdo obrazu",
        caption: "Nagwek",
        link: "cze",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, tC = {
      isoName: "pt-br",
      nativeName: "Portugus (BR)",
      diagram: {
        name: "Diagrama de Texto",
        flow: "Diagrama de Fluxo",
        sequence: "Diagrama de sequncia",
        class: "Diagrama de Classe",
        state: "Diagrama de Estado",
        gantt: "Diagrama de Gantt",
        tips: "Gerao de diagrama ou grfico a partir de texto semelhante a markdown"
      },
      editor: {
        add: "Adicionar",
        addMore: "Adicione Mais",
        url: "URL",
        bold: "Negrito",
        italic: "Itlico",
        strikethrough: "Tachar",
        underline: "Sublinhado",
        textFormat: "Mais formatos de textos",
        list: "Lista",
        unorderedList: "Lista com Marcadores",
        orderedList: "Lista Numerada",
        todoList: "Lista de afazer",
        subscript: "Subscrito",
        superscript: "Sobrescrito",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Alternar tela-cheia",
        quote: "Citao",
        left: "Alinhar  esquerda",
        center: "Alinhar ao centro",
        right: "Alinhar  direita",
        justify: "Justificar",
        print: "Imprimir",
        outdent: "Diminuir recuo",
        indent: "Aumentar recuo",
        indentDropdown: "Recuo",
        removeFormat: "Limpar formatao",
        formatting: "Formatao",
        fontFamily: "Fonte",
        defaultFont: "Fonte Padro",
        fontSize: "Tamanho da fontee",
        align: "Alinhamento",
        hr: "Linha Horizontal",
        undo: "Desfazer",
        redo: "Refazer",
        heading: "Heading & Paragraph",
        heading1: "Ttulo 1",
        heading2: "Ttulo 2",
        heading3: "Ttulo 3",
        heading4: "Ttulo 4",
        heading5: "Ttulo 5",
        headings: "Estilos de Pargrafo",
        paragraph: "Pargrafo",
        code: "Cdigo",
        codeBlock: "Bloco de Cdigo",
        size1: "Muito Pequeno",
        size2: "Pequeno",
        size3: "Normal",
        size4: "Mdio",
        size5: "Grande",
        size6: "Enorme",
        size7: "Mximo",
        viewSource: "Cdigo Fonte",
        textColor: "Cor do texto",
        highlightColor: "Cor do fundo",
        default: "Padro",
        lineHeight: "Espao entre linhas",
        blockquote: "Bloco de citao",
        table: "Tabela",
        photo: "Inserir Foto",
        video: "Insert Video",
        formula: "Frmula",
        inlineFormula: "Linha",
        blockFormula: "Bloco",
        thirdPartyService: "Servios de terceiros",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancelar",
        edit: "Editar",
        link: "Link",
        linkAddress: "Endereo do Link",
        ok: "Ok",
        preview: "Pr Visualizao",
        template: "Modelo",
        example: "Exemplo",
        submit: "Enviar",
        settings: "Configuraes",
        remove: "Excluir",
        help: "Ajuda",
        back: "Voltar",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferncias da Imagem",
        ratio: "Ratio",
        size: "Tamanho",
        width: "Largura",
        height: "Altura",
        src: "Origem da imagem",
        caption: "Legenda",
        link: "Link",
        lockAspectRatio: "Bloquear proporo",
        unlockAspectRatio: "Desbloquear proporo",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Vdeo",
        map: "Mapa",
        design: "Design",
        develop: "Desenvolvimento",
        data: "Dados",
        others: "Outros",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, qp = {
      isoName: "zh-hans",
      nativeName: "",
      diagram: {
        name: "",
        flow: "",
        sequence: "",
        class: "",
        state: "",
        gantt: "",
        tips: "Markdown"
      },
      editor: {
        add: "",
        addMore: "",
        url: "URL",
        bold: "",
        italic: "",
        strikethrough: "",
        underline: "",
        textFormat: "",
        list: "",
        unorderedList: "",
        orderedList: "",
        todoList: "",
        subscript: "",
        superscript: "",
        hyperlink: "",
        toggleFullscreen: "",
        quote: "",
        left: "",
        center: "",
        right: "",
        justify: "",
        print: "",
        outdent: "",
        indent: "",
        indentDropdown: "",
        removeFormat: "",
        formatting: "",
        fontFamily: "",
        defaultFont: "",
        fontSize: "",
        align: "",
        hr: "",
        undo: "",
        redo: "",
        heading: "",
        heading1: "",
        heading2: "",
        heading3: "",
        heading4: "",
        heading5: "",
        headings: "",
        paragraph: "",
        code: "",
        codeBlock: "",
        size1: "",
        size2: "",
        size3: "",
        size4: "",
        size5: "",
        size6: "",
        size7: "",
        viewSource: "",
        textColor: "",
        highlightColor: "",
        default: "",
        lineHeight: "",
        blockquote: "",
        table: "",
        photo: "",
        video: "",
        formula: "",
        inlineFormula: "",
        blockFormula: "",
        thirdPartyService: "",
        horizontal: "",
        callout: "",
        emoji: "",
        defaultColor: "",
        noColor: "",
        delete: "",
        duplicate: ""
      },
      label: {
        ai: "AI",
        cancel: "",
        color: "",
        edit: "",
        link: "",
        linkAddress: "",
        ok: "",
        preview: "",
        template: "",
        example: "",
        submit: "",
        settings: "",
        remove: "",
        replace: "",
        help: "",
        back: "",
        styles: "",
        basic: "",
        basicBlocks: "",
        common: "",
        media: "",
        image: "",
        video: "",
        model: "",
        modelViewer: "",
        more: "",
        toc: "",
        untitled: "",
        typeForCommands: " '/' ",
        empty: "",
        emptyTips: "",
        copy: "",
        cut: "",
        search: ""
      },
      table: {
        cellBackground: "",
        insert: "",
        remove: "",
        addColumn: "",
        removeColumn: "",
        addRow: "",
        removeRow: "",
        merge: "/ "
      },
      image: {
        preferences: "",
        ratio: "",
        size: "",
        width: "",
        height: "",
        src: "",
        caption: "",
        link: "",
        lockAspectRatio: "",
        unlockAspectRatio: "",
        original: "",
        small: "",
        medium: "",
        large: ""
      },
      embed: {
        video: "",
        map: "",
        design: "",
        develop: "",
        data: "",
        others: "",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "",
        iqiyi: "",
        bilibili: "Bilibili",
        qqvideo: "",
        google_map: "",
        amap: "",
        baidu_map: "",
        modao: "",
        lanhu: "",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "",
        iframe: "IFrame",
        linkTips: "",
        linkWarning: ""
      },
      link: {
        back: "",
        edit: "",
        off: "",
        open: "",
        open_in_new_tab: ""
      }
    }, nC = {
      isoName: "zh-hant",
      nativeName: "",
      diagram: {
        name: "",
        flow: "",
        sequence: "",
        class: "",
        state: "",
        gantt: "",
        tips: "Markdown"
      },
      editor: {
        add: "",
        addMore: "",
        url: "URL",
        bold: "",
        italic: "",
        strikethrough: "",
        underline: "",
        textFormat: "",
        list: "",
        unorderedList: "",
        orderedList: "",
        todoList: "",
        subscript: "",
        superscript: "",
        hyperlink: "",
        toggleFullscreen: "",
        quote: "",
        left: "",
        center: "",
        right: "",
        justify: "",
        print: "",
        outdent: "",
        indent: "",
        indentDropdown: "",
        removeFormat: "",
        formatting: "",
        fontFamily: "",
        defaultFont: "",
        fontSize: "",
        align: "",
        hr: "",
        undo: "",
        redo: "",
        heading: "",
        heading1: "",
        heading2: "",
        heading3: "",
        heading4: "",
        heading5: "",
        headings: "",
        paragraph: "",
        code: "",
        codeBlock: "",
        size1: "",
        size2: "",
        size3: "",
        size4: "",
        size5: "",
        size6: "",
        size7: "",
        viewSource: "",
        textColor: "",
        highlightColor: "",
        default: "",
        lineHeight: "",
        blockquote: "",
        table: "",
        photo: "",
        video: "",
        formula: "",
        inlineFormula: "",
        blockFormula: "",
        thirdPartyService: "",
        horizontal: "",
        callout: "",
        emoji: "",
        defaultColor: "",
        noColor: "",
        delete: "",
        duplicate: ""
      },
      label: {
        ai: "AI",
        cancel: "",
        edit: "",
        link: "",
        linkAddress: "",
        ok: "",
        preview: "",
        template: "",
        example: "",
        submit: "",
        settings: "",
        remove: "",
        help: "",
        back: "",
        styles: "",
        basic: "",
        basicBlocks: "",
        common: "",
        media: "",
        image: "",
        video: "",
        model: "",
        modelViewer: "",
        toc: "",
        untitled: "",
        typeForCommands: " '/' ",
        empty: "",
        emptyTips: "",
        copy: "",
        cut: "",
        search: ""
      },
      table: {
        cellBackground: "",
        insert: "",
        remove: "",
        addColumn: "",
        removeColumn: "",
        addRow: "",
        removeRow: "",
        merge: "/ "
      },
      image: {
        preferences: "",
        ratio: "",
        size: "",
        width: "",
        height: "",
        src: "",
        caption: "",
        link: "",
        lockAspectRatio: "",
        unlockAspectRatio: "",
        original: "",
        small: "",
        medium: "",
        large: ""
      },
      embed: {
        video: "",
        map: "",
        design: "",
        develop: "",
        data: "",
        others: "",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "",
        iqiyi: "",
        bilibili: "Bilibili",
        qqvideo: "",
        google_map: "",
        amap: "",
        baidu_map: "",
        modao: "",
        lanhu: "",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "",
        iframe: "IFrame",
        linkTips: "",
        linkWarning: ""
      },
      link: {
        back: "",
        edit: "",
        off: "",
        open: "",
        open_in_new_tab: ""
      }
    }, hg = {
      en: Wp,
      "en-us": Wp,
      pl: eC,
      "pt-br": tC,
      zh: qp,
      "zh-hans": qp,
      "zh-hant": nC
    }, rC = "en", oC = hg[rC], iC = (n3) => hg[n3] || oC;
    function Le() {
      const n3 = inject("locale", { value: "en" }), e = computed(() => iC(n3.value));
      function t(r) {
        return r.split(".").reduce((o, i) => {
          if (o) return o[i];
        }, e.value);
      }
      return {
        locale: n3,
        message: e,
        tr: t
      };
    }
    function al() {
      const n3 = inject("darkMode", { value: false }), e = computed(() => n3.value ? "dark" : "light");
      return {
        darkMode: n3,
        theme: e
      };
    }
    function Qe() {
      function n3(t, r, o = {}) {
        const i = t == null ? void 0 : t.chain().focus(), s = t == null ? void 0 : t.commands;
        e(s, i, r, o);
      }
      function e(t, r, o, i = {}) {
        switch (console.log("command", o, i), o) {
          // case 'aiViewer':
          // 	focus.setAiViewer({
          // 		content: 'init',
          // 	}).run()
          // 	break
          case "backColor":
            i.color ? t.setHighlight({ color: i.color }) : t.unsetHighlight();
            break;
          case "blockquote":
            r.toggleBlockquote().run();
            break;
          case "bold":
            r.toggleBold().run();
            break;
          case "bulletList":
            r.toggleBulletList().run();
            break;
          case "callout":
            r.toggleCallout().run();
            break;
          case "clearFormat":
            r.unsetAllMarks().run();
            break;
          case "code":
            r.toggleCode().run();
            break;
          case "codeBlock":
            t.toggleCodeBlock({ language: "bash" });
            break;
          // case 'columns':
          // 	commands.setColumns(2)
          // 	break
          case "content":
            t.insertContent(i.content);
            break;
          case "fontFamily":
            t.setFontFamily(i.fontFamily);
            break;
          case "foreColor":
            t.setColor(i.color);
            break;
          case "heading":
            r.toggleHeading(i).run();
            break;
          case "horizontalRule":
            r.setHorizontalRule().run();
            break;
          case "image":
            r.setImage({
              src: "init"
            }).run();
            break;
          case "imageUpdate":
            r.setImage(
              i
            ).run();
            break;
          case "italic":
            r.toggleItalic().run();
            break;
          case "linkSet":
            r.extendMarkRange("link").setLink(
              i
            ).run();
            break;
          case "linkUnset":
            r.extendMarkRange("link").unsetLink().run();
            break;
          // case 'modelViewer':
          // 	focus.setModelViewer({
          // 		src: 'init',
          // 	}).run()
          // 	break
          // case 'modelViewerUpdate':
          // 	focus.setModelViewer(options).run()
          // 	break
          case "orderedList":
            r.toggleOrderedList().run();
            break;
          case "paragraph":
            r.setParagraph().run();
            break;
          case "strike":
            r.toggleStrike().run();
            break;
          case "table":
            r.insertTable({
              rows: 3,
              cols: 3,
              withHeaderRow: true
            }).run();
            break;
          case "tableAddColumn":
            r.addColumnAfter().run();
            break;
          case "tableAddRow":
            r.addRowAfter().run();
            break;
          case "tableCellAttribute":
            r.setCellAttribute(i.name, i.value).run();
            break;
          case "tableDeleteColumn":
            r.deleteColumn().run();
            break;
          case "tableDeleteRow":
            r.deleteRow().run();
            break;
          case "tableDelete":
            r.deleteTable().run();
            break;
          case "tableInsert":
            r.insertTable(i).run();
            break;
          case "tableMergeCells":
            r.mergeCells().run();
            break;
          case "tableSelectColumn":
            r.selectColumn(i.pos).run();
            break;
          case "tableSelectRow":
            r.selectRow(i.pos).run();
            break;
          case "tableSplitCell":
            r.splitCell().run();
            break;
          case "taskList":
            t.toggleTaskList();
            break;
          case "textAlign":
            r.setTextAlign(i.textAlign).run();
            break;
          case "underline":
            r.toggleUnderline().run();
            break;
          case "video":
            r.setVideo({
              src: "init"
            }).run();
        }
      }
      return {
        run: n3,
        onCommand: e
      };
    }
    const wo = /* @__PURE__ */ defineComponent({
      __name: "OTooltip",
      props: {
        placement: {
          type: String,
          default: "top"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
          // default: 'click'
        }
      },
      setup(n3) {
        const e = n3, { theme: t } = al(), r = ref(), o = ref(), i = ref();
        function s() {
          i.value = er(r.value, {
            appendTo: () => document.body,
            animation: "perspective",
            // scale, shift-away
            content: o.value,
            duration: 100,
            interactive: true,
            placement: e.placement,
            trigger: e.trigger
          });
        }
        function a() {
          i.value.setProps({
            theme: t.value
          });
        }
        return watch(t, (l) => {
          a();
        }), onMounted(() => {
          s();
        }), (l, c2) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: r,
          "data-tippy-role": "tooltip"
        }, [
          renderSlot(l.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: o,
            class: "tooltip-content"
          }, [
            renderSlot(l.$slots, "default")
          ], 512)
        ], 512));
      }
    }), Je = /* @__PURE__ */ defineComponent({
      __name: "OMenubarBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n3, { emit: e }) {
        const t = e;
        return (r, o) => (openBlock(), createBlock(wo, {
          class: "o-tooltip",
          placement: n3.placement
        }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n3.contentClass]),
              style: normalizeStyle(n3.contentStyle),
              onClick: o[0] || (o[0] = (i) => t("click", i))
            }, [
              createVNode(ye, {
                name: n3.icon,
                color: n3.color,
                class: normalizeClass(n3.iconClass)
              }, null, 8, ["name", "color", "class"])
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n3.tooltip), 1)
          ]),
          _: 1
        }, 8, ["placement"]));
      }
    }), sC = /* @__PURE__ */ defineComponent({
      __name: "OSimpleCommandBtn",
      props: {
        name: {
          type: String,
          default: ""
        },
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { run: t } = Qe(), { tr: r } = Le(), o = computed(() => ({
          aiViewer: { icon: "auto_awesome", tooltip: r("label.ai") },
          blockquote: { icon: "format_quote_open", tooltip: r("editor.blockquote") },
          bold: { icon: "format_bold", tooltip: r("editor.bold") },
          callout: { icon: "card_text", tooltip: r("editor.callout") },
          clearFormat: { icon: "format_clear", tooltip: r("editor.removeFormat") },
          code: { icon: "code", tooltip: r("editor.code") },
          codeBlock: { icon: "code_braces", tooltip: r("editor.codeBlock") },
          columns: {
            icon: "splitscreen_vertical_add",
            tooltip: "Column",
            rotate: true
          },
          horizontalRule: { icon: "horizontal_rule", tooltip: r("editor.hr") },
          italic: { icon: "format_italic", tooltip: r("editor.italic") },
          image: { icon: "image", tooltip: r("editor.photo") },
          linkUnset: { icon: "link_off", tooltip: r("link.off") },
          modelViewer: { icon: "3d_rotation", tooltip: r("label.modelViewer") },
          strike: {
            icon: "format_strikethrough",
            tooltip: r("editor.strikethrough")
          },
          underline: { icon: "format_underlined", tooltip: r("editor.underline") },
          video: { icon: "videocam", tooltip: r("editor.video") }
        })), i = computed(() => o.value[e.name] || {
          icon: "",
          isActive: false,
          command: () => {
          }
        });
        function s() {
          t(e.editor, e.name);
        }
        return (a, l) => {
          var c2;
          return openBlock(), createBlock(Je, {
            class: "o-simple-command-btn",
            icon: i.value.icon,
            tooltip: i.value.tooltip,
            "content-class": {
              "is-active": (c2 = n3.editor) == null ? void 0 : c2.isActive(n3.name),
              "rotate-90": i.value.rotate
            },
            onClick: s
          }, null, 8, ["icon", "tooltip", "content-class"]);
        };
      }
    }), aC = { class: "o-block-placeholder" }, lC = { class: "icon" }, cC = { class: "placeholder" }, mg = /* @__PURE__ */ defineComponent({
      __name: "OBlockPlaceholder",
      props: {
        icon: {
          type: String,
          default: "image"
        },
        placeholder: {
          type: String,
          default: ""
        }
      },
      setup(n3) {
        return (e, t) => (openBlock(), createElementBlock("section", aC, [
          createBaseVNode("div", lC, [
            createVNode(unref(ye), { name: n3.icon }, null, 8, ["name"])
          ]),
          createBaseVNode("div", cC, toDisplayString(n3.placeholder), 1)
        ]));
      }
    }), Be = {
      amber: "#ffc107",
      blue: "#2172e0",
      brown: "#795548",
      cyan: "#00bcd4",
      deepOrange: "#ff5722",
      deepPurple: "#673ab7",
      green: "#4caf50",
      indigo: "#3f51b5",
      lightBlue: "#03a9f4",
      lightGreen: "#8bc34a",
      lime: "#cddc39",
      orange: "#ff9800",
      purple: "#9c27b0",
      pink: "#e91e63",
      red: "#f44336",
      teal: "#009688",
      yellow: "#ffeb3b"
    }, as = [
      {
        label: "editor.paragraph",
        value: "paragraph",
        icon: "title",
        // title, format_paragraph, local_parking
        color: "",
        style: true,
        group: "label.basic"
      },
      {
        label: "editor.heading1",
        value: "heading",
        icon: "format_h1",
        color: Be.blue,
        style: true,
        options: { level: 1 }
      },
      {
        label: "editor.heading2",
        value: "heading",
        icon: "format_h2",
        color: Be.blue,
        style: true,
        options: { level: 2 }
      },
      {
        label: "editor.heading3",
        value: "heading",
        icon: "format_h3",
        color: Be.blue,
        style: true,
        options: { level: 3 }
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        color: Be.indigo,
        style: true
      },
      {
        label: "editor.unorderedList",
        value: "bulletList",
        icon: "format_list_bulleted",
        color: Be.indigo,
        style: true
      },
      {
        label: "editor.orderedList",
        value: "orderedList",
        icon: "format_list_numbered",
        color: Be.indigo,
        style: true
      },
      {
        label: "editor.blockquote",
        value: "blockquote",
        icon: "format_quote_open",
        color: Be.brown,
        style: true
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        color: Be.lightBlue,
        style: true
      },
      {
        label: "editor.horizontal",
        value: "horizontalRule",
        icon: "horizontal_rule",
        color: Be.blue
      },
      {
        label: "editor.callout",
        value: "callout",
        color: Be.deepOrange,
        icon: "card_text",
        style: false
      },
      {
        label: "editor.emoji",
        value: "emoji",
        icon: "emoji_emotions",
        color: Be.blue
      }
    ], ha = as.filter((n3) => n3.style), Wi = [
      {
        label: "label.ai",
        value: "aiViewer",
        icon: "auto_awesome",
        color: Be.purple,
        tips: "ai",
        group: "label.ai"
      },
      {
        label: "editor.callout",
        value: "callout",
        icon: "card_text",
        color: Be.deepOrange,
        tips: "callout",
        group: "label.common"
      },
      {
        label: "editor.table",
        value: "table",
        icon: "window",
        tips: "table",
        color: Be.cyan
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        tips: "code",
        color: Be.blue
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        tips: "task",
        color: Be.indigo
      },
      {
        label: "label.image",
        value: "image",
        icon: "image",
        color: Be.amber,
        tips: "image",
        group: "label.media"
      },
      {
        label: "label.video",
        value: "video",
        icon: "videocam",
        tips: "video",
        color: Be.purple
      },
      {
        label: "label.model",
        value: "modelViewer",
        icon: "3d_rotation",
        tips: "model",
        color: Be.purple
      }
    ], Lu = [...as, ...Wi], Kp = [
      {
        label: "editor.duplicate",
        value: "duplicate",
        icon: "content_copy",
        color: Be.blue,
        tips: "Ctrl+D",
        group: "label.common",
        filter: "common"
      },
      {
        label: "editor.delete",
        value: "delete",
        icon: "delete",
        tips: "Ctrl+D",
        color: Be.deepOrange,
        filter: "common"
      },
      {
        label: "label.replace",
        value: "replace",
        icon: "cached",
        tips: "Ctrl+R",
        color: Be.blue,
        filter: "image,video,model"
      },
      {
        label: "label.color",
        value: "palette",
        icon: "palette",
        color: Be.purple,
        filter: "callout",
        component: "OCalloutColorBoard"
      }
    ], uC = {
      key: 1,
      class: "group o-tips"
    }, dC = { class: "suffix o-tips" }, pC = {
      key: 1,
      class: "item"
    }, Qo = /* @__PURE__ */ defineComponent({
      __name: "OBlockMenu",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        },
        colorful: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: Boolean,
          default: false
        }
      },
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: o } = Le(), i = ref([]), s = computed(() => {
          var f;
          return (f = t.node) == null ? void 0 : f.type.name;
        }), a = computed(() => {
          const f = Kp.filter(
            (m) => {
              var g;
              return ((g = m.filter) == null ? void 0 : g.indexOf("common")) >= 0;
            }
          ), h2 = Kp.filter(
            (m) => {
              var g;
              return ((g = m.filter) == null ? void 0 : g.indexOf(s.value)) >= 0;
            }
          );
          if (h2.length > 0) {
            const m = h2[0];
            m.group = `editor.${s.value}`;
          }
          return [...f, ...h2];
        });
        function l(f) {
          switch (f.component) {
            case "OCalloutColorBoard":
              return bg;
            default:
              return null;
          }
        }
        function c2(f) {
          r("action", f), setTimeout(() => {
            u(f);
          }, 0);
        }
        function u(f) {
          switch (f.value) {
            case "delete":
              t.deleteNode();
              break;
            case "duplicate":
              d();
              break;
          }
        }
        function d() {
          var b, w, _;
          const f = t.node.nodeSize, h2 = t.getPos() + f, m = JSON.parse(JSON.stringify(t.node));
          (b = t.editor) == null || b.commands.insertContentAt(h2, {
            type: "paragraph"
          }), (w = t.editor) == null || w.commands.insertContentAt(h2, m);
          const g = h2 + f + 1;
          (_ = t.editor) == null || _.commands.focus(g);
        }
        function p2(f, h2) {
          switch (h2.name) {
            case "backColor":
              t.updateAttributes({ background: h2.value });
              break;
            case "foreColor":
              t.updateAttributes({ borderColor: h2.value });
              break;
          }
        }
        return (f, h2) => (openBlock(), createBlock(unref(Pn), {
          class: "o-block-menu",
          hoverable: "",
          clickable: ""
        }, {
          default: withCtx(() => [
            a.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(a.value, (m, g) => (openBlock(), createElementBlock(Fragment, { key: g }, [
              m.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                g > 0 ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                n3.showGroup ? (openBlock(), createElementBlock("div", uC, toDisplayString(unref(o)(m.group)), 1)) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true),
              l(m) ? (openBlock(), createBlock(unref(at), {
                key: 1,
                ref_for: true,
                ref: i.value[m.value],
                offset: [0, 16],
                placement: "right"
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(Nn), {
                    class: "item",
                    clickable: ""
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: m.icon,
                        color: n3.colorful ? m.color : ""
                      }, null, 8, ["name", "color"])
                    ]),
                    suffix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: "navigate_next",
                        class: "o-tips"
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(o)(m.label)), 1)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(l(m)), {
                    onSelect: (b) => p2(m, b)
                  }, null, 40, ["onSelect"]))
                ]),
                _: 2
              }, 1536)) : (openBlock(), createBlock(unref(Nn), {
                key: 2,
                class: "item",
                clickable: "",
                onClick: (b) => c2(m)
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ye), {
                    name: m.icon,
                    color: n3.colorful ? m.color : ""
                  }, null, 8, ["name", "color"])
                ]),
                suffix: withCtx(() => [
                  createBaseVNode("div", dC, toDisplayString(m.tips), 1)
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString(unref(o)(m.label)), 1)
                ]),
                _: 2
              }, 1032, ["onClick"]))
            ], 64))), 128)) : (openBlock(), createElementBlock("div", pC, "No result"))
          ]),
          _: 1
        }));
      }
    }), qi = /* @__PURE__ */ defineComponent({
      __name: "OBlockPopover",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        placement: {
          type: String,
          default: "bottom-center"
        },
        showArrow: {
          type: Boolean,
          default: false
        },
        hideClickOutside: {
          type: Boolean,
          default: false
        },
        tippyClass: {
          type: String,
          default: ""
        },
        offset: {
          type: Array,
          default: function() {
            return [0, 10];
          }
        }
      },
      emits: ["update:modelValue", "show", "hide"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, o = ref();
        function i(a) {
          r("update:modelValue", a);
        }
        function s() {
          t.hideClickOutside && r("update:modelValue", false);
        }
        return watch(
          () => t.modelValue,
          (a) => {
            var l, c2;
            console.log("modelValue", a), a ? (l = o.value) == null || l.setShow(true) : (c2 = o.value) == null || c2.setShow(false);
          }
        ), onMounted(() => {
          var a;
          t.modelValue && ((a = o.value) == null || a.setShow(true));
        }), (a, l) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          placement: n3.placement,
          "tippy-class": n3.tippyClass,
          trigger: "manual",
          arrow: n3.showArrow,
          offset: n3.offset,
          show: n3.modelValue,
          "onUpdate:show": i,
          onClickoutside: s
        }, {
          trigger: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          default: withCtx(() => [
            renderSlot(a.$slots, "popover-content")
          ]),
          _: 3
        }, 8, ["placement", "tippy-class", "arrow", "offset", "show"]));
      }
    }), fC = { class: "o-block-toolbar" }, hC = { class: "button-group" }, gg = /* @__PURE__ */ defineComponent({
      __name: "OBlockToolbar",
      props: {
        ...xt,
        type: {
          type: String,
          default: "link"
        }
      },
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: i } = Le(), s = ref();
        function a(l) {
          var c2;
          r("action", l), (c2 = s.value) == null || c2.setShow(false);
        }
        return (l, c2) => (openBlock(), createElementBlock("div", fC, [
          createBaseVNode("section", hC, [
            renderSlot(l.$slots, "default"),
            createVNode(unref(at), {
              ref_key: "popover",
              ref: s,
              placement: "bottom-end",
              size: "medium",
              trigger: "click",
              "show-arrow": false
            }, {
              trigger: withCtx(() => [
                createVNode(unref(Lt), {
                  icon: "more_horiz",
                  tooltip: unref(i)("label.more")
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createVNode(unref(Qo), mergeProps(t, { onAction: a }), null, 16)
              ]),
              _: 1
            }, 512)
          ])
        ]));
      }
    }), mC = { class: "o-callout-color-board" }, gC = { class: "fore-colors" }, bC = /* @__PURE__ */ createBaseVNode("div", { class: "label o-tips" }, "Border color", -1), yC = { class: "color-row" }, vC = { class: "color-row" }, wC = { class: "back-colors" }, kC = /* @__PURE__ */ createBaseVNode("div", { class: "label o-tips" }, "Background", -1), EC = { class: "color-row" }, _C = { class: "color-row" }, bg = /* @__PURE__ */ defineComponent({
      __name: "OCalloutColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n3, { emit: e }) {
        const t = e;
        function r(s, a) {
          t("select", {
            name: s,
            value: a.value
          });
        }
        const o = computed(() => [
          { label: "Grey", value: "#e9e9e9" },
          { label: "Brown", value: "#ffd591" },
          { label: "Orange", value: "#ffbb96" },
          { label: "Yellow", value: "#fff08f" },
          { label: "Green", value: "#b7eb8f" },
          { label: "Blue", value: "#91d5ff" },
          { label: "Purple", value: "#d3adf7" },
          { label: "Pink", value: "#ffadd2" },
          { label: "Red", value: "#ffa39e" }
        ]), i = computed(() => [
          { label: "Grey", value: "#F5F5F5" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (s, a) => (openBlock(), createElementBlock("section", mC, [
          createBaseVNode("section", gC, [
            bC,
            createBaseVNode("div", yC, [
              createVNode(unref(Je), {
                icon: "slash_forward",
                tooltip: "No color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => r("foreColor", { value: "" }))
              }),
              n3.foreColor ? (openBlock(), createBlock(unref(Je), {
                key: 0,
                tooltip: "Last used",
                "content-style": { borderColor: n3.foreColor },
                onClick: a[1] || (a[1] = (l) => r("foreColor", { value: n3.foreColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", vC, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => (openBlock(), createBlock(unref(Je), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { borderColor: l.value },
                onClick: (u) => r("foreColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", wC, [
            kC,
            createBaseVNode("div", EC, [
              createVNode(unref(Je), {
                icon: "slash_forward",
                tooltip: "Default Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => r("backColor", { value: "#F5F5F5" }))
              }),
              n3.backColor ? (openBlock(), createBlock(unref(Je), {
                key: 0,
                "content-style": { backgroundColor: n3.backColor },
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[3] || (a[3] = (l) => r("backColor", { value: n3.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _C, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(Je), {
                key: `col-${c2}`,
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => r("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), Bu = /* @__PURE__ */ defineComponent({
      __name: "OContextMenu",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        clientX: {
          type: Number,
          default: 0
        },
        clientY: {
          type: Number,
          default: 0
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:modelValue"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, o = ref();
        computed(() => {
          var a;
          return t.clientX || ((a = t.event) == null ? void 0 : a.clientX) || 0;
        }), computed(() => {
          var a;
          return t.clientY || ((a = t.event) == null ? void 0 : a.clientY) || 0;
        });
        function i(a) {
          r("update:modelValue", a);
        }
        function s() {
          r("update:modelValue", false);
        }
        return watch(
          () => t.modelValue,
          (a) => {
            var l;
            a ? setTimeout(() => {
              var c2;
              (c2 = o.value) == null || c2.setShow(a);
            }, 0) : (l = o.value) == null || l.setShow(a);
          }
        ), (a, l) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          placement: "bottom-start",
          trigger: "manual",
          show: n3.modelValue,
          "show-arrow": false,
          event: n3.event,
          "onUpdate:show": i,
          onClickoutside: s
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["show", "event"]));
      }
    }), SC = { class: "o-color-board" }, CC = { class: "cell-container" }, xC = { class: "label" }, TC = ["onClick"], Pu = /* @__PURE__ */ defineComponent({
      __name: "OColorBoard",
      props: {
        defaultColor: {
          type: String,
          default: ""
        },
        defaultLabel: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n3, { emit: e }) {
        const t = n3, r = e;
        function o(l) {
          r("select", l.hex);
        }
        function i(l) {
          return t.activeColor === l;
        }
        function s(l) {
          return "abc";
        }
        const a = computed(() => [
          [
            { label: "color", rgb: "rgb(0, 0, 0)", hex: "#000000" },
            { label: "color", rgb: "rgb(38, 38, 38)", hex: "#262626" },
            { label: "color", rgb: "rgb(89, 89, 89)", hex: "#595959" },
            { label: "color", rgb: "rgb(140, 140, 140)", hex: "#8c8c8c" },
            { label: "color", rgb: "rgb(191, 191, 191)", hex: "#bfbfbf" },
            { label: "color", rgb: "rgb(217, 217, 217)", hex: "#d9d9d9" },
            { label: "color", rgb: "rgb(233, 233, 233)", hex: "#e9e9e9" },
            { label: "color", rgb: "rgb(245, 245, 245)", hex: "#f5f5f5" },
            {
              label: "color",
              rgb: "rgb(250, 250, 250)",
              hex: "#fafafa",
              border: true
            },
            {
              label: "color",
              rgb: "rgb(255, 255, 255)",
              hex: "#ffffff",
              border: true
            }
          ],
          [
            { label: "color", rgb: "rgb(245, 34, 45)", hex: "#f5222d" },
            { label: "color", rgb: "rgb(250, 84, 28)", hex: "#fa541c" },
            { label: "color", rgb: "rgb(250, 140, 22)", hex: "#fa8c16" },
            { label: "color", rgb: "rgb(250, 219, 20)", hex: "#fadb14" },
            { label: "color", rgb: "rgb(82, 196, 26)", hex: "#52c41a" },
            { label: "color", rgb: "rgb(19, 194, 194)", hex: "#13c2c2" },
            { label: "color", rgb: "rgb(24, 144, 255)", hex: "#1890ff" },
            { label: "color", rgb: "rgb(47, 84, 235)", hex: "#2f54eb" },
            { label: "color", rgb: "rgb(114, 46, 209)", hex: "#722ed1" },
            { label: "color", rgb: "rgb(235, 47, 150)", hex: "#eb2f96" }
          ],
          [
            { label: "color", rgb: "rgb(255, 232, 230)", hex: "#ffe8e6" },
            { label: "color", rgb: "rgb(255, 236, 224)", hex: "#ffece0" },
            { label: "color", rgb: "rgb(255, 239, 209)", hex: "#ffefd1" },
            { label: "color", rgb: "rgb(255, 248, 189)", hex: "#fff8bd" },
            { label: "color", rgb: "rgb(228, 247, 210)", hex: "#e4f7d2" },
            { label: "color", rgb: "rgb(211, 245, 240)", hex: "#d3f5f0" },
            { label: "color", rgb: "rgb(212, 238, 252)", hex: "#d4eefc" },
            { label: "color", rgb: "rgb(222, 232, 252)", hex: "#dee8fc" },
            { label: "color", rgb: "rgb(239, 225, 250)", hex: "#efe1fa" },
            { label: "color", rgb: "rgb(250, 225, 235)", hex: "#fae1eb" }
          ],
          [
            { label: "color", rgb: "rgb(255, 163, 158)", hex: "#ffa39e" },
            { label: "color", rgb: "rgb(255, 187, 150)", hex: "#ffbb96" },
            { label: "color", rgb: "rgb(255, 213, 145)", hex: "#ffd591" },
            { label: "color", rgb: "rgb(255, 240, 143)", hex: "#fff08f" },
            { label: "color", rgb: "rgb(183, 235, 143)", hex: "#b7eb8f" },
            { label: "color", rgb: "rgb(135, 232, 222)", hex: "#87e8de" },
            { label: "color", rgb: "rgb(145, 213, 255)", hex: "#91d5ff" },
            { label: "color", rgb: "rgb(173, 198, 255)", hex: "#adc6ff" },
            { label: "color", rgb: "rgb(211, 173, 247)", hex: "#d3adf7" },
            { label: "color", rgb: "rgb(255, 173, 210)", hex: "#ffadd2" }
          ],
          [
            { label: "color", rgb: "rgb(255, 77, 79)", hex: "#ff4d4f" },
            { label: "color", rgb: "rgb(255, 122, 69)", hex: "#ff7a45" },
            { label: "color", rgb: "rgb(255, 169, 64)", hex: "#ffa940" },
            { label: "color", rgb: "rgb(255, 236, 61)", hex: "#ffec3d" },
            { label: "color", rgb: "rgb(115, 209, 61)", hex: "#73d13d" },
            { label: "color", rgb: "rgb(54, 207, 201)", hex: "#36cfc9" },
            { label: "color", rgb: "rgb(64, 169, 255)", hex: "#40a9ff" },
            { label: "color", rgb: "rgb(89, 126, 247)", hex: "#597ef7" },
            { label: "color", rgb: "rgb(146, 84, 222)", hex: "#9254de" },
            { label: "color", rgb: "rgb(247, 89, 171)", hex: "#f759ab" }
          ],
          [
            { label: "color", rgb: "rgb(207, 19, 34)", hex: "#cf1322" },
            { label: "color", rgb: "rgb(212, 56, 13)", hex: "#d4380d" },
            { label: "color", rgb: "rgb(212, 107, 8)", hex: "#d46b08" },
            { label: "color", rgb: "rgb(212, 177, 6)", hex: "#d4b106" },
            { label: "color", rgb: "rgb(56, 158, 13)", hex: "#389e0d" },
            { label: "color", rgb: "rgb(8, 151, 156)", hex: "#08979c" },
            { label: "color", rgb: "rgb(9, 109, 217)", hex: "#096dd9" },
            { label: "color", rgb: "rgb(29, 57, 196)", hex: "#1d39c4" },
            { label: "color", rgb: "rgb(83, 29, 171)", hex: "#531dab" },
            { label: "color", rgb: "rgb(196, 29, 127)", hex: "#c41d7f" }
          ],
          [
            { label: "color", rgb: "rgb(130, 0, 20)", hex: "#820014" },
            { label: "color", rgb: "rgb(135, 20, 0)", hex: "#871400" },
            { label: "color", rgb: "rgb(135, 56, 0)", hex: "#873800" },
            { label: "color", rgb: "rgb(97, 71, 0)", hex: "#614700" },
            { label: "color", rgb: "rgb(19, 82, 0)", hex: "#135200" },
            { label: "color", rgb: "rgb(0, 71, 79)", hex: "#00474f" },
            { label: "color", rgb: "rgb(0, 58, 140)", hex: "#003a8c" },
            { label: "color", rgb: "rgb(6, 17, 120)", hex: "#061178" },
            { label: "color", rgb: "rgb(34, 7, 94)", hex: "#22075e" },
            { label: "color", rgb: "rgb(120, 6, 80)", hex: "#780650" }
          ]
        ]);
        return (l, c2) => (openBlock(), createElementBlock("section", SC, [
          createBaseVNode("div", {
            class: "default-color",
            onClick: c2[0] || (c2[0] = (u) => o({ hex: n3.defaultColor }))
          }, [
            createBaseVNode("div", CC, [
              createBaseVNode("div", {
                class: "cell border",
                style: normalizeStyle({ background: n3.defaultColor })
              }, [
                createVNode(unref(ye), { name: "slash_forward" })
              ], 4)
            ]),
            createBaseVNode("div", xC, toDisplayString(n3.defaultLabel), 1)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (u, d) => (openBlock(), createElementBlock("div", {
            class: "color-row",
            key: `row-${d}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(u, (p2, f) => (openBlock(), createElementBlock("div", {
              class: "",
              key: `col-${f}`
            }, [
              createBaseVNode("div", {
                class: "cell-container",
                onClick: (h2) => o(p2)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["cell", { border: p2.border }]),
                  style: normalizeStyle({ backgroundColor: p2.hex })
                }, [
                  i(p2.hex) ? (openBlock(), createBlock(unref(ye), {
                    key: 0,
                    name: "done",
                    style: normalizeStyle({ color: s(p2.rgb) })
                  }, null, 8, ["style"])) : createCommentVNode("", true)
                ], 6)
              ], 8, TC)
            ]))), 128))
          ]))), 128))
        ]));
      }
    }), Lt = /* @__PURE__ */ defineComponent({
      __name: "OCommandBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n3, { emit: e }) {
        const t = e;
        return (r, o) => (openBlock(), createBlock(unref(wo), { placement: n3.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n3.contentClass]),
              style: normalizeStyle(n3.contentStyle),
              onClick: o[0] || (o[0] = (i) => t("click", i))
            }, [
              createVNode(unref(ye), {
                name: n3.icon,
                color: n3.color,
                class: normalizeClass(n3.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(r.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n3.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), Dc = /* @__PURE__ */ defineComponent({
      __name: "OCommonBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n3, { emit: e }) {
        const t = e;
        return (r, o) => (openBlock(), createBlock(unref(wo), { placement: n3.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n3.contentClass]),
              style: normalizeStyle(n3.contentStyle),
              onClick: o[0] || (o[0] = (i) => t("click", i))
            }, [
              createVNode(unref(ye), {
                name: n3.icon,
                color: n3.color,
                class: normalizeClass(n3.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(r.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n3.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), ql = [
      {
        label: "Arduino",
        value: "arduino",
        icon: "code_blocks"
      },
      {
        label: "Bash",
        value: "bash",
        icon: "code_blocks"
      },
      {
        label: "C",
        value: "c",
        icon: "code_blocks"
      },
      {
        label: "C++",
        value: "cpp",
        icon: "code_blocks"
      },
      {
        label: "C#",
        value: "csharp",
        icon: "code_blocks"
      },
      {
        label: "CSS",
        value: "css",
        icon: "code_blocks"
      },
      {
        label: "Diff",
        value: "diff",
        icon: "code_blocks"
      },
      {
        label: "Go",
        value: "go",
        icon: "code_blocks"
      },
      {
        label: "GraphQL",
        value: "graphql",
        icon: "code_blocks"
      },
      {
        label: "Ini",
        value: "ini",
        icon: "code_blocks"
      },
      {
        label: "Java",
        value: "java",
        icon: "code_blocks"
      },
      {
        label: "JavaScript",
        value: "javascript",
        icon: "code_blocks"
      },
      {
        label: "JSON",
        value: "json",
        icon: "code_blocks"
      },
      {
        label: "Kotlin",
        value: "kotlin",
        icon: "code_blocks"
      },
      {
        label: "Less",
        value: "less",
        icon: "code_blocks"
      },
      {
        label: "Lua",
        value: "lua",
        icon: "code_blocks"
      },
      {
        label: "Makefile",
        value: "makefile",
        icon: "code_blocks"
      },
      {
        label: "Markdown",
        value: "markdown",
        icon: "code_blocks"
      },
      {
        label: "Objective-C",
        value: "objectivec",
        icon: "code_blocks"
      },
      {
        label: "Perl",
        value: "perl",
        icon: "code_blocks"
      },
      {
        label: "PHP",
        value: "php",
        icon: "code_blocks"
      },
      {
        label: "PHP-Template",
        value: "php-template",
        icon: "code_blocks"
      },
      {
        label: "Plain Text",
        value: "plaintext",
        icon: "code_blocks"
      },
      {
        label: "Python",
        value: "python",
        icon: "code_blocks"
      },
      {
        label: "Python-Repl",
        value: "python-repl",
        icon: "code_blocks"
      },
      {
        label: "R",
        value: "r",
        icon: "code_blocks"
      },
      {
        label: "Ruby",
        value: "ruby",
        icon: "code_blocks"
      },
      {
        label: "Rust",
        value: "rust",
        icon: "code_blocks"
      },
      {
        label: "Scss",
        value: "scss",
        icon: "code_blocks"
      },
      {
        label: "Shell",
        value: "shell",
        icon: "code_blocks"
      },
      {
        label: "SQL",
        value: "sql",
        icon: "code_blocks"
      },
      {
        label: "Swift",
        value: "swift",
        icon: "code_blocks"
      },
      {
        label: "TypeScript",
        value: "typescript",
        icon: "code_blocks"
      },
      {
        label: "VB.Net",
        value: "vbnet",
        icon: "code_blocks"
      },
      {
        label: "WebAssembly",
        value: "wasm",
        icon: "code_blocks"
      },
      {
        label: "XML",
        value: "xml",
        icon: "code_blocks"
      },
      {
        label: "YAML",
        value: "yaml",
        icon: "code_blocks"
      }
    ], OC = { class: "selected-language" }, NC = { class: "header" }, MC = { class: "o-scroll" }, AC = /* @__PURE__ */ defineComponent({
      __name: "OLanguageDropdown",
      props: {
        language: {
          type: String,
          default: "shell"
        }
      },
      emits: ["select"],
      setup(n3, { emit: e }) {
        const t = n3, r = e;
        Le();
        const i = ref(), s = ref(), a = ref(""), l = ref(0), c2 = ref(""), u = computed(() => a.value ? ql.filter(
          (b) => b.value.toLowerCase().indexOf(a.value.toLowerCase()) >= 0
        ) : ql), d = computed(() => ql.find((b) => b.value === c2.value));
        function p2(b) {
          b && setTimeout(() => {
            var w;
            (w = s.value) == null || w.focus(), l.value = 0, window.addEventListener("keyup", g);
          }, 0);
        }
        function f() {
          window.removeEventListener("keyup", g);
        }
        function h2(b) {
          f(), c2.value = b.value, r("select", b.value);
        }
        function m() {
          h2(u.value[l.value]);
        }
        function g(b) {
          if (u.value.length > 0) {
            switch (b.code) {
              case "ArrowDown":
                l.value = l.value + 1;
                break;
              case "ArrowUp":
                l.value = l.value - 1;
                break;
              case "Enter":
                m();
                break;
            }
            l.value >= u.value.length && (l.value = 0), l.value < 0 && (l.value = u.value.length - 1);
          } else
            l.value = 0;
        }
        return onMounted(() => {
          c2.value = t.language;
        }), (b, w) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: i,
          placement: "bottom-start",
          trigger: "click",
          "tippy-class": "o-language-popover dropdown",
          "onUpdate:show": p2
        }, {
          trigger: withCtx(() => [
            createVNode(unref(sn), { class: "o-dropdown-btn" }, {
              default: withCtx(() => {
                var _;
                return [
                  createBaseVNode("span", OC, toDisplayString((_ = d.value) == null ? void 0 : _.label), 1),
                  createVNode(unref(ye), {
                    name: "arrow_drop_down",
                    class: "arrow"
                  })
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("header", NC, [
              createVNode(unref(ls), {
                ref_key: "input",
                ref: s,
                modelValue: a.value,
                "onUpdate:modelValue": w[0] || (w[0] = (_) => a.value = _),
                type: "text",
                placeholder: "Search",
                autofocus: "",
                clearable: ""
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "search",
                    class: "o-tips"
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createBaseVNode("section", MC, [
              createVNode(unref(Pn), {
                hoverable: "",
                clickable: ""
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(u.value, (_, v) => (openBlock(), createBlock(unref(Nn), {
                    key: v,
                    onClick: (T) => h2(_),
                    class: normalizeClass({
                      "is-active": _.value === c2.value,
                      "is-select": v === l.value
                    })
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: _.icon
                      }, null, 8, ["name"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "class"]))), 128))
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 512));
      }
    }), RC = { class: "o-media-input" }, IC = { class: "fields" }, DC = /* @__PURE__ */ createBaseVNode("div", { class: "o-media-title" }, "Link", -1), LC = { class: "actions" }, yg = /* @__PURE__ */ defineComponent({
      __name: "OMediaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["input"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: o } = Le(), i = ref(), s = ref(""), a = ref("");
        function l() {
          return a.value ? (s.value = "null", true) : (s.value = "error", false);
        }
        function c2() {
          l() && r("input", a.value);
        }
        return onMounted(() => {
          a.value = t.val, setTimeout(() => {
            var u;
            (u = i.value) == null || u.focus();
          }, 0);
        }), (u, d) => (openBlock(), createElementBlock("section", RC, [
          createBaseVNode("section", IC, [
            DC,
            createVNode(unref(ls), {
              ref_key: "input",
              ref: i,
              modelValue: a.value,
              "onUpdate:modelValue": d[0] || (d[0] = (p2) => a.value = p2),
              status: s.value,
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ye), {
                  name: "link",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue", "status"])
          ]),
          createBaseVNode("footer", LC, [
            createVNode(unref(sn), {
              type: "info",
              onClick: c2
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), BC = { class: "o-meta-input" }, PC = { class: "header" }, $C = { class: "title" }, FC = { class: "fields" }, zC = { class: "actions" }, vg = /* @__PURE__ */ defineComponent({
      __name: "OMetaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: "Link"
        },
        type: {
          type: String,
          default: "link"
        },
        icon: {
          type: String,
          default: "link"
        },
        secondIcon: {
          type: String,
          default: ""
        },
        secondLabel: {
          type: String,
          default: ""
        }
      },
      emits: ["cancel", "confirm"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: o } = Le(), i = ref(null), s = ref("");
        function a() {
          console.log("confirm", s.value), r("confirm", s.value);
        }
        return onMounted(() => {
          s.value = t.val, setTimeout(() => {
            var l;
            (l = i.value) == null || l.focus();
          }, 0);
        }), (l, c2) => (openBlock(), createElementBlock("section", BC, [
          createBaseVNode("section", PC, [
            createBaseVNode("div", $C, toDisplayString(n3.title), 1),
            createBaseVNode("div", null, [
              renderSlot(l.$slots, "header-right")
            ])
          ]),
          createBaseVNode("section", FC, [
            createVNode(unref(ls), {
              ref_key: "input",
              ref: i,
              modelValue: s.value,
              "onUpdate:modelValue": c2[0] || (c2[0] = (u) => s.value = u),
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ye), {
                  name: n3.icon,
                  class: "o-tips"
                }, null, 8, ["name"])
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          createBaseVNode("footer", zC, [
            createVNode(unref(sn), {
              type: "tertiary",
              onClick: c2[1] || (c2[1] = (u) => r("cancel"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.cancel")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(sn), {
              type: "info",
              onClick: a
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(o)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), HC = { class: "o-table-grid" }, UC = ["onMouseover"], VC = /* @__PURE__ */ defineComponent({
      __name: "OTableGrid",
      emits: ["select"],
      setup(n3, { emit: e }) {
        const t = e, r = ref(6), o = ref(6), i = ref(2), s = ref(2);
        function a(c2, u) {
          i.value = c2, s.value = u, r.value === c2 && r.value < 10 && (r.value += 1), o.value === u && o.value < 10 && (o.value += 1);
        }
        function l() {
          t("select", {
            rows: i.value,
            cols: s.value,
            withHeaderRow: true
          });
        }
        return (c2, u) => (openBlock(), createElementBlock("section", HC, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (d, p2) => (openBlock(), createElementBlock("div", {
            class: "rows",
            key: `row-${p2}`
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (f, h2) => (openBlock(), createElementBlock("div", {
              key: `col-${h2}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["cell", { selected: d <= i.value && f <= s.value }]),
                onMouseover: (m) => a(d, f),
                onClick: l
              }, null, 42, UC)
            ]))), 128))
          ]))), 128)),
          createBaseVNode("footer", null, toDisplayString(i.value) + " x " + toDisplayString(s.value), 1)
        ]));
      }
    }), WC = { class: "o-table-cell-background o-button-group" }, qC = ["onClick"], KC = { class: "o-command-btn" }, GC = /* @__PURE__ */ defineComponent({
      __name: "OTableCellBackground",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(), i = ref("#ffec3d");
        function s() {
          a(i.value);
        }
        function a(l) {
          o.value.setShow(false), i.value = l, r(e.editor, "tableCellAttribute", {
            name: "background",
            value: i.value
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom-start",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(wo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", WC, [
                  createBaseVNode("div", {
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, [
                    createVNode(unref(ye), {
                      name: "crop_16_9",
                      class: "arrow"
                    }),
                    createBaseVNode("div", {
                      class: "indicator",
                      style: normalizeStyle(`background: ${i.value}`)
                    }, null, 4)
                  ], 8, qC),
                  createBaseVNode("div", KC, [
                    createVNode(unref(ye), { name: "arrow_drop_down" })
                  ])
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(Pu), {
              "default-color": "",
              "default-label": unref(t)("editor.noColor"),
              onSelect: a
            }, null, 8, ["default-label"])
          ]),
          _: 1
        }, 512));
      }
    }), jC = { class: "o-simple-color-board" }, JC = { class: "fore-colors" }, YC = /* @__PURE__ */ createBaseVNode("div", { class: "label o-tips" }, "Color", -1), XC = { class: "color-row" }, ZC = { class: "color-row" }, QC = { class: "back-colors" }, ex = /* @__PURE__ */ createBaseVNode("div", { class: "label o-tips" }, "Background", -1), tx = { class: "color-row" }, nx = { class: "color-row" }, rx = /* @__PURE__ */ defineComponent({
      __name: "OTextColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n3, { emit: e }) {
        const t = e;
        function r(s, a) {
          t("select", s, a.value);
        }
        const o = computed(() => [
          { label: "Grey", value: "#787774" },
          { label: "Brown", value: "#9F6B53" },
          { label: "Orange", value: "#D9730D" },
          { label: "Yellow", value: "#CB912F" },
          { label: "Green", value: "#448361" },
          { label: "Blue", value: "#337EA9" },
          { label: "Purple", value: "#9065B0" },
          { label: "Pink", value: "#C14C8A" },
          { label: "Red", value: "#D44C47" }
        ]), i = computed(() => [
          { label: "Grey", value: "#F1F1EF" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (s, a) => (openBlock(), createElementBlock("section", jC, [
          createBaseVNode("section", JC, [
            YC,
            createBaseVNode("div", XC, [
              createVNode(unref(Je), {
                icon: "format_text",
                tooltip: "Default color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => r("foreColor", { value: "" }))
              }),
              n3.foreColor ? (openBlock(), createBlock(unref(Je), {
                key: 0,
                icon: "format_text",
                color: n3.foreColor,
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[1] || (a[1] = (l) => r("foreColor", { value: n3.foreColor }))
              }, null, 8, ["color"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", ZC, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => (openBlock(), createBlock(unref(Je), {
                key: `col-${c2}`,
                icon: "format_text",
                color: l.value,
                tooltip: l.label,
                onClick: (u) => r("foreColor", l)
              }, null, 8, ["color", "tooltip", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", QC, [
            ex,
            createBaseVNode("div", tx, [
              createVNode(unref(Je), {
                icon: "slash_forward",
                tooltip: "No Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => r("backColor", { value: "" }))
              }),
              n3.backColor ? (openBlock(), createBlock(unref(Je), {
                key: 0,
                icon: "format_text",
                tooltip: "Last used",
                "content-class": "border",
                "content-style": { backgroundColor: n3.backColor },
                onClick: a[3] || (a[3] = (l) => r("backColor", { value: n3.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", nx, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (l, c2) => (openBlock(), createBlock(unref(Je), {
                key: `col-${c2}`,
                icon: "format_text",
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (u) => r("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), ma = [
      {
        type: "paragraph",
        content: []
      }
    ], wg = [
      {
        type: "listItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], kg = [
      {
        type: "taskItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], ox = { class: "o-add-node-view" }, ix = {
      key: 0,
      class: "view-main"
    }, sx = { class: "group o-tips" }, ax = { class: "panel" }, lx = { class: "group o-tips" }, cx = {
      key: 1,
      class: "item"
    }, ux = {
      key: 1,
      class: "view-emoji"
    }, dx = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: xt,
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: i } = Le(), a = ref("main"), l = ref(0);
        function c2(p2) {
          const f = t.editor.chain();
          let h2 = null;
          switch (p2.value) {
            case "blockquote":
              h2 = {
                content: ma
              };
              break;
            case "callout":
              h2 = {
                content: ma,
                attrs: { icon: "" }
              };
              break;
            case "codeBlock":
              h2 = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              h2 = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              h2 = {
                attrs: p2.options
              };
              break;
            case "horizontalRule":
              h2 = {};
              break;
            case "paragraph":
              h2 = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              h2 = {
                content: wg
              };
              break;
            case "taskList":
              h2 = {
                content: kg
              };
              break;
            case "table":
              setTimeout(() => {
                f.insertContentAt(d.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              h2 = {
                type: "paragraph",
                content: [{ type: p2.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              h2 = { attrs: { src: "init" } };
              break;
          }
          h2 && (h2.type = h2.type || p2.value, setTimeout(() => {
            u.value ? f.insertContent(h2).focus().run() : f.insertContentAt(d.value, h2).focus().run();
          }, 1)), r("action", p2);
        }
        const u = computed(() => t.node.content.size === 0), d = computed(() => u.value ? l.value : l.value + t.node.nodeSize);
        return onMounted(() => {
          l.value = t.getPos();
        }), (p2, f) => (openBlock(), createElementBlock("section", ox, [
          a.value === "main" ? (openBlock(), createElementBlock("section", ix, [
            createBaseVNode("section", null, [
              createBaseVNode("div", sx, toDisplayString(unref(i)("label.basic")), 1),
              createBaseVNode("section", ax, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(as), (h2, m) => (openBlock(), createBlock(unref(Je), {
                  key: m,
                  icon: h2.icon,
                  tooltip: unref(i)(h2.label),
                  quaternary: "",
                  onClick: (g) => c2(h2)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Wi).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Wi), (h2, m) => (openBlock(), createElementBlock(Fragment, { key: m }, [
                  h2.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    m > 0 ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", lx, toDisplayString(unref(i)(h2.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(Nn), {
                    class: "item",
                    clickable: "",
                    onClick: (g) => c2(h2)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: h2.icon,
                        color: h2.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i)(h2.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", cx, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", ux)) : createCommentVNode("", true)
        ]));
      }
    }), px = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: xt,
      setup(n3) {
        const e = n3, t = ref(null), r = ref(false);
        function o(s) {
          r.value = s;
        }
        function i() {
          var s;
          (s = t.value) == null || s.setShow(false), r.value = false;
        }
        return (s, a) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: t,
          placement: "left",
          trigger: "mouseenter",
          arrow: "",
          "onUpdate:show": o
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-node", { "is-selected": r.value }])
            }, [
              createVNode(unref(sn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(dx, mergeProps(e, { onAction: i }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), fx = { class: "o-drag-node-view" }, hx = {
      key: 0,
      class: "view-main"
    }, mx = { key: 0 }, gx = /* @__PURE__ */ createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1), bx = { class: "panel" }, yx = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: xt,
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: i } = Le(), { onCommand: a } = Qe(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var g, b;
          const m = (g = t.node) == null ? void 0 : g.content.content;
          if (m.length > 0) {
            const w = m[0];
            if (w.type.name === "image")
              return w.type.name;
          }
          return (b = t.node) == null ? void 0 : b.type.name;
        }), d = computed(() => ha.find((m) => m.value === u.value));
        function p2(m) {
          var g;
          return m.value === u.value && ((g = t.editor) == null ? void 0 : g.isActive(u.value, m.options));
        }
        function f(m) {
          switch (m.value) {
            default:
              h2(m);
              break;
          }
          r("action", m);
        }
        function h2(m) {
          var _, v, T, S, z;
          const g = t.getPos();
          if (m.value === u.value && c2.value.indexOf(u.value) < 0) {
            const U = (_ = t.editor) == null ? void 0 : _.isActive(u.value), B = (v = t.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, U, B);
            return;
          }
          const b = (T = t.editor) == null ? void 0 : T.commands, w = (S = t.editor) == null ? void 0 : S.chain().focus(g + 1);
          console.log("runCommand", m), a(b, w, m.value, m.options), (z = t.editor) == null || z.commands.setNodeSelection(g);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: Be.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: Be.deepOrange
          }
        ]), (m, g) => (openBlock(), createElementBlock("section", fx, [
          l.value === "main" ? (openBlock(), createElementBlock("section", hx, [
            d.value ? (openBlock(), createElementBlock("section", mx, [
              gx,
              createBaseVNode("section", bx, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(ha), (b, w) => (openBlock(), createBlock(unref(Je), {
                  key: w,
                  icon: b.icon,
                  tooltip: unref(i)(b.label),
                  "content-class": { "is-active": p2(b) },
                  quaternary: "",
                  onClick: (_) => f(b)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Qo), mergeProps(t, {
              colorful: "",
              "show-group": "",
              onAction: f
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), vx = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: xt,
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, i = ref(null), s = ref(0), a = ref(false), l = ref(["heading", "codeBlock", "paragraph"]), c2 = ref(false), u = computed(() => {
          var w, _;
          const b = (w = t.node) == null ? void 0 : w.content.content;
          if (b.length > 0) {
            const v = b[0];
            if (v.type.name === "image")
              return v.type.name;
          }
          return (_ = t.node) == null ? void 0 : _.type.name;
        }), d = computed(() => {
          var w;
          let b = u.value;
          return b === "heading" ? {
            icon: `format_h${((w = t.node.attrs) == null ? void 0 : w.level) || 1}`,
            color: Be.blue
          } : (b === "table-wrapper" && (b = "table"), Lu.find((_) => _.value === b) || { icon: "title" });
        });
        function p2(b) {
          var w;
          (w = i.value) == null || w.setShow(false), r("action", b);
        }
        function f(b) {
          a.value = b, console.log("show", b), b && h2();
        }
        function h2() {
          var w;
          let b = t.getPos();
          l.value.includes(u.value) || (b += 1), (w = t.editor) == null || w.commands.setNodeSelection(b), s.value = b;
        }
        function m(b) {
          c2.value = true, setTimeout(() => {
            c2.value = false;
          }, 10);
        }
        function g(b) {
          c2.value = false;
        }
        return (b, w) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: i,
          placement: "left",
          size: "medium",
          trigger: "click",
          arrow: "",
          "onUpdate:show": f
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-node", { "is-selected": a.value, "is-dragging": c2.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: m,
              onDragend: g
            }, [
              createVNode(unref(sn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: d.value.icon,
                    color: d.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ye), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(yx, mergeProps(t, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), wx = /* @__PURE__ */ defineComponent({
      __name: "index",
      props: xt,
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, o = ref(false), i = ref(0);
        ref(0);
        const s = computed(() => a.value === "paragraph" && t.node.content.size === 0), a = computed(() => {
          var p2, f;
          const d = (p2 = t.node) == null ? void 0 : p2.content.content;
          if (d.length > 0) {
            const h2 = d[0];
            if (h2.type.name === "image")
              return h2.type.name;
          }
          return (f = t.node) == null ? void 0 : f.type.name;
        }), l = computed(() => {
          var d;
          return i.value || ((d = t.node.attrs) == null ? void 0 : d.level);
        }), c2 = computed(() => a.value === "heading" ? `type-heading-${l.value}` : `type-${a.value}`);
        function u(d) {
          r("action", d);
        }
        return onMounted(() => {
          i.value = 0;
        }), (d, p2) => {
          var f;
          return (f = d.editor) != null && f.isEditable ? (openBlock(), createElementBlock("section", {
            key: 0,
            class: normalizeClass(["o-side-node", { "is-active": o.value, "is-empty": s.value }])
          }, [
            createBaseVNode("section", {
              class: normalizeClass(["action-container", c2.value])
            }, [
              createVNode(px, normalizeProps(guardReactiveProps(t)), null, 16),
              s.value ? createCommentVNode("", true) : (openBlock(), createBlock(vx, mergeProps({ key: 0 }, t, { onAction: u }), null, 16))
            ], 2)
          ], 2)) : createCommentVNode("", true);
        };
      }
    }), yr = /* @__PURE__ */ defineComponent({
      __name: "ONodeView",
      props: xt,
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, o = inject("sideNode", { value: false });
        return computed(() => {
          const i = {};
          return t.node.attrs["data-id"] && (i["data-id"] = t.node.attrs["data-id"]), i;
        }), (i, s) => (openBlock(), createBlock(unref(Iu), { class: "o-node-view" }, {
          default: withCtx(() => {
            var a;
            return [
              unref(o) && ((a = i.editor) != null && a.isEditable) ? (openBlock(), createBlock(wx, mergeProps({ key: 0 }, t, {
                onAction: s[0] || (s[0] = (l) => r("action"))
              }), null, 16)) : createCommentVNode("", true),
              renderSlot(i.$slots, "default")
            ];
          }),
          _: 3
        }));
      }
    }), kx = { class: "o-add-node-view" }, Ex = {
      key: 0,
      class: "view-main"
    }, _x = { class: "group o-tips" }, Sx = { class: "panel" }, Cx = { class: "group o-tips" }, xx = {
      key: 1,
      class: "item"
    }, Tx = {
      key: 1,
      class: "view-emoji"
    }, Ox = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: i } = Le(), a = ref("main");
        function l(d) {
          const p2 = t.editor.chain();
          let f = null;
          switch (d.value) {
            case "blockquote":
              f = {
                content: ma
              };
              break;
            case "callout":
              f = {
                content: ma,
                attrs: { icon: "" }
              };
              break;
            case "codeBlock":
              f = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              f = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              f = {
                attrs: d.options
              };
              break;
            case "horizontalRule":
              f = {};
              break;
            case "paragraph":
              f = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              f = {
                content: wg
              };
              break;
            case "taskList":
              f = {
                content: kg
              };
              break;
            case "table":
              setTimeout(() => {
                p2.insertContentAt(u.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              f = {
                type: "paragraph",
                content: [{ type: d.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              f = { attrs: { src: "init" } };
              break;
          }
          f && (console.log("add", t.getPos(), u.value), f.type = f.type || d.value, setTimeout(() => {
            c2.value ? p2.insertContent(f).focus().run() : p2.insertContentAt(u.value, f).focus().run();
          }, 1)), r("action", d);
        }
        const c2 = computed(() => {
          var d;
          return ((d = t.node) == null ? void 0 : d.content.size) === 0;
        }), u = computed(() => c2.value ? t.getPos() : t.getPos() + t.node.nodeSize);
        return (d, p2) => (openBlock(), createElementBlock("section", kx, [
          a.value === "main" ? (openBlock(), createElementBlock("section", Ex, [
            createBaseVNode("section", null, [
              createBaseVNode("div", _x, toDisplayString(unref(i)("label.basic")), 1),
              createBaseVNode("section", Sx, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(as), (f, h2) => (openBlock(), createBlock(unref(Je), {
                  key: h2,
                  icon: f.icon,
                  tooltip: unref(i)(f.label),
                  quaternary: "",
                  onClick: (m) => l(f)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Wi).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(Wi), (f, h2) => (openBlock(), createElementBlock(Fragment, { key: h2 }, [
                  f.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    h2 > 0 ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", Cx, toDisplayString(unref(i)(f.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(Nn), {
                    class: "item",
                    clickable: "",
                    onClick: (m) => l(f)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: f.icon,
                        color: f.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i)(f.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", xx, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", Tx)) : createCommentVNode("", true)
        ]));
      }
    }), Nx = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      setup(n3) {
        const e = n3, t = ref(), r = ref(false), o = computed(() => {
          var l;
          return ((l = e.node) == null ? void 0 : l.content.size) === 0;
        });
        computed(() => o.value ? e.getPos() : e.getPos() + e.node.nodeSize);
        function i(l) {
          r.value = l;
        }
        function s() {
          var l;
          (l = t.value) == null || l.setShow(true);
        }
        function a() {
          var l;
          (l = t.value) == null || l.setShow(false), r.value = false;
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: t,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "manual",
          offset: [0, 4],
          "onUpdate:show": i
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-btn", { "is-selected": r.value }])
            }, [
              createVNode(unref(sn), {
                type: "tertiary",
                class: "o-node-btn",
                onClick: s
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(Ox, mergeProps(e, { onAction: a }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), Mx = { class: "o-drag-node-view" }, Ax = {
      key: 0,
      class: "view-main"
    }, Rx = { key: 0 }, Ix = /* @__PURE__ */ createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1), Dx = { class: "panel" }, Lx = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, { tr: i } = Le(), { onCommand: a } = Qe(), l = ref("main"), c2 = ref(["heading", "codeBlock", "paragraph"]), u = computed(() => {
          var g, b;
          const m = (g = t.node) == null ? void 0 : g.content.content;
          if (m.length > 0) {
            const w = m[0];
            if (w.type.name === "image")
              return w.type.name;
          }
          return (b = t.node) == null ? void 0 : b.type.name;
        }), d = computed(() => ha.find((m) => m.value === u.value));
        function p2(m) {
          var g;
          return m.value === u.value && ((g = t.editor) == null ? void 0 : g.isActive(u.value, m.options));
        }
        function f(m) {
          switch (m.value) {
            case "delete":
              break;
            case "duplicate":
              break;
            default:
              h2(m);
              break;
          }
          r("action", m);
        }
        function h2(m) {
          var _, v, T, S, z;
          const g = t.getPos();
          if (m.value === u.value && c2.value.indexOf(u.value) < 0) {
            const U = (_ = t.editor) == null ? void 0 : _.isActive(u.value), B = (v = t.editor) == null ? void 0 : v.commands.lift(u.value);
            console.log("lift", u.value, U, B);
            return;
          }
          const b = (T = t.editor) == null ? void 0 : T.commands, w = (S = t.editor) == null ? void 0 : S.chain().focus(g + 1);
          console.log("runCommand", m), a(b, w, m.value, m.options), (z = t.editor) == null || z.commands.setNodeSelection(g);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: Be.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: Be.deepOrange
          }
        ]), (m, g) => (openBlock(), createElementBlock("section", Mx, [
          l.value === "main" ? (openBlock(), createElementBlock("section", Ax, [
            d.value ? (openBlock(), createElementBlock("section", Rx, [
              Ix,
              createBaseVNode("section", Dx, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(ha), (b, w) => (openBlock(), createBlock(unref(Je), {
                  key: w,
                  icon: b.icon,
                  tooltip: unref(i)(b.label),
                  "content-class": { "is-active": p2(b) },
                  quaternary: "",
                  onClick: (_) => f(b)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(Qo), mergeProps(t, {
              colorful: "",
              "show-group": "",
              onAction: f
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), Bx = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action", "dragstart", "dragend"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, i = ref(null), s = ref(false), a = ref(["heading", "codeBlock", "paragraph"]), l = computed(() => {
          var g, b, w;
          const m = (b = (g = t.node) == null ? void 0 : g.content) == null ? void 0 : b.content;
          if ((m == null ? void 0 : m.length) > 0) {
            const _ = m[0];
            if (_.type.name === "image")
              return _.type.name;
          }
          return (w = t.node) == null ? void 0 : w.type.name;
        }), c2 = computed(() => {
          var g;
          let m = l.value;
          return m === "heading" ? {
            icon: `format_h${((g = t.node.attrs) == null ? void 0 : g.level) || 1}`,
            color: Be.blue
          } : (m === "table-wrapper" && (m = "table"), Lu.find((b) => b.value === m) || { icon: "title" });
        });
        function u(m) {
          r("dragstart", m);
        }
        function d(m) {
          r("dragend", m);
        }
        function p2(m) {
          var g;
          (g = i.value) == null || g.setShow(false), r("action", m);
        }
        function f(m) {
          s.value = m, console.log("show", m), m && h2();
        }
        function h2() {
          var g;
          let m = t.getPos();
          a.value.includes(l.value) || (m += 1), (g = t.editor) == null || g.commands.setNodeSelection(m);
        }
        return watch(
          () => t.getPos(),
          (m) => {
            var g;
            (g = i.value) == null || g.setShow(false);
          }
        ), (m, g) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: i,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "click",
          offset: [0, 2],
          "onUpdate:show": f
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-btn", { selected: s.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: u,
              onDragend: d
            }, [
              createVNode(unref(sn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ye), {
                    name: c2.value.icon,
                    color: c2.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ye), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(Lx, mergeProps(t, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), sn = /* @__PURE__ */ defineComponent({
      __name: "OBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["click"],
      setup(n3, { emit: e }) {
        const t = e;
        return (r, o) => (openBlock(), createElementBlock("button", {
          class: normalizeClass(["o-btn", n3.type ? `type-${n3.type}` : ""]),
          onClick: o[0] || (o[0] = (i) => t("click", i))
        }, [
          n3.icon ? (openBlock(), createBlock(unref(ye), {
            key: 0,
            name: n3.icon,
            class: normalizeClass(n3.iconClass)
          }, null, 8, ["name", "class"])) : createCommentVNode("", true),
          renderSlot(r.$slots, "default")
        ], 2));
      }
    }), Px = { class: "o-checkbox" }, $x = { class: "o-checkbox__main" }, Fx = { class: "o-checkbox__suffix" }, Eg = /* @__PURE__ */ defineComponent({
      __name: "OCheckbox",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        label: {
          type: String,
          default: ""
        }
      },
      emits: ["update:modelValue"],
      setup(n3, { emit: e }) {
        const t = n3, r = e, o = computed({
          get() {
            return t.modelValue;
          },
          set(i) {
            r("update:modelValue", i);
          }
        });
        return (i, s) => (openBlock(), createElementBlock("div", Px, [
          createBaseVNode("div", $x, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": s[0] || (s[0] = (a) => o.value = a),
              type: "checkbox"
            }, null, 512), [
              [vModelCheckbox, o.value]
            ])
          ]),
          createBaseVNode("div", Fx, toDisplayString(n3.label), 1)
        ]));
      }
    }), On = /* @__PURE__ */ defineComponent({
      __name: "ODivider",
      props: {
        vertical: {
          type: Boolean,
          default: false
        }
      },
      setup(n3) {
        return (e, t) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-divider", { "o-divider-vertical": n3.vertical }])
        }, null, 2));
      }
    }), zx = { class: "o-input__prefix" }, Hx = { class: "o-input__main" }, Ux = { class: "o-input__suffix" }, ls = /* @__PURE__ */ defineComponent({
      __name: "OInput",
      props: {
        modelValue: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["blur", "update:modelValue"],
      setup(n3, { expose: e, emit: t }) {
        const r = n3, o = t, i = ref(null), s = computed({
          get() {
            return r.modelValue;
          },
          set(c2) {
            o("update:modelValue", c2);
          }
        });
        function a() {
          var c2;
          (c2 = i.value) == null || c2.focus();
        }
        function l() {
          s.value = "", a();
        }
        return e({
          clear: l,
          focus: a
        }), (c2, u) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-input", `type-${n3.type}`])
        }, [
          createBaseVNode("div", zx, [
            renderSlot(c2.$slots, "prefix")
          ]),
          createBaseVNode("div", Hx, [
            withDirectives(createBaseVNode("input", {
              ref_key: "input",
              ref: i,
              "onUpdate:modelValue": u[0] || (u[0] = (d) => s.value = d),
              onBlur: u[1] || (u[1] = (d) => o("blur"))
            }, null, 544), [
              [vModelText, s.value]
            ])
          ]),
          createBaseVNode("div", Ux, [
            renderSlot(c2.$slots, "suffix"),
            n3.clearable && s.value ? (openBlock(), createBlock(ye, {
              key: 0,
              name: "close",
              class: "clear o-tips",
              onClick: l
            })) : createCommentVNode("", true)
          ])
        ], 2));
      }
    }), Pn = /* @__PURE__ */ defineComponent({
      __name: "OList",
      props: {
        clickable: {
          type: Boolean,
          default: false
        },
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(n3) {
        return (e, t) => (openBlock(), createElementBlock("ul", {
          class: normalizeClass(["o-list", { clickable: n3.clickable, hoverable: n3.hoverable }])
        }, [
          renderSlot(e.$slots, "default")
        ], 2));
      }
    }), Vx = { class: "o-list-item" }, Wx = { class: "o-list-item__prefix" }, qx = { class: "o-list-item__main" }, Kx = { class: "o-list-item__suffix" }, Nn = /* @__PURE__ */ defineComponent({
      __name: "OListItem",
      props: {
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(n3) {
        return (e, t) => (openBlock(), createElementBlock("li", Vx, [
          createBaseVNode("div", Wx, [
            renderSlot(e.$slots, "prefix")
          ]),
          createBaseVNode("div", qx, [
            renderSlot(e.$slots, "default")
          ]),
          createBaseVNode("div", Kx, [
            renderSlot(e.$slots, "suffix")
          ])
        ]));
      }
    }), at = /* @__PURE__ */ defineComponent({
      __name: "OPopover",
      props: {
        show: {
          type: Boolean,
          default: false
        },
        arrow: {
          type: Boolean,
          default: false
        },
        offset: {
          type: Array,
          default: function() {
            return [0, 10];
          }
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
        },
        tippyClass: {
          type: String,
          default: ""
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:show"],
      setup(n3, { expose: e, emit: t }) {
        const r = n3, o = t, { theme: i } = al(), s = ref(null), a = ref(), l = ref();
        function c2(f) {
          var h2, m, g, b;
          f ? ((m = l.value) == null || m.setProps({
            getReferenceClientRect: (h2 = r.event) != null && h2.clientX ? u : null
          }), (g = l.value) == null || g.show()) : (b = l.value) == null || b.hide();
        }
        function u() {
          var f, h2;
          return {
            width: 0,
            height: 0,
            left: r.event.clientX,
            right: r.event.clientX,
            top: r.event.clientY,
            bottom: r.event.clientY,
            x: ((f = r.event) == null ? void 0 : f.clientX) || 0,
            // add missing x
            y: ((h2 = r.event) == null ? void 0 : h2.clientY) || 0,
            toJSON: () => {
              var m, g;
              return {
                // add toJSON method to satisfy DOMRect
                width: 100,
                height: 100,
                left: ((m = r.event) == null ? void 0 : m.clientX) || 0,
                top: ((g = r.event) == null ? void 0 : g.clientY) || 0
              };
            }
          };
        }
        function d() {
          l.value = er(s.value, {
            appendTo: () => document.body,
            animation: "shift-away",
            // perspective, scale, shift-away
            arrow: r.arrow,
            content: a.value,
            delay: 100,
            duration: 200,
            interactive: true,
            // offset: props.offset, // todo
            placement: r.placement,
            trigger: r.trigger,
            theme: i.value,
            onShow: (f) => {
              o("update:show", true);
            },
            onHide: (f) => {
              o("update:show", false);
            }
          });
        }
        function p2() {
          l.value.setProps({
            theme: i.value
          });
        }
        return watch(i, (f) => {
          p2();
        }), onMounted(() => {
          d();
        }), e({
          setShow: c2
        }), (f, h2) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: s,
          "data-tippy-role": "popover",
          class: "o-popover"
        }, [
          renderSlot(f.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: a,
            class: normalizeClass(["popover-content", n3.tippyClass])
          }, [
            renderSlot(f.$slots, "default")
          ], 2)
        ], 512));
      }
    }), Gx = /* @__PURE__ */ defineComponent({
      __name: "OAlignDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = computed(() => [
          { label: t("editor.left"), value: "left", icon: "format_align_center" },
          {
            label: t("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: t("editor.right"), value: "right", icon: "format_align_right" },
          {
            label: t("editor.justify"),
            value: "justify",
            icon: "format_align_justify"
          }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, "textAlign", {
            textAlign: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "format_align_center",
              "content-class": "o-align-dropdown dropdown",
              tooltip: unref(t)("editor.align")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(Nn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = n3.editor) == null ? void 0 : d.isActive({ textAlign: c2.value }) }),
                    onClick: (p2) => s(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = n3.editor) != null && p2.isActive({ textAlign: c2.value }) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), jx = { class: "o-align-group" }, Jx = /* @__PURE__ */ defineComponent({
      __name: "OAlignGroup",
      props: {
        editor: {
          type: Qn
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = computed(() => [
          { label: t("editor.left"), value: "left", icon: "format_align_left" },
          {
            label: t("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: t("editor.right"), value: "right", icon: "format_align_right" }
        ]);
        function i(s) {
          r(e.editor, "textAlign", {
            textAlign: s.value
          });
        }
        return (s, a) => (openBlock(), createElementBlock("div", jx, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(Je, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": {
                "is-active": (u = n3.editor) == null ? void 0 : u.isActive({ textAlign: l.value })
              },
              onClick: (d) => i(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), Yx = { class: "o-back-color-dropdown o-button-group" }, Xx = /* @__PURE__ */ defineComponent({
      __name: "OBackColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = ref("#ffec3d");
        function s() {
          a(i.value);
        }
        function a(l) {
          o.value.setShow(false), i.value = l, r(e.editor, "backColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(wo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", Yx, [
                  createVNode(unref(sn), {
                    icon: "ink_highlighter",
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${i.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(unref(sn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(Pu), {
                "default-color": "",
                "default-label": unref(t)("editor.noColor"),
                "active-color": (u = n3.editor) == null ? void 0 : u.getAttributes("highlight").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), Zx = /* @__PURE__ */ defineComponent({
      __name: "OFontFamilyDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = computed(() => [
          { label: t("editor.default"), value: "system-ui" },
          // todo
          { label: "Arial", value: "Arial", separator: true },
          { label: "Arial Black", value: "Arial Black" },
          { label: "Georgia", value: "Georgia" },
          { label: "Impact", value: "Impact" },
          { label: "Helvetica", value: "Helvetica" },
          { label: "Roboto", value: "Roboto" },
          { label: "Tahoma", value: "Tahoma" },
          { label: "Times New Roman", value: "Times New Roman" },
          { label: "Verdana", value: "Verdana" },
          { label: "Courier New", value: "Courier New", separator: true },
          { label: "Monaco", value: "Monaco" },
          { label: "Monospace", value: "monospace" }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, "fontFamily", {
            fontFamily: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "format_font",
              "content-class": "o-font-family-dropdown dropdown",
              tooltip: unref(t)("editor.fontFamily")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createElementBlock(Fragment, { key: u }, [
                    c2.separator ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                    createVNode(unref(Nn), {
                      class: normalizeClass({
                        "is-active": (d = n3.editor) == null ? void 0 : d.isActive("textStyle", {
                          fontFamily: c2.value
                        })
                      }),
                      onClick: (p2) => s(c2.value)
                    }, {
                      suffix: withCtx(() => {
                        var p2;
                        return [
                          (p2 = n3.editor) != null && p2.isActive("textStyle", { fontFamily: c2.value }) ? (openBlock(), createBlock(unref(ye), {
                            key: 0,
                            name: "done",
                            small: ""
                          })) : createCommentVNode("", true)
                        ];
                      }),
                      default: withCtx(() => [
                        createBaseVNode("span", {
                          style: normalizeStyle(`font-family: ${c2.value}`)
                        }, toDisplayString(c2.label), 5)
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])
                  ], 64);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), Qx = { class: "o-fore-color-dropdown o-button-group" }, e1 = /* @__PURE__ */ defineComponent({
      __name: "OForeColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = ref("#ff4d4f");
        function s() {
          a(i.value);
        }
        function a(l) {
          var c2;
          (c2 = o.value) == null || c2.setShow(false), i.value = l, r(e.editor, "foreColor", {
            color: l
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(wo), null, {
              trigger: withCtx(() => [
                createBaseVNode("div", Qx, [
                  createVNode(unref(sn), {
                    icon: "format_color_text",
                    class: "o-command-btn label",
                    onClick: withModifiers(s, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${i.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(unref(sn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.textColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(Pu), {
                "default-color": "",
                "default-label": unref(t)("editor.defaultColor"),
                "active-color": (u = n3.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), t1 = /* @__PURE__ */ defineComponent({
      __name: "OHeadingDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = computed(() => [
          {
            label: t("editor.paragraph"),
            value: "paragraph",
            valueAlt: "",
            icon: "title"
          },
          {
            label: t("editor.heading1"),
            value: "heading",
            valueAlt: 1,
            icon: "format_h1",
            separator: true
          },
          {
            label: t("editor.heading2"),
            value: "heading",
            valueAlt: 2,
            icon: "format_h2"
          },
          {
            label: t("editor.heading3"),
            value: "heading",
            valueAlt: 3,
            icon: "format_h3"
          },
          {
            label: t("editor.heading4"),
            value: "heading",
            valueAlt: 4,
            icon: "format_h4"
          },
          {
            label: t("editor.heading5"),
            value: "heading",
            valueAlt: 5,
            icon: "format_h5"
          }
        ]);
        function s(l) {
          var c2, u;
          return l.value === "heading" ? (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, { level: l.valueAlt }) : (u = e.editor) == null ? void 0 : u.isActive(l.value);
        }
        function a(l) {
          var c2;
          (c2 = o.value) == null || c2.setShow(false), r(e.editor, l.value, {
            level: l.valueAlt
          });
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "format_header_pound",
              "content-class": "o-heading-dropdown dropdown",
              tooltip: unref(t)("editor.heading")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(Nn), {
                    class: normalizeClass({ "is-active": s(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      s(u) ? (openBlock(), createBlock(unref(ye), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), n1 = { class: "o-list-dropdown o-button-group" }, r1 = /* @__PURE__ */ defineComponent({
      __name: "OListDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = ref();
        function s() {
          r(e.editor, i.value.value);
        }
        function a(c2) {
          o.value.setShow(false), i.value = c2, r(e.editor, c2.value);
        }
        const l = computed(() => [
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        return onMounted(() => {
          i.value = l.value[0];
        }), (c2, u) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(wo), { trigger: "hover" }, {
              trigger: withCtx(() => {
                var d;
                return [
                  createBaseVNode("div", n1, [
                    createVNode(unref(sn), {
                      icon: (d = i.value) == null ? void 0 : d.icon,
                      class: "o-command-btn",
                      onClick: withModifiers(s, ["stop"])
                    }, null, 8, ["icon", "onClick"]),
                    createVNode(unref(sn), {
                      icon: "arrow_drop_down",
                      class: "o-command-btn"
                    })
                  ])
                ];
              }),
              default: withCtx(() => {
                var d;
                return [
                  createTextVNode(" " + toDisplayString((d = i.value) == null ? void 0 : d.label), 1)
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => {
                  var f;
                  return openBlock(), createBlock(unref(Nn), {
                    key: p2,
                    class: normalizeClass({ "is-active": (f = n3.editor) == null ? void 0 : f.isActive(d.value) }),
                    onClick: (h2) => a(d)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: d.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var h2;
                      return [
                        (h2 = n3.editor) != null && h2.isActive(d.value) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(d.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), o1 = { class: "o-list-group" }, i1 = /* @__PURE__ */ defineComponent({
      __name: "OListGroup",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = computed(() => [
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        function i(s) {
          r(e.editor, s.value);
        }
        return (s, a) => (openBlock(), createElementBlock("div", o1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (l, c2) => {
            var u;
            return openBlock(), createBlock(Je, {
              key: c2,
              icon: l.icon,
              tooltip: l.label,
              "content-class": { "is-active": (u = n3.editor) == null ? void 0 : u.isActive(l.value) },
              onClick: (d) => i(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), s1 = /* @__PURE__ */ defineComponent({
      __name: "OLinkBtn",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(), i = ref(false), s = ref(""), a = ref(true);
        function l() {
          var p2;
          s.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (s.value = d.href, a.value = d.target === "_blank", console.log("show", i.value, d, a.value));
        }
        function c2() {
          var d;
          (d = o.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? r(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : r(e.editor, "linkUnset"), (p2 = o.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: i.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (f) => i.value = f),
            l
          ]
        }, {
          trigger: withCtx(() => {
            var f;
            return [
              createVNode(unref(Lt), {
                icon: "link",
                "content-class": { "is-active": (f = n3.editor) == null ? void 0 : f.isActive("link") },
                tooltip: unref(t)("editor.hyperlink")
              }, null, 8, ["content-class", "tooltip"])
            ];
          }),
          default: withCtx(() => [
            i.value ? (openBlock(), createBlock(unref(vg), {
              key: 0,
              title: unref(t)("editor.hyperlink"),
              val: s.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(Eg), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (f) => a.value = f),
                  label: unref(t)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), a1 = /* @__PURE__ */ defineComponent({
      __name: "OLinkEditBtn",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(), i = ref(false), s = ref(""), a = ref(true);
        function l() {
          var p2;
          s.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (s.value = d.href, a.value = d.target === "_blank");
        }
        function c2() {
          var d;
          (d = o.value) == null || d.setShow(false);
        }
        function u(d) {
          var p2;
          d ? r(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : r(e.editor, "linkUnset"), (p2 = o.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: i.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (f) => i.value = f),
            l
          ]
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "edit",
              tooltip: unref(t)("link.edit")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            i.value ? (openBlock(), createBlock(unref(vg), {
              key: 0,
              title: unref(t)("link.edit"),
              val: s.value,
              icon: "link",
              onCancel: c2,
              onConfirm: u
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(Eg), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (f) => a.value = f),
                  label: unref(t)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), l1 = /* @__PURE__ */ defineComponent({
      __name: "OLinkOpenBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le();
        function r() {
          var i;
          const o = (i = e.editor) == null ? void 0 : i.getAttributes("link");
          o != null && o.href && window.open(o.href, "target");
        }
        return (o, i) => (openBlock(), createBlock(Je, {
          icon: "open_in_new",
          tooltip: unref(t)("link.open"),
          "content-class": "o-link-open-btn",
          onClick: r
        }, null, 8, ["tooltip"]));
      }
    }), c1 = [
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "fore-color",
      "back-color",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "codeBlock",
      "link",
      "image",
      "video",
      "modelViewer",
      "table",
      "callout",
      // 'emoji',
      "columns",
      "aiViewer"
    ], u1 = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "link",
      "image"
    ], d1 = [
      "bold",
      "strike",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "list-group",
      "link",
      "callout",
      "separator",
      "align-dropdown",
      "more"
    ], p1 = ["link-open", "link-edit", "linkUnset"], f1 = ["align-group", "separator", "link"], h1 = [
      "align-group",
      "separator",
      "link-open",
      "link-edit",
      "linkUnset"
    ], m1 = [
      "heading",
      "separator",
      "italic",
      "underline",
      "font-family",
      "separator",
      "code",
      "blockquote"
    ], g1 = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "font-family",
      "text-color-dropdown",
      "separator",
      "align-group"
    ], b1 = [
      "style-dropdown",
      "separator",
      "bold",
      "italic",
      "text-color-dropdown",
      "separator",
      "align-dropdown"
    ], y1 = { class: "o-command-btn" }, v1 = { class: "o-more-bubble" }, w1 = /* @__PURE__ */ defineComponent({
      __name: "OMoreBubble",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = ref();
        return (t, r) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: e,
          offset: [4, 10],
          class: "o-simple-command-btn",
          "tippy-class": "o-more-bubble-popover",
          placement: "top-end",
          size: "medium",
          trigger: "mouseenter"
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", y1, [
              createVNode(unref(ye), { name: "more_horiz" })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("section", v1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(m1), (o, i) => (openBlock(), createElementBlock(Fragment, { key: i }, [
                o === "separator" ? (openBlock(), createBlock(unref(On), {
                  key: 0,
                  vertical: ""
                })) : typeof o == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(ll)(o)), {
                  key: 1,
                  name: o,
                  editor: n3.editor
                }, null, 8, ["name", "editor"])) : createCommentVNode("", true)
              ], 64))), 128))
            ])
          ]),
          _: 1
        }, 512));
      }
    }), k1 = /* @__PURE__ */ defineComponent({
      __name: "OStyleDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = computed(() => [
          { label: t("editor.paragraph"), value: "paragraph", icon: "title" },
          {
            label: t("editor.heading1"),
            value: "heading",
            icon: "format_h1",
            options: { level: 1 }
          },
          {
            label: t("editor.heading2"),
            value: "heading",
            icon: "format_h2",
            options: { level: 2 }
          },
          {
            label: t("editor.heading3"),
            value: "heading",
            icon: "format_h3",
            options: { level: 3 }
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" },
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          {
            label: t("editor.blockquote"),
            value: "blockquote",
            icon: "format_quote_open"
          },
          {
            label: t("editor.removeFormat"),
            value: "clearFormat",
            icon: "format_clear",
            separator: true
          }
        ]);
        function s(l) {
          var c2;
          return (c2 = e.editor) == null ? void 0 : c2.isActive(l.value, l.options);
        }
        function a(l) {
          o.value.setShow(false), r(e.editor, l.value, l.options);
        }
        return (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "format_paint",
              "content-class": "o-style-dropdown o-command-btn dropdown",
              tooltip: unref(t)("label.styles")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                  u.separator ? (openBlock(), createBlock(unref(On), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(Nn), {
                    class: normalizeClass({ "is-active": s(u) }),
                    onClick: (p2) => a(u)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      s(u) ? (openBlock(), createBlock(unref(ye), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), E1 = /* @__PURE__ */ defineComponent({
      __name: "OTableBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null);
        function i(s) {
          var a;
          (a = o.value) == null || a.setShow(false), r(e.editor, "tableInsert", s);
        }
        return (s, a) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "window",
              "content-class": "o-table-btn",
              tooltip: unref(t)("table.insert")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(VC), { onSelect: i })
          ]),
          _: 1
        }, 512));
      }
    }), _1 = { class: "o-table-group" }, S1 = /* @__PURE__ */ defineComponent({
      __name: "OTableGroup",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const { tr: e } = Le(), { run: t } = Qe();
        return (r, o) => {
          var i, s;
          return openBlock(), createElementBlock("section", _1, [
            (i = n3.editor) != null && i.can().mergeCells() ? (openBlock(), createBlock(unref(Je), {
              key: 0,
              icon: "cell_merge",
              tooltip: unref(e)("table.merge"),
              onClick: o[0] || (o[0] = (a) => unref(t)(n3.editor, "tableMergeCells"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            (s = n3.editor) != null && s.can().splitCell() ? (openBlock(), createBlock(unref(Je), {
              key: 1,
              icon: "splitscreen_left",
              tooltip: unref(e)("table.split"),
              onClick: o[1] || (o[1] = (a) => unref(t)(n3.editor, "tableSplitCell"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            createVNode(unref(GC), { editor: n3.editor }, null, 8, ["editor"])
          ]);
        };
      }
    }), C1 = /* @__PURE__ */ defineComponent({
      __name: "OTextColorDropdown",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(null), i = ref(""), s = ref("");
        function a(l, c2) {
          l === "foreColor" ? (i.value = c2, localStorage.setItem("yiitap.text-color.fore", c2)) : l === "backColor" && (s.value = c2, localStorage.setItem("yiitap.text-color.back", c2)), o.value.setShow(false), r(e.editor, l, {
            color: c2
          });
        }
        return onMounted(() => {
          i.value = localStorage.getItem("yiitap.text-color.fore") || "", s.value = localStorage.getItem("yiitap.text-color.back") || "";
        }), (l, c2) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "format_text",
              "content-class": "o-text-color-dropdown dropdown",
              tooltip: unref(t)("editor.textColor")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => {
            var u;
            return [
              createVNode(unref(rx), {
                "fore-color": i.value,
                "back-color": s.value,
                "default-label": unref(t)("editor.defaultColor"),
                "active-color": (u = n3.editor) == null ? void 0 : u.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["fore-color", "back-color", "default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), x1 = /* @__PURE__ */ defineComponent({
      __name: "OTextFormatDropdown",
      props: {
        editor: {
          type: Qn,
          required: true
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(), i = computed(() => [
          {
            label: t("editor.strikethrough"),
            value: "strike",
            icon: "format_strikethrough"
          },
          {
            label: t("editor.underline"),
            value: "underline",
            icon: "format_underlined"
          },
          { label: t("editor.code"), value: "code", icon: "code" }
        ]);
        function s(a) {
          var l;
          (l = o.value) == null || l.setShow(false), r(e.editor, a);
        }
        return (a, l) => (openBlock(), createBlock(unref(at), {
          ref_key: "popover",
          ref: o,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Lt), {
              icon: "title",
              "content-class": "o-text-format-dropdown dropdown",
              tooltip: unref(t)("editor.textFormat")
            }, {
              default: withCtx(() => [
                createVNode(unref(ye), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Pn), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (c2, u) => {
                  var d;
                  return openBlock(), createBlock(unref(Nn), {
                    key: u,
                    class: normalizeClass({ "is-active": (d = n3.editor) == null ? void 0 : d.isActive(c2.value) }),
                    onClick: (p2) => s(c2.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ye), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = n3.editor) != null && p2.isActive(c2.value) ? (openBlock(), createBlock(unref(ye), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), T1 = {
      // 'add-more': 'o-add-more-btn',
      "align-dropdown": Gx,
      "align-group": Jx,
      "back-color": Xx,
      "font-family": Zx,
      "fore-color": e1,
      heading: t1,
      // 'indent-dropdown': 'o-indent-dropdown',
      // 'line-height': 'o-line-height-dropdown',
      "list-dropdown": r1,
      "list-group": i1,
      link: s1,
      "link-edit": a1,
      "link-open": l1,
      // 'image-settings': 'o-image-settings-btn',
      // 'emoji': 'o-emoji-btn',
      more: w1,
      // 'node': 'o-node-btn',
      // 'node-dropdown': 'o-node-dropdown',
      "style-dropdown": k1,
      table: E1,
      "table-group": S1,
      "text-color-dropdown": C1,
      "text-format-dropdown": x1
    }, ll = (n3) => T1[n3] || sC, O1 = { class: "o-main-menu" }, N1 = { class: "left" }, M1 = { class: "right" }, A1 = /* @__PURE__ */ defineComponent({
      __name: "OMainMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        }
      },
      setup(n3) {
        const e = n3, t = computed(() => {
          var o;
          let r = e.menu;
          return (o = e.editor) != null && o.isActive("table") && (r = u1), r.length > 0 ? r : c1;
        });
        return (r, o) => (openBlock(), createElementBlock("section", O1, [
          createBaseVNode("section", N1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(t.value, (i, s) => (openBlock(), createElementBlock(Fragment, { key: s }, [
              i === "separator" ? (openBlock(), createBlock(unref(On), {
                key: 0,
                vertical: ""
              })) : typeof i == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(ll)(i)), {
                key: 1,
                name: i,
                editor: n3.editor
              }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(i), {
                key: 2,
                editor: n3.editor
              }, null, 8, ["editor"]))
            ], 64))), 128)),
            renderSlot(r.$slots, "left")
          ]),
          createBaseVNode("section", M1, [
            renderSlot(r.$slots, "right")
          ])
        ]));
      }
    }), R1 = {
      key: 0,
      class: "o-bubble-menu"
    }, I1 = { class: "container" }, D1 = /* @__PURE__ */ defineComponent({
      __name: "OBubbleMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n3) {
        const e = n3, { tr: t } = Le();
        al();
        const o = ref(false), i = ref({
          duration: 100,
          placement: "top",
          role: "popover",
          arrow: false,
          // offset: [0, 0]
          onShow: () => {
            o.value = false;
          }
        });
        function s() {
          o.value = true;
        }
        function a(p2) {
          const { schema: f } = e.editor, h2 = f.marks.link;
          if (!h2 || !p2) return false;
          const { $from: m, $to: g } = p2;
          return !!Zo(m, h2);
        }
        function l({ editor: p2, view: f, state: h2, oldState: m, from: g, to: b }) {
          var q;
          const { doc: w, selection: _ } = h2, { empty: v } = _, T = !w.textBetween(g, b).length && rl(h2.selection);
          if (!f.hasFocus() || v || T && p2.isActive("link") && !p2.isActive("image"))
            return false;
          const S = ["image"], z = ["toc", "video", "model-viewer"], U = _.node, B = (q = U == null ? void 0 : U.type) == null ? void 0 : q.name;
          return !(p2.isActive("codeBlock") || z.indexOf(B) >= 0 || B && !S.includes(B));
        }
        const c2 = computed(() => {
          if (e.editor) {
            const { state: p2 } = e.editor, { tr: f } = p2, { selection: h2 } = f;
            return a(h2);
          } else
            return false;
        }), u = computed(() => {
          var p2;
          return !o.value && c2.value && !((p2 = e.editor) != null && p2.isActive("image"));
        }), d = computed(() => {
          var f, h2;
          let p2 = e.menu;
          return o.value || ((f = e.editor) != null && f.isActive("image") ? p2 = c2.value ? h1 : f1 : (h2 = e.editor) != null && h2.isActive("table") ? p2 = g1 : c2.value && (p2 = p1)), p2.length > 0 ? p2 : d1;
        });
        return onMounted(() => {
          o.value = false;
        }), (p2, f) => n3.editor ? (openBlock(), createElementBlock("section", R1, [
          createVNode(unref(X_), {
            class: normalizeClass(["bubble-menu", n3.menuClass]),
            editor: n3.editor,
            "should-show": l,
            "tippy-options": i.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", I1, [
                u.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(unref(Je), {
                    icon: "arrow_back",
                    tooltip: unref(t)("link.back"),
                    onClick: s
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(On), { vertical: "" })
                ], 64)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (h2, m) => (openBlock(), createElementBlock(Fragment, { key: m }, [
                  h2 === "separator" ? (openBlock(), createBlock(unref(On), {
                    key: 0,
                    vertical: ""
                  })) : typeof h2 == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(ll)(h2)), {
                    key: 1,
                    name: h2,
                    editor: n3.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(h2), {
                    key: 2,
                    editor: n3.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    }), L1 = {
      key: 0,
      class: "o-floating-menu"
    }, B1 = { class: "container" }, P1 = /* @__PURE__ */ defineComponent({
      __name: "OFloatingMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n3) {
        const e = n3, t = ref(false), r = ref({
          arrow: false,
          duration: 100,
          role: "popover",
          placement: "right",
          offset: [0, 168]
        });
        function o() {
          t.value = true;
        }
        function i(c2) {
          const { schema: u } = e.editor, d = u.marks.link;
          if (!d || !c2) return false;
          const { $from: p2, $to: f } = c2;
          return !!Zo(p2, d);
        }
        const s = computed(() => {
          if (e.editor) {
            const { state: c2 } = e.editor, { tr: u } = c2, { selection: d } = u;
            return i(d);
          } else
            return false;
        }), a = computed(() => !t.value && s.value), l = computed(() => {
          let c2 = e.menu;
          return c2.length > 0 ? c2 : b1;
        });
        return (c2, u) => n3.editor ? (openBlock(), createElementBlock("section", L1, [
          createVNode(unref(eS), {
            class: normalizeClass(["floating-menu", n3.menuClass]),
            editor: n3.editor,
            "tippy-options": r.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", B1, [
                a.value ? (openBlock(), createBlock(unref(Je), {
                  key: 0,
                  icon: "arrow_back",
                  onClick: o
                })) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(l.value, (d, p2) => (openBlock(), createElementBlock(Fragment, { key: p2 }, [
                  d === "separator" ? (openBlock(), createBlock(unref(On), {
                    key: 0,
                    vertical: ""
                  })) : typeof d == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(ll)(d)), {
                    key: 1,
                    name: d,
                    editor: n3.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(d), {
                    key: 2,
                    editor: n3.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    function $u(n3, e) {
      const t = e == null ? void 0 : e.posAtCoords(n3);
      if (!t)
        return;
      let r = Js(t.pos, e);
      if (r !== e.dom) {
        for (; r && r.parentNode && r.parentNode !== e.dom; )
          r = r.parentNode;
        if (r)
          return r;
      }
    }
    function Js(n3, e) {
      return e.nodeDOM(n3) || e.domAtPos(n3).node;
    }
    function Fu(n3, e) {
      const t = $u(n3, e);
      if (t && t.nodeType === 1) {
        const r = e.docView, o = r.nearestDesc(t, true);
        return !o || o === r ? null : o.posBefore;
      }
      return null;
    }
    function $1(n3, e) {
      let t, r;
      const o = e.resolve(n3.from).node().type.spec.group === "blockContent", i = e.resolve(n3.to).node().type.spec.group === "blockContent", s = Math.min(n3.$anchor.depth, n3.$head.depth);
      if (o && i) {
        const a = n3.$from.start(s - 1), l = n3.$to.end(s - 1);
        t = e.resolve(a - 1).pos, r = e.resolve(l + 1).pos;
      } else
        t = n3.from, r = n3.to;
      return { from: t, to: r };
    }
    function F1(n3, e) {
      const t = Fu(n3, e.view);
      return t && t >= 0 ? {
        node: e.state.doc.nodeAt(t),
        pos: t
      } : {
        node: null,
        pos: t
      };
    }
    const ga = new Ze("sideMenu");
    class z1 {
      constructor() {
        Ge(this, "hovered", false);
        Ge(this, "coords", { left: 0, top: 0 });
        Ge(this, "className", "");
      }
      init(e) {
        return this;
      }
      apply({ tr: e, oldState: t, newState: r }) {
        return e.docChanged ? this : this;
      }
      setHover(e, t, r = "") {
        this.hovered = e, this.coords = t, this.className = r;
      }
    }
    class H1 {
      constructor({
        editor: e,
        element: t,
        view: r,
        tippyOptions: o = {},
        updateDelay: i = 250
      }) {
        Ge(this, "editor");
        Ge(this, "element");
        Ge(this, "view");
        Ge(this, "preventHide", false);
        Ge(this, "tippy");
        Ge(this, "tippyOptions");
        Ge(this, "updateDelay");
        Ge(this, "updateDebounceTimer");
        Ge(this, "mousedownHandler", () => {
          this.preventHide = true;
        });
        Ge(this, "onDragStart", (e2) => {
          this.hide();
        });
        Ge(this, "blurHandler", ({ event: e2 }) => {
          var t2;
          e2 != null && e2.relatedTarget && ((t2 = this.element.parentNode) != null && t2.contains(e2.relatedTarget)) || this.hide();
        });
        Ge(this, "tippyBlurHandler", (e2) => {
          this.blurHandler({ event: e2 });
        });
        Ge(this, "handleDebouncedUpdate", (e2, t2) => {
          const r2 = !(t2 != null && t2.selection.eq(e2.state.selection)), o2 = !(t2 != null && t2.doc.eq(e2.state.doc));
          !r2 && !o2 || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(e2, r2, o2, t2);
          }, this.updateDelay));
        });
        Ge(this, "updateHandler", (e2, t2, r2, o2) => {
          var u, d;
          const { state: i2, composing: s } = e2, { coords: a } = ga.getState(i2), l = $u(a, e2), c2 = Fu(a, e2);
          !l || c2 <= 0 || (this.createTooltip(), (d = this.tippy) == null || d.setProps({
            getReferenceClientRect: ((u = this.tippyOptions) == null ? void 0 : u.getReferenceClientRect) || (() => l.getBoundingClientRect())
          }), this.show());
        });
        this.editor = e, this.element = t, this.view = r, this.updateDelay = i, this.view.dom.addEventListener("dragstart", this.onDragStart), this.tippyOptions = o, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = er(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "left",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
      }
      update(e, t) {
        const { state: r } = e, o = !(t != null && t.selection.eq(e.state.selection)), i = !(t != null && t.doc.eq(e.state.doc));
        this.updateHandler(e, o, i, t);
      }
      show() {
        var e;
        (e = this.tippy) == null || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) == null || e.hide();
      }
      destroy() {
        var e, t;
        (e = this.tippy) != null && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ), (t = this.tippy) == null || t.destroy(), this.view.dom.removeEventListener("dragstart", this.onDragStart);
      }
    }
    const U1 = (n3, e) => {
      if (!n3.dataTransfer) return;
      const t = e.view, r = t.dom.getBoundingClientRect(), o = {
        left: r.left + r.width / 2,
        // take middle of editor
        top: n3.clientY
      }, i = Fu(o, t);
      if (i === null) return;
      const s = t.state.selection, a = t.state.doc;
      $1(s, a), t.dispatch(
        t.state.tr.setSelection(ne.create(t.state.doc, i))
      ), W1(t, i);
      const l = t.state.selection.content(), { dom: c2, text: u } = t.serializeForClipboard(l);
      n3.dataTransfer.clearData(), n3.dataTransfer.setData("text/html", c2.innerHTML), n3.dataTransfer.setData("text/plain", u), n3.dataTransfer.effectAllowed = "move", n3.dataTransfer.setDragImage(ao, 0, 0), t.dragging = { slice: l, move: true };
    }, V1 = (n3, e) => {
      _g();
    };
    let ao;
    function W1(n3, e, t = e) {
      const r = n3.domAtPos(e).node.cloneNode(true), o = n3.domAtPos(e).node, i = (d, p2) => Array.prototype.indexOf.call(d.children, p2), s = (d) => {
        let p2 = d, f = p2.parentElement;
        for (; f; ) {
          if (f === n3.dom)
            return p2;
          p2 = f, f = p2.parentElement;
        }
        return p2;
      };
      let a = -1, l = -1;
      e === t ? (a = i(
        o,
        s(Js(e, n3))
      ), l = a) : (a = i(
        o,
        // Expects from position to be just before the first selected block.
        s(Js(e + 1, n3))
      ), l = i(
        o,
        // Expects to position to be just after the last selected block.
        s(Js(t - 1, n3))
      ));
      for (let d = o.childElementCount - 1; d >= 0; d--)
        (d > a || d < l) && r.removeChild(r.children[d]);
      _g(), ao = r;
      const u = n3.dom.className.split(" ").filter(
        (d) => d !== "ProseMirror" && d !== "yiitap-root" && d !== "yiitap-editor"
      ).join(" ");
      ao.className += " yiitap-dragging-preview " + u, document.body.appendChild(ao);
    }
    function _g() {
      ao !== void 0 && (document.body.removeChild(ao), ao = void 0);
    }
    class q1 {
      constructor(e) {
        Ge(this, "options");
        Ge(this, "plugin");
        Ge(this, "sideMenuView");
        const t = new z1();
        this.options = e, this.plugin = new Ue({
          key: ga,
          props: {
            handleDOMEvents: {
              mouseover(r, o) {
                const i = {
                  left: o.clientX,
                  top: o.clientY
                }, s = $u(i, r), a = (s == null ? void 0 : s.className) || "", l = t.className;
                a.indexOf("o-table-wrapper-view") >= 0 && l.indexOf("o-table-wrapper-view") >= 0 || (t.setHover(true, i, a), r.dispatch(r.state.tr.setMeta(ga, t)));
              }
            }
          },
          state: {
            init(r, o) {
              return t.init(o);
            },
            apply(r, o, i, s) {
              return t.apply({ tr: r, oldState: i, newState: s });
            }
          },
          view: (r) => (this.sideMenuView = new H1({ view: r, ...e }), this.sideMenuView)
        });
      }
      dragstart(e) {
        U1(e, this.options.editor);
      }
      dragend(e) {
        V1(e, this.options.editor);
      }
    }
    const K1 = /* @__PURE__ */ defineComponent({
      name: "SideMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "sideMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        }
      },
      setup(n3, { expose: e, slots: t }) {
        const r = ref(null), o = ref(), i = (a) => {
          var l;
          (l = o.value) == null || l.dragstart(a);
        }, s = (a) => {
          var l;
          (l = o.value) == null || l.dragend(a);
        };
        return onMounted(() => {
          const { pluginKey: a, editor: l, updateDelay: c2, tippyOptions: u } = n3;
          o.value = new q1({
            updateDelay: c2,
            editor: l,
            element: r.value,
            pluginKey: a,
            tippyOptions: u
          }), l.registerPlugin(o.value.plugin);
        }), onBeforeUnmount(() => {
          const { pluginKey: a, editor: l } = n3;
          l.unregisterPlugin(a);
        }), e({
          ...n3,
          dragstart: i,
          dragend: s
        }), () => {
          var a;
          return h("div", { ref: r }, (a = t.default) == null ? void 0 : a.call(t));
        };
      }
    }), G1 = {
      key: 0,
      class: "o-side-menu"
    }, j1 = { class: "container" }, J1 = /* @__PURE__ */ defineComponent({
      __name: "OSideMenu",
      props: {
        editor: {
          type: Qn,
          required: true
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n3) {
        const e = n3, t = ref(null), r = ref(null), o = ref(0), i = computed(() => ({
          arrow: false,
          duration: 100,
          placement: "left"
          // offset: [0, 0]
        })), s = computed(() => ({
          editor: e.editor,
          node: r.value,
          decorations: [],
          selected: false,
          extension: {},
          getPos: () => o.value,
          pos: o.value,
          updateAttributes: l,
          deleteNode: a,
          view: void 0,
          innerDecorations: [],
          HTMLAttributes: void 0
        }));
        function a() {
          var h2, m;
          const p2 = o.value, f = p2 + ((h2 = r.value) == null ? void 0 : h2.nodeSize);
          (m = e.editor) == null || m.commands.deleteRange({ from: p2, to: f });
        }
        function l(p2) {
          var f;
          (f = e.editor) == null || f.commands.command(({ tr: h2 }) => {
            var m;
            return h2.setNodeMarkup(o.value, void 0, {
              ...(m = r.value) == null ? void 0 : m.attrs,
              ...p2
            }), true;
          });
        }
        function c2({ editor: p2, transaction: f }) {
          let h2 = { left: 0, top: 0 };
          const m = ga.getState(e.editor.view.state);
          if (m) {
            h2 = m.coords;
            const g = F1(h2, p2);
            g.node && g.pos > 0 && (r.value = g.node, o.value = g.pos);
          }
        }
        function u(p2) {
          var f;
          (f = t.value) == null || f.dragstart(p2);
        }
        function d(p2) {
          var f;
          (f = t.value) == null || f.dragend(p2);
        }
        return onMounted(() => {
          var p2;
          (p2 = e.editor) == null || p2.on("transaction", c2);
        }), (p2, f) => n3.editor ? (openBlock(), createElementBlock("section", G1, [
          createVNode(unref(K1), {
            ref_key: "menu",
            ref: t,
            class: normalizeClass(["side-menu", n3.menuClass]),
            editor: n3.editor,
            "tippy-options": i.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", j1, [
                r.value ? (openBlock(), createBlock(unref(Nx), normalizeProps(mergeProps({ key: 0 }, s.value)), null, 16)) : createCommentVNode("", true),
                r.value ? (openBlock(), createBlock(unref(Bx), mergeProps({ key: 1 }, s.value, {
                  onDragstart: u,
                  onDragend: d
                }), null, 16)) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    }), Y1 = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3;
        return (t, r) => (openBlock(), createBlock(unref(yr), mergeProps(e, { class: "o-blockquote-view" }), {
          default: withCtx(() => [
            createBaseVNode("blockquote", null, [
              createVNode(unref(br))
            ])
          ]),
          _: 1
        }, 16));
      }
    }), X1 = ig.extend({
      draggable: true,
      addNodeView() {
        return Bn(Y1);
      }
    }), Z1 = { class: "callout-container" }, Q1 = { class: "callout-icon" }, eT = { class: "callout-content" }, tT = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, { theme: t } = al(), r = ref(false), o = ref(false), i = ref({}), s = computed(() => {
          e.editor.isActive("callout");
          const { selection: g } = e.editor.view.state, b = g.from, w = e.getPos(), _ = w + e.node.nodeSize;
          return b >= w && b <= _;
        });
        computed(() => e.node.attrs);
        const a = computed({
          get() {
            return e.node.attrs.backColor;
          },
          set(g) {
            e.updateAttributes({ backColor: g });
          }
        }), l = computed({
          get() {
            return e.node.attrs.backColorDark;
          },
          set(g) {
            e.updateAttributes({ backColorDark: g });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.borderColor;
          },
          set(g) {
            e.updateAttributes({ borderColor: g });
          }
        }), u = computed({
          get() {
            return e.node.attrs.borderColorDark;
          },
          set(g) {
            e.updateAttributes({ borderColorDark: g });
          }
        }), d = computed(() => t.value === "dark" ? l.value : a.value), p2 = computed(() => t.value === "dark" ? u.value : c2.value);
        function f(g) {
          switch (r.value = false, g.value) {
            case "palette":
              m(true);
              break;
          }
        }
        function h2(g) {
          r.value = true, i.value = g;
        }
        function m(g) {
          o.value = g;
        }
        return watch(s, (g) => {
          m(g);
        }), (g, b) => (openBlock(), createBlock(unref(yr), mergeProps(e, {
          class: "o-callout-view",
          style: `--callout-border-color: ${p2.value}; --callout-back-color: ${d.value}`,
          onContextmenu: withModifiers(h2, ["prevent"])
        }), {
          default: withCtx(() => [
            createBaseVNode("div", Z1, [
              createBaseVNode("div", Q1, toDisplayString(g.node.attrs.icon), 1),
              createBaseVNode("div", eT, [
                createVNode(unref(br))
              ]),
              createVNode(unref(Bu), {
                modelValue: r.value,
                "onUpdate:modelValue": b[0] || (b[0] = (w) => r.value = w),
                event: i.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Qo), mergeProps(e, { onAction: f }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ])
          ]),
          _: 1
        }, 16, ["style", "onContextmenu"]));
      }
    }), nT = st.create({
      name: "callout",
      group: "block",
      content: "block+",
      draggable: true,
      addAttributes() {
        return {
          icon: {
            default: ""
          },
          borderColor: {
            default: "#dddddd"
          },
          borderColorDark: {
            default: "#333333"
          },
          backColor: {
            default: "#eeeeee"
          },
          backColorDark: {
            default: "rgba(101, 117, 133, 0.16)"
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: 'div[data-type="callout"]'
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return [
          "div",
          $e(n3, { "data-type": "callout" }),
          0
        ];
      },
      addCommands() {
        return {
          setCallout: () => ({ commands: n3 }) => n3.wrapIn(this.name),
          toggleCallout: () => ({ commands: n3 }) => n3.toggleWrap(this.name),
          unsetCallout: () => ({ commands: n3 }) => n3.lift(this.name)
        };
      },
      addNodeView() {
        return Bn(tT);
      }
    });
    function rT(n3) {
      return n3 && n3.__esModule && Object.prototype.hasOwnProperty.call(n3, "default") ? n3.default : n3;
    }
    function Sg(n3) {
      return n3 instanceof Map ? n3.clear = n3.delete = n3.set = function() {
        throw new Error("map is read-only");
      } : n3 instanceof Set && (n3.add = n3.clear = n3.delete = function() {
        throw new Error("set is read-only");
      }), Object.freeze(n3), Object.getOwnPropertyNames(n3).forEach((e) => {
        const t = n3[e], r = typeof t;
        (r === "object" || r === "function") && !Object.isFrozen(t) && Sg(t);
      }), n3;
    }
    class Gp {
      /**
       * @param {CompiledMode} mode
       */
      constructor(e) {
        e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function Cg(n3) {
      return n3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function Ir(n3, ...e) {
      const t = /* @__PURE__ */ Object.create(null);
      for (const r in n3)
        t[r] = n3[r];
      return e.forEach(function(r) {
        for (const o in r)
          t[o] = r[o];
      }), /** @type {T} */
      t;
    }
    const oT = "</span>", jp = (n3) => !!n3.scope, iT = (n3, { prefix: e }) => {
      if (n3.startsWith("language:"))
        return n3.replace("language:", "language-");
      if (n3.includes(".")) {
        const t = n3.split(".");
        return [
          `${e}${t.shift()}`,
          ...t.map((r, o) => `${r}${"_".repeat(o + 1)}`)
        ].join(" ");
      }
      return `${e}${n3}`;
    };
    class sT {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(e, t) {
        this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(e) {
        this.buffer += Cg(e);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(e) {
        if (!jp(e)) return;
        const t = iT(
          e.scope,
          { prefix: this.classPrefix }
        );
        this.span(t);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(e) {
        jp(e) && (this.buffer += oT);
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(e) {
        this.buffer += `<span class="${e}">`;
      }
    }
    const Jp = (n3 = {}) => {
      const e = { children: [] };
      return Object.assign(e, n3), e;
    };
    class zu {
      constructor() {
        this.rootNode = Jp(), this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(e) {
        this.top.children.push(e);
      }
      /** @param {string} scope */
      openNode(e) {
        const t = Jp({ scope: e });
        this.add(t), this.stack.push(t);
      }
      closeNode() {
        if (this.stack.length > 1)
          return this.stack.pop();
      }
      closeAllNodes() {
        for (; this.closeNode(); ) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(e) {
        return this.constructor._walk(e, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(e, t) {
        return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
      }
      /**
       * @param {Node} node
       */
      static _collapse(e) {
        typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
          zu._collapse(t);
        }));
      }
    }
    class aT extends zu {
      /**
       * @param {*} options
       */
      constructor(e) {
        super(), this.options = e;
      }
      /**
       * @param {string} text
       */
      addText(e) {
        e !== "" && this.add(e);
      }
      /** @param {string} scope */
      startScope(e) {
        this.openNode(e);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(e, t) {
        const r = e.root;
        t && (r.scope = `language:${t}`), this.add(r);
      }
      toHTML() {
        return new sT(this, this.options).value();
      }
      finalize() {
        return this.closeAllNodes(), true;
      }
    }
    function Ki(n3) {
      return n3 ? typeof n3 == "string" ? n3 : n3.source : null;
    }
    function xg(n3) {
      return ko("(?=", n3, ")");
    }
    function lT(n3) {
      return ko("(?:", n3, ")*");
    }
    function cT(n3) {
      return ko("(?:", n3, ")?");
    }
    function ko(...n3) {
      return n3.map((t) => Ki(t)).join("");
    }
    function uT(n3) {
      const e = n3[n3.length - 1];
      return typeof e == "object" && e.constructor === Object ? (n3.splice(n3.length - 1, 1), e) : {};
    }
    function Hu(...n3) {
      return "(" + (uT(n3).capture ? "" : "?:") + n3.map((r) => Ki(r)).join("|") + ")";
    }
    function Tg(n3) {
      return new RegExp(n3.toString() + "|").exec("").length - 1;
    }
    function dT(n3, e) {
      const t = n3 && n3.exec(e);
      return t && t.index === 0;
    }
    const pT = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function Uu(n3, { joinWith: e }) {
      let t = 0;
      return n3.map((r) => {
        t += 1;
        const o = t;
        let i = Ki(r), s = "";
        for (; i.length > 0; ) {
          const a = pT.exec(i);
          if (!a) {
            s += i;
            break;
          }
          s += i.substring(0, a.index), i = i.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + o) : (s += a[0], a[0] === "(" && t++);
        }
        return s;
      }).map((r) => `(${r})`).join(e);
    }
    const fT = /\b\B/, Og = "[a-zA-Z]\\w*", Vu = "[a-zA-Z_]\\w*", Ng = "\\b\\d+(\\.\\d+)?", Mg = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Ag = "\\b(0b[01]+)", hT = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", mT = (n3 = {}) => {
      const e = /^#![ ]*\//;
      return n3.binary && (n3.begin = ko(
        e,
        /.*\b/,
        n3.binary,
        /\b.*/
      )), Ir({
        scope: "meta",
        begin: e,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (t, r) => {
          t.index !== 0 && r.ignoreMatch();
        }
      }, n3);
    }, Gi = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    }, gT = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [Gi]
    }, bT = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [Gi]
    }, yT = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    }, cl = function(n3, e, t = {}) {
      const r = Ir(
        {
          scope: "comment",
          begin: n3,
          end: e,
          contains: []
        },
        t
      );
      r.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const o = Hu(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      return r.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: ko(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            o,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      ), r;
    }, vT = cl("//", "$"), wT = cl("/\\*", "\\*/"), kT = cl("#", "$"), ET = {
      scope: "number",
      begin: Ng,
      relevance: 0
    }, _T = {
      scope: "number",
      begin: Mg,
      relevance: 0
    }, ST = {
      scope: "number",
      begin: Ag,
      relevance: 0
    }, CT = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        Gi,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [Gi]
        }
      ]
    }, xT = {
      scope: "title",
      begin: Og,
      relevance: 0
    }, TT = {
      scope: "title",
      begin: Vu,
      relevance: 0
    }, OT = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + Vu,
      relevance: 0
    }, NT = function(n3) {
      return Object.assign(
        n3,
        {
          /** @type {ModeCallback} */
          "on:begin": (e, t) => {
            t.data._beginMatch = e[1];
          },
          /** @type {ModeCallback} */
          "on:end": (e, t) => {
            t.data._beginMatch !== e[1] && t.ignoreMatch();
          }
        }
      );
    };
    var Ss = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE: gT,
      BACKSLASH_ESCAPE: Gi,
      BINARY_NUMBER_MODE: ST,
      BINARY_NUMBER_RE: Ag,
      COMMENT: cl,
      C_BLOCK_COMMENT_MODE: wT,
      C_LINE_COMMENT_MODE: vT,
      C_NUMBER_MODE: _T,
      C_NUMBER_RE: Mg,
      END_SAME_AS_BEGIN: NT,
      HASH_COMMENT_MODE: kT,
      IDENT_RE: Og,
      MATCH_NOTHING_RE: fT,
      METHOD_GUARD: OT,
      NUMBER_MODE: ET,
      NUMBER_RE: Ng,
      PHRASAL_WORDS_MODE: yT,
      QUOTE_STRING_MODE: bT,
      REGEXP_MODE: CT,
      RE_STARTERS_RE: hT,
      SHEBANG: mT,
      TITLE_MODE: xT,
      UNDERSCORE_IDENT_RE: Vu,
      UNDERSCORE_TITLE_MODE: TT
    });
    function MT(n3, e) {
      n3.input[n3.index - 1] === "." && e.ignoreMatch();
    }
    function AT(n3, e) {
      n3.className !== void 0 && (n3.scope = n3.className, delete n3.className);
    }
    function RT(n3, e) {
      e && n3.beginKeywords && (n3.begin = "\\b(" + n3.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n3.__beforeBegin = MT, n3.keywords = n3.keywords || n3.beginKeywords, delete n3.beginKeywords, n3.relevance === void 0 && (n3.relevance = 0));
    }
    function IT(n3, e) {
      Array.isArray(n3.illegal) && (n3.illegal = Hu(...n3.illegal));
    }
    function DT(n3, e) {
      if (n3.match) {
        if (n3.begin || n3.end) throw new Error("begin & end are not supported with match");
        n3.begin = n3.match, delete n3.match;
      }
    }
    function LT(n3, e) {
      n3.relevance === void 0 && (n3.relevance = 1);
    }
    const BT = (n3, e) => {
      if (!n3.beforeMatch) return;
      if (n3.starts) throw new Error("beforeMatch cannot be used with starts");
      const t = Object.assign({}, n3);
      Object.keys(n3).forEach((r) => {
        delete n3[r];
      }), n3.keywords = t.keywords, n3.begin = ko(t.beforeMatch, xg(t.begin)), n3.starts = {
        relevance: 0,
        contains: [
          Object.assign(t, { endsParent: true })
        ]
      }, n3.relevance = 0, delete t.beforeMatch;
    }, PT = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ], $T = "keyword";
    function Rg(n3, e, t = $T) {
      const r = /* @__PURE__ */ Object.create(null);
      return typeof n3 == "string" ? o(t, n3.split(" ")) : Array.isArray(n3) ? o(t, n3) : Object.keys(n3).forEach(function(i) {
        Object.assign(
          r,
          Rg(n3[i], e, i)
        );
      }), r;
      function o(i, s) {
        e && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
          const l = a.split("|");
          r[l[0]] = [i, FT(l[0], l[1])];
        });
      }
    }
    function FT(n3, e) {
      return e ? Number(e) : zT(n3) ? 0 : 1;
    }
    function zT(n3) {
      return PT.includes(n3.toLowerCase());
    }
    const Yp = {}, lo = (n3) => {
      console.error(n3);
    }, Xp = (n3, ...e) => {
      console.log(`WARN: ${n3}`, ...e);
    }, Co = (n3, e) => {
      Yp[`${n3}/${e}`] || (console.log(`Deprecated as of ${n3}. ${e}`), Yp[`${n3}/${e}`] = true);
    }, ba = new Error();
    function Ig(n3, e, { key: t }) {
      let r = 0;
      const o = n3[t], i = {}, s = {};
      for (let a = 1; a <= e.length; a++)
        s[a + r] = o[a], i[a + r] = true, r += Tg(e[a - 1]);
      n3[t] = s, n3[t]._emit = i, n3[t]._multi = true;
    }
    function HT(n3) {
      if (Array.isArray(n3.begin)) {
        if (n3.skip || n3.excludeBegin || n3.returnBegin)
          throw lo("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), ba;
        if (typeof n3.beginScope != "object" || n3.beginScope === null)
          throw lo("beginScope must be object"), ba;
        Ig(n3, n3.begin, { key: "beginScope" }), n3.begin = Uu(n3.begin, { joinWith: "" });
      }
    }
    function UT(n3) {
      if (Array.isArray(n3.end)) {
        if (n3.skip || n3.excludeEnd || n3.returnEnd)
          throw lo("skip, excludeEnd, returnEnd not compatible with endScope: {}"), ba;
        if (typeof n3.endScope != "object" || n3.endScope === null)
          throw lo("endScope must be object"), ba;
        Ig(n3, n3.end, { key: "endScope" }), n3.end = Uu(n3.end, { joinWith: "" });
      }
    }
    function VT(n3) {
      n3.scope && typeof n3.scope == "object" && n3.scope !== null && (n3.beginScope = n3.scope, delete n3.scope);
    }
    function WT(n3) {
      VT(n3), typeof n3.beginScope == "string" && (n3.beginScope = { _wrap: n3.beginScope }), typeof n3.endScope == "string" && (n3.endScope = { _wrap: n3.endScope }), HT(n3), UT(n3);
    }
    function qT(n3) {
      function e(s, a) {
        return new RegExp(
          Ki(s),
          "m" + (n3.case_insensitive ? "i" : "") + (n3.unicodeRegex ? "u" : "") + (a ? "g" : "")
        );
      }
      class t {
        constructor() {
          this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += Tg(a) + 1;
        }
        compile() {
          this.regexes.length === 0 && (this.exec = () => null);
          const a = this.regexes.map((l) => l[1]);
          this.matcherRe = e(Uu(a, { joinWith: "|" }), true), this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(a) {
          this.matcherRe.lastIndex = this.lastIndex;
          const l = this.matcherRe.exec(a);
          if (!l)
            return null;
          const c2 = l.findIndex((d, p2) => p2 > 0 && d !== void 0), u = this.matchIndexes[c2];
          return l.splice(0, c2), Object.assign(l, u);
        }
      }
      class r {
        constructor() {
          this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(a) {
          if (this.multiRegexes[a]) return this.multiRegexes[a];
          const l = new t();
          return this.rules.slice(a).forEach(([c2, u]) => l.addRule(c2, u)), l.compile(), this.multiRegexes[a] = l, l;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          this.rules.push([a, l]), l.type === "begin" && this.count++;
        }
        /** @param {string} s */
        exec(a) {
          const l = this.getMatcher(this.regexIndex);
          l.lastIndex = this.lastIndex;
          let c2 = l.exec(a);
          if (this.resumingScanAtSamePosition() && !(c2 && c2.index === this.lastIndex)) {
            const u = this.getMatcher(0);
            u.lastIndex = this.lastIndex + 1, c2 = u.exec(a);
          }
          return c2 && (this.regexIndex += c2.position + 1, this.regexIndex === this.count && this.considerAll()), c2;
        }
      }
      function o(s) {
        const a = new r();
        return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
      }
      function i(s, a) {
        const l = (
          /** @type CompiledMode */
          s
        );
        if (s.isCompiled) return l;
        [
          AT,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          DT,
          WT,
          BT
        ].forEach((u) => u(s, a)), n3.compilerExtensions.forEach((u) => u(s, a)), s.__beforeBegin = null, [
          RT,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          IT,
          // default to 1 relevance if not specified
          LT
        ].forEach((u) => u(s, a)), s.isCompiled = true;
        let c2 = null;
        return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), c2 = s.keywords.$pattern, delete s.keywords.$pattern), c2 = c2 || /\w+/, s.keywords && (s.keywords = Rg(s.keywords, n3.case_insensitive)), l.keywordPatternRe = e(c2, true), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = e(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = e(l.end)), l.terminatorEnd = Ki(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = e(
          /** @type {RegExp | string} */
          s.illegal
        )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(u) {
          return KT(u === "self" ? s : u);
        })), s.contains.forEach(function(u) {
          i(
            /** @type Mode */
            u,
            l
          );
        }), s.starts && i(s.starts, a), l.matcher = o(l), l;
      }
      if (n3.compilerExtensions || (n3.compilerExtensions = []), n3.contains && n3.contains.includes("self"))
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      return n3.classNameAliases = Ir(n3.classNameAliases || {}), i(
        /** @type Mode */
        n3
      );
    }
    function Dg(n3) {
      return n3 ? n3.endsWithParent || Dg(n3.starts) : false;
    }
    function KT(n3) {
      return n3.variants && !n3.cachedVariants && (n3.cachedVariants = n3.variants.map(function(e) {
        return Ir(n3, { variants: null }, e);
      })), n3.cachedVariants ? n3.cachedVariants : Dg(n3) ? Ir(n3, { starts: n3.starts ? Ir(n3.starts) : null }) : Object.isFrozen(n3) ? Ir(n3) : n3;
    }
    var GT = "11.10.0";
    class jT extends Error {
      constructor(e, t) {
        super(e), this.name = "HTMLInjectionError", this.html = t;
      }
    }
    const Kl = Cg, Zp = Ir, Qp = Symbol("nomatch"), JT = 7, Lg = function(n3) {
      const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
      let o = true;
      const i = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: true, name: "Plain text", contains: [] };
      let a = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: aT
      };
      function l(M) {
        return a.noHighlightRe.test(M);
      }
      function c2(M) {
        let L = M.className + " ";
        L += M.parentNode ? M.parentNode.className : "";
        const J = a.languageDetectRe.exec(L);
        if (J) {
          const re = B(J[1]);
          return re || (Xp(i.replace("{}", J[1])), Xp("Falling back to no-highlight mode for this block.", M)), re ? J[1] : "no-highlight";
        }
        return L.split(/\s+/).find((re) => l(re) || B(re));
      }
      function u(M, L, J) {
        let re = "", ce = "";
        typeof L == "object" ? (re = M, J = L.ignoreIllegals, ce = L.language) : (Co("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Co("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ce = M, re = L), J === void 0 && (J = true);
        const Se = {
          code: re,
          language: ce
        };
        fe("before:highlight", Se);
        const Fe = Se.result ? Se.result : d(Se.language, Se.code, J);
        return Fe.code = Se.code, fe("after:highlight", Fe), Fe;
      }
      function d(M, L, J, re) {
        const ce = /* @__PURE__ */ Object.create(null);
        function Se(V, Y) {
          return V.keywords[Y];
        }
        function Fe() {
          if (!le.keywords) {
            Ke.addText(Re);
            return;
          }
          let V = 0;
          le.keywordPatternRe.lastIndex = 0;
          let Y = le.keywordPatternRe.exec(Re), Ee = "";
          for (; Y; ) {
            Ee += Re.substring(V, Y.index);
            const Ie = ve.case_insensitive ? Y[0].toLowerCase() : Y[0], gt = Se(le, Ie);
            if (gt) {
              const [cn, ti] = gt;
              if (Ke.addText(Ee), Ee = "", ce[Ie] = (ce[Ie] || 0) + 1, ce[Ie] <= JT && (qt += ti), cn.startsWith("_"))
                Ee += Y[0];
              else {
                const N = ve.classNameAliases[cn] || cn;
                et(Y[0], N);
              }
            } else
              Ee += Y[0];
            V = le.keywordPatternRe.lastIndex, Y = le.keywordPatternRe.exec(Re);
          }
          Ee += Re.substring(V), Ke.addText(Ee);
        }
        function kt() {
          if (Re === "") return;
          let V = null;
          if (typeof le.subLanguage == "string") {
            if (!e[le.subLanguage]) {
              Ke.addText(Re);
              return;
            }
            V = d(le.subLanguage, Re, true, Wt[le.subLanguage]), Wt[le.subLanguage] = /** @type {CompiledMode} */
            V._top;
          } else
            V = f(Re, le.subLanguage.length ? le.subLanguage : null);
          le.relevance > 0 && (qt += V.relevance), Ke.__addSublanguage(V._emitter, V.language);
        }
        function ze() {
          le.subLanguage != null ? kt() : Fe(), Re = "";
        }
        function et(V, Y) {
          V !== "" && (Ke.startScope(Y), Ke.addText(V), Ke.endScope());
        }
        function an(V, Y) {
          let Ee = 1;
          const Ie = Y.length - 1;
          for (; Ee <= Ie; ) {
            if (!V._emit[Ee]) {
              Ee++;
              continue;
            }
            const gt = ve.classNameAliases[V[Ee]] || V[Ee], cn = Y[Ee];
            gt ? et(cn, gt) : (Re = cn, Fe(), Re = ""), Ee++;
          }
        }
        function Tt(V, Y) {
          return V.scope && typeof V.scope == "string" && Ke.openNode(ve.classNameAliases[V.scope] || V.scope), V.beginScope && (V.beginScope._wrap ? (et(Re, ve.classNameAliases[V.beginScope._wrap] || V.beginScope._wrap), Re = "") : V.beginScope._multi && (an(V.beginScope, Y), Re = "")), le = Object.create(V, { parent: { value: le } }), le;
        }
        function gn(V, Y, Ee) {
          let Ie = dT(V.endRe, Ee);
          if (Ie) {
            if (V["on:end"]) {
              const gt = new Gp(V);
              V["on:end"](Y, gt), gt.isMatchIgnored && (Ie = false);
            }
            if (Ie) {
              for (; V.endsParent && V.parent; )
                V = V.parent;
              return V;
            }
          }
          if (V.endsWithParent)
            return gn(V.parent, Y, Ee);
        }
        function Ot(V) {
          return le.matcher.regexIndex === 0 ? (Re += V[0], 1) : (Kt = true, 0);
        }
        function bn(V) {
          const Y = V[0], Ee = V.rule, Ie = new Gp(Ee), gt = [Ee.__beforeBegin, Ee["on:begin"]];
          for (const cn of gt)
            if (cn && (cn(V, Ie), Ie.isMatchIgnored))
              return Ot(Y);
          return Ee.skip ? Re += Y : (Ee.excludeBegin && (Re += Y), ze(), !Ee.returnBegin && !Ee.excludeBegin && (Re = Y)), Tt(Ee, V), Ee.returnBegin ? 0 : Y.length;
        }
        function Fn(V) {
          const Y = V[0], Ee = L.substring(V.index), Ie = gn(le, V, Ee);
          if (!Ie)
            return Qp;
          const gt = le;
          le.endScope && le.endScope._wrap ? (ze(), et(Y, le.endScope._wrap)) : le.endScope && le.endScope._multi ? (ze(), an(le.endScope, V)) : gt.skip ? Re += Y : (gt.returnEnd || gt.excludeEnd || (Re += Y), ze(), gt.excludeEnd && (Re = Y));
          do
            le.scope && Ke.closeNode(), !le.skip && !le.subLanguage && (qt += le.relevance), le = le.parent;
          while (le !== Ie.parent);
          return Ie.starts && Tt(Ie.starts, V), gt.returnEnd ? 0 : Y.length;
        }
        function Mn() {
          const V = [];
          for (let Y = le; Y !== ve; Y = Y.parent)
            Y.scope && V.unshift(Y.scope);
          V.forEach((Y) => Ke.openNode(Y));
        }
        let ln = {};
        function An(V, Y) {
          const Ee = Y && Y[0];
          if (Re += V, Ee == null)
            return ze(), 0;
          if (ln.type === "begin" && Y.type === "end" && ln.index === Y.index && Ee === "") {
            if (Re += L.slice(Y.index, Y.index + 1), !o) {
              const Ie = new Error(`0 width match regex (${M})`);
              throw Ie.languageName = M, Ie.badRule = ln.rule, Ie;
            }
            return 1;
          }
          if (ln = Y, Y.type === "begin")
            return bn(Y);
          if (Y.type === "illegal" && !J) {
            const Ie = new Error('Illegal lexeme "' + Ee + '" for mode "' + (le.scope || "<unnamed>") + '"');
            throw Ie.mode = le, Ie;
          } else if (Y.type === "end") {
            const Ie = Fn(Y);
            if (Ie !== Qp)
              return Ie;
          }
          if (Y.type === "illegal" && Ee === "")
            return 1;
          if (Rn > 1e5 && Rn > Y.index * 3)
            throw new Error("potential infinite loop, way more iterations than matches");
          return Re += Ee, Ee.length;
        }
        const ve = B(M);
        if (!ve)
          throw lo(i.replace("{}", M)), new Error('Unknown language: "' + M + '"');
        const Qt = qT(ve);
        let Pt = "", le = re || Qt;
        const Wt = {}, Ke = new a.__emitter(a);
        Mn();
        let Re = "", qt = 0, ft = 0, Rn = 0, Kt = false;
        try {
          if (ve.__emitTokens)
            ve.__emitTokens(L, Ke);
          else {
            for (le.matcher.considerAll(); ; ) {
              Rn++, Kt ? Kt = false : le.matcher.considerAll(), le.matcher.lastIndex = ft;
              const V = le.matcher.exec(L);
              if (!V) break;
              const Y = L.substring(ft, V.index), Ee = An(Y, V);
              ft = V.index + Ee;
            }
            An(L.substring(ft));
          }
          return Ke.finalize(), Pt = Ke.toHTML(), {
            language: M,
            value: Pt,
            relevance: qt,
            illegal: false,
            _emitter: Ke,
            _top: le
          };
        } catch (V) {
          if (V.message && V.message.includes("Illegal"))
            return {
              language: M,
              value: Kl(L),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: V.message,
                index: ft,
                context: L.slice(ft - 100, ft + 100),
                mode: V.mode,
                resultSoFar: Pt
              },
              _emitter: Ke
            };
          if (o)
            return {
              language: M,
              value: Kl(L),
              illegal: false,
              relevance: 0,
              errorRaised: V,
              _emitter: Ke,
              _top: le
            };
          throw V;
        }
      }
      function p2(M) {
        const L = {
          value: Kl(M),
          illegal: false,
          relevance: 0,
          _top: s,
          _emitter: new a.__emitter(a)
        };
        return L._emitter.addText(M), L;
      }
      function f(M, L) {
        L = L || a.languages || Object.keys(e);
        const J = p2(M), re = L.filter(B).filter(oe).map(
          (ze) => d(ze, M, false)
        );
        re.unshift(J);
        const ce = re.sort((ze, et) => {
          if (ze.relevance !== et.relevance) return et.relevance - ze.relevance;
          if (ze.language && et.language) {
            if (B(ze.language).supersetOf === et.language)
              return 1;
            if (B(et.language).supersetOf === ze.language)
              return -1;
          }
          return 0;
        }), [Se, Fe] = ce, kt = Se;
        return kt.secondBest = Fe, kt;
      }
      function h2(M, L, J) {
        const re = L && t[L] || J;
        M.classList.add("hljs"), M.classList.add(`language-${re}`);
      }
      function m(M) {
        let L = null;
        const J = c2(M);
        if (l(J)) return;
        if (fe(
          "before:highlightElement",
          { el: M, language: J }
        ), M.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", M);
          return;
        }
        if (M.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(M)), a.throwUnescapedHTML))
          throw new jT(
            "One of your code blocks includes unescaped HTML.",
            M.innerHTML
          );
        L = M;
        const re = L.textContent, ce = J ? u(re, { language: J, ignoreIllegals: true }) : f(re);
        M.innerHTML = ce.value, M.dataset.highlighted = "yes", h2(M, J, ce.language), M.result = {
          language: ce.language,
          // TODO: remove with version 11.0
          re: ce.relevance,
          relevance: ce.relevance
        }, ce.secondBest && (M.secondBest = {
          language: ce.secondBest.language,
          relevance: ce.secondBest.relevance
        }), fe("after:highlightElement", { el: M, result: ce, text: re });
      }
      function g(M) {
        a = Zp(a, M);
      }
      const b = () => {
        v(), Co("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function w() {
        v(), Co("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let _ = false;
      function v() {
        if (document.readyState === "loading") {
          _ = true;
          return;
        }
        document.querySelectorAll(a.cssSelector).forEach(m);
      }
      function T() {
        _ && v();
      }
      typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", T, false);
      function S(M, L) {
        let J = null;
        try {
          J = L(n3);
        } catch (re) {
          if (lo("Language definition for '{}' could not be registered.".replace("{}", M)), o)
            lo(re);
          else
            throw re;
          J = s;
        }
        J.name || (J.name = M), e[M] = J, J.rawDefinition = L.bind(null, n3), J.aliases && q(J.aliases, { languageName: M });
      }
      function z(M) {
        delete e[M];
        for (const L of Object.keys(t))
          t[L] === M && delete t[L];
      }
      function U() {
        return Object.keys(e);
      }
      function B(M) {
        return M = (M || "").toLowerCase(), e[M] || e[t[M]];
      }
      function q(M, { languageName: L }) {
        typeof M == "string" && (M = [M]), M.forEach((J) => {
          t[J.toLowerCase()] = L;
        });
      }
      function oe(M) {
        const L = B(M);
        return L && !L.disableAutodetect;
      }
      function de(M) {
        M["before:highlightBlock"] && !M["before:highlightElement"] && (M["before:highlightElement"] = (L) => {
          M["before:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        }), M["after:highlightBlock"] && !M["after:highlightElement"] && (M["after:highlightElement"] = (L) => {
          M["after:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        });
      }
      function ke(M) {
        de(M), r.push(M);
      }
      function we(M) {
        const L = r.indexOf(M);
        L !== -1 && r.splice(L, 1);
      }
      function fe(M, L) {
        const J = M;
        r.forEach(function(re) {
          re[J] && re[J](L);
        });
      }
      function he(M) {
        return Co("10.7.0", "highlightBlock will be removed entirely in v12.0"), Co("10.7.0", "Please use highlightElement now."), m(M);
      }
      Object.assign(n3, {
        highlight: u,
        highlightAuto: f,
        highlightAll: v,
        highlightElement: m,
        // TODO: Remove with v12 API
        highlightBlock: he,
        configure: g,
        initHighlighting: b,
        initHighlightingOnLoad: w,
        registerLanguage: S,
        unregisterLanguage: z,
        listLanguages: U,
        getLanguage: B,
        registerAliases: q,
        autoDetection: oe,
        inherit: Zp,
        addPlugin: ke,
        removePlugin: we
      }), n3.debugMode = function() {
        o = false;
      }, n3.safeMode = function() {
        o = true;
      }, n3.versionString = GT, n3.regex = {
        concat: ko,
        lookahead: xg,
        either: Hu,
        optional: cT,
        anyNumberOfTimes: lT
      };
      for (const M in Ss)
        typeof Ss[M] == "object" && Sg(Ss[M]);
      return Object.assign(n3, Ss), n3;
    }, Jo = Lg({});
    Jo.newInstance = () => Lg({});
    var YT = Jo;
    Jo.HighlightJS = Jo;
    Jo.default = Jo;
    var XT = /* @__PURE__ */ rT(YT);
    function Bg(n3, e = []) {
      return n3.map((t) => {
        const r = [...e, ...t.properties ? t.properties.className : []];
        return t.children ? Bg(t.children, r) : {
          text: t.value,
          classes: r
        };
      }).flat();
    }
    function ef(n3) {
      return n3.value || n3.children || [];
    }
    function ZT(n3) {
      return !!XT.getLanguage(n3);
    }
    function tf({ doc: n3, name: e, lowlight: t, defaultLanguage: r }) {
      const o = [];
      return xc(n3, (i) => i.type.name === e).forEach((i) => {
        var s;
        let a = i.pos + 1;
        const l = i.node.attrs.language || r, c2 = t.listLanguages(), u = l && (c2.includes(l) || ZT(l) || !((s = t.registered) === null || s === void 0) && s.call(t, l)) ? ef(t.highlight(l, i.node.textContent)) : ef(t.highlightAuto(i.node.textContent));
        Bg(u).forEach((d) => {
          const p2 = a + d.text.length;
          if (d.classes.length) {
            const f = ht.inline(a, p2, {
              class: d.classes.join(" ")
            });
            o.push(f);
          }
          a = p2;
        });
      }), He.create(n3, o);
    }
    function QT(n3) {
      return typeof n3 == "function";
    }
    function eO({ name: n3, lowlight: e, defaultLanguage: t }) {
      if (!["highlight", "highlightAuto", "listLanguages"].every((o) => QT(e[o])))
        throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
      const r = new Ue({
        key: new Ze("lowlight"),
        state: {
          init: (o, { doc: i }) => tf({
            doc: i,
            name: n3,
            lowlight: e,
            defaultLanguage: t
          }),
          apply: (o, i, s, a) => {
            const l = s.selection.$head.parent.type.name, c2 = a.selection.$head.parent.type.name, u = xc(s.doc, (p2) => p2.type.name === n3), d = xc(a.doc, (p2) => p2.type.name === n3);
            return o.docChanged && ([l, c2].includes(n3) || d.length !== u.length || o.steps.some((p2) => (
              // @ts-ignore
              p2.from !== void 0 && p2.to !== void 0 && u.some((f) => (
                // @ts-ignore
                f.pos >= p2.from && f.pos + f.node.nodeSize <= p2.to
              ))
            ))) ? tf({
              doc: o.doc,
              name: n3,
              lowlight: e,
              defaultLanguage: t
            }) : i.map(o.mapping, o.doc);
          }
        },
        props: {
          decorations(o) {
            return r.getState(o);
          }
        }
      });
      return r;
    }
    const tO = sg.extend({
      addOptions() {
        var n3;
        return {
          ...(n3 = this.parent) === null || n3 === void 0 ? void 0 : n3.call(this),
          lowlight: {},
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      addProseMirrorPlugins() {
        var n3;
        return [
          ...((n3 = this.parent) === null || n3 === void 0 ? void 0 : n3.call(this)) || [],
          eO({
            name: this.name,
            lowlight: this.options.lowlight,
            defaultLanguage: this.options.defaultLanguage
          })
        ];
      }
    });
    function nO(n3) {
      const e = n3.regex, t = n3.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n3.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n3.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n3.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n3.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + n3.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + n3.IDENT_RE + "\\s*\\(", h2 = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], m = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], g = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], b = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: m,
        keyword: h2,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: g
      }, T = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: b
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          n3.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        T,
        d,
        a,
        t,
        n3.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], z = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, U = {
        className: "function",
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: v,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              t,
              n3.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n3.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n3.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          z,
          U,
          T,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: n3.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function rO(n3) {
      const e = {
        type: [
          "boolean",
          "byte",
          "word",
          "String"
        ],
        built_in: [
          "KeyboardController",
          "MouseController",
          "SoftwareSerial",
          "EthernetServer",
          "EthernetClient",
          "LiquidCrystal",
          "RobotControl",
          "GSMVoiceCall",
          "EthernetUDP",
          "EsploraTFT",
          "HttpClient",
          "RobotMotor",
          "WiFiClient",
          "GSMScanner",
          "FileSystem",
          "Scheduler",
          "GSMServer",
          "YunClient",
          "YunServer",
          "IPAddress",
          "GSMClient",
          "GSMModem",
          "Keyboard",
          "Ethernet",
          "Console",
          "GSMBand",
          "Esplora",
          "Stepper",
          "Process",
          "WiFiUDP",
          "GSM_SMS",
          "Mailbox",
          "USBHost",
          "Firmata",
          "PImage",
          "Client",
          "Server",
          "GSMPIN",
          "FileIO",
          "Bridge",
          "Serial",
          "EEPROM",
          "Stream",
          "Mouse",
          "Audio",
          "Servo",
          "File",
          "Task",
          "GPRS",
          "WiFi",
          "Wire",
          "TFT",
          "GSM",
          "SPI",
          "SD"
        ],
        _hints: [
          "setup",
          "loop",
          "runShellCommandAsynchronously",
          "analogWriteResolution",
          "retrieveCallingNumber",
          "printFirmwareVersion",
          "analogReadResolution",
          "sendDigitalPortPair",
          "noListenOnLocalhost",
          "readJoystickButton",
          "setFirmwareVersion",
          "readJoystickSwitch",
          "scrollDisplayRight",
          "getVoiceCallStatus",
          "scrollDisplayLeft",
          "writeMicroseconds",
          "delayMicroseconds",
          "beginTransmission",
          "getSignalStrength",
          "runAsynchronously",
          "getAsynchronously",
          "listenOnLocalhost",
          "getCurrentCarrier",
          "readAccelerometer",
          "messageAvailable",
          "sendDigitalPorts",
          "lineFollowConfig",
          "countryNameWrite",
          "runShellCommand",
          "readStringUntil",
          "rewindDirectory",
          "readTemperature",
          "setClockDivider",
          "readLightSensor",
          "endTransmission",
          "analogReference",
          "detachInterrupt",
          "countryNameRead",
          "attachInterrupt",
          "encryptionType",
          "readBytesUntil",
          "robotNameWrite",
          "readMicrophone",
          "robotNameRead",
          "cityNameWrite",
          "userNameWrite",
          "readJoystickY",
          "readJoystickX",
          "mouseReleased",
          "openNextFile",
          "scanNetworks",
          "noInterrupts",
          "digitalWrite",
          "beginSpeaker",
          "mousePressed",
          "isActionDone",
          "mouseDragged",
          "displayLogos",
          "noAutoscroll",
          "addParameter",
          "remoteNumber",
          "getModifiers",
          "keyboardRead",
          "userNameRead",
          "waitContinue",
          "processInput",
          "parseCommand",
          "printVersion",
          "readNetworks",
          "writeMessage",
          "blinkVersion",
          "cityNameRead",
          "readMessage",
          "setDataMode",
          "parsePacket",
          "isListening",
          "setBitOrder",
          "beginPacket",
          "isDirectory",
          "motorsWrite",
          "drawCompass",
          "digitalRead",
          "clearScreen",
          "serialEvent",
          "rightToLeft",
          "setTextSize",
          "leftToRight",
          "requestFrom",
          "keyReleased",
          "compassRead",
          "analogWrite",
          "interrupts",
          "WiFiServer",
          "disconnect",
          "playMelody",
          "parseFloat",
          "autoscroll",
          "getPINUsed",
          "setPINUsed",
          "setTimeout",
          "sendAnalog",
          "readSlider",
          "analogRead",
          "beginWrite",
          "createChar",
          "motorsStop",
          "keyPressed",
          "tempoWrite",
          "readButton",
          "subnetMask",
          "debugPrint",
          "macAddress",
          "writeGreen",
          "randomSeed",
          "attachGPRS",
          "readString",
          "sendString",
          "remotePort",
          "releaseAll",
          "mouseMoved",
          "background",
          "getXChange",
          "getYChange",
          "answerCall",
          "getResult",
          "voiceCall",
          "endPacket",
          "constrain",
          "getSocket",
          "writeJSON",
          "getButton",
          "available",
          "connected",
          "findUntil",
          "readBytes",
          "exitValue",
          "readGreen",
          "writeBlue",
          "startLoop",
          "IPAddress",
          "isPressed",
          "sendSysex",
          "pauseMode",
          "gatewayIP",
          "setCursor",
          "getOemKey",
          "tuneWrite",
          "noDisplay",
          "loadImage",
          "switchPIN",
          "onRequest",
          "onReceive",
          "changePIN",
          "playFile",
          "noBuffer",
          "parseInt",
          "overflow",
          "checkPIN",
          "knobRead",
          "beginTFT",
          "bitClear",
          "updateIR",
          "bitWrite",
          "position",
          "writeRGB",
          "highByte",
          "writeRed",
          "setSpeed",
          "readBlue",
          "noStroke",
          "remoteIP",
          "transfer",
          "shutdown",
          "hangCall",
          "beginSMS",
          "endWrite",
          "attached",
          "maintain",
          "noCursor",
          "checkReg",
          "checkPUK",
          "shiftOut",
          "isValid",
          "shiftIn",
          "pulseIn",
          "connect",
          "println",
          "localIP",
          "pinMode",
          "getIMEI",
          "display",
          "noBlink",
          "process",
          "getBand",
          "running",
          "beginSD",
          "drawBMP",
          "lowByte",
          "setBand",
          "release",
          "bitRead",
          "prepare",
          "pointTo",
          "readRed",
          "setMode",
          "noFill",
          "remove",
          "listen",
          "stroke",
          "detach",
          "attach",
          "noTone",
          "exists",
          "buffer",
          "height",
          "bitSet",
          "circle",
          "config",
          "cursor",
          "random",
          "IRread",
          "setDNS",
          "endSMS",
          "getKey",
          "micros",
          "millis",
          "begin",
          "print",
          "write",
          "ready",
          "flush",
          "width",
          "isPIN",
          "blink",
          "clear",
          "press",
          "mkdir",
          "rmdir",
          "close",
          "point",
          "yield",
          "image",
          "BSSID",
          "click",
          "delay",
          "read",
          "text",
          "move",
          "peek",
          "beep",
          "rect",
          "line",
          "open",
          "seek",
          "fill",
          "size",
          "turn",
          "stop",
          "home",
          "find",
          "step",
          "tone",
          "sqrt",
          "RSSI",
          "SSID",
          "end",
          "bit",
          "tan",
          "cos",
          "sin",
          "pow",
          "map",
          "abs",
          "max",
          "min",
          "get",
          "run",
          "put"
        ],
        literal: [
          "DIGITAL_MESSAGE",
          "FIRMATA_STRING",
          "ANALOG_MESSAGE",
          "REPORT_DIGITAL",
          "REPORT_ANALOG",
          "INPUT_PULLUP",
          "SET_PIN_MODE",
          "INTERNAL2V56",
          "SYSTEM_RESET",
          "LED_BUILTIN",
          "INTERNAL1V1",
          "SYSEX_START",
          "INTERNAL",
          "EXTERNAL",
          "DEFAULT",
          "OUTPUT",
          "INPUT",
          "HIGH",
          "LOW"
        ]
      }, t = nO(n3), r = (
        /** @type {Record<string,any>} */
        t.keywords
      );
      return r.type = [
        ...r.type,
        ...e.type
      ], r.literal = [
        ...r.literal,
        ...e.literal
      ], r.built_in = [
        ...r.built_in,
        ...e.built_in
      ], r._hints = e._hints, t.name = "Arduino", t.aliases = ["ino"], t.supersetOf = "cpp", t;
    }
    function oO(n3) {
      const e = n3.regex, t = {}, r = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [t]
          }
          // default values
        ]
      };
      Object.assign(t, {
        className: "variable",
        variants: [
          { begin: e.concat(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            "(?![\\w\\d])(?![$])"
          ) },
          r
        ]
      });
      const o = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [n3.BACKSLASH_ESCAPE]
      }, i = n3.inherit(
        n3.COMMENT(),
        {
          match: [
            /(^|\s)/,
            /#.*$/
          ],
          scope: {
            2: "comment"
          }
        }
      ), s = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          n3.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      }, a = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          n3.BACKSLASH_ESCAPE,
          t,
          o
        ]
      };
      o.contains.push(a);
      const l = {
        match: /\\"/
      }, c2 = {
        className: "string",
        begin: /'/,
        end: /'/
      }, u = {
        match: /\\'/
      }, d = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          n3.NUMBER_MODE,
          t
        ]
      }, p2 = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ], f = n3.SHEBANG({
        binary: `(${p2.join("|")})`,
        relevance: 10
      }), h2 = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [n3.inherit(n3.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      }, m = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ], g = [
        "true",
        "false"
      ], b = { match: /(\/[a-z._-]+)+/ }, w = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ], _ = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ], v = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ], T = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        // "false", // keyword literal already
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        // "true", // keyword literal already
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: m,
          literal: g,
          built_in: [
            ...w,
            ..._,
            // Shell modifiers
            "set",
            "shopt",
            ...v,
            ...T
          ]
        },
        contains: [
          f,
          // to catch known shells and boost relevancy
          n3.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          h2,
          d,
          i,
          s,
          b,
          a,
          l,
          c2,
          u,
          t
        ]
      };
    }
    function iO(n3) {
      const e = n3.regex, t = n3.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        variants: [
          { begin: "\\b[a-z\\d_]*_t\\b" },
          { match: /\batomic_[a-z]{3,6}\b/ }
        ]
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n3.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n3.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          { match: /\b(0b[01']+)/ },
          { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
          { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n3.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n3.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + n3.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + n3.IDENT_RE + "\\s*\\(", g = {
        keyword: [
          "asm",
          "auto",
          "break",
          "case",
          "continue",
          "default",
          "do",
          "else",
          "enum",
          "extern",
          "for",
          "fortran",
          "goto",
          "if",
          "inline",
          "register",
          "restrict",
          "return",
          "sizeof",
          "typeof",
          "typeof_unqual",
          "struct",
          "switch",
          "typedef",
          "union",
          "volatile",
          "while",
          "_Alignas",
          "_Alignof",
          "_Atomic",
          "_Generic",
          "_Noreturn",
          "_Static_assert",
          "_Thread_local",
          // aliases
          "alignas",
          "alignof",
          "noreturn",
          "static_assert",
          "thread_local",
          // not a C keyword but is, for all intents and purposes, treated exactly like one.
          "_Pragma"
        ],
        type: [
          "float",
          "double",
          "signed",
          "unsigned",
          "int",
          "short",
          "long",
          "char",
          "void",
          "_Bool",
          "_BitInt",
          "_Complex",
          "_Imaginary",
          "_Decimal32",
          "_Decimal64",
          "_Decimal96",
          "_Decimal128",
          "_Decimal64x",
          "_Decimal128x",
          "_Float16",
          "_Float32",
          "_Float64",
          "_Float128",
          "_Float32x",
          "_Float64x",
          "_Float128x",
          // modifiers
          "const",
          "static",
          "constexpr",
          // aliases
          "complex",
          "bool",
          "imaginary"
        ],
        literal: "true false NULL",
        // TODO: apply hinting work similar to what was done in cpp.js
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      }, b = [
        d,
        a,
        t,
        n3.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], w = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: g,
        contains: b.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            contains: b.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, _ = {
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: g,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: g,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [n3.inherit(p2, { className: "title.function" })],
            relevance: 0
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              t,
              n3.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: g,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n3.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n3.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: g,
        // Until differentiations are added between `c` and `cpp`, `c` will
        // not be auto-detected to avoid auto-detect conflicts between C and C++
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(
          w,
          _,
          b,
          [
            d,
            {
              begin: n3.IDENT_RE + "::",
              keywords: g
            },
            {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [
                { beginKeywords: "final class struct" },
                n3.TITLE_MODE
              ]
            }
          ]
        ),
        exports: {
          preprocessor: d,
          strings: c2,
          keywords: g
        }
      };
    }
    function sO(n3) {
      const e = n3.regex, t = n3.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, c2 = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n3.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n3.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, u = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n3.inherit(c2, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n3.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(o) + n3.IDENT_RE,
        relevance: 0
      }, f = e.optional(o) + n3.IDENT_RE + "\\s*\\(", h2 = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], m = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], g = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], b = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: m,
        keyword: h2,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: g
      }, T = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: b
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          n3.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        T,
        d,
        a,
        t,
        n3.C_BLOCK_COMMENT_MODE,
        u,
        c2
      ], z = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, U = {
        className: "function",
        begin: "(" + s + "[\\*&\\s]+)+" + f,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: r,
            keywords: v,
            relevance: 0
          },
          {
            begin: f,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              c2,
              u
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              t,
              n3.C_BLOCK_COMMENT_MODE,
              c2,
              u,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n3.C_BLOCK_COMMENT_MODE,
                  c2,
                  u,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n3.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          z,
          U,
          T,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: n3.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function aO(n3) {
      const e = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ], t = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ], r = [
        "default",
        "false",
        "null",
        "true"
      ], o = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ], i = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ], s = {
        keyword: o.concat(i),
        built_in: e,
        literal: r
      }, a = n3.inherit(n3.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      }, c2 = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      }, u = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      }, d = n3.inherit(u, { illegal: /\n/ }), p2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: s
      }, f = n3.inherit(p2, { illegal: /\n/ }), h2 = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          n3.BACKSLASH_ESCAPE,
          f
        ]
      }, m = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          p2
        ]
      }, g = n3.inherit(m, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          f
        ]
      });
      p2.contains = [
        m,
        h2,
        u,
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE,
        l,
        n3.C_BLOCK_COMMENT_MODE
      ], f.contains = [
        g,
        h2,
        d,
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE,
        l,
        n3.inherit(n3.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const b = { variants: [
        c2,
        m,
        h2,
        u,
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE
      ] }, w = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          a
        ]
      }, _ = n3.IDENT_RE + "(<" + n3.IDENT_RE + "(\\s*,\\s*" + n3.IDENT_RE + ")*>)?(\\[\\])?", v = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + n3.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: s,
        illegal: /::/,
        contains: [
          n3.COMMENT(
            "///",
            "$",
            {
              returnBegin: true,
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: "///",
                      relevance: 0
                    },
                    { begin: "<!--|-->" },
                    {
                      begin: "</?",
                      end: ">"
                    }
                  ]
                }
              ]
            }
          ),
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          b,
          l,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              a,
              w,
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              w,
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + _ + "\\s+)+" + n3.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: s,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: t.join(" "),
                relevance: 0
              },
              {
                begin: n3.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  n3.TITLE_MODE,
                  w
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: s,
                relevance: 0,
                contains: [
                  b,
                  l,
                  n3.C_BLOCK_COMMENT_MODE
                ]
              },
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          v
        ]
      };
    }
    const lO = (n3) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n3.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n3.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), cO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], uO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], dO = [
      ...cO,
      ...uO
    ], pO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), fO = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), hO = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), mO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function gO(n3) {
      const e = n3.regex, t = lO(n3), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, o = "and or not only", i = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          t.BLOCK_COMMENT,
          r,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          t.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + s,
            relevance: 0
          },
          t.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + fO.join("|") + ")" },
              { begin: ":(:)?(" + hO.join("|") + ")" }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          t.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + mO.join("|") + ")\\b"
          },
          // attribute values
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              t.BLOCK_COMMENT,
              t.HEXCOLOR,
              t.IMPORTANT,
              t.CSS_NUMBER_MODE,
              ...a,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                // from keywords
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...a,
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              t.FUNCTION_DISPATCH
            ]
          },
          {
            begin: e.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            // break on Less variables @var: ...
            contains: [
              {
                className: "keyword",
                begin: i
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: o,
                  attribute: pO.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...a,
                  t.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + dO.join("|") + ")\\b"
          }
        ]
      };
    }
    function bO(n3) {
      const e = n3.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: e.either(
              /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
              /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
              /^--- +\d+,\d+ +----$/
            )
          },
          {
            className: "comment",
            variants: [
              {
                begin: e.either(
                  /Index: /,
                  /^index/,
                  /={3,}/,
                  /^-{3}/,
                  /^\*{3} /,
                  /^\+{3}/,
                  /^diff --git/
                ),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    function yO(n3) {
      const i = {
        keyword: [
          "break",
          "case",
          "chan",
          "const",
          "continue",
          "default",
          "defer",
          "else",
          "fallthrough",
          "for",
          "func",
          "go",
          "goto",
          "if",
          "import",
          "interface",
          "map",
          "package",
          "range",
          "return",
          "select",
          "struct",
          "switch",
          "type",
          "var"
        ],
        type: [
          "bool",
          "byte",
          "complex64",
          "complex128",
          "error",
          "float32",
          "float64",
          "int8",
          "int16",
          "int32",
          "int64",
          "string",
          "uint8",
          "uint16",
          "uint32",
          "uint64",
          "int",
          "uint",
          "uintptr",
          "rune"
        ],
        literal: [
          "true",
          "false",
          "iota",
          "nil"
        ],
        built_in: [
          "append",
          "cap",
          "close",
          "complex",
          "copy",
          "imag",
          "len",
          "make",
          "new",
          "panic",
          "print",
          "println",
          "real",
          "recover",
          "delete"
        ]
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: i,
        illegal: "</",
        contains: [
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              n3.QUOTE_STRING_MODE,
              n3.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                // hex without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                // hex with a present digit before . (making a digit afterwards optional)
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                // leading 0o octal
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                // decimal without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                // decimal with a present digit before . (making a digit afterwards optional)
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
            // relevance booster
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              n3.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: i,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    function vO(n3) {
      const e = n3.regex, t = /[_A-Za-z][_0-9A-Za-z]*/;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: [
            "true",
            "false",
            "null"
          ]
        },
        contains: [
          n3.HASH_COMMENT_MODE,
          n3.QUOTE_STRING_MODE,
          n3.NUMBER_MODE,
          {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          },
          {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          },
          {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          },
          {
            scope: "meta",
            match: /@\w+/,
            excludeEnd: true
          },
          {
            scope: "symbol",
            begin: e.concat(t, e.lookahead(/\s*:/)),
            relevance: 0
          }
        ],
        illegal: [
          /[;<']/,
          /BEGIN/
        ]
      };
    }
    function wO(n3) {
      const e = n3.regex, t = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: /([+-]+)?[\d]+_[\d_]+/ },
          { begin: n3.NUMBER_RE }
        ]
      }, r = n3.COMMENT();
      r.variants = [
        {
          begin: /;/,
          end: /$/
        },
        {
          begin: /#/,
          end: /$/
        }
      ];
      const o = {
        className: "variable",
        variants: [
          { begin: /\$[\w\d"][\w\d_]*/ },
          { begin: /\$\{(.*?)\}/ }
        ]
      }, i = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      }, s = {
        className: "string",
        contains: [n3.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: "'''",
            end: "'''",
            relevance: 10
          },
          {
            begin: '"""',
            end: '"""',
            relevance: 10
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "'",
            end: "'"
          }
        ]
      }, a = {
        begin: /\[/,
        end: /\]/,
        contains: [
          r,
          i,
          o,
          s,
          t,
          "self"
        ],
        relevance: 0
      }, l = /[A-Za-z0-9_-]+/, c2 = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
        l,
        c2,
        u
      ), p2 = e.concat(
        d,
        "(\\s*\\.\\s*",
        d,
        ")*",
        e.lookahead(/\s*=\s*[^#\s]/)
      );
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [
          r,
          {
            className: "section",
            begin: /\[+/,
            end: /\]+/
          },
          {
            begin: p2,
            className: "attr",
            starts: {
              end: /$/,
              contains: [
                r,
                a,
                i,
                o,
                s,
                t
              ]
            }
          }
        ]
      };
    }
    var Mo = "[0-9](_*[0-9])*", Cs = `\\.(${Mo})`, xs = "[0-9a-fA-F](_*[0-9a-fA-F])*", nf = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${Mo})((${Cs})|\\.)?|(${Cs}))[eE][+-]?(${Mo})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${Mo})((${Cs})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${Cs})[fFdD]?\\b` },
        { begin: `\\b(${Mo})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${xs})\\.?|(${xs})?\\.(${xs}))[pP][+-]?(${Mo})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${xs})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function Pg(n3, e, t) {
      return t === -1 ? "" : n3.replace(e, (r) => Pg(n3, e, t - 1));
    }
    function kO(n3) {
      const e = n3.regex, t = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", r = t + Pg("(?:<" + t + "~~~(?:\\s*,\\s*" + t + "~~~)*>)?", /~~~/g, 2), l = {
        keyword: [
          "synchronized",
          "abstract",
          "private",
          "var",
          "static",
          "if",
          "const ",
          "for",
          "while",
          "strictfp",
          "finally",
          "protected",
          "import",
          "native",
          "final",
          "void",
          "enum",
          "else",
          "break",
          "transient",
          "catch",
          "instanceof",
          "volatile",
          "case",
          "assert",
          "package",
          "default",
          "public",
          "try",
          "switch",
          "continue",
          "throws",
          "protected",
          "public",
          "private",
          "module",
          "requires",
          "exports",
          "do",
          "sealed",
          "yield",
          "permits",
          "goto",
          "when"
        ],
        literal: [
          "false",
          "true",
          "null"
        ],
        type: [
          "char",
          "boolean",
          "long",
          "float",
          "int",
          "byte",
          "short",
          "double"
        ],
        built_in: [
          "super",
          "this"
        ]
      }, c2 = {
        className: "meta",
        begin: "@" + t,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
            // allow nested () inside our annotation
          }
        ]
      }, u = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: l,
        relevance: 0,
        contains: [n3.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: l,
        illegal: /<\/|#/,
        contains: [
          n3.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/,
                  relevance: 0
                },
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [n3.BACKSLASH_ESCAPE]
          },
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              t
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            // Exceptions for hyphenated keywords
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              e.concat(/(?!else)/, t),
              /\s+/,
              t,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              t
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              u,
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + r + "\\s+)",
              n3.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: l,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: l,
                relevance: 0,
                contains: [
                  c2,
                  n3.APOS_STRING_MODE,
                  n3.QUOTE_STRING_MODE,
                  nf,
                  n3.C_BLOCK_COMMENT_MODE
                ]
              },
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          nf,
          c2
        ]
      };
    }
    const rf = "[A-Za-z$_][0-9A-Za-z$_]*", EO = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], _O = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], $g = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], Fg = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], zg = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], SO = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], CO = [].concat(
      zg,
      $g,
      Fg
    );
    function xO(n3) {
      const e = n3.regex, t = (L, { after: J }) => {
        const re = "</" + L[0].slice(1);
        return L.input.indexOf(re, J) !== -1;
      }, r = rf, o = {
        begin: "<>",
        end: "</>"
      }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, J) => {
          const re = L[0].length + L.index, ce = L.input[re];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ce === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ce === ","
          ) {
            J.ignoreMatch();
            return;
          }
          ce === ">" && (t(L, { after: re }) || J.ignoreMatch());
          let Se;
          const Fe = L.input.substring(re);
          if (Se = Fe.match(/^\s*=/)) {
            J.ignoreMatch();
            return;
          }
          if ((Se = Fe.match(/^\s+extends\s+/)) && Se.index === 0) {
            J.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: rf,
        keyword: EO,
        literal: _O,
        built_in: CO,
        "variable.language": SO
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, f = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, h2 = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, m = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, g = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          n3.BACKSLASH_ESCAPE,
          p2
        ]
      }, w = {
        className: "comment",
        variants: [
          n3.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: r + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          n3.C_BLOCK_COMMENT_MODE,
          n3.C_LINE_COMMENT_MODE
        ]
      }, _ = [
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE,
        f,
        h2,
        m,
        g,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = _.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(_)
      });
      const v = [].concat(w, p2.contains), T = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: T
      }, z = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              r,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(r, "(", e.concat(/\./, r), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              r
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, U = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...$g,
            ...Fg
          ]
        }
      }, B = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, q = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              r,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, oe = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function de(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const ke = {
        match: e.concat(
          /\b/,
          de([
            ...zg,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          r,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, we = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(r, /(?![0-9A-Za-z$_(])/)
        )),
        end: r,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, fe = {
        match: [
          /get|set/,
          /\s+/,
          r,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n3.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
        match: [
          /const|var|let/,
          /\s+/,
          r,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: T, CLASS_REFERENCE: U },
        illegal: /#(?![$_A-z])/,
        contains: [
          n3.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          B,
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE,
          f,
          h2,
          m,
          g,
          w,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          U,
          {
            scope: "attr",
            match: r + e.lookahead(":"),
            relevance: 0
          },
          M,
          {
            // "value" container
            begin: "(" + n3.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              w,
              n3.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: n3.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: T
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: o.begin, end: o.end },
                  { match: i },
                  {
                    begin: s.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": s.isTrulyOpeningTag,
                    end: s.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: s.begin,
                    end: s.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          q,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + n3.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              n3.inherit(n3.TITLE_MODE, { begin: r, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          we,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + r,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ke,
          oe,
          z,
          fe,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function TO(n3) {
      const e = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      }, t = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      }, r = [
        "true",
        "false",
        "null"
      ], o = {
        scope: "literal",
        beginKeywords: r.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: r
        },
        contains: [
          e,
          t,
          n3.QUOTE_STRING_MODE,
          o,
          n3.C_NUMBER_MODE,
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    var Ao = "[0-9](_*[0-9])*", Ts = `\\.(${Ao})`, Os = "[0-9a-fA-F](_*[0-9a-fA-F])*", OO = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${Ao})((${Ts})|\\.)?|(${Ts}))[eE][+-]?(${Ao})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${Ao})((${Ts})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${Ts})[fFdD]?\\b` },
        { begin: `\\b(${Ao})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${Os})\\.?|(${Os})?\\.(${Os}))[pP][+-]?(${Ao})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${Os})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function NO(n3) {
      const e = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      }, t = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      }, r = {
        className: "symbol",
        begin: n3.UNDERSCORE_IDENT_RE + "@"
      }, o = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [n3.C_NUMBER_MODE]
      }, i = {
        className: "variable",
        begin: "\\$" + n3.UNDERSCORE_IDENT_RE
      }, s = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              i,
              o
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [n3.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              i,
              o
            ]
          }
        ]
      };
      o.contains.push(s);
      const a = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + n3.UNDERSCORE_IDENT_RE + ")?"
      }, l = {
        className: "meta",
        begin: "@" + n3.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              n3.inherit(s, { className: "string" }),
              "self"
            ]
          }
        ]
      }, c2 = OO, u = n3.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [n3.C_BLOCK_COMMENT_MODE] }
      ), d = { variants: [
        {
          className: "type",
          begin: n3.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
          // defined later
        }
      ] }, p2 = d;
      return p2.variants[1].contains = [d], d.variants[1].contains = [p2], {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: e,
        contains: [
          n3.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          n3.C_LINE_COMMENT_MODE,
          u,
          t,
          r,
          a,
          l,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: e,
            relevance: 5,
            contains: [
              {
                begin: n3.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [n3.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: e,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      d,
                      n3.C_LINE_COMMENT_MODE,
                      u
                    ],
                    relevance: 0
                  },
                  n3.C_LINE_COMMENT_MODE,
                  u,
                  a,
                  l,
                  s,
                  n3.C_NUMBER_MODE
                ]
              },
              u
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              n3.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              n3.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              a,
              l
            ]
          },
          s,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: `
`
          },
          c2
        ]
      };
    }
    const MO = (n3) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n3.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n3.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), AO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], RO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], IO = [
      ...AO,
      ...RO
    ], DO = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), Hg = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), Ug = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), LO = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse(), BO = Hg.concat(Ug).sort().reverse();
    function PO(n3) {
      const e = MO(n3), t = BO, r = "and or not only", o = "[\\w-]+", i = "(" + o + "|@\\{" + o + "\\})", s = [], a = [], l = function(_) {
        return {
          // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
          className: "string",
          begin: "~?" + _ + ".*?" + _
        };
      }, c2 = function(_, v, T) {
        return {
          className: _,
          begin: v,
          relevance: T
        };
      }, u = {
        $pattern: /[a-z-]+/,
        keyword: r,
        attribute: DO.join(" ")
      }, d = {
        // used only to properly balance nested parens inside mixin call, def. arg list
        begin: "\\(",
        end: "\\)",
        contains: a,
        keywords: u,
        relevance: 0
      };
      a.push(
        n3.C_LINE_COMMENT_MODE,
        n3.C_BLOCK_COMMENT_MODE,
        l("'"),
        l('"'),
        e.CSS_NUMBER_MODE,
        // fixme: it does not include dot for numbers like .5em :(
        {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        },
        e.HEXCOLOR,
        d,
        c2("variable", "@@?" + o, 10),
        c2("variable", "@\\{" + o + "\\}"),
        c2("built_in", "~?`[^`]*?`"),
        // inline javascript (or whatever host language) *multiline* string
        {
          // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
          className: "attribute",
          begin: o + "\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        },
        e.IMPORTANT,
        { beginKeywords: "and not" },
        e.FUNCTION_DISPATCH
      );
      const p2 = a.concat({
        begin: /\{/,
        end: /\}/,
        contains: s
      }), f = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{ beginKeywords: "and not" }].concat(a)
        // using this form to override VALUEs 'function' match
      }, h2 = {
        begin: i + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + LO.join("|") + ")\\b",
            end: /(?=:)/,
            starts: {
              endsWithParent: true,
              illegal: "[<=$]",
              relevance: 0,
              contains: a
            }
          }
        ]
      }, m = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: u,
          returnEnd: true,
          contains: a,
          relevance: 0
        }
      }, g = {
        className: "variable",
        variants: [
          // using more strict pattern for higher relevance to increase chances of Less detection.
          // this is *the only* Less specific statement used in most of the sources, so...
          // (well still often loose to the css-parser unless there's '//' comment,
          // simply because 1 variable just can't beat 99 properties :)
          {
            begin: "@" + o + "\\s*:",
            relevance: 15
          },
          { begin: "@" + o }
        ],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: p2
        }
      }, b = {
        // first parse unambiguous selectors (i.e. those not starting with tag)
        // then fall into the scary lookahead-discriminator variant.
        // this mode also handles mixin definitions and calls
        variants: [
          {
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
            // mixin calls end with ';'
          },
          {
            begin: i,
            end: /\{/
          }
        ],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          f,
          c2("keyword", "all\\b"),
          c2("variable", "@\\{" + o + "\\}"),
          // otherwise its identified as tag
          {
            begin: "\\b(" + IO.join("|") + ")\\b",
            className: "selector-tag"
          },
          e.CSS_NUMBER_MODE,
          c2("selector-tag", i, 0),
          c2("selector-id", "#" + i),
          c2("selector-class", "\\." + i, 0),
          c2("selector-tag", "&", 0),
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            begin: ":(" + Hg.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + Ug.join("|") + ")"
          },
          {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: p2
          },
          // argument list of parametric mixins
          { begin: "!important" },
          // eat !important after mixin call or it will be colored as tag
          e.FUNCTION_DISPATCH
        ]
      }, w = {
        begin: o + `:(:)?(${t.join("|")})`,
        returnBegin: true,
        contains: [b]
      };
      return s.push(
        n3.C_LINE_COMMENT_MODE,
        n3.C_BLOCK_COMMENT_MODE,
        m,
        g,
        w,
        h2,
        b,
        f,
        e.FUNCTION_DISPATCH
      ), {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: s
      };
    }
    function $O(n3) {
      const e = "\\[=*\\[", t = "\\]=*\\]", r = {
        begin: e,
        end: t,
        contains: ["self"]
      }, o = [
        n3.COMMENT("--(?!" + e + ")", "$"),
        n3.COMMENT(
          "--" + e,
          t,
          {
            contains: [r],
            relevance: 10
          }
        )
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: n3.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: (
            // Metatags and globals:
            "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          )
        },
        contains: o.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              n3.inherit(n3.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: o
              }
            ].concat(o)
          },
          n3.C_NUMBER_MODE,
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: e,
            end: t,
            contains: [r],
            relevance: 5
          }
        ])
      };
    }
    function FO(n3) {
      const e = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + n3.UNDERSCORE_IDENT_RE + "\\)",
            contains: [n3.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      }, t = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          n3.BACKSLASH_ESCAPE,
          e
        ]
      }, r = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          e,
          t
          // Added QUOTE_STRING as they can be a part of functions
        ]
      }, o = { begin: "^" + n3.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, i = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      }, s = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [e]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          n3.HASH_COMMENT_MODE,
          e,
          t,
          r,
          o,
          i,
          s
        ]
      };
    }
    function zO(n3) {
      const e = n3.regex, t = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      }, r = {
        begin: "^[-\\*]{3,}",
        end: "$"
      }, o = {
        className: "code",
        variants: [
          // TODO: fix to allow these to work with sublanguage also
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          // needed to allow markdown as a sublanguage to work
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            // use contains to gobble up multiple lines to allow the block to be whatever size
            // but only have a single open/close tag vs one per line
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      }, i = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      }, s = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
        variants: [
          // too much like nested array access in so many languages
          // to have any real relevance
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          // popular internet URLs
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
            relevance: 2
          },
          // relative urls
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          // whatever else, lower relevance (might not be a link at all)
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            // empty strings for alt or link text
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      }, c2 = {
        className: "strong",
        contains: [],
        // defined later
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      }, u = {
        className: "emphasis",
        contains: [],
        // defined later
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      }, d = n3.inherit(c2, { contains: [] }), p2 = n3.inherit(u, { contains: [] });
      c2.contains.push(p2), u.contains.push(d);
      let f = [
        t,
        l
      ];
      return [
        c2,
        u,
        d,
        p2
      ].forEach((b) => {
        b.contains = b.contains.concat(f);
      }), f = f.concat(c2, u), {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          {
            className: "section",
            variants: [
              {
                begin: "^#{1,6}",
                end: "$",
                contains: f
              },
              {
                begin: "(?=^.+?\\n[=-]{2,}$)",
                contains: [
                  { begin: "^[=-]*$" },
                  {
                    begin: "^",
                    end: "\\n",
                    contains: f
                  }
                ]
              }
            ]
          },
          t,
          i,
          c2,
          u,
          {
            className: "quote",
            begin: "^>\\s+",
            contains: f,
            end: "$"
          },
          o,
          r,
          l,
          s,
          {
            //https://spec.commonmark.org/0.31.2/#entity-references
            scope: "literal",
            match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
          }
        ]
      };
    }
    function HO(n3) {
      const e = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      }, t = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: t,
        keyword: [
          "while",
          "export",
          "sizeof",
          "typedef",
          "const",
          "struct",
          "for",
          "union",
          "volatile",
          "static",
          "mutable",
          "if",
          "do",
          "return",
          "goto",
          "enum",
          "else",
          "break",
          "extern",
          "asm",
          "case",
          "default",
          "register",
          "explicit",
          "typename",
          "switch",
          "continue",
          "inline",
          "readonly",
          "assign",
          "readwrite",
          "self",
          "@synchronized",
          "id",
          "typeof",
          "nonatomic",
          "IBOutlet",
          "IBAction",
          "strong",
          "weak",
          "copy",
          "in",
          "out",
          "inout",
          "bycopy",
          "byref",
          "oneway",
          "__strong",
          "__weak",
          "__block",
          "__autoreleasing",
          "@private",
          "@protected",
          "@public",
          "@try",
          "@property",
          "@end",
          "@throw",
          "@catch",
          "@finally",
          "@autoreleasepool",
          "@synthesize",
          "@dynamic",
          "@selector",
          "@optional",
          "@required",
          "@encode",
          "@package",
          "@import",
          "@defs",
          "@compatibility_alias",
          "__bridge",
          "__bridge_transfer",
          "__bridge_retained",
          "__bridge_retain",
          "__covariant",
          "__contravariant",
          "__kindof",
          "_Nonnull",
          "_Nullable",
          "_Null_unspecified",
          "__FUNCTION__",
          "__PRETTY_FUNCTION__",
          "__attribute__",
          "getter",
          "setter",
          "retain",
          "unsafe_unretained",
          "nonnull",
          "nullable",
          "null_unspecified",
          "null_resettable",
          "class",
          "instancetype",
          "NS_DESIGNATED_INITIALIZER",
          "NS_UNAVAILABLE",
          "NS_REQUIRES_SUPER",
          "NS_RETURNS_INNER_POINTER",
          "NS_INLINE",
          "NS_AVAILABLE",
          "NS_DEPRECATED",
          "NS_ENUM",
          "NS_OPTIONS",
          "NS_SWIFT_UNAVAILABLE",
          "NS_ASSUME_NONNULL_BEGIN",
          "NS_ASSUME_NONNULL_END",
          "NS_REFINED_FOR_SWIFT",
          "NS_SWIFT_NAME",
          "NS_SWIFT_NOTHROW",
          "NS_DURING",
          "NS_HANDLER",
          "NS_ENDHANDLER",
          "NS_VALUERETURN",
          "NS_VOIDRETURN"
        ],
        literal: [
          "false",
          "true",
          "FALSE",
          "TRUE",
          "nil",
          "YES",
          "NO",
          "NULL"
        ],
        built_in: [
          "dispatch_once_t",
          "dispatch_queue_t",
          "dispatch_sync",
          "dispatch_async",
          "dispatch_once"
        ],
        type: [
          "int",
          "float",
          "char",
          "unsigned",
          "signed",
          "short",
          "long",
          "double",
          "wchar_t",
          "unichar",
          "void",
          "bool",
          "BOOL",
          "id|0",
          "_Bool"
        ]
      }, l = {
        $pattern: t,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: a,
        illegal: "</",
        contains: [
          e,
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          n3.C_NUMBER_MODE,
          n3.QUOTE_STRING_MODE,
          n3.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [n3.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              n3.inherit(n3.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              n3.C_LINE_COMMENT_MODE,
              n3.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + l.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: l,
            contains: [n3.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + n3.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    function UO(n3) {
      const e = n3.regex, t = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ], r = /[dualxmsipngr]{0,12}/, o = {
        $pattern: /[\w.]+/,
        keyword: t.join(" ")
      }, i = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: o
      }, s = {
        begin: /->\{/,
        end: /\}/
        // contains defined later
      }, a = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      }, l = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: e.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              // negative look-ahead tries to avoid matching patterns that are not
              // Perl at all like $ident$, @ident@, etc.
              "(?![A-Za-z])(?![@$%])"
            )
          },
          {
            // Only $= is a special Perl variable and one can't declare @= or %=.
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [a]
      }, c2 = {
        className: "number",
        variants: [
          // decimal numbers:
          // include the case where a number starts with a dot (eg. .9), and
          // the leading 0? avoids mixing the first and second match on 0.x cases
          { match: /0?\.[0-9][0-9_]+\b/ },
          // include the special versioned number (eg. v5.38)
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          // non-decimal numbers:
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      }, u = [
        n3.BACKSLASH_ESCAPE,
        i,
        l
      ], d = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        // valid but infrequent and weird
        /#/
        // valid but infrequent and weird
      ], p2 = (m, g, b = "\\1") => {
        const w = b === "\\1" ? b : e.concat(b, g);
        return e.concat(
          e.concat("(?:", m, ")"),
          g,
          /(?:\\.|[^\\\/])*?/,
          w,
          /(?:\\.|[^\\\/])*?/,
          b,
          r
        );
      }, f = (m, g, b) => e.concat(
        e.concat("(?:", m, ")"),
        g,
        /(?:\\.|[^\\\/])*?/,
        b,
        r
      ), h2 = [
        l,
        n3.HASH_COMMENT_MODE,
        n3.COMMENT(
          /^=\w/,
          /=cut/,
          { endsWithParent: true }
        ),
        s,
        {
          className: "string",
          contains: u,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [n3.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [n3.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        c2,
        {
          // regexp container
          begin: "(\\/\\/|" + n3.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            n3.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                // allow matching common delimiters
                { begin: p2("s|tr|y", e.either(...d, { capture: true })) },
                // and then paired delmis
                { begin: p2("s|tr|y", "\\(", "\\)") },
                { begin: p2("s|tr|y", "\\[", "\\]") },
                { begin: p2("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  // could be a comment in many languages so do not count
                  // as relevant
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                // prefix is optional with /regex/
                { begin: f("(?:m|qr)?", /\//, /\//) },
                // allow matching common delimiters
                { begin: f("m|qr", e.either(...d, { capture: true }), /\1/) },
                // allow common paired delmins
                { begin: f("m|qr", /\(/, /\)/) },
                { begin: f("m|qr", /\[/, /\]/) },
                { begin: f("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [n3.TITLE_MODE, a]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [n3.TITLE_MODE, a, c2]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      return i.contains = h2, s.contains = h2, {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: o,
        contains: h2
      };
    }
    function VO(n3) {
      const e = n3.regex, t = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
        t
      ), o = e.concat(
        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
        t
      ), i = e.concat(
        /[A-Z]+/,
        t
      ), s = {
        scope: "variable",
        match: "\\$+" + r
      }, a = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          // boost for obvious PHP
          { begin: /<\?=/ },
          // less relevant per PSR-1 which says not to use short-tags
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
          // end php tag
        ]
      }, l = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      }, c2 = n3.inherit(n3.APOS_STRING_MODE, { illegal: null }), u = n3.inherit(n3.QUOTE_STRING_MODE, {
        illegal: null,
        contains: n3.QUOTE_STRING_MODE.contains.concat(l)
      }), d = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: n3.QUOTE_STRING_MODE.contains.concat(l),
        "on:begin": (we, fe) => {
          fe.data._beginMatch = we[1] || we[2];
        },
        "on:end": (we, fe) => {
          fe.data._beginMatch !== we[1] && fe.ignoreMatch();
        }
      }, p2 = n3.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      }), f = `[ 	
]`, h2 = {
        scope: "string",
        variants: [
          u,
          c2,
          d,
          p2
        ]
      }, m = {
        scope: "number",
        variants: [
          { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
          // Binary w/ underscore support
          { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
          // Octals w/ underscore support
          { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
          // Hex w/ underscore support
          // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
          { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
        ],
        relevance: 0
      }, g = [
        "false",
        "null",
        "true"
      ], b = [
        // Magic constants:
        // <https://www.php.net/manual/en/language.constants.predefined.php>
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        // Function that look like language construct or language construct that look like function:
        // List of keywords that may not require parenthesis
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
        // Other keywords:
        // <https://www.php.net/manual/en/reserved.php>
        // <https://www.php.net/manual/en/language.types.type-juggling.php>
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ], w = [
        // Standard PHP library:
        // <https://www.php.net/manual/en/book.spl.php>
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        // Reserved interfaces:
        // <https://www.php.net/manual/en/reserved.interfaces.php>
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        // Reserved classes:
        // <https://www.php.net/manual/en/reserved.classes.php>
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ], v = {
        keyword: b,
        literal: ((we) => {
          const fe = [];
          return we.forEach((he) => {
            fe.push(he), he.toLowerCase() === he ? fe.push(he.toUpperCase()) : fe.push(he.toLowerCase());
          }), fe;
        })(g),
        built_in: w
      }, T = (we) => we.map((fe) => fe.replace(/\|\d+$/, "")), S = { variants: [
        {
          match: [
            /new/,
            e.concat(f, "+"),
            // to prevent built ins from being confused as the class constructor call
            e.concat("(?!", T(w).join("\\b|"), "\\b)"),
            o
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] }, z = e.concat(r, "\\b(?!\\()"), U = { variants: [
        {
          match: [
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            z
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            o,
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            z
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            o,
            e.concat(
              "::",
              e.lookahead(/(?!class\b)/)
            )
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            o,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] }, B = {
        scope: "attr",
        match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
      }, q = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: [
          B,
          s,
          U,
          n3.C_BLOCK_COMMENT_MODE,
          h2,
          m,
          S
        ]
      }, oe = {
        relevance: 0,
        match: [
          /\b/,
          // to prevent keywords from being confused as the function title
          e.concat("(?!fn\\b|function\\b|", T(b).join("\\b|"), "|", T(w).join("\\b|"), "\\b)"),
          r,
          e.concat(f, "*"),
          e.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [q]
      };
      q.contains.push(oe);
      const de = [
        B,
        U,
        n3.C_BLOCK_COMMENT_MODE,
        h2,
        m,
        S
      ], ke = {
        begin: e.concat(
          /#\[\s*\\?/,
          e.either(
            o,
            i
          )
        ),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: g,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: g,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...de
            ]
          },
          ...de,
          {
            scope: "meta",
            variants: [
              { match: o },
              { match: i }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: v,
        contains: [
          ke,
          n3.HASH_COMMENT_MODE,
          n3.COMMENT("//", "$"),
          n3.COMMENT(
            "/\\*",
            "\\*/",
            { contains: [
              {
                scope: "doctag",
                match: "@[A-Za-z]+"
              }
            ] }
          ),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: n3.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          a,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          s,
          oe,
          U,
          {
            match: [
              /const/,
              /\s/,
              r
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          S,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              n3.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                // No markup, just a relevance booster
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: v,
                contains: [
                  "self",
                  ke,
                  s,
                  U,
                  n3.C_BLOCK_COMMENT_MODE,
                  h2,
                  m
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              n3.UNDERSCORE_TITLE_MODE
            ]
          },
          // both use and namespace still use "old style" rules (vs multi-match)
          // because the namespace name can include `\` and we still want each
          // element to be treated as its own *individual* title
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [n3.inherit(n3.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              // TODO: title.function vs title.class
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              // TODO: could be title.class or title.function
              n3.UNDERSCORE_TITLE_MODE
            ]
          },
          h2,
          m
        ]
      };
    }
    function WO(n3) {
      return {
        name: "PHP template",
        subLanguage: "xml",
        contains: [
          {
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [
              // We don't want the php closing tag ?> to close the PHP block when
              // inside any of the following blocks:
              {
                begin: "/\\*",
                end: "\\*/",
                skip: true
              },
              {
                begin: 'b"',
                end: '"',
                skip: true
              },
              {
                begin: "b'",
                end: "'",
                skip: true
              },
              n3.inherit(n3.APOS_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              }),
              n3.inherit(n3.QUOTE_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              })
            ]
          }
        ]
      };
    }
    function qO(n3) {
      return {
        name: "Plain text",
        aliases: [
          "text",
          "txt"
        ],
        disableAutodetect: true
      };
    }
    function KO(n3) {
      const e = n3.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ], a = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: r,
        built_in: [
          "__import__",
          "abs",
          "all",
          "any",
          "ascii",
          "bin",
          "bool",
          "breakpoint",
          "bytearray",
          "bytes",
          "callable",
          "chr",
          "classmethod",
          "compile",
          "complex",
          "delattr",
          "dict",
          "dir",
          "divmod",
          "enumerate",
          "eval",
          "exec",
          "filter",
          "float",
          "format",
          "frozenset",
          "getattr",
          "globals",
          "hasattr",
          "hash",
          "help",
          "hex",
          "id",
          "input",
          "int",
          "isinstance",
          "issubclass",
          "iter",
          "len",
          "list",
          "locals",
          "map",
          "max",
          "memoryview",
          "min",
          "next",
          "object",
          "oct",
          "open",
          "ord",
          "pow",
          "print",
          "property",
          "range",
          "repr",
          "reversed",
          "round",
          "set",
          "setattr",
          "slice",
          "sorted",
          "staticmethod",
          "str",
          "sum",
          "super",
          "tuple",
          "type",
          "vars",
          "zip"
        ],
        literal: [
          "__debug__",
          "Ellipsis",
          "False",
          "None",
          "NotImplemented",
          "True"
        ],
        type: [
          "Any",
          "Callable",
          "Coroutine",
          "Dict",
          "List",
          "Literal",
          "Generic",
          "Optional",
          "Sequence",
          "Set",
          "Tuple",
          "Type",
          "Union"
        ]
      }, l = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      }, c2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: a,
        illegal: /#/
      }, u = {
        begin: /\{\{/,
        relevance: 0
      }, d = {
        className: "string",
        contains: [n3.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              l,
              u,
              c2
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              n3.BACKSLASH_ESCAPE,
              u,
              c2
            ]
          },
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE
        ]
      }, p2 = "[0-9](_?[0-9])*", f = `(\\b(${p2}))?\\.(${p2})|\\b(${p2})\\.`, h2 = `\\b|${r.join("|")}`, m = {
        className: "number",
        relevance: 0,
        variants: [
          // exponentfloat, pointfloat
          // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
          // optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          // Note: no leading \b because floats can start with a decimal point
          // and we don't want to mishandle e.g. `fn(.5)`,
          // no trailing \b for pointfloat because it can end with a decimal point
          // and we don't want to mishandle e.g. `0..hex()`; this should be safe
          // because both MUST contain a decimal point and so cannot be confused with
          // the interior part of an identifier
          {
            begin: `(\\b(${p2})|(${f}))[eE][+-]?(${p2})[jJ]?(?=${h2})`
          },
          {
            begin: `(${f})[jJ]?`
          },
          // decinteger, bininteger, octinteger, hexinteger
          // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
          // optionally "long" in Python 2
          // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
          // decinteger is optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h2})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${h2})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h2})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h2})`
          },
          // imagnumber (digitpart-based)
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b(${p2})[jJ](?=${h2})`
          }
        ]
      }, g = {
        className: "comment",
        begin: e.lookahead(/# type:/),
        end: /$/,
        keywords: a,
        contains: [
          {
            // prevent keywords from coloring `type`
            begin: /# type:/
          },
          // comment within a datatype comment includes no keywords
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      }, b = {
        className: "params",
        variants: [
          // Exclude params in functions without params
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: a,
            contains: [
              "self",
              l,
              m,
              d,
              n3.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      return c2.contains = [
        d,
        m,
        l
      ], {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: a,
        illegal: /(<\/|\?)|=>/,
        contains: [
          l,
          m,
          {
            // very common convention
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            // eat "if" prior to string so that it won't accidentally be
            // labeled as an f-string
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          d,
          g,
          n3.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              t
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [b]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  t,
                  /\s*/,
                  /\(\s*/,
                  t,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  t
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              m,
              b,
              d
            ]
          }
        ]
      };
    }
    function GO(n3) {
      return {
        aliases: ["pycon"],
        contains: [
          {
            className: "meta.prompt",
            starts: {
              // a space separates the REPL prefix from the actual code
              // this is purely for cleaner HTML output
              end: / |$/,
              starts: {
                end: "$",
                subLanguage: "python"
              }
            },
            variants: [
              { begin: /^>>>(?=[ ]|$)/ },
              { begin: /^\.\.\.(?=[ ]|$)/ }
            ]
          }
        ]
      };
    }
    function jO(n3) {
      const e = n3.regex, t = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(
        // Special case: only hexadecimal binary powers can contain fractions
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        // Hexadecimal numbers without fraction and optional binary power
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        // Decimal numbers
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ), o = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, i = e.either(
        /[()]/,
        /[{}]/,
        /\[\[/,
        /[[\]]/,
        /\\/,
        /,/
      );
      return {
        name: "R",
        keywords: {
          $pattern: t,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: (
            // Builtin constants
            "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          )
        },
        contains: [
          // Roxygen comments
          n3.COMMENT(
            /#'/,
            /$/,
            { contains: [
              {
                // Handle `@examples` separately to cause all subsequent code
                // until the next `@`-tag on its own line to be kept as-is,
                // preventing highlighting. This code is example R code, so nested
                // doctags shouldnt be treated as such. See
                // `test/markup/r/roxygen.txt` for an example.
                scope: "doctag",
                match: /@examples/,
                starts: {
                  end: e.lookahead(e.either(
                    // end if another doc comment
                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                    // or a line with no comment
                    /\n^(?!#')/
                  )),
                  endsParent: true
                }
              },
              {
                // Handle `@param` to highlight the parameter name following
                // after.
                scope: "doctag",
                begin: "@param",
                end: /$/,
                contains: [
                  {
                    scope: "variable",
                    variants: [
                      { match: t },
                      { match: /`(?:\\.|[^`\\])+`/ }
                    ],
                    endsParent: true
                  }
                ]
              },
              {
                scope: "doctag",
                match: /@[a-zA-Z]+/
              },
              {
                scope: "keyword",
                match: /\\[a-zA-Z]+/
              }
            ] }
          ),
          n3.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [n3.BACKSLASH_ESCAPE],
            variants: [
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              n3.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          // Matching numbers immediately following punctuation and operators is
          // tricky since we need to look at the character ahead of a number to
          // ensure the number is not part of an identifier, and we cannot use
          // negative look-behind assertions. So instead we explicitly handle all
          // possible combinations of (operator|punctuation), number.
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  o,
                  r
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  r
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  i,
                  r
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  // not part of an identifier, or start of document
                  r
                ]
              }
            ]
          },
          // Operators/punctuation when they're not directly followed by numbers
          {
            // Relevance boost for the most common assignment form.
            scope: { 3: "operator" },
            match: [
              t,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: o },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: i
          },
          {
            // Escaped identifier
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    function JO(n3) {
      const e = n3.regex, t = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
        /\b([A-Z]+[a-z0-9]+)+/,
        // ends in caps
        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
      ), o = e.concat(r, /(::\w+)*/), s = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...[
            "include",
            "extend",
            "prepend",
            "public",
            "private",
            "protected",
            "raise",
            "throw"
          ]
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      }, a = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      }, l = {
        begin: "#<",
        end: ">"
      }, c2 = [
        n3.COMMENT(
          "#",
          "$",
          { contains: [a] }
        ),
        n3.COMMENT(
          "^=begin",
          "^=end",
          {
            contains: [a],
            relevance: 10
          }
        ),
        n3.COMMENT("^__END__", n3.MATCH_NOTHING_RE)
      ], u = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: s
      }, d = {
        className: "string",
        contains: [
          n3.BACKSLASH_ESCAPE,
          u
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
          // where ? is the last character of a preceding identifier, as in: `func?4`
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          // heredocs
          {
            // this guard makes sure that we have an entire heredoc and not a false
            // positive (auto-detect, etc.)
            begin: e.concat(
              /<<[-~]?'?/,
              e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
            ),
            contains: [
              n3.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  n3.BACKSLASH_ESCAPE,
                  u
                ]
              })
            ]
          }
        ]
      }, p2 = "[1-9](_?[0-9])*|0", f = "[0-9](_?[0-9])*", h2 = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal integer/float, optionally exponential or rational, optionally imaginary
          { begin: `\\b(${p2})(\\.(${f}))?([eE][+-]?(${f})|r)?i?\\b` },
          // explicit decimal/binary/octal/hexadecimal integer,
          // optionally rational and/or imaginary
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          // 0-prefixed implicit octal integer, optionally rational and/or imaginary
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      }, m = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: s
          }
        ]
      }, S = [
        d,
        {
          variants: [
            {
              match: [
                /class\s+/,
                o,
                /\s+<\s+/,
                o
              ]
            },
            {
              match: [
                /\b(class|module)\s+/,
                o
              ]
            }
          ],
          scope: {
            2: "title.class",
            4: "title.class.inherited"
          },
          keywords: s
        },
        {
          match: [
            /(include|extend)\s+/,
            o
          ],
          scope: {
            2: "title.class"
          },
          keywords: s
        },
        {
          relevance: 0,
          match: [
            o,
            /\.new[. (]/
          ],
          scope: {
            1: "title.class"
          }
        },
        {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        },
        {
          relevance: 0,
          match: r,
          scope: "title.class"
        },
        {
          match: [
            /def/,
            /\s+/,
            t
          ],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [
            m
          ]
        },
        {
          // swallow namespace qualifiers before symbols
          begin: n3.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: n3.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            d,
            { begin: t }
          ],
          relevance: 0
        },
        h2,
        {
          // negative-look forward attempts to prevent false matches like:
          // @ident@ or $ident$ that might indicate this is not ruby at all
          className: "variable",
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          // this could be a lot of things (in other languages) other than params
          keywords: s
        },
        {
          // regexp container
          begin: "(" + n3.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                n3.BACKSLASH_ESCAPE,
                u
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(l, c2),
          relevance: 0
        }
      ].concat(l, c2);
      u.contains = S, m.contains = S;
      const q = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: S
          }
        },
        {
          className: "meta.prompt",
          begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
          starts: {
            end: "$",
            keywords: s,
            contains: S
          }
        }
      ];
      return c2.unshift(l), {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: s,
        illegal: /\/\*/,
        contains: [n3.SHEBANG({ binary: "ruby" })].concat(q).concat(c2).concat(S)
      };
    }
    function YO(n3) {
      const e = n3.regex, t = /(r#)?/, r = e.concat(t, n3.UNDERSCORE_IDENT_RE), o = e.concat(t, n3.IDENT_RE), i = {
        className: "title.function.invoke",
        relevance: 0,
        begin: e.concat(
          /\b/,
          /(?!let|for|while|if|else|match\b)/,
          o,
          e.lookahead(/\s*\(/)
        )
      }, s = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ], l = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ], c2 = [
        // functions
        "drop ",
        // traits
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        // macros
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ], u = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: n3.IDENT_RE + "!?",
          type: u,
          keyword: a,
          literal: l,
          built_in: c2
        },
        illegal: "</",
        contains: [
          n3.C_LINE_COMMENT_MODE,
          n3.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          n3.inherit(n3.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            // negative lookahead to avoid matching `'`
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + s },
              { begin: "\\b0o([0-7_]+)" + s },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  n3.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              r
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          // must come before impl/for rule later
          {
            begin: [
              /for/,
              /\s+/,
              r,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              r
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: n3.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: c2,
              type: u
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          i
        ]
      };
    }
    const XO = (n3) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n3.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n3.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), ZO = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], QO = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], eN = [
      ...ZO,
      ...QO
    ], tN = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), nN = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), rN = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), oN = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function iN(n3) {
      const e = XO(n3), t = rN, r = nN, o = "@[a-z-]+", i = "and or not only", a = {
        className: "variable",
        begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [
          n3.C_LINE_COMMENT_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          e.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          },
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-tag",
            begin: "\\b(" + eN.join("|") + ")\\b",
            // was there, before, but why?
            relevance: 0
          },
          {
            className: "selector-pseudo",
            begin: ":(" + r.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + t.join("|") + ")"
          },
          a,
          {
            // pseudo-selector params
            begin: /\(/,
            end: /\)/,
            contains: [e.CSS_NUMBER_MODE]
          },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + oN.join("|") + ")\\b"
          },
          { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
          {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [
              e.BLOCK_COMMENT,
              a,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE,
              n3.QUOTE_STRING_MODE,
              n3.APOS_STRING_MODE,
              e.IMPORTANT,
              e.FUNCTION_DISPATCH
            ]
          },
          // matching these here allows us to treat them more like regular CSS
          // rules so everything between the {} gets regular rule highlighting,
          // which is what we want for page and font-face
          {
            begin: "@(page|font-face)",
            keywords: {
              $pattern: o,
              keyword: "@page @font-face"
            }
          },
          {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: tN.join(" ")
            },
            contains: [
              {
                begin: o,
                className: "keyword"
              },
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              a,
              n3.QUOTE_STRING_MODE,
              n3.APOS_STRING_MODE,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE
            ]
          },
          e.FUNCTION_DISPATCH
        ]
      };
    }
    function sN(n3) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
            // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
            // echo /path/to/home > t.exe
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    function aN(n3) {
      const e = n3.regex, t = n3.COMMENT("--", "$"), r = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      }, o = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      }, i = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ], s = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ], a = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        // modifier (character varying)
        "varbinary"
      ], l = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ], c2 = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ], u = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ], d = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ], p2 = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ], f = u, h2 = [
        ...c2,
        ...l
      ].filter((T) => !u.includes(T)), m = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      }, g = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      }, b = {
        match: e.concat(/\b/, e.either(...f), /\s*\(/),
        relevance: 0,
        keywords: { built_in: f }
      };
      function w(T) {
        return e.concat(
          /\b/,
          e.either(...T.map((S) => S.replace(/\s+/, "\\s+"))),
          /\b/
        );
      }
      const _ = {
        scope: "keyword",
        match: w(p2),
        relevance: 0
      };
      function v(T, {
        exceptions: S,
        when: z
      } = {}) {
        const U = z;
        return S = S || [], T.map((B) => B.match(/\|\d+$/) || S.includes(B) ? B : U(B) ? `${B}|0` : B);
      }
      return {
        name: "SQL",
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: v(h2, { when: (T) => T.length < 3 }),
          literal: i,
          type: a,
          built_in: d
        },
        contains: [
          {
            scope: "type",
            match: w(s)
          },
          _,
          b,
          m,
          r,
          o,
          n3.C_NUMBER_MODE,
          n3.C_BLOCK_COMMENT_MODE,
          t,
          g
        ]
      };
    }
    function Vg(n3) {
      return n3 ? typeof n3 == "string" ? n3 : n3.source : null;
    }
    function si(n3) {
      return je("(?=", n3, ")");
    }
    function je(...n3) {
      return n3.map((t) => Vg(t)).join("");
    }
    function lN(n3) {
      const e = n3[n3.length - 1];
      return typeof e == "object" && e.constructor === Object ? (n3.splice(n3.length - 1, 1), e) : {};
    }
    function jt(...n3) {
      return "(" + (lN(n3).capture ? "" : "?:") + n3.map((r) => Vg(r)).join("|") + ")";
    }
    const Wu = (n3) => je(
      /\b/,
      n3,
      /\w$/.test(n3) ? /\b/ : /\B/
    ), cN = [
      "Protocol",
      // contextual
      "Type"
      // contextual
    ].map(Wu), of = [
      "init",
      "self"
    ].map(Wu), uN = [
      "Any",
      "Self"
    ], Gl = [
      // strings below will be fed into the regular `keywords` engine while regex
      // will result in additional modes being created to scan for those keywords to
      // avoid conflicts with other rules
      "actor",
      "any",
      // contextual
      "associatedtype",
      "async",
      "await",
      /as\?/,
      // operator
      /as!/,
      // operator
      "as",
      // operator
      "borrowing",
      // contextual
      "break",
      "case",
      "catch",
      "class",
      "consume",
      // contextual
      "consuming",
      // contextual
      "continue",
      "convenience",
      // contextual
      "copy",
      // contextual
      "default",
      "defer",
      "deinit",
      "didSet",
      // contextual
      "distributed",
      "do",
      "dynamic",
      // contextual
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      // contextual
      "for",
      "func",
      "get",
      // contextual
      "guard",
      "if",
      "import",
      "indirect",
      // contextual
      "infix",
      // contextual
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      // operator
      "isolated",
      // contextual
      "nonisolated",
      // contextual
      "lazy",
      // contextual
      "let",
      "macro",
      "mutating",
      // contextual
      "nonmutating",
      // contextual
      /open\(set\)/,
      // contextual
      "open",
      // contextual
      "operator",
      "optional",
      // contextual
      "override",
      // contextual
      "package",
      "postfix",
      // contextual
      "precedencegroup",
      "prefix",
      // contextual
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      // contextual
      "rethrows",
      "return",
      "set",
      // contextual
      "some",
      // contextual
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      // operator
      /try!/,
      // operator
      "try",
      // operator
      "typealias",
      /unowned\(safe\)/,
      // contextual
      /unowned\(unsafe\)/,
      // contextual
      "unowned",
      // contextual
      "var",
      "weak",
      // contextual
      "where",
      "while",
      "willSet"
      // contextual
    ], sf = [
      "false",
      "nil",
      "true"
    ], dN = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ], pN = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ], af = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ], Wg = jt(
      /[/=\-+!*%<>&|^~?]/,
      /[\u00A1-\u00A7]/,
      /[\u00A9\u00AB]/,
      /[\u00AC\u00AE]/,
      /[\u00B0\u00B1]/,
      /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
      /[\u2016-\u2017]/,
      /[\u2020-\u2027]/,
      /[\u2030-\u203E]/,
      /[\u2041-\u2053]/,
      /[\u2055-\u205E]/,
      /[\u2190-\u23FF]/,
      /[\u2500-\u2775]/,
      /[\u2794-\u2BFF]/,
      /[\u2E00-\u2E7F]/,
      /[\u3001-\u3003]/,
      /[\u3008-\u3020]/,
      /[\u3030]/
    ), qg = jt(
      Wg,
      /[\u0300-\u036F]/,
      /[\u1DC0-\u1DFF]/,
      /[\u20D0-\u20FF]/,
      /[\uFE00-\uFE0F]/,
      /[\uFE20-\uFE2F]/
      // TODO: The following characters are also allowed, but the regex isn't supported yet.
      // /[\u{E0100}-\u{E01EF}]/u
    ), jl = je(Wg, qg, "*"), Kg = jt(
      /[a-zA-Z_]/,
      /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
      /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
      /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
      /[\u1E00-\u1FFF]/,
      /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
      /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
      /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
      /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
      /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
      /[\uFE47-\uFEFE\uFF00-\uFFFD]/
      // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
      // The following characters are also allowed, but the regexes aren't supported yet.
      // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
      // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
      // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
      // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
    ), ya = jt(
      Kg,
      /\d/,
      /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
    ), Un = je(Kg, ya, "*"), Ns = je(/[A-Z]/, ya, "*"), fN = [
      "attached",
      "autoclosure",
      je(/convention\(/, jt("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      je(/objc\(/, Un, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ], hN = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function mN(n3) {
      const e = {
        match: /\s+/,
        relevance: 0
      }, t = n3.COMMENT(
        "/\\*",
        "\\*/",
        { contains: ["self"] }
      ), r = [
        n3.C_LINE_COMMENT_MODE,
        t
      ], o = {
        match: [
          /\./,
          jt(...cN, ...of)
        ],
        className: { 2: "keyword" }
      }, i = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: je(/\./, jt(...Gl)),
        relevance: 0
      }, s = Gl.filter((ve) => typeof ve == "string").concat(["_|0"]), a = Gl.filter((ve) => typeof ve != "string").concat(uN).map(Wu), l = { variants: [
        {
          className: "keyword",
          match: jt(...a, ...of)
        }
      ] }, c2 = {
        $pattern: jt(
          /\b\w+/,
          // regular keywords
          /#\w+/
          // number keywords
        ),
        keyword: s.concat(pN),
        literal: sf
      }, u = [
        o,
        i,
        l
      ], d = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: je(/\./, jt(...af)),
        relevance: 0
      }, p2 = {
        className: "built_in",
        match: je(/\b/, jt(...af), /(?=\()/)
      }, f = [
        d,
        p2
      ], h2 = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
      }, m = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: jl },
          {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: `\\.(\\.|${qg})+`
          }
        ]
      }, g = [
        h2,
        m
      ], b = "([0-9]_*)+", w = "([0-9a-fA-F]_*)+", _ = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal floating-point-literal (subsumes decimal-literal)
          { match: `\\b(${b})(\\.(${b}))?([eE][+-]?(${b}))?\\b` },
          // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
          { match: `\\b0x(${w})(\\.(${w}))?([pP][+-]?(${b}))?\\b` },
          // octal-literal
          { match: /\b0o([0-7]_*)+\b/ },
          // binary-literal
          { match: /\b0b([01]_*)+\b/ }
        ]
      }, v = (ve = "") => ({
        className: "subst",
        variants: [
          { match: je(/\\/, ve, /[0\\tnr"']/) },
          { match: je(/\\/, ve, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      }), T = (ve = "") => ({
        className: "subst",
        match: je(/\\/, ve, /[\t ]*(?:[\r\n]|\r\n)/)
      }), S = (ve = "") => ({
        className: "subst",
        label: "interpol",
        begin: je(/\\/, ve, /\(/),
        end: /\)/
      }), z = (ve = "") => ({
        begin: je(ve, /"""/),
        end: je(/"""/, ve),
        contains: [
          v(ve),
          T(ve),
          S(ve)
        ]
      }), U = (ve = "") => ({
        begin: je(ve, /"/),
        end: je(/"/, ve),
        contains: [
          v(ve),
          S(ve)
        ]
      }), B = {
        className: "string",
        variants: [
          z(),
          z("#"),
          z("##"),
          z("###"),
          U(),
          U("#"),
          U("##"),
          U("###")
        ]
      }, q = [
        n3.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [n3.BACKSLASH_ESCAPE]
        }
      ], oe = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: q
      }, de = (ve) => {
        const Qt = je(ve, /\//), Pt = je(/\//, ve);
        return {
          begin: Qt,
          end: Pt,
          contains: [
            ...q,
            {
              scope: "comment",
              begin: `#(?!.*${Pt})`,
              end: /$/
            }
          ]
        };
      }, ke = {
        scope: "regexp",
        variants: [
          de("###"),
          de("##"),
          de("#"),
          oe
        ]
      }, we = { match: je(/`/, Un, /`/) }, fe = {
        className: "variable",
        match: /\$\d+/
      }, he = {
        className: "variable",
        match: `\\$${ya}+`
      }, M = [
        we,
        fe,
        he
      ], L = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: hN,
            contains: [
              ...g,
              _,
              B
            ]
          }
        ] }
      }, J = {
        scope: "keyword",
        match: je(/@/, jt(...fN), si(jt(/\(/, /\s+/)))
      }, re = {
        scope: "meta",
        match: je(/@/, Un)
      }, ce = [
        L,
        J,
        re
      ], Se = {
        match: si(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            // Common Apple frameworks, for relevance boost
            className: "type",
            match: je(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, ya, "+")
          },
          {
            // Type identifier
            className: "type",
            match: Ns,
            relevance: 0
          },
          {
            // Optional type
            match: /[?!]+/,
            relevance: 0
          },
          {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
          },
          {
            // Protocol composition
            match: je(/\s+&\s+/, si(Ns)),
            relevance: 0
          }
        ]
      }, Fe = {
        begin: /</,
        end: />/,
        keywords: c2,
        contains: [
          ...r,
          ...u,
          ...ce,
          h2,
          Se
        ]
      };
      Se.contains.push(Fe);
      const kt = {
        match: je(Un, /\s*:/),
        keywords: "_|0",
        relevance: 0
      }, ze = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: c2,
        contains: [
          "self",
          kt,
          ...r,
          ke,
          ...u,
          ...f,
          ...g,
          _,
          B,
          ...M,
          ...ce,
          Se
        ]
      }, et = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...r,
          Se
        ]
      }, an = {
        begin: jt(
          si(je(Un, /\s*:/)),
          si(je(Un, /\s+/, Un, /\s*:/))
        ),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: Un
          }
        ]
      }, Tt = {
        begin: /\(/,
        end: /\)/,
        keywords: c2,
        contains: [
          an,
          ...r,
          ...u,
          ...g,
          _,
          B,
          ...ce,
          Se,
          ze
        ],
        endsParent: true,
        illegal: /["']/
      }, gn = {
        match: [
          /(func|macro)/,
          /\s+/,
          jt(we.match, Un, jl)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          et,
          Tt,
          e
        ],
        illegal: [
          /\[/,
          /%/
        ]
      }, Ot = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          et,
          Tt,
          e
        ],
        illegal: /\[|%/
      }, bn = {
        match: [
          /operator/,
          /\s+/,
          jl
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      }, Fn = {
        begin: [
          /precedencegroup/,
          /\s+/,
          Ns
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [Se],
        keywords: [
          ...dN,
          ...sf
        ],
        end: /}/
      }, Mn = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      }, ln = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      }, An = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          Un,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: c2,
        contains: [
          et,
          ...u,
          {
            begin: /:/,
            end: /\{/,
            keywords: c2,
            contains: [
              {
                scope: "title.class.inherited",
                match: Ns
              },
              ...u
            ],
            relevance: 0
          }
        ]
      };
      for (const ve of B.variants) {
        const Qt = ve.contains.find((le) => le.label === "interpol");
        Qt.keywords = c2;
        const Pt = [
          ...u,
          ...f,
          ...g,
          _,
          B,
          ...M
        ];
        Qt.contains = [
          ...Pt,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...Pt
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: c2,
        contains: [
          ...r,
          gn,
          Ot,
          Mn,
          ln,
          An,
          bn,
          Fn,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...r],
            relevance: 0
          },
          ke,
          ...u,
          ...f,
          ...g,
          _,
          B,
          ...M,
          ...ce,
          Se,
          ze
        ]
      };
    }
    const va = "[A-Za-z$_][0-9A-Za-z$_]*", Gg = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], jg = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], Jg = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], Yg = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], Xg = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], Zg = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], Qg = [].concat(
      Xg,
      Jg,
      Yg
    );
    function gN(n3) {
      const e = n3.regex, t = (L, { after: J }) => {
        const re = "</" + L[0].slice(1);
        return L.input.indexOf(re, J) !== -1;
      }, r = va, o = {
        begin: "<>",
        end: "</>"
      }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, J) => {
          const re = L[0].length + L.index, ce = L.input[re];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ce === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ce === ","
          ) {
            J.ignoreMatch();
            return;
          }
          ce === ">" && (t(L, { after: re }) || J.ignoreMatch());
          let Se;
          const Fe = L.input.substring(re);
          if (Se = Fe.match(/^\s*=/)) {
            J.ignoreMatch();
            return;
          }
          if ((Se = Fe.match(/^\s+extends\s+/)) && Se.index === 0) {
            J.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: va,
        keyword: Gg,
        literal: jg,
        built_in: Qg,
        "variable.language": Zg
      }, l = "[0-9](_?[0-9])*", c2 = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${u})((${c2})|\\.)?|(${c2}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${u})\\b((${c2})\\b|\\.)?|(${c2})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, f = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, h2 = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, m = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n3.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, g = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          n3.BACKSLASH_ESCAPE,
          p2
        ]
      }, w = {
        className: "comment",
        variants: [
          n3.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: r + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          n3.C_BLOCK_COMMENT_MODE,
          n3.C_LINE_COMMENT_MODE
        ]
      }, _ = [
        n3.APOS_STRING_MODE,
        n3.QUOTE_STRING_MODE,
        f,
        h2,
        m,
        g,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = _.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(_)
      });
      const v = [].concat(w, p2.contains), T = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: T
      }, z = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              r,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(r, "(", e.concat(/\./, r), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              r
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, U = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...Jg,
            ...Yg
          ]
        }
      }, B = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, q = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              r,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, oe = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function de(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const ke = {
        match: e.concat(
          /\b/,
          de([
            ...Xg,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          r,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, we = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(r, /(?![0-9A-Za-z$_(])/)
        )),
        end: r,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, fe = {
        match: [
          /get|set/,
          /\s+/,
          r,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, he = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n3.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
        match: [
          /const|var|let/,
          /\s+/,
          r,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(he)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: T, CLASS_REFERENCE: U },
        illegal: /#(?![$_A-z])/,
        contains: [
          n3.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          B,
          n3.APOS_STRING_MODE,
          n3.QUOTE_STRING_MODE,
          f,
          h2,
          m,
          g,
          w,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          U,
          {
            scope: "attr",
            match: r + e.lookahead(":"),
            relevance: 0
          },
          M,
          {
            // "value" container
            begin: "(" + n3.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              w,
              n3.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: he,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: n3.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: T
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: o.begin, end: o.end },
                  { match: i },
                  {
                    begin: s.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": s.isTrulyOpeningTag,
                    end: s.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: s.begin,
                    end: s.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          q,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + n3.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              n3.inherit(n3.TITLE_MODE, { begin: r, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          we,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + r,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ke,
          oe,
          z,
          fe,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function bN(n3) {
      const e = n3.regex, t = gN(n3), r = va, o = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ], i = {
        begin: [
          /namespace/,
          /\s+/,
          n3.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      }, s = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: o
        },
        contains: [t.exports.CLASS_REFERENCE]
      }, a = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      }, l = [
        "type",
        // "namespace",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ], c2 = {
        $pattern: va,
        keyword: Gg.concat(l),
        literal: jg,
        built_in: Qg.concat(o),
        "variable.language": Zg
      }, u = {
        className: "meta",
        begin: "@" + r
      }, d = (m, g, b) => {
        const w = m.contains.findIndex((_) => _.label === g);
        if (w === -1)
          throw new Error("can not find mode to replace");
        m.contains.splice(w, 1, b);
      };
      Object.assign(t.keywords, c2), t.exports.PARAMS_CONTAINS.push(u);
      const p2 = t.contains.find((m) => m.scope === "attr"), f = Object.assign(
        {},
        p2,
        { match: e.concat(r, e.lookahead(/\s*\?:/)) }
      );
      t.exports.PARAMS_CONTAINS.push([
        t.exports.CLASS_REFERENCE,
        // class reference for highlighting the params types
        p2,
        // highlight the params key
        f
        // Added for optional property assignment highlighting
      ]), t.contains = t.contains.concat([
        u,
        i,
        s,
        f
        // Added for optional property assignment highlighting
      ]), d(t, "shebang", n3.SHEBANG()), d(t, "use_strict", a);
      const h2 = t.contains.find((m) => m.label === "func.def");
      return h2.relevance = 0, Object.assign(t, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      }), t;
    }
    function yN(n3) {
      const e = n3.regex, t = {
        className: "string",
        begin: /"(""|[^/n])"C\b/
      }, r = {
        className: "string",
        begin: /"/,
        end: /"/,
        illegal: /\n/,
        contains: [
          {
            // double quote escape
            begin: /""/
          }
        ]
      }, o = /\d{1,2}\/\d{1,2}\/\d{4}/, i = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
        className: "literal",
        variants: [
          {
            // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
            begin: e.concat(/# */, e.either(i, o), / *#/)
          },
          {
            // #H:mm[:ss]# (24h Time)
            begin: e.concat(/# */, a, / *#/)
          },
          {
            // #h[:mm[:ss]] A# (12h Time)
            begin: e.concat(/# */, s, / *#/)
          },
          {
            // date plus time
            begin: e.concat(
              /# */,
              e.either(i, o),
              / +/,
              e.either(s, a),
              / *#/
            )
          }
        ]
      }, c2 = {
        className: "number",
        relevance: 0,
        variants: [
          {
            // Float
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          },
          {
            // Integer (base 10)
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 16)
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 8)
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 2)
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }
        ]
      }, u = {
        className: "label",
        begin: /^\w+:/
      }, d = n3.COMMENT(/'''/, /$/, { contains: [
        {
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }
      ] }), p2 = n3.COMMENT(null, /$/, { variants: [
        { begin: /'/ },
        {
          // TODO: Use multi-class for leading spaces
          begin: /([\t ]|^)REM(?=\s)/
        }
      ] });
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: { label: "symbol" },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: (
            // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
            "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
          ),
          type: (
            // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
            "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
          ),
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [
          t,
          r,
          l,
          c2,
          u,
          d,
          p2,
          {
            className: "meta",
            // TODO: Use multi-class for indentation once available
            begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
            end: /$/,
            keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
            contains: [p2]
          }
        ]
      };
    }
    function vN(n3) {
      n3.regex;
      const e = n3.COMMENT(/\(;/, /;\)/);
      e.contains.push("self");
      const t = n3.COMMENT(/;;/, /$/), r = [
        "anyfunc",
        "block",
        "br",
        "br_if",
        "br_table",
        "call",
        "call_indirect",
        "data",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "func",
        "global.get",
        "global.set",
        "local.get",
        "local.set",
        "local.tee",
        "get_global",
        "get_local",
        "global",
        "if",
        "import",
        "local",
        "loop",
        "memory",
        "memory.grow",
        "memory.size",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "return",
        "select",
        "set_global",
        "set_local",
        "start",
        "table",
        "tee_local",
        "then",
        "type",
        "unreachable"
      ], o = {
        begin: [
          /(?:func|call|call_indirect)/,
          /\s+/,
          /\$[^\s)]+/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      }, i = {
        className: "variable",
        begin: /\$[\w_]+/
      }, s = {
        match: /(\((?!;)|\))+/,
        className: "punctuation",
        relevance: 0
      }, a = {
        className: "number",
        relevance: 0,
        // borrowed from Prism, TODO: split out into variants
        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
      }, l = {
        // look-ahead prevents us from gobbling up opcodes
        match: /(i32|i64|f32|f64)(?!\.)/,
        className: "type"
      }, c2 = {
        className: "keyword",
        // borrowed from Prism, TODO: split out into variants
        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
      };
      return {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: r
        },
        contains: [
          t,
          e,
          {
            match: [
              /(?:offset|align)/,
              /\s*/,
              /=/
            ],
            className: {
              1: "keyword",
              3: "operator"
            }
          },
          i,
          s,
          o,
          n3.QUOTE_STRING_MODE,
          l,
          c2,
          a
        ]
      };
    }
    function wN(n3) {
      const e = n3.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      }, i = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      }, s = n3.inherit(i, {
        begin: /\(/,
        end: /\)/
      }), a = n3.inherit(n3.APOS_STRING_MODE, { className: "string" }), l = n3.inherit(n3.QUOTE_STRING_MODE, { className: "string" }), c2 = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: r,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [o]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [o]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              i,
              l,
              a,
              s,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      i,
                      s,
                      l,
                      a
                    ]
                  }
                ]
              }
            ]
          },
          n3.COMMENT(
            /<!--/,
            /-->/,
            { relevance: 10 }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          o,
          // xml processing instructions
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  l
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending bracket.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [c2],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [c2],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: e.concat(
              /</,
              e.lookahead(e.concat(
                t,
                // <tag/>
                // <tag>
                // <tag ...
                e.either(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: t,
                relevance: 0,
                starts: c2
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: e.concat(
              /<\//,
              e.lookahead(e.concat(
                t,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: t,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    function kN(n3) {
      const e = "true false yes no null", t = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
        className: "attr",
        variants: [
          // added brackets support and special char support
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets and special char support
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets and special char support
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      }, o = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      }, i = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      }, s = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          n3.BACKSLASH_ESCAPE,
          o
        ]
      }, a = n3.inherit(s, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] }), p2 = {
        className: "number",
        begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
      }, f = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: e,
        relevance: 0
      }, h2 = {
        begin: /\{/,
        end: /\}/,
        contains: [f],
        illegal: "\\n",
        relevance: 0
      }, m = {
        begin: "\\[",
        end: "\\]",
        contains: [f],
        illegal: "\\n",
        relevance: 0
      }, g = [
        r,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + t
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + t + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + t
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + t
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + n3.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + n3.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        n3.HASH_COMMENT_MODE,
        {
          beginKeywords: e,
          keywords: { literal: e }
        },
        p2,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: n3.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        h2,
        m,
        i,
        s
      ], b = [...g];
      return b.pop(), b.push(a), f.contains = b, {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: g
      };
    }
    const EN = {
      arduino: rO,
      bash: oO,
      c: iO,
      cpp: sO,
      csharp: aO,
      css: gO,
      diff: bO,
      go: yO,
      graphql: vO,
      ini: wO,
      java: kO,
      javascript: xO,
      json: TO,
      kotlin: NO,
      less: PO,
      lua: $O,
      makefile: FO,
      markdown: zO,
      objectivec: HO,
      perl: UO,
      php: VO,
      "php-template": WO,
      plaintext: qO,
      python: KO,
      "python-repl": GO,
      r: jO,
      ruby: JO,
      rust: YO,
      scss: iN,
      shell: sN,
      sql: aN,
      swift: mN,
      typescript: bN,
      vbnet: yN,
      wasm: vN,
      xml: wN,
      yaml: kN
    };
    function _N(n3) {
      return n3 && n3.__esModule && Object.prototype.hasOwnProperty.call(n3, "default") ? n3.default : n3;
    }
    var Jl, lf;
    function SN() {
      if (lf) return Jl;
      lf = 1;
      function n3(k) {
        return k instanceof Map ? k.clear = k.delete = k.set = function() {
          throw new Error("map is read-only");
        } : k instanceof Set && (k.add = k.clear = k.delete = function() {
          throw new Error("set is read-only");
        }), Object.freeze(k), Object.getOwnPropertyNames(k).forEach((R) => {
          const W = k[R], me = typeof W;
          (me === "object" || me === "function") && !Object.isFrozen(W) && n3(W);
        }), k;
      }
      class e {
        /**
         * @param {CompiledMode} mode
         */
        constructor(R) {
          R.data === void 0 && (R.data = {}), this.data = R.data, this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function t(k) {
        return k.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function r(k, ...R) {
        const W = /* @__PURE__ */ Object.create(null);
        for (const me in k)
          W[me] = k[me];
        return R.forEach(function(me) {
          for (const ot in me)
            W[ot] = me[ot];
        }), /** @type {T} */
        W;
      }
      const o = "</span>", i = (k) => !!k.scope, s = (k, { prefix: R }) => {
        if (k.startsWith("language:"))
          return k.replace("language:", "language-");
        if (k.includes(".")) {
          const W = k.split(".");
          return [
            `${R}${W.shift()}`,
            ...W.map((me, ot) => `${me}${"_".repeat(ot + 1)}`)
          ].join(" ");
        }
        return `${R}${k}`;
      };
      class a {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(R, W) {
          this.buffer = "", this.classPrefix = W.classPrefix, R.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(R) {
          this.buffer += t(R);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(R) {
          if (!i(R)) return;
          const W = s(
            R.scope,
            { prefix: this.classPrefix }
          );
          this.span(W);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(R) {
          i(R) && (this.buffer += o);
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(R) {
          this.buffer += `<span class="${R}">`;
        }
      }
      const l = (k = {}) => {
        const R = { children: [] };
        return Object.assign(R, k), R;
      };
      class c2 {
        constructor() {
          this.rootNode = l(), this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(R) {
          this.top.children.push(R);
        }
        /** @param {string} scope */
        openNode(R) {
          const W = l({ scope: R });
          this.add(W), this.stack.push(W);
        }
        closeNode() {
          if (this.stack.length > 1)
            return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); ) ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(R) {
          return this.constructor._walk(R, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(R, W) {
          return typeof W == "string" ? R.addText(W) : W.children && (R.openNode(W), W.children.forEach((me) => this._walk(R, me)), R.closeNode(W)), R;
        }
        /**
         * @param {Node} node
         */
        static _collapse(R) {
          typeof R != "string" && R.children && (R.children.every((W) => typeof W == "string") ? R.children = [R.children.join("")] : R.children.forEach((W) => {
            c2._collapse(W);
          }));
        }
      }
      class u extends c2 {
        /**
         * @param {*} options
         */
        constructor(R) {
          super(), this.options = R;
        }
        /**
         * @param {string} text
         */
        addText(R) {
          R !== "" && this.add(R);
        }
        /** @param {string} scope */
        startScope(R) {
          this.openNode(R);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(R, W) {
          const me = R.root;
          W && (me.scope = `language:${W}`), this.add(me);
        }
        toHTML() {
          return new a(this, this.options).value();
        }
        finalize() {
          return this.closeAllNodes(), true;
        }
      }
      function d(k) {
        return k ? typeof k == "string" ? k : k.source : null;
      }
      function p2(k) {
        return m("(?=", k, ")");
      }
      function f(k) {
        return m("(?:", k, ")*");
      }
      function h2(k) {
        return m("(?:", k, ")?");
      }
      function m(...k) {
        return k.map((W) => d(W)).join("");
      }
      function g(k) {
        const R = k[k.length - 1];
        return typeof R == "object" && R.constructor === Object ? (k.splice(k.length - 1, 1), R) : {};
      }
      function b(...k) {
        return "(" + (g(k).capture ? "" : "?:") + k.map((me) => d(me)).join("|") + ")";
      }
      function w(k) {
        return new RegExp(k.toString() + "|").exec("").length - 1;
      }
      function _(k, R) {
        const W = k && k.exec(R);
        return W && W.index === 0;
      }
      const v = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function T(k, { joinWith: R }) {
        let W = 0;
        return k.map((me) => {
          W += 1;
          const ot = W;
          let tt = d(me), ee = "";
          for (; tt.length > 0; ) {
            const X = v.exec(tt);
            if (!X) {
              ee += tt;
              break;
            }
            ee += tt.substring(0, X.index), tt = tt.substring(X.index + X[0].length), X[0][0] === "\\" && X[1] ? ee += "\\" + String(Number(X[1]) + ot) : (ee += X[0], X[0] === "(" && W++);
          }
          return ee;
        }).map((me) => `(${me})`).join(R);
      }
      const S = /\b\B/, z = "[a-zA-Z]\\w*", U = "[a-zA-Z_]\\w*", B = "\\b\\d+(\\.\\d+)?", q = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", oe = "\\b(0b[01]+)", de = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ke = (k = {}) => {
        const R = /^#![ ]*\//;
        return k.binary && (k.begin = m(
          R,
          /.*\b/,
          k.binary,
          /\b.*/
        )), r({
          scope: "meta",
          begin: R,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (W, me) => {
            W.index !== 0 && me.ignoreMatch();
          }
        }, k);
      }, we = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      }, fe = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [we]
      }, he = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [we]
      }, M = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      }, L = function(k, R, W = {}) {
        const me = r(
          {
            scope: "comment",
            begin: k,
            end: R,
            contains: []
          },
          W
        );
        me.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ot = b(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        return me.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: m(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              ot,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        ), me;
      }, J = L("//", "$"), re = L("/\\*", "\\*/"), ce = L("#", "$"), Se = {
        scope: "number",
        begin: B,
        relevance: 0
      }, Fe = {
        scope: "number",
        begin: q,
        relevance: 0
      }, kt = {
        scope: "number",
        begin: oe,
        relevance: 0
      }, ze = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          we,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [we]
          }
        ]
      }, et = {
        scope: "title",
        begin: z,
        relevance: 0
      }, an = {
        scope: "title",
        begin: U,
        relevance: 0
      }, Tt = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + U,
        relevance: 0
      };
      var Ot = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: fe,
        BACKSLASH_ESCAPE: we,
        BINARY_NUMBER_MODE: kt,
        BINARY_NUMBER_RE: oe,
        COMMENT: L,
        C_BLOCK_COMMENT_MODE: re,
        C_LINE_COMMENT_MODE: J,
        C_NUMBER_MODE: Fe,
        C_NUMBER_RE: q,
        END_SAME_AS_BEGIN: function(k) {
          return Object.assign(
            k,
            {
              /** @type {ModeCallback} */
              "on:begin": (R, W) => {
                W.data._beginMatch = R[1];
              },
              /** @type {ModeCallback} */
              "on:end": (R, W) => {
                W.data._beginMatch !== R[1] && W.ignoreMatch();
              }
            }
          );
        },
        HASH_COMMENT_MODE: ce,
        IDENT_RE: z,
        MATCH_NOTHING_RE: S,
        METHOD_GUARD: Tt,
        NUMBER_MODE: Se,
        NUMBER_RE: B,
        PHRASAL_WORDS_MODE: M,
        QUOTE_STRING_MODE: he,
        REGEXP_MODE: ze,
        RE_STARTERS_RE: de,
        SHEBANG: ke,
        TITLE_MODE: et,
        UNDERSCORE_IDENT_RE: U,
        UNDERSCORE_TITLE_MODE: an
      });
      function bn(k, R) {
        k.input[k.index - 1] === "." && R.ignoreMatch();
      }
      function Fn(k, R) {
        k.className !== void 0 && (k.scope = k.className, delete k.className);
      }
      function Mn(k, R) {
        R && k.beginKeywords && (k.begin = "\\b(" + k.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", k.__beforeBegin = bn, k.keywords = k.keywords || k.beginKeywords, delete k.beginKeywords, k.relevance === void 0 && (k.relevance = 0));
      }
      function ln(k, R) {
        Array.isArray(k.illegal) && (k.illegal = b(...k.illegal));
      }
      function An(k, R) {
        if (k.match) {
          if (k.begin || k.end) throw new Error("begin & end are not supported with match");
          k.begin = k.match, delete k.match;
        }
      }
      function ve(k, R) {
        k.relevance === void 0 && (k.relevance = 1);
      }
      const Qt = (k, R) => {
        if (!k.beforeMatch) return;
        if (k.starts) throw new Error("beforeMatch cannot be used with starts");
        const W = Object.assign({}, k);
        Object.keys(k).forEach((me) => {
          delete k[me];
        }), k.keywords = W.keywords, k.begin = m(W.beforeMatch, p2(W.begin)), k.starts = {
          relevance: 0,
          contains: [
            Object.assign(W, { endsParent: true })
          ]
        }, k.relevance = 0, delete W.beforeMatch;
      }, Pt = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ], le = "keyword";
      function Wt(k, R, W = le) {
        const me = /* @__PURE__ */ Object.create(null);
        return typeof k == "string" ? ot(W, k.split(" ")) : Array.isArray(k) ? ot(W, k) : Object.keys(k).forEach(function(tt) {
          Object.assign(
            me,
            Wt(k[tt], R, tt)
          );
        }), me;
        function ot(tt, ee) {
          R && (ee = ee.map((X) => X.toLowerCase())), ee.forEach(function(X) {
            const ge = X.split("|");
            me[ge[0]] = [tt, Ke(ge[0], ge[1])];
          });
        }
      }
      function Ke(k, R) {
        return R ? Number(R) : Re(k) ? 0 : 1;
      }
      function Re(k) {
        return Pt.includes(k.toLowerCase());
      }
      const qt = {}, ft = (k) => {
        console.error(k);
      }, Rn = (k, ...R) => {
        console.log(`WARN: ${k}`, ...R);
      }, Kt = (k, R) => {
        qt[`${k}/${R}`] || (console.log(`Deprecated as of ${k}. ${R}`), qt[`${k}/${R}`] = true);
      }, V = new Error();
      function Y(k, R, { key: W }) {
        let me = 0;
        const ot = k[W], tt = {}, ee = {};
        for (let X = 1; X <= R.length; X++)
          ee[X + me] = ot[X], tt[X + me] = true, me += w(R[X - 1]);
        k[W] = ee, k[W]._emit = tt, k[W]._multi = true;
      }
      function Ee(k) {
        if (Array.isArray(k.begin)) {
          if (k.skip || k.excludeBegin || k.returnBegin)
            throw ft("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), V;
          if (typeof k.beginScope != "object" || k.beginScope === null)
            throw ft("beginScope must be object"), V;
          Y(k, k.begin, { key: "beginScope" }), k.begin = T(k.begin, { joinWith: "" });
        }
      }
      function Ie(k) {
        if (Array.isArray(k.end)) {
          if (k.skip || k.excludeEnd || k.returnEnd)
            throw ft("skip, excludeEnd, returnEnd not compatible with endScope: {}"), V;
          if (typeof k.endScope != "object" || k.endScope === null)
            throw ft("endScope must be object"), V;
          Y(k, k.end, { key: "endScope" }), k.end = T(k.end, { joinWith: "" });
        }
      }
      function gt(k) {
        k.scope && typeof k.scope == "object" && k.scope !== null && (k.beginScope = k.scope, delete k.scope);
      }
      function cn(k) {
        gt(k), typeof k.beginScope == "string" && (k.beginScope = { _wrap: k.beginScope }), typeof k.endScope == "string" && (k.endScope = { _wrap: k.endScope }), Ee(k), Ie(k);
      }
      function ti(k) {
        function R(ee, X) {
          return new RegExp(
            d(ee),
            "m" + (k.case_insensitive ? "i" : "") + (k.unicodeRegex ? "u" : "") + (X ? "g" : "")
          );
        }
        class W {
          constructor() {
            this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
          }
          // @ts-ignore
          addRule(X, ge) {
            ge.position = this.position++, this.matchIndexes[this.matchAt] = ge, this.regexes.push([ge, X]), this.matchAt += w(X) + 1;
          }
          compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            const X = this.regexes.map((ge) => ge[1]);
            this.matcherRe = R(T(X, { joinWith: "|" }), true), this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(X) {
            this.matcherRe.lastIndex = this.lastIndex;
            const ge = this.matcherRe.exec(X);
            if (!ge)
              return null;
            const _t = ge.findIndex((ri, pl) => pl > 0 && ri !== void 0), bt = this.matchIndexes[_t];
            return ge.splice(0, _t), Object.assign(ge, bt);
          }
        }
        class me {
          constructor() {
            this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(X) {
            if (this.multiRegexes[X]) return this.multiRegexes[X];
            const ge = new W();
            return this.rules.slice(X).forEach(([_t, bt]) => ge.addRule(_t, bt)), ge.compile(), this.multiRegexes[X] = ge, ge;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(X, ge) {
            this.rules.push([X, ge]), ge.type === "begin" && this.count++;
          }
          /** @param {string} s */
          exec(X) {
            const ge = this.getMatcher(this.regexIndex);
            ge.lastIndex = this.lastIndex;
            let _t = ge.exec(X);
            if (this.resumingScanAtSamePosition() && !(_t && _t.index === this.lastIndex)) {
              const bt = this.getMatcher(0);
              bt.lastIndex = this.lastIndex + 1, _t = bt.exec(X);
            }
            return _t && (this.regexIndex += _t.position + 1, this.regexIndex === this.count && this.considerAll()), _t;
          }
        }
        function ot(ee) {
          const X = new me();
          return ee.contains.forEach((ge) => X.addRule(ge.begin, { rule: ge, type: "begin" })), ee.terminatorEnd && X.addRule(ee.terminatorEnd, { type: "end" }), ee.illegal && X.addRule(ee.illegal, { type: "illegal" }), X;
        }
        function tt(ee, X) {
          const ge = (
            /** @type CompiledMode */
            ee
          );
          if (ee.isCompiled) return ge;
          [
            Fn,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            An,
            cn,
            Qt
          ].forEach((bt) => bt(ee, X)), k.compilerExtensions.forEach((bt) => bt(ee, X)), ee.__beforeBegin = null, [
            Mn,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            ln,
            // default to 1 relevance if not specified
            ve
          ].forEach((bt) => bt(ee, X)), ee.isCompiled = true;
          let _t = null;
          return typeof ee.keywords == "object" && ee.keywords.$pattern && (ee.keywords = Object.assign({}, ee.keywords), _t = ee.keywords.$pattern, delete ee.keywords.$pattern), _t = _t || /\w+/, ee.keywords && (ee.keywords = Wt(ee.keywords, k.case_insensitive)), ge.keywordPatternRe = R(_t, true), X && (ee.begin || (ee.begin = /\B|\b/), ge.beginRe = R(ge.begin), !ee.end && !ee.endsWithParent && (ee.end = /\B|\b/), ee.end && (ge.endRe = R(ge.end)), ge.terminatorEnd = d(ge.end) || "", ee.endsWithParent && X.terminatorEnd && (ge.terminatorEnd += (ee.end ? "|" : "") + X.terminatorEnd)), ee.illegal && (ge.illegalRe = R(
            /** @type {RegExp | string} */
            ee.illegal
          )), ee.contains || (ee.contains = []), ee.contains = [].concat(...ee.contains.map(function(bt) {
            return Q(bt === "self" ? ee : bt);
          })), ee.contains.forEach(function(bt) {
            tt(
              /** @type Mode */
              bt,
              ge
            );
          }), ee.starts && tt(ee.starts, X), ge.matcher = ot(ge), ge;
        }
        if (k.compilerExtensions || (k.compilerExtensions = []), k.contains && k.contains.includes("self"))
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return k.classNameAliases = r(k.classNameAliases || {}), tt(
          /** @type Mode */
          k
        );
      }
      function N(k) {
        return k ? k.endsWithParent || N(k.starts) : false;
      }
      function Q(k) {
        return k.variants && !k.cachedVariants && (k.cachedVariants = k.variants.map(function(R) {
          return r(k, { variants: null }, R);
        })), k.cachedVariants ? k.cachedVariants : N(k) ? r(k, { starts: k.starts ? r(k.starts) : null }) : Object.isFrozen(k) ? r(k) : k;
      }
      var pe = "11.11.1";
      class Pe extends Error {
        constructor(R, W) {
          super(R), this.name = "HTMLInjectionError", this.html = W;
        }
      }
      const Me = t, Et = r, Gt = Symbol("nomatch"), vr = 7, ni = function(k) {
        const R = /* @__PURE__ */ Object.create(null), W = /* @__PURE__ */ Object.create(null), me = [];
        let ot = true;
        const tt = "Could not find the language '{}', did you forget to load/include a language module?", ee = { disableAutodetect: true, name: "Plain text", contains: [] };
        let X = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: u
        };
        function ge(H) {
          return X.noHighlightRe.test(H);
        }
        function _t(H) {
          let se = H.className + " ";
          se += H.parentNode ? H.parentNode.className : "";
          const Ae = X.languageDetectRe.exec(se);
          if (Ae) {
            const nt = wr(Ae[1]);
            return nt || (Rn(tt.replace("{}", Ae[1])), Rn("Falling back to no-highlight mode for this block.", H)), nt ? Ae[1] : "no-highlight";
          }
          return se.split(/\s+/).find((nt) => ge(nt) || wr(nt));
        }
        function bt(H, se, Ae) {
          let nt = "", vt = "";
          typeof se == "object" ? (nt = H, Ae = se.ignoreIllegals, vt = se.language) : (Kt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Kt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), vt = H, nt = se), Ae === void 0 && (Ae = true);
          const In = {
            code: nt,
            language: vt
          };
          us("before:highlight", In);
          const kr = In.result ? In.result : ri(In.language, In.code, Ae);
          return kr.code = In.code, us("after:highlight", kr), kr;
        }
        function ri(H, se, Ae, nt) {
          const vt = /* @__PURE__ */ Object.create(null);
          function In(j, te) {
            return j.keywords[te];
          }
          function kr() {
            if (!_e.keywords) {
              Nt.addText(rt);
              return;
            }
            let j = 0;
            _e.keywordPatternRe.lastIndex = 0;
            let te = _e.keywordPatternRe.exec(rt), Oe = "";
            for (; te; ) {
              Oe += rt.substring(j, te.index);
              const Ve = Hn.case_insensitive ? te[0].toLowerCase() : te[0], $t = In(_e, Ve);
              if ($t) {
                const [nr, Ub] = $t;
                if (Nt.addText(Oe), Oe = "", vt[Ve] = (vt[Ve] || 0) + 1, vt[Ve] <= vr && (fs += Ub), nr.startsWith("_"))
                  Oe += te[0];
                else {
                  const Vb = Hn.classNameAliases[nr] || nr;
                  zn(te[0], Vb);
                }
              } else
                Oe += te[0];
              j = _e.keywordPatternRe.lastIndex, te = _e.keywordPatternRe.exec(rt);
            }
            Oe += rt.substring(j), Nt.addText(Oe);
          }
          function ds() {
            if (rt === "") return;
            let j = null;
            if (typeof _e.subLanguage == "string") {
              if (!R[_e.subLanguage]) {
                Nt.addText(rt);
                return;
              }
              j = ri(_e.subLanguage, rt, true, ld[_e.subLanguage]), ld[_e.subLanguage] = /** @type {CompiledMode} */
              j._top;
            } else
              j = fl(rt, _e.subLanguage.length ? _e.subLanguage : null);
            _e.relevance > 0 && (fs += j.relevance), Nt.__addSublanguage(j._emitter, j.language);
          }
          function un() {
            _e.subLanguage != null ? ds() : kr(), rt = "";
          }
          function zn(j, te) {
            j !== "" && (Nt.startScope(te), Nt.addText(j), Nt.endScope());
          }
          function od(j, te) {
            let Oe = 1;
            const Ve = te.length - 1;
            for (; Oe <= Ve; ) {
              if (!j._emit[Oe]) {
                Oe++;
                continue;
              }
              const $t = Hn.classNameAliases[j[Oe]] || j[Oe], nr = te[Oe];
              $t ? zn(nr, $t) : (rt = nr, kr(), rt = ""), Oe++;
            }
          }
          function id(j, te) {
            return j.scope && typeof j.scope == "string" && Nt.openNode(Hn.classNameAliases[j.scope] || j.scope), j.beginScope && (j.beginScope._wrap ? (zn(rt, Hn.classNameAliases[j.beginScope._wrap] || j.beginScope._wrap), rt = "") : j.beginScope._multi && (od(j.beginScope, te), rt = "")), _e = Object.create(j, { parent: { value: _e } }), _e;
          }
          function sd(j, te, Oe) {
            let Ve = _(j.endRe, Oe);
            if (Ve) {
              if (j["on:end"]) {
                const $t = new e(j);
                j["on:end"](te, $t), $t.isMatchIgnored && (Ve = false);
              }
              if (Ve) {
                for (; j.endsParent && j.parent; )
                  j = j.parent;
                return j;
              }
            }
            if (j.endsWithParent)
              return sd(j.parent, te, Oe);
          }
          function Pb(j) {
            return _e.matcher.regexIndex === 0 ? (rt += j[0], 1) : (bl = true, 0);
          }
          function $b(j) {
            const te = j[0], Oe = j.rule, Ve = new e(Oe), $t = [Oe.__beforeBegin, Oe["on:begin"]];
            for (const nr of $t)
              if (nr && (nr(j, Ve), Ve.isMatchIgnored))
                return Pb(te);
            return Oe.skip ? rt += te : (Oe.excludeBegin && (rt += te), un(), !Oe.returnBegin && !Oe.excludeBegin && (rt = te)), id(Oe, j), Oe.returnBegin ? 0 : te.length;
          }
          function Fb(j) {
            const te = j[0], Oe = se.substring(j.index), Ve = sd(_e, j, Oe);
            if (!Ve)
              return Gt;
            const $t = _e;
            _e.endScope && _e.endScope._wrap ? (un(), zn(te, _e.endScope._wrap)) : _e.endScope && _e.endScope._multi ? (un(), od(_e.endScope, j)) : $t.skip ? rt += te : ($t.returnEnd || $t.excludeEnd || (rt += te), un(), $t.excludeEnd && (rt = te));
            do
              _e.scope && Nt.closeNode(), !_e.skip && !_e.subLanguage && (fs += _e.relevance), _e = _e.parent;
            while (_e !== Ve.parent);
            return Ve.starts && id(Ve.starts, j), $t.returnEnd ? 0 : te.length;
          }
          function zb() {
            const j = [];
            for (let te = _e; te !== Hn; te = te.parent)
              te.scope && j.unshift(te.scope);
            j.forEach((te) => Nt.openNode(te));
          }
          let ps = {};
          function ad(j, te) {
            const Oe = te && te[0];
            if (rt += j, Oe == null)
              return un(), 0;
            if (ps.type === "begin" && te.type === "end" && ps.index === te.index && Oe === "") {
              if (rt += se.slice(te.index, te.index + 1), !ot) {
                const Ve = new Error(`0 width match regex (${H})`);
                throw Ve.languageName = H, Ve.badRule = ps.rule, Ve;
              }
              return 1;
            }
            if (ps = te, te.type === "begin")
              return $b(te);
            if (te.type === "illegal" && !Ae) {
              const Ve = new Error('Illegal lexeme "' + Oe + '" for mode "' + (_e.scope || "<unnamed>") + '"');
              throw Ve.mode = _e, Ve;
            } else if (te.type === "end") {
              const Ve = Fb(te);
              if (Ve !== Gt)
                return Ve;
            }
            if (te.type === "illegal" && Oe === "")
              return rt += `
`, 1;
            if (gl > 1e5 && gl > te.index * 3)
              throw new Error("potential infinite loop, way more iterations than matches");
            return rt += Oe, Oe.length;
          }
          const Hn = wr(H);
          if (!Hn)
            throw ft(tt.replace("{}", H)), new Error('Unknown language: "' + H + '"');
          const Hb = ti(Hn);
          let ml = "", _e = nt || Hb;
          const ld = {}, Nt = new X.__emitter(X);
          zb();
          let rt = "", fs = 0, Kr = 0, gl = 0, bl = false;
          try {
            if (Hn.__emitTokens)
              Hn.__emitTokens(se, Nt);
            else {
              for (_e.matcher.considerAll(); ; ) {
                gl++, bl ? bl = false : _e.matcher.considerAll(), _e.matcher.lastIndex = Kr;
                const j = _e.matcher.exec(se);
                if (!j) break;
                const te = se.substring(Kr, j.index), Oe = ad(te, j);
                Kr = j.index + Oe;
              }
              ad(se.substring(Kr));
            }
            return Nt.finalize(), ml = Nt.toHTML(), {
              language: H,
              value: ml,
              relevance: fs,
              illegal: false,
              _emitter: Nt,
              _top: _e
            };
          } catch (j) {
            if (j.message && j.message.includes("Illegal"))
              return {
                language: H,
                value: Me(se),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: j.message,
                  index: Kr,
                  context: se.slice(Kr - 100, Kr + 100),
                  mode: j.mode,
                  resultSoFar: ml
                },
                _emitter: Nt
              };
            if (ot)
              return {
                language: H,
                value: Me(se),
                illegal: false,
                relevance: 0,
                errorRaised: j,
                _emitter: Nt,
                _top: _e
              };
            throw j;
          }
        }
        function pl(H) {
          const se = {
            value: Me(H),
            illegal: false,
            relevance: 0,
            _top: ee,
            _emitter: new X.__emitter(X)
          };
          return se._emitter.addText(H), se;
        }
        function fl(H, se) {
          se = se || X.languages || Object.keys(R);
          const Ae = pl(H), nt = se.filter(wr).filter(rd).map(
            (un) => ri(un, H, false)
          );
          nt.unshift(Ae);
          const vt = nt.sort((un, zn) => {
            if (un.relevance !== zn.relevance) return zn.relevance - un.relevance;
            if (un.language && zn.language) {
              if (wr(un.language).supersetOf === zn.language)
                return 1;
              if (wr(zn.language).supersetOf === un.language)
                return -1;
            }
            return 0;
          }), [In, kr] = vt, ds = In;
          return ds.secondBest = kr, ds;
        }
        function xb(H, se, Ae) {
          const nt = se && W[se] || Ae;
          H.classList.add("hljs"), H.classList.add(`language-${nt}`);
        }
        function hl(H) {
          let se = null;
          const Ae = _t(H);
          if (ge(Ae)) return;
          if (us(
            "before:highlightElement",
            { el: H, language: Ae }
          ), H.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", H);
            return;
          }
          if (H.children.length > 0 && (X.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(H)), X.throwUnescapedHTML))
            throw new Pe(
              "One of your code blocks includes unescaped HTML.",
              H.innerHTML
            );
          se = H;
          const nt = se.textContent, vt = Ae ? bt(nt, { language: Ae, ignoreIllegals: true }) : fl(nt);
          H.innerHTML = vt.value, H.dataset.highlighted = "yes", xb(H, Ae, vt.language), H.result = {
            language: vt.language,
            // TODO: remove with version 11.0
            re: vt.relevance,
            relevance: vt.relevance
          }, vt.secondBest && (H.secondBest = {
            language: vt.secondBest.language,
            relevance: vt.secondBest.relevance
          }), us("after:highlightElement", { el: H, result: vt, text: nt });
        }
        function Tb(H) {
          X = Et(X, H);
        }
        const Ob = () => {
          cs(), Kt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function Nb() {
          cs(), Kt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let td = false;
        function cs() {
          function H() {
            cs();
          }
          if (document.readyState === "loading") {
            td || window.addEventListener("DOMContentLoaded", H, false), td = true;
            return;
          }
          document.querySelectorAll(X.cssSelector).forEach(hl);
        }
        function Mb(H, se) {
          let Ae = null;
          try {
            Ae = se(k);
          } catch (nt) {
            if (ft("Language definition for '{}' could not be registered.".replace("{}", H)), ot)
              ft(nt);
            else
              throw nt;
            Ae = ee;
          }
          Ae.name || (Ae.name = H), R[H] = Ae, Ae.rawDefinition = se.bind(null, k), Ae.aliases && nd(Ae.aliases, { languageName: H });
        }
        function Ab(H) {
          delete R[H];
          for (const se of Object.keys(W))
            W[se] === H && delete W[se];
        }
        function Rb() {
          return Object.keys(R);
        }
        function wr(H) {
          return H = (H || "").toLowerCase(), R[H] || R[W[H]];
        }
        function nd(H, { languageName: se }) {
          typeof H == "string" && (H = [H]), H.forEach((Ae) => {
            W[Ae.toLowerCase()] = se;
          });
        }
        function rd(H) {
          const se = wr(H);
          return se && !se.disableAutodetect;
        }
        function Ib(H) {
          H["before:highlightBlock"] && !H["before:highlightElement"] && (H["before:highlightElement"] = (se) => {
            H["before:highlightBlock"](
              Object.assign({ block: se.el }, se)
            );
          }), H["after:highlightBlock"] && !H["after:highlightElement"] && (H["after:highlightElement"] = (se) => {
            H["after:highlightBlock"](
              Object.assign({ block: se.el }, se)
            );
          });
        }
        function Db(H) {
          Ib(H), me.push(H);
        }
        function Lb(H) {
          const se = me.indexOf(H);
          se !== -1 && me.splice(se, 1);
        }
        function us(H, se) {
          const Ae = H;
          me.forEach(function(nt) {
            nt[Ae] && nt[Ae](se);
          });
        }
        function Bb(H) {
          return Kt("10.7.0", "highlightBlock will be removed entirely in v12.0"), Kt("10.7.0", "Please use highlightElement now."), hl(H);
        }
        Object.assign(k, {
          highlight: bt,
          highlightAuto: fl,
          highlightAll: cs,
          highlightElement: hl,
          // TODO: Remove with v12 API
          highlightBlock: Bb,
          configure: Tb,
          initHighlighting: Ob,
          initHighlightingOnLoad: Nb,
          registerLanguage: Mb,
          unregisterLanguage: Ab,
          listLanguages: Rb,
          getLanguage: wr,
          registerAliases: nd,
          autoDetection: rd,
          inherit: Et,
          addPlugin: Db,
          removePlugin: Lb
        }), k.debugMode = function() {
          ot = false;
        }, k.safeMode = function() {
          ot = true;
        }, k.versionString = pe, k.regex = {
          concat: m,
          lookahead: p2,
          either: b,
          optional: h2,
          anyNumberOfTimes: f
        };
        for (const H in Ot)
          typeof Ot[H] == "object" && n3(Ot[H]);
        return Object.assign(k, Ot), k;
      }, en = ni({});
      return en.newInstance = () => ni({}), Jl = en, en.HighlightJS = en, en.default = en, Jl;
    }
    var CN = /* @__PURE__ */ SN();
    const xN = /* @__PURE__ */ _N(CN), cf = {}, TN = "hljs-";
    function ON(n3) {
      const e = xN.newInstance();
      return n3 && i(n3), {
        highlight: t,
        highlightAuto: r,
        listLanguages: o,
        register: i,
        registerAlias: s,
        registered: a
      };
      function t(l, c2, u) {
        const d = u || cf, p2 = typeof d.prefix == "string" ? d.prefix : TN;
        if (!e.getLanguage(l))
          throw new Error("Unknown language: `" + l + "` is not registered");
        e.configure({ __emitter: NN, classPrefix: p2 });
        const f = (
          /** @type {HighlightResult & {_emitter: HastEmitter}} */
          e.highlight(c2, { ignoreIllegals: true, language: l })
        );
        if (f.errorRaised)
          throw new Error("Could not highlight with `Highlight.js`", {
            cause: f.errorRaised
          });
        const h2 = f._emitter.root, m = (
          /** @type {RootData} */
          h2.data
        );
        return m.language = f.language, m.relevance = f.relevance, h2;
      }
      function r(l, c2) {
        const d = (c2 || cf).subset || o();
        let p2 = -1, f = 0, h2;
        for (; ++p2 < d.length; ) {
          const m = d[p2];
          if (!e.getLanguage(m)) continue;
          const g = t(m, l, c2);
          g.data && g.data.relevance !== void 0 && g.data.relevance > f && (f = g.data.relevance, h2 = g);
        }
        return h2 || {
          type: "root",
          children: [],
          data: { language: void 0, relevance: f }
        };
      }
      function o() {
        return e.listLanguages();
      }
      function i(l, c2) {
        if (typeof l == "string")
          e.registerLanguage(l, c2);
        else {
          let u;
          for (u in l)
            Object.hasOwn(l, u) && e.registerLanguage(u, l[u]);
        }
      }
      function s(l, c2) {
        if (typeof l == "string")
          e.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof c2 == "string" ? c2 : [...c2],
            { languageName: l }
          );
        else {
          let u;
          for (u in l)
            if (Object.hasOwn(l, u)) {
              const d = l[u];
              e.registerAliases(
                // Note: copy needed because hljs doesnt accept readonly arrays yet.
                typeof d == "string" ? d : [...d],
                { languageName: u }
              );
            }
        }
      }
      function a(l) {
        return !!e.getLanguage(l);
      }
    }
    class NN {
      /**
       * @param {Readonly<HljsOptions>} options
       *   Configuration.
       * @returns
       *   Instance.
       */
      constructor(e) {
        this.options = e, this.root = {
          type: "root",
          children: [],
          data: { language: void 0, relevance: 0 }
        }, this.stack = [this.root];
      }
      /**
       * @param {string} value
       *   Text to add.
       * @returns {undefined}
       *   Nothing.
       *
       */
      addText(e) {
        if (e === "") return;
        const t = this.stack[this.stack.length - 1], r = t.children[t.children.length - 1];
        r && r.type === "text" ? r.value += e : t.children.push({ type: "text", value: e });
      }
      /**
       *
       * @param {unknown} rawName
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      startScope(e) {
        this.openNode(String(e));
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      endScope() {
        this.closeNode();
      }
      /**
       * @param {HastEmitter} other
       *   Other emitter.
       * @param {string} name
       *   Name of the sublanguage.
       * @returns {undefined}
       *   Nothing.
       */
      __addSublanguage(e, t) {
        const r = this.stack[this.stack.length - 1], o = (
          /** @type {Array<ElementContent>} */
          e.root.children
        );
        t ? r.children.push({
          type: "element",
          tagName: "span",
          properties: { className: [t] },
          children: o
        }) : r.children.push(...o);
      }
      /**
       * @param {string} name
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      openNode(e) {
        const t = this, r = e.split(".").map(function(s, a) {
          return a ? s + "_".repeat(a) : t.options.classPrefix + s;
        }), o = this.stack[this.stack.length - 1], i = {
          type: "element",
          tagName: "span",
          properties: { className: r },
          children: []
        };
        o.children.push(i), this.stack.push(i);
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      closeNode() {
        this.stack.pop();
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      finalize() {
      }
      /**
       * @returns {string}
       *   Nothing.
       */
      toHTML() {
        return "";
      }
    }
    function MN(n3) {
      const e = document.createElement("textarea");
      e.value = n3, e.contentEditable = "true", e.style.position = "fixed", document.body.appendChild(e), e.focus(), e.select();
      const t = document.execCommand("copy");
      return e.remove(), t;
    }
    function AN(n3) {
      return navigator.clipboard !== void 0 ? navigator.clipboard.writeText(n3) : new Promise((e, t) => {
        const r = MN(n3);
        r ? e(true) : t(r);
      });
    }
    const RN = { class: "code-block-toolbar" }, IN = { class: "wrap editable" }, DN = { class: "wrap" }, LN = { class: "language readonly" }, BN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, t = ref("content_copy"), r = computed({
          get() {
            return e.node.attrs.language;
          },
          set(c2) {
            e.updateAttributes({ language: c2 });
          }
        }), o = computed({
          get() {
            return e.node.attrs.wrap;
          },
          set(c2) {
            e.updateAttributes({ wrap: c2 });
          }
        }), i = computed(() => o.value ? "text_select_move_down" : "format_text_wrap");
        function s(c2) {
          r.value = c2;
        }
        function a() {
          const c2 = e.node.content.content[0].text;
          AN(c2).then(() => {
            t.value = "done", setTimeout(() => {
              t.value = "content_copy";
            }, 2e3);
          });
        }
        function l() {
          o.value = !o.value;
        }
        return (c2, u) => (openBlock(), createBlock(unref(yr), mergeProps(e, { class: "o-code-block-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", RN, [
              createBaseVNode("div", IN, [
                createVNode(unref(AC), {
                  language: r.value,
                  onSelect: s
                }, null, 8, ["language"])
              ]),
              createBaseVNode("div", DN, [
                createBaseVNode("div", LN, toDisplayString(r.value), 1),
                createVNode(unref(Je), {
                  icon: i.value,
                  "icon-class": { "rotate-270": o.value },
                  tooltip: "Wrap",
                  class: "editable",
                  onClick: l
                }, null, 8, ["icon", "icon-class"]),
                createVNode(unref(Je), {
                  icon: t.value,
                  tooltip: "Copy",
                  onClick: a
                }, null, 8, ["icon"])
              ])
            ]),
            createBaseVNode("pre", null, [
              createVNode(unref(br), {
                as: "code",
                class: normalizeClass({ wrap: o.value })
              }, null, 8, ["class"])
            ])
          ]),
          _: 1
        }, 16));
      }
    }), PN = ON(EN), $N = tO.extend({
      draggable: true,
      addAttributes() {
        var n3;
        return {
          ...(n3 = this.parent) == null ? void 0 : n3.call(this),
          wrap: {
            default: true,
            rendered: false
          }
        };
      },
      addNodeView() {
        return Bn(BN);
      }
    }).configure({
      languageClassPrefix: "language-",
      defaultLanguage: "bash",
      lowlight: PN
    }), uf = (n3) => {
      const e = /(#[0-9a-f]{3,6})\b/gi, t = [];
      return n3.descendants((r, o) => {
        r.text && Array.from(r.text.matchAll(e)).forEach((i) => {
          const s = i[0], a = i.index || 0, l = o + a, c2 = l + s.length, u = ht.inline(l, c2, {
            class: "color",
            style: `--color: ${s}`
          });
          t.push(u);
        });
      }), He.create(n3, t);
    }, FN = qe.create({
      name: "colorHighlighter",
      addProseMirrorPlugins() {
        return [
          new Ue({
            state: {
              init(n3, { doc: e }) {
                return uf(e);
              },
              apply(n3, e) {
                return n3.docChanged ? uf(n3.doc) : e;
              }
            },
            props: {
              decorations(n3) {
                return this.getState(n3);
              }
            }
          })
        ];
      }
    });
    qe.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("focus"),
            props: {
              decorations: ({ doc: n3, selection: e }) => {
                const { isEditable: t, isFocused: r } = this.editor, { anchor: o } = e, i = [];
                if (!t || !r)
                  return He.create(n3, []);
                let s = 0;
                this.options.mode === "deepest" && n3.descendants((l, c2) => {
                  if (l.isText)
                    return;
                  if (!(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  s += 1;
                });
                let a = 0;
                return n3.descendants((l, c2) => {
                  if (l.isText || !(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  i.push(
                    ht.node(c2, c2 + l.nodeSize, {
                      class: this.options.className
                    })
                  );
                }), He.create(n3, i);
              }
            }
          })
        ];
      }
    });
    const zN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, t = computed(() => e.node.attrs.level);
        return (r, o) => (openBlock(), createBlock(unref(yr), mergeProps(e, {
          class: ["o-heading-view", `h${t.value}`],
          "data-id": r.node.attrs["data-id"],
          style: `text-align: ${r.node.attrs.textAlign}`
        }), {
          default: withCtx(() => [
            createVNode(unref(br))
          ]),
          _: 1
        }, 16, ["class", "data-id", "style"]));
      }
    }), HN = ag.extend({
      draggable: true,
      addNodeView() {
        return Bn(zN);
      }
    }), UN = { class: "horizontal" }, VN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3;
        return (t, r) => (openBlock(), createBlock(unref(yr), mergeProps(e, { class: "o-horizontal-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", UN, [
              createVNode(unref(br), {
                as: "div",
                class: "divider"
              })
            ])
          ]),
          _: 1
        }, 16));
      }
    }), WN = pg.extend({
      draggable: true,
      addNodeView() {
        return Bn(VN);
      }
    }), qN = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, eb = st.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["img", $e(this.options.HTMLAttributes, n3)];
      },
      addCommands() {
        return {
          setImage: (n3) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: n3
          })
        };
      },
      addInputRules() {
        return [
          Su({
            find: qN,
            type: this.type,
            getAttributes: (n3) => {
              const [, , e, t, r] = n3;
              return { src: t, alt: e, title: r };
            }
          })
        ];
      }
    }), KN = {
      key: 1,
      class: "image-container"
    }, GN = { key: 1 }, jN = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, t = ref(false), r = ref(false), o = ref({}), i = ref(null), s = ref(false), a = computed(() => e.node.attrs), l = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.title;
          },
          set(g) {
            e.updateAttributes({ title: g });
          }
        });
        function u() {
          s.value = true, setTimeout(() => {
            var g;
            (g = i.value) == null || g.focus();
          }, 0);
        }
        function d() {
          s.value = false;
        }
        function p2() {
          l.value === "init" && m(true);
        }
        function f(g) {
          switch (t.value = false, g.value) {
            case "replace":
              m(true);
              break;
          }
        }
        function h2(g) {
          l.value = g, m(false);
        }
        function m(g) {
          r.value = g;
        }
        return onMounted(() => {
          m(l.value === "init");
        }), (g, b) => {
          var w;
          return openBlock(), createBlock(unref(yr), mergeProps(e, {
            class: ["o-image-view", {
              "with-caption": a.value.alt,
              "with-ratio": a.value.ratio,
              readonly: !((w = g.editor) != null && w.isEditable),
              init: l.value === "init"
            }],
            size: a.value.size,
            as: "div",
            onClick: p2
          }), {
            default: withCtx(() => [
              createVNode(unref(qi), {
                modelValue: r.value,
                "onUpdate:modelValue": b[1] || (b[1] = (_) => r.value = _),
                placement: l.value === "init" ? "bottom" : "top",
                "show-arrow": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(yg), {
                    val: l.value === "init" ? "" : l.value,
                    type: "image",
                    onInput: h2
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var _;
                  return [
                    l.value === "init" ? (openBlock(), createBlock(unref(mg), {
                      key: 0,
                      icon: "image",
                      placeholder: "Add an image"
                    })) : (openBlock(), createElementBlock("div", KN, [
                      createVNode(unref(gg), mergeProps(e, { onAction: f }), {
                        default: withCtx(() => [
                          createVNode(unref(Je), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: u
                          })
                        ]),
                        _: 1
                      }, 16),
                      createBaseVNode("img", mergeProps(a.value, {
                        draggable: "true",
                        "data-drag-handle": ""
                      }), null, 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: u
                      }, [
                        (_ = g.editor) != null && _.isEditable && s.value ? (openBlock(), createBlock(unref(ls), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: i,
                          class: "caption-input",
                          modelValue: c2.value,
                          "onUpdate:modelValue": b[0] || (b[0] = (v) => c2.value = v),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: d
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", GN, toDisplayString(c2.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(Bu), {
                modelValue: t.value,
                "onUpdate:modelValue": b[2] || (b[2] = (_) => t.value = _),
                event: o.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Qo), mergeProps(e, { onAction: f }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class", "size"]);
        };
      }
    }), JN = eb.extend({
      draggable: true,
      addAttributes() {
        var n3;
        return {
          ...(n3 = this.parent) == null ? void 0 : n3.call(this),
          size: {
            default: "",
            rendered: false
          },
          // small, medium, large
          ratio: {
            default: "",
            rendered: false
          },
          isDraggable: {
            default: true,
            renderHTML: (e) => ({})
          }
        };
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        return e.size = n3.attrs.size, e.ratio = n3.attrs.ratio, ["img", $e(this.options.HTMLAttributes, e)];
      },
      addNodeView() {
        return Bn(jN);
      }
    }).configure({
      inline: true
    }), YN = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", XN = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", Yo = (n3, e) => {
      for (const t in e)
        n3[t] = e[t];
      return n3;
    }, Lc = "numeric", Bc = "ascii", Pc = "alpha", Ci = "asciinumeric", bi = "alphanumeric", $c = "domain", tb = "emoji", ZN = "scheme", QN = "slashscheme", Yl = "whitespace";
    function eM(n3, e) {
      return n3 in e || (e[n3] = []), e[n3];
    }
    function eo(n3, e, t) {
      e[Lc] && (e[Ci] = true, e[bi] = true), e[Bc] && (e[Ci] = true, e[Pc] = true), e[Ci] && (e[bi] = true), e[Pc] && (e[bi] = true), e[bi] && (e[$c] = true), e[tb] && (e[$c] = true);
      for (const r in e) {
        const o = eM(r, t);
        o.indexOf(n3) < 0 && o.push(n3);
      }
    }
    function tM(n3, e) {
      const t = {};
      for (const r in e)
        e[r].indexOf(n3) >= 0 && (t[r] = true);
      return t;
    }
    function tn(n3 = null) {
      this.j = {}, this.jr = [], this.jd = null, this.t = n3;
    }
    tn.groups = {};
    tn.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(n3) {
        const e = this, t = e.j[n3];
        if (t)
          return t;
        for (let r = 0; r < e.jr.length; r++) {
          const o = e.jr[r][0], i = e.jr[r][1];
          if (i && o.test(n3))
            return i;
        }
        return e.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(n3, e = false) {
        return e ? n3 in this.j : !!this.go(n3);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(n3, e, t, r) {
        for (let o = 0; o < n3.length; o++)
          this.tt(n3[o], e, t, r);
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(n3, e, t, r) {
        r = r || tn.groups;
        let o;
        return e && e.j ? o = e : (o = new tn(e), t && r && eo(e, t, r)), this.jr.push([n3, o]), o;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(n3, e, t, r) {
        let o = this;
        const i = n3.length;
        if (!i)
          return o;
        for (let s = 0; s < i - 1; s++)
          o = o.tt(n3[s]);
        return o.tt(n3[i - 1], e, t, r);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(n3, e, t, r) {
        r = r || tn.groups;
        const o = this;
        if (e && e.j)
          return o.j[n3] = e, e;
        const i = e;
        let s, a = o.go(n3);
        if (a ? (s = new tn(), Yo(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new tn(), i) {
          if (r)
            if (s.t && typeof s.t == "string") {
              const l = Yo(tM(s.t, r), t);
              eo(i, l, r);
            } else t && eo(i, t, r);
          s.t = i;
        }
        return o.j[n3] = s, s;
      }
    };
    const xe = (n3, e, t, r, o) => n3.ta(e, t, r, o), ct = (n3, e, t, r, o) => n3.tr(e, t, r, o), df = (n3, e, t, r, o) => n3.ts(e, t, r, o), F = (n3, e, t, r, o) => n3.tt(e, t, r, o), sr = "WORD", Fc = "UWORD", nb = "ASCIINUMERICAL", rb = "ALPHANUMERICAL", ji = "LOCALHOST", zc = "TLD", Hc = "UTLD", Ys = "SCHEME", Ro = "SLASH_SCHEME", qu = "NUM", Uc = "WS", Ku = "NL", xi = "OPENBRACE", Ti = "CLOSEBRACE", wa = "OPENBRACKET", ka = "CLOSEBRACKET", Ea = "OPENPAREN", _a = "CLOSEPAREN", Sa = "OPENANGLEBRACKET", Ca = "CLOSEANGLEBRACKET", xa = "FULLWIDTHLEFTPAREN", Ta = "FULLWIDTHRIGHTPAREN", Oa = "LEFTCORNERBRACKET", Na = "RIGHTCORNERBRACKET", Ma = "LEFTWHITECORNERBRACKET", Aa = "RIGHTWHITECORNERBRACKET", Ra = "FULLWIDTHLESSTHAN", Ia = "FULLWIDTHGREATERTHAN", Da = "AMPERSAND", Gu = "APOSTROPHE", La = "ASTERISK", xr = "AT", Ba = "BACKSLASH", Pa = "BACKTICK", $a = "CARET", Or = "COLON", ju = "COMMA", Fa = "DOLLAR", Wn = "DOT", za = "EQUALS", Ju = "EXCLAMATION", vn = "HYPHEN", Oi = "PERCENT", Ha = "PIPE", Ua = "PLUS", Va = "POUND", Ni = "QUERY", Yu = "QUOTE", ob = "FULLWIDTHMIDDLEDOT", Xu = "SEMI", qn = "SLASH", Mi = "TILDE", Wa = "UNDERSCORE", ib = "EMOJI", qa = "SYM";
    var sb = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      WORD: sr,
      UWORD: Fc,
      ASCIINUMERICAL: nb,
      ALPHANUMERICAL: rb,
      LOCALHOST: ji,
      TLD: zc,
      UTLD: Hc,
      SCHEME: Ys,
      SLASH_SCHEME: Ro,
      NUM: qu,
      WS: Uc,
      NL: Ku,
      OPENBRACE: xi,
      CLOSEBRACE: Ti,
      OPENBRACKET: wa,
      CLOSEBRACKET: ka,
      OPENPAREN: Ea,
      CLOSEPAREN: _a,
      OPENANGLEBRACKET: Sa,
      CLOSEANGLEBRACKET: Ca,
      FULLWIDTHLEFTPAREN: xa,
      FULLWIDTHRIGHTPAREN: Ta,
      LEFTCORNERBRACKET: Oa,
      RIGHTCORNERBRACKET: Na,
      LEFTWHITECORNERBRACKET: Ma,
      RIGHTWHITECORNERBRACKET: Aa,
      FULLWIDTHLESSTHAN: Ra,
      FULLWIDTHGREATERTHAN: Ia,
      AMPERSAND: Da,
      APOSTROPHE: Gu,
      ASTERISK: La,
      AT: xr,
      BACKSLASH: Ba,
      BACKTICK: Pa,
      CARET: $a,
      COLON: Or,
      COMMA: ju,
      DOLLAR: Fa,
      DOT: Wn,
      EQUALS: za,
      EXCLAMATION: Ju,
      HYPHEN: vn,
      PERCENT: Oi,
      PIPE: Ha,
      PLUS: Ua,
      POUND: Va,
      QUERY: Ni,
      QUOTE: Yu,
      FULLWIDTHMIDDLEDOT: ob,
      SEMI: Xu,
      SLASH: qn,
      TILDE: Mi,
      UNDERSCORE: Wa,
      EMOJI: ib,
      SYM: qa
    });
    const or = /[a-z]/, ai = new RegExp("\\p{L}", "u"), Xl = new RegExp("\\p{Emoji}", "u"), ir = /\d/, Zl = /\s/, pf = "\r", Ql = `
`, nM = "", rM = "", ec = "";
    let Ms = null, As = null;
    function oM(n3 = []) {
      const e = {};
      tn.groups = e;
      const t = new tn();
      Ms == null && (Ms = ff(YN)), As == null && (As = ff(XN)), F(t, "'", Gu), F(t, "{", xi), F(t, "}", Ti), F(t, "[", wa), F(t, "]", ka), F(t, "(", Ea), F(t, ")", _a), F(t, "<", Sa), F(t, ">", Ca), F(t, "", xa), F(t, "", Ta), F(t, "", Oa), F(t, "", Na), F(t, "", Ma), F(t, "", Aa), F(t, "", Ra), F(t, "", Ia), F(t, "&", Da), F(t, "*", La), F(t, "@", xr), F(t, "`", Pa), F(t, "^", $a), F(t, ":", Or), F(t, ",", ju), F(t, "$", Fa), F(t, ".", Wn), F(t, "=", za), F(t, "!", Ju), F(t, "-", vn), F(t, "%", Oi), F(t, "|", Ha), F(t, "+", Ua), F(t, "#", Va), F(t, "?", Ni), F(t, '"', Yu), F(t, "/", qn), F(t, ";", Xu), F(t, "~", Mi), F(t, "_", Wa), F(t, "\\", Ba), F(t, "", ob);
      const r = ct(t, ir, qu, {
        [Lc]: true
      });
      ct(r, ir, r);
      const o = ct(r, or, nb, {
        [Ci]: true
      }), i = ct(r, ai, rb, {
        [bi]: true
      }), s = ct(t, or, sr, {
        [Bc]: true
      });
      ct(s, ir, o), ct(s, or, s), ct(o, ir, o), ct(o, or, o);
      const a = ct(t, ai, Fc, {
        [Pc]: true
      });
      ct(a, or), ct(a, ir, i), ct(a, ai, a), ct(i, ir, i), ct(i, or), ct(i, ai, i);
      const l = F(t, Ql, Ku, {
        [Yl]: true
      }), c2 = F(t, pf, Uc, {
        [Yl]: true
      }), u = ct(t, Zl, Uc, {
        [Yl]: true
      });
      F(t, ec, u), F(c2, Ql, l), F(c2, ec, u), ct(c2, Zl, u), F(u, pf), F(u, Ql), ct(u, Zl, u), F(u, ec, u);
      const d = ct(t, Xl, ib, {
        [tb]: true
      });
      F(d, "#"), ct(d, Xl, d), F(d, nM, d);
      const p2 = F(d, rM);
      F(p2, "#"), ct(p2, Xl, d);
      const f = [[or, s], [ir, o]], h2 = [[or, null], [ai, a], [ir, i]];
      for (let m = 0; m < Ms.length; m++)
        Er(t, Ms[m], zc, sr, f);
      for (let m = 0; m < As.length; m++)
        Er(t, As[m], Hc, Fc, h2);
      eo(zc, {
        tld: true,
        ascii: true
      }, e), eo(Hc, {
        utld: true,
        alpha: true
      }, e), Er(t, "file", Ys, sr, f), Er(t, "mailto", Ys, sr, f), Er(t, "http", Ro, sr, f), Er(t, "https", Ro, sr, f), Er(t, "ftp", Ro, sr, f), Er(t, "ftps", Ro, sr, f), eo(Ys, {
        scheme: true,
        ascii: true
      }, e), eo(Ro, {
        slashscheme: true,
        ascii: true
      }, e), n3 = n3.sort((m, g) => m[0] > g[0] ? 1 : -1);
      for (let m = 0; m < n3.length; m++) {
        const g = n3[m][0], w = n3[m][1] ? {
          [ZN]: true
        } : {
          [QN]: true
        };
        g.indexOf("-") >= 0 ? w[$c] = true : or.test(g) ? ir.test(g) ? w[Ci] = true : w[Bc] = true : w[Lc] = true, df(t, g, g, w);
      }
      return df(t, "localhost", ji, {
        ascii: true
      }), t.jd = new tn(qa), {
        start: t,
        tokens: Yo({
          groups: e
        }, sb)
      };
    }
    function ab(n3, e) {
      const t = iM(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = t.length, o = [];
      let i = 0, s = 0;
      for (; s < r; ) {
        let a = n3, l = null, c2 = 0, u = null, d = -1, p2 = -1;
        for (; s < r && (l = a.go(t[s])); )
          a = l, a.accepts() ? (d = 0, p2 = 0, u = a) : d >= 0 && (d += t[s].length, p2++), c2 += t[s].length, i += t[s].length, s++;
        i -= d, s -= p2, c2 -= d, o.push({
          t: u.t,
          // token type/name
          v: e.slice(i - c2, i),
          // string value
          s: i - c2,
          // start index
          e: i
          // end index (excluding)
        });
      }
      return o;
    }
    function iM(n3) {
      const e = [], t = n3.length;
      let r = 0;
      for (; r < t; ) {
        let o = n3.charCodeAt(r), i, s = o < 55296 || o > 56319 || r + 1 === t || (i = n3.charCodeAt(r + 1)) < 56320 || i > 57343 ? n3[r] : n3.slice(r, r + 2);
        e.push(s), r += s.length;
      }
      return e;
    }
    function Er(n3, e, t, r, o) {
      let i;
      const s = e.length;
      for (let a = 0; a < s - 1; a++) {
        const l = e[a];
        n3.j[l] ? i = n3.j[l] : (i = new tn(r), i.jr = o.slice(), n3.j[l] = i), n3 = i;
      }
      return i = new tn(t), i.jr = o.slice(), n3.j[e[s - 1]] = i, i;
    }
    function ff(n3) {
      const e = [], t = [];
      let r = 0, o = "0123456789";
      for (; r < n3.length; ) {
        let i = 0;
        for (; o.indexOf(n3[r + i]) >= 0; )
          i++;
        if (i > 0) {
          e.push(t.join(""));
          for (let s = parseInt(n3.substring(r, r + i), 10); s > 0; s--)
            t.pop();
          r += i;
        } else
          t.push(n3[r]), r++;
      }
      return e;
    }
    const Ji = {
      defaultProtocol: "http",
      events: null,
      format: hf,
      formatHref: hf,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: 1 / 0,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    function Zu(n3, e = null) {
      let t = Yo({}, Ji);
      n3 && (t = Yo(t, n3 instanceof Zu ? n3.o : n3));
      const r = t.ignoreTags, o = [];
      for (let i = 0; i < r.length; i++)
        o.push(r[i].toUpperCase());
      this.o = t, e && (this.defaultRender = e), this.ignoreTags = o;
    }
    Zu.prototype = {
      o: Ji,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(n3) {
        return n3;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(n3) {
        return this.get("validate", n3.toString(), n3);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(n3, e, t) {
        const r = e != null;
        let o = this.o[n3];
        return o && (typeof o == "object" ? (o = t.t in o ? o[t.t] : Ji[n3], typeof o == "function" && r && (o = o(e, t))) : typeof o == "function" && r && (o = o(e, t.t, t)), o);
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(n3, e, t) {
        let r = this.o[n3];
        return typeof r == "function" && e != null && (r = r(e, t.t, t)), r;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(n3) {
        const e = n3.render(this);
        return (this.get("render", null, n3) || this.defaultRender)(e, n3.t, n3);
      }
    };
    function hf(n3) {
      return n3;
    }
    function lb(n3, e) {
      this.t = "token", this.v = n3, this.tk = e;
    }
    lb.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
       */
      toHref(n3) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(n3) {
        const e = this.toString(), t = n3.get("truncate", e, this), r = n3.get("format", e, this);
        return t && r.length > t ? r.substring(0, t) + "" : r;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(n3) {
        return n3.get("formatHref", this.toHref(n3.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(n3 = Ji.defaultProtocol) {
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(n3),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(n3) {
        return {
          type: this.t,
          value: this.toFormattedString(n3),
          isLink: this.isLink,
          href: this.toFormattedHref(n3),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(n3) {
        return n3.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(n3) {
        const e = this, t = this.toHref(n3.get("defaultProtocol")), r = n3.get("formatHref", t, this), o = n3.get("tagName", t, e), i = this.toFormattedString(n3), s = {}, a = n3.get("className", t, e), l = n3.get("target", t, e), c2 = n3.get("rel", t, e), u = n3.getObj("attributes", t, e), d = n3.getObj("events", t, e);
        return s.href = r, a && (s.class = a), l && (s.target = l), c2 && (s.rel = c2), u && Yo(s, u), {
          tagName: o,
          attributes: s,
          content: i,
          eventListeners: d
        };
      }
    };
    function ul(n3, e) {
      class t extends lb {
        constructor(o, i) {
          super(o, i), this.t = n3;
        }
      }
      for (const r in e)
        t.prototype[r] = e[r];
      return t.t = n3, t;
    }
    const mf = ul("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    }), gf = ul("text"), sM = ul("nl"), Rs = ul("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(n3 = Ji.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${n3}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const n3 = this.tk;
        return n3.length >= 2 && n3[0].t !== ji && n3[1].t === Or;
      }
    }), yn = (n3) => new tn(n3);
    function aM({
      groups: n3
    }) {
      const e = n3.domain.concat([Da, La, xr, Ba, Pa, $a, Fa, za, vn, qu, Oi, Ha, Ua, Va, qn, qa, Mi, Wa]), t = [Or, ju, Wn, Ju, Oi, Ni, Yu, Xu, Sa, Ca, xi, Ti, ka, wa, Ea, _a, xa, Ta, Oa, Na, Ma, Aa, Ra, Ia], r = [Da, Gu, La, Ba, Pa, $a, Fa, za, vn, xi, Ti, Oi, Ha, Ua, Va, Ni, qn, qa, Mi, Wa], o = yn(), i = F(o, Mi);
      xe(i, r, i), xe(i, n3.domain, i);
      const s = yn(), a = yn(), l = yn();
      xe(o, n3.domain, s), xe(o, n3.scheme, a), xe(o, n3.slashscheme, l), xe(s, r, i), xe(s, n3.domain, s);
      const c2 = F(s, xr);
      F(i, xr, c2), F(a, xr, c2), F(l, xr, c2);
      const u = F(i, Wn);
      xe(u, r, i), xe(u, n3.domain, i);
      const d = yn();
      xe(c2, n3.domain, d), xe(d, n3.domain, d);
      const p2 = F(d, Wn);
      xe(p2, n3.domain, d);
      const f = yn(mf);
      xe(p2, n3.tld, f), xe(p2, n3.utld, f), F(c2, ji, f);
      const h2 = F(d, vn);
      F(h2, vn, h2), xe(h2, n3.domain, d), xe(f, n3.domain, d), F(f, Wn, p2), F(f, vn, h2);
      const m = F(f, Or);
      xe(m, n3.numeric, mf);
      const g = F(s, vn), b = F(s, Wn);
      F(g, vn, g), xe(g, n3.domain, s), xe(b, r, i), xe(b, n3.domain, s);
      const w = yn(Rs);
      xe(b, n3.tld, w), xe(b, n3.utld, w), xe(w, n3.domain, s), xe(w, r, i), F(w, Wn, b), F(w, vn, g), F(w, xr, c2);
      const _ = F(w, Or), v = yn(Rs);
      xe(_, n3.numeric, v);
      const T = yn(Rs), S = yn();
      xe(T, e, T), xe(T, t, S), xe(S, e, T), xe(S, t, S), F(w, qn, T), F(v, qn, T);
      const z = F(a, Or), U = F(l, Or), B = F(U, qn), q = F(B, qn);
      xe(a, n3.domain, s), F(a, Wn, b), F(a, vn, g), xe(l, n3.domain, s), F(l, Wn, b), F(l, vn, g), xe(z, n3.domain, T), F(z, qn, T), F(z, Ni, T), xe(q, n3.domain, T), xe(q, e, T), F(q, qn, T);
      const oe = [
        [xi, Ti],
        // {}
        [wa, ka],
        // []
        [Ea, _a],
        // ()
        [Sa, Ca],
        // <>
        [xa, Ta],
        // 
        [Oa, Na],
        // 
        [Ma, Aa],
        // 
        [Ra, Ia]
        // 
      ];
      for (let de = 0; de < oe.length; de++) {
        const [ke, we] = oe[de], fe = F(T, ke);
        F(S, ke, fe), F(fe, we, T);
        const he = yn(Rs);
        xe(fe, e, he);
        const M = yn();
        xe(fe, t), xe(he, e, he), xe(he, t, M), xe(M, e, he), xe(M, t, M), F(he, we, T), F(M, we, T);
      }
      return F(o, ji, w), F(o, Ku, sM), {
        start: o,
        tokens: sb
      };
    }
    function lM(n3, e, t) {
      let r = t.length, o = 0, i = [], s = [];
      for (; o < r; ) {
        let a = n3, l = null, c2 = null, u = 0, d = null, p2 = -1;
        for (; o < r && !(l = a.go(t[o].t)); )
          s.push(t[o++]);
        for (; o < r && (c2 = l || a.go(t[o].t)); )
          l = null, a = c2, a.accepts() ? (p2 = 0, d = a) : p2 >= 0 && p2++, o++, u++;
        if (p2 < 0)
          o -= u, o < r && (s.push(t[o]), o++);
        else {
          s.length > 0 && (i.push(tc(gf, e, s)), s = []), o -= p2, u -= p2;
          const f = d.t, h2 = t.slice(o - u, o);
          i.push(tc(f, e, h2));
        }
      }
      return s.length > 0 && i.push(tc(gf, e, s)), i;
    }
    function tc(n3, e, t) {
      const r = t[0].s, o = t[t.length - 1].e, i = e.slice(r, o);
      return new n3(i, t);
    }
    const cM = typeof console < "u" && console && console.warn || (() => {
    }), uM = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", it = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
    function dM() {
      return tn.groups = {}, it.scanner = null, it.parser = null, it.tokenQueue = [], it.pluginQueue = [], it.customSchemes = [], it.initialized = false, it;
    }
    function bf(n3, e = false) {
      if (it.initialized && cM(`linkifyjs: already initialized - will not register custom scheme "${n3}" ${uM}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n3))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
      it.customSchemes.push([n3, e]);
    }
    function pM() {
      it.scanner = oM(it.customSchemes);
      for (let n3 = 0; n3 < it.tokenQueue.length; n3++)
        it.tokenQueue[n3][1]({
          scanner: it.scanner
        });
      it.parser = aM(it.scanner.tokens);
      for (let n3 = 0; n3 < it.pluginQueue.length; n3++)
        it.pluginQueue[n3][1]({
          scanner: it.scanner,
          parser: it.parser
        });
      return it.initialized = true, it;
    }
    function Qu(n3) {
      return it.initialized || pM(), lM(it.parser.start, n3, ab(it.scanner.start, n3));
    }
    Qu.scan = ab;
    function cb(n3, e = null, t = null) {
      if (e && typeof e == "object") {
        if (t)
          throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        t = e, e = null;
      }
      const r = new Zu(t), o = Qu(n3), i = [];
      for (let s = 0; s < o.length; s++) {
        const a = o[s];
        a.isLink && (!e || a.t === e) && r.check(a) && i.push(a.toFormattedObject(r));
      }
      return i;
    }
    function fM(n3) {
      return n3.length === 1 ? n3[0].isLink : n3.length === 3 && n3[1].isLink ? ["()", "[]"].includes(n3[0].value + n3[2].value) : false;
    }
    function hM(n3) {
      return new Ue({
        key: new Ze("autolink"),
        appendTransaction: (e, t, r) => {
          const o = e.some((c2) => c2.docChanged) && !t.doc.eq(r.doc), i = e.some((c2) => c2.getMeta("preventAutolink"));
          if (!o || i)
            return;
          const { tr: s } = r, a = Ak(t.doc, [...e]);
          if (Pk(a).forEach(({ newRange: c2 }) => {
            const u = Ik(r.doc, c2, (f) => f.isTextblock);
            let d, p2;
            if (u.length > 1 ? (d = u[0], p2 = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && r.doc.textBetween(c2.from, c2.to, " ", " ").endsWith(" ") && (d = u[0], p2 = r.doc.textBetween(d.pos, c2.to, void 0, " ")), d && p2) {
              const f = p2.split(" ").filter((b) => b !== "");
              if (f.length <= 0)
                return false;
              const h2 = f[f.length - 1], m = d.pos + p2.lastIndexOf(h2);
              if (!h2)
                return false;
              const g = Qu(h2).map((b) => b.toObject(n3.defaultProtocol));
              if (!fM(g))
                return false;
              g.filter((b) => b.isLink).map((b) => ({
                ...b,
                from: m + b.start + 1,
                to: m + b.end + 1
              })).filter((b) => r.schema.marks.code ? !r.doc.rangeHasMark(b.from, b.to, r.schema.marks.code) : true).filter((b) => n3.validate(b.value)).filter((b) => n3.shouldAutoLink(b.value)).forEach((b) => {
                Eu(b.from, b.to, r.doc).some((w) => w.mark.type === n3.type) || s.addMark(b.from, b.to, n3.type.create({
                  href: b.href
                }));
              });
            }
          }), !!s.steps.length)
            return s;
        }
      });
    }
    function mM(n3) {
      return new Ue({
        key: new Ze("handleClickLink"),
        props: {
          handleClick: (e, t, r) => {
            var o, i;
            if (r.button !== 0 || !e.editable)
              return false;
            let s = r.target;
            const a = [];
            for (; s.nodeName !== "DIV"; )
              a.push(s), s = s.parentNode;
            if (!a.find((p2) => p2.nodeName === "A"))
              return false;
            const l = Rm(e.state, n3.type.name), c2 = r.target, u = (o = c2 == null ? void 0 : c2.href) !== null && o !== void 0 ? o : l.href, d = (i = c2 == null ? void 0 : c2.target) !== null && i !== void 0 ? i : l.target;
            return c2 && u ? (window.open(u, d), true) : false;
          }
        }
      });
    }
    function gM(n3) {
      return new Ue({
        key: new Ze("handlePasteLink"),
        props: {
          handlePaste: (e, t, r) => {
            const { state: o } = e, { selection: i } = o, { empty: s } = i;
            if (s)
              return false;
            let a = "";
            r.content.forEach((c2) => {
              a += c2.textContent;
            });
            const l = cb(a, { defaultProtocol: n3.defaultProtocol }).find((c2) => c2.isLink && c2.value === a);
            return !a || !l ? false : n3.editor.commands.setMark(n3.type, {
              href: l.href
            });
          }
        }
      });
    }
    const bM = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
    function Gr(n3, e) {
      const t = [
        "http",
        "https",
        "ftp",
        "ftps",
        "mailto",
        "tel",
        "callto",
        "sms",
        "cid",
        "xmpp"
      ];
      return e && e.forEach((r) => {
        const o = typeof r == "string" ? r : r.scheme;
        o && t.push(o);
      }), !n3 || n3.replace(bM, "").match(new RegExp(
        // eslint-disable-next-line no-useless-escape
        `^(?:(?:${t.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
        "i"
      ));
    }
    const ub = Cn.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      exitable: true,
      onCreate() {
        this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((n3) => {
          if (typeof n3 == "string") {
            bf(n3);
            return;
          }
          bf(n3.scheme, n3.optionalSlashes);
        });
      },
      onDestroy() {
        dM();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          defaultProtocol: "http",
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          isAllowedUri: (n3, e) => !!Gr(n3, e.protocols),
          validate: (n3) => !!n3,
          shouldAutoLink: (n3) => !!n3
        };
      },
      addAttributes() {
        return {
          href: {
            default: null,
            parseHTML(n3) {
              return n3.getAttribute("href");
            }
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]",
            getAttrs: (n3) => {
              const e = n3.getAttribute("href");
              return !e || !this.options.isAllowedUri(e, {
                defaultValidate: (t) => !!Gr(t, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol
              }) ? false : null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return this.options.isAllowedUri(n3.href, {
          defaultValidate: (e) => !!Gr(e, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? ["a", $e(this.options.HTMLAttributes, n3), 0] : [
          "a",
          $e(this.options.HTMLAttributes, { ...n3, href: "" }),
          0
        ];
      },
      addCommands() {
        return {
          setLink: (n3) => ({ chain: e }) => {
            const { href: t } = n3;
            return this.options.isAllowedUri(t, {
              defaultValidate: (r) => !!Gr(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().setMark(this.name, n3).setMeta("preventAutolink", true).run() : false;
          },
          toggleLink: (n3) => ({ chain: e }) => {
            const { href: t } = n3;
            return this.options.isAllowedUri(t, {
              defaultValidate: (r) => !!Gr(r, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().toggleMark(this.name, n3, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() : false;
          },
          unsetLink: () => ({ chain: n3 }) => n3().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run()
        };
      },
      addPasteRules() {
        return [
          Hr({
            find: (n3) => {
              const e = [];
              if (n3) {
                const { protocols: t, defaultProtocol: r } = this.options, o = cb(n3).filter((i) => i.isLink && this.options.isAllowedUri(i.value, {
                  defaultValidate: (s) => !!Gr(s, t),
                  protocols: t,
                  defaultProtocol: r
                }));
                o.length && o.forEach((i) => e.push({
                  text: i.value,
                  data: {
                    href: i.href
                  },
                  index: i.start
                }));
              }
              return e;
            },
            type: this.type,
            getAttributes: (n3) => {
              var e;
              return {
                href: (e = n3.data) === null || e === void 0 ? void 0 : e.href
              };
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const n3 = [], { protocols: e, defaultProtocol: t } = this.options;
        return this.options.autolink && n3.push(hM({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (r) => this.options.isAllowedUri(r, {
            defaultValidate: (o) => !!Gr(o, e),
            protocols: e,
            defaultProtocol: t
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })), this.options.openOnClick === true && n3.push(mM({
          type: this.type
        })), this.options.linkOnPaste && n3.push(gM({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })), n3;
      }
    });
    function yM(n3) {
      return new Ue({
        key: new Ze("handleClickSelectLink"),
        props: {
          handleClick: (e, t, r) => {
            const { schema: o, doc: i, tr: s } = e.state, a = Zo(i.resolve(t), o.marks.link);
            if (!a) return false;
            const l = i.resolve(a.from), c2 = i.resolve(a.to), u = s.setSelection(new ie(l, c2));
            return e.dispatch(u), true;
          }
        }
      });
    }
    const vM = ub.extend({
      addProseMirrorPlugins() {
        var n3;
        return [
          ...((n3 = this.parent) == null ? void 0 : n3.call(this)) || [],
          yM({
            type: this.type
          })
        ];
      }
    }).configure({
      openOnClick: false
    }), wM = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3;
        return (t, r) => (openBlock(), createBlock(unref(yr), mergeProps(e, { class: "o-paragraph-view" }), {
          default: withCtx(() => [
            createVNode(unref(br), {
              as: "p",
              style: normalizeStyle(`text-align: ${t.node.attrs.textAlign}`)
            }, null, 8, ["style"])
          ]),
          _: 1
        }, 16));
      }
    }), kM = fg.extend({
      draggable: false,
      addNodeView() {
        return Bn(wM, {
          stopEvent: () => false
        });
      }
    }), EM = qe.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something ",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("placeholder"),
            props: {
              decorations: ({ doc: n3, selection: e }) => {
                const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, o = [];
                return t ? (n3.descendants((i, s) => {
                  const a = r >= s && r <= s + i.nodeSize, l = !i.isLeaf && !i.childCount, c2 = this.options.showOnlyCurrent;
                  if ((a || !c2) && l) {
                    const u = [this.options.emptyNodeClass];
                    this.editor.isEmpty && u.push(this.options.emptyEditorClass);
                    const d = ht.node(s, s + i.nodeSize, {
                      class: u.join(" "),
                      "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                        editor: this.editor,
                        node: i,
                        pos: s,
                        hasAnchor: a
                      }) : this.options.placeholder
                    });
                    o.push(d);
                  }
                  return this.options.includeChildren;
                }), He.create(n3, o)) : null;
              }
            }
          })
        ];
      }
    });
    var Vc, Wc;
    if (typeof WeakMap < "u") {
      let n3 = /* @__PURE__ */ new WeakMap();
      Vc = (e) => n3.get(e), Wc = (e, t) => (n3.set(e, t), t);
    } else {
      const n3 = [];
      let t = 0;
      Vc = (r) => {
        for (let o = 0; o < n3.length; o += 2)
          if (n3[o] == r) return n3[o + 1];
      }, Wc = (r, o) => (t == 10 && (t = 0), n3[t++] = r, n3[t++] = o);
    }
    var dt = class {
      constructor(n3, e, t, r) {
        this.width = n3, this.height = e, this.map = t, this.problems = r;
      }
      // Find the dimensions of the cell at the given position.
      findCell(n3) {
        for (let e = 0; e < this.map.length; e++) {
          const t = this.map[e];
          if (t != n3) continue;
          const r = e % this.width, o = e / this.width | 0;
          let i = r + 1, s = o + 1;
          for (let a = 1; i < this.width && this.map[e + a] == t; a++)
            i++;
          for (let a = 1; s < this.height && this.map[e + this.width * a] == t; a++)
            s++;
          return { left: r, top: o, right: i, bottom: s };
        }
        throw new RangeError(`No cell with offset ${n3} found`);
      }
      // Find the left side of the cell at the given position.
      colCount(n3) {
        for (let e = 0; e < this.map.length; e++)
          if (this.map[e] == n3)
            return e % this.width;
        throw new RangeError(`No cell with offset ${n3} found`);
      }
      // Find the next cell in the given direction, starting from the cell
      // at `pos`, if any.
      nextCell(n3, e, t) {
        const { left: r, right: o, top: i, bottom: s } = this.findCell(n3);
        return e == "horiz" ? (t < 0 ? r == 0 : o == this.width) ? null : this.map[i * this.width + (t < 0 ? r - 1 : o)] : (t < 0 ? i == 0 : s == this.height) ? null : this.map[r + this.width * (t < 0 ? i - 1 : s)];
      }
      // Get the rectangle spanning the two given cells.
      rectBetween(n3, e) {
        const {
          left: t,
          right: r,
          top: o,
          bottom: i
        } = this.findCell(n3), {
          left: s,
          right: a,
          top: l,
          bottom: c2
        } = this.findCell(e);
        return {
          left: Math.min(t, s),
          top: Math.min(o, l),
          right: Math.max(r, a),
          bottom: Math.max(i, c2)
        };
      }
      // Return the position of all cells that have the top left corner in
      // the given rectangle.
      cellsInRect(n3) {
        const e = [], t = {};
        for (let r = n3.top; r < n3.bottom; r++)
          for (let o = n3.left; o < n3.right; o++) {
            const i = r * this.width + o, s = this.map[i];
            t[s] || (t[s] = true, !(o == n3.left && o && this.map[i - 1] == s || r == n3.top && r && this.map[i - this.width] == s) && e.push(s));
          }
        return e;
      }
      // Return the position at which the cell at the given row and column
      // starts, or would start, if a cell started there.
      positionAt(n3, e, t) {
        for (let r = 0, o = 0; ; r++) {
          const i = o + t.child(r).nodeSize;
          if (r == n3) {
            let s = e + n3 * this.width;
            const a = (n3 + 1) * this.width;
            for (; s < a && this.map[s] < o; ) s++;
            return s == a ? i - 1 : this.map[s];
          }
          o = i;
        }
      }
      // Find the table map for the given table node.
      static get(n3) {
        return Vc(n3) || Wc(n3, _M(n3));
      }
    };
    function _M(n3) {
      if (n3.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + n3.type.name);
      const e = SM(n3), t = n3.childCount, r = [];
      let o = 0, i = null;
      const s = [];
      for (let c2 = 0, u = e * t; c2 < u; c2++) r[c2] = 0;
      for (let c2 = 0, u = 0; c2 < t; c2++) {
        const d = n3.child(c2);
        u++;
        for (let h2 = 0; ; h2++) {
          for (; o < r.length && r[o] != 0; ) o++;
          if (h2 == d.childCount) break;
          const m = d.child(h2), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
          for (let _ = 0; _ < b; _++) {
            if (_ + c2 >= t) {
              (i || (i = [])).push({
                type: "overlong_rowspan",
                pos: u,
                n: b - _
              });
              break;
            }
            const v = o + _ * e;
            for (let T = 0; T < g; T++) {
              r[v + T] == 0 ? r[v + T] = u : (i || (i = [])).push({
                type: "collision",
                row: c2,
                pos: u,
                n: g - T
              });
              const S = w && w[T];
              if (S) {
                const z = (v + T) % e * 2, U = s[z];
                U == null || U != S && s[z + 1] == 1 ? (s[z] = S, s[z + 1] = 1) : U == S && s[z + 1]++;
              }
            }
          }
          o += g, u += m.nodeSize;
        }
        const p2 = (c2 + 1) * e;
        let f = 0;
        for (; o < p2; ) r[o++] == 0 && f++;
        f && (i || (i = [])).push({ type: "missing", row: c2, n: f }), u++;
      }
      (e === 0 || t === 0) && (i || (i = [])).push({ type: "zero_sized" });
      const a = new dt(e, t, r, i);
      let l = false;
      for (let c2 = 0; !l && c2 < s.length; c2 += 2)
        s[c2] != null && s[c2 + 1] < t && (l = true);
      return l && CM(a, s, n3), a;
    }
    function SM(n3) {
      let e = -1, t = false;
      for (let r = 0; r < n3.childCount; r++) {
        const o = n3.child(r);
        let i = 0;
        if (t)
          for (let s = 0; s < r; s++) {
            const a = n3.child(s);
            for (let l = 0; l < a.childCount; l++) {
              const c2 = a.child(l);
              s + c2.attrs.rowspan > r && (i += c2.attrs.colspan);
            }
          }
        for (let s = 0; s < o.childCount; s++) {
          const a = o.child(s);
          i += a.attrs.colspan, a.attrs.rowspan > 1 && (t = true);
        }
        e == -1 ? e = i : e != i && (e = Math.max(e, i));
      }
      return e;
    }
    function CM(n3, e, t) {
      n3.problems || (n3.problems = []);
      const r = {};
      for (let o = 0; o < n3.map.length; o++) {
        const i = n3.map[o];
        if (r[i]) continue;
        r[i] = true;
        const s = t.nodeAt(i);
        if (!s)
          throw new RangeError(`No cell with offset ${i} found`);
        let a = null;
        const l = s.attrs;
        for (let c2 = 0; c2 < l.colspan; c2++) {
          const u = (o + c2) % n3.width, d = e[u * 2];
          d != null && (!l.colwidth || l.colwidth[c2] != d) && ((a || (a = xM(l)))[c2] = d);
        }
        a && n3.problems.unshift({
          type: "colwidth mismatch",
          pos: i,
          colwidth: a
        });
      }
    }
    function xM(n3) {
      if (n3.colwidth) return n3.colwidth.slice();
      const e = [];
      for (let t = 0; t < n3.colspan; t++) e.push(0);
      return e;
    }
    function Ht(n3) {
      let e = n3.cached.tableNodeTypes;
      if (!e) {
        e = n3.cached.tableNodeTypes = {};
        for (const t in n3.nodes) {
          const r = n3.nodes[t], o = r.spec.tableRole;
          o && (e[o] = r);
        }
      }
      return e;
    }
    var Nr = new Ze("selectingCells");
    function ei(n3) {
      for (let e = n3.depth - 1; e > 0; e--)
        if (n3.node(e).type.spec.tableRole == "row")
          return n3.node(0).resolve(n3.before(e + 1));
      return null;
    }
    function TM(n3) {
      for (let e = n3.depth; e > 0; e--) {
        const t = n3.node(e).type.spec.tableRole;
        if (t === "cell" || t === "header_cell") return n3.node(e);
      }
      return null;
    }
    function $n(n3) {
      const e = n3.selection.$head;
      for (let t = e.depth; t > 0; t--)
        if (e.node(t).type.spec.tableRole == "row") return true;
      return false;
    }
    function dl(n3) {
      const e = n3.selection;
      if ("$anchorCell" in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
      if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
      const t = ei(e.$head) || OM(e.$head);
      if (t)
        return t;
      throw new RangeError(`No cell found around position ${e.head}`);
    }
    function OM(n3) {
      for (let e = n3.nodeAfter, t = n3.pos; e; e = e.firstChild, t++) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell") return n3.doc.resolve(t);
      }
      for (let e = n3.nodeBefore, t = n3.pos; e; e = e.lastChild, t--) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
          return n3.doc.resolve(t - e.nodeSize);
      }
    }
    function qc(n3) {
      return n3.parent.type.spec.tableRole == "row" && !!n3.nodeAfter;
    }
    function NM(n3) {
      return n3.node(0).resolve(n3.pos + n3.nodeAfter.nodeSize);
    }
    function ed(n3, e) {
      return n3.depth == e.depth && n3.pos >= e.start(-1) && n3.pos <= e.end(-1);
    }
    function db(n3, e, t) {
      const r = n3.node(-1), o = dt.get(r), i = n3.start(-1), s = o.nextCell(n3.pos - i, e, t);
      return s == null ? null : n3.node(0).resolve(i + s);
    }
    function go(n3, e, t = 1) {
      const r = { ...n3, colspan: n3.colspan - t };
      return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
    }
    function pb(n3, e, t = 1) {
      const r = { ...n3, colspan: n3.colspan + t };
      if (r.colwidth) {
        r.colwidth = r.colwidth.slice();
        for (let o = 0; o < t; o++) r.colwidth.splice(e, 0, 0);
      }
      return r;
    }
    function MM(n3, e, t) {
      const r = Ht(e.type.schema).header_cell;
      for (let o = 0; o < n3.height; o++)
        if (e.nodeAt(n3.map[t + o * n3.width]).type != r)
          return false;
      return true;
    }
    var Xe = class ar extends ue {
      // A table selection is identified by its anchor and head cells. The
      // positions given to this constructor should point _before_ two
      // cells in the same table. They may be the same, to select a single
      // cell.
      constructor(e, t = e) {
        const r = e.node(-1), o = dt.get(r), i = e.start(-1), s = o.rectBetween(
          e.pos - i,
          t.pos - i
        ), a = e.node(0), l = o.cellsInRect(s).filter((u) => u != t.pos - i);
        l.unshift(t.pos - i);
        const c2 = l.map((u) => {
          const d = r.nodeAt(u);
          if (!d)
            throw RangeError(`No cell with offset ${u} found`);
          const p2 = i + u + 1;
          return new hh(
            a.resolve(p2),
            a.resolve(p2 + d.content.size)
          );
        });
        super(c2[0].$from, c2[0].$to, c2), this.$anchorCell = e, this.$headCell = t;
      }
      map(e, t) {
        const r = e.resolve(t.map(this.$anchorCell.pos)), o = e.resolve(t.map(this.$headCell.pos));
        if (qc(r) && qc(o) && ed(r, o)) {
          const i = this.$anchorCell.node(-1) != r.node(-1);
          return i && this.isRowSelection() ? ar.rowSelection(r, o) : i && this.isColSelection() ? ar.colSelection(r, o) : new ar(r, o);
        }
        return ie.between(r, o);
      }
      // Returns a rectangular slice of table rows containing the selected
      // cells.
      content() {
        const e = this.$anchorCell.node(-1), t = dt.get(e), r = this.$anchorCell.start(-1), o = t.rectBetween(
          this.$anchorCell.pos - r,
          this.$headCell.pos - r
        ), i = {}, s = [];
        for (let l = o.top; l < o.bottom; l++) {
          const c2 = [];
          for (let u = l * t.width + o.left, d = o.left; d < o.right; d++, u++) {
            const p2 = t.map[u];
            if (i[p2]) continue;
            i[p2] = true;
            const f = t.findCell(p2);
            let h2 = e.nodeAt(p2);
            if (!h2)
              throw RangeError(`No cell with offset ${p2} found`);
            const m = o.left - f.left, g = f.right - o.right;
            if (m > 0 || g > 0) {
              let b = h2.attrs;
              if (m > 0 && (b = go(b, 0, m)), g > 0 && (b = go(
                b,
                b.colspan - g,
                g
              )), f.left < o.left) {
                if (h2 = h2.type.createAndFill(b), !h2)
                  throw RangeError(
                    `Could not create cell with attrs ${JSON.stringify(b)}`
                  );
              } else
                h2 = h2.type.create(b, h2.content);
            }
            if (f.top < o.top || f.bottom > o.bottom) {
              const b = {
                ...h2.attrs,
                rowspan: Math.min(f.bottom, o.bottom) - Math.max(f.top, o.top)
              };
              f.top < o.top ? h2 = h2.type.createAndFill(b) : h2 = h2.type.create(b, h2.content);
            }
            c2.push(h2);
          }
          s.push(e.child(l).copy(O.from(c2)));
        }
        const a = this.isColSelection() && this.isRowSelection() ? e : s;
        return new I(O.from(a), 1, 1);
      }
      replace(e, t = I.empty) {
        const r = e.steps.length, o = this.ranges;
        for (let s = 0; s < o.length; s++) {
          const { $from: a, $to: l } = o[s], c2 = e.mapping.slice(r);
          e.replace(
            c2.map(a.pos),
            c2.map(l.pos),
            s ? I.empty : t
          );
        }
        const i = ue.findFrom(
          e.doc.resolve(e.mapping.slice(r).map(this.to)),
          -1
        );
        i && e.setSelection(i);
      }
      replaceWith(e, t) {
        this.replace(e, new I(O.from(t), 0, 0));
      }
      forEachCell(e) {
        const t = this.$anchorCell.node(-1), r = dt.get(t), o = this.$anchorCell.start(-1), i = r.cellsInRect(
          r.rectBetween(
            this.$anchorCell.pos - o,
            this.$headCell.pos - o
          )
        );
        for (let s = 0; s < i.length; s++)
          e(t.nodeAt(i[s]), o + i[s]);
      }
      // True if this selection goes all the way from the top to the
      // bottom of the table.
      isColSelection() {
        const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
        if (Math.min(e, t) > 0) return false;
        const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = t + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(r, o) == this.$headCell.node(-1).childCount;
      }
      // Returns the smallest column selection that covers the given anchor
      // and head cell.
      static colSelection(e, t = e) {
        const r = e.node(-1), o = dt.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(t.pos - i), l = e.node(0);
        return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i + o.map[s.left])), a.bottom < o.height && (t = l.resolve(
          i + o.map[o.width * (o.height - 1) + a.right - 1]
        ))) : (a.top > 0 && (t = l.resolve(i + o.map[a.left])), s.bottom < o.height && (e = l.resolve(
          i + o.map[o.width * (o.height - 1) + s.right - 1]
        ))), new ar(e, t);
      }
      // True if this selection goes all the way from the left to the
      // right of the table.
      isRowSelection() {
        const e = this.$anchorCell.node(-1), t = dt.get(e), r = this.$anchorCell.start(-1), o = t.colCount(this.$anchorCell.pos - r), i = t.colCount(this.$headCell.pos - r);
        if (Math.min(o, i) > 0) return false;
        const s = o + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(s, a) == t.width;
      }
      eq(e) {
        return e instanceof ar && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
      }
      // Returns the smallest row selection that covers the given anchor
      // and head cell.
      static rowSelection(e, t = e) {
        const r = e.node(-1), o = dt.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(t.pos - i), l = e.node(0);
        return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
          i + o.map[s.top * o.width]
        )), a.right < o.width && (t = l.resolve(
          i + o.map[o.width * (a.top + 1) - 1]
        ))) : (a.left > 0 && (t = l.resolve(i + o.map[a.top * o.width])), s.right < o.width && (e = l.resolve(
          i + o.map[o.width * (s.top + 1) - 1]
        ))), new ar(e, t);
      }
      toJSON() {
        return {
          type: "cell",
          anchor: this.$anchorCell.pos,
          head: this.$headCell.pos
        };
      }
      static fromJSON(e, t) {
        return new ar(e.resolve(t.anchor), e.resolve(t.head));
      }
      static create(e, t, r = t) {
        return new ar(e.resolve(t), e.resolve(r));
      }
      getBookmark() {
        return new AM(this.$anchorCell.pos, this.$headCell.pos);
      }
    };
    Xe.prototype.visible = false;
    ue.jsonID("cell", Xe);
    var AM = class fb {
      constructor(e, t) {
        this.anchor = e, this.head = t;
      }
      map(e) {
        return new fb(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        const t = e.resolve(this.anchor), r = e.resolve(this.head);
        return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && ed(t, r) ? new Xe(t, r) : ue.near(r, 1);
      }
    };
    function RM(n3) {
      if (!(n3.selection instanceof Xe)) return null;
      const e = [];
      return n3.selection.forEachCell((t, r) => {
        e.push(
          ht.node(r, r + t.nodeSize, { class: "selectedCell" })
        );
      }), He.create(n3.doc, e);
    }
    function IM({ $from: n3, $to: e }) {
      if (n3.pos == e.pos || n3.pos < e.pos - 6) return false;
      let t = n3.pos, r = e.pos, o = n3.depth;
      for (; o >= 0 && !(n3.after(o + 1) < n3.end(o)); o--, t++)
        ;
      for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--)
        ;
      return t == r && /row|table/.test(n3.node(o).type.spec.tableRole);
    }
    function DM({ $from: n3, $to: e }) {
      let t, r;
      for (let o = n3.depth; o > 0; o--) {
        const i = n3.node(o);
        if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
          t = i;
          break;
        }
      }
      for (let o = e.depth; o > 0; o--) {
        const i = e.node(o);
        if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
          r = i;
          break;
        }
      }
      return t !== r && e.parentOffset === 0;
    }
    function LM(n3, e, t) {
      const r = (e || n3).selection, o = (e || n3).doc;
      let i, s;
      if (r instanceof ne && (s = r.node.type.spec.tableRole)) {
        if (s == "cell" || s == "header_cell")
          i = Xe.create(o, r.from);
        else if (s == "row") {
          const a = o.resolve(r.from + 1);
          i = Xe.rowSelection(a, a);
        } else if (!t) {
          const a = dt.get(r.node), l = r.from + 1, c2 = l + a.map[a.width * a.height - 1];
          i = Xe.create(o, l + 1, c2);
        }
      } else r instanceof ie && IM(r) ? i = ie.create(o, r.from) : r instanceof ie && DM(r) && (i = ie.create(o, r.$from.start(), r.$from.end()));
      return i && (e || (e = n3.tr)).setSelection(i), e;
    }
    var BM = new Ze("fix-tables");
    function hb(n3, e, t, r) {
      const o = n3.childCount, i = e.childCount;
      e: for (let s = 0, a = 0; s < i; s++) {
        const l = e.child(s);
        for (let c2 = a, u = Math.min(o, s + 3); c2 < u; c2++)
          if (n3.child(c2) == l) {
            a = c2 + 1, t += l.nodeSize;
            continue e;
          }
        r(l, t), a < o && n3.child(a).sameMarkup(l) ? hb(n3.child(a), l, t + 1, r) : l.nodesBetween(0, l.content.size, r, t + 1), t += l.nodeSize;
      }
    }
    function mb(n3, e) {
      let t;
      const r = (o, i) => {
        o.type.spec.tableRole == "table" && (t = PM(n3, o, i, t));
      };
      return e ? e.doc != n3.doc && hb(e.doc, n3.doc, 0, r) : n3.doc.descendants(r), t;
    }
    function PM(n3, e, t, r) {
      const o = dt.get(e);
      if (!o.problems) return r;
      r || (r = n3.tr);
      const i = [];
      for (let l = 0; l < o.height; l++) i.push(0);
      for (let l = 0; l < o.problems.length; l++) {
        const c2 = o.problems[l];
        if (c2.type == "collision") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          const d = u.attrs;
          for (let p2 = 0; p2 < d.rowspan; p2++) i[c2.row + p2] += c2.n;
          r.setNodeMarkup(
            r.mapping.map(t + 1 + c2.pos),
            null,
            go(d, d.colspan - c2.n, c2.n)
          );
        } else if (c2.type == "missing")
          i[c2.row] += c2.n;
        else if (c2.type == "overlong_rowspan") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          r.setNodeMarkup(r.mapping.map(t + 1 + c2.pos), null, {
            ...u.attrs,
            rowspan: u.attrs.rowspan - c2.n
          });
        } else if (c2.type == "colwidth mismatch") {
          const u = e.nodeAt(c2.pos);
          if (!u) continue;
          r.setNodeMarkup(r.mapping.map(t + 1 + c2.pos), null, {
            ...u.attrs,
            colwidth: c2.colwidth
          });
        } else if (c2.type == "zero_sized") {
          const u = r.mapping.map(t);
          r.delete(u, u + e.nodeSize);
        }
      }
      let s, a;
      for (let l = 0; l < i.length; l++)
        i[l] && (s == null && (s = l), a = l);
      for (let l = 0, c2 = t + 1; l < o.height; l++) {
        const u = e.child(l), d = c2 + u.nodeSize, p2 = i[l];
        if (p2 > 0) {
          let f = "cell";
          u.firstChild && (f = u.firstChild.type.spec.tableRole);
          const h2 = [];
          for (let g = 0; g < p2; g++) {
            const b = Ht(n3.schema)[f].createAndFill();
            b && h2.push(b);
          }
          const m = (l == 0 || s == l - 1) && a == l ? c2 + 1 : d - 1;
          r.insert(r.mapping.map(m), h2);
        }
        c2 = d;
      }
      return r.setMeta(BM, { fixTables: true });
    }
    function tr(n3) {
      const e = n3.selection, t = dl(n3), r = t.node(-1), o = t.start(-1), i = dt.get(r);
      return { ...e instanceof Xe ? i.rectBetween(
        e.$anchorCell.pos - o,
        e.$headCell.pos - o
      ) : i.findCell(t.pos - o), tableStart: o, map: i, table: r };
    }
    function gb(n3, { map: e, tableStart: t, table: r }, o) {
      let i = o > 0 ? -1 : 0;
      MM(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
      for (let s = 0; s < e.height; s++) {
        const a = s * e.width + o;
        if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
          const l = e.map[a], c2 = r.nodeAt(l);
          n3.setNodeMarkup(
            n3.mapping.map(t + l),
            null,
            pb(c2.attrs, o - e.colCount(l))
          ), s += c2.attrs.rowspan - 1;
        } else {
          const l = i == null ? Ht(r.type.schema).cell : r.nodeAt(e.map[a + i]).type, c2 = e.positionAt(s, o, r);
          n3.insert(n3.mapping.map(t + c2), l.createAndFill());
        }
      }
      return n3;
    }
    function $M(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3);
        e(gb(n3.tr, t, t.left));
      }
      return true;
    }
    function FM(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3);
        e(gb(n3.tr, t, t.right));
      }
      return true;
    }
    function zM(n3, { map: e, table: t, tableStart: r }, o) {
      const i = n3.mapping.maps.length;
      for (let s = 0; s < e.height; ) {
        const a = s * e.width + o, l = e.map[a], c2 = t.nodeAt(l), u = c2.attrs;
        if (o > 0 && e.map[a - 1] == l || o < e.width - 1 && e.map[a + 1] == l)
          n3.setNodeMarkup(
            n3.mapping.slice(i).map(r + l),
            null,
            go(u, o - e.colCount(l))
          );
        else {
          const d = n3.mapping.slice(i).map(r + l);
          n3.delete(d, d + c2.nodeSize);
        }
        s += u.rowspan;
      }
    }
    function HM(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3), r = n3.tr;
        if (t.left == 0 && t.right == t.map.width) return false;
        for (let o = t.right - 1; zM(r, t, o), o != t.left; o--) {
          const i = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
          if (!i)
            throw RangeError("No table found");
          t.table = i, t.map = dt.get(i);
        }
        e(r);
      }
      return true;
    }
    function UM(n3, e, t) {
      var r;
      const o = Ht(e.type.schema).header_cell;
      for (let i = 0; i < n3.width; i++)
        if (((r = e.nodeAt(n3.map[i + t * n3.width])) == null ? void 0 : r.type) != o)
          return false;
      return true;
    }
    function bb(n3, { map: e, tableStart: t, table: r }, o) {
      var i;
      let s = t;
      for (let c2 = 0; c2 < o; c2++) s += r.child(c2).nodeSize;
      const a = [];
      let l = o > 0 ? -1 : 0;
      UM(e, r, o + l) && (l = o == 0 || o == e.height ? null : 0);
      for (let c2 = 0, u = e.width * o; c2 < e.width; c2++, u++)
        if (o > 0 && o < e.height && e.map[u] == e.map[u - e.width]) {
          const d = e.map[u], p2 = r.nodeAt(d).attrs;
          n3.setNodeMarkup(t + d, null, {
            ...p2,
            rowspan: p2.rowspan + 1
          }), c2 += p2.colspan - 1;
        } else {
          const d = l == null ? Ht(r.type.schema).cell : (i = r.nodeAt(e.map[u + l * e.width])) == null ? void 0 : i.type, p2 = d == null ? void 0 : d.createAndFill();
          p2 && a.push(p2);
        }
      return n3.insert(s, Ht(r.type.schema).row.create(null, a)), n3;
    }
    function VM(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3);
        e(bb(n3.tr, t, t.top));
      }
      return true;
    }
    function WM(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3);
        e(bb(n3.tr, t, t.bottom));
      }
      return true;
    }
    function qM(n3, { map: e, table: t, tableStart: r }, o) {
      let i = 0;
      for (let c2 = 0; c2 < o; c2++) i += t.child(c2).nodeSize;
      const s = i + t.child(o).nodeSize, a = n3.mapping.maps.length;
      n3.delete(i + r, s + r);
      const l = /* @__PURE__ */ new Set();
      for (let c2 = 0, u = o * e.width; c2 < e.width; c2++, u++) {
        const d = e.map[u];
        if (!l.has(d)) {
          if (l.add(d), o > 0 && d == e.map[u - e.width]) {
            const p2 = t.nodeAt(d).attrs;
            n3.setNodeMarkup(n3.mapping.slice(a).map(d + r), null, {
              ...p2,
              rowspan: p2.rowspan - 1
            }), c2 += p2.colspan - 1;
          } else if (o < e.height && d == e.map[u + e.width]) {
            const p2 = t.nodeAt(d), f = p2.attrs, h2 = p2.type.create(
              { ...f, rowspan: p2.attrs.rowspan - 1 },
              p2.content
            ), m = e.positionAt(o + 1, c2, t);
            n3.insert(n3.mapping.slice(a).map(r + m), h2), c2 += f.colspan - 1;
          }
        }
      }
    }
    function KM(n3, e) {
      if (!$n(n3)) return false;
      if (e) {
        const t = tr(n3), r = n3.tr;
        if (t.top == 0 && t.bottom == t.map.height) return false;
        for (let o = t.bottom - 1; qM(r, t, o), o != t.top; o--) {
          const i = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
          if (!i)
            throw RangeError("No table found");
          t.table = i, t.map = dt.get(t.table);
        }
        e(r);
      }
      return true;
    }
    function yf(n3) {
      const e = n3.content;
      return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
    }
    function GM({ width: n3, height: e, map: t }, r) {
      let o = r.top * n3 + r.left, i = o, s = (r.bottom - 1) * n3 + r.left, a = o + (r.right - r.left - 1);
      for (let l = r.top; l < r.bottom; l++) {
        if (r.left > 0 && t[i] == t[i - 1] || r.right < n3 && t[a] == t[a + 1])
          return true;
        i += n3, a += n3;
      }
      for (let l = r.left; l < r.right; l++) {
        if (r.top > 0 && t[o] == t[o - n3] || r.bottom < e && t[s] == t[s + n3])
          return true;
        o++, s++;
      }
      return false;
    }
    function vf(n3, e) {
      const t = n3.selection;
      if (!(t instanceof Xe) || t.$anchorCell.pos == t.$headCell.pos)
        return false;
      const r = tr(n3), { map: o } = r;
      if (GM(o, r)) return false;
      if (e) {
        const i = n3.tr, s = {};
        let a = O.empty, l, c2;
        for (let u = r.top; u < r.bottom; u++)
          for (let d = r.left; d < r.right; d++) {
            const p2 = o.map[u * o.width + d], f = r.table.nodeAt(p2);
            if (!(s[p2] || !f))
              if (s[p2] = true, l == null)
                l = p2, c2 = f;
              else {
                yf(f) || (a = a.append(f.content));
                const h2 = i.mapping.map(p2 + r.tableStart);
                i.delete(h2, h2 + f.nodeSize);
              }
          }
        if (l == null || c2 == null)
          return true;
        if (i.setNodeMarkup(l + r.tableStart, null, {
          ...pb(
            c2.attrs,
            c2.attrs.colspan,
            r.right - r.left - c2.attrs.colspan
          ),
          rowspan: r.bottom - r.top
        }), a.size) {
          const u = l + 1 + c2.content.size, d = yf(c2) ? l + 1 : u;
          i.replaceWith(d + r.tableStart, u + r.tableStart, a);
        }
        i.setSelection(
          new Xe(i.doc.resolve(l + r.tableStart))
        ), e(i);
      }
      return true;
    }
    function wf(n3, e) {
      const t = Ht(n3.schema);
      return jM(({ node: r }) => t[r.type.spec.tableRole])(n3, e);
    }
    function jM(n3) {
      return (e, t) => {
        var r;
        const o = e.selection;
        let i, s;
        if (o instanceof Xe) {
          if (o.$anchorCell.pos != o.$headCell.pos) return false;
          i = o.$anchorCell.nodeAfter, s = o.$anchorCell.pos;
        } else {
          if (i = TM(o.$from), !i) return false;
          s = (r = ei(o.$from)) == null ? void 0 : r.pos;
        }
        if (i == null || s == null || i.attrs.colspan == 1 && i.attrs.rowspan == 1)
          return false;
        if (t) {
          let a = i.attrs;
          const l = [], c2 = a.colwidth;
          a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
          const u = tr(e), d = e.tr;
          for (let f = 0; f < u.right - u.left; f++)
            l.push(
              c2 ? {
                ...a,
                colwidth: c2 && c2[f] ? [c2[f]] : null
              } : a
            );
          let p2;
          for (let f = u.top; f < u.bottom; f++) {
            let h2 = u.map.positionAt(f, u.left, u.table);
            f == u.top && (h2 += i.nodeSize);
            for (let m = u.left, g = 0; m < u.right; m++, g++)
              m == u.left && f == u.top || d.insert(
                p2 = d.mapping.map(h2 + u.tableStart, 1),
                n3({ node: i, row: f, col: m }).createAndFill(l[g])
              );
          }
          d.setNodeMarkup(
            s,
            n3({ node: i, row: u.top, col: u.left }),
            l[0]
          ), o instanceof Xe && d.setSelection(
            new Xe(
              d.doc.resolve(o.$anchorCell.pos),
              p2 ? d.doc.resolve(p2) : void 0
            )
          ), t(d);
        }
        return true;
      };
    }
    function JM(n3, e) {
      return function(t, r) {
        if (!$n(t)) return false;
        const o = dl(t);
        if (o.nodeAfter.attrs[n3] === e) return false;
        if (r) {
          const i = t.tr;
          t.selection instanceof Xe ? t.selection.forEachCell((s, a) => {
            s.attrs[n3] !== e && i.setNodeMarkup(a, null, {
              ...s.attrs,
              [n3]: e
            });
          }) : i.setNodeMarkup(o.pos, null, {
            ...o.nodeAfter.attrs,
            [n3]: e
          }), r(i);
        }
        return true;
      };
    }
    function YM(n3) {
      return function(e, t) {
        if (!$n(e)) return false;
        if (t) {
          const r = Ht(e.schema), o = tr(e), i = e.tr, s = o.map.cellsInRect(
            n3 == "column" ? {
              left: o.left,
              top: 0,
              right: o.right,
              bottom: o.map.height
            } : n3 == "row" ? {
              left: 0,
              top: o.top,
              right: o.map.width,
              bottom: o.bottom
            } : o
          ), a = s.map((l) => o.table.nodeAt(l));
          for (let l = 0; l < s.length; l++)
            a[l].type == r.header_cell && i.setNodeMarkup(
              o.tableStart + s[l],
              r.cell,
              a[l].attrs
            );
          if (i.steps.length == 0)
            for (let l = 0; l < s.length; l++)
              i.setNodeMarkup(
                o.tableStart + s[l],
                r.header_cell,
                a[l].attrs
              );
          t(i);
        }
        return true;
      };
    }
    function kf(n3, e, t) {
      const r = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: n3 == "row" ? e.map.width : 1,
        bottom: n3 == "column" ? e.map.height : 1
      });
      for (let o = 0; o < r.length; o++) {
        const i = e.table.nodeAt(r[o]);
        if (i && i.type !== t.header_cell)
          return false;
      }
      return true;
    }
    function Yi(n3, e) {
      return e = e || { useDeprecatedLogic: false }, e.useDeprecatedLogic ? YM(n3) : function(t, r) {
        if (!$n(t)) return false;
        if (r) {
          const o = Ht(t.schema), i = tr(t), s = t.tr, a = kf("row", i, o), l = kf(
            "column",
            i,
            o
          ), u = (n3 === "column" ? a : n3 === "row" ? l : false) ? 1 : 0, d = n3 == "column" ? {
            left: 0,
            top: u,
            right: 1,
            bottom: i.map.height
          } : n3 == "row" ? {
            left: u,
            top: 0,
            right: i.map.width,
            bottom: 1
          } : i, p2 = n3 == "column" ? l ? o.cell : o.header_cell : n3 == "row" ? a ? o.cell : o.header_cell : o.cell;
          i.map.cellsInRect(d).forEach((f) => {
            const h2 = f + i.tableStart, m = s.doc.nodeAt(h2);
            m && s.setNodeMarkup(h2, p2, m.attrs);
          }), r(s);
        }
        return true;
      };
    }
    Yi("row", {
      useDeprecatedLogic: true
    });
    Yi("column", {
      useDeprecatedLogic: true
    });
    var XM = Yi("cell", {
      useDeprecatedLogic: true
    });
    function ZM(n3, e) {
      if (e < 0) {
        const t = n3.nodeBefore;
        if (t) return n3.pos - t.nodeSize;
        for (let r = n3.index(-1) - 1, o = n3.before(); r >= 0; r--) {
          const i = n3.node(-1).child(r), s = i.lastChild;
          if (s)
            return o - 1 - s.nodeSize;
          o -= i.nodeSize;
        }
      } else {
        if (n3.index() < n3.parent.childCount - 1)
          return n3.pos + n3.nodeAfter.nodeSize;
        const t = n3.node(-1);
        for (let r = n3.indexAfter(-1), o = n3.after(); r < t.childCount; r++) {
          const i = t.child(r);
          if (i.childCount) return o + 1;
          o += i.nodeSize;
        }
      }
      return null;
    }
    function Ef(n3) {
      return function(e, t) {
        if (!$n(e)) return false;
        const r = ZM(dl(e), n3);
        if (r == null) return false;
        if (t) {
          const o = e.doc.resolve(r);
          t(
            e.tr.setSelection(ie.between(o, NM(o))).scrollIntoView()
          );
        }
        return true;
      };
    }
    function QM(n3, e) {
      const t = n3.selection.$anchor;
      for (let r = t.depth; r > 0; r--)
        if (t.node(r).type.spec.tableRole == "table")
          return e && e(
            n3.tr.delete(t.before(r), t.after(r)).scrollIntoView()
          ), true;
      return false;
    }
    function Is(n3, e) {
      const t = n3.selection;
      if (!(t instanceof Xe)) return false;
      if (e) {
        const r = n3.tr, o = Ht(n3.schema).cell.createAndFill().content;
        t.forEachCell((i, s) => {
          i.content.eq(o) || r.replace(
            r.mapping.map(s + 1),
            r.mapping.map(s + i.nodeSize - 1),
            new I(o, 0, 0)
          );
        }), r.docChanged && e(r);
      }
      return true;
    }
    function eA(n3) {
      if (!n3.size) return null;
      let { content: e, openStart: t, openEnd: r } = n3;
      for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
        t--, r--, e = e.child(0).content;
      const o = e.child(0), i = o.type.spec.tableRole, s = o.type.schema, a = [];
      if (i == "row")
        for (let l = 0; l < e.childCount; l++) {
          let c2 = e.child(l).content;
          const u = l ? 0 : Math.max(0, t - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
          (u || d) && (c2 = Kc(
            Ht(s).row,
            new I(c2, u, d)
          ).content), a.push(c2);
        }
      else if (i == "cell" || i == "header_cell")
        a.push(
          t || r ? Kc(
            Ht(s).row,
            new I(e, t, r)
          ).content : e
        );
      else
        return null;
      return tA(s, a);
    }
    function tA(n3, e) {
      const t = [];
      for (let o = 0; o < e.length; o++) {
        const i = e[o];
        for (let s = i.childCount - 1; s >= 0; s--) {
          const { rowspan: a, colspan: l } = i.child(s).attrs;
          for (let c2 = o; c2 < o + a; c2++)
            t[c2] = (t[c2] || 0) + l;
        }
      }
      let r = 0;
      for (let o = 0; o < t.length; o++) r = Math.max(r, t[o]);
      for (let o = 0; o < t.length; o++)
        if (o >= e.length && e.push(O.empty), t[o] < r) {
          const i = Ht(n3).cell.createAndFill(), s = [];
          for (let a = t[o]; a < r; a++)
            s.push(i);
          e[o] = e[o].append(O.from(s));
        }
      return { height: e.length, width: r, rows: e };
    }
    function Kc(n3, e) {
      const t = n3.createAndFill();
      return new Nh(t).replace(0, t.content.size, e).doc;
    }
    function nA({ width: n3, height: e, rows: t }, r, o) {
      if (n3 != r) {
        const i = [], s = [];
        for (let a = 0; a < t.length; a++) {
          const l = t[a], c2 = [];
          for (let u = i[a] || 0, d = 0; u < r; d++) {
            let p2 = l.child(d % l.childCount);
            u + p2.attrs.colspan > r && (p2 = p2.type.createChecked(
              go(
                p2.attrs,
                p2.attrs.colspan,
                u + p2.attrs.colspan - r
              ),
              p2.content
            )), c2.push(p2), u += p2.attrs.colspan;
            for (let f = 1; f < p2.attrs.rowspan; f++)
              i[a + f] = (i[a + f] || 0) + p2.attrs.colspan;
          }
          s.push(O.from(c2));
        }
        t = s, n3 = r;
      }
      if (e != o) {
        const i = [];
        for (let s = 0, a = 0; s < o; s++, a++) {
          const l = [], c2 = t[a % e];
          for (let u = 0; u < c2.childCount; u++) {
            let d = c2.child(u);
            s + d.attrs.rowspan > o && (d = d.type.create(
              {
                ...d.attrs,
                rowspan: Math.max(1, o - d.attrs.rowspan)
              },
              d.content
            )), l.push(d);
          }
          i.push(O.from(l));
        }
        t = i, e = o;
      }
      return { width: n3, height: e, rows: t };
    }
    function rA(n3, e, t, r, o, i, s) {
      const a = n3.doc.type.schema, l = Ht(a);
      let c2, u;
      if (o > e.width)
        for (let d = 0, p2 = 0; d < e.height; d++) {
          const f = t.child(d);
          p2 += f.nodeSize;
          const h2 = [];
          let m;
          f.lastChild == null || f.lastChild.type == l.cell ? m = c2 || (c2 = l.cell.createAndFill()) : m = u || (u = l.header_cell.createAndFill());
          for (let g = e.width; g < o; g++) h2.push(m);
          n3.insert(n3.mapping.slice(s).map(p2 - 1 + r), h2);
        }
      if (i > e.height) {
        const d = [];
        for (let h2 = 0, m = (e.height - 1) * e.width; h2 < Math.max(e.width, o); h2++) {
          const g = h2 >= e.width ? false : t.nodeAt(e.map[m + h2]).type == l.header_cell;
          d.push(
            g ? u || (u = l.header_cell.createAndFill()) : c2 || (c2 = l.cell.createAndFill())
          );
        }
        const p2 = l.row.create(null, O.from(d)), f = [];
        for (let h2 = e.height; h2 < i; h2++) f.push(p2);
        n3.insert(n3.mapping.slice(s).map(r + t.nodeSize - 2), f);
      }
      return !!(c2 || u);
    }
    function _f(n3, e, t, r, o, i, s, a) {
      if (s == 0 || s == e.height) return false;
      let l = false;
      for (let c2 = o; c2 < i; c2++) {
        const u = s * e.width + c2, d = e.map[u];
        if (e.map[u - e.width] == d) {
          l = true;
          const p2 = t.nodeAt(d), { top: f, left: h2 } = e.findCell(d);
          n3.setNodeMarkup(n3.mapping.slice(a).map(d + r), null, {
            ...p2.attrs,
            rowspan: s - f
          }), n3.insert(
            n3.mapping.slice(a).map(e.positionAt(s, h2, t)),
            p2.type.createAndFill({
              ...p2.attrs,
              rowspan: f + p2.attrs.rowspan - s
            })
          ), c2 += p2.attrs.colspan - 1;
        }
      }
      return l;
    }
    function Sf(n3, e, t, r, o, i, s, a) {
      if (s == 0 || s == e.width) return false;
      let l = false;
      for (let c2 = o; c2 < i; c2++) {
        const u = c2 * e.width + s, d = e.map[u];
        if (e.map[u - 1] == d) {
          l = true;
          const p2 = t.nodeAt(d), f = e.colCount(d), h2 = n3.mapping.slice(a).map(d + r);
          n3.setNodeMarkup(
            h2,
            null,
            go(
              p2.attrs,
              s - f,
              p2.attrs.colspan - (s - f)
            )
          ), n3.insert(
            h2 + p2.nodeSize,
            p2.type.createAndFill(
              go(p2.attrs, 0, s - f)
            )
          ), c2 += p2.attrs.rowspan - 1;
        }
      }
      return l;
    }
    function Cf(n3, e, t, r, o) {
      let i = t ? n3.doc.nodeAt(t - 1) : n3.doc;
      if (!i)
        throw new Error("No table found");
      let s = dt.get(i);
      const { top: a, left: l } = r, c2 = l + o.width, u = a + o.height, d = n3.tr;
      let p2 = 0;
      function f() {
        if (i = t ? d.doc.nodeAt(t - 1) : d.doc, !i)
          throw new Error("No table found");
        s = dt.get(i), p2 = d.mapping.maps.length;
      }
      rA(d, s, i, t, c2, u, p2) && f(), _f(d, s, i, t, l, c2, a, p2) && f(), _f(d, s, i, t, l, c2, u, p2) && f(), Sf(d, s, i, t, a, u, l, p2) && f(), Sf(d, s, i, t, a, u, c2, p2) && f();
      for (let h2 = a; h2 < u; h2++) {
        const m = s.positionAt(h2, l, i), g = s.positionAt(h2, c2, i);
        d.replace(
          d.mapping.slice(p2).map(m + t),
          d.mapping.slice(p2).map(g + t),
          new I(o.rows[h2 - a], 0, 0)
        );
      }
      f(), d.setSelection(
        new Xe(
          d.doc.resolve(t + s.positionAt(a, l, i)),
          d.doc.resolve(t + s.positionAt(u - 1, c2 - 1, i))
        )
      ), e(d);
    }
    var oA = pu({
      ArrowLeft: Ds("horiz", -1),
      ArrowRight: Ds("horiz", 1),
      ArrowUp: Ds("vert", -1),
      ArrowDown: Ds("vert", 1),
      "Shift-ArrowLeft": Ls("horiz", -1),
      "Shift-ArrowRight": Ls("horiz", 1),
      "Shift-ArrowUp": Ls("vert", -1),
      "Shift-ArrowDown": Ls("vert", 1),
      Backspace: Is,
      "Mod-Backspace": Is,
      Delete: Is,
      "Mod-Delete": Is
    });
    function Xs(n3, e, t) {
      return t.eq(n3.selection) ? false : (e && e(n3.tr.setSelection(t).scrollIntoView()), true);
    }
    function Ds(n3, e) {
      return (t, r, o) => {
        if (!o) return false;
        const i = t.selection;
        if (i instanceof Xe)
          return Xs(
            t,
            r,
            ue.near(i.$headCell, e)
          );
        if (n3 != "horiz" && !i.empty) return false;
        const s = yb(o, n3, e);
        if (s == null) return false;
        if (n3 == "horiz")
          return Xs(
            t,
            r,
            ue.near(t.doc.resolve(i.head + e), e)
          );
        {
          const a = t.doc.resolve(s), l = db(a, n3, e);
          let c2;
          return l ? c2 = ue.near(l, 1) : e < 0 ? c2 = ue.near(t.doc.resolve(a.before(-1)), -1) : c2 = ue.near(t.doc.resolve(a.after(-1)), 1), Xs(t, r, c2);
        }
      };
    }
    function Ls(n3, e) {
      return (t, r, o) => {
        if (!o) return false;
        const i = t.selection;
        let s;
        if (i instanceof Xe)
          s = i;
        else {
          const l = yb(o, n3, e);
          if (l == null) return false;
          s = new Xe(t.doc.resolve(l));
        }
        const a = db(s.$headCell, n3, e);
        return a ? Xs(
          t,
          r,
          new Xe(s.$anchorCell, a)
        ) : false;
      };
    }
    function iA(n3, e) {
      const t = n3.state.doc, r = ei(t.resolve(e));
      return r ? (n3.dispatch(n3.state.tr.setSelection(new Xe(r))), true) : false;
    }
    function sA(n3, e, t) {
      if (!$n(n3.state)) return false;
      let r = eA(t);
      const o = n3.state.selection;
      if (o instanceof Xe) {
        r || (r = {
          width: 1,
          height: 1,
          rows: [
            O.from(
              Kc(Ht(n3.state.schema).cell, t)
            )
          ]
        });
        const i = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), a = dt.get(i).rectBetween(
          o.$anchorCell.pos - s,
          o.$headCell.pos - s
        );
        return r = nA(r, a.right - a.left, a.bottom - a.top), Cf(n3.state, n3.dispatch, s, a, r), true;
      } else if (r) {
        const i = dl(n3.state), s = i.start(-1);
        return Cf(
          n3.state,
          n3.dispatch,
          s,
          dt.get(i.node(-1)).findCell(i.pos - s),
          r
        ), true;
      } else
        return false;
    }
    function aA(n3, e) {
      var t;
      if (e.ctrlKey || e.metaKey) return;
      const r = xf(n3, e.target);
      let o;
      if (e.shiftKey && n3.state.selection instanceof Xe)
        i(n3.state.selection.$anchorCell, e), e.preventDefault();
      else if (e.shiftKey && r && (o = ei(n3.state.selection.$anchor)) != null && ((t = nc(n3, e)) == null ? void 0 : t.pos) != o.pos)
        i(o, e), e.preventDefault();
      else if (!r)
        return;
      function i(l, c2) {
        let u = nc(n3, c2);
        const d = Nr.getState(n3.state) == null;
        if (!u || !ed(l, u))
          if (d) u = l;
          else return;
        const p2 = new Xe(l, u);
        if (d || !n3.state.selection.eq(p2)) {
          const f = n3.state.tr.setSelection(p2);
          d && f.setMeta(Nr, l.pos), n3.dispatch(f);
        }
      }
      function s() {
        n3.root.removeEventListener("mouseup", s), n3.root.removeEventListener("dragstart", s), n3.root.removeEventListener("mousemove", a), Nr.getState(n3.state) != null && n3.dispatch(n3.state.tr.setMeta(Nr, -1));
      }
      function a(l) {
        const c2 = l, u = Nr.getState(n3.state);
        let d;
        if (u != null)
          d = n3.state.doc.resolve(u);
        else if (xf(n3, c2.target) != r && (d = nc(n3, e), !d))
          return s();
        d && i(d, c2);
      }
      n3.root.addEventListener("mouseup", s), n3.root.addEventListener("dragstart", s), n3.root.addEventListener("mousemove", a);
    }
    function yb(n3, e, t) {
      if (!(n3.state.selection instanceof ie)) return null;
      const { $head: r } = n3.state.selection;
      for (let o = r.depth - 1; o >= 0; o--) {
        const i = r.node(o);
        if ((t < 0 ? r.index(o) : r.indexAfter(o)) != (t < 0 ? 0 : i.childCount)) return null;
        if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
          const a = r.before(o), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
          return n3.endOfTextblock(l) ? a : null;
        }
      }
      return null;
    }
    function xf(n3, e) {
      for (; e && e != n3.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
          return e;
      return null;
    }
    function nc(n3, e) {
      const t = n3.posAtCoords({
        left: e.clientX,
        top: e.clientY
      });
      return t && t ? ei(n3.state.doc.resolve(t.pos)) : null;
    }
    var lA = class {
      constructor(e, t) {
        this.node = e, this.defaultCellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
          "--default-cell-min-width",
          `${t}px`
        ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Gc(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type != this.node.type ? false : (this.node = e, Gc(
          e,
          this.colgroup,
          this.table,
          this.defaultCellMinWidth
        ), true);
      }
      ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
      }
    };
    function Gc(n3, e, t, r, o, i) {
      var s;
      let a = 0, l = true, c2 = e.firstChild;
      const u = n3.firstChild;
      if (u) {
        for (let d = 0, p2 = 0; d < u.childCount; d++) {
          const { colspan: f, colwidth: h2 } = u.child(d).attrs;
          for (let m = 0; m < f; m++, p2++) {
            const g = o == p2 ? i : h2 && h2[m], b = g ? g + "px" : "";
            if (a += g || r, g || (l = false), c2)
              c2.style.width != b && (c2.style.width = b), c2 = c2.nextSibling;
            else {
              const w = document.createElement("col");
              w.style.width = b, e.appendChild(w);
            }
          }
        }
        for (; c2; ) {
          const d = c2.nextSibling;
          (s = c2.parentNode) == null || s.removeChild(c2), c2 = d;
        }
        l ? (t.style.width = a + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = a + "px");
      }
    }
    var fn = new Ze(
      "tableColumnResizing"
    );
    function cA({
      handleWidth: n3 = 5,
      cellMinWidth: e = 25,
      defaultCellMinWidth: t = 100,
      View: r = lA,
      lastColumnResizable: o = true
    } = {}) {
      const i = new Ue({
        key: fn,
        state: {
          init(s, a) {
            var l, c2;
            const u = (c2 = (l = i.spec) == null ? void 0 : l.props) == null ? void 0 : c2.nodeViews, d = Ht(a.schema).table.name;
            return r && u && (u[d] = (p2, f) => new r(p2, t, f)), new uA(-1, false);
          },
          apply(s, a) {
            return a.apply(s);
          }
        },
        props: {
          attributes: (s) => {
            const a = fn.getState(s);
            return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
          },
          handleDOMEvents: {
            mousemove: (s, a) => {
              dA(s, a, n3, o);
            },
            mouseleave: (s) => {
              pA(s);
            },
            mousedown: (s, a) => {
              fA(s, a, e, t);
            }
          },
          decorations: (s) => {
            const a = fn.getState(s);
            if (a && a.activeHandle > -1)
              return yA(s, a.activeHandle);
          },
          nodeViews: {}
        }
      });
      return i;
    }
    var uA = class Zs {
      constructor(e, t) {
        this.activeHandle = e, this.dragging = t;
      }
      apply(e) {
        const t = this, r = e.getMeta(fn);
        if (r && r.setHandle != null)
          return new Zs(r.setHandle, false);
        if (r && r.setDragging !== void 0)
          return new Zs(t.activeHandle, r.setDragging);
        if (t.activeHandle > -1 && e.docChanged) {
          let o = e.mapping.map(t.activeHandle, -1);
          return qc(e.doc.resolve(o)) || (o = -1), new Zs(o, t.dragging);
        }
        return t;
      }
    };
    function dA(n3, e, t, r) {
      if (!n3.editable) return;
      const o = fn.getState(n3.state);
      if (o && !o.dragging) {
        const i = mA(e.target);
        let s = -1;
        if (i) {
          const { left: a, right: l } = i.getBoundingClientRect();
          e.clientX - a <= t ? s = Tf(n3, e, "left", t) : l - e.clientX <= t && (s = Tf(n3, e, "right", t));
        }
        if (s != o.activeHandle) {
          if (!r && s !== -1) {
            const a = n3.state.doc.resolve(s), l = a.node(-1), c2 = dt.get(l), u = a.start(-1);
            if (c2.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c2.width - 1)
              return;
          }
          vb(n3, s);
        }
      }
    }
    function pA(n3) {
      if (!n3.editable) return;
      const e = fn.getState(n3.state);
      e && e.activeHandle > -1 && !e.dragging && vb(n3, -1);
    }
    function fA(n3, e, t, r) {
      var o;
      if (!n3.editable) return false;
      const i = (o = n3.dom.ownerDocument.defaultView) != null ? o : window, s = fn.getState(n3.state);
      if (!s || s.activeHandle == -1 || s.dragging)
        return false;
      const a = n3.state.doc.nodeAt(s.activeHandle), l = hA(n3, s.activeHandle, a.attrs);
      n3.dispatch(
        n3.state.tr.setMeta(fn, {
          setDragging: { startX: e.clientX, startWidth: l }
        })
      );
      function c2(d) {
        i.removeEventListener("mouseup", c2), i.removeEventListener("mousemove", u);
        const p2 = fn.getState(n3.state);
        p2 != null && p2.dragging && (gA(
          n3,
          p2.activeHandle,
          Of(p2.dragging, d, t)
        ), n3.dispatch(
          n3.state.tr.setMeta(fn, { setDragging: null })
        ));
      }
      function u(d) {
        if (!d.which) return c2(d);
        const p2 = fn.getState(n3.state);
        if (p2 && p2.dragging) {
          const f = Of(p2.dragging, d, t);
          Nf(
            n3,
            p2.activeHandle,
            f,
            r
          );
        }
      }
      return Nf(
        n3,
        s.activeHandle,
        l,
        r
      ), i.addEventListener("mouseup", c2), i.addEventListener("mousemove", u), e.preventDefault(), true;
    }
    function hA(n3, e, { colspan: t, colwidth: r }) {
      const o = r && r[r.length - 1];
      if (o) return o;
      const i = n3.domAtPos(e);
      let a = i.node.childNodes[i.offset].offsetWidth, l = t;
      if (r)
        for (let c2 = 0; c2 < t; c2++)
          r[c2] && (a -= r[c2], l--);
      return a / l;
    }
    function mA(n3) {
      for (; n3 && n3.nodeName != "TD" && n3.nodeName != "TH"; )
        n3 = n3.classList && n3.classList.contains("ProseMirror") ? null : n3.parentNode;
      return n3;
    }
    function Tf(n3, e, t, r) {
      const o = t == "right" ? -r : r, i = n3.posAtCoords({
        left: e.clientX + o,
        top: e.clientY
      });
      if (!i) return -1;
      const { pos: s } = i, a = ei(n3.state.doc.resolve(s));
      if (!a) return -1;
      if (t == "right") return a.pos;
      const l = dt.get(a.node(-1)), c2 = a.start(-1), u = l.map.indexOf(a.pos - c2);
      return u % l.width == 0 ? -1 : c2 + l.map[u - 1];
    }
    function Of(n3, e, t) {
      const r = e.clientX - n3.startX;
      return Math.max(t, n3.startWidth + r);
    }
    function vb(n3, e) {
      n3.dispatch(
        n3.state.tr.setMeta(fn, { setHandle: e })
      );
    }
    function gA(n3, e, t) {
      const r = n3.state.doc.resolve(e), o = r.node(-1), i = dt.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = n3.state.tr;
      for (let c2 = 0; c2 < i.height; c2++) {
        const u = c2 * i.width + a;
        if (c2 && i.map[u] == i.map[u - i.width]) continue;
        const d = i.map[u], p2 = o.nodeAt(d).attrs, f = p2.colspan == 1 ? 0 : a - i.colCount(d);
        if (p2.colwidth && p2.colwidth[f] == t) continue;
        const h2 = p2.colwidth ? p2.colwidth.slice() : bA(p2.colspan);
        h2[f] = t, l.setNodeMarkup(s + d, null, { ...p2, colwidth: h2 });
      }
      l.docChanged && n3.dispatch(l);
    }
    function Nf(n3, e, t, r) {
      const o = n3.state.doc.resolve(e), i = o.node(-1), s = o.start(-1), a = dt.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
      let l = n3.domAtPos(o.start(-1)).node;
      for (; l && l.nodeName != "TABLE"; )
        l = l.parentNode;
      l && Gc(
        i,
        l.firstChild,
        l,
        r,
        a,
        t
      );
    }
    function bA(n3) {
      return Array(n3).fill(0);
    }
    function yA(n3, e) {
      var t;
      const r = [], o = n3.doc.resolve(e), i = o.node(-1);
      if (!i)
        return He.empty;
      const s = dt.get(i), a = o.start(-1), l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
      for (let c2 = 0; c2 < s.height; c2++) {
        const u = l + c2 * s.width;
        if ((l == s.width - 1 || s.map[u] != s.map[u + 1]) && (c2 == 0 || s.map[u] != s.map[u - s.width])) {
          const d = s.map[u], p2 = a + d + i.nodeAt(d).nodeSize - 1, f = document.createElement("div");
          f.className = "column-resize-handle", (t = fn.getState(n3)) != null && t.dragging && r.push(
            ht.node(
              a + d,
              a + d + i.nodeAt(d).nodeSize,
              {
                class: "column-resize-dragging"
              }
            )
          ), r.push(ht.widget(p2, f));
        }
      }
      return He.create(n3.doc, r);
    }
    function vA({
      allowTableNodeSelection: n3 = false
    } = {}) {
      return new Ue({
        key: Nr,
        // This piece of state is used to remember when a mouse-drag
        // cell-selection is happening, so that it can continue even as
        // transactions (which might move its anchor cell) come in.
        state: {
          init() {
            return null;
          },
          apply(e, t) {
            const r = e.getMeta(Nr);
            if (r != null) return r == -1 ? null : r;
            if (t == null || !e.docChanged) return t;
            const { deleted: o, pos: i } = e.mapping.mapResult(t);
            return o ? null : i;
          }
        },
        props: {
          decorations: RM,
          handleDOMEvents: {
            mousedown: aA
          },
          createSelectionBetween(e) {
            return Nr.getState(e.state) != null ? e.state.selection : null;
          },
          handleTripleClick: iA,
          handleKeyDown: oA,
          handlePaste: sA
        },
        appendTransaction(e, t, r) {
          return LM(
            r,
            mb(r, t),
            n3
          );
        }
      });
    }
    function jc(n3, e) {
      return e ? ["width", `${Math.max(e, n3)}px`] : ["min-width", `${n3}px`];
    }
    function Mf(n3, e, t, r, o, i) {
      var s;
      let a = 0, l = true, c2 = e.firstChild;
      const u = n3.firstChild;
      if (u !== null)
        for (let d = 0, p2 = 0; d < u.childCount; d += 1) {
          const { colspan: f, colwidth: h2 } = u.child(d).attrs;
          for (let m = 0; m < f; m += 1, p2 += 1) {
            const g = o === p2 ? i : h2 && h2[m], b = g ? `${g}px` : "";
            if (a += g || r, g || (l = false), c2) {
              if (c2.style.width !== b) {
                const [w, _] = jc(r, g);
                c2.style.setProperty(w, _);
              }
              c2 = c2.nextSibling;
            } else {
              const w = document.createElement("col"), [_, v] = jc(r, g);
              w.style.setProperty(_, v), e.appendChild(w);
            }
          }
        }
      for (; c2; ) {
        const d = c2.nextSibling;
        (s = c2.parentNode) === null || s === void 0 || s.removeChild(c2), c2 = d;
      }
      l ? (t.style.width = `${a}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${a}px`);
    }
    let wA = class {
      constructor(e, t) {
        this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Mf(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, Mf(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    };
    function kA(n3, e, t, r) {
      let o = 0, i = true;
      const s = [], a = n3.firstChild;
      if (!a)
        return {};
      for (let d = 0, p2 = 0; d < a.childCount; d += 1) {
        const { colspan: f, colwidth: h2 } = a.child(d).attrs;
        for (let m = 0; m < f; m += 1, p2 += 1) {
          const g = t === p2 ? r : h2 && h2[m];
          o += g || e, g || (i = false);
          const [b, w] = jc(e, g);
          s.push([
            "col",
            { style: `${b}: ${w}` }
          ]);
        }
      }
      const l = i ? `${o}px` : "", c2 = i ? "" : `${o}px`;
      return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c2 };
    }
    function Af(n3, e) {
      return n3.createAndFill();
    }
    function EA(n3) {
      if (n3.cached.tableNodeTypes)
        return n3.cached.tableNodeTypes;
      const e = {};
      return Object.keys(n3.nodes).forEach((t) => {
        const r = n3.nodes[t];
        r.spec.tableRole && (e[r.spec.tableRole] = r);
      }), n3.cached.tableNodeTypes = e, e;
    }
    function wb(n3, e, t, r, o) {
      const i = EA(n3), s = [], a = [];
      for (let c2 = 0; c2 < t; c2 += 1) {
        const u = Af(i.cell);
        if (u && a.push(u), r) {
          const d = Af(i.header_cell);
          d && s.push(d);
        }
      }
      const l = [];
      for (let c2 = 0; c2 < e; c2 += 1)
        l.push(i.row.createChecked(null, r && c2 === 0 ? s : a));
      return i.table.createChecked(null, l);
    }
    function _A(n3) {
      return n3 instanceof Xe;
    }
    const Bs = ({ editor: n3 }) => {
      const { selection: e } = n3.state;
      if (!_A(e))
        return false;
      let t = 0;
      const r = Mm(e.ranges[0].$from, (i) => i.type.name === "table");
      return r == null || r.node.descendants((i) => {
        if (i.type.name === "table")
          return false;
        ["tableCell", "tableHeader"].includes(i.type.name) && (t += 1);
      }), t === e.ranges.length ? (n3.commands.deleteTable(), true) : false;
    }, kb = st.create({
      name: "table",
      // @ts-ignore
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: false,
          handleWidth: 5,
          cellMinWidth: 25,
          // TODO: fix
          View: wA,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      content: "tableRow+",
      tableRole: "table",
      isolating: true,
      group: "block",
      parseHTML() {
        return [{ tag: "table" }];
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        const { colgroup: t, tableWidth: r, tableMinWidth: o } = kA(n3, this.options.cellMinWidth);
        return [
          "table",
          $e(this.options.HTMLAttributes, e, {
            style: r ? `width: ${r}` : `min-width: ${o}`
          }),
          t,
          ["tbody", 0]
        ];
      },
      addCommands() {
        return {
          insertTable: ({ rows: n3 = 3, cols: e = 3, withHeaderRow: t = true } = {}) => ({ tr: r, dispatch: o, editor: i }) => {
            const s = wb(i.schema, n3, e, t);
            if (o) {
              const a = r.selection.from + 1;
              r.replaceSelectionWith(s).scrollIntoView().setSelection(ie.near(r.doc.resolve(a)));
            }
            return true;
          },
          addColumnBefore: () => ({ state: n3, dispatch: e }) => $M(n3, e),
          addColumnAfter: () => ({ state: n3, dispatch: e }) => FM(n3, e),
          deleteColumn: () => ({ state: n3, dispatch: e }) => HM(n3, e),
          addRowBefore: () => ({ state: n3, dispatch: e }) => VM(n3, e),
          addRowAfter: () => ({ state: n3, dispatch: e }) => WM(n3, e),
          deleteRow: () => ({ state: n3, dispatch: e }) => KM(n3, e),
          deleteTable: () => ({ state: n3, dispatch: e }) => QM(n3, e),
          mergeCells: () => ({ state: n3, dispatch: e }) => vf(n3, e),
          splitCell: () => ({ state: n3, dispatch: e }) => wf(n3, e),
          toggleHeaderColumn: () => ({ state: n3, dispatch: e }) => Yi("column")(n3, e),
          toggleHeaderRow: () => ({ state: n3, dispatch: e }) => Yi("row")(n3, e),
          toggleHeaderCell: () => ({ state: n3, dispatch: e }) => XM(n3, e),
          mergeOrSplit: () => ({ state: n3, dispatch: e }) => vf(n3, e) ? true : wf(n3, e),
          setCellAttribute: (n3, e) => ({ state: t, dispatch: r }) => JM(n3, e)(t, r),
          goToNextCell: () => ({ state: n3, dispatch: e }) => Ef(1)(n3, e),
          goToPreviousCell: () => ({ state: n3, dispatch: e }) => Ef(-1)(n3, e),
          fixTables: () => ({ state: n3, dispatch: e }) => (e && mb(n3), true),
          setCellSelection: (n3) => ({ tr: e, dispatch: t }) => {
            if (t) {
              const r = Xe.create(e.doc, n3.anchorCell, n3.headCell);
              e.setSelection(r);
            }
            return true;
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          Tab: () => this.editor.commands.goToNextCell() ? true : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : false,
          "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
          Backspace: Bs,
          "Mod-Backspace": Bs,
          Delete: Bs,
          "Mod-Delete": Bs
        };
      },
      addProseMirrorPlugins() {
        return [
          ...this.options.resizable && this.editor.isEditable ? [
            cA({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              View: this.options.View,
              lastColumnResizable: this.options.lastColumnResizable
            })
          ] : [],
          vA({
            allowTableNodeSelection: this.options.allowTableNodeSelection
          })
        ];
      },
      extendNodeSchema(n3) {
        const e = {
          name: n3.name,
          options: n3.options,
          storage: n3.storage
        };
        return {
          tableRole: Te(Z(n3, "tableRole", e))
        };
      }
    });
    function Rf(n3, e, t, r, o, i) {
      let s = 0, a = true, l = e.firstChild;
      const c2 = n3.firstChild;
      for (let u = 0, d = 0; u < c2.childCount; u += 1) {
        const { colspan: p2, colwidth: f } = c2.child(u).attrs;
        for (let h2 = 0; h2 < p2; h2 += 1, d += 1) {
          const m = o === d ? i : f && f[h2], g = m ? `${m}px` : "";
          if (s += m || r, m || (a = false), l)
            l.style.width !== g && (l.style.width = g), l = l.nextSibling;
          else {
            const b = document.createElement("col");
            b.className = `col-${d}`, e.appendChild(b).style.width = g;
          }
        }
      }
      for (; l; ) {
        const u = l.nextSibling;
        l.parentNode.removeChild(l), l = u;
      }
      a ? (t.style.width = `${s}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${s}px`);
    }
    class SA {
      constructor(e, t, r) {
        Ge(this, "node");
        Ge(this, "cellMinWidth");
        Ge(this, "view");
        Ge(this, "dom");
        Ge(this, "table");
        Ge(this, "colgroup");
        Ge(this, "contentDOM");
        this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Rf(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        );
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, Rf(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    const CA = kb.extend({
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: true,
          handleWidth: 5,
          cellMinWidth: 25,
          View: SA,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      addCommands() {
        var n3;
        return {
          ...(n3 = this.parent) == null ? void 0 : n3.call(this),
          insertTable: ({ rows: e, cols: t, withHeaderRow: r }) => ({ editor: o, commands: i, tr: s, dispatch: a }) => {
            const l = wb(o.schema, e, t, r);
            if (a) {
              const c2 = s.selection.anchor + 1;
              i.insertContent({
                type: "table-wrapper",
                content: [l.toJSON()]
              }), s.scrollIntoView().setSelection(
                ie.near(s.doc.resolve(c2))
              );
            }
            return true;
          },
          deleteTable: () => ({ state: e, dispatch: t }) => {
            const r = e.selection.$anchor;
            for (let o = r.depth; o > 0; o--)
              if (r.node(o).type.name === "table-wrapper")
                return t && t(
                  e.tr.delete(r.before(o), r.after(o)).scrollIntoView()
                ), true;
            return false;
          },
          selectRow: (e) => ({ tr: t, dispatch: r }) => {
            if (r) {
              const o = t.doc.resolve(e), i = Xe.rowSelection(o);
              t.setSelection(i);
            }
            return true;
          },
          selectColumn: (e) => ({ tr: t, dispatch: r }) => {
            if (r) {
              const o = t.doc.resolve(e), i = Xe.colSelection(o);
              t.setSelection(i);
            }
            return true;
          }
        };
      }
    }), Eb = st.create({
      name: "tableCell",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (n3) => {
              const e = n3.getAttribute("colwidth");
              return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
            }
          }
        };
      },
      tableRole: "cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "td" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["td", $e(this.options.HTMLAttributes, n3), 0];
      }
    }), xA = { class: "add" }, TA = /* @__PURE__ */ createBaseVNode("div", { class: "indicator" }, [
      /* @__PURE__ */ createBaseVNode("svg", {
        width: "3",
        height: "3",
        viewBox: "0 0 3 3",
        fill: "none"
      }, [
        /* @__PURE__ */ createBaseVNode("circle", {
          cx: "1.5",
          cy: "1.5",
          r: "1.5",
          fill: "#BBBFC4"
        })
      ])
    ], -1), OA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(false);
        function i() {
          o.value = true;
        }
        function s() {
          a("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function a(l, c2 = {}) {
          l === "tableDeleteRow" && (o.value = false), setTimeout(() => {
            r(e.editor, l, c2);
          }, 0);
        }
        return (l, c2) => (openBlock(), createBlock(unref(Iu), mergeProps({
          class: "o-table-cell-view",
          as: "td"
        }, l.node.attrs, {
          style: { background: l.node.attrs.background }
        }), {
          default: withCtx(() => {
            var u;
            return [
              (u = l.editor) != null && u.isEditable ? (openBlock(), createBlock(unref(qi), {
                key: 0,
                modelValue: o.value,
                "onUpdate:modelValue": c2[2] || (c2[2] = (d) => o.value = d),
                placement: "left",
                "tippy-class": "o-row-popover",
                offset: [16, 40],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(Lt), {
                    icon: "select_all",
                    tooltip: unref(t)("table.removeColumn"),
                    onClick: s
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(Lt), {
                    icon: "delete",
                    tooltip: unref(t)("table.removeRow"),
                    onClick: c2[1] || (c2[1] = (d) => a("tableDeleteRow"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["row-handler", { active: o.value }]),
                    onClick: i
                  }, [
                    createBaseVNode("div", xA, [
                      TA,
                      createVNode(unref(Dc), {
                        icon: "add_circle",
                        color: unref(Be).blue,
                        tooltip: unref(t)("table.addRow"),
                        placement: "left",
                        onClick: c2[0] || (c2[0] = withModifiers((d) => a("tableAddRow"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"])) : createCommentVNode("", true),
              createVNode(unref(br))
            ];
          }),
          _: 1
        }, 16, ["style"]));
      }
    }), NA = Eb.extend({
      addAttributes() {
        var n3;
        return {
          ...(n3 = this.parent) == null ? void 0 : n3.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Bn(OA, {
          stopEvent: () => false
        });
      }
    }), _b = st.create({
      name: "tableHeader",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (n3) => {
              const e = n3.getAttribute("colwidth");
              return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
            }
          }
        };
      },
      tableRole: "header_cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "th" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["th", $e(this.options.HTMLAttributes, n3), 0];
      }
    }), MA = { class: "add" }, AA = /* @__PURE__ */ createBaseVNode("div", { class: "indicator" }, [
      /* @__PURE__ */ createBaseVNode("svg", {
        width: "3",
        height: "3",
        viewBox: "0 0 3 3",
        fill: "none"
      }, [
        /* @__PURE__ */ createBaseVNode("circle", {
          cx: "1.5",
          cy: "1.5",
          r: "1.5",
          fill: "#BBBFC4"
        })
      ])
    ], -1), RA = { class: "add" }, IA = /* @__PURE__ */ createBaseVNode("div", { class: "indicator" }, [
      /* @__PURE__ */ createBaseVNode("svg", {
        width: "3",
        height: "3",
        viewBox: "0 0 3 3",
        fill: "none"
      }, [
        /* @__PURE__ */ createBaseVNode("circle", {
          cx: "1.5",
          cy: "1.5",
          r: "1.5",
          fill: "#BBBFC4"
        })
      ])
    ], -1), DA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, { tr: t } = Le(), { run: r } = Qe(), o = ref(false), i = ref(false);
        function s() {
          setTimeout(() => {
            o.value = true;
          }, 0);
        }
        function a() {
          i.value = true;
        }
        function l() {
          o.value = false, u("tableSelectColumn", {
            pos: e.getPos()
          });
        }
        function c2() {
          u("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function u(d, p2 = {}) {
          d === "tableDeleteRow" ? i.value = false : d === "tableDeleteColumn" && (o.value = false), setTimeout(() => {
            r(e.editor, d, p2);
          }, 0);
        }
        return (d, p2) => (openBlock(), createBlock(unref(Iu), mergeProps({
          class: "o-table-header-view",
          as: "th"
        }, d.node.attrs, {
          style: { background: d.node.attrs.background }
        }), {
          default: withCtx(() => {
            var f;
            return [
              (f = d.editor) != null && f.isEditable ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createVNode(unref(qi), {
                  modelValue: o.value,
                  "onUpdate:modelValue": p2[2] || (p2[2] = (h2) => o.value = h2),
                  placement: "top",
                  "tippy-class": "o-column-popover",
                  offset: [0, 20],
                  "hide-click-outside": ""
                }, {
                  "popover-content": withCtx(() => [
                    createVNode(unref(Lt), {
                      icon: "select_all",
                      tooltip: unref(t)("table.removeColumn"),
                      onClick: l
                    }, null, 8, ["tooltip"]),
                    createVNode(unref(Lt), {
                      icon: "delete",
                      tooltip: unref(t)("table.removeColumn"),
                      onClick: p2[1] || (p2[1] = (h2) => u("tableDeleteColumn"))
                    }, null, 8, ["tooltip"])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("section", {
                      class: normalizeClass(["col-handler", { active: o.value }]),
                      onClick: s
                    }, [
                      createBaseVNode("div", MA, [
                        AA,
                        createVNode(unref(Dc), {
                          icon: "add_circle",
                          color: unref(Be).blue,
                          tooltip: unref(t)("table.addColumn"),
                          onClick: p2[0] || (p2[0] = withModifiers((h2) => u("tableAddColumn"), ["stop"]))
                        }, null, 8, ["color", "tooltip"])
                      ])
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["modelValue"]),
                createVNode(unref(qi), {
                  modelValue: i.value,
                  "onUpdate:modelValue": p2[5] || (p2[5] = (h2) => i.value = h2),
                  placement: "left",
                  "tippy-class": "o-row-popover",
                  offset: [15, 40],
                  "hide-click-outside": ""
                }, {
                  "popover-content": withCtx(() => [
                    createVNode(unref(Lt), {
                      icon: "select_all",
                      tooltip: unref(t)("table.removeColumn"),
                      onClick: c2
                    }, null, 8, ["tooltip"]),
                    createVNode(unref(Lt), {
                      icon: "delete",
                      tooltip: unref(t)("table.removeRow"),
                      onClick: p2[4] || (p2[4] = (h2) => u("tableDeleteRow"))
                    }, null, 8, ["tooltip"])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("section", {
                      class: normalizeClass(["row-handler", { active: i.value }]),
                      onClick: a
                    }, [
                      createBaseVNode("div", RA, [
                        IA,
                        createVNode(unref(Dc), {
                          icon: "add_circle",
                          color: unref(Be).blue,
                          tooltip: unref(t)("table.addRow"),
                          placement: "left",
                          onClick: p2[3] || (p2[3] = withModifiers((h2) => u("tableAddRow"), ["stop"]))
                        }, null, 8, ["color", "tooltip"])
                      ])
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ], 64)) : createCommentVNode("", true),
              createVNode(unref(br))
            ];
          }),
          _: 1
        }, 16, ["style"]));
      }
    }), LA = _b.extend({
      addAttributes() {
        var n3;
        return {
          ...(n3 = this.parent) == null ? void 0 : n3.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return Bn(DA, {
          stopEvent: () => false
        });
      }
    }), BA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, t = inject("sideNode", { value: false }), r = ref(false), o = computed(() => {
          const { selection: s } = e.editor.view.state, a = s.from, l = e.getPos(), c2 = l + e.node.nodeSize;
          return a >= l && a <= c2;
        });
        function i(s) {
          r.value = s;
        }
        return watch(o, (s) => {
          i(s);
        }), (s, a) => (openBlock(), createBlock(unref(yr), mergeProps(e, {
          class: ["o-table-wrapper-view", { "side-node-enabled": unref(t) }]
        }), {
          default: withCtx(() => [
            createVNode(unref(br), { as: "table" })
          ]),
          _: 1
        }, 16, ["class"]));
      }
    }), PA = st.create({
      name: "table-wrapper",
      group: "block",
      content: "table",
      draggable: true,
      parseHTML() {
        return [{ tag: "table-wrapper" }];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["table-wrapper", $e(n3), 0];
      },
      addNodeView() {
        return Bn(BA, {
          stopEvent: () => false
        });
      }
    });
    function $A({ node: n3, types: e }) {
      return Array.isArray(e) && e.includes(n3 == null ? void 0 : n3.type) || (n3 == null ? void 0 : n3.type) === e;
    }
    function Ps({ node: n3, types: e }) {
      return n3 ? !$A({ node: n3, types: e }) : false;
    }
    const FA = qe.create({
      name: "trailingNode",
      addOptions() {
        return {
          node: "paragraph",
          notAfter: ["paragraph"]
        };
      },
      addProseMirrorPlugins() {
        const n3 = new Ze(this.name), e = Object.entries(this.editor.schema.nodes).map(([, t]) => t).filter((t) => this.options.notAfter.includes(t.name));
        return [
          new Ue({
            key: n3,
            appendTransaction: (t, r, o) => {
              const { doc: i, tr: s, schema: a } = o, l = n3.getState(o), c2 = i.content.size, u = a.nodes[this.options.node];
              if (l)
                return s.insert(c2, u.create());
            },
            state: {
              init: (t, r) => {
                const o = r.tr.doc.lastChild, i = (o == null ? void 0 : o.firstChild) ?? null;
                return Ps({ node: o, types: e }) || Ps({ node: i, types: e });
              },
              apply: (t, r) => {
                var s;
                if (!t.docChanged) return r;
                const o = t.doc.lastChild, i = ((s = t.doc.lastChild) == null ? void 0 : s.firstChild) ?? null;
                return Ps({ node: o, types: e }) || Ps({ node: i, types: e });
              }
            }
          })
        ];
      }
    });
    var Mt = [];
    for (var rc = 0; rc < 256; ++rc)
      Mt.push((rc + 256).toString(16).slice(1));
    function zA(n3, e = 0) {
      return (Mt[n3[e + 0]] + Mt[n3[e + 1]] + Mt[n3[e + 2]] + Mt[n3[e + 3]] + "-" + Mt[n3[e + 4]] + Mt[n3[e + 5]] + "-" + Mt[n3[e + 6]] + Mt[n3[e + 7]] + "-" + Mt[n3[e + 8]] + Mt[n3[e + 9]] + "-" + Mt[n3[e + 10]] + Mt[n3[e + 11]] + Mt[n3[e + 12]] + Mt[n3[e + 13]] + Mt[n3[e + 14]] + Mt[n3[e + 15]]).toLowerCase();
    }
    var $s, HA = new Uint8Array(16);
    function UA() {
      if (!$s && ($s = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !$s))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return $s(HA);
    }
    var VA = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const If = {
      randomUUID: VA
    };
    function WA(n3, e, t) {
      if (If.randomUUID && !n3)
        return If.randomUUID();
      n3 = n3 || {};
      var r = n3.random || (n3.rng || UA)();
      return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, zA(r);
    }
    const qA = () => WA(), KA = qe.create({
      name: "uniqueID",
      priority: 1e4,
      addOptions: () => ({
        attributeName: "data-id",
        types: ["heading"],
        enableRender: false,
        generateId: () => qA()
      }),
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              [this.options.attributeName]: {
                default: this.options.generateId(),
                parseHTML: (n3) => n3.getAttribute(this.options.attributeName),
                renderHTML: (n3) => this.options.enableRender ? {
                  [this.options.attributeName]: n3[this.options.attributeName]
                } : {}
              }
            }
          }
        ];
      }
    }), GA = {
      key: 1,
      class: "video-container"
    }, jA = /* @__PURE__ */ createBaseVNode("div", { class: "video-cover" }, null, -1), JA = { key: 1 }, YA = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: xt,
      setup(n3) {
        const e = n3, t = ref(false), r = ref({}), o = ref(null), i = ref(false), s = ref(false), a = computed({
          get() {
            return e.node.attrs.caption;
          },
          set(g) {
            e.updateAttributes({ caption: g });
          }
        }), l = computed({
          get() {
            return e.node.attrs.src;
          },
          set(g) {
            e.updateAttributes({ src: g });
          }
        });
        function c2(g) {
          switch (t.value = false, g.value) {
            case "replace":
              m(true);
              break;
          }
        }
        function u() {
          i.value = true, setTimeout(() => {
            var g;
            (g = o.value) == null || g.focus();
          }, 0);
        }
        function d() {
          i.value = false;
        }
        function p2() {
          l.value === "init" && m(true);
        }
        function f(g) {
          t.value = true, r.value = g;
        }
        function h2(g) {
          l.value = g, m(false);
        }
        function m(g) {
          s.value = g;
        }
        return onMounted(() => {
          m(l.value === "init");
        }), (g, b) => {
          var w;
          return openBlock(), createBlock(unref(yr), mergeProps(e, {
            class: ["o-video-view", {
              readonly: !((w = g.editor) != null && w.isEditable),
              init: l.value === "init"
            }],
            as: "div",
            onContextmenu: withModifiers(f, ["prevent"]),
            onClick: p2
          }), {
            default: withCtx(() => [
              createVNode(unref(qi), {
                modelValue: s.value,
                "onUpdate:modelValue": b[1] || (b[1] = (_) => s.value = _),
                placement: l.value === "init" ? "bottom" : "top"
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(yg), {
                    val: l.value === "init" ? "" : l.value,
                    type: "video",
                    onInput: h2
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var _;
                  return [
                    l.value === "init" ? (openBlock(), createBlock(unref(mg), {
                      key: 0,
                      icon: "videocam",
                      placeholder: "Add a video"
                    })) : (openBlock(), createElementBlock("div", GA, [
                      jA,
                      createVNode(unref(gg), mergeProps(e, { onAction: c2 }), {
                        default: withCtx(() => [
                          createVNode(unref(Je), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: u
                          })
                        ]),
                        _: 1
                      }, 16),
                      createBaseVNode("video", mergeProps(g.node.attrs, {
                        draggable: "true",
                        "data-drag-handle": "",
                        controls: ""
                      }), [
                        createBaseVNode("source", normalizeProps(guardReactiveProps(g.node.attrs)), null, 16)
                      ], 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: u
                      }, [
                        (_ = g.editor) != null && _.isEditable && i.value ? (openBlock(), createBlock(unref(ls), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: o,
                          class: "caption-input",
                          modelValue: a.value,
                          "onUpdate:modelValue": b[0] || (b[0] = (v) => a.value = v),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: d
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", JA, toDisplayString(a.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(Bu), {
                modelValue: t.value,
                "onUpdate:modelValue": b[2] || (b[2] = (_) => t.value = _),
                event: r.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(Qo), mergeProps(e, { onAction: c2 }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class", "onContextmenu"]);
        };
      }
    }), XA = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, ZA = st.create({
      name: "video",
      draggable: true,
      addOptions() {
        return {
          inline: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      addAttributes() {
        return {
          // small, medium, large
          caption: {
            default: "",
            rendered: false
          },
          src: {
            default: null,
            parseHTML: (n3) => {
              const e = n3.firstElementChild;
              return (e == null ? void 0 : e.src) ?? "";
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "video"
          }
        ];
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        return [
          "video",
          {
            caption: n3.attrs.caption
          },
          ["source", $e(this.options.HTMLAttributes, e)]
        ];
      },
      addCommands() {
        return {
          setVideo: (n3) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: n3
          })
        };
      },
      addInputRules() {
        return [
          Su({
            find: XA,
            type: this.type,
            getAttributes: (n3) => {
              const [e] = n3;
              return { src: e };
            }
          })
        ];
      },
      addNodeView() {
        return Bn(YA);
      }
    }), Df = [
      "BackColor",
      "Focus",
      "FontFamily",
      "ForeColor",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline",
      "OHorizontalRule",
      "OUniqueID"
    ], QA = [
      "BackColor",
      "Blockquote",
      "Bold",
      "BulletList",
      "Code",
      "CodeBlockLowlight",
      "Focus",
      "FontFamily",
      "ForeColor",
      "HorizontalRule",
      "Image",
      "Italic",
      "Link",
      "ListItem",
      "OrderedList",
      "Strike",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline"
    ], eR = [
      "OBlockquote",
      "OCallout",
      "OCodeBlock",
      "OColon",
      "OColorHighlighter",
      "OColumnExtension",
      "ODiagram",
      "ODoc",
      "ODraggableItem",
      "OEmbed",
      "OFocus",
      "OFontFamily",
      "OFormatClear",
      "OHeading",
      "OHorizontalRule",
      "OIframe",
      "OImage",
      "OIndent",
      "OInsertHtml",
      "OKatexBlock",
      "OKatexInline",
      "OLineHeight",
      "OLink",
      "OModelViewer",
      "OParagraph",
      "OPrint",
      "OSlash",
      "OSlashZh",
      "OTOC",
      "OTableWrapper",
      "OTitle",
      "OTodoItem",
      "OTrailingNode",
      "OUniqueID",
      "OVideo"
    ], tR = [...QA, ...eR], nR = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, rR = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, oR = Cn.create({
      name: "highlight",
      addOptions() {
        return {
          multicolor: false,
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return this.options.multicolor ? {
          color: {
            default: null,
            parseHTML: (n3) => n3.getAttribute("data-color") || n3.style.backgroundColor,
            renderHTML: (n3) => n3.color ? {
              "data-color": n3.color,
              style: `background-color: ${n3.color}; color: inherit`
            } : {}
          }
        } : {};
      },
      parseHTML() {
        return [
          {
            tag: "mark"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["mark", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setHighlight: (n3) => ({ commands: e }) => e.setMark(this.name, n3),
          toggleHighlight: (n3) => ({ commands: e }) => e.toggleMark(this.name, n3),
          unsetHighlight: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
        };
      },
      addInputRules() {
        return [
          ho({
            find: nR,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          Hr({
            find: rR,
            type: this.type
          })
        ];
      }
    }), iR = qe.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new Ue({
            key: new Ze("focus"),
            props: {
              decorations: ({ doc: n3, selection: e }) => {
                const { isEditable: t, isFocused: r } = this.editor, { anchor: o } = e, i = [];
                if (!t || !r)
                  return He.create(n3, []);
                let s = 0;
                this.options.mode === "deepest" && n3.descendants((l, c2) => {
                  if (l.isText)
                    return;
                  if (!(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  s += 1;
                });
                let a = 0;
                return n3.descendants((l, c2) => {
                  if (l.isText || !(o >= c2 && o <= c2 + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  i.push(ht.node(c2, c2 + l.nodeSize, {
                    class: this.options.className
                  }));
                }), He.create(n3, i);
              }
            }
          })
        ];
      }
    }), sR = qe.create({
      name: "fontFamily",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontFamily: {
                default: null,
                parseHTML: (n3) => n3.style.fontFamily,
                renderHTML: (n3) => n3.fontFamily ? {
                  style: `font-family: ${n3.fontFamily}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontFamily: (n3) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: n3 }).run(),
          unsetFontFamily: () => ({ chain: n3 }) => n3().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
        };
      }
    }), aR = qe.create({
      name: "color",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (n3) => {
                  var e;
                  return (e = n3.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
                },
                renderHTML: (n3) => n3.color ? {
                  style: `color: ${n3.color}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setColor: (n3) => ({ chain: e }) => e().setMark("textStyle", { color: n3 }).run(),
          unsetColor: () => ({ chain: n3 }) => n3().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
        };
      }
    }), lR = /^\s*(\[([( |x])?\])\s$/, cR = st.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList"
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (n3) => {
              const e = n3.getAttribute("data-checked");
              return e === "" || e === "true";
            },
            renderHTML: (n3) => ({
              "data-checked": n3.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node: n3, HTMLAttributes: e }) {
        return [
          "li",
          $e(this.options.HTMLAttributes, e, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: n3.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      addKeyboardShortcuts() {
        const n3 = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        return this.options.nested ? {
          ...n3,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        } : n3;
      },
      addNodeView() {
        return ({ node: n3, HTMLAttributes: e, getPos: t, editor: r }) => {
          const o = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
          return i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c2) => c2.preventDefault()), a.addEventListener("change", (c2) => {
            if (!r.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked;
              return;
            }
            const { checked: u } = c2.target;
            r.isEditable && typeof t == "function" && r.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: d }) => {
              const p2 = t();
              if (typeof p2 != "number")
                return false;
              const f = d.doc.nodeAt(p2);
              return d.setNodeMarkup(p2, void 0, {
                ...f == null ? void 0 : f.attrs,
                checked: u
              }), true;
            }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(n3, u) || (a.checked = !a.checked));
          }), Object.entries(this.options.HTMLAttributes).forEach(([c2, u]) => {
            o.setAttribute(c2, u);
          }), o.dataset.checked = n3.attrs.checked, a.checked = n3.attrs.checked, i.append(a, s), o.append(i, l), Object.entries(e).forEach(([c2, u]) => {
            o.setAttribute(c2, u);
          }), {
            dom: o,
            contentDOM: l,
            update: (c2) => c2.type !== this.type ? false : (o.dataset.checked = c2.attrs.checked, a.checked = c2.attrs.checked, true)
          };
        };
      },
      addInputRules() {
        return [
          Wo({
            find: lR,
            type: this.type,
            getAttributes: (n3) => ({
              checked: n3[n3.length - 1] === "x"
            })
          })
        ];
      }
    }), uR = st.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["ul", $e(this.options.HTMLAttributes, n3, { "data-type": this.name }), 0];
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: n3 }) => n3.toggleList(this.name, this.options.itemTypeName)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    }), dR = qe.create({
      name: "textAlign",
      addOptions() {
        return {
          types: [],
          alignments: ["left", "center", "right", "justify"],
          defaultAlignment: null
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              textAlign: {
                default: this.options.defaultAlignment,
                parseHTML: (n3) => {
                  const e = n3.style.textAlign;
                  return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
                },
                renderHTML: (n3) => n3.textAlign ? { style: `text-align: ${n3.textAlign}` } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setTextAlign: (n3) => ({ commands: e }) => this.options.alignments.includes(n3) ? this.options.types.map((t) => e.updateAttributes(t, { textAlign: n3 })).every((t) => t) : false,
          unsetTextAlign: () => ({ commands: n3 }) => this.options.types.map((e) => n3.resetAttributes(e, "textAlign")).every((e) => e)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
          "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
          "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
          "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
        };
      }
    }), pR = (n3) => pt({
      find: /--$/,
      replace: n3 ?? ""
    }), fR = (n3) => pt({
      find: /\.\.\.$/,
      replace: n3 ?? ""
    }), hR = (n3) => pt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
      replace: n3 ?? ""
    }), mR = (n3) => pt({
      find: /"$/,
      replace: n3 ?? ""
    }), gR = (n3) => pt({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
      replace: n3 ?? ""
    }), bR = (n3) => pt({
      find: /'$/,
      replace: n3 ?? ""
    }), yR = (n3) => pt({
      find: /<-$/,
      replace: n3 ?? ""
    }), vR = (n3) => pt({
      find: /->$/,
      replace: n3 ?? ""
    }), wR = (n3) => pt({
      find: /\(c\)$/,
      replace: n3 ?? ""
    }), kR = (n3) => pt({
      find: /\(tm\)$/,
      replace: n3 ?? ""
    }), ER = (n3) => pt({
      find: /\(sm\)$/,
      replace: n3 ?? ""
    }), _R = (n3) => pt({
      find: /\(r\)$/,
      replace: n3 ?? ""
    }), SR = (n3) => pt({
      find: /(?:^|\s)(1\/2)\s$/,
      replace: n3 ?? ""
    }), CR = (n3) => pt({
      find: /\+\/-$/,
      replace: n3 ?? ""
    }), xR = (n3) => pt({
      find: /!=$/,
      replace: n3 ?? ""
    }), TR = (n3) => pt({
      find: /<<$/,
      replace: n3 ?? ""
    }), OR = (n3) => pt({
      find: />>$/,
      replace: n3 ?? ""
    }), NR = (n3) => pt({
      find: /\d+\s?([*x])\s?\d+$/,
      replace: n3 ?? ""
    }), MR = (n3) => pt({
      find: /\^2$/,
      replace: n3 ?? ""
    }), AR = (n3) => pt({
      find: /\^3$/,
      replace: n3 ?? ""
    }), RR = (n3) => pt({
      find: /(?:^|\s)(1\/4)\s$/,
      replace: n3 ?? ""
    }), IR = (n3) => pt({
      find: /(?:^|\s)(3\/4)\s$/,
      replace: n3 ?? ""
    }), DR = qe.create({
      name: "typography",
      addOptions() {
        return {
          closeDoubleQuote: "",
          closeSingleQuote: "",
          copyright: "",
          ellipsis: "",
          emDash: "",
          laquo: "",
          leftArrow: "",
          multiplication: "",
          notEqual: "",
          oneHalf: "",
          oneQuarter: "",
          openDoubleQuote: "",
          openSingleQuote: "",
          plusMinus: "",
          raquo: "",
          registeredTrademark: "",
          rightArrow: "",
          servicemark: "",
          superscriptThree: "",
          superscriptTwo: "",
          threeQuarters: "",
          trademark: ""
        };
      },
      addInputRules() {
        const n3 = [];
        return this.options.emDash !== false && n3.push(pR(this.options.emDash)), this.options.ellipsis !== false && n3.push(fR(this.options.ellipsis)), this.options.openDoubleQuote !== false && n3.push(hR(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== false && n3.push(mR(this.options.closeDoubleQuote)), this.options.openSingleQuote !== false && n3.push(gR(this.options.openSingleQuote)), this.options.closeSingleQuote !== false && n3.push(bR(this.options.closeSingleQuote)), this.options.leftArrow !== false && n3.push(yR(this.options.leftArrow)), this.options.rightArrow !== false && n3.push(vR(this.options.rightArrow)), this.options.copyright !== false && n3.push(wR(this.options.copyright)), this.options.trademark !== false && n3.push(kR(this.options.trademark)), this.options.servicemark !== false && n3.push(ER(this.options.servicemark)), this.options.registeredTrademark !== false && n3.push(_R(this.options.registeredTrademark)), this.options.oneHalf !== false && n3.push(SR(this.options.oneHalf)), this.options.plusMinus !== false && n3.push(CR(this.options.plusMinus)), this.options.notEqual !== false && n3.push(xR(this.options.notEqual)), this.options.laquo !== false && n3.push(TR(this.options.laquo)), this.options.raquo !== false && n3.push(OR(this.options.raquo)), this.options.multiplication !== false && n3.push(NR(this.options.multiplication)), this.options.superscriptTwo !== false && n3.push(MR(this.options.superscriptTwo)), this.options.superscriptThree !== false && n3.push(AR(this.options.superscriptThree)), this.options.oneQuarter !== false && n3.push(RR(this.options.oneQuarter)), this.options.threeQuarters !== false && n3.push(IR(this.options.threeQuarters)), n3;
      }
    }), LR = Cn.create({
      name: "underline",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "u"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (n3) => n3.includes("underline") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["u", $e(this.options.HTMLAttributes, n3), 0];
      },
      addCommands() {
        return {
          setUnderline: () => ({ commands: n3 }) => n3.setMark(this.name),
          toggleUnderline: () => ({ commands: n3 }) => n3.toggleMark(this.name),
          unsetUnderline: () => ({ commands: n3 }) => n3.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline()
        };
      }
    }), Sb = st.create({
      name: "tableRow",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "(tableCell | tableHeader)*",
      tableRole: "row",
      parseHTML() {
        return [
          { tag: "tr" }
        ];
      },
      renderHTML({ HTMLAttributes: n3 }) {
        return ["tr", $e(this.options.HTMLAttributes, n3), 0];
      }
    });
    function BR(n3) {
      var e;
      const { char: t, allowSpaces: r, allowToIncludeChar: o, allowedPrefixes: i, startOfLine: s, $position: a } = n3, l = r && !o, c2 = mE(t), u = new RegExp(`\\s${c2}$`), d = s ? "^" : "", p2 = o ? "" : c2, f = l ? new RegExp(`${d}${c2}.*?(?=\\s${p2}|$)`, "gm") : new RegExp(`${d}(?:^)?${c2}[^\\s${p2}]*`, "gm"), h2 = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
      if (!h2)
        return null;
      const m = a.pos - h2.length, g = Array.from(h2.matchAll(f)).pop();
      if (!g || g.input === void 0 || g.index === void 0)
        return null;
      const b = g.input.slice(Math.max(0, g.index - 1), g.index), w = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(b);
      if (i !== null && !w)
        return null;
      const _ = m + g.index;
      let v = _ + g[0].length;
      return l && u.test(h2.slice(v - 1, v + 1)) && (g[0] += " ", v += 1), _ < a.pos && v >= a.pos ? {
        range: {
          from: _,
          to: v
        },
        query: g[0].slice(t.length),
        text: g[0]
      } : null;
    }
    const PR = new Ze("suggestion");
    function Cb({ pluginKey: n3 = PR, editor: e, char: t = "@", allowSpaces: r = false, allowToIncludeChar: o = false, allowedPrefixes: i = [" "], startOfLine: s = false, decorationTag: a = "span", decorationClass: l = "suggestion", command: c2 = () => null, items: u = () => [], render: d = () => ({}), allow: p2 = () => true, findSuggestionMatch: f = BR }) {
      let h2;
      const m = d == null ? void 0 : d(), g = new Ue({
        key: n3,
        view() {
          return {
            update: async (b, w) => {
              var _, v, T, S, z, U, B;
              const q = (_ = this.key) === null || _ === void 0 ? void 0 : _.getState(w), oe = (v = this.key) === null || v === void 0 ? void 0 : v.getState(b.state), de = q.active && oe.active && q.range.from !== oe.range.from, ke = !q.active && oe.active, we = q.active && !oe.active, fe = !ke && !we && q.query !== oe.query, he = ke || de && fe, M = fe || de, L = we || de && fe;
              if (!he && !M && !L)
                return;
              const J = L && !he ? q : oe, re = b.dom.querySelector(`[data-decoration-id="${J.decorationId}"]`);
              h2 = {
                editor: e,
                range: J.range,
                query: J.query,
                text: J.text,
                items: [],
                command: (ce) => c2({
                  editor: e,
                  range: J.range,
                  props: ce
                }),
                decorationNode: re,
                // virtual node for popper.js or tippy.js
                // this can be used for building popups without a DOM node
                clientRect: re ? () => {
                  var ce;
                  const { decorationId: Se } = (ce = this.key) === null || ce === void 0 ? void 0 : ce.getState(e.state), Fe = b.dom.querySelector(`[data-decoration-id="${Se}"]`);
                  return (Fe == null ? void 0 : Fe.getBoundingClientRect()) || null;
                } : null
              }, he && ((T = m == null ? void 0 : m.onBeforeStart) === null || T === void 0 || T.call(m, h2)), M && ((S = m == null ? void 0 : m.onBeforeUpdate) === null || S === void 0 || S.call(m, h2)), (M || he) && (h2.items = await u({
                editor: e,
                query: J.query
              })), L && ((z = m == null ? void 0 : m.onExit) === null || z === void 0 || z.call(m, h2)), M && ((U = m == null ? void 0 : m.onUpdate) === null || U === void 0 || U.call(m, h2)), he && ((B = m == null ? void 0 : m.onStart) === null || B === void 0 || B.call(m, h2));
            },
            destroy: () => {
              var b;
              h2 && ((b = m == null ? void 0 : m.onExit) === null || b === void 0 || b.call(m, h2));
            }
          };
        },
        state: {
          // Initialize the plugin's internal state.
          init() {
            return {
              active: false,
              range: {
                from: 0,
                to: 0
              },
              query: null,
              text: null,
              composing: false
            };
          },
          // Apply changes to the plugin state from a view transaction.
          apply(b, w, _, v) {
            const { isEditable: T } = e, { composing: S } = e.view, { selection: z } = b, { empty: U, from: B } = z, q = { ...w };
            if (q.composing = S, T && (U || e.view.composing)) {
              (B < w.range.from || B > w.range.to) && !S && !w.composing && (q.active = false);
              const oe = f({
                char: t,
                allowSpaces: r,
                allowToIncludeChar: o,
                allowedPrefixes: i,
                startOfLine: s,
                $position: z.$from
              }), de = `id_${Math.floor(Math.random() * 4294967295)}`;
              oe && p2({
                editor: e,
                state: v,
                range: oe.range,
                isActive: w.active
              }) ? (q.active = true, q.decorationId = w.decorationId ? w.decorationId : de, q.range = oe.range, q.query = oe.query, q.text = oe.text) : q.active = false;
            } else
              q.active = false;
            return q.active || (q.decorationId = null, q.range = { from: 0, to: 0 }, q.query = null, q.text = null), q;
          }
        },
        props: {
          // Call the keydown hook if suggestion is active.
          handleKeyDown(b, w) {
            var _;
            const { active: v, range: T } = g.getState(b.state);
            return v && ((_ = m == null ? void 0 : m.onKeyDown) === null || _ === void 0 ? void 0 : _.call(m, { view: b, event: w, range: T })) || false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(b) {
            const { active: w, range: _, decorationId: v } = g.getState(b);
            return w ? He.create(b.doc, [
              ht.inline(_.from, _.to, {
                nodeName: a,
                class: l,
                "data-decoration-id": v
              })
            ]) : null;
          }
        }
      });
      return g;
    }
    const $R = qe.create({
      name: "slash",
      addOptions() {
        return {
          suggestion: {
            char: "/",
            command: ({
              editor: n3,
              range: e,
              props: t
            }) => {
              t.command({ editor: n3, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          Cb({
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), FR = qe.create({
      name: "slash-zh",
      addOptions() {
        return {
          suggestion: {
            char: "",
            command: ({
              editor: n3,
              range: e,
              props: t
            }) => {
              t.command({ editor: n3, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          Cb({
            pluginKey: new Ze("slash-zh-suggestion"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), zR = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: n3, tr: e } = Le(), { onCommand: t } = Qe();
        return {
          locale: n3,
          tr: e,
          onCommand: t
        };
      },
      data() {
        return {
          view: "main",
          selectedIndex: 0
        };
      },
      components: {
        ODivider: On,
        OIcon: ye,
        OList: Pn,
        OListItem: Nn
      },
      watch: {
        items() {
          this.selectedIndex = 0;
        }
      },
      methods: {
        onClick(n3) {
          switch (n3.value) {
            default:
              this.run(n3);
              break;
          }
          return true;
        },
        run(n3) {
          const e = this.editor.chain().focus().deleteRange(this.range), t = this.editor.commands;
          switch (n3.value) {
            case "codeBlock":
              t.deleteRange(this.range), this.editor.commands.setCodeBlock({ language: "bash" });
              break;
            case "content":
              t.deleteRange(this.range), this.editor.commands.insertContent(n3.options.content);
              break;
            case "taskList":
              t.deleteRange(this.range), this.editor.commands.toggleTaskList();
              break;
            default:
              this.onCommand(t, e, n3.value, n3.options);
              break;
          }
        },
        onKeyDown({ event: n3 }) {
          return n3.key === "ArrowUp" ? (this.upHandler(), true) : n3.key === "ArrowDown" ? (this.downHandler(), true) : n3.key === "Enter" ? (this.enterHandler(), true) : false;
        },
        upHandler() {
          this.selectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
        },
        downHandler() {
          this.selectedIndex = (this.selectedIndex + 1) % this.items.length;
        },
        enterHandler() {
          this.selectItem(this.selectedIndex);
        },
        selectItem(n3) {
          const e = this.items[n3];
          e && this.onClick(e);
        },
        setEmoji(n3) {
          this.onClick({ value: "content", options: { content: n3 } });
        }
      },
      computed: {
        basicBlocks() {
          return as.slice(1);
        }
      },
      mounted() {
        this.selectedIndex = 0;
      }
    }, HR = (n3, e) => {
      const t = n3.__vccOpts || n3;
      for (const [r, o] of e)
        t[r] = o;
      return t;
    }, UR = {
      key: 0,
      class: "view-main"
    }, VR = { class: "group o-tips" }, WR = { class: "o-tips" }, qR = {
      key: 1,
      class: "item"
    }, KR = {
      key: 1,
      class: "view-emoji"
    }, GR = {
      key: 2,
      class: "view-emoji"
    };
    function jR(n3, e, t, r, o, i) {
      const s = resolveComponent("o-divider"), a = resolveComponent("o-icon"), l = resolveComponent("o-list-item"), c2 = resolveComponent("o-list");
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(["o-slash-view o-shadow-3 o-menu o-scroll", `view-${o.view}`])
      }, [
        o.view === "main" ? (openBlock(), createElementBlock("section", UR, [
          createVNode(c2, {
            hoverable: "",
            clickable: ""
          }, {
            default: withCtx(() => [
              t.items.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(t.items, (u, d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
                u.group ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  d > 0 ? (openBlock(), createBlock(s, { key: 0 })) : createCommentVNode("", true),
                  createBaseVNode("div", VR, toDisplayString(r.tr(u.group)), 1)
                ], 64)) : createCommentVNode("", true),
                createVNode(l, {
                  class: normalizeClass(["item", { "is-active": d === o.selectedIndex }]),
                  clickable: "",
                  onClick: (p2) => i.onClick(u)
                }, {
                  prefix: withCtx(() => [
                    createVNode(a, {
                      name: u.icon,
                      color: u.color
                    }, null, 8, ["name", "color"])
                  ]),
                  suffix: withCtx(() => [
                    createBaseVNode("span", WR, toDisplayString(u.tips), 1)
                  ]),
                  default: withCtx(() => [
                    createTextVNode(" " + toDisplayString(r.tr(u.label)), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])
              ], 64))), 128)) : (openBlock(), createElementBlock("div", qR, "No result"))
            ]),
            _: 1
          })
        ])) : o.view === "emoji" ? (openBlock(), createElementBlock("section", KR)) : o.view === "ai" ? (openBlock(), createElementBlock("section", GR)) : createCommentVNode("", true)
      ], 2);
    }
    const JR = /* @__PURE__ */ HR(zR, [["render", jR]]), Lf = {
      items: ({ query: n3 }) => Lu.filter(
        (e) => e.value.toLowerCase().startsWith(n3.toLowerCase())
      ),
      render: () => {
        let n3, e;
        return {
          onStart: (t) => {
            n3 = new og(JR, {
              props: t,
              editor: t.editor
            }), e = er("body", {
              getReferenceClientRect: t.clientRect,
              appendTo: () => document.body,
              content: n3.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false
            });
          },
          onUpdate(t) {
            n3.updateProps(t), e[0].setProps({
              getReferenceClientRect: t.clientRect
            });
          },
          onKeyDown(t) {
            var r;
            return t.event.key === "Escape" ? (e[0].hide(), n3.destroy(), true) : (r = n3.ref) == null ? void 0 : r.onKeyDown(t);
          },
          onExit() {
            e[0].destroy(), n3.destroy();
          }
        };
      }
    }, YR = {
      // default
      BackColor: oR.configure({
        multicolor: true
      }),
      Focus: iR,
      ForeColor: aR,
      FontFamily: sR,
      Image: eb,
      Link: ub,
      TextAlign: dR.configure({
        types: ["heading", "paragraph"]
      }),
      // task
      TaskItem: cR,
      TaskList: uR.configure({
        itemTypeName: "taskItem"
      }),
      Underline: LR,
      Typography: DR,
      // Custom extensions
      OSlash: $R.configure({
        suggestion: Lf
      }),
      OSlashZh: FR.configure({
        suggestion: Lf
      }),
      // // custom
      // OTOC: TOC,
      // OModelViewer: ModelViewer,
      OBlockquote: X1,
      OCallout: nT,
      OCodeBlock: $N,
      OColorHighlighter: FN,
      OHeading: HN,
      OHorizontalRule: WN,
      OImage: JN,
      OLink: vM.configure({
        openOnClick: false
      }),
      OParagraph: kM,
      OTrailingNode: FA,
      // OColumnExtension: ColumnExtension,
      // OColon: Colon.configure({
      //   suggestion: colonSuggestion
      // }),
      OUniqueID: KA.configure({
        attributeName: "data-id",
        enableRender: false,
        types: ["heading", "paragraph"]
      }),
      OVideo: ZA
    };
    class XR {
      constructor(e) {
        return YR[e];
      }
    }
    const ZR = [
      PA,
      CA.configure({
        resizable: true
      }),
      Sb,
      LA,
      NA
    ];
    kb.configure({
      resizable: true
    });
    const QR = ["data-theme"], eI = /* @__PURE__ */ defineComponent({
      __name: "YiiEditor",
      props: {
        content: {
          type: [String, Object],
          default: ""
        },
        editable: {
          type: Boolean,
          default: true
        },
        locale: {
          type: String,
          default: "en"
        },
        darkMode: {
          type: Boolean,
          default: false
        },
        showMainMenu: {
          type: Boolean,
          default: false
        },
        showBubbleMenu: {
          type: Boolean,
          default: false
        },
        showFloatingMenu: {
          type: Boolean,
          default: false
        },
        showSideMenu: {
          type: Boolean,
          default: false
        },
        showSideNode: {
          type: Boolean,
          default: false
        },
        showContent: {
          type: Boolean,
          default: true
        },
        showGuide: {
          type: Boolean,
          default: false
        },
        scrollable: {
          type: Boolean,
          default: false
        },
        editorProps: {
          type: Object,
          default: function() {
            return {};
          }
        },
        extensions: {
          type: Array,
          default: function() {
            return [];
          }
        },
        mainMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        bubbleMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        floatingMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        pageView: {
          type: String,
          default: "page"
        },
        options: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["transaction", "update"],
      setup(n3, { expose: e, emit: t }) {
        const r = n3, o = t, { tr: i } = Le(), s = ref(false), a = ref("en"), l = ref(false);
        provide("darkMode", s), provide("locale", a), provide("sideNode", l);
        const c2 = computed(() => m()), u = tS({
          editable: r.editable,
          content: r.content,
          extensions: c2.value,
          onUpdate: () => {
            var w, _;
            const g = (w = u.value) == null ? void 0 : w.getJSON(), b = (_ = u.value) == null ? void 0 : _.getHTML();
            o("update", { json: g, html: b });
          },
          onTransaction: ({ editor: g, transaction: b }) => {
            o("transaction", { editor: g, transaction: b });
          }
        }), d = computed(() => ({
          editor: u.value,
          menu: r.mainMenu
        })), p2 = computed(() => ({
          editor: u.value,
          menu: r.bubbleMenu
        })), f = computed(() => ({
          editor: u.value,
          menu: r.floatingMenu
        })), h2 = computed(() => ({
          editor: u.value,
          menu: []
        }));
        function m() {
          const g = [];
          g.push(
            EM.configure({
              placeholder: ({ editor: w, node: _, pos: v }) => {
                if (_.type.name === "heading") {
                  const T = _.attrs.level;
                  return v > 0 ? `H${T}` : i("label.untitled");
                } else return _.type.name === "paragraph" ? i("label.typeForCommands") : "";
              }
            })
          ), g.push(QS), g.push(
            XS.configure({
              blockquote: r.extensions.includes("OBlockquote") ? false : {},
              codeBlock: false,
              heading: r.extensions.includes("OHeading") ? false : {
                levels: [1, 2, 3, 4, 5]
              },
              paragraph: r.extensions.includes("OParagraph") ? false : {},
              dropcursor: {
                width: 5,
                color: "skyblue",
                class: "yiitap-dropcursor"
              },
              horizontalRule: false
            })
          ), console.log("default", Df);
          const b = Df.concat(r.extensions);
          for (const w of b)
            if (typeof w == "string") {
              if (!tR.includes(w))
                continue;
              switch (w) {
                case "Table":
                  g.push(...ZR);
                  break;
                default:
                  try {
                    const _ = new XR(w);
                    g.push(_), console.log("dynamic extension", w, _);
                  } catch (_) {
                    console.error(_.message);
                  }
                  break;
              }
            } else
              g.push(w);
          return g;
        }
        return watch(
          () => r.darkMode,
          (g) => {
            s.value = g;
          }
        ), watch(
          () => r.locale,
          (g) => {
            a.value = g;
          }
        ), watch(
          () => r.editable,
          (g) => {
            var b;
            (b = u.value) == null || b.setEditable(g);
          }
        ), onBeforeMount(() => {
          s.value = r.darkMode, a.value = r.locale, l.value = !r.showSideMenu && r.showSideNode;
        }), e({
          editor: u,
          darkModeAlt: s,
          localeAlt: a
        }), (g, b) => {
          var w, _, v;
          return openBlock(), createElementBlock("main", {
            class: "yiitap yiitap-editor",
            "data-theme": s.value ? "dark" : ""
          }, [
            n3.showMainMenu ? (openBlock(), createBlock(A1, mergeProps({ key: 0 }, d.value, { class: "desktop-only" }), {
              left: withCtx(() => [
                renderSlot(g.$slots, "toolbar-left")
              ]),
              right: withCtx(() => [
                renderSlot(g.$slots, "toolbar-right")
              ]),
              _: 3
            }, 16)) : createCommentVNode("", true),
            (w = unref(u)) != null && w.isEditable && n3.showBubbleMenu ? (openBlock(), createBlock(D1, normalizeProps(mergeProps({ key: 1 }, p2.value)), null, 16)) : createCommentVNode("", true),
            (_ = unref(u)) != null && _.isEditable && n3.showFloatingMenu ? (openBlock(), createBlock(P1, normalizeProps(mergeProps({ key: 2 }, f.value)), null, 16)) : createCommentVNode("", true),
            (v = unref(u)) != null && v.isEditable && n3.showSideMenu ? (openBlock(), createBlock(J1, normalizeProps(mergeProps({ key: 3 }, h2.value)), null, 16)) : createCommentVNode("", true),
            createVNode(unref(Q_), {
              class: normalizeClass(["editor-content", n3.pageView]),
              editor: unref(u)
            }, null, 8, ["class", "editor"])
          ], 8, QR);
        };
      }
    });
    const BasicFeaturesArticle = `
<h1>Introduction</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em> </em></strong></span>is a WYSIWYG rich-text block-based editor built on top of <span style="font-family: &quot;Arial Black&quot;">tiptap</span>.</p><h2>Callout</h2><div icon="" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>Announcement</strong></p><p>Make writing stand out.</p></div><h2>Blockquote</h2><blockquote><p>A gentleman should constantly strike to become stronger just like the evolution of the universe.</p><p>A gentleman should generously cultivate to become tolerant just like the earth bears everything on it.</p></blockquote><h2>Table</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th4</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">Cell Background</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>Merged Cell</p></td></tr></tbody></table></table-wrapper><h2>Image</h2><blockquote><p>A picture is worth a thousand of words.</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="Title" size="large" ratio="5/1"></p><h2>Video</h2><video caption="Caption"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>Model View</h2><h2>List</h2><h3>Unordered List</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>Ordered List</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>Task</h3><ul data-type="taskList"><li data-checked="true" data-type="taskItem"><label><input type="checkbox" checked="checked"><span></span></label><div><p>Model Viewer</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Diagram</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Math Formula</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Draggable handler for all blocks</p></div></li></ul><h2>Code Block</h2><blockquote><p>Friendly to developer, with syntax highlight.</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Shortcut</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Remarks</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Heading</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Blockquote</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code Block</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>Typography</h2><h3>Heading 3</h3><h4>Heading 4</h4><h3>Paragraph</h3><p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p><p>Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p><p>Whether 60 or 16, there is in every human beings heart the lure of wonder, the unfailing childlike appetite of whats next and the joy of the game of living. In the center of your heart and my heart there is a wireless station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the Infinite, so long are you young.</p><p>When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at 20, but as long as your aerials are up, to catch waves of optimism, there is hope you may die young at 80.</p><h3>Smart</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Input</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Output</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>Copyright</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Right</p></td><td colspan="1" rowspan="1" background=""><p><code>(r)</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Not equal</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Ratio</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code>&nbsp;&nbsp;<code>1/4</code>&nbsp;&nbsp;<code>3/4</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>  &nbsp;</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Dash</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h3>Color Highlighter</h3><p>#abc, #00ff00, Info color #2080f0</p><h2>Text</h2><p><span style="font-family: &quot;Arial Black&quot;"><strong>Bold text</strong></span></p><p><em>Italic text</em></p><p><u>Underline text</u></p><p><s>Strike through text</s></p><hr><p><code>Inline code</code></p><p><span style="color: rgb(255, 77, 79)">Text with color</span></p><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">Text with highlight background</mark></p><p></p>
`;
    const BasicFeaturesArticleZh = `
<h1>Yiitap</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em>&nbsp;</em></strong></span><a target="_blank" rel="noopener noreferrer nofollow" href="https://tiptap.dev/"><span style="font-family: system-ui">Tiptap</span></a></p><h2></h2><div icon="" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong></strong></p><p></p></div><h2></h2><blockquote><p><br></p></blockquote><h2></h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th3</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)"></span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><blockquote><p></p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="" size="large" ratio="5/1"></p><h2></h2><video caption=""><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2></h2><h3></h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3></h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3></h3><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li></ul><h2></h2><blockquote><p></p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><h3> 3</h3><h4> 4</h4><h3></h3><p></p><p></p><p></p><p></p><p></p><h3></h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code>&nbsp; <code>(r)</code>&nbsp; <code>(tm)</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>   </p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><ul><li><p><span style="font-family: &quot;Arial Black&quot;"><strong></strong></span></p></li><li><p><em></em></p></li><li><p><u></u></p></li><li><p><s></s></p></li><li><p><code></code></p></li><li><p><span style="color: rgb(255, 77, 79)"> </span></p></li><li><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit"></mark></p></li></ul><p></p>
`;
    const _hoisted_1 = { class: "layout-toolbar" };
    const _hoisted_2 = /* @__PURE__ */ createBaseVNode("section", { class: "info" }, [
      /* @__PURE__ */ createBaseVNode("img", {
        src: _imports_0,
        alt: "Logo"
      }),
      /* @__PURE__ */ createBaseVNode("div", { class: "title" }, "Yiitap Editor")
    ], -1);
    const _hoisted_3 = { class: "actions" };
    const _hoisted_4 = { class: "toolbar" };
    const _hoisted_5 = { class: "layout-content" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "Demo",
      emits: ["mode"],
      setup(__props, { emit: __emit }) {
        const emit2 = __emit;
        const yiiEditor = ref();
        const locale = ref("en");
        const darkMode = ref(false);
        const editable = ref(true);
        const showDrawer = ref(false);
        provide("locale", locale);
        provide("darkMode", darkMode);
        const options = computed(() => {
          return {
            locale: locale.value,
            darkMode: darkMode.value,
            editable: editable.value,
            content: content.value,
            showMainMenu: false,
            showBubbleMenu: true,
            showFloatingMenu: true,
            showSideMenu: true,
            // showSideNode: true,
            pageView: "page",
            mainMenu: [
              "bold",
              "italic",
              "text-format-dropdown",
              "separator",
              "heading",
              "font-family",
              "text-color-dropdown",
              "fore-color",
              "back-color",
              "clearFormat",
              "separator",
              "align-dropdown",
              "separator",
              "horizontalRule",
              "blockquote",
              "list-dropdown",
              "codeBlock",
              "link",
              "image",
              "video",
              "table",
              "callout",
              "emoji"
            ],
            extensions: [
              "OBlockquote",
              "OCallout",
              "OCodeBlock",
              "OColorHighlighter",
              "OHeading",
              "OImage",
              "OParagraph",
              "OSlash",
              "OSlashZh",
              "OLink",
              "OTrailingNode",
              "OVideo"
            ]
          };
        });
        const content = computed(() => {
          return locale.value === "zh" ? BasicFeaturesArticleZh : BasicFeaturesArticle;
        });
        function onToggleDrawer() {
          showDrawer.value = !showDrawer.value;
        }
        function onGithub() {
          window.open("https://github.com/yiitap/yiitap", "_blank");
        }
        function onMode() {
          emit2("mode", darkMode.value);
        }
        function onUpdate({ json, html }) {
          console.log("update", html);
        }
        watch(locale, (newValue) => {
          var _a2;
          (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor.commands.setContent(content.value);
        });
        onMounted(() => {
          console.log("ref", yiiEditor.value);
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("section", {
            class: normalizeClass(["page-demo", { dark: darkMode.value }])
          }, [
            createBaseVNode("section", _hoisted_1, [
              createBaseVNode("header", null, [
                _hoisted_2,
                createBaseVNode("section", _hoisted_3, [
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onGithub
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ye), { name: "github" })
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onToggleDrawer
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ye), { name: "menu" })
                    ]),
                    _: 1
                  })
                ])
              ]),
              createBaseVNode("div", _hoisted_4, [
                createVNode(unref(A1), {
                  editor: (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor,
                  menu: options.value.mainMenu,
                  "data-theme": darkMode.value ? "dark" : ""
                }, null, 8, ["editor", "menu", "data-theme"])
              ])
            ]),
            createBaseVNode("section", _hoisted_5, [
              createVNode(unref(eI), mergeProps({
                ref_key: "yiiEditor",
                ref: yiiEditor
              }, options.value, { onUpdate }), null, 16)
            ]),
            createVNode(unref(NDrawer), {
              show: showDrawer.value,
              "onUpdate:show": _cache[3] || (_cache[3] = ($event) => showDrawer.value = $event),
              "default-width": 400,
              placement: "right",
              resizable: ""
            }, {
              default: withCtx(() => [
                createVNode(unref(NDrawerContent), {
                  title: "Yii Editor",
                  closable: ""
                }, {
                  default: withCtx(() => [
                    createVNode(unref(NForm), {
                      ref: "form",
                      "label-placement": "left",
                      "label-width": "auto"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), { label: "Language" }, {
                          default: withCtx(() => [
                            createVNode(unref(NRadioGroup), {
                              value: locale.value,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => locale.value = $event),
                              name: "radiogroup1"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NSpace), null, {
                                  default: withCtx(() => [
                                    createVNode(unref(NRadio), { value: "en" }, {
                                      default: withCtx(() => [
                                        createTextVNode(" English ")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(unref(NRadio), { value: "zh" }, {
                                      default: withCtx(() => [
                                        createTextVNode("  ")
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Mode" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: darkMode.value,
                              "onUpdate:value": [
                                _cache[1] || (_cache[1] = ($event) => darkMode.value = $event),
                                onMode
                              ]
                            }, {
                              checked: withCtx(() => [
                                createTextVNode(" Dark ")
                              ]),
                              unchecked: withCtx(() => [
                                createTextVNode(" Light ")
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Edit" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: editable.value,
                              "onUpdate:value": _cache[2] || (_cache[2] = ($event) => editable.value = $event)
                            }, {
                              checked: withCtx(() => [
                                createTextVNode(" Editable ")
                              ]),
                              unchecked: withCtx(() => [
                                createTextVNode(" Readonly ")
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["show"])
          ], 2);
        };
      }
    });
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const darkMode = ref(false);
        const theme = computed(() => {
          return darkMode.value ? darkTheme : null;
        });
        function onMode(value) {
          darkMode.value = value;
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(NConfigProvider), { theme: theme.value }, {
            default: withCtx(() => [
              createVNode(_sfc_main$1, { onMode })
            ]),
            _: 1
          }, 8, ["theme"]);
        };
      }
    });
    const app = createApp(_sfc_main);
    app.mount("#app");
  }
});
export default require_index_001();
