var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-DGDDZUy_.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map[key] = 1;
      return (val) => val in map;
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el2) => {
      const i2 = arr.indexOf(el2);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$9 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$9.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$2 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props) return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length) return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a.length; i2++) {
        equal = looseEqual(a[i2], b[i2]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b) return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i2) => {
              entries[stringifySymbol(key, i2) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$2(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i2 = "") => {
      var _a2;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i2})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i2, l;
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].pause();
            }
          }
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i2, l;
            if (this.scopes) {
              for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
                this.scopes[i2].resume();
              }
            }
            for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
              this.effects[i2].resume();
            }
          }
        }
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          this.effects.length = 0;
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeSub;
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn) {
        this.fn = fn;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= -65;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= -3;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= -2;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed = false) {
      sub.flags |= 8;
      if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= -9;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head;
      let tail = sub.depsTail;
      let link = tail;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail) tail = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head;
      sub.depsTail = tail;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= -17;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= -3;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= -3;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= -5;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (false) ;
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      ""
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      ""
    );
    const ARRAY_ITERATE_KEY = Symbol(
      ""
    );
    function track(target, type, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        {
          dep.track();
        }
      }
    }
    function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run2 = (dep) => {
        if (dep) {
          {
            dep.trigger();
          }
        }
      };
      startBatch();
      if (type === "clear") {
        depsMap.forEach(run2);
      } else {
        const targetIsArray = isArray$1(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
              run2(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run2(depsMap.get(key));
          }
          if (isArrayIndex) {
            run2(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type) {
            case "add":
              if (!targetIsArray) {
                run2(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run2(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run2(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run2(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  run2(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap(target)) {
                run2(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function getDepFromReactive(object, key) {
      const depMap = targetMap.get(object);
      return depMap && depMap.get(key);
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn, thisArg) {
        return apply$2(this, "every", fn, thisArg, void 0, arguments);
      },
      filter(fn, thisArg) {
        return apply$2(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn, thisArg) {
        return apply$2(this, "find", fn, thisArg, toReactive, arguments);
      },
      findIndex(fn, thisArg) {
        return apply$2(this, "findIndex", fn, thisArg, void 0, arguments);
      },
      findLast(fn, thisArg) {
        return apply$2(this, "findLast", fn, thisArg, toReactive, arguments);
      },
      findLastIndex(fn, thisArg) {
        return apply$2(this, "findLastIndex", fn, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn, thisArg) {
        return apply$2(this, "forEach", fn, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn, thisArg) {
        return apply$2(this, "map", fn, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn, ...args) {
        return reduce(this, "reduce", fn, args);
      },
      reduceRight(fn, ...args) {
        return reduce(this, "reduceRight", fn, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn, thisArg) {
        return apply$2(this, "some", fn, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto$1 = Array.prototype;
    function apply$2(self2, method, fn, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto$1[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn.call(this, toReactive(item), index, self2);
          };
        } else if (fn.length > 2) {
          wrappedFn = function(item, index) {
            return fn.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    function hasOwnProperty$8(key) {
      if (!isSymbol$1(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          let fn;
          if (targetIsArray && (fn = arrayInstrumentations[key])) {
            return fn;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$8;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger$1(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap2 = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap2(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap2(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap2 = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap2(value), wrap2(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger$1(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            const oldValue = get2.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger$1(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger$1(target, "set", key, value);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            get2 ? get2.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger$1(target, "delete", key, void 0);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const result = target.clear();
            if (hadItems) {
              trigger$1(
                target,
                "clear",
                void 0,
                void 0
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, isShallow2) {
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
      }
      get value() {
        {
          this.dep.track();
        }
        return this._value;
      }
      set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          {
            this.dep.trigger();
          }
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this["__v_isRef"] = true;
        this._value = void 0;
        const dep = this.dep = new Dep();
        const { get: get2, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
        this._get = get2;
        this._set = set;
      }
      get value() {
        return this._value = this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
      }
      get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
      }
      get value() {
        return this._value = this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$2(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(fn, setter, isSSR) {
        this.fn = fn;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        }
      }
      get value() {
        const link = this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction$2(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      return cRef;
    }
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      }
    }
    function watch$1(source, cb2, options = EMPTY_OBJ) {
      const { immediate, deep, once, scheduler: scheduler2, augmentJob, call: call2 } = options;
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$2(s)) {
            return call2 ? call2(s, 2) : s();
          } else ;
        });
      } else if (isFunction$2(source)) {
        if (cb2) {
          getter = call2 ? () => call2(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb2 && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope && scope.active) {
          remove(scope.effects, effect2);
        }
      };
      if (once && cb2) {
        const _cb = cb2;
        cb2 = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb2) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call2 ? call2(cb2, 3, args) : (
                // @ts-expect-error
                cb2(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler2 ? () => scheduler2(job, false) : job;
      boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call2) {
            call2(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      if (cb2) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler2) {
        scheduler2(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$1(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], depth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$2(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack$1 = [];
    let isWarning = false;
    function warn$1$1(msg2, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg2 + args.map((a) => {
              var _a2, _b2;
              return (_b2 = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b2 : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack$1[stack$1.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close2 = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$2(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction$2(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$1(fn)) {
        const values = [];
        for (let i2 = 0; i2 < fn.length; i2++) {
          values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
      if (throwInProd) {
        throw err;
      } else {
        console.error(err);
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb2) {
      if (!isArray$1(cb2)) {
        if (activePostFlushCbs && cb2.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb2);
        } else if (!(cb2.flags & 1)) {
          pendingPostFlushCbs.push(cb2);
          cb2.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb2);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
      for (; i2 < queue.length; i2++) {
        const cb2 = queue[i2];
        if (cb2 && cb2.flags & 2) {
          if (instance && cb2.id !== instance.uid) {
            continue;
          }
          queue.splice(i2, 1);
          i2--;
          if (cb2.flags & 4) {
            cb2.flags &= -2;
          }
          cb2();
          if (!(cb2.flags & 4)) {
            cb2.flags &= -2;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb2 = activePostFlushCbs[postFlushIndex];
          if (cb2.flags & 4) {
            cb2.flags &= -2;
          }
          if (!(cb2.flags & 8)) cb2();
          cb2.flags &= -2;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (false) ;
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= -2;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs();
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn, ctx2 = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx2) return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx2);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers2 = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$2(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers: modifiers2
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n12 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const mount2 = (container2, anchor2) => {
            if (shapeFlag & 16) {
              if (parentComponent && parentComponent.isCE) {
                parentComponent.ce._teleportTarget = container2;
              }
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountToTarget = () => {
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = prepareAnchor(target, n2, createText, insert);
            if (target) {
              if (namespace2 !== "svg" && isTargetSVG(target)) {
                namespace2 = "svg";
              } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
                namespace2 = "mathml";
              }
              if (!disabled) {
                mount2(target, targetAnchor);
                updateCssVars(n2, false);
              }
            }
          };
          if (disabled) {
            mount2(container, mainAnchor);
            updateCssVars(n2, true);
          }
          if (isTeleportDeferred(n2.props)) {
            queuePostRenderEffect(() => {
              mountToTarget();
              n2.el.__isMounted = true;
            }, parentSuspense);
          } else {
            mountToTarget();
          }
        } else {
          if (isTeleportDeferred(n2.props) && !n12.el.__isMounted) {
            queuePostRenderEffect(() => {
              TeleportImpl.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
              delete n12.el.__isMounted;
            }, parentSuspense);
            return;
          }
          n2.el = n12.el;
          n2.targetStart = n12.targetStart;
          const mainAnchor = n2.anchor = n12.anchor;
          const target = n2.target = n12.target;
          const targetAnchor = n2.targetAnchor = n12.targetAnchor;
          const wasDisabled = isTeleportDisabled(n12.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace2 === "svg" || isTargetSVG(target)) {
            namespace2 = "svg";
          } else if (namespace2 === "mathml" || isTargetMathML(target)) {
            namespace2 = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            traverseStaticChildren(n12, n2, true);
          } else if (!optimized) {
            patchChildren(
              n12,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n12.props && n2.props.to !== n12.props.to) {
                n2.props.to = n12.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n12.props && n12.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
          updateCssVars(n2, disabled);
        }
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            unmount2(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el: el2, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el2, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode: parentNode2, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (disabled) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode2(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode, disabled);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode, isDisabled) {
      const ctx2 = vnode.ctx;
      if (ctx2 && ctx2.ut) {
        let node, anchor;
        if (isDisabled) {
          node = vnode.el;
          anchor = vnode.anchor;
        } else {
          node = vnode.targetStart;
          anchor = vnode.targetAnchor;
        }
        while (node && node !== anchor) {
          if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx2.uid);
          node = node.nextSibling;
        }
        ctx2.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const child = findNonCommentChild(children);
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getInnerChild$1(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          if (innerChild.type !== Comment) {
            setTransitionHooks(innerChild, enterHooks);
          }
          let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            let leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (!(instance.job.flags & 8)) {
                  instance.update();
                }
                delete leavingHooks.afterLeave;
                oldInnerChild = void 0;
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el2[leaveCbKey] = () => {
                  earlyRemove();
                  el2[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
                enterHooks.delayedLeave = () => {
                  delayedLeave();
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
              };
            } else {
              oldInnerChild = void 0;
            }
          } else if (oldInnerChild) {
            oldInnerChild = void 0;
          }
          return child;
        };
      }
    };
    function findNonCommentChild(children) {
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      return child;
    }
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1)) done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el2) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el2[leaveCbKey]) {
            el2[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el2]);
        },
        enter(el2) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el2[enterCbKey$1] = (cancelled) => {
            if (called) return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el2]);
            } else {
              callHook2(afterHook, [el2]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el2[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el2, done]);
          } else {
            done();
          }
        },
        leave(el2, remove2) {
          const key2 = String(vnode.key);
          if (el2[enterCbKey$1]) {
            el2[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el2]);
          let called = false;
          const done = el2[leaveCbKey] = (cancelled) => {
            if (called) return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el2]);
            } else {
              callHook2(onAfterLeave, [el2]);
            }
            el2[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el2, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone) postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getInnerChild$1(vnode) {
      if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) {
          return findNonCommentChild(vnode.children);
        }
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$2(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = children[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment$1) {
          if (child.patchFlag & 128) keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$2(options) ? (
        // #8236: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i2) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$2(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    getGlobalThis().requestIdleCallback || ((cb2) => setTimeout(cb2, 1));
    getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    function renderList(source, renderItem, cache2, index) {
      let ret;
      const cached = cache2;
      const sourceIsArray = isArray$1(source);
      if (sourceIsArray || isString(source)) {
        const sourceIsReactiveArray = sourceIsArray && isReactive(source);
        let needsWrap = false;
        if (sourceIsReactiveArray) {
          needsWrap = !isShallow(source);
          source = shallowReadArray(source);
        }
        ret = new Array(source.length);
        for (let i2 = 0, l = source.length; i2 < l; i2++) {
          ret[i2] = renderItem(
            needsWrap ? toReactive(source[i2]) : source[i2],
            i2,
            void 0,
            cached
          );
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached)
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached);
          }
        }
      } else {
        ret = [];
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(
          Fragment$1,
          null,
          [createVNode("slot", props, fallback)],
          64
        );
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode$1(slot(props));
      const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key;
      const rendered = createBlock(
        Fragment$1,
        {
          key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
          ""
        },
        validSlotContent || [],
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode$1(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment$1 && !ensureValidVNode$1(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i2) => {
      if (!i2) return null;
      if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $host: (i2) => i2.ce,
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => {
          queueJob(i2.update);
        }),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx: ctx2, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx2[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
            accessCache[key] = 4;
            return ctx2[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx: ctx2 } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx2[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx2 = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$2(methodHandler)) {
            {
              ctx2[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data)) ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set
          });
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx2, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx2, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx2[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx2, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString(raw)) {
        const handler = ctx2[raw];
        if (isFunction$2(handler)) {
          {
            watch(getter, handler);
          }
        }
      } else if (isFunction$2(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
        } else {
          const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
          if (isFunction$2(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$1(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from[key]) : from[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from) {
      if (!from) {
        return to2;
      }
      if (!to2) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$2(to2) ? to2.call(this, this) : to2,
          isFunction$2(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to2, from) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from) {
      return to2 ? [...new Set([].concat(to2, from))] : from;
    }
    function mergeObjectOptions(to2, from) {
      return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
    }
    function mergeEmitsOrPropsOptions(to2, from) {
      if (to2) {
        if (isArray$1(to2) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to2, from) {
      if (!to2) return from;
      if (!from) return to2;
      const merged = extend(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from) {
        merged[key] = mergeAsArray(to2[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$2(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted2 = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin2, ...options) {
            if (installedPlugins.has(plugin2)) ;
            else if (plugin2 && isFunction$2(plugin2.install)) {
              installedPlugins.add(plugin2);
              plugin2.install(app2, ...options);
            } else if (isFunction$2(plugin2)) {
              installedPlugins.add(plugin2);
              plugin2(app2, ...options);
            } else ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace2) {
            if (!isMounted2) {
              const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace2 === true) {
                namespace2 = "svg";
              } else if (namespace2 === false) {
                namespace2 = void 0;
              }
              {
                render2(vnode, rootContainer, namespace2);
              }
              isMounted2 = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getComponentPublicInstance(vnode.component);
            }
          },
          onUnmount(cleanupFn) {
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted2) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app2._instance,
                16
              );
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
      }
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2) needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$1(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type = propType[index];
                const typeName = isFunction$2(type) && type.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$2(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx2) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false) ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx2);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx2 = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$2(value)) {
          slots[key] = normalizeSlot(key, value, ctx2);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n12, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n12 === n2) {
          return;
        }
        if (n12 && !isSameVNodeType(n12, n2)) {
          anchor = getNextHostNode(n12);
          unmount2(n12, parentComponent, parentSuspense, true);
          n12 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n12, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n12, n2, container, anchor);
            break;
          case Static:
            if (n12 == null) {
              mountStaticNode(n2, container, anchor, namespace2);
            }
            break;
          case Fragment$1:
            processFragment(
              n12,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n12,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n12 && n12.ref, parentSuspense, n2 || n12, !n2);
        }
      };
      const processText = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el2 = n2.el = n12.el;
          if (n2.children !== n12.children) {
            hostSetText(el2, n2.children);
          }
        }
      };
      const processCommentNode = (n12, n2, container, anchor) => {
        if (n12 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n12.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostInsert(el2, container, nextSibling);
          el2 = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el: el2, anchor }) => {
        let next;
        while (el2 && el2 !== anchor) {
          next = hostNextSibling(el2);
          hostRemove(el2);
          el2 = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace2 = "svg";
        } else if (n2.type === "math") {
          namespace2 = "mathml";
        }
        if (n12 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n12,
            n2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
          vnode.type,
          namespace2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace2),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el2, key, null, props[key], namespace2, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el2, "value", null, props.value, namespace2);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el2);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el2, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el2,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n12, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const el2 = n2.el = n12.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n12.patchFlag & 16;
        const oldProps = n12.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n12, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el2, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n12.dynamicChildren,
            dynamicChildren,
            el2,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n12,
            n2,
            el2,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el2, oldProps, newProps, parentComponent, namespace2);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el2, "class", null, newProps.class, namespace2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n12.children !== n2.children) {
              hostSetElementText(el2, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el2, oldProps, newProps, parentComponent, namespace2);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n12);
            dirs && invokeDirectiveHook(n2, n12, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment$1 || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el2, oldProps, newProps, parentComponent, namespace2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el2,
                  key,
                  oldProps[key],
                  null,
                  namespace2,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace2);
          }
        }
      };
      const processFragment = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n12 ? n12.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n12 ? n12.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n12 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n12.dynamicChildren) {
            patchBlockChildren(
              n12.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n12,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n12,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n12 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              optimized
            );
          }
        } else {
          updateComponent(n12, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      };
      const updateComponent = (n12, n2, optimized) => {
        const instance = n2.component = n12.component;
        if (shouldUpdateComponent(n12, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n12.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el: el2, props } = initialVNode;
            const { bm: bm2, m, parent, root: root2, type } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm2) {
              invokeArrayFns(bm2);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            {
              if (root2.ce) {
                root2.ce._injectChildStyle(type);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace2
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu: bu2, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu2) {
              invokeArrayFns(bu2);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n12, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
        const c12 = n12 && n12.children;
        const prevShapeFlag = n12 ? n12.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c12,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c12, parentComponent, parentSuspense);
          }
          if (c2 !== c12) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c12,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c12, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c12, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        c12 = c12 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c12.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c12[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c12,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c12, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e12 = c12.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e12 && i2 <= e2) {
          const n12 = c12[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e12 && i2 <= e2) {
          const n12 = c12[e12];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n12, n2)) {
            patch(
              n12,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e12--;
          e2--;
        }
        if (i2 > e12) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e12) {
            unmount2(c12[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s12 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
          for (i2 = s12; i2 <= e12; i2++) {
            const prevChild = c12[i2];
            if (patched >= toBePatched) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount2(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment$1) {
          hostInsert(el2, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el2);
            hostInsert(el2, container, anchor);
            queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el2, container, anchor);
            const performLeave = () => {
              leave(el2, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el2, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el2, container, anchor);
        }
      };
      const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el: el2, anchor, transition } = vnode;
        if (type === Fragment$1) {
          {
            removeFragment(el2, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el2);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el2, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, job, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (job) {
          job.flags |= 8;
          unmount2(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i2 = start; i2 < children.length; i2++) {
          unmount2(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el2 = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el2 && el2[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el2;
      };
      let isFlushing = false;
      const render2 = (vnode, container, namespace2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount2(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace2
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount2,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= -33;
        job.flags &= -5;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n12, n2, shallow = false) {
      const ch1 = n12.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c12 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c12.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c12, c2);
          }
          if (c2.type === Text) {
            c2.el = c12.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u, v, c2;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c2 = u + v >> 1;
            if (arr[result[c2]] < arrI) {
              u = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i2] = result[u - 1];
            }
            result[u] = i2;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i2 = 0; i2 < hooks.length; i2++)
          hooks[i2].flags |= 8;
      }
    }
    const ssrContextKey$1 = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx2 = inject(ssrContextKey$1);
        return ctx2;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watch(source, cb2, options) {
      return doWatch(source, cb2, options);
    }
    function doWatch(source, cb2, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once } = options;
      const baseWatchOptions = extend({}, options);
      const runsImmediately = cb2 && immediate || !cb2 && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx2 = useSSRContext();
          ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb2) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb2, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb2;
      if (isFunction$2(value)) {
        cb2 = value;
      } else {
        cb2 = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb2.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx2, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx2;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers2 = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers2) {
        if (modifiers2.trim) {
          args = rawArgs.map((a) => isString(a) ? a.trim() : a);
        }
        if (modifiers2.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx: ctx2,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx2
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false) ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        setTransitionHooks(root2, vnode.transition);
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el2) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el2;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const Fragment$1 = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n12, n2) {
      return n12.type === n2.type && n12.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode2 = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode2 && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode2 = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style2)) {
          if (isProxy(style2) && !isArray$1(style2)) {
            style2 = extend({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$2(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode2,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment$1,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$2(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup: setup2 } = Component;
      if (setup2) {
        pauseTracking();
        const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup2,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        const isAsyncSetup = isPromise(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult);
        }
      } else {
        finishComponentSetup(instance);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$2(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else ;
      finishComponentSetup(instance);
    }
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$2(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c2;
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.5.13";
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt$1 = typeof window !== "undefined" && window.trustedTypes;
    if (tt$1) {
      try {
        policy = /* @__PURE__ */ tt$1.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc$2 = typeof document !== "undefined" ? document : null;
    const templateContainer = doc$2 && /* @__PURE__ */ doc$2.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace2, is2, props) => {
        const el2 = namespace2 === "svg" ? doc$2.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc$2.createElementNS(mathmlNS, tag) : is2 ? doc$2.createElement(tag, { is: is2 }) : doc$2.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el2.setAttribute("multiple", props.multiple);
        }
        return el2;
      },
      createText: (text) => doc$2.createTextNode(text),
      createComment: (text) => doc$2.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el2, text) => {
        el2.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc$2.querySelector(selector),
      setScopeId(el2, id2) {
        el2.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace2, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace2 === "svg" || namespace2 === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const decorate$1 = (t) => {
      t.displayName = "Transition";
      t.props = TransitionPropsValidators;
      return t;
    };
    const Transition = /* @__PURE__ */ decorate$1(
      (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration: duration2,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration2);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el2, isAppear, done, isCancelled) => {
        el2._enterCancelled = isCancelled;
        removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el2, done) => {
        el2._isLeaving = false;
        removeTransitionClass(el2, leaveFromClass);
        removeTransitionClass(el2, leaveToClass);
        removeTransitionClass(el2, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el2, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el2, isAppear, done);
          callHook(hook, [el2, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el2, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el2) {
          callHook(onBeforeEnter, [el2]);
          addTransitionClass(el2, enterFromClass);
          addTransitionClass(el2, enterActiveClass);
        },
        onBeforeAppear(el2) {
          callHook(onBeforeAppear, [el2]);
          addTransitionClass(el2, appearFromClass);
          addTransitionClass(el2, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el2, done) {
          el2._isLeaving = true;
          const resolve2 = () => finishLeave(el2, done);
          addTransitionClass(el2, leaveFromClass);
          if (!el2._enterCancelled) {
            forceReflow();
            addTransitionClass(el2, leaveActiveClass);
          } else {
            addTransitionClass(el2, leaveActiveClass);
            forceReflow();
          }
          nextFrame(() => {
            if (!el2._isLeaving) {
              return;
            }
            removeTransitionClass(el2, leaveFromClass);
            addTransitionClass(el2, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el2, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el2, resolve2]);
        },
        onEnterCancelled(el2) {
          finishEnter(el2, false, void 0, true);
          callHook(onEnterCancelled, [el2]);
        },
        onAppearCancelled(el2) {
          finishEnter(el2, true, void 0, true);
          callHook(onAppearCancelled, [el2]);
        },
        onLeaveCancelled(el2) {
          finishLeave(el2);
          callHook(onLeaveCancelled, [el2]);
        }
      });
    }
    function normalizeDuration(duration2) {
      if (duration2 == null) {
        return null;
      } else if (isObject$1(duration2)) {
        return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
      } else {
        const n = NumberOf(duration2);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.add(c2));
      (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el2, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el2.classList.remove(c2));
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el2[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb2) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb2);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
      const id2 = el2._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el2._endId) {
          resolve2();
        }
      };
      if (explicitTimeout != null) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el2.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el2 && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el2.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el2, expectedType) {
      const styles = window.getComputedStyle(el2);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      if (s === "auto") return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el2, value, isSVG2) {
      const transitionClasses = el2[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el2.removeAttribute("class");
      } else if (isSVG2) {
        el2.setAttribute("class", value);
      } else {
        el2.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el2, { value }, { transition }) {
        el2[vShowOriginalDisplay] = el2.style.display === "none" ? "" : el2.style.display;
        if (transition && value) {
          transition.beforeEnter(el2);
        } else {
          setDisplay(el2, value);
        }
      },
      mounted(el2, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el2);
        }
      },
      updated(el2, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el2);
            setDisplay(el2, true);
            transition.enter(el2);
          } else {
            transition.leave(el2, () => {
              setDisplay(el2, false);
            });
          }
        } else {
          setDisplay(el2, value);
        }
      },
      beforeUnmount(el2, { value }) {
        setDisplay(el2, value);
      }
    };
    function setDisplay(el2, value) {
      el2.style.display = value ? el2[vShowOriginalDisplay] : "none";
      el2[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el2, prev, next) {
      const style2 = el2.style;
      const isCssString = isString(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style2, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style2[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style2.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el2.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el2) {
        el2[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
        if (el2[vShowHidden]) {
          style2.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style2, name, v));
      } else {
        if (val == null) val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el2, key, value, isSVG2, instance, isBoolean = isSpecialBooleanAttr(key)) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el2.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean && !includeBooleanAttr(value)) {
          el2.removeAttribute(key);
        } else {
          el2.setAttribute(
            key,
            isBoolean ? "" : isSymbol$1(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el2, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el2[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el2.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el2.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el2)) {
          el2.value = newValue;
        }
        if (value == null) {
          el2.removeAttribute(key);
        }
        el2._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el2[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el2[key] = value;
      } catch (e) {
      }
      needRemove && el2.removeAttribute(attrName || key);
    }
    function addEventListener(el2, event, handler, options) {
      el2.addEventListener(event, handler, options);
    }
    function removeEventListener(el2, event, handler, options) {
      el2.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
      const invokers = el2[veiKey] || (el2[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el2, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el2, key, prevValue, nextValue, namespace2, parentComponent) => {
      const isSVG2 = namespace2 === "svg";
      if (key === "class") {
        patchClass(el2, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG2)) {
        patchDOMProp(el2, key, nextValue);
        if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el2, key, nextValue, isSVG2, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el2._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
      ) {
        patchDOMProp(el2, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el2._trueValue = nextValue;
        } else if (key === "false-value") {
          el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el2, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el2 && isNativeOn(key) && isFunction$2(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el2.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el2.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString(value)) {
        return false;
      }
      return key in el2;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const decorate = (t) => {
      delete t.props.mode;
      return t;
    };
    const TransitionGroupImpl = /* @__PURE__ */ decorate({
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el2 = c2.el;
            const style2 = el2.style;
            addTransitionClass(el2, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb2 = el2[moveCbKey] = (e) => {
              if (e && e.target !== el2) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el2.removeEventListener("transitionend", cb2);
                el2[moveCbKey] = null;
                removeTransitionClass(el2, moveClass);
              }
            };
            el2.addEventListener("transitionend", cb2);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment$1;
          prevChildren = [];
          if (children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    });
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el2 = c2.el;
      if (el2[moveCbKey]) {
        el2[moveCbKey]();
      }
      if (el2[enterCbKey]) {
        el2[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy2 = oldPos.top - newPos.top;
      if (dx || dy2) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy2}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el2, root2, moveClass) {
      const clone = el2.cloneNode();
      const _vtc = el2[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el2, { modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el2, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el2.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el2[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el2, "change", () => {
            el2.value = el2.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el2, "compositionstart", onCompositionStart);
          addEventListener(el2, "compositionend", onCompositionEnd);
          addEventListener(el2, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el2, { value }) {
        el2.value = value == null ? "" : value;
      },
      beforeUpdate(el2, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        if (el2.composing) return;
        const elValue = (number || el2.type === "number") && !/^0\d/.test(el2.value) ? looseToNumber(el2.value) : el2.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el2 && el2.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el2.value.trim() === newValue) {
            return;
          }
        }
        el2.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el2, _, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        addEventListener(el2, "change", () => {
          const modelValue = el2._modelValue;
          const elementValue = getValue$2(el2);
          const checked = el2.checked;
          const assign = el2[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found2 = index !== -1;
            if (checked && !found2) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found2) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el2, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el2, binding, vnode) {
        el2[assignKey] = getModelAssigner(vnode);
        setChecked(el2, binding, vnode);
      }
    };
    function setChecked(el2, { value, oldValue }, vnode) {
      el2._modelValue = value;
      let checked;
      if (isArray$1(value)) {
        checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        checked = value.has(vnode.props.value);
      } else {
        if (value === oldValue) return;
        checked = looseEqual(value, getCheckboxValue(el2, true));
      }
      if (el2.checked !== checked) {
        el2.checked = checked;
      }
    }
    function getValue$2(el2) {
      return "_value" in el2 ? el2._value : el2.value;
    }
    function getCheckboxValue(el2, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el2 ? el2[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers2) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers2.includes(m))
    };
    const withModifiers = (fn, modifiers2) => {
      const cache2 = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers2.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
        for (let i2 = 0; i2 < modifiers2.length; i2++) {
          const guard = modifierGuards[modifiers2[i2]];
          if (guard && guard(event, modifiers2)) return;
        }
        return fn(event, ...args);
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render$1 = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount: mount2 } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app2._component;
        if (!isFunction$2(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount2(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    function plugin$1(options) {
      let _bPrefix = ".";
      let _ePrefix = "__";
      let _mPrefix = "--";
      let c2;
      if (options) {
        let t = options.blockPrefix;
        if (t) {
          _bPrefix = t;
        }
        t = options.elementPrefix;
        if (t) {
          _ePrefix = t;
        }
        t = options.modifierPrefix;
        if (t) {
          _mPrefix = t;
        }
      }
      const _plugin = {
        install(instance) {
          c2 = instance.c;
          const ctx2 = instance.context;
          ctx2.bem = {};
          ctx2.bem.b = null;
          ctx2.bem.els = null;
        }
      };
      function b(arg) {
        let memorizedB;
        let memorizedE;
        return {
          before(ctx2) {
            memorizedB = ctx2.bem.b;
            memorizedE = ctx2.bem.els;
            ctx2.bem.els = null;
          },
          after(ctx2) {
            ctx2.bem.b = memorizedB;
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.b = arg;
            return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
          }
        };
      }
      function e(arg) {
        let memorizedE;
        return {
          before(ctx2) {
            memorizedE = ctx2.bem.els;
          },
          after(ctx2) {
            ctx2.bem.els = memorizedE;
          },
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            context.bem.els = arg.split(",").map((v) => v.trim());
            return context.bem.els.map((el2) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el2}`).join(", ");
          }
        };
      }
      function m(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const modifiers2 = arg.split(",").map((v) => v.trim());
            function elementToSelector(el2) {
              return modifiers2.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el2 !== void 0 ? `${_ePrefix}${el2}` : ""}${_mPrefix}${modifier}`).join(", ");
            }
            const els = context.bem.els;
            if (els !== null) {
              return elementToSelector(els[0]);
            } else {
              return elementToSelector();
            }
          }
        };
      }
      function notM(arg) {
        return {
          $({ context, props }) {
            arg = typeof arg === "string" ? arg : arg({ context, props });
            const els = context.bem.els;
            return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
          }
        };
      }
      const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
      const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
      const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
      const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
      Object.assign(_plugin, {
        cB: cB2,
        cE: cE2,
        cM: cM2,
        cNotM: cNotM2
      });
      return _plugin;
    }
    function ampCount(selector) {
      let cnt = 0;
      for (let i2 = 0; i2 < selector.length; ++i2) {
        if (selector[i2] === "&")
          ++cnt;
      }
      return cnt;
    }
    const separatorRegex = /\s*,(?![^(]*\))\s*/g;
    const extraSpaceRegex = /\s+/g;
    function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        let round = ampCount(partialSelector);
        if (!round) {
          amp.forEach((partialAmp) => {
            nextAmp.push(
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              (partialAmp && partialAmp + " ") + partialSelector
            );
          });
          return;
        } else if (round === 1) {
          amp.forEach((partialAmp) => {
            nextAmp.push(partialSelector.replace("&", partialAmp));
          });
          return;
        }
        let partialNextAmp = [
          partialSelector
        ];
        while (round--) {
          const nextPartialNextAmp = [];
          partialNextAmp.forEach((selectorItr) => {
            amp.forEach((partialAmp) => {
              nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
            });
          });
          partialNextAmp = nextPartialNextAmp;
        }
        partialNextAmp.forEach((part) => nextAmp.push(part));
      });
      return nextAmp;
    }
    function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach((partialSelector) => {
        amp.forEach((partialAmp) => {
          nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
        });
      });
      return nextAmp;
    }
    function parseSelectorPath(selectorPaths) {
      let amp = [""];
      selectorPaths.forEach((selector) => {
        selector = selector && selector.trim();
        if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector
        ) {
          return;
        }
        if (selector.includes("&")) {
          amp = resolveSelectorWithAmp(amp, selector);
        } else {
          amp = resolveSelector(amp, selector);
        }
      });
      return amp.join(", ").replace(extraSpaceRegex, " ");
    }
    function removeElement(el2) {
      if (!el2)
        return;
      const parentElement = el2.parentElement;
      if (parentElement)
        parentElement.removeChild(el2);
    }
    function queryElement(id2, parent) {
      return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id2}"]`);
    }
    function createElement(id2) {
      const el2 = document.createElement("style");
      el2.setAttribute("cssr-id", id2);
      return el2;
    }
    function isMediaOrSupports(selector) {
      if (!selector)
        return false;
      return /^\s*@(s|m)/.test(selector);
    }
    const kebabRegex = /[A-Z]/g;
    function kebabCase(pattern) {
      return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
    }
    function unwrapProperty(prop, indent = "  ") {
      if (typeof prop === "object" && prop !== null) {
        return " {\n" + Object.entries(prop).map((v) => {
          return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
        }).join("\n") + "\n" + indent + "}";
      }
      return `: ${prop};`;
    }
    function unwrapProperties(props, instance, params) {
      if (typeof props === "function") {
        return props({
          context: instance.context,
          props: params
        });
      }
      return props;
    }
    function createStyle(selector, props, instance, params) {
      if (!props)
        return "";
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
        return "";
      if (typeof unwrappedProps === "string") {
        return `${selector} {
${unwrappedProps}
}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
        if (instance.config.keepEmptyBlock)
          return selector + " {\n}";
        return "";
      }
      const statements = selector ? [
        selector + " {"
      ] : [];
      propertyNames.forEach((propertyName) => {
        const property = unwrappedProps[propertyName];
        if (propertyName === "raw") {
          statements.push("\n" + property + "\n");
          return;
        }
        propertyName = kebabCase(propertyName);
        if (property !== null && property !== void 0) {
          statements.push(`  ${propertyName}${unwrapProperty(property)}`);
        }
      });
      if (selector) {
        statements.push("}");
      }
      return statements.join("\n");
    }
    function loopCNodeListWithCallback(children, options, callback) {
      if (!children)
        return;
      children.forEach((child) => {
        if (Array.isArray(child)) {
          loopCNodeListWithCallback(child, options, callback);
        } else if (typeof child === "function") {
          const grandChildren = child(options);
          if (Array.isArray(grandChildren)) {
            loopCNodeListWithCallback(grandChildren, options, callback);
          } else if (grandChildren) {
            callback(grandChildren);
          }
        } else if (child) {
          callback(child);
        }
      });
    }
    function traverseCNode(node, selectorPaths, styles, instance, params) {
      const $ = node.$;
      let blockSelector = "";
      if (!$ || typeof $ === "string") {
        if (isMediaOrSupports($)) {
          blockSelector = $;
        } else {
          selectorPaths.push($);
        }
      } else if (typeof $ === "function") {
        const selector2 = $({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      } else {
        if ($.before)
          $.before(instance.context);
        if (!$.$ || typeof $.$ === "string") {
          if (isMediaOrSupports($.$)) {
            blockSelector = $.$;
          } else {
            selectorPaths.push($.$);
          }
        } else if ($.$) {
          const selector2 = $.$({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style2 = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
        styles.push(`${blockSelector} {`);
      } else if (style2.length) {
        styles.push(style2);
      }
      if (node.children) {
        loopCNodeListWithCallback(node.children, {
          context: instance.context,
          props: params
        }, (childNode) => {
          if (typeof childNode === "string") {
            const style3 = createStyle(selector, { raw: childNode }, instance, params);
            styles.push(style3);
          } else {
            traverseCNode(childNode, selectorPaths, styles, instance, params);
          }
        });
      }
      selectorPaths.pop();
      if (blockSelector) {
        styles.push("}");
      }
      if ($ && $.after)
        $.after(instance.context);
    }
    function render(node, instance, props) {
      const styles = [];
      traverseCNode(node, [], styles, instance, props);
      return styles.join("\n\n");
    }
    function murmur2(str) {
      var h2 = 0;
      var k, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= /* k >>> r: */
        k >>> 24;
        h2 = /* Math.imul(k, m): */
        (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    if (typeof window !== "undefined") {
      window.__cssrContext = {};
    }
    function unmount(instance, node, id2, parent) {
      const { els } = node;
      if (id2 === void 0) {
        els.forEach(removeElement);
        node.els = [];
      } else {
        const target = queryElement(id2, parent);
        if (target && els.includes(target)) {
          removeElement(target);
          node.els = els.filter((el2) => el2 !== target);
        }
      }
    }
    function addElementToList(els, target) {
      els.push(target);
    }
    function mount(instance, node, id2, props, head, force, anchorMetaName, parent, ssrAdapter2) {
      let style2;
      if (id2 === void 0) {
        style2 = node.render(props);
        id2 = murmur2(style2);
      }
      if (ssrAdapter2) {
        ssrAdapter2.adapter(id2, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
        return;
      }
      if (parent === void 0) {
        parent = document.head;
      }
      const queriedTarget = queryElement(id2, parent);
      if (queriedTarget !== null && !force) {
        return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id2);
      if (style2 === void 0)
        style2 = node.render(props);
      target.textContent = style2;
      if (queriedTarget !== null)
        return queriedTarget;
      if (anchorMetaName) {
        const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
        if (anchorMetaEl) {
          parent.insertBefore(target, anchorMetaEl);
          addElementToList(node.els, target);
          return target;
        }
      }
      if (head) {
        parent.insertBefore(target, parent.querySelector("style, link"));
      } else {
        parent.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
    }
    function wrappedRender(props) {
      return render(this, this.instance, props);
    }
    function wrappedMount(options = {}) {
      const { id: id2, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
      const targetElement = mount(this.instance, this, id2, props, head, force, anchorMetaName, parent, ssr);
      return targetElement;
    }
    function wrappedUnmount(options = {}) {
      const { id: id2, parent } = options;
      unmount(this.instance, this, id2, parent);
    }
    const createCNode = function(instance, $, props, children) {
      return {
        instance,
        $,
        props,
        children,
        els: [],
        render: wrappedRender,
        mount: wrappedMount,
        unmount: wrappedUnmount
      };
    };
    const c$1 = function(instance, $, props, children) {
      if (Array.isArray($)) {
        return createCNode(instance, { $: null }, null, $);
      } else if (Array.isArray(props)) {
        return createCNode(instance, $, null, props);
      } else if (Array.isArray(children)) {
        return createCNode(instance, $, props, children);
      } else {
        return createCNode(instance, $, props, null);
      }
    };
    function CssRender(config = {}) {
      const cssr2 = {
        c: (...args) => c$1(cssr2, ...args),
        use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
        find: queryElement,
        context: {},
        config
      };
      return cssr2;
    }
    function exists(id2, ssr) {
      if (id2 === void 0)
        return false;
      if (ssr) {
        const { context: { ids } } = ssr;
        return ids.has(id2);
      }
      return queryElement(id2) !== null;
    }
    const namespace = "n";
    const prefix$1 = `.${namespace}-`;
    const elementPrefix = "__";
    const modifierPrefix = "--";
    const cssr = CssRender();
    const plugin = plugin$1({
      blockPrefix: prefix$1,
      elementPrefix,
      modifierPrefix
    });
    cssr.use(plugin);
    const {
      c,
      find
    } = cssr;
    const {
      cB,
      cE: cE$1,
      cM,
      cNotM
    } = plugin;
    function createKey$1(prefix2, suffix2) {
      return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
    }
    function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
    }
    function depx(value) {
      if (typeof value === "string") {
        if (value.endsWith("px")) {
          return Number(value.slice(0, value.length - 2));
        }
        return Number(value);
      }
      return value;
    }
    function pxfy(value) {
      if (value === void 0 || value === null)
        return void 0;
      if (typeof value === "number")
        return `${value}px`;
      if (value.endsWith("px"))
        return value;
      return `${value}px`;
    }
    function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
        top: parts[0]
      };
      switch (parts.length) {
        case 1:
          margin.right = parts[0];
          margin.bottom = parts[0];
          margin.left = parts[0];
          break;
        case 2:
          margin.right = parts[1];
          margin.left = parts[1];
          margin.bottom = parts[0];
          break;
        case 3:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[1];
          break;
        case 4:
          margin.right = parts[1];
          margin.bottom = parts[2];
          margin.left = parts[3];
          break;
        default:
          throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
      }
      return margin;
    }
    function getGap(value, orient) {
      const [rowGap, colGap] = value.split(" ");
      return {
        row: rowGap,
        col: colGap || rowGap
      };
    }
    const colors = {
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#0FF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000",
      blanchedalmond: "#FFEBCD",
      blue: "#00F",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#0FF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgrey: "#A9A9A9",
      darkgreen: "#006400",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#F0F",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgrey: "#D3D3D3",
      lightgreen: "#90EE90",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#0F0",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#F0F",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#F00",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FF0",
      yellowgreen: "#9ACD32",
      transparent: "#0000"
    };
    function hsv2rgb(h2, s, v) {
      s /= 100;
      v /= 100;
      let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5) * 255, f(3) * 255, f(1) * 255];
    }
    function hsl2rgb(h2, s, l) {
      s /= 100;
      l /= 100;
      let a = s * Math.min(l, 1 - l);
      let f = (n, k = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0) * 255, f(8) * 255, f(4) * 255];
    }
    const prefix = "^\\s*";
    const suffix = "\\s*$";
    const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
    const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
    const hex = "([0-9A-Fa-f])";
    const dhex = "([0-9A-Fa-f]{2})";
    const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
    const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
    const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
    const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
    const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
    const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
    const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
    const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
    function parseHex(value) {
      return parseInt(value, 16);
    }
    function hsla(color) {
      try {
        let i2;
        if (i2 = hslaRegex.exec(color)) {
          return [
            roundDeg(i2[1]),
            roundPercent(i2[5]),
            roundPercent(i2[9]),
            roundAlpha(i2[13])
          ];
        } else if (i2 = hslRegex.exec(color)) {
          return [roundDeg(i2[1]), roundPercent(i2[5]), roundPercent(i2[9]), 1];
        }
        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function hsva(color) {
      try {
        let i2;
        if (i2 = hsvaRegex.exec(color)) {
          return [
            roundDeg(i2[1]),
            roundPercent(i2[5]),
            roundPercent(i2[9]),
            roundAlpha(i2[13])
          ];
        } else if (i2 = hsvRegex.exec(color)) {
          return [roundDeg(i2[1]), roundPercent(i2[5]), roundPercent(i2[9]), 1];
        }
        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function rgba(color) {
      try {
        let i2;
        if (i2 = hexRegex.exec(color)) {
          return [parseHex(i2[1]), parseHex(i2[2]), parseHex(i2[3]), 1];
        } else if (i2 = rgbRegex.exec(color)) {
          return [roundChannel(i2[1]), roundChannel(i2[5]), roundChannel(i2[9]), 1];
        } else if (i2 = rgbaRegex.exec(color)) {
          return [
            roundChannel(i2[1]),
            roundChannel(i2[5]),
            roundChannel(i2[9]),
            roundAlpha(i2[13])
          ];
        } else if (i2 = sHexRegex.exec(color)) {
          return [
            parseHex(i2[1] + i2[1]),
            parseHex(i2[2] + i2[2]),
            parseHex(i2[3] + i2[3]),
            1
          ];
        } else if (i2 = hexaRegex.exec(color)) {
          return [
            parseHex(i2[1]),
            parseHex(i2[2]),
            parseHex(i2[3]),
            roundAlpha(parseHex(i2[4]) / 255)
          ];
        } else if (i2 = sHexaRegex.exec(color)) {
          return [
            parseHex(i2[1] + i2[1]),
            parseHex(i2[2] + i2[2]),
            parseHex(i2[3] + i2[3]),
            roundAlpha(parseHex(i2[4] + i2[4]) / 255)
          ];
        } else if (color in colors) {
          return rgba(colors[color]);
        } else if (hslRegex.test(color) || hslaRegex.test(color)) {
          const [h2, s, l, a] = hsla(color);
          return [...hsl2rgb(h2, s, l), a];
        } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
          const [h2, s, v, a] = hsva(color);
          return [...hsv2rgb(h2, s, v), a];
        }
        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      } catch (e) {
        throw e;
      }
    }
    function normalizeAlpha(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
    }
    function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
    }
    function compositeChannel(v12, a12, v2, a2, a) {
      return roundChannel((v12 * a12 * (1 - a2) + v2 * a2) / a);
    }
    function composite(background, overlay2) {
      if (!Array.isArray(background))
        background = rgba(background);
      if (!Array.isArray(overlay2))
        overlay2 = rgba(overlay2);
      const a12 = background[3];
      const a2 = overlay2[3];
      const alpha = roundAlpha(a12 + a2 - a12 * a2);
      return stringifyRgba(compositeChannel(background[0], a12, overlay2[0], a2, alpha), compositeChannel(background[1], a12, overlay2[1], a2, alpha), compositeChannel(background[2], a12, overlay2[2], a2, alpha), alpha);
    }
    function changeColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      if (typeof options.alpha === "number") {
        return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
    }
    function scaleColor(base2, options) {
      const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
    }
    function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
        return 1;
      if (v < 0)
        return 0;
      return v;
    }
    function roundDeg(value) {
      const v = Math.round(Number(value));
      if (v >= 360)
        return 0;
      if (v < 0)
        return 0;
      return v;
    }
    function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
        return 255;
      if (v < 0)
        return 0;
      return v;
    }
    function roundPercent(value) {
      const v = Math.round(Number(value));
      if (v > 100)
        return 100;
      if (v < 0)
        return 0;
      return v;
    }
    function toRgbaString(base2) {
      const [r, g, b] = base2;
      if (3 in base2) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
    }
    function createId(length = 8) {
      return Math.random().toString(16).slice(2, 2 + length);
    }
    function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
    }
    const traps = {
      mousemoveoutside: /* @__PURE__ */ new WeakMap(),
      clickoutside: /* @__PURE__ */ new WeakMap()
    };
    function createTrapHandler(name, el2, originalHandler) {
      if (name === "mousemoveoutside") {
        const moveHandler = (e) => {
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousemove: moveHandler,
          touchstart: moveHandler
        };
      } else if (name === "clickoutside") {
        let mouseDownOutside = false;
        const downHandler = (e) => {
          mouseDownOutside = !el2.contains(getEventTarget(e));
        };
        const upHanlder = (e) => {
          if (!mouseDownOutside)
            return;
          if (el2.contains(getEventTarget(e)))
            return;
          originalHandler(e);
        };
        return {
          mousedown: downHandler,
          mouseup: upHanlder,
          touchstart: downHandler,
          touchend: upHanlder
        };
      }
      console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
      );
      return {};
    }
    function ensureTrapHandlers(name, el2, handler) {
      const handlers2 = traps[name];
      let elHandlers = handlers2.get(el2);
      if (elHandlers === void 0) {
        handlers2.set(el2, elHandlers = /* @__PURE__ */ new WeakMap());
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === void 0) {
        elHandlers.set(handler, trapHandler = createTrapHandler(name, el2, handler));
      }
      return trapHandler;
    }
    function trapOn(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          on$1(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function trapOff(name, el2, handler, options) {
      if (name === "mousemoveoutside" || name === "clickoutside") {
        const trapHandlers = ensureTrapHandlers(name, el2, handler);
        Object.keys(trapHandlers).forEach((key) => {
          off(key, document, trapHandlers[key], options);
        });
        return true;
      }
      return false;
    }
    function createDelegate() {
      if (typeof window === "undefined") {
        return {
          on: () => {
          },
          off: () => {
          }
        };
      }
      const propagationStopped = /* @__PURE__ */ new WeakMap();
      const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
      function trackPropagation() {
        propagationStopped.set(this, true);
      }
      function trackImmediate() {
        propagationStopped.set(this, true);
        immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn) {
        const source = event[propName];
        event[propName] = function() {
          fn.apply(event, arguments);
          return source.apply(event, arguments);
        };
        return event;
      }
      function unspy(event, propName) {
        event[propName] = Event.prototype[propName];
      }
      const currentTargets = /* @__PURE__ */ new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
      function getCurrentTarget() {
        var _a2;
        return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function defineCurrentTarget(event, getter) {
        if (currentTargetDescriptor === void 0)
          return;
        Object.defineProperty(event, "currentTarget", {
          configurable: true,
          enumerable: true,
          get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
        });
      }
      const phaseToTypeToElToHandlers = {
        bubble: {},
        capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
        const delegeteHandler = function(e) {
          const { type, eventPhase, bubbles } = e;
          const target = getEventTarget(e);
          if (eventPhase === 2)
            return;
          const phase = eventPhase === 1 ? "capture" : "bubble";
          let cursor = target;
          const path = [];
          while (true) {
            if (cursor === null)
              cursor = window;
            path.push(cursor);
            if (cursor === window) {
              break;
            }
            cursor = cursor.parentNode || null;
          }
          const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
          const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
          spy(e, "stopPropagation", trackPropagation);
          spy(e, "stopImmediatePropagation", trackImmediate);
          defineCurrentTarget(e, getCurrentTarget);
          if (phase === "capture") {
            if (captureElToHandlers === void 0)
              return;
            for (let i2 = path.length - 1; i2 >= 0; --i2) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i2];
              const handlers2 = captureElToHandlers.get(target2);
              if (handlers2 !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers2) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
              if (i2 === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                const bubbleHandlers = bubbleElToHandlers.get(target2);
                if (bubbleHandlers !== void 0) {
                  for (const handler of bubbleHandlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
          } else if (phase === "bubble") {
            if (bubbleElToHandlers === void 0)
              return;
            for (let i2 = 0; i2 < path.length; ++i2) {
              if (propagationStopped.has(e))
                break;
              const target2 = path[i2];
              const handlers2 = bubbleElToHandlers.get(target2);
              if (handlers2 !== void 0) {
                currentTargets.set(e, target2);
                for (const handler of handlers2) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
          unspy(e, "stopPropagation");
          unspy(e, "stopImmediatePropagation");
          defineCurrentTarget(e);
        };
        delegeteHandler.displayName = "evtdUnifiedHandler";
        return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
        const delegateHandler = function(e) {
          const { type, eventPhase } = e;
          if (eventPhase !== 2)
            return;
          const handlers2 = typeToWindowEventHandlers[type];
          if (handlers2 === void 0)
            return;
          handlers2.forEach((handler) => handler(e));
        };
        delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
        return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type) {
        const phaseHandlers = phaseToTypeToElToHandlers[phase];
        if (phaseHandlers[type] === void 0) {
          phaseHandlers[type] = /* @__PURE__ */ new Map();
          window.addEventListener(type, unifiedHandler, phase === "capture");
        }
        return phaseHandlers[type];
      }
      function ensureWindowEventHandlers(type) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        if (windowEventHandlers === void 0) {
          typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
          window.addEventListener(type, unfiendWindowEventHandler);
        }
        return typeToWindowEventHandlers[type];
      }
      function ensureHandlers(elToHandlers, el2) {
        let elHandlers = elToHandlers.get(el2);
        if (elHandlers === void 0) {
          elToHandlers.set(el2, elHandlers = /* @__PURE__ */ new Set());
        }
        return elHandlers;
      }
      function handlerExist(el2, phase, type, handler) {
        const elToHandlers = phaseToTypeToElToHandlers[phase][type];
        if (elToHandlers !== void 0) {
          const handlers2 = elToHandlers.get(el2);
          if (handlers2 !== void 0) {
            if (handlers2.has(handler))
              return true;
          }
        }
        return false;
      }
      function windowEventHandlerExist(type, handler) {
        const handlers2 = typeToWindowEventHandlers[type];
        if (handlers2 !== void 0) {
          if (handlers2.has(handler)) {
            return true;
          }
        }
        return false;
      }
      function on2(type, el2, handler, options) {
        let mergedHandler;
        if (typeof options === "object" && options.once === true) {
          mergedHandler = (e) => {
            off2(type, el2, mergedHandler, options);
            handler(e);
          };
        } else {
          mergedHandler = handler;
        }
        const trapped = trapOn(type, el2, mergedHandler, options);
        if (trapped)
          return;
        const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers2 = ensureHandlers(elToHandlers, el2);
        if (!handlers2.has(mergedHandler))
          handlers2.add(mergedHandler);
        if (el2 === window) {
          const windowEventHandlers = ensureWindowEventHandlers(type);
          if (!windowEventHandlers.has(mergedHandler)) {
            windowEventHandlers.add(mergedHandler);
          }
        }
      }
      function off2(type, el2, handler, options) {
        const trapped = trapOff(type, el2, handler, options);
        if (trapped)
          return;
        const capture = options === true || typeof options === "object" && options.capture === true;
        const phase = capture ? "capture" : "bubble";
        const elToHandlers = ensureElToHandlers(phase, type);
        const handlers2 = ensureHandlers(elToHandlers, el2);
        if (el2 === window) {
          const mirrorPhase = capture ? "bubble" : "capture";
          if (!handlerExist(el2, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
            const windowEventHandlers = typeToWindowEventHandlers[type];
            windowEventHandlers.delete(handler);
            if (windowEventHandlers.size === 0) {
              window.removeEventListener(type, unfiendWindowEventHandler);
              typeToWindowEventHandlers[type] = void 0;
            }
          }
        }
        if (handlers2.has(handler))
          handlers2.delete(handler);
        if (handlers2.size === 0) {
          elToHandlers.delete(el2);
        }
        if (elToHandlers.size === 0) {
          window.removeEventListener(type, unifiedHandler, phase === "capture");
          phaseToTypeToElToHandlers[phase][type] = void 0;
        }
      }
      return {
        on: on2,
        off: off2
      };
    }
    const { on: on$1, off } = createDelegate();
    function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
        return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
        if (value) {
          currentRef.value = true;
          stop();
        }
      });
      return readonly(currentRef);
    }
    function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
        valueRef.value = value;
      });
      if (typeof getterOrOptions === "function") {
        return valueRef;
      } else {
        return {
          __v_isRef: true,
          get value() {
            return valueRef.value;
          },
          set value(v) {
            getterOrOptions.set(v);
          }
        };
      }
    }
    function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, (value) => {
        if (value !== void 0) {
          uncontrolledStateRef.value = value;
        }
      });
      return computed(() => {
        if (controlledStateRef.value === void 0) {
          return uncontrolledStateRef.value;
        }
        return controlledStateRef.value;
      });
    }
    function isMounted() {
      const isMounted2 = ref(false);
      onMounted(() => {
        isMounted2.value = true;
      });
      return readonly(isMounted2);
    }
    const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    !window.MSStream;
    function useIsIos() {
      return isIos;
    }
    function createInjectionKey(key) {
      return key;
    }
    const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
    const drawerInjectionKey = createInjectionKey("n-drawer");
    const modalBodyInjectionKey = createInjectionKey("n-modal-body");
    const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
    function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a2;
      const injection = inject(injectionName, null);
      if (injection === null) return;
      const vm2 = (_a2 = getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
        registerInstance(void 0, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
        if (!injection) return;
        const collection = injection[collectionKey];
        if (oldKey !== void 0) removeInstance(collection, oldKey);
        if (key !== void 0) addInstance(collection, key);
      }
      function removeInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        collection[key].splice(collection[key].findIndex((instance) => instance === vm2), 1);
      }
      function addInstance(collection, key) {
        if (!collection[key]) collection[key] = [];
        if (!~collection[key].findIndex((instance) => instance === vm2)) {
          collection[key].push(vm2);
        }
      }
    }
    const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
    const isComposingRef = ref(false);
    function compositionStartHandler() {
      isComposingRef.value = true;
    }
    function compositionEndHandler() {
      isComposingRef.value = false;
    }
    let mountedCount = 0;
    function useIsComposing() {
      if (isBrowser$1) {
        onBeforeMount(() => {
          if (!mountedCount) {
            window.addEventListener("compositionstart", compositionStartHandler);
            window.addEventListener("compositionend", compositionEndHandler);
          }
          mountedCount++;
        });
        onBeforeUnmount(() => {
          if (mountedCount <= 1) {
            window.removeEventListener("compositionstart", compositionStartHandler);
            window.removeEventListener("compositionend", compositionEndHandler);
            mountedCount = 0;
          } else {
            mountedCount--;
          }
        });
      }
      return isComposingRef;
    }
    let lockCount = 0;
    let originalMarginRight = "";
    let originalOverflow = "";
    let originalOverflowX = "";
    let originalOverflowY = "";
    const lockHtmlScrollRightCompensationRef = ref("0px");
    function useLockHtmlScroll(lockRef) {
      if (typeof document === "undefined") return;
      const el2 = document.documentElement;
      let watchStopHandle;
      let activated = false;
      const unlock = () => {
        el2.style.marginRight = originalMarginRight;
        el2.style.overflow = originalOverflow;
        el2.style.overflowX = originalOverflowX;
        el2.style.overflowY = originalOverflowY;
        lockHtmlScrollRightCompensationRef.value = "0px";
      };
      onMounted(() => {
        watchStopHandle = watch(lockRef, (value) => {
          if (value) {
            if (!lockCount) {
              const scrollbarWidth = window.innerWidth - el2.offsetWidth;
              if (scrollbarWidth > 0) {
                originalMarginRight = el2.style.marginRight;
                el2.style.marginRight = `${scrollbarWidth}px`;
                lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
              }
              originalOverflow = el2.style.overflow;
              originalOverflowX = el2.style.overflowX;
              originalOverflowY = el2.style.overflowY;
              el2.style.overflow = "hidden";
              el2.style.overflowX = "hidden";
              el2.style.overflowY = "hidden";
            }
            activated = true;
            lockCount++;
          } else {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
        if (activated) {
          lockCount--;
          if (!lockCount) {
            unlock();
          }
          activated = false;
        }
      });
    }
    function useReactivated(callback) {
      const isDeactivatedRef = {
        isDeactivated: false
      };
      let activateStateInitialized = false;
      onActivated(() => {
        isDeactivatedRef.isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        callback();
      });
      onDeactivated(() => {
        isDeactivatedRef.isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      return isDeactivatedRef;
    }
    function getSlot$1(scope, slots, slotName = "default") {
      const slot = slots[slotName];
      if (slot === void 0) {
        throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
    }
    const ctxKey = "@@coContext";
    const clickoutside = {
      mounted(el2, { value, modifiers: modifiers2 }) {
        el2[ctxKey] = {
          handler: void 0
        };
        if (typeof value === "function") {
          el2[ctxKey].handler = value;
          on$1("clickoutside", el2, value, {
            capture: modifiers2.capture
          });
        }
      },
      updated(el2, { value, modifiers: modifiers2 }) {
        const ctx2 = el2[ctxKey];
        if (typeof value === "function") {
          if (ctx2.handler) {
            if (ctx2.handler !== value) {
              off("clickoutside", el2, ctx2.handler, {
                capture: modifiers2.capture
              });
              ctx2.handler = value;
              on$1("clickoutside", el2, value, {
                capture: modifiers2.capture
              });
            }
          } else {
            el2[ctxKey].handler = value;
            on$1("clickoutside", el2, value, {
              capture: modifiers2.capture
            });
          }
        } else {
          if (ctx2.handler) {
            off("clickoutside", el2, ctx2.handler, {
              capture: modifiers2.capture
            });
            ctx2.handler = void 0;
          }
        }
      },
      unmounted(el2, { modifiers: modifiers2 }) {
        const { handler } = el2[ctxKey];
        if (handler) {
          off("clickoutside", el2, handler, {
            capture: modifiers2.capture
          });
        }
        el2[ctxKey].handler = void 0;
      }
    };
    function warn$2(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
    }
    class ZIndexManager {
      constructor() {
        this.elementZIndex = /* @__PURE__ */ new Map();
        this.nextZIndex = 2e3;
      }
      get elementCount() {
        return this.elementZIndex.size;
      }
      ensureZIndex(el2, zIndex) {
        const { elementZIndex } = this;
        if (zIndex !== void 0) {
          el2.style.zIndex = `${zIndex}`;
          elementZIndex.delete(el2);
          return;
        }
        const { nextZIndex } = this;
        if (elementZIndex.has(el2)) {
          const currentZIndex = elementZIndex.get(el2);
          if (currentZIndex + 1 === this.nextZIndex)
            return;
        }
        el2.style.zIndex = `${nextZIndex}`;
        elementZIndex.set(el2, nextZIndex);
        this.nextZIndex = nextZIndex + 1;
        this.squashState();
      }
      unregister(el2, zIndex) {
        const { elementZIndex } = this;
        if (elementZIndex.has(el2)) {
          elementZIndex.delete(el2);
        } else if (zIndex === void 0) {
          warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
        }
        this.squashState();
      }
      squashState() {
        const { elementCount } = this;
        if (!elementCount) {
          this.nextZIndex = 2e3;
        }
        if (this.nextZIndex - elementCount > 2500)
          this.rearrange();
      }
      rearrange() {
        const elementZIndexPair = Array.from(this.elementZIndex.entries());
        elementZIndexPair.sort((pair1, pair2) => {
          return pair1[1] - pair2[1];
        });
        this.nextZIndex = 2e3;
        elementZIndexPair.forEach((pair) => {
          const el2 = pair[0];
          const zIndex = this.nextZIndex++;
          if (`${zIndex}` !== el2.style.zIndex)
            el2.style.zIndex = `${zIndex}`;
        });
      }
    }
    const zIndexManager = new ZIndexManager();
    const ctx = "@@ziContext";
    const zindexable = {
      mounted(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        el2[ctx] = {
          enabled: !!enabled,
          initialized: false
        };
        if (enabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
      },
      updated(el2, bindings) {
        const { value = {} } = bindings;
        const { zIndex, enabled } = value;
        const cachedEnabled = el2[ctx].enabled;
        if (enabled && !cachedEnabled) {
          zIndexManager.ensureZIndex(el2, zIndex);
          el2[ctx].initialized = true;
        }
        el2[ctx].enabled = !!enabled;
      },
      unmounted(el2, bindings) {
        if (!el2[ctx].initialized)
          return;
        const { value = {} } = bindings;
        const { zIndex } = value;
        zIndexManager.unregister(el2, zIndex);
      }
    };
    const ssrContextKey = "@css-render/vue3-ssr";
    function createStyleString(id2, style2) {
      return `<style cssr-id="${id2}">
${style2}
</style>`;
    }
    function ssrAdapter(id2, style2, ssrContext) {
      const { styles, ids } = ssrContext;
      if (ids.has(id2))
        return;
      if (styles !== null) {
        ids.add(id2);
        styles.push(createStyleString(id2, style2));
      }
    }
    const isBrowser = typeof document !== "undefined";
    function useSsrAdapter() {
      if (isBrowser)
        return void 0;
      const context = inject(ssrContextKey, null);
      if (context === null)
        return void 0;
      return {
        adapter: (id2, style2) => ssrAdapter(id2, style2, context),
        context
      };
    }
    function warn$1(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
    }
    function resolveTo(selector) {
      if (typeof selector === "string") {
        return document.querySelector(selector);
      }
      return selector();
    }
    const LazyTeleport = /* @__PURE__ */ defineComponent({
      name: "LazyTeleport",
      props: {
        to: {
          type: [String, Object],
          default: void 0
        },
        disabled: Boolean,
        show: {
          type: Boolean,
          required: true
        }
      },
      setup(props) {
        return {
          showTeleport: useFalseUntilTruthy(toRef(props, "show")),
          mergedTo: computed(() => {
            const { to: to2 } = props;
            return to2 !== null && to2 !== void 0 ? to2 : "body";
          })
        };
      },
      render() {
        return this.showTeleport ? this.disabled ? getSlot$1("lazy-teleport", this.$slots) : h(Teleport, {
          disabled: this.disabled,
          to: this.mergedTo
        }, getSlot$1("lazy-teleport", this.$slots)) : null;
      }
    });
    var resizeObservers = [];
    var hasActiveObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.activeTargets.length > 0;
      });
    };
    var hasSkippedObservations = function() {
      return resizeObservers.some(function(ro2) {
        return ro2.skippedTargets.length > 0;
      });
    };
    var msg = "ResizeObserver loop completed with undelivered notifications.";
    var deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
    var ResizeObserverBoxOptions;
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
    var freeze = function(obj) {
      return Object.freeze(obj);
    };
    var ResizeObserverSize = /* @__PURE__ */ function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
    var DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
    var isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    var isHidden = function(target) {
      if (isSVG(target)) {
        var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
        return !width && !height;
      }
      var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    var isElement = function(obj) {
      var _a2;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    var isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
    var global$1 = typeof window !== "undefined" ? window : {};
    var cache = /* @__PURE__ */ new WeakMap();
    var scrollRegexp = /auto|scroll/;
    var verticalRegexp = /^tb|vertical/;
    var IE$1 = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
    var parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    var size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    var calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs2 = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE$1 && cs2.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs2.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs2.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs2.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs2.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs2.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs2.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs2.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs2.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs2.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs2.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs2.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs2.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs2.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    var calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
    var ResizeObserverEntry = /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
    var calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
    var broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro2) {
        if (ro2.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro2.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro2.callback.call(ro2.observer, entries, ro2.observer);
        });
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
      });
      for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
        var callback = callbacks_1[_i2];
        callback();
      }
      return shallowestDepth;
    };
    var gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro2) {
        ro2.activeTargets.splice(0, ro2.activeTargets.length);
        ro2.skippedTargets.splice(0, ro2.skippedTargets.length);
        ro2.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro2.activeTargets.push(ot);
            } else {
              ro2.skippedTargets.push(ot);
            }
          }
        });
      });
    };
    var process = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
    var trigger;
    var callbacks = [];
    var notify = function() {
      return callbacks.splice(0).forEach(function(cb2) {
        return cb2();
      });
    };
    var queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
    var queueResizeObserver = function(cb2) {
      queueMicroTask(function ResizeObserver2() {
        requestAnimationFrame(cb2);
      });
    };
    var watching = 0;
    var isWatching = function() {
      return !!watching;
    };
    var CATCH_PERIOD = 250;
    var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    var events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    var time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    var scheduled = false;
    var Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb2 = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb2() : global$1.addEventListener("DOMContentLoaded", cb2);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global$1.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global$1.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    var scheduler = new Scheduler();
    var updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
    var skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    var ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
    var ResizeObserverDetail = /* @__PURE__ */ function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
    var observerMap = /* @__PURE__ */ new WeakMap();
    var getObservationIndex = function(observationTargets, target) {
      for (var i2 = 0; i2 < observationTargets.length; i2 += 1) {
        if (observationTargets[i2].target === target) {
          return i2;
        }
      }
      return -1;
    };
    var ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options && options.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
    var ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver2.prototype.observe = function(target, options) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver2.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver2.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver2.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver2;
    }();
    class ResizeObserverDelegate {
      constructor() {
        this.handleResize = this.handleResize.bind(this);
        this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
        this.elHandlersMap = /* @__PURE__ */ new Map();
      }
      handleResize(entries) {
        for (const entry of entries) {
          const handler = this.elHandlersMap.get(entry.target);
          if (handler !== void 0) {
            handler(entry);
          }
        }
      }
      registerHandler(el2, handler) {
        this.elHandlersMap.set(el2, handler);
        this.observer.observe(el2);
      }
      unregisterHandler(el2) {
        if (!this.elHandlersMap.has(el2)) {
          return;
        }
        this.elHandlersMap.delete(el2);
        this.observer.unobserve(el2);
      }
    }
    const resizeObserverManager = new ResizeObserverDelegate();
    const VResizeObserver = /* @__PURE__ */ defineComponent({
      name: "ResizeObserver",
      props: {
        onResize: Function
      },
      setup(props) {
        let registered = false;
        const proxy = getCurrentInstance().proxy;
        function handleResize(entry) {
          const { onResize } = props;
          if (onResize !== void 0)
            onResize(entry);
        }
        onMounted(() => {
          const el2 = proxy.$el;
          if (el2 === void 0) {
            warn$1("resize-observer", "$el does not exist.");
            return;
          }
          if (el2.nextElementSibling !== el2.nextSibling) {
            if (el2.nodeType === 3 && el2.nodeValue !== "") {
              warn$1("resize-observer", "$el can not be observed (it may be a text node).");
              return;
            }
          }
          if (el2.nextElementSibling !== null) {
            resizeObserverManager.registerHandler(el2.nextElementSibling, handleResize);
            registered = true;
          }
        });
        onBeforeUnmount(() => {
          if (registered) {
            resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
          }
        });
      },
      render() {
        return renderSlot(this.$slots, "default");
      }
    });
    function isHTMLElement(node) {
      return node instanceof HTMLElement;
    }
    function focusFirstDescendant(node) {
      for (let i2 = 0; i2 < node.childNodes.length; i2++) {
        const child = node.childNodes[i2];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusFirstDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function focusLastDescendant(element) {
      for (let i2 = element.childNodes.length - 1; i2 >= 0; i2--) {
        const child = element.childNodes[i2];
        if (isHTMLElement(child)) {
          if (attemptFocus(child) || focusLastDescendant(child)) {
            return true;
          }
        }
      }
      return false;
    }
    function attemptFocus(element) {
      if (!isFocusable(element)) {
        return false;
      }
      try {
        element.focus({ preventScroll: true });
      } catch (e) {
      }
      return document.activeElement === element;
    }
    function isFocusable(element) {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.getAttribute("disabled")) {
        return false;
      }
      switch (element.nodeName) {
        case "A":
          return !!element.href && element.rel !== "ignore";
        case "INPUT":
          return element.type !== "hidden" && element.type !== "file";
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA":
          return true;
        default:
          return false;
      }
    }
    let stack = [];
    const FocusTrap = /* @__PURE__ */ defineComponent({
      name: "FocusTrap",
      props: {
        disabled: Boolean,
        active: Boolean,
        autoFocus: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        initialFocusTo: String,
        finalFocusTo: String,
        returnFocusOnDeactivated: {
          type: Boolean,
          default: true
        }
      },
      setup(props) {
        const id2 = createId();
        const focusableStartRef = ref(null);
        const focusableEndRef = ref(null);
        let activated = false;
        let ignoreInternalFocusChange = false;
        const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
        function isCurrentActive() {
          const currentActiveId = stack[stack.length - 1];
          return currentActiveId === id2;
        }
        function handleDocumentKeydown(e) {
          var _a2;
          if (e.code === "Escape") {
            if (isCurrentActive()) {
              (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
            }
          }
        }
        onMounted(() => {
          watch(() => props.active, (value) => {
            if (value) {
              activate();
              on$1("keydown", document, handleDocumentKeydown);
            } else {
              off("keydown", document, handleDocumentKeydown);
              if (activated) {
                deactivate();
              }
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          off("keydown", document, handleDocumentKeydown);
          if (activated)
            deactivate();
        });
        function handleDocumentFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (isCurrentActive()) {
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (mainEl.contains(getPreciseEventTarget(e)))
              return;
            resetFocusTo("first");
          }
        }
        function getMainEl() {
          const focusableStartEl = focusableStartRef.value;
          if (focusableStartEl === null)
            return null;
          let mainEl = focusableStartEl;
          while (true) {
            mainEl = mainEl.nextSibling;
            if (mainEl === null)
              break;
            if (mainEl instanceof Element && mainEl.tagName === "DIV") {
              break;
            }
          }
          return mainEl;
        }
        function activate() {
          var _a2;
          if (props.disabled)
            return;
          stack.push(id2);
          if (props.autoFocus) {
            const { initialFocusTo } = props;
            if (initialFocusTo === void 0) {
              resetFocusTo("first");
            } else {
              (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
            }
          }
          activated = true;
          document.addEventListener("focus", handleDocumentFocus, true);
        }
        function deactivate() {
          var _a2;
          if (props.disabled)
            return;
          document.removeEventListener("focus", handleDocumentFocus, true);
          stack = stack.filter((idInStack) => idInStack !== id2);
          if (isCurrentActive())
            return;
          const { finalFocusTo } = props;
          if (finalFocusTo !== void 0) {
            (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          } else if (props.returnFocusOnDeactivated) {
            if (lastFocusedElement instanceof HTMLElement) {
              ignoreInternalFocusChange = true;
              lastFocusedElement.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
        function resetFocusTo(target) {
          if (!isCurrentActive())
            return;
          if (props.active) {
            const focusableStartEl = focusableStartRef.value;
            const focusableEndEl = focusableEndRef.value;
            if (focusableStartEl !== null && focusableEndEl !== null) {
              const mainEl = getMainEl();
              if (mainEl == null || mainEl === focusableEndEl) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
                return;
              }
              ignoreInternalFocusChange = true;
              const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
              ignoreInternalFocusChange = false;
              if (!focused) {
                ignoreInternalFocusChange = true;
                focusableStartEl.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
        }
        function handleStartFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        function handleEndFocus(e) {
          if (ignoreInternalFocusChange)
            return;
          if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
            resetFocusTo("last");
          } else {
            resetFocusTo("first");
          }
        }
        return {
          focusableStartRef,
          focusableEndRef,
          focusableStyle: "position: absolute; height: 0; width: 0;",
          handleStartFocus,
          handleEndFocus
        };
      },
      render() {
        const { default: defaultSlot } = this.$slots;
        if (defaultSlot === void 0)
          return null;
        if (this.disabled)
          return defaultSlot();
        const { active, focusableStyle } = this;
        return h(Fragment$1, null, [
          h("div", {
            "aria-hidden": "true",
            tabindex: active ? "0" : "-1",
            ref: "focusableStartRef",
            style: focusableStyle,
            onFocus: this.handleStartFocus
          }),
          defaultSlot(),
          h("div", {
            "aria-hidden": "true",
            style: focusableStyle,
            ref: "focusableEndRef",
            tabindex: active ? "0" : "-1",
            onFocus: this.handleEndFocus
          })
        ]);
      }
    });
    function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s|\./g, "_");
    }
    const pureNumberRegex = /^(\d|\.)+$/;
    const numberRegex = /(\d|\.)+/;
    function formatLength(length, {
      c: c2 = 1,
      offset = 0,
      attachPx = true
    } = {}) {
      if (typeof length === "number") {
        const result = (length + offset) * c2;
        if (result === 0) return "0";
        return `${result}px`;
      } else if (typeof length === "string") {
        if (pureNumberRegex.test(length)) {
          const result = (Number(length) + offset) * c2;
          if (attachPx) {
            if (result === 0) return "0";
            return `${result}px`;
          } else {
            return `${result}`;
          }
        } else {
          const result = numberRegex.exec(length);
          if (!result) return length;
          return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
        }
      }
      return length;
    }
    function rtlInset(inset) {
      const {
        left,
        right,
        top,
        bottom
      } = getMargin(inset);
      return `${top} ${left} ${bottom} ${right}`;
    }
    const eventSet = /* @__PURE__ */ new WeakSet();
    function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
    }
    function warn(location, message) {
      console.error(`[naive/${location}]: ${message}`);
    }
    function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
    }
    function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
        funcs.forEach((func) => call(func, ...args));
      } else {
        return funcs(...args);
      }
    }
    function flatten(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
        if (vNode === null) return;
        if (typeof vNode !== "object") {
          if (typeof vNode === "string" || typeof vNode === "number") {
            result.push(createTextVNode(String(vNode)));
          }
          return;
        }
        if (Array.isArray(vNode)) {
          flatten(vNode, filterCommentNode, result);
          return;
        }
        if (vNode.type === Fragment$1) {
          if (vNode.children === null) return;
          if (Array.isArray(vNode.children)) {
            flatten(vNode.children, filterCommentNode, result);
          }
        } else {
          if (vNode.type === Comment && filterCommentNode) return;
          result.push(vNode);
        }
      });
      return result;
    }
    function getSlot(instance, slotName = "default", fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === void 0) return fallback;
      return slot();
    }
    function keysOf(obj) {
      return Object.keys(obj);
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) {
          return true;
        }
        if (child.type === Comment) {
          return false;
        }
        if (child.type === Fragment$1 && !ensureValidVNode(child.children)) {
          return false;
        }
        return true;
      }) ? vnodes : null;
    }
    function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
    }
    function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      render() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    });
    const configProviderInjectionKey = createInjectionKey("n-config-provider");
    const defaultClsPrefix = "n";
    function useConfig(props = {}, options = {
      defaultBordered: true
    }) {
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      return {
        // NConfigProvider,
        inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
        mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
        mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
        mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
        mergedBorderedRef: computed(() => {
          var _a2, _b2;
          const {
            bordered
          } = props;
          if (bordered !== void 0) return bordered;
          return (_b2 = (_a2 = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
        }),
        mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
        namespaceRef: computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
      };
    }
    function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
      const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
      const themeClassRef = ref("");
      const ssrAdapter2 = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
        let finalThemeHash = hashClassPrefix;
        const hashValue = hashRef ? hashRef.value : void 0;
        const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
        if (themeHash) finalThemeHash += `-${themeHash}`;
        if (hashValue) finalThemeHash += `-${hashValue}`;
        const {
          themeOverrides,
          builtinThemeOverrides
        } = props;
        if (themeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
        }
        if (builtinThemeOverrides) {
          finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
        }
        themeClassRef.value = finalThemeHash;
        renderCallback = () => {
          const cssVars = cssVarsRef.value;
          let style2 = "";
          for (const key in cssVars) {
            style2 += `${key}: ${cssVars[key]};`;
          }
          c(`.${finalThemeHash}`, style2).mount({
            id: finalThemeHash,
            ssr: ssrAdapter2,
            parent: styleMountTarget
          });
          renderCallback = void 0;
        };
      };
      watchEffect(() => {
        mountStyle();
      });
      return {
        themeClass: themeClassRef,
        onRender: () => {
          renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
        }
      };
    }
    const formItemInjectionKey = createInjectionKey("n-form-item");
    function useFormItem(props, {
      defaultSize = "medium",
      mergedSize,
      mergedDisabled
    } = {}) {
      const NFormItem2 = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
        const {
          size: size2
        } = props;
        if (size2) return size2;
        if (NFormItem2) {
          const {
            mergedSize: mergedSize2
          } = NFormItem2;
          if (mergedSize2.value !== void 0) {
            return mergedSize2.value;
          }
        }
        return defaultSize;
      });
      const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
        const {
          disabled
        } = props;
        if (disabled !== void 0) {
          return disabled;
        }
        if (NFormItem2) {
          return NFormItem2.disabled.value;
        }
        return false;
      });
      const mergedStatusRef = computed(() => {
        const {
          status
        } = props;
        if (status) return status;
        return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
        if (NFormItem2) {
          NFormItem2.restoreValidation();
        }
      });
      return {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur() {
          if (NFormItem2) {
            NFormItem2.handleContentBlur();
          }
        },
        nTriggerFormChange() {
          if (NFormItem2) {
            NFormItem2.handleContentChange();
          }
        },
        nTriggerFormFocus() {
          if (NFormItem2) {
            NFormItem2.handleContentFocus();
          }
        },
        nTriggerFormInput() {
          if (NFormItem2) {
            NFormItem2.handleContentInput();
          }
        }
      };
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$9.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$8 = Object.prototype;
    var nativeObjectToString = objectProto$8.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$1(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply$1(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$1(value);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$1 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject$1(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return false ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsZWJ$1 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      {
        return buffer.slice();
      }
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction$1(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    const cssrAnchorMetaName = "naive-ui-style";
    function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef) return void 0;
      const ssrAdapter2 = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
        const {
          value: rtlState
        } = rtlStateRef;
        if (!rtlState) {
          return void 0;
        }
        const componentRtlState = rtlState[mountId];
        if (!componentRtlState) {
          return void 0;
        }
        return componentRtlState;
      });
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        watchEffect(() => {
          const {
            value: clsPrefix
          } = clsPrefixRef;
          const id2 = `${clsPrefix}${mountId}Rtl`;
          if (exists(id2, ssrAdapter2)) return;
          const {
            value: componentRtlState
          } = componentRtlStateRef;
          if (!componentRtlState) return;
          componentRtlState.style.mount({
            id: id2,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        });
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
    }
    const commonVariables$n = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
      fontWeight: "400",
      fontWeightStrong: "500",
      cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
      cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
      cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
      borderRadius: "3px",
      borderRadiusSmall: "2px",
      fontSize: "14px",
      fontSizeMini: "12px",
      fontSizeTiny: "12px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      lineHeight: "1.6",
      heightMini: "16px",
      // private now, it's too small
      heightTiny: "22px",
      heightSmall: "28px",
      heightMedium: "34px",
      heightLarge: "40px",
      heightHuge: "46px"
    };
    const {
      fontSize,
      fontFamily,
      lineHeight
    } = commonVariables$n;
    const globalStyle = c("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
    function useStyle(mountId, style2, clsPrefixRef) {
      if (!style2) {
        return;
      }
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
        if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    function createTheme(theme) {
      return theme;
    }
    function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter2 = useSsrAdapter();
      const NConfigProvider2 = inject(configProviderInjectionKey, null);
      if (style2) {
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          onBeforeMount(mountStyle);
        }
      }
      const mergedThemeRef = computed(() => {
        var _a2;
        const {
          theme: {
            common: selfCommon,
            self: self2,
            peers = {}
          } = {},
          themeOverrides: selfOverrides = {},
          builtinThemeOverrides: builtinOverrides = {}
        } = props;
        const {
          common: selfCommonOverrides,
          peers: peersOverrides
        } = selfOverrides;
        const {
          common: globalCommon = void 0,
          [resolveId]: {
            common: globalSelfCommon = void 0,
            self: globalSelf = void 0,
            peers: globalPeers = {}
          } = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
        const {
          common: globalCommonOverrides = void 0,
          [resolveId]: globalSelfOverrides = {}
        } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
        const {
          common: globalSelfCommonOverrides,
          peers: globalPeersOverrides = {}
        } = globalSelfOverrides;
        const mergedCommon = merge({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
        const mergedSelf = merge(
          // {}, executed every time, no need for empty obj
          (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
          builtinOverrides,
          globalSelfOverrides,
          selfOverrides
        );
        return {
          common: mergedCommon,
          self: mergedSelf,
          peers: merge({}, defaultTheme.peers, globalPeers, peers),
          peerOverrides: merge({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
        };
      });
      return mergedThemeRef;
    }
    useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
    };
    const style$c = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c("svg", `
 height: 1em;
 width: 1em;
 `)]);
    const NBaseIcon = /* @__PURE__ */ defineComponent({
      name: "BaseIcon",
      props: {
        role: String,
        ariaLabel: String,
        ariaDisabled: {
          type: Boolean,
          default: void 0
        },
        ariaHidden: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: {
          type: String,
          required: true
        },
        onClick: Function,
        onMousedown: Function,
        onMouseup: Function
      },
      setup(props) {
        useStyle("-base-icon", style$c, toRef(props, "clsPrefix"));
      },
      render() {
        return h("i", {
          class: `${this.clsPrefix}-base-icon`,
          onClick: this.onClick,
          onMousedown: this.onMousedown,
          onMouseup: this.onMouseup,
          role: this.role,
          "aria-label": this.ariaLabel,
          "aria-hidden": this.ariaHidden,
          "aria-disabled": this.ariaDisabled
        }, this.$slots);
      }
    });
    const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
      name: "BaseIconSwitchTransition",
      setup(_, {
        slots
      }) {
        const isMountedRef = isMounted();
        return () => h(Transition, {
          name: "icon-switch-transition",
          appear: isMountedRef.value
        }, slots);
      }
    });
    function replaceable(name, icon) {
      const IconComponent = /* @__PURE__ */ defineComponent({
        render() {
          return icon();
        }
      });
      return /* @__PURE__ */ defineComponent({
        name: upperFirst(name),
        setup() {
          var _a2;
          const mergedIconsRef = (_a2 = inject(configProviderInjectionKey, null)) === null || _a2 === void 0 ? void 0 : _a2.mergedIconsRef;
          return () => {
            var _a3;
            const iconOverride = (_a3 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a3 === void 0 ? void 0 : _a3[name];
            return iconOverride ? iconOverride() : h(IconComponent, null);
          };
        }
      });
    }
    const ErrorIcon = replaceable("close", () => h("svg", {
      viewBox: "0 0 12 12",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": true
    }, h("g", {
      stroke: "none",
      "stroke-width": "1",
      fill: "none",
      "fill-rule": "evenodd"
    }, h("g", {
      fill: "currentColor",
      "fill-rule": "nonzero"
    }, h("path", {
      d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
    })))));
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$3
    } = commonVariables$n;
    function iconSwitchTransition({
      originalTransform = "",
      left = 0,
      top = 0,
      transition = `all .3s ${cubicBezierEaseInOut$3} !important`
    } = {}) {
      return [c("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
        transform: `${originalTransform} scale(0.75)`,
        left,
        top,
        opacity: 0
      }), c("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
        transform: `scale(1) ${originalTransform}`,
        left,
        top,
        opacity: 1
      }), c("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
        transformOrigin: "center",
        position: "absolute",
        left,
        top,
        transition
      })];
    }
    const style$b = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c("&::before", `
 border-radius: 50%;
 `)])]);
    const NBaseClose = /* @__PURE__ */ defineComponent({
      name: "BaseClose",
      props: {
        isButtonTag: {
          type: Boolean,
          default: true
        },
        clsPrefix: {
          type: String,
          required: true
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        focusable: {
          type: Boolean,
          default: true
        },
        round: Boolean,
        onClick: Function,
        absolute: Boolean
      },
      setup(props) {
        useStyle("-base-close", style$b, toRef(props, "clsPrefix"));
        return () => {
          const {
            clsPrefix,
            disabled,
            absolute,
            round,
            isButtonTag
          } = props;
          const Tag = isButtonTag ? "button" : "div";
          return h(Tag, {
            type: isButtonTag ? "button" : void 0,
            tabindex: disabled || !props.focusable ? -1 : 0,
            "aria-disabled": disabled,
            "aria-label": "close",
            role: isButtonTag ? void 0 : "button",
            disabled,
            class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round && `${clsPrefix}-base-close--round`],
            onMousedown: (e) => {
              if (!props.focusable) {
                e.preventDefault();
              }
            },
            onClick: props.onClick
          }, h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => h(ErrorIcon, null)
          }));
        };
      }
    });
    const NFadeInExpandTransition = /* @__PURE__ */ defineComponent({
      name: "FadeInExpandTransition",
      props: {
        appear: Boolean,
        group: Boolean,
        mode: String,
        onLeave: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        width: Boolean,
        // reverse mode is only used in tree
        // it make it from expanded to collapsed after mounted
        reverse: Boolean
      },
      setup(props, {
        slots
      }) {
        function handleBeforeLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = `${el2.offsetWidth}px`;
          } else {
            el2.style.maxHeight = `${el2.offsetHeight}px`;
          }
          void el2.offsetWidth;
        }
        function handleLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "0";
          } else {
            el2.style.maxHeight = "0";
          }
          void el2.offsetWidth;
          const {
            onLeave
          } = props;
          if (onLeave) onLeave();
        }
        function handleAfterLeave(el2) {
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            el2.style.maxHeight = "";
          }
          const {
            onAfterLeave
          } = props;
          if (onAfterLeave) onAfterLeave();
        }
        function handleEnter(el2) {
          el2.style.transition = "none";
          if (props.width) {
            const memorizedWidth = el2.offsetWidth;
            el2.style.maxWidth = "0";
            void el2.offsetWidth;
            el2.style.transition = "";
            el2.style.maxWidth = `${memorizedWidth}px`;
          } else {
            if (props.reverse) {
              el2.style.maxHeight = `${el2.offsetHeight}px`;
              void el2.offsetHeight;
              el2.style.transition = "";
              el2.style.maxHeight = "0";
            } else {
              const memorizedHeight = el2.offsetHeight;
              el2.style.maxHeight = "0";
              void el2.offsetWidth;
              el2.style.transition = "";
              el2.style.maxHeight = `${memorizedHeight}px`;
            }
          }
          void el2.offsetWidth;
        }
        function handleAfterEnter(el2) {
          var _a2;
          if (props.width) {
            el2.style.maxWidth = "";
          } else {
            if (!props.reverse) {
              el2.style.maxHeight = "";
            }
          }
          (_a2 = props.onAfterEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        return () => {
          const {
            group,
            width,
            appear,
            mode
          } = props;
          const type = group ? TransitionGroup : Transition;
          const resolvedProps = {
            name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
            appear,
            onEnter: handleEnter,
            onAfterEnter: handleAfterEnter,
            onBeforeLeave: handleBeforeLeave,
            onLeave: handleLeave,
            onAfterLeave: handleAfterLeave
          };
          if (!group) {
            resolvedProps.mode = mode;
          }
          return h(type, resolvedProps, slots);
        };
      }
    });
    const style$a = c([c("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE$1("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE$1("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("container", `
 animation: rotator 3s linear infinite both;
 `, [cE$1("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
    const duration = "1.6s";
    const exposedLoadingProps = {
      strokeWidth: {
        type: Number,
        default: 28
      },
      stroke: {
        type: String,
        default: void 0
      }
    };
    const NBaseLoading = /* @__PURE__ */ defineComponent({
      name: "BaseLoading",
      props: Object.assign({
        clsPrefix: {
          type: String,
          required: true
        },
        show: {
          type: Boolean,
          default: true
        },
        scale: {
          type: Number,
          default: 1
        },
        radius: {
          type: Number,
          default: 100
        }
      }, exposedLoadingProps),
      setup(props) {
        useStyle("-base-loading", style$a, toRef(props, "clsPrefix"));
      },
      render() {
        const {
          clsPrefix,
          radius,
          strokeWidth,
          stroke,
          scale
        } = this;
        const scaledRadius = radius / scale;
        return h("div", {
          class: `${clsPrefix}-base-loading`,
          role: "img",
          "aria-label": "loading"
        }, h(NIconSwitchTransition, null, {
          default: () => this.show ? h("div", {
            key: "icon",
            class: `${clsPrefix}-base-loading__transition-wrapper`
          }, h("div", {
            class: `${clsPrefix}-base-loading__container`
          }, h("svg", {
            class: `${clsPrefix}-base-loading__icon`,
            viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
            xmlns: "http://www.w3.org/2000/svg",
            style: {
              color: stroke
            }
          }, h("g", null, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("circle", {
            class: `${clsPrefix}-base-loading__icon`,
            fill: "none",
            stroke: "currentColor",
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            cx: scaledRadius,
            cy: scaledRadius,
            r: radius - strokeWidth / 2,
            "stroke-dasharray": 5.67 * radius,
            "stroke-dashoffset": 18.48 * radius
          }, h("animateTransform", {
            attributeName: "transform",
            type: "rotate",
            values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          }), h("animate", {
            attributeName: "stroke-dashoffset",
            values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
            begin: "0s",
            dur: duration,
            fill: "freeze",
            repeatCount: "indefinite"
          })))))) : h("div", {
            key: "placeholder",
            class: `${clsPrefix}-base-loading__placeholder`
          }, this.$slots)
        }));
      }
    });
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$2
    } = commonVariables$n;
    function fadeInTransition({
      name = "fade-in",
      enterDuration = "0.2s",
      leaveDuration = "0.2s",
      enterCubicBezier = cubicBezierEaseInOut$2,
      leaveCubicBezier = cubicBezierEaseInOut$2
    } = {}) {
      return [c(`&.${name}-transition-enter-active`, {
        transition: `all ${enterDuration} ${enterCubicBezier}!important`
      }), c(`&.${name}-transition-leave-active`, {
        transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
      }), c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0
      }), c(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
        opacity: 1
      })];
    }
    const base$2 = {
      neutralBase: "#000",
      neutralInvertBase: "#fff",
      neutralTextBase: "#fff",
      neutralPopover: "rgb(72, 72, 78)",
      neutralCard: "rgb(24, 24, 28)",
      neutralModal: "rgb(44, 44, 50)",
      neutralBody: "rgb(16, 16, 20)",
      alpha1: "0.9",
      alpha2: "0.82",
      alpha3: "0.52",
      alpha4: "0.38",
      alpha5: "0.28",
      alphaClose: "0.52",
      alphaDisabled: "0.38",
      alphaDisabledInput: "0.06",
      alphaPending: "0.09",
      alphaTablePending: "0.06",
      alphaTableStriped: "0.05",
      alphaPressed: "0.05",
      alphaAvatar: "0.18",
      alphaRail: "0.2",
      alphaProgressRail: "0.12",
      alphaBorder: "0.24",
      alphaDivider: "0.09",
      alphaInput: "0.1",
      alphaAction: "0.06",
      alphaTab: "0.04",
      alphaScrollbar: "0.2",
      alphaScrollbarHover: "0.3",
      alphaCode: "0.12",
      alphaTag: "0.2",
      // primary
      primaryHover: "#7fe7c4",
      primaryDefault: "#63e2b7",
      primaryActive: "#5acea7",
      primarySuppl: "rgb(42, 148, 125)",
      // info
      infoHover: "#8acbec",
      infoDefault: "#70c0e8",
      infoActive: "#66afd3",
      infoSuppl: "rgb(56, 137, 197)",
      // error
      errorHover: "#e98b8b",
      errorDefault: "#e88080",
      errorActive: "#e57272",
      errorSuppl: "rgb(208, 58, 82)",
      // warning
      warningHover: "#f5d599",
      warningDefault: "#f2c97d",
      warningActive: "#e6c260",
      warningSuppl: "rgb(240, 138, 0)",
      // success
      successHover: "#7fe7c4",
      successDefault: "#63e2b7",
      successActive: "#5acea7",
      successSuppl: "rgb(42, 148, 125)"
    };
    const baseBackgroundRgb$1 = rgba(base$2.neutralBase);
    const baseInvertBackgroundRgb$1 = rgba(base$2.neutralInvertBase);
    const overlayPrefix$1 = `rgba(${baseInvertBackgroundRgb$1.slice(0, 3).join(", ")}, `;
    function overlay$1(alpha) {
      return `${overlayPrefix$1 + String(alpha)})`;
    }
    function neutral$1(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb$1);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb$1, overlayRgba);
    }
    const derived$1 = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base$2.neutralBase,
      // primary color
      primaryColor: base$2.primaryDefault,
      primaryColorHover: base$2.primaryHover,
      primaryColorPressed: base$2.primaryActive,
      primaryColorSuppl: base$2.primarySuppl,
      // info color
      infoColor: base$2.infoDefault,
      infoColorHover: base$2.infoHover,
      infoColorPressed: base$2.infoActive,
      infoColorSuppl: base$2.infoSuppl,
      // success color
      successColor: base$2.successDefault,
      successColorHover: base$2.successHover,
      successColorPressed: base$2.successActive,
      successColorSuppl: base$2.successSuppl,
      // warning color
      warningColor: base$2.warningDefault,
      warningColorHover: base$2.warningHover,
      warningColorPressed: base$2.warningActive,
      warningColorSuppl: base$2.warningSuppl,
      // error color
      errorColor: base$2.errorDefault,
      errorColorHover: base$2.errorHover,
      errorColorPressed: base$2.errorActive,
      errorColorSuppl: base$2.errorSuppl,
      // text color
      textColorBase: base$2.neutralTextBase,
      textColor1: overlay$1(base$2.alpha1),
      textColor2: overlay$1(base$2.alpha2),
      textColor3: overlay$1(base$2.alpha3),
      // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
      // textColor5: overlay(base.alpha5),
      textColorDisabled: overlay$1(base$2.alpha4),
      placeholderColor: overlay$1(base$2.alpha4),
      placeholderColorDisabled: overlay$1(base$2.alpha5),
      iconColor: overlay$1(base$2.alpha4),
      iconColorDisabled: overlay$1(base$2.alpha5),
      iconColorHover: overlay$1(Number(base$2.alpha4) * 1.25),
      iconColorPressed: overlay$1(Number(base$2.alpha4) * 0.8),
      opacity1: base$2.alpha1,
      opacity2: base$2.alpha2,
      opacity3: base$2.alpha3,
      opacity4: base$2.alpha4,
      opacity5: base$2.alpha5,
      dividerColor: overlay$1(base$2.alphaDivider),
      borderColor: overlay$1(base$2.alphaBorder),
      // close
      closeIconColorHover: overlay$1(Number(base$2.alphaClose)),
      closeIconColor: overlay$1(Number(base$2.alphaClose)),
      closeIconColorPressed: overlay$1(Number(base$2.alphaClose)),
      closeColorHover: "rgba(255, 255, 255, .12)",
      closeColorPressed: "rgba(255, 255, 255, .08)",
      // clear
      clearColor: overlay$1(base$2.alpha4),
      clearColorHover: scaleColor(overlay$1(base$2.alpha4), {
        alpha: 1.25
      }),
      clearColorPressed: scaleColor(overlay$1(base$2.alpha4), {
        alpha: 0.8
      }),
      scrollbarColor: overlay$1(base$2.alphaScrollbar),
      scrollbarColorHover: overlay$1(base$2.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: overlay$1(base$2.alphaProgressRail),
      railColor: overlay$1(base$2.alphaRail),
      popoverColor: base$2.neutralPopover,
      tableColor: base$2.neutralCard,
      cardColor: base$2.neutralCard,
      modalColor: base$2.neutralModal,
      bodyColor: base$2.neutralBody,
      tagColor: neutral$1(base$2.alphaTag),
      avatarColor: overlay$1(base$2.alphaAvatar),
      invertedColor: base$2.neutralBase,
      inputColor: overlay$1(base$2.alphaInput),
      codeColor: overlay$1(base$2.alphaCode),
      tabColor: overlay$1(base$2.alphaTab),
      actionColor: overlay$1(base$2.alphaAction),
      tableHeaderColor: overlay$1(base$2.alphaAction),
      hoverColor: overlay$1(base$2.alphaPending),
      tableColorHover: overlay$1(base$2.alphaTablePending),
      tableColorStriped: overlay$1(base$2.alphaTableStriped),
      pressedColor: overlay$1(base$2.alphaPressed),
      opacityDisabled: base$2.alphaDisabled,
      inputColorDisabled: overlay$1(base$2.alphaDisabledInput),
      buttonColor2: "rgba(255, 255, 255, .08)",
      buttonColor2Hover: "rgba(255, 255, 255, .12)",
      buttonColor2Pressed: "rgba(255, 255, 255, .08)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const base$1 = {
      neutralBase: "#FFF",
      neutralInvertBase: "#000",
      neutralTextBase: "#000",
      neutralPopover: "#fff",
      neutralCard: "#fff",
      neutralModal: "#fff",
      neutralBody: "#fff",
      alpha1: "0.82",
      alpha2: "0.72",
      alpha3: "0.38",
      alpha4: "0.24",
      // disabled text, placeholder, icon
      alpha5: "0.18",
      // disabled placeholder
      alphaClose: "0.6",
      alphaDisabled: "0.5",
      alphaAvatar: "0.2",
      alphaProgressRail: ".08",
      alphaInput: "0",
      alphaScrollbar: "0.25",
      alphaScrollbarHover: "0.4",
      // primary
      primaryHover: "#36ad6a",
      primaryDefault: "#18a058",
      primaryActive: "#0c7a43",
      primarySuppl: "#36ad6a",
      // info
      infoHover: "#4098fc",
      infoDefault: "#2080f0",
      infoActive: "#1060c9",
      infoSuppl: "#4098fc",
      // error
      errorHover: "#de576d",
      errorDefault: "#d03050",
      errorActive: "#ab1f3f",
      errorSuppl: "#de576d",
      // warning
      warningHover: "#fcb040",
      warningDefault: "#f0a020",
      warningActive: "#c97c10",
      warningSuppl: "#fcb040",
      // success
      successHover: "#36ad6a",
      successDefault: "#18a058",
      successActive: "#0c7a43",
      successSuppl: "#36ad6a"
    };
    const baseBackgroundRgb = rgba(base$1.neutralBase);
    const baseInvertBackgroundRgb = rgba(base$1.neutralInvertBase);
    const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
    function overlay(alpha) {
      return `${overlayPrefix + String(alpha)})`;
    }
    function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
    }
    const derived = Object.assign(Object.assign({
      name: "common"
    }, commonVariables$n), {
      baseColor: base$1.neutralBase,
      // primary color
      primaryColor: base$1.primaryDefault,
      primaryColorHover: base$1.primaryHover,
      primaryColorPressed: base$1.primaryActive,
      primaryColorSuppl: base$1.primarySuppl,
      // info color
      infoColor: base$1.infoDefault,
      infoColorHover: base$1.infoHover,
      infoColorPressed: base$1.infoActive,
      infoColorSuppl: base$1.infoSuppl,
      // success color
      successColor: base$1.successDefault,
      successColorHover: base$1.successHover,
      successColorPressed: base$1.successActive,
      successColorSuppl: base$1.successSuppl,
      // warning color
      warningColor: base$1.warningDefault,
      warningColorHover: base$1.warningHover,
      warningColorPressed: base$1.warningActive,
      warningColorSuppl: base$1.warningSuppl,
      // error color
      errorColor: base$1.errorDefault,
      errorColorHover: base$1.errorHover,
      errorColorPressed: base$1.errorActive,
      errorColorSuppl: base$1.errorSuppl,
      // text color
      textColorBase: base$1.neutralTextBase,
      textColor1: "rgb(31, 34, 37)",
      textColor2: "rgb(51, 54, 57)",
      textColor3: "rgb(118, 124, 130)",
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base$1.alpha4),
      placeholderColor: neutral(base$1.alpha4),
      placeholderColorDisabled: neutral(base$1.alpha5),
      iconColor: neutral(base$1.alpha4),
      iconColorHover: scaleColor(neutral(base$1.alpha4), {
        lightness: 0.75
      }),
      iconColorPressed: scaleColor(neutral(base$1.alpha4), {
        lightness: 0.9
      }),
      iconColorDisabled: neutral(base$1.alpha5),
      opacity1: base$1.alpha1,
      opacity2: base$1.alpha2,
      opacity3: base$1.alpha3,
      opacity4: base$1.alpha4,
      opacity5: base$1.alpha5,
      dividerColor: "rgb(239, 239, 245)",
      borderColor: "rgb(224, 224, 230)",
      // close
      closeIconColor: neutral(Number(base$1.alphaClose)),
      closeIconColorHover: neutral(Number(base$1.alphaClose)),
      closeIconColorPressed: neutral(Number(base$1.alphaClose)),
      closeColorHover: "rgba(0, 0, 0, .09)",
      closeColorPressed: "rgba(0, 0, 0, .13)",
      // clear
      clearColor: neutral(base$1.alpha4),
      clearColorHover: scaleColor(neutral(base$1.alpha4), {
        lightness: 0.75
      }),
      clearColorPressed: scaleColor(neutral(base$1.alpha4), {
        lightness: 0.9
      }),
      scrollbarColor: overlay(base$1.alphaScrollbar),
      scrollbarColorHover: overlay(base$1.alphaScrollbarHover),
      scrollbarWidth: "5px",
      scrollbarHeight: "5px",
      scrollbarBorderRadius: "5px",
      progressRailColor: neutral(base$1.alphaProgressRail),
      railColor: "rgb(219, 219, 223)",
      popoverColor: base$1.neutralPopover,
      tableColor: base$1.neutralCard,
      cardColor: base$1.neutralCard,
      modalColor: base$1.neutralModal,
      bodyColor: base$1.neutralBody,
      tagColor: "#eee",
      avatarColor: neutral(base$1.alphaAvatar),
      invertedColor: "rgb(0, 20, 40)",
      inputColor: neutral(base$1.alphaInput),
      codeColor: "rgb(244, 244, 248)",
      tabColor: "rgb(247, 247, 250)",
      actionColor: "rgb(250, 250, 252)",
      tableHeaderColor: "rgb(250, 250, 252)",
      hoverColor: "rgb(243, 243, 245)",
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: "rgba(0, 0, 100, 0.03)",
      tableColorStriped: "rgba(0, 0, 100, 0.02)",
      pressedColor: "rgb(237, 237, 239)",
      opacityDisabled: base$1.alphaDisabled,
      inputColorDisabled: "rgb(250, 250, 252)",
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: "rgba(46, 51, 56, .05)",
      buttonColor2Hover: "rgba(46, 51, 56, .09)",
      buttonColor2Pressed: "rgba(46, 51, 56, .13)",
      boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
      boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
      boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
    });
    const commonVars$d = {
      railInsetHorizontalBottom: "auto 2px 4px 2px",
      railInsetHorizontalTop: "4px 2px auto 2px",
      railInsetVerticalRight: "2px 4px 2px auto",
      railInsetVerticalLeft: "2px auto 2px 4px",
      railColor: "transparent"
    };
    function self$S(vars) {
      const {
        scrollbarColor,
        scrollbarColorHover,
        scrollbarHeight,
        scrollbarWidth,
        scrollbarBorderRadius
      } = vars;
      return Object.assign(Object.assign({}, commonVars$d), {
        height: scrollbarHeight,
        width: scrollbarWidth,
        borderRadius: scrollbarBorderRadius,
        color: scrollbarColor,
        colorHover: scrollbarColorHover
      });
    }
    const scrollbarLight = {
      name: "Scrollbar",
      common: derived,
      self: self$S
    };
    const scrollbarDark = {
      name: "Scrollbar",
      common: derived$1,
      self: self$S
    };
    const style$9 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c(">", [
      // We can't set overflow hidden since it affects positioning.
      cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
    ])])]), c(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c(">", [cE$1("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c(">", [cE$1("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM("disabled", [c(">", [cE$1("scrollbar", "pointer-events: none;")])]), c(">", [cE$1("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
    const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
      duration: {
        type: Number,
        default: 0
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      xScrollable: Boolean,
      trigger: {
        type: String,
        default: "hover"
      },
      useUnifiedContainer: Boolean,
      triggerDisplayManually: Boolean,
      // If container is set, resize observer won't not attached
      container: Function,
      content: Function,
      containerClass: String,
      containerStyle: [String, Object],
      contentClass: [String, Array],
      contentStyle: [String, Object],
      horizontalRailStyle: [String, Object],
      verticalRailStyle: [String, Object],
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      internalOnUpdateScrollLeft: Function,
      internalHoistYRail: Boolean,
      yPlacement: {
        type: String,
        default: "right"
      },
      xPlacement: {
        type: String,
        default: "bottom"
      }
    });
    const Scrollbar = /* @__PURE__ */ defineComponent({
      name: "Scrollbar",
      props: scrollbarProps,
      inheritAttrs: false,
      setup(props) {
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
        const wrapperRef = ref(null);
        const containerRef = ref(null);
        const contentRef = ref(null);
        const yRailRef = ref(null);
        const xRailRef = ref(null);
        const contentHeightRef = ref(null);
        const contentWidthRef = ref(null);
        const containerHeightRef = ref(null);
        const containerWidthRef = ref(null);
        const yRailSizeRef = ref(null);
        const xRailSizeRef = ref(null);
        const containerScrollTopRef = ref(0);
        const containerScrollLeftRef = ref(0);
        const isShowXBarRef = ref(false);
        const isShowYBarRef = ref(false);
        let yBarPressed = false;
        let xBarPressed = false;
        let xBarVanishTimerId;
        let yBarVanishTimerId;
        let memoYTop = 0;
        let memoXLeft = 0;
        let memoMouseX = 0;
        let memoMouseY = 0;
        const isIos2 = useIsIos();
        const themeRef = useTheme("Scrollbar", "-scrollbar", style$9, scrollbarLight, props, mergedClsPrefixRef);
        const yBarSizeRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
          }
        });
        const yBarSizePxRef = computed(() => {
          return `${yBarSizeRef.value}px`;
        });
        const xBarSizeRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
          }
        });
        const xBarSizePxRef = computed(() => {
          return `${xBarSizeRef.value}px`;
        });
        const yBarTopRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: containerScrollTop
          } = containerScrollTopRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yRailSize
          } = yRailSizeRef;
          if (containerHeight === null || contentHeight === null || yRailSize === null) {
            return 0;
          } else {
            const heightDiff = contentHeight - containerHeight;
            if (!heightDiff) return 0;
            return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
          }
        });
        const yBarTopPxRef = computed(() => {
          return `${yBarTopRef.value}px`;
        });
        const xBarLeftRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: containerScrollLeft
          } = containerScrollLeftRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xRailSize
          } = xRailSizeRef;
          if (containerWidth === null || contentWidth === null || xRailSize === null) {
            return 0;
          } else {
            const widthDiff = contentWidth - containerWidth;
            if (!widthDiff) return 0;
            return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
          }
        });
        const xBarLeftPxRef = computed(() => {
          return `${xBarLeftRef.value}px`;
        });
        const needYBarRef = computed(() => {
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
        });
        const needXBarRef = computed(() => {
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
        });
        const mergedShowXBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowXBarRef.value;
        });
        const mergedShowYBarRef = computed(() => {
          const {
            trigger: trigger2
          } = props;
          return trigger2 === "none" || isShowYBarRef.value;
        });
        const mergedContainerRef = computed(() => {
          const {
            container
          } = props;
          if (container) return container();
          return containerRef.value;
        });
        const mergedContentRef = computed(() => {
          const {
            content
          } = props;
          if (content) return content();
          return contentRef.value;
        });
        const scrollTo = (options, y) => {
          if (!props.scrollable) return;
          if (typeof options === "number") {
            scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
            return;
          }
          const {
            left,
            top,
            index,
            elSize,
            position,
            behavior,
            el: el2,
            debounce = true
          } = options;
          if (left !== void 0 || top !== void 0) {
            scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
          }
          if (el2 !== void 0) {
            scrollToPosition(0, el2.offsetTop, el2.offsetHeight, debounce, behavior);
          } else if (index !== void 0 && elSize !== void 0) {
            scrollToPosition(0, index * elSize, elSize, debounce, behavior);
          } else if (position === "bottom") {
            scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
          } else if (position === "top") {
            scrollToPosition(0, 0, 0, false, behavior);
          }
        };
        const activateState = useReactivated(() => {
          if (!props.container) {
            scrollTo({
              top: containerScrollTopRef.value,
              left: containerScrollLeftRef.value
            });
          }
        });
        const handleContentResize = () => {
          if (activateState.isDeactivated) return;
          sync();
        };
        const handleContainerResize = (e) => {
          if (activateState.isDeactivated) return;
          const {
            onResize
          } = props;
          if (onResize) onResize(e);
          sync();
        };
        const scrollBy = (options, y) => {
          if (!props.scrollable) return;
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (typeof options === "object") {
            container.scrollBy(options);
          } else {
            container.scrollBy(options, y || 0);
          }
        };
        function scrollToPosition(left, top, elSize, debounce, behavior) {
          const {
            value: container
          } = mergedContainerRef;
          if (!container) return;
          if (debounce) {
            const {
              scrollTop,
              offsetHeight
            } = container;
            if (top > scrollTop) {
              if (top + elSize <= scrollTop + offsetHeight) ;
              else {
                container.scrollTo({
                  left,
                  top: top + elSize - offsetHeight,
                  behavior
                });
              }
              return;
            }
          }
          container.scrollTo({
            left,
            top,
            behavior
          });
        }
        function handleMouseEnterWrapper() {
          showXBar();
          showYBar();
          sync();
        }
        function handleMouseLeaveWrapper() {
          hideBar();
        }
        function hideBar() {
          hideYBar();
          hideXBar();
        }
        function hideYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          yBarVanishTimerId = window.setTimeout(() => {
            isShowYBarRef.value = false;
          }, props.duration);
        }
        function hideXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          xBarVanishTimerId = window.setTimeout(() => {
            isShowXBarRef.value = false;
          }, props.duration);
        }
        function showXBar() {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          isShowXBarRef.value = true;
        }
        function showYBar() {
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          isShowYBarRef.value = true;
        }
        function handleScroll(e) {
          const {
            onScroll
          } = props;
          if (onScroll) onScroll(e);
          syncScrollState();
        }
        function syncScrollState() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          }
        }
        function syncPositionState() {
          const {
            value: content
          } = mergedContentRef;
          if (content) {
            contentHeightRef.value = content.offsetHeight;
            contentWidthRef.value = content.offsetWidth;
          }
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function syncUnifiedContainer() {
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            containerScrollTopRef.value = container.scrollTop;
            containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            containerHeightRef.value = container.offsetHeight;
            containerWidthRef.value = container.offsetWidth;
            contentHeightRef.value = container.scrollHeight;
            contentWidthRef.value = container.scrollWidth;
          }
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            xRailSizeRef.value = xRailEl.offsetWidth;
          }
          if (yRailEl) {
            yRailSizeRef.value = yRailEl.offsetHeight;
          }
        }
        function sync() {
          if (!props.scrollable) return;
          if (props.useUnifiedContainer) {
            syncUnifiedContainer();
          } else {
            syncPositionState();
            syncScrollState();
          }
        }
        function isMouseUpAway(e) {
          var _a2;
          return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
        }
        function handleXScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          xBarPressed = true;
          on$1("mousemove", window, handleXScrollMouseMove, true);
          on$1("mouseup", window, handleXScrollMouseUp, true);
          memoXLeft = containerScrollLeftRef.value;
          memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
        }
        function handleXScrollMouseMove(e) {
          if (!xBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerWidth
          } = containerWidthRef;
          const {
            value: contentWidth
          } = contentWidthRef;
          const {
            value: xBarSize
          } = xBarSizeRef;
          if (containerWidth === null || contentWidth === null) return;
          const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
          const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
          const toScrollLeftUpperBound = contentWidth - containerWidth;
          let toScrollLeft = memoXLeft + dScrollLeft;
          toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
          toScrollLeft = Math.max(toScrollLeft, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            const {
              internalOnUpdateScrollLeft
            } = props;
            if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
          }
        }
        function handleXScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleXScrollMouseMove, true);
          off("mouseup", window, handleXScrollMouseUp, true);
          xBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        function handleYScrollMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          yBarPressed = true;
          on$1("mousemove", window, handleYScrollMouseMove, true);
          on$1("mouseup", window, handleYScrollMouseUp, true);
          memoYTop = containerScrollTopRef.value;
          memoMouseY = e.clientY;
        }
        function handleYScrollMouseMove(e) {
          if (!yBarPressed) return;
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          const {
            value: containerHeight
          } = containerHeightRef;
          const {
            value: contentHeight
          } = contentHeightRef;
          const {
            value: yBarSize
          } = yBarSizeRef;
          if (containerHeight === null || contentHeight === null) return;
          const dY = e.clientY - memoMouseY;
          const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
          const toScrollTopUpperBound = contentHeight - containerHeight;
          let toScrollTop = memoYTop + dScrollTop;
          toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
          toScrollTop = Math.max(toScrollTop, 0);
          const {
            value: container
          } = mergedContainerRef;
          if (container) {
            container.scrollTop = toScrollTop;
          }
        }
        function handleYScrollMouseUp(e) {
          e.preventDefault();
          e.stopPropagation();
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
          yBarPressed = false;
          sync();
          if (isMouseUpAway(e)) {
            hideBar();
          }
        }
        watchEffect(() => {
          const {
            value: needXBar
          } = needXBarRef;
          const {
            value: needYBar
          } = needYBarRef;
          const {
            value: mergedClsPrefix
          } = mergedClsPrefixRef;
          const {
            value: xRailEl
          } = xRailRef;
          const {
            value: yRailEl
          } = yRailRef;
          if (xRailEl) {
            if (!needXBar) {
              xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
          if (yRailEl) {
            if (!needYBar) {
              yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            } else {
              yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
            }
          }
        });
        onMounted(() => {
          if (props.container) return;
          sync();
        });
        onBeforeUnmount(() => {
          if (xBarVanishTimerId !== void 0) {
            window.clearTimeout(xBarVanishTimerId);
          }
          if (yBarVanishTimerId !== void 0) {
            window.clearTimeout(yBarVanishTimerId);
          }
          off("mousemove", window, handleYScrollMouseMove, true);
          off("mouseup", window, handleYScrollMouseUp, true);
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              color,
              colorHover,
              height,
              width,
              borderRadius,
              railInsetHorizontalTop,
              railInsetHorizontalBottom,
              railInsetVerticalRight,
              railInsetVerticalLeft,
              railColor
            }
          } = themeRef.value;
          const {
            top: railTopHorizontalTop,
            right: railRightHorizontalTop,
            bottom: railBottomHorizontalTop,
            left: railLeftHorizontalTop
          } = getMargin(railInsetHorizontalTop);
          const {
            top: railTopHorizontalBottom,
            right: railRightHorizontalBottom,
            bottom: railBottomHorizontalBottom,
            left: railLeftHorizontalBottom
          } = getMargin(railInsetHorizontalBottom);
          const {
            top: railTopVerticalRight,
            right: railRightVerticalRight,
            bottom: railBottomVerticalRight,
            left: railLeftVerticalRight
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
          const {
            top: railTopVerticalLeft,
            right: railRightVerticalLeft,
            bottom: railBottomVerticalLeft,
            left: railLeftVerticalLeft
          } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
          return {
            "--n-scrollbar-bezier": cubicBezierEaseInOut2,
            "--n-scrollbar-color": color,
            "--n-scrollbar-color-hover": colorHover,
            "--n-scrollbar-border-radius": borderRadius,
            "--n-scrollbar-width": width,
            "--n-scrollbar-height": height,
            "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
            "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
            "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
            "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
            "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
            "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
            "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
            "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
            "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
            "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
            "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
            "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
            "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
            "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
            "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
            "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
            "--n-scrollbar-rail-color": railColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
        const exposedMethods = {
          scrollTo,
          scrollBy,
          sync,
          syncUnifiedContainer,
          handleMouseEnterWrapper,
          handleMouseLeaveWrapper
        };
        return Object.assign(Object.assign({}, exposedMethods), {
          mergedClsPrefix: mergedClsPrefixRef,
          rtlEnabled: rtlEnabledRef,
          containerScrollTop: containerScrollTopRef,
          wrapperRef,
          containerRef,
          contentRef,
          yRailRef,
          xRailRef,
          needYBar: needYBarRef,
          needXBar: needXBarRef,
          yBarSizePx: yBarSizePxRef,
          xBarSizePx: xBarSizePxRef,
          yBarTopPx: yBarTopPxRef,
          xBarLeftPx: xBarLeftPxRef,
          isShowXBar: mergedShowXBarRef,
          isShowYBar: mergedShowYBarRef,
          isIos: isIos2,
          handleScroll,
          handleContentResize,
          handleContainerResize,
          handleYScrollMouseDown,
          handleXScrollMouseDown,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        var _a2;
        const {
          $slots,
          mergedClsPrefix,
          triggerDisplayManually,
          rtlEnabled,
          internalHoistYRail,
          yPlacement,
          xPlacement,
          xScrollable
        } = this;
        if (!this.scrollable) return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
        const triggerIsNone = this.trigger === "none";
        const createYRail = (className, style2) => {
          return h("div", {
            ref: "yRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
            "data-scrollbar-rail": true,
            style: [style2 || "", this.verticalRailStyle],
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needYBar && this.isShowYBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                height: this.yBarSizePx,
                top: this.yBarTopPx
              },
              onMousedown: this.handleYScrollMouseDown
            }) : null
          }));
        };
        const createChildren = () => {
          var _a3, _b2;
          (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
          return h("div", mergeProps(this.$attrs, {
            role: "none",
            ref: "wrapperRef",
            class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
            style: this.cssVars,
            onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
            onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
          }), [this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h("div", {
            role: "none",
            ref: "containerRef",
            class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
            style: this.containerStyle,
            onScroll: this.handleScroll,
            onWheel: this.onWheel
          }, h(VResizeObserver, {
            onResize: this.handleContentResize
          }, {
            default: () => h("div", {
              ref: "contentRef",
              role: "none",
              style: [{
                width: this.xScrollable ? "fit-content" : null
              }, this.contentStyle],
              class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
            }, $slots)
          })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && h("div", {
            ref: "xRailRef",
            class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
            style: this.horizontalRailStyle,
            "data-scrollbar-rail": true,
            "aria-hidden": true
          }, h(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
            name: "fade-in-transition"
          }, {
            default: () => this.needXBar && this.isShowXBar && !this.isIos ? h("div", {
              class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
              style: {
                width: this.xBarSizePx,
                right: rtlEnabled ? this.xBarLeftPx : void 0,
                left: rtlEnabled ? void 0 : this.xBarLeftPx
              },
              onMousedown: this.handleXScrollMouseDown
            }) : null
          }))]);
        };
        const scrollbarNode = this.container ? createChildren() : h(VResizeObserver, {
          onResize: this.handleContainerResize
        }, {
          default: createChildren
        });
        if (internalHoistYRail) {
          return h(Fragment$1, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
        } else {
          return scrollbarNode;
        }
      }
    });
    const commonVars$c = {
      iconSizeTiny: "28px",
      iconSizeSmall: "34px",
      iconSizeMedium: "40px",
      iconSizeLarge: "46px",
      iconSizeHuge: "52px"
    };
    function self$R(vars) {
      const {
        textColorDisabled,
        iconColor,
        textColor2,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVars$c), {
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        textColor: textColorDisabled,
        iconColor,
        extraTextColor: textColor2
      });
    }
    const emptyLight = {
      name: "Empty",
      common: derived,
      self: self$R
    };
    const emptyDark = {
      name: "Empty",
      common: derived$1,
      self: self$R
    };
    const commonVariables$m = {
      height: "calc(var(--n-option-height) * 7.6)",
      paddingTiny: "4px 0",
      paddingSmall: "4px 0",
      paddingMedium: "4px 0",
      paddingLarge: "4px 0",
      paddingHuge: "4px 0",
      optionPaddingTiny: "0 12px",
      optionPaddingSmall: "0 12px",
      optionPaddingMedium: "0 12px",
      optionPaddingLarge: "0 12px",
      optionPaddingHuge: "0 12px",
      loadingSize: "18px"
    };
    function self$Q(vars) {
      const {
        borderRadius,
        popoverColor,
        textColor3,
        dividerColor,
        textColor2,
        primaryColorPressed,
        textColorDisabled,
        primaryColor,
        opacityDisabled,
        hoverColor,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$m), {
        optionFontSizeTiny: fontSizeTiny,
        optionFontSizeSmall: fontSizeSmall,
        optionFontSizeMedium: fontSizeMedium,
        optionFontSizeLarge: fontSizeLarge,
        optionFontSizeHuge: fontSizeHuge,
        optionHeightTiny: heightTiny,
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        color: popoverColor,
        groupHeaderTextColor: textColor3,
        actionDividerColor: dividerColor,
        optionTextColor: textColor2,
        optionTextColorPressed: primaryColorPressed,
        optionTextColorDisabled: textColorDisabled,
        optionTextColorActive: primaryColor,
        optionOpacityDisabled: opacityDisabled,
        optionCheckColor: primaryColor,
        optionColorPending: hoverColor,
        optionColorActive: "rgba(0, 0, 0, 0)",
        optionColorActivePending: hoverColor,
        actionTextColor: textColor2,
        loadingColor: primaryColor
      });
    }
    const internalSelectMenuDark = {
      name: "InternalSelectMenu",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self: self$Q
    };
    const commonVariables$l = {
      space: "6px",
      spaceArrow: "10px",
      arrowOffset: "10px",
      arrowOffsetVertical: "10px",
      arrowHeight: "6px",
      padding: "8px 14px"
    };
    function self$P(vars) {
      const {
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        fontSize: fontSize2,
        dividerColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$l), {
        fontSize: fontSize2,
        borderRadius,
        color: popoverColor,
        dividerColor,
        textColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const popoverDark = {
      name: "Popover",
      common: derived$1,
      self: self$P
    };
    const commonVariables$k = {
      closeIconSizeTiny: "12px",
      closeIconSizeSmall: "12px",
      closeIconSizeMedium: "14px",
      closeIconSizeLarge: "14px",
      closeSizeTiny: "16px",
      closeSizeSmall: "16px",
      closeSizeMedium: "18px",
      closeSizeLarge: "18px",
      padding: "0 7px",
      closeMargin: "0 0 0 4px"
    };
    const tagDark = {
      name: "Tag",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          primaryColorHover,
          primaryColorPressed,
          primaryColor,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          baseColor,
          borderColor,
          tagColor,
          opacityDisabled,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderRadiusSmall: borderRadius,
          fontSizeMini,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          heightMini,
          heightTiny,
          heightSmall,
          heightMedium,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$k), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
          // checked
          textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
          // default
          border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "#0000",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          colorBorderedPrimary: "#0000",
          closeIconColorPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorHoverPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeIconColorPressedPrimary: scaleColor(primaryColor, {
            lightness: 0.7
          }),
          closeColorHoverPrimary: changeColor(primaryColor, {
            alpha: 0.16
          }),
          closeColorPressedPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          borderInfo: `1px solid ${changeColor(infoColor, {
            alpha: 0.3
          })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          colorBorderedInfo: "#0000",
          closeIconColorInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorHoverInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeIconColorPressedInfo: scaleColor(infoColor, {
            alpha: 0.7
          }),
          closeColorHoverInfo: changeColor(infoColor, {
            alpha: 0.16
          }),
          closeColorPressedInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          borderSuccess: `1px solid ${changeColor(successColor, {
            alpha: 0.3
          })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          colorBorderedSuccess: "#0000",
          closeIconColorSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorHoverSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeIconColorPressedSuccess: scaleColor(successColor, {
            alpha: 0.7
          }),
          closeColorHoverSuccess: changeColor(successColor, {
            alpha: 0.16
          }),
          closeColorPressedSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          borderWarning: `1px solid ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          colorBorderedWarning: "#0000",
          closeIconColorWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorHoverWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeIconColorPressedWarning: scaleColor(warningColor, {
            alpha: 0.7
          }),
          closeColorHoverWarning: changeColor(warningColor, {
            alpha: 0.16
          }),
          closeColorPressedWarning: changeColor(warningColor, {
            alpha: 0.11
          }),
          borderError: `1px solid ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, {
            alpha: 0.16
          }),
          colorBorderedError: "#0000",
          closeIconColorError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorHoverError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeIconColorPressedError: scaleColor(errorColor, {
            alpha: 0.7
          }),
          closeColorHoverError: changeColor(errorColor, {
            alpha: 0.16
          }),
          closeColorPressedError: changeColor(errorColor, {
            alpha: 0.12
          })
        });
      }
    };
    const commonVariables$j = {
      paddingSingle: "0 26px 0 12px",
      paddingMultiple: "3px 26px 0 12px",
      clearSize: "16px",
      arrowSize: "16px"
    };
    const internalSelectionDark = {
      name: "InternalSelection",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          textColor2,
          textColorDisabled,
          inputColor,
          inputColorDisabled,
          primaryColor,
          primaryColorHover,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          iconColor,
          iconColorDisabled,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$j), {
          fontWeight,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          // default
          textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: changeColor(primaryColor, {
            alpha: 0.1
          }),
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.4
          })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
          // warning
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.4
          })}`,
          colorActiveWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          caretColorWarning: warningColor,
          // error
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.4
          })}`,
          colorActiveError: changeColor(errorColor, {
            alpha: 0.1
          }),
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      }
    };
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut$1
    } = commonVariables$n;
    function fadeInWidthExpandTransition({
      duration: duration2 = ".2s",
      delay = ".1s"
    } = {}) {
      return [c("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
        opacity: 1
      }), c("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1},
 max-width ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-left ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 margin-right ${duration2} ${cubicBezierEaseInOut$1} ${delay};
 `), c("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$1} ${delay},
 max-width ${duration2} ${cubicBezierEaseInOut$1},
 margin-left ${duration2} ${cubicBezierEaseInOut$1},
 margin-right ${duration2} ${cubicBezierEaseInOut$1};
 `)];
    }
    const style$8 = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
    const NBaseWave = /* @__PURE__ */ defineComponent({
      name: "BaseWave",
      props: {
        clsPrefix: {
          type: String,
          required: true
        }
      },
      setup(props) {
        useStyle("-base-wave", style$8, toRef(props, "clsPrefix"));
        const selfRef = ref(null);
        const activeRef = ref(false);
        let animationTimerId = null;
        onBeforeUnmount(() => {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
          }
        });
        return {
          active: activeRef,
          selfRef,
          play() {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
              activeRef.value = false;
              animationTimerId = null;
            }
            void nextTick(() => {
              var _a2;
              void ((_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight);
              activeRef.value = true;
              animationTimerId = window.setTimeout(() => {
                activeRef.value = false;
                animationTimerId = null;
              }, 1e3);
            });
          }
        };
      },
      render() {
        const {
          clsPrefix
        } = this;
        return h("div", {
          ref: "selfRef",
          "aria-hidden": true,
          class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
        });
      }
    });
    const commonVars$b = {
      iconMargin: "11px 8px 0 12px",
      iconMarginRtl: "11px 12px 0 8px",
      iconSize: "24px",
      closeIconSize: "16px",
      closeSize: "20px",
      closeMargin: "13px 14px 0 0",
      closeMarginRtl: "13px 0 0 14px",
      padding: "13px"
    };
    const alertDark = {
      name: "Alert",
      common: derived$1,
      self(vars) {
        const {
          lineHeight: lineHeight2,
          borderRadius,
          fontWeightStrong,
          dividerColor,
          inputColor,
          textColor1,
          textColor2,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$b), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          titleFontWeight: fontWeightStrong,
          borderRadius,
          border: `1px solid ${dividerColor}`,
          color: inputColor,
          titleTextColor: textColor1,
          iconColor: textColor2,
          contentTextColor: textColor2,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderInfo: `1px solid ${changeColor(infoColorSuppl, {
            alpha: 0.35
          })}`,
          colorInfo: changeColor(infoColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorInfo: textColor1,
          iconColorInfo: infoColorSuppl,
          contentTextColorInfo: textColor2,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          borderSuccess: `1px solid ${changeColor(successColorSuppl, {
            alpha: 0.35
          })}`,
          colorSuccess: changeColor(successColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorSuccess: textColor1,
          iconColorSuccess: successColorSuppl,
          contentTextColorSuccess: textColor2,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          borderWarning: `1px solid ${changeColor(warningColorSuppl, {
            alpha: 0.35
          })}`,
          colorWarning: changeColor(warningColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorWarning: textColor1,
          iconColorWarning: warningColorSuppl,
          contentTextColorWarning: textColor2,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          borderError: `1px solid ${changeColor(errorColorSuppl, {
            alpha: 0.35
          })}`,
          colorError: changeColor(errorColorSuppl, {
            alpha: 0.25
          }),
          titleTextColorError: textColor1,
          iconColorError: errorColorSuppl,
          contentTextColorError: textColor2,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed
        });
      }
    };
    const commonVars$a = {
      linkFontSize: "13px",
      linkPadding: "0 0 0 16px",
      railWidth: "4px"
    };
    function self$O(vars) {
      const {
        borderRadius,
        railColor,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$a), {
        borderRadius,
        railColor,
        railColorActive: primaryColor,
        linkColor: changeColor(primaryColor, {
          alpha: 0.15
        }),
        linkTextColor: textColor2,
        linkTextColorHover: primaryColorHover,
        linkTextColorPressed: primaryColorPressed,
        linkTextColorActive: primaryColor
      });
    }
    const anchorDark = {
      name: "Anchor",
      common: derived$1,
      self: self$O
    };
    const isChrome = isBrowser$1 && "chrome" in window;
    isBrowser$1 && navigator.userAgent.includes("Firefox");
    const isSafari = isBrowser$1 && navigator.userAgent.includes("Safari") && !isChrome;
    const commonVariables$i = {
      paddingTiny: "0 8px",
      paddingSmall: "0 10px",
      paddingMedium: "0 12px",
      paddingLarge: "0 14px",
      clearSize: "16px"
    };
    const inputDark = {
      name: "Input",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          textColor3,
          textColorDisabled,
          primaryColor,
          primaryColorHover,
          inputColor,
          inputColorDisabled,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderRadius,
          lineHeight: lineHeight2,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$i), {
          fontWeight,
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: inputColor,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          groupLabelTextColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: changeColor(primaryColor, {
            alpha: 0.1
          }),
          groupLabelBorder: "1px solid #0000",
          border: "1px solid #0000",
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: "1px solid #0000",
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          loadingColor: primaryColor,
          // warning
          loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: changeColor(warningColor, {
            alpha: 0.1
          }),
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 8px 0 ${changeColor(warningColor, {
            alpha: 0.3
          })}`,
          caretColorWarning: warningColor,
          // error
          loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: changeColor(errorColor, {
            alpha: 0.1
          }),
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 8px 0 ${changeColor(errorColor, {
            alpha: 0.3
          })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      }
    };
    function self$N(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const autoCompleteDark = {
      name: "AutoComplete",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self: self$N
    };
    function self$M(vars) {
      const {
        borderRadius,
        avatarColor,
        cardColor,
        fontSize: fontSize2,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        modalColor,
        popoverColor
      } = vars;
      return {
        borderRadius,
        fontSize: fontSize2,
        border: `2px solid ${cardColor}`,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        color: composite(cardColor, avatarColor),
        colorModal: composite(modalColor, avatarColor),
        colorPopover: composite(popoverColor, avatarColor)
      };
    }
    const avatarDark = {
      name: "Avatar",
      common: derived$1,
      self: self$M
    };
    function self$L() {
      return {
        gap: "-12px"
      };
    }
    const avatarGroupDark = {
      name: "AvatarGroup",
      common: derived$1,
      peers: {
        Avatar: avatarDark
      },
      self: self$L
    };
    const commonVariables$h = {
      width: "44px",
      height: "44px",
      borderRadius: "22px",
      iconSize: "26px"
    };
    const backTopDark = {
      name: "BackTop",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          primaryColorHover,
          primaryColorPressed
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$h), {
          color: popoverColor,
          textColor: textColor2,
          iconColor: textColor2,
          iconColorHover: primaryColorHover,
          iconColorPressed: primaryColorPressed,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
        });
      }
    };
    const badgeDark = {
      name: "Badge",
      common: derived$1,
      self(vars) {
        const {
          errorColorSuppl,
          infoColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          fontFamily: fontFamily2
        } = vars;
        return {
          color: errorColorSuppl,
          colorInfo: infoColorSuppl,
          colorSuccess: successColorSuppl,
          colorError: errorColorSuppl,
          colorWarning: warningColorSuppl,
          fontSize: "12px",
          fontFamily: fontFamily2
        };
      }
    };
    const commonVariables$g = {
      fontWeightActive: "400"
    };
    function self$K(vars) {
      const {
        fontSize: fontSize2,
        textColor3,
        textColor2,
        borderRadius,
        buttonColor2Hover,
        buttonColor2Pressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$g), {
        fontSize: fontSize2,
        itemLineHeight: "1.25",
        itemTextColor: textColor3,
        itemTextColorHover: textColor2,
        itemTextColorPressed: textColor2,
        itemTextColorActive: textColor2,
        itemBorderRadius: borderRadius,
        itemColorHover: buttonColor2Hover,
        itemColorPressed: buttonColor2Pressed,
        separatorColor: textColor3
      });
    }
    const breadcrumbDark = {
      name: "Breadcrumb",
      common: derived$1,
      self: self$K
    };
    function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
    }
    function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
    }
    const buttonGroupInjectionKey = createInjectionKey("n-button-group");
    const commonVariables$f = {
      paddingTiny: "0 6px",
      paddingSmall: "0 10px",
      paddingMedium: "0 14px",
      paddingLarge: "0 18px",
      paddingRoundTiny: "0 10px",
      paddingRoundSmall: "0 14px",
      paddingRoundMedium: "0 18px",
      paddingRoundLarge: "0 22px",
      iconMarginTiny: "6px",
      iconMarginSmall: "6px",
      iconMarginMedium: "6px",
      iconMarginLarge: "6px",
      iconSizeTiny: "14px",
      iconSizeSmall: "18px",
      iconSizeMedium: "18px",
      iconSizeLarge: "20px",
      rippleDuration: ".6s"
    };
    function self$J(vars) {
      const {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        textColor2,
        textColor3,
        primaryColorHover,
        primaryColorPressed,
        borderColor,
        primaryColor,
        baseColor,
        infoColor,
        infoColorHover,
        infoColorPressed,
        successColor,
        successColorHover,
        successColorPressed,
        warningColor,
        warningColorHover,
        warningColorPressed,
        errorColor,
        errorColorHover,
        errorColorPressed,
        fontWeight,
        buttonColor2,
        buttonColor2Hover,
        buttonColor2Pressed,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$f), {
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        borderRadiusTiny: borderRadius,
        borderRadiusSmall: borderRadius,
        borderRadiusMedium: borderRadius,
        borderRadiusLarge: borderRadius,
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        opacityDisabled,
        // secondary
        colorOpacitySecondary: "0.16",
        colorOpacitySecondaryHover: "0.22",
        colorOpacitySecondaryPressed: "0.28",
        colorSecondary: buttonColor2,
        colorSecondaryHover: buttonColor2Hover,
        colorSecondaryPressed: buttonColor2Pressed,
        // tertiary
        colorTertiary: buttonColor2,
        colorTertiaryHover: buttonColor2Hover,
        colorTertiaryPressed: buttonColor2Pressed,
        // quaternary
        colorQuaternary: "#0000",
        colorQuaternaryHover: buttonColor2Hover,
        colorQuaternaryPressed: buttonColor2Pressed,
        // default type
        color: "#0000",
        colorHover: "#0000",
        colorPressed: "#0000",
        colorFocus: "#0000",
        colorDisabled: "#0000",
        textColor: textColor2,
        textColorTertiary: textColor3,
        textColorHover: primaryColorHover,
        textColorPressed: primaryColorPressed,
        textColorFocus: primaryColorHover,
        textColorDisabled: textColor2,
        textColorText: textColor2,
        textColorTextHover: primaryColorHover,
        textColorTextPressed: primaryColorPressed,
        textColorTextFocus: primaryColorHover,
        textColorTextDisabled: textColor2,
        textColorGhost: textColor2,
        textColorGhostHover: primaryColorHover,
        textColorGhostPressed: primaryColorPressed,
        textColorGhostFocus: primaryColorHover,
        textColorGhostDisabled: textColor2,
        border: `1px solid ${borderColor}`,
        borderHover: `1px solid ${primaryColorHover}`,
        borderPressed: `1px solid ${primaryColorPressed}`,
        borderFocus: `1px solid ${primaryColorHover}`,
        borderDisabled: `1px solid ${borderColor}`,
        rippleColor: primaryColor,
        // primary
        colorPrimary: primaryColor,
        colorHoverPrimary: primaryColorHover,
        colorPressedPrimary: primaryColorPressed,
        colorFocusPrimary: primaryColorHover,
        colorDisabledPrimary: primaryColor,
        textColorPrimary: baseColor,
        textColorHoverPrimary: baseColor,
        textColorPressedPrimary: baseColor,
        textColorFocusPrimary: baseColor,
        textColorDisabledPrimary: baseColor,
        textColorTextPrimary: primaryColor,
        textColorTextHoverPrimary: primaryColorHover,
        textColorTextPressedPrimary: primaryColorPressed,
        textColorTextFocusPrimary: primaryColorHover,
        textColorTextDisabledPrimary: textColor2,
        textColorGhostPrimary: primaryColor,
        textColorGhostHoverPrimary: primaryColorHover,
        textColorGhostPressedPrimary: primaryColorPressed,
        textColorGhostFocusPrimary: primaryColorHover,
        textColorGhostDisabledPrimary: primaryColor,
        borderPrimary: `1px solid ${primaryColor}`,
        borderHoverPrimary: `1px solid ${primaryColorHover}`,
        borderPressedPrimary: `1px solid ${primaryColorPressed}`,
        borderFocusPrimary: `1px solid ${primaryColorHover}`,
        borderDisabledPrimary: `1px solid ${primaryColor}`,
        rippleColorPrimary: primaryColor,
        // info
        colorInfo: infoColor,
        colorHoverInfo: infoColorHover,
        colorPressedInfo: infoColorPressed,
        colorFocusInfo: infoColorHover,
        colorDisabledInfo: infoColor,
        textColorInfo: baseColor,
        textColorHoverInfo: baseColor,
        textColorPressedInfo: baseColor,
        textColorFocusInfo: baseColor,
        textColorDisabledInfo: baseColor,
        textColorTextInfo: infoColor,
        textColorTextHoverInfo: infoColorHover,
        textColorTextPressedInfo: infoColorPressed,
        textColorTextFocusInfo: infoColorHover,
        textColorTextDisabledInfo: textColor2,
        textColorGhostInfo: infoColor,
        textColorGhostHoverInfo: infoColorHover,
        textColorGhostPressedInfo: infoColorPressed,
        textColorGhostFocusInfo: infoColorHover,
        textColorGhostDisabledInfo: infoColor,
        borderInfo: `1px solid ${infoColor}`,
        borderHoverInfo: `1px solid ${infoColorHover}`,
        borderPressedInfo: `1px solid ${infoColorPressed}`,
        borderFocusInfo: `1px solid ${infoColorHover}`,
        borderDisabledInfo: `1px solid ${infoColor}`,
        rippleColorInfo: infoColor,
        // success
        colorSuccess: successColor,
        colorHoverSuccess: successColorHover,
        colorPressedSuccess: successColorPressed,
        colorFocusSuccess: successColorHover,
        colorDisabledSuccess: successColor,
        textColorSuccess: baseColor,
        textColorHoverSuccess: baseColor,
        textColorPressedSuccess: baseColor,
        textColorFocusSuccess: baseColor,
        textColorDisabledSuccess: baseColor,
        textColorTextSuccess: successColor,
        textColorTextHoverSuccess: successColorHover,
        textColorTextPressedSuccess: successColorPressed,
        textColorTextFocusSuccess: successColorHover,
        textColorTextDisabledSuccess: textColor2,
        textColorGhostSuccess: successColor,
        textColorGhostHoverSuccess: successColorHover,
        textColorGhostPressedSuccess: successColorPressed,
        textColorGhostFocusSuccess: successColorHover,
        textColorGhostDisabledSuccess: successColor,
        borderSuccess: `1px solid ${successColor}`,
        borderHoverSuccess: `1px solid ${successColorHover}`,
        borderPressedSuccess: `1px solid ${successColorPressed}`,
        borderFocusSuccess: `1px solid ${successColorHover}`,
        borderDisabledSuccess: `1px solid ${successColor}`,
        rippleColorSuccess: successColor,
        // warning
        colorWarning: warningColor,
        colorHoverWarning: warningColorHover,
        colorPressedWarning: warningColorPressed,
        colorFocusWarning: warningColorHover,
        colorDisabledWarning: warningColor,
        textColorWarning: baseColor,
        textColorHoverWarning: baseColor,
        textColorPressedWarning: baseColor,
        textColorFocusWarning: baseColor,
        textColorDisabledWarning: baseColor,
        textColorTextWarning: warningColor,
        textColorTextHoverWarning: warningColorHover,
        textColorTextPressedWarning: warningColorPressed,
        textColorTextFocusWarning: warningColorHover,
        textColorTextDisabledWarning: textColor2,
        textColorGhostWarning: warningColor,
        textColorGhostHoverWarning: warningColorHover,
        textColorGhostPressedWarning: warningColorPressed,
        textColorGhostFocusWarning: warningColorHover,
        textColorGhostDisabledWarning: warningColor,
        borderWarning: `1px solid ${warningColor}`,
        borderHoverWarning: `1px solid ${warningColorHover}`,
        borderPressedWarning: `1px solid ${warningColorPressed}`,
        borderFocusWarning: `1px solid ${warningColorHover}`,
        borderDisabledWarning: `1px solid ${warningColor}`,
        rippleColorWarning: warningColor,
        // error
        colorError: errorColor,
        colorHoverError: errorColorHover,
        colorPressedError: errorColorPressed,
        colorFocusError: errorColorHover,
        colorDisabledError: errorColor,
        textColorError: baseColor,
        textColorHoverError: baseColor,
        textColorPressedError: baseColor,
        textColorFocusError: baseColor,
        textColorDisabledError: baseColor,
        textColorTextError: errorColor,
        textColorTextHoverError: errorColorHover,
        textColorTextPressedError: errorColorPressed,
        textColorTextFocusError: errorColorHover,
        textColorTextDisabledError: textColor2,
        textColorGhostError: errorColor,
        textColorGhostHoverError: errorColorHover,
        textColorGhostPressedError: errorColorPressed,
        textColorGhostFocusError: errorColorHover,
        textColorGhostDisabledError: errorColor,
        borderError: `1px solid ${errorColor}`,
        borderHoverError: `1px solid ${errorColorHover}`,
        borderPressedError: `1px solid ${errorColorPressed}`,
        borderFocusError: `1px solid ${errorColorHover}`,
        borderDisabledError: `1px solid ${errorColor}`,
        rippleColorError: errorColor,
        waveOpacity: "0.6",
        fontWeight,
        fontWeightStrong
      });
    }
    const buttonLight = {
      common: derived,
      self: self$J
    };
    const buttonDark = {
      name: "Button",
      common: derived$1,
      self(vars) {
        const commonSelf = self$J(vars);
        commonSelf.waveOpacity = "0.8";
        commonSelf.colorOpacitySecondary = "0.16";
        commonSelf.colorOpacitySecondaryHover = "0.2";
        commonSelf.colorOpacitySecondaryPressed = "0.12";
        return commonSelf;
      }
    };
    const style$7 = c([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE$1("border", {
      borderColor: "var(--n-border-color)"
    }), cM("disabled", [cE$1("border", {
      borderColor: "var(--n-border-color-disabled)"
    })]), cNotM("disabled", [c("&:focus", [cE$1("state-border", {
      borderColor: "var(--n-border-color-focus)"
    })]), c("&:hover", [cE$1("state-border", {
      borderColor: "var(--n-border-color-hover)"
    })]), c("&:active", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })]), cM("pressed", [cE$1("state-border", {
      borderColor: "var(--n-border-color-pressed)"
    })])])]), cM("disabled", {
      backgroundColor: "var(--n-color-disabled)",
      color: "var(--n-text-color-disabled)"
    }, [cE$1("border", {
      border: "var(--n-border-disabled)"
    })]), cNotM("disabled", [c("&:focus", {
      backgroundColor: "var(--n-color-focus)",
      color: "var(--n-text-color-focus)"
    }, [cE$1("state-border", {
      border: "var(--n-border-focus)"
    })]), c("&:hover", {
      backgroundColor: "var(--n-color-hover)",
      color: "var(--n-text-color-hover)"
    }, [cE$1("state-border", {
      border: "var(--n-border-hover)"
    })]), c("&:active", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })]), cM("pressed", {
      backgroundColor: "var(--n-color-pressed)",
      color: "var(--n-text-color-pressed)"
    }, [cE$1("state-border", {
      border: "var(--n-border-pressed)"
    })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
      zIndex: 1,
      animationName: "button-wave-spread, button-wave-opacity"
    })]), isBrowser$1 && "MozBoxSizing" in document.createElement("div").style ? c("&::moz-focus-inner", {
      border: 0
    }) : null, cE$1("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE$1("border", {
      border: "var(--n-border)"
    }), cE$1("state-border", {
      border: "var(--n-border)",
      borderColor: "#0000",
      zIndex: 1
    }), cE$1("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
      top: "50%",
      originalTransform: "translateY(-50%)"
    })]), fadeInWidthExpandTransition()]), cE$1("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c("~", [cE$1("icon", {
      margin: "var(--n-icon-margin)",
      marginRight: 0
    })])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE$1("border, state-border", {
      borderStyle: "dashed !important"
    })]), cM("disabled", {
      cursor: "not-allowed",
      opacity: "var(--n-opacity-disabled)"
    })]), c("@keyframes button-wave-spread", {
      from: {
        boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
      },
      to: {
        // don't use exact 5px since chrome will display the animation with glitches
        boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
      }
    }), c("@keyframes button-wave-opacity", {
      from: {
        opacity: "var(--n-wave-opacity)"
      },
      to: {
        opacity: 0
      }
    })]);
    const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
      color: String,
      textColor: String,
      text: Boolean,
      block: Boolean,
      loading: Boolean,
      disabled: Boolean,
      circle: Boolean,
      size: String,
      ghost: Boolean,
      round: Boolean,
      secondary: Boolean,
      tertiary: Boolean,
      quaternary: Boolean,
      strong: Boolean,
      focusable: {
        type: Boolean,
        default: true
      },
      keyboard: {
        type: Boolean,
        default: true
      },
      tag: {
        type: String,
        default: "button"
      },
      type: {
        type: String,
        default: "default"
      },
      dashed: Boolean,
      renderIcon: Function,
      iconPlacement: {
        type: String,
        default: "left"
      },
      attrType: {
        type: String,
        default: "button"
      },
      bordered: {
        type: Boolean,
        default: true
      },
      onClick: [Function, Array],
      nativeFocusBehavior: {
        type: Boolean,
        default: !isSafari
      }
    });
    const Button = /* @__PURE__ */ defineComponent({
      name: "Button",
      props: buttonProps,
      slots: Object,
      setup(props) {
        const selfElRef = ref(null);
        const waveElRef = ref(null);
        const enterPressedRef = ref(false);
        const showBorderRef = useMemo(() => {
          return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
        });
        const NButtonGroup = inject(buttonGroupInjectionKey, {});
        const {
          mergedSizeRef
        } = useFormItem({}, {
          defaultSize: "medium",
          mergedSize: (NFormItem2) => {
            const {
              size: size2
            } = props;
            if (size2) return size2;
            const {
              size: buttonGroupSize
            } = NButtonGroup;
            if (buttonGroupSize) return buttonGroupSize;
            const {
              mergedSize: formItemSize2
            } = NFormItem2 || {};
            if (formItemSize2) {
              return formItemSize2.value;
            }
            return "medium";
          }
        });
        const mergedFocusableRef = computed(() => {
          return props.focusable && !props.disabled;
        });
        const handleMousedown = (e) => {
          var _a2;
          if (!mergedFocusableRef.value) {
            e.preventDefault();
          }
          if (props.nativeFocusBehavior) {
            return;
          }
          e.preventDefault();
          if (props.disabled) {
            return;
          }
          if (mergedFocusableRef.value) {
            (_a2 = selfElRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus({
              preventScroll: true
            });
          }
        };
        const handleClick = (e) => {
          var _a2;
          if (!props.disabled && !props.loading) {
            const {
              onClick
            } = props;
            if (onClick) call(onClick, e);
            if (!props.text) {
              (_a2 = waveElRef.value) === null || _a2 === void 0 ? void 0 : _a2.play();
            }
          }
        };
        const handleKeyup = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard) {
                return;
              }
              enterPressedRef.value = false;
          }
        };
        const handleKeydown = (e) => {
          switch (e.key) {
            case "Enter":
              if (!props.keyboard || props.loading) {
                e.preventDefault();
                return;
              }
              enterPressedRef.value = true;
          }
        };
        const handleBlur = () => {
          enterPressedRef.value = false;
        };
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Button", "-button", style$7, buttonLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const theme = themeRef.value;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: self2
          } = theme;
          const {
            rippleDuration,
            opacityDisabled,
            fontWeight,
            fontWeightStrong
          } = self2;
          const size2 = mergedSizeRef.value;
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          const fontProps = {
            "--n-font-weight": strong ? fontWeightStrong : fontWeight
          };
          let colorProps = {
            "--n-color": "initial",
            "--n-color-hover": "initial",
            "--n-color-pressed": "initial",
            "--n-color-focus": "initial",
            "--n-color-disabled": "initial",
            "--n-ripple-color": "initial",
            "--n-text-color": "initial",
            "--n-text-color-hover": "initial",
            "--n-text-color-pressed": "initial",
            "--n-text-color-focus": "initial",
            "--n-text-color-disabled": "initial"
          };
          const typeIsTertiary = type === "tertiary";
          const typeIsDefault = type === "default";
          const mergedType = typeIsTertiary ? "default" : type;
          if (text) {
            const propTextColor = textColor || color;
            const mergedTextColor = propTextColor || self2[createKey$1("textColorText", mergedType)];
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey$1("textColorTextHover", mergedType)],
              "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey$1("textColorTextPressed", mergedType)],
              "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey$1("textColorTextHover", mergedType)],
              "--n-text-color-disabled": propTextColor || self2[createKey$1("textColorTextDisabled", mergedType)]
            };
          } else if (ghost || dashed) {
            const mergedTextColor = textColor || color;
            colorProps = {
              "--n-color": "#0000",
              "--n-color-hover": "#0000",
              "--n-color-pressed": "#0000",
              "--n-color-focus": "#0000",
              "--n-color-disabled": "#0000",
              "--n-ripple-color": color || self2[createKey$1("rippleColor", mergedType)],
              "--n-text-color": mergedTextColor || self2[createKey$1("textColorGhost", mergedType)],
              "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey$1("textColorGhostHover", mergedType)],
              "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey$1("textColorGhostPressed", mergedType)],
              "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey$1("textColorGhostHover", mergedType)],
              "--n-text-color-disabled": mergedTextColor || self2[createKey$1("textColorGhostDisabled", mergedType)]
            };
          } else if (secondary) {
            const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey$1("color", mergedType)];
            const mergedTextColor = color || typeTextColor;
            const isColoredType = type !== "default" && type !== "tertiary";
            colorProps = {
              "--n-color": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondary)
              }) : self2.colorSecondary,
              "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryPressed)
              }) : self2.colorSecondaryPressed,
              "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                alpha: Number(self2.colorOpacitySecondaryHover)
              }) : self2.colorSecondaryHover,
              "--n-color-disabled": self2.colorSecondary,
              "--n-ripple-color": "#0000",
              "--n-text-color": mergedTextColor,
              "--n-text-color-hover": mergedTextColor,
              "--n-text-color-pressed": mergedTextColor,
              "--n-text-color-focus": mergedTextColor,
              "--n-text-color-disabled": mergedTextColor
            };
          } else if (tertiary || quaternary) {
            const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey$1("color", mergedType)];
            const mergedColor = color || typeColor;
            if (tertiary) {
              colorProps["--n-color"] = self2.colorTertiary;
              colorProps["--n-color-hover"] = self2.colorTertiaryHover;
              colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
              colorProps["--n-color-focus"] = self2.colorSecondaryHover;
              colorProps["--n-color-disabled"] = self2.colorTertiary;
            } else {
              colorProps["--n-color"] = self2.colorQuaternary;
              colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
              colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
              colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
              colorProps["--n-color-disabled"] = self2.colorQuaternary;
            }
            colorProps["--n-ripple-color"] = "#0000";
            colorProps["--n-text-color"] = mergedColor;
            colorProps["--n-text-color-hover"] = mergedColor;
            colorProps["--n-text-color-pressed"] = mergedColor;
            colorProps["--n-text-color-focus"] = mergedColor;
            colorProps["--n-text-color-disabled"] = mergedColor;
          } else {
            colorProps = {
              "--n-color": color || self2[createKey$1("color", mergedType)],
              "--n-color-hover": color ? createHoverColor(color) : self2[createKey$1("colorHover", mergedType)],
              "--n-color-pressed": color ? createPressedColor(color) : self2[createKey$1("colorPressed", mergedType)],
              "--n-color-focus": color ? createHoverColor(color) : self2[createKey$1("colorFocus", mergedType)],
              "--n-color-disabled": color || self2[createKey$1("colorDisabled", mergedType)],
              "--n-ripple-color": color || self2[createKey$1("rippleColor", mergedType)],
              "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey$1("textColor", mergedType)]),
              "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey$1("textColorHover", mergedType)]),
              "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey$1("textColorPressed", mergedType)]),
              "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey$1("textColorFocus", mergedType)]),
              "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey$1("textColorDisabled", mergedType)])
            };
          }
          let borderProps = {
            "--n-border": "initial",
            "--n-border-hover": "initial",
            "--n-border-pressed": "initial",
            "--n-border-focus": "initial",
            "--n-border-disabled": "initial"
          };
          if (text) {
            borderProps = {
              "--n-border": "none",
              "--n-border-hover": "none",
              "--n-border-pressed": "none",
              "--n-border-focus": "none",
              "--n-border-disabled": "none"
            };
          } else {
            borderProps = {
              "--n-border": self2[createKey$1("border", mergedType)],
              "--n-border-hover": self2[createKey$1("borderHover", mergedType)],
              "--n-border-pressed": self2[createKey$1("borderPressed", mergedType)],
              "--n-border-focus": self2[createKey$1("borderFocus", mergedType)],
              "--n-border-disabled": self2[createKey$1("borderDisabled", mergedType)]
            };
          }
          const {
            [createKey$1("height", size2)]: height,
            [createKey$1("fontSize", size2)]: fontSize2,
            [createKey$1("padding", size2)]: padding,
            [createKey$1("paddingRound", size2)]: paddingRound,
            [createKey$1("iconSize", size2)]: iconSize,
            [createKey$1("borderRadius", size2)]: borderRadius,
            [createKey$1("iconMargin", size2)]: iconMargin,
            waveOpacity
          } = self2;
          const sizeProps = {
            "--n-width": circle && !text ? height : "initial",
            "--n-height": text ? "initial" : height,
            "--n-font-size": fontSize2,
            "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
            "--n-icon-size": iconSize,
            "--n-icon-margin": iconMargin,
            "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-ease-out": cubicBezierEaseOut2,
            "--n-ripple-duration": rippleDuration,
            "--n-opacity-disabled": opacityDisabled,
            "--n-wave-opacity": waveOpacity
          }, fontProps), colorProps), borderProps), sizeProps);
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", computed(() => {
          let hash = "";
          const {
            dashed,
            type,
            ghost,
            text,
            color,
            round,
            circle,
            textColor,
            secondary,
            tertiary,
            quaternary,
            strong
          } = props;
          if (dashed) hash += "a";
          if (ghost) hash += "b";
          if (text) hash += "c";
          if (round) hash += "d";
          if (circle) hash += "e";
          if (secondary) hash += "f";
          if (tertiary) hash += "g";
          if (quaternary) hash += "h";
          if (strong) hash += "i";
          if (color) hash += `j${color2Class(color)}`;
          if (textColor) hash += `k${color2Class(textColor)}`;
          const {
            value: size2
          } = mergedSizeRef;
          hash += `l${size2[0]}`;
          hash += `m${type[0]}`;
          return hash;
        }), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          waveElRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedFocusable: mergedFocusableRef,
          mergedSize: mergedSizeRef,
          showBorder: showBorderRef,
          enterPressed: enterPressedRef,
          rtlEnabled: rtlEnabledRef,
          handleMousedown,
          handleKeydown,
          handleBlur,
          handleKeyup,
          handleClick,
          customColorCssVars: computed(() => {
            const {
              color
            } = props;
            if (!color) return null;
            const hoverColor = createHoverColor(color);
            return {
              "--n-border-color": color,
              "--n-border-color-hover": hoverColor,
              "--n-border-color-pressed": createPressedColor(color),
              "--n-border-color-focus": hoverColor,
              "--n-border-color-disabled": color
            };
          }),
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          tag: Component,
          onRender
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && h("span", {
          class: `${mergedClsPrefix}-button__content`
        }, children2));
        return h(Component, {
          ref: "selfElRef",
          class: [
            this.themeClass,
            `${mergedClsPrefix}-button`,
            `${mergedClsPrefix}-button--${this.type}-type`,
            `${mergedClsPrefix}-button--${this.mergedSize}-type`,
            this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
            this.disabled && `${mergedClsPrefix}-button--disabled`,
            this.block && `${mergedClsPrefix}-button--block`,
            this.enterPressed && `${mergedClsPrefix}-button--pressed`,
            !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
            this.color && `${mergedClsPrefix}-button--color`,
            this.secondary && `${mergedClsPrefix}-button--secondary`,
            this.loading && `${mergedClsPrefix}-button--loading`,
            this.ghost && `${mergedClsPrefix}-button--ghost`
            // required for button group border collapse
          ],
          tabindex: this.mergedFocusable ? 0 : -1,
          type: this.attrType,
          style: this.cssVars,
          disabled: this.disabled,
          onClick: this.handleClick,
          onBlur: this.handleBlur,
          onMousedown: this.handleMousedown,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, this.iconPlacement === "right" && children, h(NFadeInExpandTransition, {
          width: true
        }, {
          default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && h("span", {
            class: `${mergedClsPrefix}-button__icon`,
            style: {
              margin: isSlotEmpty(this.$slots.default) ? "0" : ""
            }
          }, h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              clsPrefix: mergedClsPrefix,
              key: "loading",
              class: `${mergedClsPrefix}-icon-slot`,
              strokeWidth: 20
            }) : h("div", {
              key: "icon",
              class: `${mergedClsPrefix}-icon-slot`,
              role: "none"
            }, this.renderIcon ? this.renderIcon() : children2)
          })))
        }), this.iconPlacement === "left" && children, !this.text ? h(NBaseWave, {
          ref: "waveElRef",
          clsPrefix: mergedClsPrefix
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__border`,
          style: this.customColorCssVars
        }) : null, this.showBorder ? h("div", {
          "aria-hidden": true,
          class: `${mergedClsPrefix}-button__state-border`,
          style: this.customColorCssVars
        }) : null);
      }
    });
    const commonVariables$e = {
      titleFontSize: "22px"
    };
    function self$I(vars) {
      const {
        borderRadius,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        textColor2,
        textColor1,
        textColorDisabled,
        dividerColor,
        fontWeightStrong,
        primaryColor,
        baseColor,
        hoverColor,
        cardColor,
        modalColor,
        popoverColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$e), {
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        textColor: textColor2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        dayTextColor: textColorDisabled,
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        dateColorCurrent: primaryColor,
        dateTextColorCurrent: baseColor,
        cellColorHover: composite(cardColor, hoverColor),
        cellColorHoverModal: composite(modalColor, hoverColor),
        cellColorHoverPopover: composite(popoverColor, hoverColor),
        cellColor: cardColor,
        cellColorModal: modalColor,
        cellColorPopover: popoverColor,
        barColor: primaryColor
      });
    }
    const calendarDark = {
      name: "Calendar",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$I
    };
    const commonVariables$d = {
      paddingSmall: "12px 16px 12px",
      paddingMedium: "19px 24px 20px",
      paddingLarge: "23px 32px 24px",
      paddingHuge: "27px 40px 28px",
      titleFontSizeSmall: "16px",
      titleFontSizeMedium: "18px",
      titleFontSizeLarge: "18px",
      titleFontSizeHuge: "18px",
      closeIconSize: "18px",
      closeSize: "22px"
    };
    function self$H(vars) {
      const {
        primaryColor,
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        cardColor,
        textColor2,
        textColor1,
        dividerColor,
        fontWeightStrong,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        modalColor,
        boxShadow1,
        popoverColor,
        actionColor
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$d), {
        lineHeight: lineHeight2,
        color: cardColor,
        colorModal: modalColor,
        colorPopover: popoverColor,
        colorTarget: primaryColor,
        colorEmbedded: actionColor,
        colorEmbeddedModal: actionColor,
        colorEmbeddedPopover: actionColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        borderColor: dividerColor,
        actionColor,
        titleFontWeight: fontWeightStrong,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        fontSizeSmall: fontSize2,
        fontSizeMedium: fontSize2,
        fontSizeLarge: fontSize2,
        fontSizeHuge: fontSize2,
        boxShadow: boxShadow1,
        borderRadius
      });
    }
    const cardDark = {
      name: "Card",
      common: derived$1,
      self(vars) {
        const commonSelf = self$H(vars);
        const {
          cardColor,
          modalColor,
          popoverColor
        } = vars;
        commonSelf.colorEmbedded = cardColor;
        commonSelf.colorEmbeddedModal = modalColor;
        commonSelf.colorEmbeddedPopover = popoverColor;
        return commonSelf;
      }
    };
    function self$G() {
      return {
        dotSize: "8px",
        dotColor: "rgba(255, 255, 255, .3)",
        dotColorActive: "rgba(255, 255, 255, 1)",
        dotColorFocus: "rgba(255, 255, 255, .5)",
        dotLineWidth: "16px",
        dotLineWidthActive: "24px",
        arrowColor: "#eee"
      };
    }
    const carouselDark = {
      name: "Carousel",
      common: derived$1,
      self: self$G
    };
    const commonVariables$c = {
      sizeSmall: "14px",
      sizeMedium: "16px",
      sizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    function self$F(vars) {
      const {
        baseColor,
        inputColorDisabled,
        cardColor,
        modalColor,
        popoverColor,
        textColorDisabled,
        borderColor,
        primaryColor,
        textColor2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadiusSmall,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), {
        labelLineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderRadius: borderRadiusSmall,
        color: baseColor,
        colorChecked: primaryColor,
        colorDisabled: inputColorDisabled,
        colorDisabledChecked: inputColorDisabled,
        colorTableHeader: cardColor,
        colorTableHeaderModal: modalColor,
        colorTableHeaderPopover: popoverColor,
        checkMarkColor: baseColor,
        checkMarkColorDisabled: textColorDisabled,
        checkMarkColorDisabledChecked: textColorDisabled,
        border: `1px solid ${borderColor}`,
        borderDisabled: `1px solid ${borderColor}`,
        borderDisabledChecked: `1px solid ${borderColor}`,
        borderChecked: `1px solid ${primaryColor}`,
        borderFocus: `1px solid ${primaryColor}`,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        textColor: textColor2,
        textColorDisabled
      });
    }
    const checkboxDark = {
      name: "Checkbox",
      common: derived$1,
      self(vars) {
        const {
          cardColor
        } = vars;
        const commonSelf = self$F(vars);
        commonSelf.color = "#0000";
        commonSelf.checkMarkColor = cardColor;
        return commonSelf;
      }
    };
    function self$E(vars) {
      const {
        borderRadius,
        boxShadow2,
        popoverColor,
        textColor2,
        textColor3,
        primaryColor,
        textColorDisabled,
        dividerColor,
        hoverColor,
        fontSizeMedium,
        heightMedium
      } = vars;
      return {
        menuBorderRadius: borderRadius,
        menuColor: popoverColor,
        menuBoxShadow: boxShadow2,
        menuDividerColor: dividerColor,
        menuHeight: "calc(var(--n-option-height) * 6.6)",
        optionArrowColor: textColor3,
        optionHeight: heightMedium,
        optionFontSize: fontSizeMedium,
        optionColorHover: hoverColor,
        optionTextColor: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorDisabled: textColorDisabled,
        optionCheckMarkColor: primaryColor,
        loadingColor: primaryColor,
        columnWidth: "180px"
      };
    }
    const cascaderDark = {
      name: "Cascader",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        InternalSelection: internalSelectionDark,
        Scrollbar: scrollbarDark,
        Checkbox: checkboxDark,
        Empty: emptyLight
      },
      self: self$E
    };
    const codeDark = {
      name: "Code",
      common: derived$1,
      self(vars) {
        const {
          textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          textColor3
        } = vars;
        return {
          textColor: textColor2,
          fontSize: fontSize2,
          fontWeightStrong,
          // extracted from hljs atom-one-dark.scss
          "mono-3": "#5c6370",
          "hue-1": "#56b6c2",
          "hue-2": "#61aeee",
          "hue-3": "#c678dd",
          "hue-4": "#98c379",
          "hue-5": "#e06c75",
          "hue-5-2": "#be5046",
          "hue-6": "#d19a66",
          "hue-6-2": "#e6c07b",
          // line-number styles
          lineNumberTextColor: textColor3
        };
      }
    };
    function self$D(vars) {
      const {
        fontWeight,
        textColor1,
        textColor2,
        textColorDisabled,
        dividerColor,
        fontSize: fontSize2
      } = vars;
      return {
        titleFontSize: fontSize2,
        titleFontWeight: fontWeight,
        dividerColor,
        titleTextColor: textColor1,
        titleTextColorDisabled: textColorDisabled,
        fontSize: fontSize2,
        textColor: textColor2,
        arrowColor: textColor2,
        arrowColorDisabled: textColorDisabled,
        itemMargin: "16px 0 0 0",
        titlePadding: "16px 0 0 0"
      };
    }
    const collapseDark = {
      name: "Collapse",
      common: derived$1,
      self: self$D
    };
    function self$C(vars) {
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut2
      } = vars;
      return {
        bezier: cubicBezierEaseInOut2
      };
    }
    const collapseTransitionDark = {
      name: "CollapseTransition",
      common: derived$1,
      self: self$C
    };
    function self$B(vars) {
      const {
        fontSize: fontSize2,
        boxShadow2,
        popoverColor,
        textColor2,
        borderRadius,
        borderColor,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      } = vars;
      return {
        panelFontSize: fontSize2,
        boxShadow: boxShadow2,
        color: popoverColor,
        textColor: textColor2,
        borderRadius,
        border: `1px solid ${borderColor}`,
        heightSmall,
        heightMedium,
        heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor
      };
    }
    const colorPickerDark = {
      name: "ColorPicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self: self$B
    };
    const configProviderProps = {
      abstract: Boolean,
      bordered: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: String,
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
        type: String,
        default: "div"
      },
      hljs: Object,
      katex: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      styleMountTarget: Object,
      inlineThemeDisabled: {
        type: Boolean,
        default: void 0
      },
      // deprecated
      as: {
        type: String,
        validator: () => {
          warn("config-provider", "`as` is deprecated, please use `tag` instead.");
          return true;
        },
        default: void 0
      }
    };
    const NConfigProvider = /* @__PURE__ */ defineComponent({
      name: "ConfigProvider",
      alias: ["App"],
      props: configProviderProps,
      setup(props) {
        const NConfigProvider2 = inject(configProviderInjectionKey, null);
        const mergedThemeRef = computed(() => {
          const {
            theme
          } = props;
          if (theme === null) return void 0;
          const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
          return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
        });
        const mergedThemeOverridesRef = computed(() => {
          const {
            themeOverrides
          } = props;
          if (themeOverrides === null) return void 0;
          if (themeOverrides === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
          } else {
            const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            if (inheritedThemeOverrides === void 0) {
              return themeOverrides;
            } else {
              return merge({}, inheritedThemeOverrides, themeOverrides);
            }
          }
        });
        const mergedNamespaceRef = useMemo(() => {
          const {
            namespace: namespace2
          } = props;
          return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
        });
        const mergedBorderedRef = useMemo(() => {
          const {
            bordered
          } = props;
          return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
        });
        const mergedIconsRef = computed(() => {
          const {
            icons
          } = props;
          return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
        });
        const mergedComponentPropsRef = computed(() => {
          const {
            componentOptions
          } = props;
          if (componentOptions !== void 0) return componentOptions;
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
        });
        const mergedClsPrefixRef = computed(() => {
          const {
            clsPrefix
          } = props;
          if (clsPrefix !== void 0) return clsPrefix;
          if (NConfigProvider2) return NConfigProvider2.mergedClsPrefixRef.value;
          return defaultClsPrefix;
        });
        const mergedRtlRef = computed(() => {
          var _a2;
          const {
            rtl
          } = props;
          if (rtl === void 0) {
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
          }
          const rtlEnabledState = {};
          for (const rtlInfo of rtl) {
            rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
            (_a2 = rtlInfo.peers) === null || _a2 === void 0 ? void 0 : _a2.forEach((peerRtlInfo) => {
              if (!(peerRtlInfo.name in rtlEnabledState)) {
                rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
              }
            });
          }
          return rtlEnabledState;
        });
        const mergedBreakpointsRef = computed(() => {
          return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
        });
        const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
        const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
        const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
        const mergedThemeHashRef = computed(() => {
          const {
            value: theme
          } = mergedThemeRef;
          const {
            value: mergedThemeOverrides
          } = mergedThemeOverridesRef;
          const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
          const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
          if (themeName) {
            if (hasThemeOverrides) {
              return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
            }
            return themeName;
          } else {
            if (hasThemeOverrides) {
              return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
            }
            return "";
          }
        });
        provide(configProviderInjectionKey, {
          mergedThemeHashRef,
          mergedBreakpointsRef,
          mergedRtlRef,
          mergedIconsRef,
          mergedComponentPropsRef,
          mergedBorderedRef,
          mergedNamespaceRef,
          mergedClsPrefixRef,
          mergedLocaleRef: computed(() => {
            const {
              locale
            } = props;
            if (locale === null) return void 0;
            return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
          }),
          mergedDateLocaleRef: computed(() => {
            const {
              dateLocale
            } = props;
            if (dateLocale === null) return void 0;
            return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
          }),
          mergedHljsRef: computed(() => {
            const {
              hljs
            } = props;
            return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
          }),
          mergedKatexRef: computed(() => {
            const {
              katex
            } = props;
            return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
          }),
          mergedThemeRef,
          mergedThemeOverridesRef,
          inlineThemeDisabled: inlineThemeDisabled || false,
          preflightStyleDisabled: preflightStyleDisabled || false,
          styleMountTarget
        });
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          mergedBordered: mergedBorderedRef,
          mergedNamespace: mergedNamespaceRef,
          mergedTheme: mergedThemeRef,
          mergedThemeOverrides: mergedThemeOverridesRef
        };
      },
      render() {
        var _a2, _b2, _c2, _d2;
        return !this.abstract ? h(this.as || this.tag, {
          class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
        }, (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)) : (_d2 = (_c2 = this.$slots).default) === null || _d2 === void 0 ? void 0 : _d2.call(_c2);
      }
    });
    const popselect = {
      name: "Popselect",
      common: derived$1,
      peers: {
        Popover: popoverDark,
        InternalSelectMenu: internalSelectMenuDark
      }
    };
    function self$A(vars) {
      const {
        boxShadow2
      } = vars;
      return {
        menuBoxShadow: boxShadow2
      };
    }
    const selectDark = {
      name: "Select",
      common: derived$1,
      peers: {
        InternalSelection: internalSelectionDark,
        InternalSelectMenu: internalSelectMenuDark
      },
      self: self$A
    };
    const commonVariables$b = {
      itemPaddingSmall: "0 4px",
      itemMarginSmall: "0 0 0 8px",
      itemMarginSmallRtl: "0 8px 0 0",
      itemPaddingMedium: "0 4px",
      itemMarginMedium: "0 0 0 8px",
      itemMarginMediumRtl: "0 8px 0 0",
      itemPaddingLarge: "0 4px",
      itemMarginLarge: "0 0 0 8px",
      itemMarginLargeRtl: "0 8px 0 0",
      buttonIconSizeSmall: "14px",
      buttonIconSizeMedium: "16px",
      buttonIconSizeLarge: "18px",
      inputWidthSmall: "60px",
      selectWidthSmall: "unset",
      inputMarginSmall: "0 0 0 8px",
      inputMarginSmallRtl: "0 8px 0 0",
      selectMarginSmall: "0 0 0 8px",
      prefixMarginSmall: "0 8px 0 0",
      suffixMarginSmall: "0 0 0 8px",
      inputWidthMedium: "60px",
      selectWidthMedium: "unset",
      inputMarginMedium: "0 0 0 8px",
      inputMarginMediumRtl: "0 8px 0 0",
      selectMarginMedium: "0 0 0 8px",
      prefixMarginMedium: "0 8px 0 0",
      suffixMarginMedium: "0 0 0 8px",
      inputWidthLarge: "60px",
      selectWidthLarge: "unset",
      inputMarginLarge: "0 0 0 8px",
      inputMarginLargeRtl: "0 8px 0 0",
      selectMarginLarge: "0 0 0 8px",
      prefixMarginLarge: "0 8px 0 0",
      suffixMarginLarge: "0 0 0 8px"
    };
    function self$z(vars) {
      const {
        textColor2,
        primaryColor,
        primaryColorHover,
        primaryColorPressed,
        inputColorDisabled,
        textColorDisabled,
        borderColor,
        borderRadius,
        // item font size
        fontSizeTiny,
        fontSizeSmall,
        fontSizeMedium,
        // item size
        heightTiny,
        heightSmall,
        heightMedium
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), {
        buttonColor: "#0000",
        buttonColorHover: "#0000",
        buttonColorPressed: "#0000",
        buttonBorder: `1px solid ${borderColor}`,
        buttonBorderHover: `1px solid ${borderColor}`,
        buttonBorderPressed: `1px solid ${borderColor}`,
        buttonIconColor: textColor2,
        buttonIconColorHover: textColor2,
        buttonIconColorPressed: textColor2,
        itemTextColor: textColor2,
        itemTextColorHover: primaryColorHover,
        itemTextColorPressed: primaryColorPressed,
        itemTextColorActive: primaryColor,
        itemTextColorDisabled: textColorDisabled,
        itemColor: "#0000",
        itemColorHover: "#0000",
        itemColorPressed: "#0000",
        itemColorActive: "#0000",
        itemColorActiveHover: "#0000",
        itemColorDisabled: inputColorDisabled,
        itemBorder: "1px solid #0000",
        itemBorderHover: "1px solid #0000",
        itemBorderPressed: "1px solid #0000",
        itemBorderActive: `1px solid ${primaryColor}`,
        itemBorderDisabled: `1px solid ${borderColor}`,
        itemBorderRadius: borderRadius,
        itemSizeSmall: heightTiny,
        itemSizeMedium: heightSmall,
        itemSizeLarge: heightMedium,
        itemFontSizeSmall: fontSizeTiny,
        itemFontSizeMedium: fontSizeSmall,
        itemFontSizeLarge: fontSizeMedium,
        jumperFontSizeSmall: fontSizeTiny,
        jumperFontSizeMedium: fontSizeSmall,
        jumperFontSizeLarge: fontSizeMedium,
        jumperTextColor: textColor2,
        jumperTextColorDisabled: textColorDisabled
      });
    }
    const paginationDark = {
      name: "Pagination",
      common: derived$1,
      peers: {
        Select: selectDark,
        Input: inputDark,
        Popselect: popselect
      },
      self(vars) {
        const {
          primaryColor,
          opacity3
        } = vars;
        const borderColorActive = changeColor(primaryColor, {
          alpha: Number(opacity3)
        });
        const commonSelf = self$z(vars);
        commonSelf.itemBorderActive = `1px solid ${borderColorActive}`;
        commonSelf.itemBorderDisabled = "1px solid #0000";
        return commonSelf;
      }
    };
    const commonVariables$a = {
      padding: "4px 0",
      optionIconSizeSmall: "14px",
      optionIconSizeMedium: "16px",
      optionIconSizeLarge: "16px",
      optionIconSizeHuge: "18px",
      optionSuffixWidthSmall: "14px",
      optionSuffixWidthMedium: "14px",
      optionSuffixWidthLarge: "16px",
      optionSuffixWidthHuge: "16px",
      optionIconSuffixWidthSmall: "32px",
      optionIconSuffixWidthMedium: "32px",
      optionIconSuffixWidthLarge: "36px",
      optionIconSuffixWidthHuge: "36px",
      optionPrefixWidthSmall: "14px",
      optionPrefixWidthMedium: "14px",
      optionPrefixWidthLarge: "16px",
      optionPrefixWidthHuge: "16px",
      optionIconPrefixWidthSmall: "36px",
      optionIconPrefixWidthMedium: "36px",
      optionIconPrefixWidthLarge: "40px",
      optionIconPrefixWidthHuge: "40px"
    };
    function self$y(vars) {
      const {
        primaryColor,
        textColor2,
        dividerColor,
        hoverColor,
        popoverColor,
        invertedColor,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        textColor3,
        opacityDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), {
        optionHeightSmall: heightSmall,
        optionHeightMedium: heightMedium,
        optionHeightLarge: heightLarge,
        optionHeightHuge: heightHuge,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        fontSizeHuge,
        // non-inverted
        optionTextColor: textColor2,
        optionTextColorHover: textColor2,
        optionTextColorActive: primaryColor,
        optionTextColorChildActive: primaryColor,
        color: popoverColor,
        dividerColor,
        suffixColor: textColor2,
        prefixColor: textColor2,
        optionColorHover: hoverColor,
        optionColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        groupHeaderTextColor: textColor3,
        // inverted
        optionTextColorInverted: "#BBB",
        optionTextColorHoverInverted: "#FFF",
        optionTextColorActiveInverted: "#FFF",
        optionTextColorChildActiveInverted: "#FFF",
        colorInverted: invertedColor,
        dividerColorInverted: "#BBB",
        suffixColorInverted: "#BBB",
        prefixColorInverted: "#BBB",
        optionColorHoverInverted: primaryColor,
        optionColorActiveInverted: primaryColor,
        groupHeaderTextColorInverted: "#AAA",
        optionOpacityDisabled: opacityDisabled
      });
    }
    const dropdownDark = {
      name: "Dropdown",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          primaryColorSuppl,
          primaryColor,
          popoverColor
        } = vars;
        const commonSelf = self$y(vars);
        commonSelf.colorInverted = popoverColor;
        commonSelf.optionColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.optionColorActiveInverted = primaryColorSuppl;
        commonSelf.optionColorHoverInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const commonVars$9 = {
      padding: "8px 14px"
    };
    const tooltipDark = {
      name: "Tooltip",
      common: derived$1,
      peers: {
        Popover: popoverDark
      },
      self(vars) {
        const {
          borderRadius,
          boxShadow2,
          popoverColor,
          textColor2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$9), {
          borderRadius,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2
        });
      }
    };
    const ellipsisDark = {
      name: "Ellipsis",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      }
    };
    const commonVariables$9 = {
      radioSizeSmall: "14px",
      radioSizeMedium: "16px",
      radioSizeLarge: "18px",
      labelPadding: "0 8px",
      labelFontWeight: "400"
    };
    const radioDark = {
      name: "Radio",
      common: derived$1,
      self(vars) {
        const {
          borderColor,
          primaryColor,
          baseColor,
          textColorDisabled,
          inputColorDisabled,
          textColor2,
          opacityDisabled,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightSmall,
          heightMedium,
          heightLarge,
          lineHeight: lineHeight2
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$9), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: "#0000",
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: primaryColor,
          buttonColor: "#0000",
          buttonColorActive: primaryColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: baseColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.3
          })}`,
          buttonBoxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      }
    };
    function self$x(vars) {
      const {
        borderColor,
        primaryColor,
        baseColor,
        textColorDisabled,
        inputColorDisabled,
        textColor2,
        opacityDisabled,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        heightSmall,
        heightMedium,
        heightLarge,
        lineHeight: lineHeight2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), {
        labelLineHeight: lineHeight2,
        buttonHeightSmall: heightSmall,
        buttonHeightMedium: heightMedium,
        buttonHeightLarge: heightLarge,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        boxShadow: `inset 0 0 0 1px ${borderColor}`,
        boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
        boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
        boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
        color: baseColor,
        colorDisabled: inputColorDisabled,
        colorActive: "#0000",
        textColor: textColor2,
        textColorDisabled,
        dotColorActive: primaryColor,
        dotColorDisabled: borderColor,
        buttonBorderColor: borderColor,
        buttonBorderColorActive: primaryColor,
        buttonBorderColorHover: borderColor,
        buttonColor: baseColor,
        buttonColorActive: baseColor,
        buttonTextColor: textColor2,
        buttonTextColorActive: primaryColor,
        buttonTextColorHover: primaryColor,
        opacityDisabled,
        buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
        buttonBoxShadowHover: "inset 0 0 0 1px #0000",
        buttonBoxShadow: "inset 0 0 0 1px #0000",
        buttonBorderRadius: borderRadius
      });
    }
    const radioLight = {
      common: derived,
      self: self$x
    };
    const commonVariables$8 = {
      thPaddingSmall: "8px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "8px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px",
      sorterSize: "15px",
      resizableContainerSize: "8px",
      resizableSize: "2px",
      filterSize: "15px",
      paginationMargin: "12px 0 0 0",
      emptyPadding: "48px 0",
      actionPadding: "8px 12px",
      actionButtonMargin: "0 8px 0 0"
    };
    function self$w(vars) {
      const {
        cardColor,
        modalColor,
        popoverColor,
        textColor2,
        textColor1,
        tableHeaderColor,
        tableColorHover,
        iconColor,
        primaryColor,
        fontWeightStrong,
        borderRadius,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        dividerColor,
        heightSmall,
        opacityDisabled,
        tableColorStriped
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), {
        actionDividerColor: dividerColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        borderColor: composite(cardColor, dividerColor),
        tdColorHover: composite(cardColor, tableColorHover),
        tdColorSorting: composite(cardColor, tableColorHover),
        tdColorStriped: composite(cardColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        thColorSorting: composite(composite(cardColor, tableHeaderColor), tableColorHover),
        tdColor: cardColor,
        tdTextColor: textColor2,
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        thButtonColorHover: tableColorHover,
        thIconColor: iconColor,
        thIconColorActive: primaryColor,
        // modal
        borderColorModal: composite(modalColor, dividerColor),
        tdColorHoverModal: composite(modalColor, tableColorHover),
        tdColorSortingModal: composite(modalColor, tableColorHover),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        thColorSortingModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
        tdColorModal: modalColor,
        // popover
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColorHoverPopover: composite(popoverColor, tableColorHover),
        tdColorSortingPopover: composite(popoverColor, tableColorHover),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        thColorSortingPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
        tdColorPopover: popoverColor,
        boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
        boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
        // loading
        loadingColor: primaryColor,
        loadingSize: heightSmall,
        opacityLoading: opacityDisabled
      });
    }
    const dataTableDark = {
      name: "DataTable",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Checkbox: checkboxDark,
        Radio: radioDark,
        Pagination: paginationDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark,
        Popover: popoverDark,
        Ellipsis: ellipsisDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const commonSelf = self$w(vars);
        commonSelf.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)";
        commonSelf.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)";
        return commonSelf;
      }
    };
    const style$6 = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM("checked", [cE$1("dot", `
 background-color: var(--n-color-active);
 `)]), cE$1("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE$1("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM("checked", {
      boxShadow: "var(--n-box-shadow-active)"
    }, [c("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE$1("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-hover)"
    })]), cM("focus", [c("&:not(:active)", [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-focus)"
    })])])]), cM("disabled", `
 cursor: not-allowed;
 `, [cE$1("dot", {
      boxShadow: "var(--n-box-shadow-disabled)",
      backgroundColor: "var(--n-color-disabled)"
    }, [c("&::before", {
      backgroundColor: "var(--n-dot-color-disabled)"
    }), cM("checked", `
 opacity: 1;
 `)]), cE$1("label", {
      color: "var(--n-text-color-disabled)"
    }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
    const radioBaseProps = {
      name: String,
      value: {
        type: [String, Number, Boolean],
        default: "on"
      },
      checked: {
        type: Boolean,
        default: void 0
      },
      defaultChecked: Boolean,
      disabled: {
        type: Boolean,
        default: void 0
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      "onUpdate:checked": [Function, Array],
      // deprecated
      checkedValue: {
        type: Boolean,
        default: void 0
      }
    };
    const radioGroupInjectionKey = createInjectionKey("n-radio-group");
    function setup(props) {
      const NRadioGroup2 = inject(radioGroupInjectionKey, null);
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const {
            size: size2
          } = props;
          if (size2 !== void 0) return size2;
          if (NRadioGroup2) {
            const {
              mergedSizeRef: {
                value: mergedSize
              }
            } = NRadioGroup2;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            return NFormItem2.mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          if (props.disabled) return true;
          if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value) return true;
          if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value) return true;
          return false;
        }
      });
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
        if (NRadioGroup2) return NRadioGroup2.valueRef.value === props.value;
        return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
        const {
          name
        } = props;
        if (name !== void 0) return name;
        if (NRadioGroup2) return NRadioGroup2.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
        if (NRadioGroup2) {
          const {
            doUpdateValue
          } = NRadioGroup2;
          const {
            value
          } = props;
          call(doUpdateValue, value);
        } else {
          const {
            onUpdateChecked,
            "onUpdate:checked": _onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (onUpdateChecked) call(onUpdateChecked, true);
          if (_onUpdateChecked) call(_onUpdateChecked, true);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = true;
        }
      }
      function toggle() {
        if (mergedDisabledRef.value) return;
        if (!renderSafeCheckedRef.value) {
          doUpdateChecked();
        }
      }
      function handleRadioInputChange() {
        toggle();
        if (inputRef.value) {
          inputRef.value.checked = renderSafeCheckedRef.value;
        }
      }
      function handleRadioInputBlur() {
        focusRef.value = false;
      }
      function handleRadioInputFocus() {
        focusRef.value = true;
      }
      return {
        mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
        inputRef,
        labelRef,
        mergedName: mergedNameRef,
        mergedDisabled: mergedDisabledRef,
        renderSafeChecked: renderSafeCheckedRef,
        focus: focusRef,
        mergedSize: mergedSizeRef,
        handleRadioInputChange,
        handleRadioInputBlur,
        handleRadioInputFocus
      };
    }
    const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
    const NRadio = /* @__PURE__ */ defineComponent({
      name: "Radio",
      props: radioProps,
      setup(props) {
        const radio = setup(props);
        const themeRef = useTheme("Radio", "-radio", style$6, radioLight, props, radio.mergedClsPrefix);
        const cssVarsRef = computed(() => {
          const {
            mergedSize: {
              value: size2
            }
          } = radio;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              boxShadow,
              boxShadowActive,
              boxShadowDisabled,
              boxShadowFocus,
              boxShadowHover,
              color,
              colorDisabled,
              colorActive,
              textColor,
              textColorDisabled,
              dotColorActive,
              dotColorDisabled,
              labelPadding,
              labelLineHeight,
              labelFontWeight,
              [createKey$1("fontSize", size2)]: fontSize2,
              [createKey$1("radioSize", size2)]: radioSize
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-label-line-height": labelLineHeight,
            "--n-label-font-weight": labelFontWeight,
            "--n-box-shadow": boxShadow,
            "--n-box-shadow-active": boxShadowActive,
            "--n-box-shadow-disabled": boxShadowDisabled,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-box-shadow-hover": boxShadowHover,
            "--n-color": color,
            "--n-color-active": colorActive,
            "--n-color-disabled": colorDisabled,
            "--n-dot-color-active": dotColorActive,
            "--n-dot-color-disabled": dotColorDisabled,
            "--n-font-size": fontSize2,
            "--n-radio-size": radioSize,
            "--n-text-color": textColor,
            "--n-text-color-disabled": textColorDisabled,
            "--n-label-padding": labelPadding
          };
        });
        const {
          inlineThemeDisabled,
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
        return Object.assign(radio, {
          rtlEnabled: rtlEnabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          onRender,
          label
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        return h("label", {
          class: [`${mergedClsPrefix}-radio`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-radio--rtl`, this.mergedDisabled && `${mergedClsPrefix}-radio--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio--checked`, this.focus && `${mergedClsPrefix}-radio--focus`],
          style: this.cssVars
        }, h("input", {
          ref: "inputRef",
          type: "radio",
          class: `${mergedClsPrefix}-radio-input`,
          value: this.value,
          name: this.mergedName,
          checked: this.renderSafeChecked,
          disabled: this.mergedDisabled,
          onChange: this.handleRadioInputChange,
          onFocus: this.handleRadioInputFocus,
          onBlur: this.handleRadioInputBlur
        }), h("div", {
          class: `${mergedClsPrefix}-radio__dot-wrapper`
        }, "", h("div", {
          class: [`${mergedClsPrefix}-radio__dot`, this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`]
        })), resolveWrappedSlot($slots.default, (children) => {
          if (!children && !label) return null;
          return h("div", {
            ref: "labelRef",
            class: `${mergedClsPrefix}-radio__label`
          }, children || label);
        }));
      }
    });
    const style$5 = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE$1("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM("checked", {
      backgroundColor: "var(--n-button-border-color-active)"
    }), cM("disabled", {
      opacity: "var(--n-opacity-disabled)"
    })]), cM("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
      height: "var(--n-height)",
      lineHeight: "var(--n-height)"
    }), cE$1("splitor", {
      height: "var(--n-height)"
    })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE$1("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE$1("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c("&:hover", [cE$1("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
      color: "var(--n-button-text-color-hover)"
    })]), cM("focus", [c("&:not(:active)", [cE$1("state-border", {
      boxShadow: "var(--n-button-box-shadow-focus)"
    })])])]), cM("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
    function mapSlot(defaultSlot, value, clsPrefix) {
      var _a2;
      const children = [];
      let isButtonGroup = false;
      for (let i2 = 0; i2 < defaultSlot.length; ++i2) {
        const wrappedInstance = defaultSlot[i2];
        const name = (_a2 = wrappedInstance.type) === null || _a2 === void 0 ? void 0 : _a2.name;
        if (name === "RadioButton") {
          isButtonGroup = true;
        }
        const instanceProps = wrappedInstance.props;
        if (name !== "RadioButton") {
          children.push(wrappedInstance);
          continue;
        }
        if (i2 === 0) {
          children.push(wrappedInstance);
        } else {
          const lastInstanceProps = children[children.length - 1].props;
          const lastInstanceChecked = value === lastInstanceProps.value;
          const lastInstanceDisabled = lastInstanceProps.disabled;
          const currentInstanceChecked = value === instanceProps.value;
          const currentInstanceDisabled = instanceProps.disabled;
          const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
          const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
          const lastInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
          };
          const currentInstanceClass = {
            [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
            [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
          };
          const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
          children.push(h("div", {
            class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
          }), wrappedInstance);
        }
      }
      return {
        children,
        isButtonGroup
      };
    }
    const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), {
      name: String,
      value: [String, Number, Boolean],
      defaultValue: {
        type: [String, Number, Boolean],
        default: null
      },
      size: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array]
    });
    const NRadioGroup = /* @__PURE__ */ defineComponent({
      name: "RadioGroup",
      props: radioGroupProps,
      setup(props) {
        const selfElRef = ref(null);
        const {
          mergedSizeRef,
          mergedDisabledRef,
          nTriggerFormChange,
          nTriggerFormInput,
          nTriggerFormBlur,
          nTriggerFormFocus
        } = useFormItem(props);
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Radio", "-radio-group", style$5, radioLight, props, mergedClsPrefixRef);
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        function doUpdateValue(value) {
          const {
            onUpdateValue,
            "onUpdate:value": _onUpdateValue
          } = props;
          if (onUpdateValue) {
            call(onUpdateValue, value);
          }
          if (_onUpdateValue) {
            call(_onUpdateValue, value);
          }
          uncontrolledValueRef.value = value;
          nTriggerFormChange();
          nTriggerFormInput();
        }
        function handleFocusin(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormFocus();
        }
        function handleFocusout(e) {
          const {
            value: selfEl
          } = selfElRef;
          if (!selfEl) return;
          if (selfEl.contains(e.relatedTarget)) return;
          nTriggerFormBlur();
        }
        provide(radioGroupInjectionKey, {
          mergedClsPrefixRef,
          nameRef: toRef(props, "name"),
          valueRef: mergedValueRef,
          disabledRef: mergedDisabledRef,
          mergedSizeRef,
          doUpdateValue
        });
        const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              buttonBorderColor,
              buttonBorderColorActive,
              buttonBorderRadius,
              buttonBoxShadow,
              buttonBoxShadowFocus,
              buttonBoxShadowHover,
              buttonColor,
              buttonColorActive,
              buttonTextColor,
              buttonTextColorActive,
              buttonTextColorHover,
              opacityDisabled,
              [createKey$1("buttonHeight", size2)]: height,
              [createKey$1("fontSize", size2)]: fontSize2
            }
          } = themeRef.value;
          return {
            "--n-font-size": fontSize2,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-color": buttonBorderColor,
            "--n-button-border-color-active": buttonBorderColorActive,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-box-shadow-focus": buttonBoxShadowFocus,
            "--n-button-box-shadow-hover": buttonBoxShadowHover,
            "--n-button-color": buttonColor,
            "--n-button-color-active": buttonColorActive,
            "--n-button-text-color": buttonTextColor,
            "--n-button-text-color-hover": buttonTextColorHover,
            "--n-button-text-color-active": buttonTextColorActive,
            "--n-height": height,
            "--n-opacity-disabled": opacityDisabled
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
        return {
          selfElRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          handleFocusout,
          handleFocusin,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        var _a2;
        const {
          mergedValue,
          mergedClsPrefix,
          handleFocusin,
          handleFocusout
        } = this;
        const {
          children,
          isButtonGroup
        } = mapSlot(flatten(getSlot(this)), mergedValue, mergedClsPrefix);
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        return h("div", {
          onFocusin: handleFocusin,
          onFocusout: handleFocusout,
          ref: "selfElRef",
          class: [`${mergedClsPrefix}-radio-group`, this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`, this.themeClass, isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`],
          style: this.cssVars
        }, children);
      }
    });
    function self$v(vars) {
      const {
        textColorBase,
        opacity1,
        opacity2,
        opacity3,
        opacity4,
        opacity5
      } = vars;
      return {
        color: textColorBase,
        opacity1Depth: opacity1,
        opacity2Depth: opacity2,
        opacity3Depth: opacity3,
        opacity4Depth: opacity4,
        opacity5Depth: opacity5
      };
    }
    const iconDark$1 = {
      name: "Icon",
      common: derived$1,
      self: self$v
    };
    const commonVars$8 = {
      itemFontSize: "12px",
      itemHeight: "36px",
      itemWidth: "52px",
      panelActionPadding: "8px 0"
    };
    function self$u(vars) {
      const {
        popoverColor,
        textColor2,
        primaryColor,
        hoverColor,
        dividerColor,
        opacityDisabled,
        boxShadow2,
        borderRadius,
        iconColor,
        iconColorDisabled
      } = vars;
      return Object.assign(Object.assign({}, commonVars$8), {
        panelColor: popoverColor,
        panelBoxShadow: boxShadow2,
        panelDividerColor: dividerColor,
        itemTextColor: textColor2,
        itemTextColorActive: primaryColor,
        itemColorHover: hoverColor,
        itemOpacityDisabled: opacityDisabled,
        itemBorderRadius: borderRadius,
        borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const timePickerDark = {
      name: "TimePicker",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Button: buttonDark,
        Input: inputDark
      },
      self: self$u
    };
    const commonVars$7 = {
      itemSize: "24px",
      itemCellWidth: "38px",
      itemCellHeight: "32px",
      scrollItemWidth: "80px",
      scrollItemHeight: "40px",
      panelExtraFooterPadding: "8px 12px",
      panelActionPadding: "8px 12px",
      calendarTitlePadding: "0",
      calendarTitleHeight: "28px",
      arrowSize: "14px",
      panelHeaderPadding: "8px 12px",
      calendarDaysHeight: "32px",
      calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
      // type
      calendarLeftPaddingDate: "6px 12px 4px 12px",
      calendarLeftPaddingDatetime: "4px 12px",
      calendarLeftPaddingDaterange: "6px 12px 4px 12px",
      calendarLeftPaddingDatetimerange: "4px 12px",
      calendarLeftPaddingMonth: "0",
      // TODO: make it actually effective
      calendarLeftPaddingYear: "0",
      calendarLeftPaddingQuarter: "0",
      calendarLeftPaddingMonthrange: "0",
      calendarLeftPaddingQuarterrange: "0",
      calendarLeftPaddingYearrange: "0",
      calendarLeftPaddingWeek: "6px 12px 4px 12px",
      calendarRightPaddingDate: "6px 12px 4px 12px",
      calendarRightPaddingDatetime: "4px 12px",
      calendarRightPaddingDaterange: "6px 12px 4px 12px",
      calendarRightPaddingDatetimerange: "4px 12px",
      calendarRightPaddingMonth: "0",
      calendarRightPaddingYear: "0",
      calendarRightPaddingQuarter: "0",
      calendarRightPaddingMonthrange: "0",
      calendarRightPaddingQuarterrange: "0",
      calendarRightPaddingYearrange: "0",
      calendarRightPaddingWeek: "0"
    };
    function self$t(vars) {
      const {
        hoverColor,
        fontSize: fontSize2,
        textColor2,
        textColorDisabled,
        popoverColor,
        primaryColor,
        borderRadiusSmall,
        iconColor,
        iconColorDisabled,
        textColor1,
        dividerColor,
        boxShadow2,
        borderRadius,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVars$7), {
        itemFontSize: fontSize2,
        calendarDaysFontSize: fontSize2,
        calendarTitleFontSize: fontSize2,
        itemTextColor: textColor2,
        itemTextColorDisabled: textColorDisabled,
        itemTextColorActive: popoverColor,
        itemTextColorCurrent: primaryColor,
        itemColorIncluded: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorHover: hoverColor,
        itemColorDisabled: hoverColor,
        itemColorActive: primaryColor,
        itemBorderRadius: borderRadiusSmall,
        panelColor: popoverColor,
        panelTextColor: textColor2,
        arrowColor: iconColor,
        calendarTitleTextColor: textColor1,
        calendarTitleColorHover: hoverColor,
        calendarDaysTextColor: textColor2,
        panelHeaderDividerColor: dividerColor,
        calendarDaysDividerColor: dividerColor,
        calendarDividerColor: dividerColor,
        panelActionDividerColor: dividerColor,
        panelBoxShadow: boxShadow2,
        panelBorderRadius: borderRadius,
        calendarTitleFontWeight: fontWeightStrong,
        scrollItemBorderRadius: borderRadius,
        iconColor,
        iconColorDisabled
      });
    }
    const datePickerDark = {
      name: "DatePicker",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        TimePicker: timePickerDark,
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          popoverColor,
          hoverColor,
          primaryColor
        } = vars;
        const commonSelf = self$t(vars);
        commonSelf.itemColorDisabled = composite(popoverColor, hoverColor);
        commonSelf.itemColorIncluded = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorHover = composite(popoverColor, hoverColor);
        return commonSelf;
      }
    };
    const commonVariables$7 = {
      thPaddingBorderedSmall: "8px 12px",
      thPaddingBorderedMedium: "12px 16px",
      thPaddingBorderedLarge: "16px 24px",
      thPaddingSmall: "0",
      thPaddingMedium: "0",
      thPaddingLarge: "0",
      tdPaddingBorderedSmall: "8px 12px",
      tdPaddingBorderedMedium: "12px 16px",
      tdPaddingBorderedLarge: "16px 24px",
      tdPaddingSmall: "0 0 8px 0",
      tdPaddingMedium: "0 0 12px 0",
      tdPaddingLarge: "0 0 16px 0"
    };
    function self$s(vars) {
      const {
        tableHeaderColor,
        textColor2,
        textColor1,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), {
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        titleTextColor: textColor1,
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        thFontWeight: fontWeightStrong,
        tdTextColor: textColor2,
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius
      });
    }
    const descriptionsDark = {
      name: "Descriptions",
      common: derived$1,
      self: self$s
    };
    const commonVars$6 = {
      titleFontSize: "18px",
      padding: "16px 28px 20px 28px",
      iconSize: "28px",
      actionSpace: "12px",
      contentMargin: "8px 0 16px 0",
      iconMargin: "0 4px 0 0",
      iconMarginIconTop: "4px 0 8px 0",
      closeSize: "22px",
      closeIconSize: "18px",
      closeMargin: "20px 26px 0 0",
      closeMarginIconTop: "10px 16px 0 0"
    };
    function self$r(vars) {
      const {
        textColor1,
        textColor2,
        modalColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        infoColor,
        successColor,
        warningColor,
        errorColor,
        primaryColor,
        dividerColor,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$6), {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        border: `1px solid ${dividerColor}`,
        titleTextColor: textColor1,
        textColor: textColor2,
        color: modalColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        iconColor: primaryColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        borderRadius,
        titleFontWeight: fontWeightStrong
      });
    }
    const dialogDark = {
      name: "Dialog",
      common: derived$1,
      peers: {
        Button: buttonDark
      },
      self: self$r
    };
    function self$q(vars) {
      const {
        modalColor,
        textColor2,
        boxShadow3
      } = vars;
      return {
        color: modalColor,
        textColor: textColor2,
        boxShadow: boxShadow3
      };
    }
    const modalDark = {
      name: "Modal",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Dialog: dialogDark,
        Card: cardDark
      },
      self: self$q
    };
    const loadingBarDark = {
      name: "LoadingBar",
      common: derived$1,
      self(vars) {
        const {
          primaryColor
        } = vars;
        return {
          colorError: "red",
          colorLoading: primaryColor,
          height: "2px"
        };
      }
    };
    const commonVariables$6 = {
      margin: "0 0 8px 0",
      padding: "10px 20px",
      maxWidth: "720px",
      minWidth: "420px",
      iconMargin: "0 10px 0 0",
      closeMargin: "0 0 0 10px",
      closeSize: "20px",
      closeIconSize: "16px",
      iconSize: "20px",
      fontSize: "14px"
    };
    function self$p(vars) {
      const {
        textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        infoColor,
        successColor,
        errorColor,
        warningColor,
        popoverColor,
        boxShadow2,
        primaryColor,
        lineHeight: lineHeight2,
        borderRadius,
        closeColorHover,
        closeColorPressed
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$6), {
        closeBorderRadius: borderRadius,
        textColor: textColor2,
        textColorInfo: textColor2,
        textColorSuccess: textColor2,
        textColorError: textColor2,
        textColorWarning: textColor2,
        textColorLoading: textColor2,
        color: popoverColor,
        colorInfo: popoverColor,
        colorSuccess: popoverColor,
        colorError: popoverColor,
        colorWarning: popoverColor,
        colorLoading: popoverColor,
        boxShadow: boxShadow2,
        boxShadowInfo: boxShadow2,
        boxShadowSuccess: boxShadow2,
        boxShadowError: boxShadow2,
        boxShadowWarning: boxShadow2,
        boxShadowLoading: boxShadow2,
        iconColor: textColor2,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        iconColorLoading: primaryColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHoverInfo: closeColorHover,
        closeColorPressedInfo: closeColorPressed,
        closeIconColorInfo: closeIconColor,
        closeIconColorHoverInfo: closeIconColorHover,
        closeIconColorPressedInfo: closeIconColorPressed,
        closeColorHoverSuccess: closeColorHover,
        closeColorPressedSuccess: closeColorPressed,
        closeIconColorSuccess: closeIconColor,
        closeIconColorHoverSuccess: closeIconColorHover,
        closeIconColorPressedSuccess: closeIconColorPressed,
        closeColorHoverError: closeColorHover,
        closeColorPressedError: closeColorPressed,
        closeIconColorError: closeIconColor,
        closeIconColorHoverError: closeIconColorHover,
        closeIconColorPressedError: closeIconColorPressed,
        closeColorHoverWarning: closeColorHover,
        closeColorPressedWarning: closeColorPressed,
        closeIconColorWarning: closeIconColor,
        closeIconColorHoverWarning: closeIconColorHover,
        closeIconColorPressedWarning: closeIconColorPressed,
        closeColorHoverLoading: closeColorHover,
        closeColorPressedLoading: closeColorPressed,
        closeIconColorLoading: closeIconColor,
        closeIconColorHoverLoading: closeIconColorHover,
        closeIconColorPressedLoading: closeIconColorPressed,
        loadingColor: primaryColor,
        lineHeight: lineHeight2,
        borderRadius
      });
    }
    const messageDark = {
      name: "Message",
      common: derived$1,
      self: self$p
    };
    const commonVars$5 = {
      closeMargin: "16px 12px",
      closeSize: "20px",
      closeIconSize: "16px",
      width: "365px",
      padding: "16px",
      titleFontSize: "16px",
      metaFontSize: "12px",
      descriptionFontSize: "12px"
    };
    function self$o(vars) {
      const {
        textColor2,
        successColor,
        infoColor,
        warningColor,
        errorColor,
        popoverColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        textColor1,
        textColor3,
        borderRadius,
        fontWeightStrong,
        boxShadow2,
        lineHeight: lineHeight2,
        fontSize: fontSize2
      } = vars;
      return Object.assign(Object.assign({}, commonVars$5), {
        borderRadius,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        headerFontWeight: fontWeightStrong,
        iconColor: textColor2,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        color: popoverColor,
        textColor: textColor2,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeBorderRadius: borderRadius,
        closeColorHover,
        closeColorPressed,
        headerTextColor: textColor1,
        descriptionTextColor: textColor3,
        actionTextColor: textColor2,
        boxShadow: boxShadow2
      });
    }
    const notificationDark = {
      name: "Notification",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$o
    };
    function self$n(vars) {
      const {
        textColor1,
        dividerColor,
        fontWeightStrong
      } = vars;
      return {
        textColor: textColor1,
        color: dividerColor,
        fontWeight: fontWeightStrong
      };
    }
    const dividerDark = {
      name: "Divider",
      common: derived$1,
      self: self$n
    };
    function self$m(vars) {
      const {
        modalColor,
        textColor1,
        textColor2,
        boxShadow3,
        lineHeight: lineHeight2,
        fontWeightStrong,
        dividerColor,
        closeColorHover,
        closeColorPressed,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        borderRadius,
        primaryColorHover
      } = vars;
      return {
        bodyPadding: "16px 24px",
        borderRadius,
        headerPadding: "16px 24px",
        footerPadding: "16px 24px",
        color: modalColor,
        textColor: textColor2,
        titleTextColor: textColor1,
        titleFontSize: "18px",
        titleFontWeight: fontWeightStrong,
        boxShadow: boxShadow3,
        lineHeight: lineHeight2,
        headerBorderBottom: `1px solid ${dividerColor}`,
        footerBorderTop: `1px solid ${dividerColor}`,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeSize: "22px",
        closeIconSize: "18px",
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        resizableTriggerColorHover: primaryColorHover
      };
    }
    const drawerLight = createTheme({
      name: "Drawer",
      common: derived,
      peers: {
        Scrollbar: scrollbarLight
      },
      self: self$m
    });
    const drawerDark = {
      name: "Drawer",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self: self$m
    };
    const NDrawerBodyWrapper = /* @__PURE__ */ defineComponent({
      name: "NDrawerContent",
      inheritAttrs: false,
      props: {
        blockScroll: Boolean,
        show: {
          type: Boolean,
          default: void 0
        },
        displayDirective: {
          type: String,
          required: true
        },
        placement: {
          type: String,
          required: true
        },
        contentClass: String,
        contentStyle: [Object, String],
        nativeScrollbar: {
          type: Boolean,
          required: true
        },
        scrollbarProps: Object,
        trapFocus: {
          type: Boolean,
          default: true
        },
        autoFocus: {
          type: Boolean,
          default: true
        },
        showMask: {
          type: [Boolean, String],
          required: true
        },
        maxWidth: Number,
        maxHeight: Number,
        minWidth: Number,
        minHeight: Number,
        resizable: Boolean,
        onClickoutside: Function,
        onAfterLeave: Function,
        onAfterEnter: Function,
        onEsc: Function
      },
      setup(props) {
        const displayedRef = ref(!!props.show);
        const bodyRef = ref(null);
        const NDrawer2 = inject(drawerInjectionKey);
        let startPosition = 0;
        let memoizedBodyStyleCursor = "";
        let hoverTimerId = null;
        const isHoverOnResizeTriggerRef = ref(false);
        const isDraggingRef = ref(false);
        const isVertical = computed(() => {
          return props.placement === "top" || props.placement === "bottom";
        });
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
        const handleBodyMouseleave = handleBodyMouseup;
        const handleMousedownResizeTrigger = (e) => {
          isDraggingRef.value = true;
          startPosition = isVertical.value ? e.clientY : e.clientX;
          memoizedBodyStyleCursor = document.body.style.cursor;
          document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
          document.body.addEventListener("mousemove", handleBodyMousemove);
          document.body.addEventListener("mouseleave", handleBodyMouseleave);
          document.body.addEventListener("mouseup", handleBodyMouseup);
        };
        const handleMouseenterResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          if (isDraggingRef.value) {
            isHoverOnResizeTriggerRef.value = true;
          } else {
            hoverTimerId = window.setTimeout(() => {
              isHoverOnResizeTriggerRef.value = true;
            }, 300);
          }
        };
        const handleMouseleaveResizeTrigger = () => {
          if (hoverTimerId !== null) {
            window.clearTimeout(hoverTimerId);
            hoverTimerId = null;
          }
          isHoverOnResizeTriggerRef.value = false;
        };
        const {
          doUpdateHeight,
          doUpdateWidth
        } = NDrawer2;
        const regulateWidth = (size2) => {
          const {
            maxWidth
          } = props;
          if (maxWidth && size2 > maxWidth) return maxWidth;
          const {
            minWidth
          } = props;
          if (minWidth && size2 < minWidth) return minWidth;
          return size2;
        };
        const regulateHeight = (size2) => {
          const {
            maxHeight
          } = props;
          if (maxHeight && size2 > maxHeight) return maxHeight;
          const {
            minHeight
          } = props;
          if (minHeight && size2 < minHeight) return minHeight;
          return size2;
        };
        function handleBodyMousemove(e) {
          var _a2, _b2;
          if (isDraggingRef.value) {
            if (isVertical.value) {
              let height = ((_a2 = bodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
              const increment = startPosition - e.clientY;
              height += props.placement === "bottom" ? increment : -increment;
              height = regulateHeight(height);
              doUpdateHeight(height);
              startPosition = e.clientY;
            } else {
              let width = ((_b2 = bodyRef.value) === null || _b2 === void 0 ? void 0 : _b2.offsetWidth) || 0;
              const increment = startPosition - e.clientX;
              width += props.placement === "right" ? increment : -increment;
              width = regulateWidth(width);
              doUpdateWidth(width);
              startPosition = e.clientX;
            }
          }
        }
        function handleBodyMouseup() {
          if (isDraggingRef.value) {
            startPosition = 0;
            isDraggingRef.value = false;
            document.body.style.cursor = memoizedBodyStyleCursor;
            document.body.removeEventListener("mousemove", handleBodyMousemove);
            document.body.removeEventListener("mouseup", handleBodyMouseup);
            document.body.removeEventListener("mouseleave", handleBodyMouseleave);
          }
        }
        watchEffect(() => {
          if (props.show) displayedRef.value = true;
        });
        watch(() => props.show, (value) => {
          if (!value) {
            handleBodyMouseup();
          }
        });
        onBeforeUnmount(() => {
          handleBodyMouseup();
        });
        const bodyDirectivesRef = computed(() => {
          const {
            show
          } = props;
          const directives = [[vShow, show]];
          if (!props.showMask) {
            directives.push([clickoutside, props.onClickoutside, void 0, {
              capture: true
            }]);
          }
          return directives;
        });
        function handleAfterLeave() {
          var _a2;
          displayedRef.value = false;
          (_a2 = props.onAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(props);
        }
        useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
        provide(drawerBodyInjectionKey, bodyRef);
        provide(popoverBodyInjectionKey, null);
        provide(modalBodyInjectionKey, null);
        return {
          bodyRef,
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef,
          isMounted: NDrawer2.isMountedRef,
          mergedTheme: NDrawer2.mergedThemeRef,
          displayed: displayedRef,
          transitionName: computed(() => {
            return {
              right: "slide-in-from-right-transition",
              left: "slide-in-from-left-transition",
              top: "slide-in-from-top-transition",
              bottom: "slide-in-from-bottom-transition"
            }[props.placement];
          }),
          handleAfterLeave,
          bodyDirectives: bodyDirectivesRef,
          handleMousedownResizeTrigger,
          handleMouseenterResizeTrigger,
          handleMouseleaveResizeTrigger,
          isDragging: isDraggingRef,
          isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
        };
      },
      render() {
        const {
          $slots,
          mergedClsPrefix
        } = this;
        return this.displayDirective === "show" || this.displayed || this.show ? withDirectives(
          /* Keep the wrapper dom. Make sure the drawer has a host.
          Nor the detached content will disappear without transition */
          h("div", {
            role: "none"
          }, h(FocusTrap, {
            disabled: !this.showMask || !this.trapFocus,
            active: this.show,
            autoFocus: this.autoFocus,
            onEsc: this.onEsc
          }, {
            default: () => h(Transition, {
              name: this.transitionName,
              appear: this.isMounted,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.handleAfterLeave
            }, {
              default: () => withDirectives(h("div", mergeProps(this.$attrs, {
                role: "dialog",
                ref: "bodyRef",
                "aria-modal": "true",
                class: [
                  `${mergedClsPrefix}-drawer`,
                  this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                  `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                  /**
                   * When the mouse is pressed to resize the drawer,
                   * disable text selection
                   */
                  this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                  this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
                ]
              }), [this.resizable ? h("div", {
                class: [`${mergedClsPrefix}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`],
                onMouseenter: this.handleMouseenterResizeTrigger,
                onMouseleave: this.handleMouseleaveResizeTrigger,
                onMousedown: this.handleMousedownResizeTrigger
              }) : null, this.nativeScrollbar ? h("div", {
                class: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                style: this.contentStyle,
                role: "none"
              }, $slots) : h(Scrollbar, Object.assign({}, this.scrollbarProps, {
                contentStyle: this.contentStyle,
                contentClass: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
                theme: this.mergedTheme.peers.Scrollbar,
                themeOverrides: this.mergedTheme.peerOverrides.Scrollbar
              }), $slots)]), this.bodyDirectives)
            })
          })),
          [[vShow, this.displayDirective === "if" || this.displayed || this.show]]
        ) : null;
      }
    });
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$3,
      cubicBezierEaseOut: cubicBezierEaseOut$3
    } = commonVariables$n;
    function slideInFromBottomTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-bottom"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$3}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$2,
      cubicBezierEaseOut: cubicBezierEaseOut$2
    } = commonVariables$n;
    function slideInFromLeftTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-left"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$2}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(-100%)"
      })];
    }
    const {
      cubicBezierEaseIn: cubicBezierEaseIn$1,
      cubicBezierEaseOut: cubicBezierEaseOut$1
    } = commonVariables$n;
    function slideInFromRightTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-right"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut$1}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateX(100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateX(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateX(100%)"
      })];
    }
    const {
      cubicBezierEaseIn,
      cubicBezierEaseOut
    } = commonVariables$n;
    function slideInFromTopTransition({
      duration: duration2 = "0.3s",
      leaveDuration = "0.2s",
      name = "slide-in-from-top"
    } = {}) {
      return [c(`&.${name}-transition-leave-active`, {
        transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `transform ${duration2} ${cubicBezierEaseOut}`
      }), c(`&.${name}-transition-enter-to`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-enter-from`, {
        transform: "translateY(-100%)"
      }), c(`&.${name}-transition-leave-from`, {
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-to`, {
        transform: "translateY(-100%)"
      })];
    }
    const style$4 = c([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE$1("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE$1("main", `
 flex: 1;
 `), cE$1("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [cE$1("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c("body", [c(">", [cB("drawer-container", `
 position: fixed;
 `)])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c("> *", `
 pointer-events: all;
 `)]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
      enterDuration: "0.2s",
      leaveDuration: "0.2s",
      enterCubicBezier: "var(--n-bezier-in)",
      leaveCubicBezier: "var(--n-bezier-out)"
    })])]);
    const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
      show: Boolean,
      width: [Number, String],
      height: [Number, String],
      placement: {
        type: String,
        default: "right"
      },
      maskClosable: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        default: true
      },
      to: [String, Object],
      displayDirective: {
        type: String,
        default: "if"
      },
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      onMaskClick: Function,
      scrollbarProps: Object,
      contentClass: String,
      contentStyle: [Object, String],
      trapFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      autoFocus: {
        type: Boolean,
        default: true
      },
      closeOnEsc: {
        type: Boolean,
        default: true
      },
      blockScroll: {
        type: Boolean,
        default: true
      },
      maxWidth: Number,
      maxHeight: Number,
      minWidth: Number,
      minHeight: Number,
      resizable: Boolean,
      defaultWidth: {
        type: [Number, String],
        default: 251
      },
      defaultHeight: {
        type: [Number, String],
        default: 251
      },
      onUpdateWidth: [Function, Array],
      onUpdateHeight: [Function, Array],
      "onUpdate:width": [Function, Array],
      "onUpdate:height": [Function, Array],
      "onUpdate:show": [Function, Array],
      onUpdateShow: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      /** @deprecated */
      drawerStyle: [String, Object],
      drawerClass: String,
      target: null,
      onShow: Function,
      onHide: Function
    });
    const NDrawer = /* @__PURE__ */ defineComponent({
      name: "Drawer",
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          namespaceRef,
          inlineThemeDisabled
        } = useConfig(props);
        const isMountedRef = isMounted();
        const themeRef = useTheme("Drawer", "-drawer", style$4, drawerLight, props, mergedClsPrefixRef);
        const uncontrolledWidthRef = ref(props.defaultWidth);
        const uncontrolledHeightRef = ref(props.defaultHeight);
        const mergedWidthRef = useMergedState(toRef(props, "width"), uncontrolledWidthRef);
        const mergedHeightRef = useMergedState(toRef(props, "height"), uncontrolledHeightRef);
        const styleWidthRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "top" || placement === "bottom") return "";
          return formatLength(mergedWidthRef.value);
        });
        const styleHeightRef = computed(() => {
          const {
            placement
          } = props;
          if (placement === "left" || placement === "right") return "";
          return formatLength(mergedHeightRef.value);
        });
        const doUpdateWidth = (value) => {
          const {
            onUpdateWidth,
            "onUpdate:width": _onUpdateWidth
          } = props;
          if (onUpdateWidth) call(onUpdateWidth, value);
          if (_onUpdateWidth) call(_onUpdateWidth, value);
          uncontrolledWidthRef.value = value;
        };
        const doUpdateHeight = (value) => {
          const {
            onUpdateHeight,
            "onUpdate:width": _onUpdateHeight
          } = props;
          if (onUpdateHeight) call(onUpdateHeight, value);
          if (_onUpdateHeight) call(_onUpdateHeight, value);
          uncontrolledHeightRef.value = value;
        };
        const mergedBodyStyleRef = computed(() => {
          return [{
            width: styleWidthRef.value,
            height: styleHeightRef.value
          }, props.drawerStyle || ""];
        });
        function handleMaskClick(e) {
          const {
            onMaskClick,
            maskClosable
          } = props;
          if (maskClosable) {
            doUpdateShow(false);
          }
          if (onMaskClick) onMaskClick(e);
        }
        function handleOutsideClick(e) {
          handleMaskClick(e);
        }
        const isComposingRef2 = useIsComposing();
        function handleEsc(e) {
          var _a2;
          (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props);
          if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
            if (!isComposingRef2.value) {
              doUpdateShow(false);
            }
          }
        }
        function doUpdateShow(show) {
          const {
            onHide,
            onUpdateShow,
            "onUpdate:show": _onUpdateShow
          } = props;
          if (onUpdateShow) call(onUpdateShow, show);
          if (_onUpdateShow) call(_onUpdateShow, show);
          if (onHide && !show) call(onHide, show);
        }
        provide(drawerInjectionKey, {
          isMountedRef,
          mergedThemeRef: themeRef,
          mergedClsPrefixRef,
          doUpdateShow,
          doUpdateHeight,
          doUpdateWidth
        });
        const cssVarsRef = computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseIn: cubicBezierEaseIn2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: {
              color,
              textColor,
              boxShadow,
              lineHeight: lineHeight2,
              headerPadding,
              footerPadding,
              borderRadius,
              bodyPadding,
              titleFontSize,
              titleTextColor,
              titleFontWeight,
              headerBorderBottom,
              footerBorderTop,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeColorHover,
              closeColorPressed,
              closeIconSize,
              closeSize,
              closeBorderRadius,
              resizableTriggerColorHover
            }
          } = themeRef.value;
          return {
            "--n-line-height": lineHeight2,
            "--n-color": color,
            "--n-border-radius": borderRadius,
            "--n-text-color": textColor,
            "--n-box-shadow": boxShadow,
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-out": cubicBezierEaseOut2,
            "--n-bezier-in": cubicBezierEaseIn2,
            "--n-header-padding": headerPadding,
            "--n-body-padding": bodyPadding,
            "--n-footer-padding": footerPadding,
            "--n-title-text-color": titleTextColor,
            "--n-title-font-size": titleFontSize,
            "--n-title-font-weight": titleFontWeight,
            "--n-header-border-bottom": headerBorderBottom,
            "--n-footer-border-top": footerBorderTop,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-close-size": closeSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-size": closeIconSize,
            "--n-close-border-radius": closeBorderRadius,
            "--n-resize-trigger-color-hover": resizableTriggerColorHover
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
        return {
          mergedClsPrefix: mergedClsPrefixRef,
          namespace: namespaceRef,
          mergedBodyStyle: mergedBodyStyleRef,
          handleOutsideClick,
          handleMaskClick,
          handleEsc,
          mergedTheme: themeRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
          isMounted: isMountedRef
        };
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h(LazyTeleport, {
          to: this.to,
          show: this.show
        }, {
          default: () => {
            var _a2;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return withDirectives(h("div", {
              class: [`${mergedClsPrefix}-drawer-container`, this.namespace, this.themeClass],
              style: this.cssVars,
              role: "none"
            }, this.showMask ? h(Transition, {
              name: "fade-in-transition",
              appear: this.isMounted
            }, {
              default: () => this.show ? h("div", {
                "aria-hidden": true,
                class: [`${mergedClsPrefix}-drawer-mask`, this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`],
                onClick: this.handleMaskClick
              }) : null
            }) : null, h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, {
              class: [this.drawerClass, this.$attrs.class],
              style: [this.mergedBodyStyle, this.$attrs.style],
              blockScroll: this.blockScroll,
              contentStyle: this.contentStyle,
              contentClass: this.contentClass,
              placement: this.placement,
              scrollbarProps: this.scrollbarProps,
              show: this.show,
              displayDirective: this.displayDirective,
              nativeScrollbar: this.nativeScrollbar,
              onAfterEnter: this.onAfterEnter,
              onAfterLeave: this.onAfterLeave,
              trapFocus: this.trapFocus,
              autoFocus: this.autoFocus,
              resizable: this.resizable,
              maxHeight: this.maxHeight,
              minHeight: this.minHeight,
              maxWidth: this.maxWidth,
              minWidth: this.minWidth,
              showMask: this.showMask,
              onEsc: this.handleEsc,
              onClickoutside: this.handleOutsideClick
            }), this.$slots)), [[zindexable, {
              zIndex: this.zIndex,
              enabled: this.show
            }]]);
          }
        });
      }
    });
    const drawerContentProps = {
      title: String,
      headerClass: String,
      headerStyle: [Object, String],
      footerClass: String,
      footerStyle: [Object, String],
      bodyClass: String,
      bodyStyle: [Object, String],
      bodyContentClass: String,
      bodyContentStyle: [Object, String],
      nativeScrollbar: {
        type: Boolean,
        default: true
      },
      scrollbarProps: Object,
      closable: Boolean
    };
    const NDrawerContent = /* @__PURE__ */ defineComponent({
      name: "DrawerContent",
      props: drawerContentProps,
      slots: Object,
      setup() {
        const NDrawer2 = inject(drawerInjectionKey, null);
        if (!NDrawer2) {
          throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
        }
        const {
          doUpdateShow
        } = NDrawer2;
        function handleCloseClick() {
          doUpdateShow(false);
        }
        return {
          handleCloseClick,
          mergedTheme: NDrawer2.mergedThemeRef,
          mergedClsPrefix: NDrawer2.mergedClsPrefixRef
        };
      },
      render() {
        const {
          title,
          mergedClsPrefix,
          nativeScrollbar,
          mergedTheme,
          bodyClass,
          bodyStyle,
          bodyContentClass,
          bodyContentStyle,
          headerClass,
          headerStyle,
          footerClass,
          footerStyle,
          scrollbarProps: scrollbarProps2,
          closable,
          $slots
        } = this;
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-drawer-content`, nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`]
        }, $slots.header || title || closable ? h("div", {
          class: [`${mergedClsPrefix}-drawer-header`, headerClass],
          style: headerStyle,
          role: "none"
        }, h("div", {
          class: `${mergedClsPrefix}-drawer-header__main`,
          role: "heading",
          "aria-level": "1"
        }, $slots.header !== void 0 ? $slots.header() : title), closable && h(NBaseClose, {
          onClick: this.handleCloseClick,
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-drawer-header__close`,
          absolute: true
        })) : null, nativeScrollbar ? h("div", {
          class: [`${mergedClsPrefix}-drawer-body`, bodyClass],
          style: bodyStyle,
          role: "none"
        }, h("div", {
          class: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          style: bodyContentStyle,
          role: "none"
        }, $slots)) : h(Scrollbar, Object.assign({
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          theme: mergedTheme.peers.Scrollbar
        }, scrollbarProps2, {
          class: `${mergedClsPrefix}-drawer-body`,
          contentClass: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
          contentStyle: bodyContentStyle
        }), $slots), $slots.footer ? h("div", {
          class: [`${mergedClsPrefix}-drawer-footer`, footerClass],
          style: footerStyle,
          role: "none"
        }, $slots.footer()) : null);
      }
    });
    const commonVariables$5 = {
      actionMargin: "0 0 0 20px",
      actionMarginRtl: "0 20px 0 0"
    };
    const dynamicInputDark = {
      name: "DynamicInput",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark
      },
      self() {
        return commonVariables$5;
      }
    };
    const commonVars$4 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const spaceDark = {
      name: "Space",
      self() {
        return commonVars$4;
      }
    };
    function self$l() {
      return commonVars$4;
    }
    const spaceLight = {
      self: self$l
    };
    let supportFlexGap;
    function ensureSupportFlexGap() {
      if (!isBrowser$1) return true;
      if (supportFlexGap === void 0) {
        const flex = document.createElement("div");
        flex.style.display = "flex";
        flex.style.flexDirection = "column";
        flex.style.rowGap = "1px";
        flex.appendChild(document.createElement("div"));
        flex.appendChild(document.createElement("div"));
        document.body.appendChild(flex);
        const isSupported = flex.scrollHeight === 1;
        document.body.removeChild(flex);
        return supportFlexGap = isSupported;
      }
      return supportFlexGap;
    }
    const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
      align: String,
      justify: {
        type: String,
        default: "start"
      },
      inline: Boolean,
      vertical: Boolean,
      reverse: Boolean,
      size: {
        type: [String, Number, Array],
        default: "medium"
      },
      wrapItem: {
        type: Boolean,
        default: true
      },
      itemClass: String,
      itemStyle: [String, Object],
      wrap: {
        type: Boolean,
        default: true
      },
      // internal
      internalUseGap: {
        type: Boolean,
        default: void 0
      }
    });
    const NSpace = /* @__PURE__ */ defineComponent({
      name: "Space",
      props: spaceProps,
      setup(props) {
        const {
          mergedClsPrefixRef,
          mergedRtlRef
        } = useConfig(props);
        const themeRef = useTheme("Space", "-space", void 0, spaceLight, props, mergedClsPrefixRef);
        const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
        return {
          useGap: ensureSupportFlexGap(),
          rtlEnabled: rtlEnabledRef,
          mergedClsPrefix: mergedClsPrefixRef,
          margin: computed(() => {
            const {
              size: size2
            } = props;
            if (Array.isArray(size2)) {
              return {
                horizontal: size2[0],
                vertical: size2[1]
              };
            }
            if (typeof size2 === "number") {
              return {
                horizontal: size2,
                vertical: size2
              };
            }
            const {
              self: {
                [createKey$1("gap", size2)]: gap
              }
            } = themeRef.value;
            const {
              row,
              col
            } = getGap(gap);
            return {
              horizontal: depx(col),
              vertical: depx(row)
            };
          })
        };
      },
      render() {
        const {
          vertical,
          reverse,
          align,
          inline,
          justify,
          itemClass,
          itemStyle,
          margin,
          wrap: wrap2,
          mergedClsPrefix,
          rtlEnabled,
          useGap,
          wrapItem,
          internalUseGap
        } = this;
        const children = flatten(getSlot(this), false);
        if (!children.length) return null;
        const horizontalMargin = `${margin.horizontal}px`;
        const semiHorizontalMargin = `${margin.horizontal / 2}px`;
        const verticalMargin = `${margin.vertical}px`;
        const semiVerticalMargin = `${margin.vertical / 2}px`;
        const lastIndex = children.length - 1;
        const isJustifySpace = justify.startsWith("space-");
        return h("div", {
          role: "none",
          class: [`${mergedClsPrefix}-space`, rtlEnabled && `${mergedClsPrefix}-space--rtl`],
          style: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: (() => {
              if (vertical && !reverse) return "column";
              if (vertical && reverse) return "column-reverse";
              if (!vertical && reverse) return "row-reverse";
              else return "row";
            })(),
            justifyContent: ["start", "end"].includes(justify) ? `flex-${justify}` : justify,
            flexWrap: !wrap2 || vertical ? "nowrap" : "wrap",
            marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
            alignItems: align,
            gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
          }
        }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => child.type === Comment ? child : h("div", {
          role: "none",
          class: itemClass,
          style: [itemStyle, {
            maxWidth: "100%"
          }, useGap ? "" : vertical ? {
            marginBottom: index !== lastIndex ? verticalMargin : ""
          } : rtlEnabled ? {
            marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          } : {
            marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
            marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
            paddingTop: semiVerticalMargin,
            paddingBottom: semiVerticalMargin
          }]
        }, child)));
      }
    });
    const dynamicTagsDark = {
      name: "DynamicTags",
      common: derived$1,
      peers: {
        Input: inputDark,
        Button: buttonDark,
        Tag: tagDark,
        Space: spaceDark
      },
      self() {
        return {
          inputWidth: "64px"
        };
      }
    };
    const elementDark = {
      name: "Element",
      common: derived$1
    };
    const commonVars$3 = {
      gapSmall: "4px 8px",
      gapMedium: "8px 12px",
      gapLarge: "12px 16px"
    };
    const flexDark = {
      name: "Flex",
      self() {
        return commonVars$3;
      }
    };
    const buttonGroupDark = {
      name: "ButtonGroup",
      common: derived$1
    };
    const commonVariables$4 = {
      feedbackPadding: "4px 0 0 2px",
      feedbackHeightSmall: "24px",
      feedbackHeightMedium: "24px",
      feedbackHeightLarge: "26px",
      feedbackFontSizeSmall: "13px",
      feedbackFontSizeMedium: "14px",
      feedbackFontSizeLarge: "14px",
      labelFontSizeLeftSmall: "14px",
      labelFontSizeLeftMedium: "14px",
      labelFontSizeLeftLarge: "15px",
      labelFontSizeTopSmall: "13px",
      labelFontSizeTopMedium: "14px",
      labelFontSizeTopLarge: "14px",
      labelHeightSmall: "24px",
      labelHeightMedium: "26px",
      labelHeightLarge: "28px",
      labelPaddingVertical: "0 0 6px 2px",
      labelPaddingHorizontal: "0 12px 0 0",
      labelTextAlignVertical: "left",
      labelTextAlignHorizontal: "right",
      labelFontWeight: "400"
    };
    function self$k(vars) {
      const {
        heightSmall,
        heightMedium,
        heightLarge,
        textColor1,
        errorColor,
        warningColor,
        lineHeight: lineHeight2,
        textColor3
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), {
        blankHeightSmall: heightSmall,
        blankHeightMedium: heightMedium,
        blankHeightLarge: heightLarge,
        lineHeight: lineHeight2,
        labelTextColor: textColor1,
        asteriskColor: errorColor,
        feedbackTextColorError: errorColor,
        feedbackTextColorWarning: warningColor,
        feedbackTextColor: textColor3
      });
    }
    const formLight = {
      common: derived,
      self: self$k
    };
    const formItemDark = {
      name: "Form",
      common: derived$1,
      self: self$k
    };
    const gradientTextDark = {
      name: "GradientText",
      common: derived$1,
      self(vars) {
        const {
          primaryColor,
          successColor,
          warningColor,
          errorColor,
          infoColor,
          primaryColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          errorColorSuppl,
          infoColorSuppl,
          fontWeightStrong
        } = vars;
        return {
          fontWeight: fontWeightStrong,
          rotate: "252deg",
          colorStartPrimary: primaryColor,
          colorEndPrimary: primaryColorSuppl,
          colorStartInfo: infoColor,
          colorEndInfo: infoColorSuppl,
          colorStartWarning: warningColor,
          colorEndWarning: warningColorSuppl,
          colorStartError: errorColor,
          colorEndError: errorColorSuppl,
          colorStartSuccess: successColor,
          colorEndSuccess: successColorSuppl
        };
      }
    };
    const inputNumberDark = {
      name: "InputNumber",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Input: inputDark
      },
      self(vars) {
        const {
          textColorDisabled
        } = vars;
        return {
          iconColorDisabled: textColorDisabled
        };
      }
    };
    const layoutDark = {
      name: "Layout",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark
      },
      self(vars) {
        const {
          textColor2,
          bodyColor,
          popoverColor,
          cardColor,
          dividerColor,
          scrollbarColor,
          scrollbarColorHover
        } = vars;
        return {
          textColor: textColor2,
          textColorInverted: textColor2,
          color: bodyColor,
          colorEmbedded: bodyColor,
          headerColor: cardColor,
          headerColorInverted: cardColor,
          footerColor: cardColor,
          footerColorInverted: cardColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: dividerColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: dividerColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: dividerColor,
          siderColor: cardColor,
          siderColorInverted: cardColor,
          siderToggleButtonBorder: "1px solid transparent",
          siderToggleButtonColor: popoverColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          __invertScrollbar: "false"
        };
      }
    };
    const rowDark = {
      name: "Row",
      common: derived$1
    };
    function self$j(vars) {
      const {
        textColor2,
        cardColor,
        modalColor,
        popoverColor,
        dividerColor,
        borderRadius,
        fontSize: fontSize2,
        hoverColor
      } = vars;
      return {
        textColor: textColor2,
        color: cardColor,
        colorHover: hoverColor,
        colorModal: modalColor,
        colorHoverModal: composite(modalColor, hoverColor),
        colorPopover: popoverColor,
        colorHoverPopover: composite(popoverColor, hoverColor),
        borderColor: dividerColor,
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        borderRadius,
        fontSize: fontSize2
      };
    }
    const listDark$1 = {
      name: "List",
      common: derived$1,
      self: self$j
    };
    const logDark = {
      name: "Log",
      common: derived$1,
      peers: {
        Scrollbar: scrollbarDark,
        Code: codeDark
      },
      self(vars) {
        const {
          textColor2,
          inputColor,
          fontSize: fontSize2,
          primaryColor
        } = vars;
        return {
          loaderFontSize: fontSize2,
          loaderTextColor: textColor2,
          loaderColor: inputColor,
          loaderBorder: "1px solid #0000",
          loadingColor: primaryColor
        };
      }
    };
    const listDark = {
      name: "Mention",
      common: derived$1,
      peers: {
        InternalSelectMenu: internalSelectMenuDark,
        Input: inputDark
      },
      self(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
    };
    function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
        itemColorHoverInverted: "#0000",
        itemColorActiveInverted: activeItemColor,
        itemColorActiveHoverInverted: activeItemColor,
        itemColorActiveCollapsedInverted: activeItemColor,
        itemTextColorInverted: color,
        itemTextColorHoverInverted: activeTextColor,
        itemTextColorChildActiveInverted: activeTextColor,
        itemTextColorChildActiveHoverInverted: activeTextColor,
        itemTextColorActiveInverted: activeTextColor,
        itemTextColorActiveHoverInverted: activeTextColor,
        itemTextColorHorizontalInverted: color,
        itemTextColorHoverHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHorizontalInverted: activeTextColor,
        itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
        itemTextColorActiveHorizontalInverted: activeTextColor,
        itemTextColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorInverted: color,
        itemIconColorHoverInverted: activeTextColor,
        itemIconColorActiveInverted: activeTextColor,
        itemIconColorActiveHoverInverted: activeTextColor,
        itemIconColorChildActiveInverted: activeTextColor,
        itemIconColorChildActiveHoverInverted: activeTextColor,
        itemIconColorCollapsedInverted: color,
        itemIconColorHorizontalInverted: color,
        itemIconColorHoverHorizontalInverted: activeTextColor,
        itemIconColorActiveHorizontalInverted: activeTextColor,
        itemIconColorActiveHoverHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHorizontalInverted: activeTextColor,
        itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
        arrowColorInverted: color,
        arrowColorHoverInverted: activeTextColor,
        arrowColorActiveInverted: activeTextColor,
        arrowColorActiveHoverInverted: activeTextColor,
        arrowColorChildActiveInverted: activeTextColor,
        arrowColorChildActiveHoverInverted: activeTextColor,
        groupTextColorInverted: groupTextColor
      };
    }
    function self$i(vars) {
      const {
        borderRadius,
        textColor3,
        primaryColor,
        textColor2,
        textColor1,
        fontSize: fontSize2,
        dividerColor,
        hoverColor,
        primaryColorHover
      } = vars;
      return Object.assign({
        borderRadius,
        color: "#0000",
        groupTextColor: textColor3,
        itemColorHover: hoverColor,
        itemColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveHover: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemColorActiveCollapsed: changeColor(primaryColor, {
          alpha: 0.1
        }),
        itemTextColor: textColor2,
        itemTextColorHover: textColor2,
        itemTextColorActive: primaryColor,
        itemTextColorActiveHover: primaryColor,
        itemTextColorChildActive: primaryColor,
        itemTextColorChildActiveHover: primaryColor,
        itemTextColorHorizontal: textColor2,
        itemTextColorHoverHorizontal: primaryColorHover,
        itemTextColorActiveHorizontal: primaryColor,
        itemTextColorActiveHoverHorizontal: primaryColor,
        itemTextColorChildActiveHorizontal: primaryColor,
        itemTextColorChildActiveHoverHorizontal: primaryColor,
        itemIconColor: textColor1,
        itemIconColorHover: textColor1,
        itemIconColorActive: primaryColor,
        itemIconColorActiveHover: primaryColor,
        itemIconColorChildActive: primaryColor,
        itemIconColorChildActiveHover: primaryColor,
        itemIconColorCollapsed: textColor1,
        itemIconColorHorizontal: textColor1,
        itemIconColorHoverHorizontal: primaryColorHover,
        itemIconColorActiveHorizontal: primaryColor,
        itemIconColorActiveHoverHorizontal: primaryColor,
        itemIconColorChildActiveHorizontal: primaryColor,
        itemIconColorChildActiveHoverHorizontal: primaryColor,
        itemHeight: "42px",
        arrowColor: textColor2,
        arrowColorHover: textColor2,
        arrowColorActive: primaryColor,
        arrowColorActiveHover: primaryColor,
        arrowColorChildActive: primaryColor,
        arrowColorChildActiveHover: primaryColor,
        colorInverted: "#0000",
        borderColorHorizontal: "#0000",
        fontSize: fontSize2,
        dividerColor
      }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
    }
    const menuDark = {
      name: "Menu",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark,
        Dropdown: dropdownDark
      },
      self(vars) {
        const {
          primaryColor,
          primaryColorSuppl
        } = vars;
        const commonSelf = self$i(vars);
        commonSelf.itemColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveHover = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveCollapsed = changeColor(primaryColor, {
          alpha: 0.15
        });
        commonSelf.itemColorActiveInverted = primaryColorSuppl;
        commonSelf.itemColorActiveHoverInverted = primaryColorSuppl;
        commonSelf.itemColorActiveCollapsedInverted = primaryColorSuppl;
        return commonSelf;
      }
    };
    const common = {
      titleFontSize: "18px",
      backSize: "22px"
    };
    function self$h(vars) {
      const {
        textColor1,
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeightStrong,
        primaryColorHover,
        primaryColorPressed
      } = vars;
      return Object.assign(Object.assign({}, common), {
        titleFontWeight: fontWeightStrong,
        fontSize: fontSize2,
        titleTextColor: textColor1,
        backColor: textColor2,
        backColorHover: primaryColorHover,
        backColorPressed: primaryColorPressed,
        subtitleTextColor: textColor3
      });
    }
    const pageHeaderDark = {
      name: "PageHeader",
      common: derived$1,
      self: self$h
    };
    const commonVars$2 = {
      iconSize: "22px"
    };
    function self$g(vars) {
      const {
        fontSize: fontSize2,
        warningColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars$2), {
        fontSize: fontSize2,
        iconColor: warningColor
      });
    }
    const popconfirmDark = {
      name: "Popconfirm",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Popover: popoverDark
      },
      self: self$g
    };
    function self$f(vars) {
      const {
        infoColor,
        successColor,
        warningColor,
        errorColor,
        textColor2,
        progressRailColor,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        fontSize: fontSize2,
        fontSizeCircle: "28px",
        fontWeightCircle: fontWeight,
        railColor: progressRailColor,
        railHeight: "8px",
        iconSizeCircle: "36px",
        iconSizeLine: "18px",
        iconColor: infoColor,
        iconColorInfo: infoColor,
        iconColorSuccess: successColor,
        iconColorWarning: warningColor,
        iconColorError: errorColor,
        textColorCircle: textColor2,
        textColorLineInner: "rgb(255, 255, 255)",
        textColorLineOuter: textColor2,
        fillColor: infoColor,
        fillColorInfo: infoColor,
        fillColorSuccess: successColor,
        fillColorWarning: warningColor,
        fillColorError: errorColor,
        lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
      };
    }
    const progressDark = {
      name: "Progress",
      common: derived$1,
      self(vars) {
        const commonSelf = self$f(vars);
        commonSelf.textColorLineInner = "rgb(0, 0, 0)";
        commonSelf.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)";
        return commonSelf;
      }
    };
    const rateDark = {
      name: "Rate",
      common: derived$1,
      self(vars) {
        const {
          railColor
        } = vars;
        return {
          itemColor: railColor,
          itemColorActive: "#CCAA33",
          itemSize: "20px",
          sizeSmall: "16px",
          sizeMedium: "20px",
          sizeLarge: "24px"
        };
      }
    };
    const commonVariables$3 = {
      titleFontSizeSmall: "26px",
      titleFontSizeMedium: "32px",
      titleFontSizeLarge: "40px",
      titleFontSizeHuge: "48px",
      fontSizeSmall: "14px",
      fontSizeMedium: "14px",
      fontSizeLarge: "15px",
      fontSizeHuge: "16px",
      iconSizeSmall: "64px",
      iconSizeMedium: "80px",
      iconSizeLarge: "100px",
      iconSizeHuge: "125px",
      iconColor418: void 0,
      iconColor404: void 0,
      iconColor403: void 0,
      iconColor500: void 0
    };
    function self$e(vars) {
      const {
        textColor2,
        textColor1,
        errorColor,
        successColor,
        infoColor,
        warningColor,
        lineHeight: lineHeight2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), {
        lineHeight: lineHeight2,
        titleFontWeight: fontWeightStrong,
        titleTextColor: textColor1,
        textColor: textColor2,
        iconColorError: errorColor,
        iconColorSuccess: successColor,
        iconColorInfo: infoColor,
        iconColorWarning: warningColor
      });
    }
    const resultDark = {
      name: "Result",
      common: derived$1,
      self: self$e
    };
    const sizeVariables$3 = {
      railHeight: "4px",
      railWidthVertical: "4px",
      handleSize: "18px",
      dotHeight: "8px",
      dotWidth: "8px",
      dotBorderRadius: "4px"
    };
    const sliderDark = {
      name: "Slider",
      common: derived$1,
      self(vars) {
        const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
        const {
          railColor,
          modalColor,
          primaryColorSuppl,
          popoverColor,
          textColor2,
          cardColor,
          borderRadius,
          fontSize: fontSize2,
          opacityDisabled
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables$3), {
          fontSize: fontSize2,
          markFontSize: fontSize2,
          railColor,
          railColorHover: railColor,
          fillColor: primaryColorSuppl,
          fillColorHover: primaryColorSuppl,
          opacityDisabled,
          handleColor: "#FFF",
          dotColor: cardColor,
          dotColorModal: modalColor,
          dotColorPopover: popoverColor,
          handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          indicatorColor: popoverColor,
          indicatorBoxShadow: boxShadow,
          indicatorTextColor: textColor2,
          indicatorBorderRadius: borderRadius,
          dotBorder: `2px solid ${railColor}`,
          dotBorderActive: `2px solid ${primaryColorSuppl}`,
          dotBoxShadow: ""
        });
      }
    };
    function self$d(vars) {
      const {
        opacityDisabled,
        heightTiny,
        heightSmall,
        heightMedium,
        heightLarge,
        heightHuge,
        primaryColor,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        textColor: primaryColor,
        sizeTiny: heightTiny,
        sizeSmall: heightSmall,
        sizeMedium: heightMedium,
        sizeLarge: heightLarge,
        sizeHuge: heightHuge,
        color: primaryColor,
        opacitySpinning: opacityDisabled
      };
    }
    const spinDark = {
      name: "Spin",
      common: derived$1,
      self: self$d
    };
    function self$c(vars) {
      const {
        textColor2,
        textColor3,
        fontSize: fontSize2,
        fontWeight
      } = vars;
      return {
        labelFontSize: fontSize2,
        labelFontWeight: fontWeight,
        valueFontWeight: fontWeight,
        valueFontSize: "24px",
        labelTextColor: textColor3,
        valuePrefixTextColor: textColor2,
        valueSuffixTextColor: textColor2,
        valueTextColor: textColor2
      };
    }
    const statisticDark = {
      name: "Statistic",
      common: derived$1,
      self: self$c
    };
    const commonVariables$2 = {
      stepHeaderFontSizeSmall: "14px",
      stepHeaderFontSizeMedium: "16px",
      indicatorIndexFontSizeSmall: "14px",
      indicatorIndexFontSizeMedium: "16px",
      indicatorSizeSmall: "22px",
      indicatorSizeMedium: "28px",
      indicatorIconSizeSmall: "14px",
      indicatorIconSizeMedium: "18px"
    };
    function self$b(vars) {
      const {
        fontWeightStrong,
        baseColor,
        textColorDisabled,
        primaryColor,
        errorColor,
        textColor1,
        textColor2
      } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), {
        stepHeaderFontWeight: fontWeightStrong,
        indicatorTextColorProcess: baseColor,
        indicatorTextColorWait: textColorDisabled,
        indicatorTextColorFinish: primaryColor,
        indicatorTextColorError: errorColor,
        indicatorBorderColorProcess: primaryColor,
        indicatorBorderColorWait: textColorDisabled,
        indicatorBorderColorFinish: primaryColor,
        indicatorBorderColorError: errorColor,
        indicatorColorProcess: primaryColor,
        indicatorColorWait: "#0000",
        indicatorColorFinish: "#0000",
        indicatorColorError: "#0000",
        splitorColorProcess: textColorDisabled,
        splitorColorWait: textColorDisabled,
        splitorColorFinish: primaryColor,
        splitorColorError: textColorDisabled,
        headerTextColorProcess: textColor1,
        headerTextColorWait: textColorDisabled,
        headerTextColorFinish: textColorDisabled,
        headerTextColorError: errorColor,
        descriptionTextColorProcess: textColor2,
        descriptionTextColorWait: textColorDisabled,
        descriptionTextColorFinish: textColorDisabled,
        descriptionTextColorError: errorColor
      });
    }
    const stepsDark = {
      name: "Steps",
      common: derived$1,
      self: self$b
    };
    const commonVars$1 = {
      buttonHeightSmall: "14px",
      buttonHeightMedium: "18px",
      buttonHeightLarge: "22px",
      buttonWidthSmall: "14px",
      buttonWidthMedium: "18px",
      buttonWidthLarge: "22px",
      buttonWidthPressedSmall: "20px",
      buttonWidthPressedMedium: "24px",
      buttonWidthPressedLarge: "28px",
      railHeightSmall: "18px",
      railHeightMedium: "22px",
      railHeightLarge: "26px",
      railWidthSmall: "32px",
      railWidthMedium: "40px",
      railWidthLarge: "48px"
    };
    const switchDark = {
      name: "Switch",
      common: derived$1,
      self(vars) {
        const {
          primaryColorSuppl,
          opacityDisabled,
          borderRadius,
          primaryColor,
          textColor2,
          baseColor
        } = vars;
        const railOverlayColor = "rgba(255, 255, 255, .20)";
        return Object.assign(Object.assign({}, commonVars$1), {
          iconColor: baseColor,
          textColor: textColor2,
          loadingColor: primaryColorSuppl,
          opacityDisabled,
          railColor: railOverlayColor,
          railColorActive: primaryColorSuppl,
          buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)",
          buttonColor: "#FFF",
          railBorderRadiusSmall: borderRadius,
          railBorderRadiusMedium: borderRadius,
          railBorderRadiusLarge: borderRadius,
          buttonBorderRadiusSmall: borderRadius,
          buttonBorderRadiusMedium: borderRadius,
          buttonBorderRadiusLarge: borderRadius,
          boxShadowFocus: `0 0 8px 0 ${changeColor(primaryColor, {
            alpha: 0.3
          })}`
        });
      }
    };
    function self$a(vars) {
      const {
        primaryColor,
        opacityDisabled,
        borderRadius,
        textColor3
      } = vars;
      const railOverlayColor = "rgba(0, 0, 0, .14)";
      return Object.assign(Object.assign({}, commonVars$1), {
        iconColor: textColor3,
        textColor: "white",
        loadingColor: primaryColor,
        opacityDisabled,
        railColor: railOverlayColor,
        railColorActive: primaryColor,
        buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
        buttonColor: "#FFF",
        railBorderRadiusSmall: borderRadius,
        railBorderRadiusMedium: borderRadius,
        railBorderRadiusLarge: borderRadius,
        buttonBorderRadiusSmall: borderRadius,
        buttonBorderRadiusMedium: borderRadius,
        buttonBorderRadiusLarge: borderRadius,
        boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`
      });
    }
    const switchLight = {
      common: derived,
      self: self$a
    };
    const sizeVariables$2 = {
      thPaddingSmall: "6px",
      thPaddingMedium: "12px",
      thPaddingLarge: "12px",
      tdPaddingSmall: "6px",
      tdPaddingMedium: "12px",
      tdPaddingLarge: "12px"
    };
    function self$9(vars) {
      const {
        dividerColor,
        cardColor,
        modalColor,
        popoverColor,
        tableHeaderColor,
        tableColorStriped,
        textColor1,
        textColor2,
        borderRadius,
        fontWeightStrong,
        lineHeight: lineHeight2,
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$2), {
        fontSizeSmall,
        fontSizeMedium,
        fontSizeLarge,
        lineHeight: lineHeight2,
        borderRadius,
        borderColor: composite(cardColor, dividerColor),
        borderColorModal: composite(modalColor, dividerColor),
        borderColorPopover: composite(popoverColor, dividerColor),
        tdColor: cardColor,
        tdColorModal: modalColor,
        tdColorPopover: popoverColor,
        tdColorStriped: composite(cardColor, tableColorStriped),
        tdColorStripedModal: composite(modalColor, tableColorStriped),
        tdColorStripedPopover: composite(popoverColor, tableColorStriped),
        thColor: composite(cardColor, tableHeaderColor),
        thColorModal: composite(modalColor, tableHeaderColor),
        thColorPopover: composite(popoverColor, tableHeaderColor),
        thTextColor: textColor1,
        tdTextColor: textColor2,
        thFontWeight: fontWeightStrong
      });
    }
    const tableDark = {
      name: "Table",
      common: derived$1,
      self: self$9
    };
    const sizeVariables$1 = {
      tabFontSizeSmall: "14px",
      tabFontSizeMedium: "14px",
      tabFontSizeLarge: "16px",
      tabGapSmallLine: "36px",
      tabGapMediumLine: "36px",
      tabGapLargeLine: "36px",
      tabGapSmallLineVertical: "8px",
      tabGapMediumLineVertical: "8px",
      tabGapLargeLineVertical: "8px",
      tabPaddingSmallLine: "6px 0",
      tabPaddingMediumLine: "10px 0",
      tabPaddingLargeLine: "14px 0",
      tabPaddingVerticalSmallLine: "6px 12px",
      tabPaddingVerticalMediumLine: "8px 16px",
      tabPaddingVerticalLargeLine: "10px 20px",
      tabGapSmallBar: "36px",
      tabGapMediumBar: "36px",
      tabGapLargeBar: "36px",
      tabGapSmallBarVertical: "8px",
      tabGapMediumBarVertical: "8px",
      tabGapLargeBarVertical: "8px",
      tabPaddingSmallBar: "4px 0",
      tabPaddingMediumBar: "6px 0",
      tabPaddingLargeBar: "10px 0",
      tabPaddingVerticalSmallBar: "6px 12px",
      tabPaddingVerticalMediumBar: "8px 16px",
      tabPaddingVerticalLargeBar: "10px 20px",
      tabGapSmallCard: "4px",
      tabGapMediumCard: "4px",
      tabGapLargeCard: "4px",
      tabGapSmallCardVertical: "4px",
      tabGapMediumCardVertical: "4px",
      tabGapLargeCardVertical: "4px",
      tabPaddingSmallCard: "8px 16px",
      tabPaddingMediumCard: "10px 20px",
      tabPaddingLargeCard: "12px 24px",
      tabPaddingSmallSegment: "4px 0",
      tabPaddingMediumSegment: "6px 0",
      tabPaddingLargeSegment: "8px 0",
      tabPaddingVerticalLargeSegment: "0 8px",
      tabPaddingVerticalSmallCard: "8px 12px",
      tabPaddingVerticalMediumCard: "10px 16px",
      tabPaddingVerticalLargeCard: "12px 20px",
      tabPaddingVerticalSmallSegment: "0 4px",
      tabPaddingVerticalMediumSegment: "0 6px",
      tabGapSmallSegment: "0",
      tabGapMediumSegment: "0",
      tabGapLargeSegment: "0",
      tabGapSmallSegmentVertical: "0",
      tabGapMediumSegmentVertical: "0",
      tabGapLargeSegmentVertical: "0",
      panePaddingSmall: "8px 0 0 0",
      panePaddingMedium: "12px 0 0 0",
      panePaddingLarge: "16px 0 0 0",
      closeSize: "18px",
      closeIconSize: "14px"
    };
    function self$8(vars) {
      const {
        textColor2,
        primaryColor,
        textColorDisabled,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        tabColor,
        baseColor,
        dividerColor,
        fontWeight,
        textColor1,
        borderRadius,
        fontSize: fontSize2,
        fontWeightStrong
      } = vars;
      return Object.assign(Object.assign({}, sizeVariables$1), {
        colorSegment: tabColor,
        tabFontSizeCard: fontSize2,
        tabTextColorLine: textColor1,
        tabTextColorActiveLine: primaryColor,
        tabTextColorHoverLine: primaryColor,
        tabTextColorDisabledLine: textColorDisabled,
        tabTextColorSegment: textColor1,
        tabTextColorActiveSegment: textColor2,
        tabTextColorHoverSegment: textColor2,
        tabTextColorDisabledSegment: textColorDisabled,
        tabTextColorBar: textColor1,
        tabTextColorActiveBar: primaryColor,
        tabTextColorHoverBar: primaryColor,
        tabTextColorDisabledBar: textColorDisabled,
        tabTextColorCard: textColor1,
        tabTextColorHoverCard: textColor1,
        tabTextColorActiveCard: primaryColor,
        tabTextColorDisabledCard: textColorDisabled,
        barColor: primaryColor,
        closeIconColor,
        closeIconColorHover,
        closeIconColorPressed,
        closeColorHover,
        closeColorPressed,
        closeBorderRadius: borderRadius,
        tabColor,
        tabColorSegment: baseColor,
        tabBorderColor: dividerColor,
        tabFontWeightActive: fontWeight,
        tabFontWeight: fontWeight,
        tabBorderRadius: borderRadius,
        paneTextColor: textColor2,
        fontWeightStrong
      });
    }
    const tabsDark = {
      name: "Tabs",
      common: derived$1,
      self(vars) {
        const commonSelf = self$8(vars);
        const {
          inputColor
        } = vars;
        commonSelf.colorSegment = inputColor;
        commonSelf.tabColorSegment = inputColor;
        return commonSelf;
      }
    };
    function self$7(vars) {
      const {
        textColor1,
        textColor2,
        fontWeightStrong,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        titleTextColor: textColor1,
        textColor: textColor2,
        titleFontWeight: fontWeightStrong
      };
    }
    const thingDark = {
      name: "Thing",
      common: derived$1,
      self: self$7
    };
    const sizeVariables = {
      titleMarginMedium: "0 0 6px 0",
      titleMarginLarge: "-2px 0 6px 0",
      titleFontSizeMedium: "14px",
      titleFontSizeLarge: "16px",
      iconSizeMedium: "14px",
      iconSizeLarge: "14px"
    };
    const timelineDark = {
      name: "Timeline",
      common: derived$1,
      self(vars) {
        const {
          textColor3,
          infoColorSuppl,
          errorColorSuppl,
          successColorSuppl,
          warningColorSuppl,
          textColor1,
          textColor2,
          railColor,
          fontWeightStrong,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables), {
          contentFontSize: fontSize2,
          titleFontWeight: fontWeightStrong,
          circleBorder: `2px solid ${textColor3}`,
          circleBorderInfo: `2px solid ${infoColorSuppl}`,
          circleBorderError: `2px solid ${errorColorSuppl}`,
          circleBorderSuccess: `2px solid ${successColorSuppl}`,
          circleBorderWarning: `2px solid ${warningColorSuppl}`,
          iconColor: textColor3,
          iconColorInfo: infoColorSuppl,
          iconColorError: errorColorSuppl,
          iconColorSuccess: successColorSuppl,
          iconColorWarning: warningColorSuppl,
          titleTextColor: textColor1,
          contentTextColor: textColor2,
          metaTextColor: textColor3,
          lineColor: railColor
        });
      }
    };
    const commonVariables$1 = {
      extraFontSizeSmall: "12px",
      extraFontSizeMedium: "12px",
      extraFontSizeLarge: "14px",
      titleFontSizeSmall: "14px",
      titleFontSizeMedium: "16px",
      titleFontSizeLarge: "16px",
      closeSize: "20px",
      closeIconSize: "16px",
      headerHeightSmall: "44px",
      headerHeightMedium: "44px",
      headerHeightLarge: "50px"
    };
    const transferDark$1 = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          textColor3,
          hoverColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          dividerColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          itemHeightSmall: heightMedium,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          dividerColor,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor3,
          extraTextColorDisabled: textColorDisabled,
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed
        });
      }
    };
    function self$6(vars) {
      const {
        borderRadiusSmall,
        dividerColor,
        hoverColor,
        pressedColor,
        primaryColor,
        textColor3,
        textColor2,
        textColorDisabled,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: "1.5",
        nodeHeight: "30px",
        nodeWrapperPadding: "3px 0",
        nodeBorderRadius: borderRadiusSmall,
        nodeColorHover: hoverColor,
        nodeColorPressed: pressedColor,
        nodeColorActive: changeColor(primaryColor, {
          alpha: 0.1
        }),
        arrowColor: textColor3,
        nodeTextColor: textColor2,
        nodeTextColorDisabled: textColorDisabled,
        loadingColor: primaryColor,
        dropMarkColor: primaryColor,
        lineColor: dividerColor
      };
    }
    const treeDark = {
      name: "Tree",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Empty: emptyDark
      },
      self(vars) {
        const {
          primaryColor
        } = vars;
        const commonSelf = self$6(vars);
        commonSelf.nodeColorActive = changeColor(primaryColor, {
          alpha: 0.15
        });
        return commonSelf;
      }
    };
    const treeSelectDark = {
      name: "TreeSelect",
      common: derived$1,
      peers: {
        Tree: treeDark,
        Empty: emptyDark,
        InternalSelection: internalSelectionDark
      }
    };
    const commonVars = {
      headerFontSize1: "30px",
      headerFontSize2: "22px",
      headerFontSize3: "18px",
      headerFontSize4: "16px",
      headerFontSize5: "16px",
      headerFontSize6: "16px",
      headerMargin1: "28px 0 20px 0",
      headerMargin2: "28px 0 20px 0",
      headerMargin3: "28px 0 20px 0",
      headerMargin4: "28px 0 18px 0",
      headerMargin5: "28px 0 18px 0",
      headerMargin6: "28px 0 18px 0",
      headerPrefixWidth1: "16px",
      headerPrefixWidth2: "16px",
      headerPrefixWidth3: "12px",
      headerPrefixWidth4: "12px",
      headerPrefixWidth5: "12px",
      headerPrefixWidth6: "12px",
      headerBarWidth1: "4px",
      headerBarWidth2: "4px",
      headerBarWidth3: "3px",
      headerBarWidth4: "3px",
      headerBarWidth5: "3px",
      headerBarWidth6: "3px",
      pMargin: "16px 0 16px 0",
      liMargin: ".25em 0 0 0",
      olPadding: "0 0 0 2em",
      ulPadding: "0 0 0 2em"
    };
    function self$5(vars) {
      const {
        primaryColor,
        textColor2,
        borderColor,
        lineHeight: lineHeight2,
        fontSize: fontSize2,
        borderRadiusSmall,
        dividerColor,
        fontWeightStrong,
        textColor1,
        textColor3,
        infoColor,
        warningColor,
        errorColor,
        successColor,
        codeColor
      } = vars;
      return Object.assign(Object.assign({}, commonVars), {
        aTextColor: primaryColor,
        blockquoteTextColor: textColor2,
        blockquotePrefixColor: borderColor,
        blockquoteLineHeight: lineHeight2,
        blockquoteFontSize: fontSize2,
        codeBorderRadius: borderRadiusSmall,
        liTextColor: textColor2,
        liLineHeight: lineHeight2,
        liFontSize: fontSize2,
        hrColor: dividerColor,
        headerFontWeight: fontWeightStrong,
        headerTextColor: textColor1,
        pTextColor: textColor2,
        pTextColor1Depth: textColor1,
        pTextColor2Depth: textColor2,
        pTextColor3Depth: textColor3,
        pLineHeight: lineHeight2,
        pFontSize: fontSize2,
        headerBarColor: primaryColor,
        headerBarColorPrimary: primaryColor,
        headerBarColorInfo: infoColor,
        headerBarColorError: errorColor,
        headerBarColorWarning: warningColor,
        headerBarColorSuccess: successColor,
        textColor: textColor2,
        textColor1Depth: textColor1,
        textColor2Depth: textColor2,
        textColor3Depth: textColor3,
        textColorPrimary: primaryColor,
        textColorInfo: infoColor,
        textColorSuccess: successColor,
        textColorWarning: warningColor,
        textColorError: errorColor,
        codeTextColor: textColor2,
        codeColor,
        codeBorder: "1px solid #0000"
      });
    }
    const typographyDark = {
      name: "Typography",
      common: derived$1,
      self: self$5
    };
    function self$4(vars) {
      const {
        iconColor,
        primaryColor,
        errorColor,
        textColor2,
        successColor,
        opacityDisabled,
        actionColor,
        borderColor,
        hoverColor,
        lineHeight: lineHeight2,
        borderRadius,
        fontSize: fontSize2
      } = vars;
      return {
        fontSize: fontSize2,
        lineHeight: lineHeight2,
        borderRadius,
        draggerColor: actionColor,
        draggerBorder: `1px dashed ${borderColor}`,
        draggerBorderHover: `1px dashed ${primaryColor}`,
        itemColorHover: hoverColor,
        itemColorHoverError: changeColor(errorColor, {
          alpha: 0.06
        }),
        itemTextColor: textColor2,
        itemTextColorError: errorColor,
        itemTextColorSuccess: successColor,
        itemIconColor: iconColor,
        itemDisabledOpacity: opacityDisabled,
        itemBorderImageCardError: `1px solid ${errorColor}`,
        itemBorderImageCard: `1px solid ${borderColor}`
      };
    }
    const uploadDark = {
      name: "Upload",
      common: derived$1,
      peers: {
        Button: buttonDark,
        Progress: progressDark
      },
      self(vars) {
        const {
          errorColor
        } = vars;
        const commonSelf = self$4(vars);
        commonSelf.itemColorHoverError = changeColor(errorColor, {
          alpha: 0.09
        });
        return commonSelf;
      }
    };
    const watermarkDark = {
      name: "Watermark",
      common: derived$1,
      self(vars) {
        const {
          fontFamily: fontFamily2
        } = vars;
        return {
          fontFamily: fontFamily2
        };
      }
    };
    const floatButtonDark = {
      name: "FloatButton",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          textColor2,
          buttonColor2Hover,
          buttonColor2Pressed,
          primaryColor,
          primaryColorHover,
          primaryColorPressed,
          baseColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          textColor: textColor2,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
          boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)",
          colorHover: buttonColor2Hover,
          colorPressed: buttonColor2Pressed,
          colorPrimary: primaryColor,
          colorPrimaryHover: primaryColorHover,
          colorPrimaryPressed: primaryColorPressed,
          textColorPrimary: baseColor,
          borderRadiusSquare: borderRadius
        };
      }
    };
    const formInjectionKey = createInjectionKey("n-form");
    const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
    const style$3 = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
      width: "auto",
      marginRight: "18px"
    }, [c("&:last-child", {
      marginRight: 0
    })])])]);
    var __awaiter$1 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formProps = Object.assign(Object.assign({}, useTheme.props), {
      inline: Boolean,
      labelWidth: [Number, String],
      labelAlign: String,
      labelPlacement: {
        type: String,
        default: "top"
      },
      model: {
        type: Object,
        default: () => {
        }
      },
      rules: Object,
      disabled: Boolean,
      size: String,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: true
      },
      onSubmit: {
        type: Function,
        default: (e) => {
          e.preventDefault();
        }
      },
      showLabel: {
        type: Boolean,
        default: void 0
      },
      validateMessages: Object
    });
    const NForm = /* @__PURE__ */ defineComponent({
      name: "Form",
      props: formProps,
      setup(props) {
        const {
          mergedClsPrefixRef
        } = useConfig(props);
        useTheme("Form", "-form", style$3, formLight, props, mergedClsPrefixRef);
        const formItems = {};
        const maxChildLabelWidthRef = ref(void 0);
        const deriveMaxChildLabelWidth = (currentWidth) => {
          const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
          if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
            maxChildLabelWidthRef.value = currentWidth;
          }
        };
        function validate(validateCallback_1) {
          return __awaiter$1(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
            return yield new Promise((resolve2, reject) => {
              const formItemValidationPromises = [];
              for (const key of keysOf(formItems)) {
                const formItemInstances = formItems[key];
                for (const formItemInstance of formItemInstances) {
                  if (formItemInstance.path) {
                    formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                  }
                }
              }
              void Promise.all(formItemValidationPromises).then((results) => {
                const formInvalid = results.some((result) => !result.valid);
                const errors = [];
                const warnings = [];
                results.forEach((result) => {
                  var _a2, _b2;
                  if ((_a2 = result.errors) === null || _a2 === void 0 ? void 0 : _a2.length) {
                    errors.push(result.errors);
                  }
                  if ((_b2 = result.warnings) === null || _b2 === void 0 ? void 0 : _b2.length) {
                    warnings.push(result.warnings);
                  }
                });
                if (validateCallback) {
                  validateCallback(errors.length ? errors : void 0, {
                    warnings: warnings.length ? warnings : void 0
                  });
                }
                if (formInvalid) {
                  reject(errors.length ? errors : void 0);
                } else {
                  resolve2({
                    warnings: warnings.length ? warnings : void 0
                  });
                }
              });
            });
          });
        }
        function restoreValidation() {
          for (const key of keysOf(formItems)) {
            const formItemInstances = formItems[key];
            for (const formItemInstance of formItemInstances) {
              formItemInstance.restoreValidation();
            }
          }
        }
        provide(formInjectionKey, {
          props,
          maxChildLabelWidthRef,
          deriveMaxChildLabelWidth
        });
        provide(formItemInstsInjectionKey, {
          formItems
        });
        const formExposedMethod = {
          validate,
          restoreValidation
        };
        return Object.assign(formExposedMethod, {
          mergedClsPrefix: mergedClsPrefixRef
        });
      },
      render() {
        const {
          mergedClsPrefix
        } = this;
        return h("form", {
          class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
          onSubmit: this.onSubmit
        }, this.$slots);
      }
    });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
        o2.__proto__ = p22;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i2 = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i2 >= len) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i2 = 0; i2 < path.length; i2++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i2]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip2 = function ip22(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip2.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip2.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip2.v4().source;
      var ipv6 = ip2.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float2(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex2(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema$1 = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc2) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc22() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i2 = 0; i2 < results.length; i2++) {
            add(results[i2]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb2, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e) {
              return cb2(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType2(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema$1.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema$1.warning = warning;
    Schema$1.messages = messages;
    Schema$1.validators = validators;
    const {
      cubicBezierEaseInOut
    } = commonVariables$n;
    function fadeDownTransition({
      name = "fade-down",
      fromOffset = "-4px",
      enterDuration = ".3s",
      leaveDuration = ".3s",
      enterCubicBezier = cubicBezierEaseInOut,
      leaveCubicBezier = cubicBezierEaseInOut
    } = {}) {
      return [c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
        opacity: 0,
        transform: `translateY(${fromOffset})`
      }), c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
        opacity: 1,
        transform: "translateY(0)"
      }), c(`&.${name}-transition-leave-active`, {
        transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
      }), c(`&.${name}-transition-enter-active`, {
        transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
      })];
    }
    const style$2 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE$1("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE$1("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE$1("text", `
 grid-area: text; 
 `), cE$1("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
      transition: "color .3s var(--n-bezier)",
      color: "var(--n-feedback-text-color)"
    }, [cM("warning", {
      color: "var(--n-feedback-text-color-warning)"
    }), cM("error", {
      color: "var(--n-feedback-text-color-error)"
    }), fadeDownTransition({
      fromOffset: "-3px",
      enterDuration: ".3s",
      leaveDuration: ".2s"
    })])])]);
    function formItemSize(props) {
      const NForm2 = inject(formInjectionKey, null);
      return {
        mergedSize: computed(() => {
          if (props.size !== void 0) return props.size;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0) return NForm2.props.size;
          return "medium";
        })
      };
    }
    function formItemMisc(props) {
      const NForm2 = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
        const {
          labelPlacement
        } = props;
        if (labelPlacement !== void 0) return labelPlacement;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement) return NForm2.props.labelPlacement;
        return "top";
      });
      const isAutoLabelWidthRef = computed(() => {
        return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
      });
      const mergedLabelWidthRef = computed(() => {
        if (mergedLabelPlacementRef.value === "top") return;
        const {
          labelWidth
        } = props;
        if (labelWidth !== void 0 && labelWidth !== "auto") {
          return formatLength(labelWidth);
        }
        if (isAutoLabelWidthRef.value) {
          const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
          if (autoComputedWidth !== void 0) {
            return formatLength(autoComputedWidth);
          } else {
            return void 0;
          }
        }
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
          return formatLength(NForm2.props.labelWidth);
        }
        return void 0;
      });
      const mergedLabelAlignRef = computed(() => {
        const {
          labelAlign
        } = props;
        if (labelAlign) return labelAlign;
        if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign) return NForm2.props.labelAlign;
        return void 0;
      });
      const mergedLabelStyleRef = computed(() => {
        var _a2;
        return [(_a2 = props.labelProps) === null || _a2 === void 0 ? void 0 : _a2.style, props.labelStyle, {
          width: mergedLabelWidthRef.value
        }];
      });
      const mergedShowRequireMarkRef = computed(() => {
        const {
          showRequireMark
        } = props;
        if (showRequireMark !== void 0) return showRequireMark;
        return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
        const {
          requireMarkPlacement
        } = props;
        if (requireMarkPlacement !== void 0) return requireMarkPlacement;
        return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
      });
      const validationErroredRef = ref(false);
      const validationWarnedRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
        const {
          validationStatus
        } = props;
        if (validationStatus !== void 0) return validationStatus;
        if (validationErroredRef.value) return "error";
        if (validationWarnedRef.value) return "warning";
        return void 0;
      });
      const mergedShowFeedbackRef = computed(() => {
        const {
          showFeedback
        } = props;
        if (showFeedback !== void 0) return showFeedback;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0) return NForm2.props.showFeedback;
        return true;
      });
      const mergedShowLabelRef = computed(() => {
        const {
          showLabel
        } = props;
        if (showLabel !== void 0) return showLabel;
        if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0) return NForm2.props.showLabel;
        return true;
      });
      return {
        validationErrored: validationErroredRef,
        validationWarned: validationWarnedRef,
        mergedLabelStyle: mergedLabelStyleRef,
        mergedLabelPlacement: mergedLabelPlacementRef,
        mergedLabelAlign: mergedLabelAlignRef,
        mergedShowRequireMark: mergedShowRequireMarkRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
        mergedValidationStatus: mergedValidationStatusRef,
        mergedShowFeedback: mergedShowFeedbackRef,
        mergedShowLabel: mergedShowLabelRef,
        isAutoLabelWidth: isAutoLabelWidthRef
      };
    }
    function formItemRule(props) {
      const NForm2 = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
        const {
          rulePath
        } = props;
        if (rulePath !== void 0) return rulePath;
        const {
          path
        } = props;
        if (path !== void 0) return path;
        return void 0;
      });
      const mergedRulesRef = computed(() => {
        const rules2 = [];
        const {
          rule
        } = props;
        if (rule !== void 0) {
          if (Array.isArray(rule)) rules2.push(...rule);
          else rules2.push(rule);
        }
        if (NForm2) {
          const {
            rules: formRules
          } = NForm2.props;
          const {
            value: rulePath
          } = compatibleRulePathRef;
          if (formRules !== void 0 && rulePath !== void 0) {
            const formRule = get(formRules, rulePath);
            if (formRule !== void 0) {
              if (Array.isArray(formRule)) {
                rules2.push(...formRule);
              } else {
                rules2.push(formRule);
              }
            }
          }
        }
        return rules2;
      });
      const hasRequiredRuleRef = computed(() => {
        return mergedRulesRef.value.some((rule) => rule.required);
      });
      const mergedRequiredRef = computed(() => {
        return hasRequiredRuleRef.value || props.required;
      });
      return {
        mergedRules: mergedRulesRef,
        mergedRequired: mergedRequiredRef
      };
    }
    var __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
      label: String,
      labelWidth: [Number, String],
      labelStyle: [String, Object],
      labelAlign: String,
      labelPlacement: String,
      path: String,
      first: Boolean,
      rulePath: String,
      required: Boolean,
      showRequireMark: {
        type: Boolean,
        default: void 0
      },
      requireMarkPlacement: String,
      showFeedback: {
        type: Boolean,
        default: void 0
      },
      rule: [Object, Array],
      size: String,
      ignorePathChange: Boolean,
      validationStatus: String,
      feedback: String,
      feedbackClass: String,
      feedbackStyle: [String, Object],
      showLabel: {
        type: Boolean,
        default: void 0
      },
      labelProps: Object
    });
    function wrapValidator(validator, async) {
      return (...args) => {
        try {
          const validateResult = validator(...args);
          if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
            return validateResult;
          } else if (validateResult === void 0) {
            return true;
          } else {
            warn("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
            return true;
          }
        } catch (err) {
          warn("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
          console.error(err);
          return void 0;
        }
      };
    }
    const NFormItem = /* @__PURE__ */ defineComponent({
      name: "FormItem",
      props: formItemProps,
      setup(props) {
        useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", toRef(props, "path"));
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const NForm2 = inject(formInjectionKey, null);
        const formItemSizeRefs = formItemSize(props);
        const formItemMiscRefs = formItemMisc(props);
        const {
          validationErrored: validationErroredRef,
          validationWarned: validationWarnedRef
        } = formItemMiscRefs;
        const {
          mergedRequired: mergedRequiredRef,
          mergedRules: mergedRulesRef
        } = formItemRule(props);
        const {
          mergedSize: mergedSizeRef
        } = formItemSizeRefs;
        const {
          mergedLabelPlacement: labelPlacementRef,
          mergedLabelAlign: labelTextAlignRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
        } = formItemMiscRefs;
        const renderExplainsRef = ref([]);
        const feedbackIdRef = ref(createId());
        const mergedDisabledRef = NForm2 ? toRef(NForm2.props, "disabled") : ref(false);
        const themeRef = useTheme("Form", "-form-item", style$2, formLight, props, mergedClsPrefixRef);
        watch(toRef(props, "path"), () => {
          if (props.ignorePathChange) return;
          restoreValidation();
        });
        function restoreValidation() {
          renderExplainsRef.value = [];
          validationErroredRef.value = false;
          validationWarnedRef.value = false;
          if (props.feedback) {
            feedbackIdRef.value = createId();
          }
        }
        const internalValidate = (...args_1) => __awaiter(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
          suppressWarning: true
        }) {
          const {
            path
          } = props;
          if (!options) {
            options = {};
          } else {
            if (!options.first) options.first = props.first;
          }
          const {
            value: rules2
          } = mergedRulesRef;
          const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
          const messageRenderers = {};
          const originalMessageRendersMessage = {};
          const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          })).filter(shouldRuleBeApplied).map((rule, i2) => {
            const shallowClonedRule = Object.assign({}, rule);
            if (shallowClonedRule.validator) {
              shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
            }
            if (shallowClonedRule.asyncValidator) {
              shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
            }
            if (shallowClonedRule.renderMessage) {
              const rendererKey = `__renderMessage__${i2}`;
              originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
              shallowClonedRule.message = rendererKey;
              messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
            }
            return shallowClonedRule;
          });
          const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
          const activeWarningRules = activeRules.filter((r) => r.level === "warning");
          const validationResult = {
            valid: true,
            errors: void 0,
            warnings: void 0
          };
          if (!activeRules.length) return validationResult;
          const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
          const validator = new Schema$1({
            [mergedPath]: activeErrorRules
          });
          const warningValidator = new Schema$1({
            [mergedPath]: activeWarningRules
          });
          const {
            validateMessages
          } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
          if (validateMessages) {
            validator.messages(validateMessages);
            warningValidator.messages(validateMessages);
          }
          const renderMessages = (errors) => {
            renderExplainsRef.value = errors.map((error) => {
              const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
              return {
                key: transformedMessage,
                render: () => {
                  if (transformedMessage.startsWith("__renderMessage__")) {
                    return messageRenderers[transformedMessage]();
                  }
                  return transformedMessage;
                }
              };
            });
            errors.forEach((error) => {
              var _a2;
              if ((_a2 = error.message) === null || _a2 === void 0 ? void 0 : _a2.startsWith("__renderMessage__")) {
                error.message = originalMessageRendersMessage[error.message];
              }
            });
          };
          if (activeErrorRules.length) {
            const errors = yield new Promise((resolve2) => {
              void validator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (errors === null || errors === void 0 ? void 0 : errors.length) {
              validationResult.valid = false;
              validationResult.errors = errors;
              renderMessages(errors);
            }
          }
          if (activeWarningRules.length && !validationResult.errors) {
            const warnings = yield new Promise((resolve2) => {
              void warningValidator.validate({
                [mergedPath]: value
              }, options, resolve2);
            });
            if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
              renderMessages(warnings);
              validationResult.warnings = warnings;
            }
          }
          if (!validationResult.errors && !validationResult.warnings) {
            restoreValidation();
          } else {
            validationErroredRef.value = !!validationResult.errors;
            validationWarnedRef.value = !!validationResult.warnings;
          }
          return validationResult;
        });
        function handleContentBlur() {
          void internalValidate("blur");
        }
        function handleContentChange() {
          void internalValidate("change");
        }
        function handleContentFocus() {
          void internalValidate("focus");
        }
        function handleContentInput() {
          void internalValidate("input");
        }
        function validate(options, callback) {
          return __awaiter(this, void 0, void 0, function* () {
            let trigger2;
            let validateCallback;
            let shouldRuleBeApplied;
            let asyncValidatorOptions;
            if (typeof options === "string") {
              trigger2 = options;
              validateCallback = callback;
            } else if (options !== null && typeof options === "object") {
              trigger2 = options.trigger;
              validateCallback = options.callback;
              shouldRuleBeApplied = options.shouldRuleBeApplied;
              asyncValidatorOptions = options.options;
            }
            return yield new Promise((resolve2, reject) => {
              void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
                valid,
                errors,
                warnings
              }) => {
                if (valid) {
                  if (validateCallback) {
                    validateCallback(void 0, {
                      warnings
                    });
                  }
                  resolve2({
                    warnings
                  });
                } else {
                  if (validateCallback) {
                    validateCallback(errors, {
                      warnings
                    });
                  }
                  reject(errors);
                }
              });
            });
          });
        }
        provide(formItemInjectionKey, {
          path: toRef(props, "path"),
          disabled: mergedDisabledRef,
          mergedSize: formItemSizeRefs.mergedSize,
          mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
          restoreValidation,
          handleContentBlur,
          handleContentChange,
          handleContentFocus,
          handleContentInput
        });
        const exposedRef = {
          validate,
          restoreValidation,
          internalValidate
        };
        const labelElementRef = ref(null);
        onMounted(() => {
          if (!formItemMiscRefs.isAutoLabelWidth.value) return;
          const labelElement = labelElementRef.value;
          if (labelElement !== null) {
            const memoizedWhitespace = labelElement.style.whiteSpace;
            labelElement.style.whiteSpace = "nowrap";
            labelElement.style.width = "";
            NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
            labelElement.style.whiteSpace = memoizedWhitespace;
          }
        });
        const cssVarsRef = computed(() => {
          var _a2;
          const {
            value: size2
          } = mergedSizeRef;
          const {
            value: labelPlacement
          } = labelPlacementRef;
          const direction = labelPlacement === "top" ? "vertical" : "horizontal";
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              labelTextColor,
              asteriskColor,
              lineHeight: lineHeight2,
              feedbackTextColor,
              feedbackTextColorWarning,
              feedbackTextColorError,
              feedbackPadding,
              labelFontWeight,
              [createKey$1("labelHeight", size2)]: labelHeight,
              [createKey$1("blankHeight", size2)]: blankHeight,
              [createKey$1("feedbackFontSize", size2)]: feedbackFontSize,
              [createKey$1("feedbackHeight", size2)]: feedbackHeight,
              [createKey$1("labelPadding", direction)]: labelPadding,
              [createKey$1("labelTextAlign", direction)]: labelTextAlign,
              [createKey$1(createKey$1("labelFontSize", labelPlacement), size2)]: labelFontSize
            }
          } = themeRef.value;
          let mergedLabelTextAlign = (_a2 = labelTextAlignRef.value) !== null && _a2 !== void 0 ? _a2 : labelTextAlign;
          if (labelPlacement === "top") {
            mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
          }
          const cssVars = {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-line-height": lineHeight2,
            "--n-blank-height": blankHeight,
            "--n-label-font-size": labelFontSize,
            "--n-label-text-align": mergedLabelTextAlign,
            "--n-label-height": labelHeight,
            "--n-label-padding": labelPadding,
            "--n-label-font-weight": labelFontWeight,
            "--n-asterisk-color": asteriskColor,
            "--n-label-text-color": labelTextColor,
            "--n-feedback-padding": feedbackPadding,
            "--n-feedback-font-size": feedbackFontSize,
            "--n-feedback-height": feedbackHeight,
            "--n-feedback-text-color": feedbackTextColor,
            "--n-feedback-text-color-warning": feedbackTextColorWarning,
            "--n-feedback-text-color-error": feedbackTextColorError
          };
          return cssVars;
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", computed(() => {
          var _a2;
          return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a2 = labelTextAlignRef.value) === null || _a2 === void 0 ? void 0 : _a2[0]) || ""}`;
        }), cssVarsRef, props) : void 0;
        const reverseColSpaceRef = computed(() => {
          return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
        });
        return Object.assign(Object.assign(Object.assign(Object.assign({
          labelElementRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedRequired: mergedRequiredRef,
          feedbackId: feedbackIdRef,
          renderExplains: renderExplainsRef,
          reverseColSpace: reverseColSpaceRef
        }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        });
      },
      render() {
        const {
          $slots,
          mergedClsPrefix,
          mergedShowLabel,
          mergedShowRequireMark,
          mergedRequireMarkPlacement,
          onRender
        } = this;
        const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const renderLabel = () => {
          const labelText = this.$slots.label ? this.$slots.label() : this.label;
          if (!labelText) return null;
          const textNode = h("span", {
            class: `${mergedClsPrefix}-form-item-label__text`
          }, labelText);
          const markNode = renderedShowRequireMark ? h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk`
          }, mergedRequireMarkPlacement !== "left" ? "*" : "*") : mergedRequireMarkPlacement === "right-hanging" && h("span", {
            class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
          }, "*");
          const {
            labelProps
          } = this;
          return h("label", Object.assign({}, labelProps, {
            class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
            style: this.mergedLabelStyle,
            ref: "labelElementRef"
          }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
        };
        return h("div", {
          class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
          style: this.cssVars
        }, mergedShowLabel && renderLabel(), h("div", {
          class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]
        }, $slots), this.mergedShowFeedback ? h("div", {
          key: this.feedbackId,
          style: this.feedbackStyle,
          class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
        }, h(Transition, {
          name: "fade-down-transition",
          mode: "out-in"
        }, {
          default: () => {
            const {
              mergedValidationStatus
            } = this;
            return resolveWrappedSlot($slots.feedback, (children) => {
              var _a2;
              const {
                feedback
              } = this;
              const feedbackNodes = children || feedback ? h("div", {
                key: "__feedback__",
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, children || feedback) : this.renderExplains.length ? (_a2 = this.renderExplains) === null || _a2 === void 0 ? void 0 : _a2.map(({
                key,
                render: render2
              }) => h("div", {
                key,
                class: `${mergedClsPrefix}-form-item-feedback__line`
              }, render2())) : null;
              return feedbackNodes ? mergedValidationStatus === "warning" ? h("div", {
                key: "controlled-warning",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
              }, feedbackNodes) : mergedValidationStatus === "error" ? h("div", {
                key: "controlled-error",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
              }, feedbackNodes) : mergedValidationStatus === "success" ? h("div", {
                key: "controlled-success",
                class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
              }, feedbackNodes) : h("div", {
                key: "controlled-default",
                class: `${mergedClsPrefix}-form-item-feedback`
              }, feedbackNodes) : null;
            });
          }
        })) : null);
      }
    });
    function self$3(vars) {
      const {
        primaryColor,
        baseColor
      } = vars;
      return {
        color: primaryColor,
        iconColor: baseColor
      };
    }
    const iconDark = {
      name: "IconWrapper",
      common: derived$1,
      self: self$3
    };
    const imageDark = {
      name: "Image",
      common: derived$1,
      peers: {
        Tooltip: tooltipDark
      },
      self: (vars) => {
        const {
          textColor2
        } = vars;
        return {
          toolbarIconColor: textColor2,
          toolbarColor: "rgba(0, 0, 0, .35)",
          toolbarBoxShadow: "none",
          toolbarBorderRadius: "24px"
        };
      }
    };
    const commonVariables = {
      extraFontSize: "12px",
      width: "440px"
    };
    const transferDark = {
      name: "Transfer",
      common: derived$1,
      peers: {
        Checkbox: checkboxDark,
        Scrollbar: scrollbarDark,
        Input: inputDark,
        Empty: emptyDark,
        Button: buttonDark
      },
      self(vars) {
        const {
          iconColorDisabled,
          iconColor,
          fontWeight,
          fontSizeLarge,
          fontSizeMedium,
          fontSizeSmall,
          heightLarge,
          heightMedium,
          heightSmall,
          borderRadius,
          inputColor,
          tableHeaderColor,
          textColor1,
          textColorDisabled,
          textColor2,
          hoverColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          itemHeightSmall: heightSmall,
          itemHeightMedium: heightMedium,
          itemHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor: "#0000",
          listColor: inputColor,
          headerColor: tableHeaderColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          extraTextColor: textColor2,
          filterDividerColor: "#0000",
          itemTextColor: textColor2,
          itemTextColorDisabled: textColorDisabled,
          itemColorPending: hoverColor,
          titleFontWeight: fontWeight,
          iconColor,
          iconColorDisabled
        });
      }
    };
    function self$2() {
      return {};
    }
    const marqueeDark = {
      name: "Marquee",
      common: derived$1,
      self: self$2
    };
    const qrcodeDark = {
      name: "QrCode",
      common: derived$1,
      self: (vars) => {
        return {
          borderRadius: vars.borderRadius
        };
      }
    };
    const skeletonDark = {
      name: "Skeleton",
      common: derived$1,
      self(vars) {
        const {
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius
        } = vars;
        return {
          color: "rgba(255, 255, 255, 0.12)",
          colorEnd: "rgba(255, 255, 255, 0.18)",
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
        };
      }
    };
    const splitDark = {
      name: "Split",
      common: derived$1
    };
    const style$1 = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE$1("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE$1("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE$1("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
      left: "50%",
      top: "50%",
      originalTransform: "translateX(-50%) translateY(-50%)"
    })]), cE$1("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE$1("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE$1("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c("&:focus", [cE$1("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM("round", [cE$1("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE$1("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM("rubber-band", [cM("pressed", [cE$1("rail", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cE$1("rail", [c("&:active", [cE$1("button", "max-width: var(--n-button-width-pressed);")])]), cM("active", [cM("pressed", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE$1("rail", [c("&:active", [cE$1("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM("active", [cE$1("rail", [cE$1("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE$1("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE$1("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE$1("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM("active", [cE$1("rail", "background-color: var(--n-rail-color-active);")]), cM("loading", [cE$1("rail", `
 cursor: wait;
 `)]), cM("disabled", [cE$1("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
    const switchProps = Object.assign(Object.assign({}, useTheme.props), {
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      loading: Boolean,
      defaultValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      round: {
        type: Boolean,
        default: true
      },
      "onUpdate:value": [Function, Array],
      onUpdateValue: [Function, Array],
      checkedValue: {
        type: [String, Number, Boolean],
        default: true
      },
      uncheckedValue: {
        type: [String, Number, Boolean],
        default: false
      },
      railStyle: Function,
      rubberBand: {
        type: Boolean,
        default: true
      },
      /** @deprecated */
      onChange: [Function, Array]
    });
    let supportCssMax;
    const NSwitch = /* @__PURE__ */ defineComponent({
      name: "Switch",
      props: switchProps,
      slots: Object,
      setup(props) {
        if (supportCssMax === void 0) {
          if (typeof CSS !== "undefined") {
            if (typeof CSS.supports !== "undefined") {
              supportCssMax = CSS.supports("width", "max(1px)");
            } else {
              supportCssMax = false;
            }
          } else {
            supportCssMax = true;
          }
        }
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Switch", "-switch", style$1, switchLight, props, mergedClsPrefixRef);
        const formItem = useFormItem(props);
        const {
          mergedSizeRef,
          mergedDisabledRef
        } = formItem;
        const uncontrolledValueRef = ref(props.defaultValue);
        const controlledValueRef = toRef(props, "value");
        const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
        const checkedRef = computed(() => {
          return mergedValueRef.value === props.checkedValue;
        });
        const pressedRef = ref(false);
        const focusedRef = ref(false);
        const mergedRailStyleRef = computed(() => {
          const {
            railStyle
          } = props;
          if (!railStyle) return void 0;
          return railStyle({
            focused: focusedRef.value,
            checked: checkedRef.value
          });
        });
        function doUpdateValue(value) {
          const {
            "onUpdate:value": _onUpdateValue,
            onChange,
            onUpdateValue
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          if (_onUpdateValue) call(_onUpdateValue, value);
          if (onUpdateValue) call(onUpdateValue, value);
          if (onChange) call(onChange, value);
          uncontrolledValueRef.value = value;
          nTriggerFormInput();
          nTriggerFormChange();
        }
        function doFocus() {
          const {
            nTriggerFormFocus
          } = formItem;
          nTriggerFormFocus();
        }
        function doBlur() {
          const {
            nTriggerFormBlur
          } = formItem;
          nTriggerFormBlur();
        }
        function handleClick() {
          if (props.loading || mergedDisabledRef.value) return;
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
        }
        function handleFocus() {
          focusedRef.value = true;
          doFocus();
        }
        function handleBlur() {
          focusedRef.value = false;
          doBlur();
          pressedRef.value = false;
        }
        function handleKeyup(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
            pressedRef.value = false;
          }
        }
        function handleKeydown(e) {
          if (props.loading || mergedDisabledRef.value) return;
          if (e.key === " ") {
            e.preventDefault();
            pressedRef.value = true;
          }
        }
        const cssVarsRef = computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            self: {
              opacityDisabled,
              railColor,
              railColorActive,
              buttonBoxShadow,
              buttonColor,
              boxShadowFocus,
              loadingColor,
              textColor,
              iconColor,
              [createKey$1("buttonHeight", size2)]: buttonHeight,
              [createKey$1("buttonWidth", size2)]: buttonWidth,
              [createKey$1("buttonWidthPressed", size2)]: buttonWidthPressed,
              [createKey$1("railHeight", size2)]: railHeight,
              [createKey$1("railWidth", size2)]: railWidth,
              [createKey$1("railBorderRadius", size2)]: railBorderRadius,
              [createKey$1("buttonBorderRadius", size2)]: buttonBorderRadius
            },
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            }
          } = themeRef.value;
          let offset;
          let height;
          let width;
          if (supportCssMax) {
            offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
            height = `max(${railHeight}, ${buttonHeight})`;
            width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
          } else {
            offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
            height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
            width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
          }
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-button-border-radius": buttonBorderRadius,
            "--n-button-box-shadow": buttonBoxShadow,
            "--n-button-color": buttonColor,
            "--n-button-width": buttonWidth,
            "--n-button-width-pressed": buttonWidthPressed,
            "--n-button-height": buttonHeight,
            "--n-height": height,
            "--n-offset": offset,
            "--n-opacity-disabled": opacityDisabled,
            "--n-rail-border-radius": railBorderRadius,
            "--n-rail-color": railColor,
            "--n-rail-color-active": railColorActive,
            "--n-rail-height": railHeight,
            "--n-rail-width": railWidth,
            "--n-width": width,
            "--n-box-shadow-focus": boxShadowFocus,
            "--n-loading-color": loadingColor,
            "--n-text-color": textColor,
            "--n-icon-color": iconColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", computed(() => {
          return mergedSizeRef.value[0];
        }), cssVarsRef, props) : void 0;
        return {
          handleClick,
          handleBlur,
          handleFocus,
          handleKeyup,
          handleKeydown,
          mergedRailStyle: mergedRailStyleRef,
          pressed: pressedRef,
          mergedClsPrefix: mergedClsPrefixRef,
          mergedValue: mergedValueRef,
          checked: checkedRef,
          mergedDisabled: mergedDisabledRef,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        };
      },
      render() {
        const {
          mergedClsPrefix,
          mergedDisabled,
          checked,
          mergedRailStyle,
          onRender,
          $slots
        } = this;
        onRender === null || onRender === void 0 ? void 0 : onRender();
        const {
          checked: checkedSlot,
          unchecked: uncheckedSlot,
          icon: iconSlot,
          "checked-icon": checkedIconSlot,
          "unchecked-icon": uncheckedIconSlot
        } = $slots;
        const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
        return h("div", {
          role: "switch",
          "aria-checked": checked,
          class: [`${mergedClsPrefix}-switch`, this.themeClass, hasIcon && `${mergedClsPrefix}-switch--icon`, checked && `${mergedClsPrefix}-switch--active`, mergedDisabled && `${mergedClsPrefix}-switch--disabled`, this.round && `${mergedClsPrefix}-switch--round`, this.loading && `${mergedClsPrefix}-switch--loading`, this.pressed && `${mergedClsPrefix}-switch--pressed`, this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`],
          tabindex: !this.mergedDisabled ? 0 : void 0,
          style: this.cssVars,
          onClick: this.handleClick,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur,
          onKeyup: this.handleKeyup,
          onKeydown: this.handleKeydown
        }, h("div", {
          class: `${mergedClsPrefix}-switch__rail`,
          "aria-hidden": "true",
          style: mergedRailStyle
        }, resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
          if (checkedSlotChildren || uncheckedSlotChildren) {
            return h("div", {
              "aria-hidden": true,
              class: `${mergedClsPrefix}-switch__children-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), checkedSlotChildren), h("div", {
              class: `${mergedClsPrefix}-switch__rail-placeholder`
            }, h("div", {
              class: `${mergedClsPrefix}-switch__button-placeholder`
            }), uncheckedSlotChildren));
          }
          return null;
        })), h("div", {
          class: `${mergedClsPrefix}-switch__button`
        }, resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
          return h(NIconSwitchTransition, null, {
            default: () => this.loading ? h(NBaseLoading, {
              key: "loading",
              clsPrefix: mergedClsPrefix,
              strokeWidth: 20
            }) : this.checked && (checkedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: checkedIcon ? "checked-icon" : "icon"
            }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? h("div", {
              class: `${mergedClsPrefix}-switch__button-icon`,
              key: uncheckedIcon ? "unchecked-icon" : "icon"
            }, uncheckedIcon || icon) : null
          });
        }))), resolveWrappedSlot(checkedSlot, (children) => children && h("div", {
          key: "checked",
          class: `${mergedClsPrefix}-switch__checked`
        }, children)), resolveWrappedSlot(uncheckedSlot, (children) => children && h("div", {
          key: "unchecked",
          class: `${mergedClsPrefix}-switch__unchecked`
        }, children)))));
      }
    });
    const self$1 = () => ({});
    const equationDark = {
      name: "Equation",
      common: derived$1,
      self: self$1
    };
    const floatButtonGroupDark = {
      name: "FloatButtonGroup",
      common: derived$1,
      self(vars) {
        const {
          popoverColor,
          dividerColor,
          borderRadius
        } = vars;
        return {
          color: popoverColor,
          buttonBorderColor: dividerColor,
          borderRadiusSquare: borderRadius,
          boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)"
        };
      }
    };
    const darkTheme = {
      name: "dark",
      common: derived$1,
      Alert: alertDark,
      Anchor: anchorDark,
      AutoComplete: autoCompleteDark,
      Avatar: avatarDark,
      AvatarGroup: avatarGroupDark,
      BackTop: backTopDark,
      Badge: badgeDark,
      Breadcrumb: breadcrumbDark,
      Button: buttonDark,
      ButtonGroup: buttonGroupDark,
      Calendar: calendarDark,
      Card: cardDark,
      Carousel: carouselDark,
      Cascader: cascaderDark,
      Checkbox: checkboxDark,
      Code: codeDark,
      Collapse: collapseDark,
      CollapseTransition: collapseTransitionDark,
      ColorPicker: colorPickerDark,
      DataTable: dataTableDark,
      DatePicker: datePickerDark,
      Descriptions: descriptionsDark,
      Dialog: dialogDark,
      Divider: dividerDark,
      Drawer: drawerDark,
      Dropdown: dropdownDark,
      DynamicInput: dynamicInputDark,
      DynamicTags: dynamicTagsDark,
      Element: elementDark,
      Empty: emptyDark,
      Ellipsis: ellipsisDark,
      Equation: equationDark,
      Flex: flexDark,
      Form: formItemDark,
      GradientText: gradientTextDark,
      Icon: iconDark$1,
      IconWrapper: iconDark,
      Image: imageDark,
      Input: inputDark,
      InputNumber: inputNumberDark,
      LegacyTransfer: transferDark,
      Layout: layoutDark,
      List: listDark$1,
      LoadingBar: loadingBarDark,
      Log: logDark,
      Menu: menuDark,
      Mention: listDark,
      Message: messageDark,
      Modal: modalDark,
      Notification: notificationDark,
      PageHeader: pageHeaderDark,
      Pagination: paginationDark,
      Popconfirm: popconfirmDark,
      Popover: popoverDark,
      Popselect: popselect,
      Progress: progressDark,
      QrCode: qrcodeDark,
      Radio: radioDark,
      Rate: rateDark,
      Result: resultDark,
      Row: rowDark,
      Scrollbar: scrollbarDark,
      Select: selectDark,
      Skeleton: skeletonDark,
      Slider: sliderDark,
      Space: spaceDark,
      Spin: spinDark,
      Statistic: statisticDark,
      Steps: stepsDark,
      Switch: switchDark,
      Table: tableDark,
      Tabs: tabsDark,
      Tag: tagDark,
      Thing: thingDark,
      TimePicker: timePickerDark,
      Timeline: timelineDark,
      Tooltip: tooltipDark,
      Transfer: transferDark$1,
      Tree: treeDark,
      TreeSelect: treeSelectDark,
      Typography: typographyDark,
      Upload: uploadDark,
      Watermark: watermarkDark,
      Split: splitDark,
      FloatButton: floatButtonDark,
      FloatButtonGroup: floatButtonGroupDark,
      Marquee: marqueeDark
    };
    const _imports_0 = "/yiitap/logo.png";
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i2 = 0; i2 < this.content.length; i2 += 2)
          if (this.content[i2] === key) return i2;
        return -1;
      },
      // :: (string)  ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found2 = this.find(key);
        return found2 == -1 ? void 0 : this.content[found2 + 1];
      },
      // :: (string, any, ?string)  OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found2 = self2.find(key), content = self2.content.slice();
        if (found2 == -1) {
          content.push(newKey || key, value);
        } else {
          content[found2 + 1] = value;
          if (newKey) content[found2] = newKey;
        }
        return new OrderedMap(content);
      },
      // :: (string)  OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found2 = this.find(key);
        if (found2 == -1) return this;
        var content = this.content.slice();
        content.splice(found2, 2);
        return new OrderedMap(content);
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      // :: (string, string, any)  OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found2 = without.find(place);
        content.splice(found2 == -1 ? content.length : found2, 0, key, value);
        return new OrderedMap(content);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i2 = 0; i2 < this.content.length; i2 += 2)
          f(this.content[i2], this.content[i2 + 1]);
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(map.content.concat(this.subtract(map).content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(this.subtract(map).content.concat(map.content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i2 = 0; i2 < map.content.length; i2 += 2)
          result = result.remove(map.content[i2]);
        return result;
      },
      // :: ()  Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var result = {};
        this.forEach(function(key, value) {
          result[key] = value;
        });
        return result;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value;
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    function findDiffStart(a, b, pos) {
      for (let i2 = 0; ; i2++) {
        if (i2 == a.childCount || i2 == b.childCount)
          return a.childCount == b.childCount ? null : pos;
        let childA = a.child(i2), childB = b.child(i2);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return pos;
        if (childA.isText && childA.text != childB.text) {
          for (let j = 0; childA.text[j] == childB.text[j]; j++)
            pos++;
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          let inner = findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null)
            return inner;
        }
        pos += childA.nodeSize;
      }
    }
    function findDiffEnd(a, b, posA, posB) {
      for (let iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0)
          return iA == iB ? null : { a: posA, b: posB };
        let childA = a.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
        if (childA == childB) {
          posA -= size2;
          posB -= size2;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return { a: posA, b: posB };
        if (childA.isText && childA.text != childB.text) {
          let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return { a: posA, b: posB };
        }
        if (childA.content.size || childB.content.size) {
          let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner)
            return inner;
        }
        posA -= size2;
        posB -= size2;
      }
    }
    class Fragment {
      /**
      @internal
      */
      constructor(content, size2) {
        this.content = content;
        this.size = size2 || 0;
        if (size2 == null)
          for (let i2 = 0; i2 < content.length; i2++)
            this.size += content[i2].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(from, to2, f, nodeStart = 0, parent) {
        for (let i2 = 0, pos = 0; pos < to2; i2++) {
          let child = this.content[i2], end = pos + child.nodeSize;
          if (end > from && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
            let start = pos + 1;
            child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to2 - start), f, nodeStart + start);
          }
          pos = end;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(f) {
        this.nodesBetween(0, this.size, f);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(from, to2, blockSeparator, leafText) {
        let text = "", first2 = true;
        this.nodesBetween(from, to2, (node, pos) => {
          let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to2 - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
          if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
            if (first2)
              first2 = false;
            else
              text += blockSeparator;
          }
          text += nodeText;
        }, 0);
        return text;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(other) {
        if (!other.size)
          return this;
        if (!this.size)
          return other;
        let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i2 = 0;
        if (last.isText && last.sameMarkup(first2)) {
          content[content.length - 1] = last.withText(last.text + first2.text);
          i2 = 1;
        }
        for (; i2 < other.content.length; i2++)
          content.push(other.content[i2]);
        return new Fragment(content, this.size + other.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(from, to2 = this.size) {
        if (from == 0 && to2 == this.size)
          return this;
        let result = [], size2 = 0;
        if (to2 > from)
          for (let i2 = 0, pos = 0; pos < to2; i2++) {
            let child = this.content[i2], end = pos + child.nodeSize;
            if (end > from) {
              if (pos < from || end > to2) {
                if (child.isText)
                  child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to2 - pos));
                else
                  child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to2 - pos - 1));
              }
              result.push(child);
              size2 += child.nodeSize;
            }
            pos = end;
          }
        return new Fragment(result, size2);
      }
      /**
      @internal
      */
      cutByIndex(from, to2) {
        if (from == to2)
          return Fragment.empty;
        if (from == 0 && to2 == this.content.length)
          return this;
        return new Fragment(this.content.slice(from, to2));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(index, node) {
        let current = this.content[index];
        if (current == node)
          return this;
        let copy2 = this.content.slice();
        let size2 = this.size + node.nodeSize - current.nodeSize;
        copy2[index] = node;
        return new Fragment(copy2, size2);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(node) {
        return new Fragment([node].concat(this.content), this.size + node.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(node) {
        return new Fragment(this.content.concat(node), this.size + node.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(other) {
        if (this.content.length != other.content.length)
          return false;
        for (let i2 = 0; i2 < this.content.length; i2++)
          if (!this.content[i2].eq(other.content[i2]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(index) {
        let found2 = this.content[index];
        if (!found2)
          throw new RangeError("Index " + index + " out of range for " + this);
        return found2;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content[index] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        for (let i2 = 0, p2 = 0; i2 < this.content.length; i2++) {
          let child = this.content[i2];
          f(child, p2, i2);
          p2 += child.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(other, pos = 0) {
        return findDiffStart(this, other, pos);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(other, pos = this.size, otherPos = other.size) {
        return findDiffEnd(this, other, pos, otherPos);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(pos, round = -1) {
        if (pos == 0)
          return retIndex(0, pos);
        if (pos == this.size)
          return retIndex(this.content.length, pos);
        if (pos > this.size || pos < 0)
          throw new RangeError(`Position ${pos} outside of fragment (${this})`);
        for (let i2 = 0, curPos = 0; ; i2++) {
          let cur = this.child(i2), end = curPos + cur.nodeSize;
          if (end >= pos) {
            if (end == pos || round > 0)
              return retIndex(i2 + 1, end);
            return retIndex(i2, curPos);
          }
          curPos = end;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((n) => n.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(schema, value) {
        if (!value)
          return Fragment.empty;
        if (!Array.isArray(value))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new Fragment(value.map(schema.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(array) {
        if (!array.length)
          return Fragment.empty;
        let joined, size2 = 0;
        for (let i2 = 0; i2 < array.length; i2++) {
          let node = array[i2];
          size2 += node.nodeSize;
          if (i2 && node.isText && array[i2 - 1].sameMarkup(node)) {
            if (!joined)
              joined = array.slice(0, i2);
            joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
          } else if (joined) {
            joined.push(node);
          }
        }
        return new Fragment(joined || array, size2);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(nodes) {
        if (!nodes)
          return Fragment.empty;
        if (nodes instanceof Fragment)
          return nodes;
        if (Array.isArray(nodes))
          return this.fromArray(nodes);
        if (nodes.attrs)
          return new Fragment([nodes], nodes.nodeSize);
        throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }
    Fragment.empty = new Fragment([], 0);
    const found = { index: 0, offset: 0 };
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found;
    }
    function compareDeep(a, b) {
      if (a === b)
        return true;
      if (!(a && typeof a == "object") || !(b && typeof b == "object"))
        return false;
      let array = Array.isArray(a);
      if (Array.isArray(b) != array)
        return false;
      if (array) {
        if (a.length != b.length)
          return false;
        for (let i2 = 0; i2 < a.length; i2++)
          if (!compareDeep(a[i2], b[i2]))
            return false;
      } else {
        for (let p2 in a)
          if (!(p2 in b) || !compareDeep(a[p2], b[p2]))
            return false;
        for (let p2 in b)
          if (!(p2 in a))
            return false;
      }
      return true;
    }
    let Mark$1 = class Mark2 {
      /**
      @internal
      */
      constructor(type, attrs) {
        this.type = type;
        this.attrs = attrs;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(set) {
        let copy2, placed = false;
        for (let i2 = 0; i2 < set.length; i2++) {
          let other = set[i2];
          if (this.eq(other))
            return set;
          if (this.type.excludes(other.type)) {
            if (!copy2)
              copy2 = set.slice(0, i2);
          } else if (other.type.excludes(this.type)) {
            return set;
          } else {
            if (!placed && other.type.rank > this.type.rank) {
              if (!copy2)
                copy2 = set.slice(0, i2);
              copy2.push(this);
              placed = true;
            }
            if (copy2)
              copy2.push(other);
          }
        }
        if (!copy2)
          copy2 = set.slice();
        if (!placed)
          copy2.push(this);
        return copy2;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (this.eq(set[i2]))
            return set.slice(0, i2).concat(set.slice(i2 + 1));
        return set;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (this.eq(set[i2]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(other) {
        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        return obj;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(schema, json) {
        if (!json)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let type = schema.marks[json.type];
        if (!type)
          throw new RangeError(`There is no mark type ${json.type} in this schema`);
        let mark = type.create(json.attrs);
        type.checkAttrs(mark.attrs);
        return mark;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(a, b) {
        if (a == b)
          return true;
        if (a.length != b.length)
          return false;
        for (let i2 = 0; i2 < a.length; i2++)
          if (!a[i2].eq(b[i2]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(marks) {
        if (!marks || Array.isArray(marks) && marks.length == 0)
          return Mark2.none;
        if (marks instanceof Mark2)
          return [marks];
        let copy2 = marks.slice();
        copy2.sort((a, b) => a.type.rank - b.type.rank);
        return copy2;
      }
    };
    Mark$1.none = [];
    class ReplaceError extends Error {
    }
    class Slice {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragmenti.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(content, openStart, openEnd) {
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(pos, fragment) {
        let content = insertInto(this.content, pos + this.openStart, fragment);
        return content && new Slice(content, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(from, to2) {
        return new Slice(removeRange(this.content, from + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let json = { content: this.content.toJSON() };
        if (this.openStart > 0)
          json.openStart = this.openStart;
        if (this.openEnd > 0)
          json.openEnd = this.openEnd;
        return json;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(schema, json) {
        if (!json)
          return Slice.empty;
        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(fragment, openIsolating = true) {
        let openStart = 0, openEnd = 0;
        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
          openStart++;
        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
          openEnd++;
        return new Slice(fragment, openStart, openEnd);
      }
    }
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    function removeRange(content, from, to2) {
      let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
      let { index: indexTo, offset: offsetTo } = content.findIndex(to2);
      if (offset == from || child.isText) {
        if (offsetTo != to2 && !content.child(indexTo).isText)
          throw new RangeError("Removing non-flat range");
        return content.cut(0, from).append(content.cut(to2));
      }
      if (index != indexTo)
        throw new RangeError("Removing non-flat range");
      return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to2 - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      let inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index, child.copy(inner));
    }
    function replace($from, $to, slice) {
      if (slice.openStart > $from.depth)
        throw new ReplaceError("Inserted content deeper than insertion position");
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
        throw new ReplaceError("Inconsistent open depths");
      return replaceOuter($from, $to, slice, 0);
    }
    function replaceOuter($from, $to, slice, depth) {
      let index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        let inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
        let parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
      } else {
        let { start, end } = prepareSliceForReplace(slice, $from);
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type))
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
    }
    function joinable$1($before, $after, depth) {
      let node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      let last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last]))
        target[last] = child.withText(target[last].text + child.text);
      else
        target.push(child);
    }
    function addRange($start, $end, depth, target) {
      let node = ($end || $start).node(depth);
      let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (let i2 = startIndex; i2 < endIndex; i2++)
        addNode(node.child(i2), target);
      if ($end && $end.depth == depth && $end.textOffset)
        addNode($end.nodeBefore, target);
    }
    function close(node, content) {
      node.type.checkContent(content);
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
      let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
      let content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart)
          addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        addRange($start, $end, depth, content);
        if (openEnd)
          addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function replaceTwoWay($from, $to, depth) {
      let content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        let type = joinable$1($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function prepareSliceForReplace(slice, $along) {
      let extra = $along.depth - slice.openStart, parent = $along.node(extra);
      let node = parent.copy(slice.content);
      for (let i2 = extra - 1; i2 >= 0; i2--)
        node = $along.node(i2).copy(Fragment.from(node));
      return {
        start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
      };
    }
    class ResolvedPos {
      /**
      @internal
      */
      constructor(pos, path, parentOffset) {
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(val) {
        if (val == null)
          return this.depth;
        if (val < 0)
          return this.depth + val;
        return val;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parenttext nodes are flat in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(depth) {
        return this.path[this.resolveDepth(depth) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(depth) {
        return this.path[this.resolveDepth(depth) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position before the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position after the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let parent = this.parent, index = this.index(this.depth);
        if (index == parent.childCount)
          return null;
        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let index = this.index(this.depth);
        let dOff = this.pos - this.path[this.path.length - 1];
        if (dOff)
          return this.parent.child(index).cut(0, dOff);
        return index == 0 ? null : this.parent.child(index - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(index, depth) {
        depth = this.resolveDepth(depth);
        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        for (let i2 = 0; i2 < index; i2++)
          pos += node.child(i2).nodeSize;
        return pos;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let parent = this.parent, index = this.index();
        if (parent.content.size == 0)
          return Mark$1.none;
        if (this.textOffset)
          return parent.child(index).marks;
        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
        if (!main) {
          let tmp = main;
          main = other;
          other = tmp;
        }
        let marks = main.marks;
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross($end) {
        let after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline)
          return null;
        let marks = after.marks, next = $end.parent.maybeChild($end.index());
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(pos) {
        for (let depth = this.depth; depth > 0; depth--)
          if (this.start(depth) <= pos && this.end(depth) >= pos)
            return depth;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(other = this, pred) {
        if (other.pos < this.pos)
          return other.blockRange(this);
        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
          if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
            return new NodeRange(this, other, d);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(other) {
        return other.pos > this.pos ? other : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(other) {
        return other.pos < this.pos ? other : this;
      }
      /**
      @internal
      */
      toString() {
        let str = "";
        for (let i2 = 1; i2 <= this.depth; i2++)
          str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
        return str + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(doc2, pos) {
        if (!(pos >= 0 && pos <= doc2.content.size))
          throw new RangeError("Position " + pos + " out of range");
        let path = [];
        let start = 0, parentOffset = pos;
        for (let node = doc2; ; ) {
          let { index, offset } = node.content.findIndex(parentOffset);
          let rem = parentOffset - offset;
          path.push(node, index, start + offset);
          if (!rem)
            break;
          node = node.child(index);
          if (node.isText)
            break;
          parentOffset = rem - 1;
          start += offset + 1;
        }
        return new ResolvedPos(pos, path, parentOffset);
      }
      /**
      @internal
      */
      static resolveCached(doc2, pos) {
        let cache2 = resolveCache.get(doc2);
        if (cache2) {
          for (let i2 = 0; i2 < cache2.elts.length; i2++) {
            let elt = cache2.elts[i2];
            if (elt.pos == pos)
              return elt;
          }
        } else {
          resolveCache.set(doc2, cache2 = new ResolveCache());
        }
        let result = cache2.elts[cache2.i] = ResolvedPos.resolve(doc2, pos);
        cache2.i = (cache2.i + 1) % resolveCacheSize;
        return result;
      }
    }
    class ResolveCache {
      constructor() {
        this.elts = [];
        this.i = 0;
      }
    }
    const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
    class NodeRange {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor($from, $to, depth) {
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    }
    const emptyAttrs = /* @__PURE__ */ Object.create(null);
    let Node$1 = class Node2 {
      /**
      @internal
      */
      constructor(type, attrs, content, marks = Mark$1.none) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(index) {
        return this.content.child(index);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content.maybeChild(index);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        this.content.forEach(f);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(from, to2, f, startPos = 0) {
        this.content.nodesBetween(from, to2, f, startPos, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(f) {
        this.nodesBetween(0, this.content.size, f);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(from, to2, blockSeparator, leafText) {
        return this.content.textBetween(from, to2, blockSeparator, leafText);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(other) {
        return this == other || this.sameMarkup(other) && this.content.eq(other.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(type, attrs, marks) {
        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(content = null) {
        if (content == this.content)
          return this;
        return new Node2(this.type, this.attrs, content, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(marks) {
        return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(from, to2 = this.content.size) {
        if (from == 0 && to2 == this.content.size)
          return this;
        return this.copy(this.content.cut(from, to2));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(from, to2 = this.content.size, includeParents = false) {
        if (from == to2)
          return Slice.empty;
        let $from = this.resolve(from), $to = this.resolve(to2);
        let depth = includeParents ? 0 : $from.sharedDepth(to2);
        let start = $from.start(depth), node = $from.node(depth);
        let content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(from, to2, slice) {
        return replace(this.resolve(from), this.resolve(to2), slice);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(pos) {
        for (let node = this; ; ) {
          let { index, offset } = node.content.findIndex(pos);
          node = node.maybeChild(index);
          if (!node)
            return null;
          if (offset == pos || node.isText)
            return node;
          pos -= offset + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(pos) {
        let { index, offset } = this.content.findIndex(pos);
        return { node: this.content.maybeChild(index), index, offset };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(pos) {
        if (pos == 0)
          return { node: null, index: 0, offset: 0 };
        let { index, offset } = this.content.findIndex(pos);
        if (offset < pos)
          return { node: this.content.child(index), index, offset };
        let node = this.content.child(index - 1);
        return { node, index: index - 1, offset: offset - node.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(pos) {
        return ResolvedPos.resolveCached(this, pos);
      }
      /**
      @internal
      */
      resolveNoCache(pos) {
        return ResolvedPos.resolve(this, pos);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(from, to2, type) {
        let found2 = false;
        if (to2 > from)
          this.nodesBetween(from, to2, (node) => {
            if (type.isInSet(node.marks))
              found2 = true;
            return !found2;
          });
        return found2;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let name = this.type.name;
        if (this.content.size)
          name += "(" + this.content.toStringInner() + ")";
        return wrapMarks(this.marks, name);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(index) {
        let match = this.type.contentMatch.matchFragment(this.content, 0, index);
        if (!match)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return match;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(from, to2, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
        let two = one && one.matchFragment(this.content, to2);
        if (!two || !two.validEnd)
          return false;
        for (let i2 = start; i2 < end; i2++)
          if (!this.type.allowsMarks(replacement.child(i2).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(from, to2, type, marks) {
        if (marks && !this.type.allowsMarks(marks))
          return false;
        let start = this.contentMatchAt(from).matchType(type);
        let end = start && start.matchFragment(this.content, to2);
        return end ? end.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(other) {
        if (other.content.size)
          return this.canReplace(this.childCount, this.childCount, other.content);
        else
          return this.type.compatibleContent(other.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content);
        this.type.checkAttrs(this.attrs);
        let copy2 = Mark$1.none;
        for (let i2 = 0; i2 < this.marks.length; i2++) {
          let mark = this.marks[i2];
          mark.type.checkAttrs(mark.attrs);
          copy2 = mark.addToSet(copy2);
        }
        if (!Mark$1.sameSet(copy2, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
        this.content.forEach((node) => node.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        if (this.content.size)
          obj.content = this.content.toJSON();
        if (this.marks.length)
          obj.marks = this.marks.map((n) => n.toJSON());
        return obj;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(schema, json) {
        if (!json)
          throw new RangeError("Invalid input for Node.fromJSON");
        let marks = void 0;
        if (json.marks) {
          if (!Array.isArray(json.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          marks = json.marks.map(schema.markFromJSON);
        }
        if (json.type == "text") {
          if (typeof json.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return schema.text(json.text, marks);
        }
        let content = Fragment.fromJSON(schema, json.content);
        let node = schema.nodeType(json.type).create(json.attrs, content, marks);
        node.type.checkAttrs(node.attrs);
        return node;
      }
    };
    Node$1.prototype.text = void 0;
    class TextNode extends Node$1 {
      /**
      @internal
      */
      constructor(type, attrs, content, marks) {
        super(type, attrs, null, marks);
        if (!content)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = content;
      }
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        return wrapMarks(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(from, to2) {
        return this.text.slice(from, to2);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(marks) {
        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
      }
      withText(text) {
        if (text == this.text)
          return this;
        return new TextNode(this.type, this.attrs, text, this.marks);
      }
      cut(from = 0, to2 = this.text.length) {
        if (from == 0 && to2 == this.text.length)
          return this;
        return this.withText(this.text.slice(from, to2));
      }
      eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
      }
      toJSON() {
        let base2 = super.toJSON();
        base2.text = this.text;
        return base2;
      }
    }
    function wrapMarks(marks, str) {
      for (let i2 = marks.length - 1; i2 >= 0; i2--)
        str = marks[i2].type.name + "(" + str + ")";
      return str;
    }
    class ContentMatch {
      /**
      @internal
      */
      constructor(validEnd) {
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(string2, nodeTypes) {
        let stream = new TokenStream(string2, nodeTypes);
        if (stream.next == null)
          return ContentMatch.empty;
        let expr = parseExpr(stream);
        if (stream.next)
          stream.err("Unexpected trailing text");
        let match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(type) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          if (this.next[i2].type == type)
            return this.next[i2].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(frag, start = 0, end = frag.childCount) {
        let cur = this;
        for (let i2 = start; cur && i2 < end; i2++)
          cur = cur.matchType(frag.child(i2).type);
        return cur;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let i2 = 0; i2 < this.next.length; i2++) {
          let { type } = this.next[i2];
          if (!(type.isText || type.hasRequiredAttrs()))
            return type;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(other) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          for (let j = 0; j < other.next.length; j++)
            if (this.next[i2].type == other.next[j].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(after, toEnd = false, startIndex = 0) {
        let seen = [this];
        function search(match, types2) {
          let finished = match.matchFragment(after, startIndex);
          if (finished && (!toEnd || finished.validEnd))
            return Fragment.from(types2.map((tp2) => tp2.createAndFill()));
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
              seen.push(next);
              let found2 = search(next, types2.concat(type));
              if (found2)
                return found2;
            }
          }
          return null;
        }
        return search(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(target) {
        for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
          if (this.wrapCache[i2] == target)
            return this.wrapCache[i2 + 1];
        let computed2 = this.computeWrapping(target);
        this.wrapCache.push(target, computed2);
        return computed2;
      }
      /**
      @internal
      */
      computeWrapping(target) {
        let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
        while (active.length) {
          let current = active.shift(), match = current.match;
          if (match.matchType(target)) {
            let result = [];
            for (let obj = current; obj.type; obj = obj.via)
              result.push(obj.type);
            return result.reverse();
          }
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
              active.push({ match: type.contentMatch, type, via: current });
              seen[type.name] = true;
            }
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(n) {
        if (n >= this.next.length)
          throw new RangeError(`There's no ${n}th edge in this content match`);
        return this.next[n];
      }
      /**
      @internal
      */
      toString() {
        let seen = [];
        function scan(m) {
          seen.push(m);
          for (let i2 = 0; i2 < m.next.length; i2++)
            if (seen.indexOf(m.next[i2].next) == -1)
              scan(m.next[i2].next);
        }
        scan(this);
        return seen.map((m, i2) => {
          let out = i2 + (m.validEnd ? "*" : " ") + " ";
          for (let i3 = 0; i3 < m.next.length; i3++)
            out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
          return out;
        }).join("\n");
      }
    }
    ContentMatch.empty = new ContentMatch(true);
    class TokenStream {
      constructor(string2, nodeTypes) {
        this.string = string2;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string2.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
          this.tokens.pop();
        if (this.tokens[0] == "")
          this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(tok) {
        return this.next == tok && (this.pos++ || true);
      }
      err(str) {
        throw new SyntaxError(str + " (in content expression '" + this.string + "')");
      }
    }
    function parseExpr(stream) {
      let exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    }
    function parseExprSeq(stream) {
      let exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
    }
    function parseExprSubscript(stream) {
      let expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+"))
          expr = { type: "plus", expr };
        else if (stream.eat("*"))
          expr = { type: "star", expr };
        else if (stream.eat("?"))
          expr = { type: "opt", expr };
        else if (stream.eat("{"))
          expr = parseExprRange(stream, expr);
        else
          break;
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next))
        stream.err("Expected number, got '" + stream.next + "'");
      let result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      let min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}")
          max = parseNum(stream);
        else
          max = -1;
      }
      if (!stream.eat("}"))
        stream.err("Unclosed braced range");
      return { type: "range", min, max, expr };
    }
    function resolveName(stream, name) {
      let types2 = stream.nodeTypes, type = types2[name];
      if (type)
        return [type];
      let result = [];
      for (let typeName in types2) {
        let type3 = types2[typeName];
        if (type3.isInGroup(name))
          result.push(type3);
      }
      if (result.length == 0)
        stream.err("No node type or group '" + name + "' found");
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        let expr = parseExpr(stream);
        if (!stream.eat(")"))
          stream.err("Missing closing paren");
        return expr;
      } else if (!/\W/.test(stream.next)) {
        let exprs = resolveName(stream, stream.next).map((type) => {
          if (stream.inline == null)
            stream.inline = type.isInline;
          else if (stream.inline != type.isInline)
            stream.err("Mixing inline and block content");
          return { type: "name", value: type };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      let nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from, to2, term) {
        let edge2 = { term, to: to2 };
        nfa2[from].push(edge2);
        return edge2;
      }
      function connect(edges, to2) {
        edges.forEach((edge2) => edge2.to = to2);
      }
      function compile(expr2, from) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
        } else if (expr2.type == "seq") {
          for (let i2 = 0; ; i2++) {
            let next = compile(expr2.exprs[i2], from);
            if (i2 == expr2.exprs.length - 1)
              return next;
            connect(next, from = node());
          }
        } else if (expr2.type == "star") {
          let loop = node();
          edge(from, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          let loop = node();
          connect(compile(expr2.expr, from), loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "opt") {
          return [edge(from)].concat(compile(expr2.expr, from));
        } else if (expr2.type == "range") {
          let cur = from;
          for (let i2 = 0; i2 < expr2.min; i2++) {
            let next = node();
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (let i2 = expr2.min; i2 < expr2.max; i2++) {
              let next = node();
              edge(cur, next);
              connect(compile(expr2.expr, cur), next);
              cur = next;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from, void 0, expr2.value)];
        } else {
          throw new Error("Unknown expr type");
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      let result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        let edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term)
          return scan(edges[0].to);
        result.push(node2);
        for (let i2 = 0; i2 < edges.length; i2++) {
          let { term, to: to2 } = edges[i2];
          if (!term && result.indexOf(to2) == -1)
            scan(to2);
        }
      }
    }
    function dfa(nfa2) {
      let labeled = /* @__PURE__ */ Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        let out = [];
        states.forEach((node) => {
          nfa2[node].forEach(({ term, to: to2 }) => {
            if (!term)
              return;
            let set;
            for (let i2 = 0; i2 < out.length; i2++)
              if (out[i2][0] == term)
                set = out[i2][1];
            nullFrom(nfa2, to2).forEach((node2) => {
              if (!set)
                out.push([term, set = []]);
              if (set.indexOf(node2) == -1)
                set.push(node2);
            });
          });
        });
        let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (let i2 = 0; i2 < out.length; i2++) {
          let states2 = out[i2][1].sort(cmp);
          state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
        }
        return state;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
        let state = work[i2], dead = !state.validEnd, nodes = [];
        for (let j = 0; j < state.next.length; j++) {
          let { type, next } = state.next[j];
          nodes.push(type.name);
          if (dead && !(type.isText || type.hasRequiredAttrs()))
            dead = false;
          if (work.indexOf(next) == -1)
            work.push(next);
        }
        if (dead)
          stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function defaultAttrs(attrs) {
      let defaults = /* @__PURE__ */ Object.create(null);
      for (let attrName in attrs) {
        let attr = attrs[attrName];
        if (!attr.hasDefault)
          return null;
        defaults[attrName] = attr.default;
      }
      return defaults;
    }
    function computeAttrs(attrs, value) {
      let built = /* @__PURE__ */ Object.create(null);
      for (let name in attrs) {
        let given = value && value[name];
        if (given === void 0) {
          let attr = attrs[name];
          if (attr.hasDefault)
            given = attr.default;
          else
            throw new RangeError("No value supplied for attribute " + name);
        }
        built[name] = given;
      }
      return built;
    }
    function checkAttrs(attrs, values, type, name) {
      for (let name2 in values)
        if (!(name2 in attrs))
          throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
      for (let name2 in attrs) {
        let attr = attrs[name2];
        if (attr.validate)
          attr.validate(values[name2]);
      }
    }
    function initAttrs(typeName, attrs) {
      let result = /* @__PURE__ */ Object.create(null);
      if (attrs)
        for (let name in attrs)
          result[name] = new Attribute(typeName, name, attrs[name]);
      return result;
    }
    let NodeType$1 = class NodeType2 {
      /**
      @internal
      */
      constructor(name, schema, spec) {
        this.name = name;
        this.schema = schema;
        this.spec = spec;
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(name, spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == ContentMatch.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(group) {
        return this.groups.indexOf(group) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let n in this.attrs)
          if (this.attrs[n].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(other) {
        return this == other || this.contentMatch.compatible(other.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(attrs) {
        if (!attrs && this.defaultAttrs)
          return this.defaultAttrs;
        else
          return computeAttrs(this.attrs, attrs);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(attrs = null, content, marks) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(attrs = null, content, marks) {
        content = Fragment.from(content);
        this.checkContent(content);
        return new Node$1(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(attrs = null, content, marks) {
        attrs = this.computeAttrs(attrs);
        content = Fragment.from(content);
        if (content.size) {
          let before = this.contentMatch.fillBefore(content);
          if (!before)
            return null;
          content = before.append(content);
        }
        let matched = this.contentMatch.matchFragment(content);
        let after = matched && matched.fillBefore(Fragment.empty, true);
        if (!after)
          return null;
        return new Node$1(this, attrs, content.append(after), Mark$1.setFrom(marks));
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(content) {
        let result = this.contentMatch.matchFragment(content);
        if (!result || !result.validEnd)
          return false;
        for (let i2 = 0; i2 < content.childCount; i2++)
          if (!this.allowsMarks(content.child(i2).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(content) {
        if (!this.validContent(content))
          throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(markType) {
        return this.markSet == null || this.markSet.indexOf(markType) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(marks) {
        if (this.markSet == null)
          return true;
        for (let i2 = 0; i2 < marks.length; i2++)
          if (!this.allowsMarkType(marks[i2].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(marks) {
        if (this.markSet == null)
          return marks;
        let copy2;
        for (let i2 = 0; i2 < marks.length; i2++) {
          if (!this.allowsMarkType(marks[i2].type)) {
            if (!copy2)
              copy2 = marks.slice(0, i2);
          } else if (copy2) {
            copy2.push(marks[i2]);
          }
        }
        return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
      }
      /**
      @internal
      */
      static compile(nodes, schema) {
        let result = /* @__PURE__ */ Object.create(null);
        nodes.forEach((name, spec) => result[name] = new NodeType2(name, schema, spec));
        let topType = schema.spec.topNode || "doc";
        if (!result[topType])
          throw new RangeError("Schema is missing its top node type ('" + topType + "')");
        if (!result.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let _ in result.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return result;
      }
    };
    function validateType(typeName, attrName, type) {
      let types2 = type.split("|");
      return (value) => {
        let name = value === null ? "null" : typeof value;
        if (types2.indexOf(name) < 0)
          throw new RangeError(`Expected value of type ${types2} for attribute ${attrName} on type ${typeName}, got ${name}`);
      };
    }
    class Attribute {
      constructor(typeName, attrName, options) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this.default = options.default;
        this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    }
    class MarkType {
      /**
      @internal
      */
      constructor(name, rank, schema, spec) {
        this.name = name;
        this.rank = rank;
        this.schema = schema;
        this.spec = spec;
        this.attrs = initAttrs(name, spec.attrs);
        this.excluded = null;
        let defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark$1(this, defaults) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(attrs = null) {
        if (!attrs && this.instance)
          return this.instance;
        return new Mark$1(this, computeAttrs(this.attrs, attrs));
      }
      /**
      @internal
      */
      static compile(marks, schema) {
        let result = /* @__PURE__ */ Object.create(null), rank = 0;
        marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
        return result;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(set) {
        for (var i2 = 0; i2 < set.length; i2++)
          if (set[i2].type == this) {
            set = set.slice(0, i2).concat(set.slice(i2 + 1));
            i2--;
          }
        return set;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (set[i2].type == this)
            return set[i2];
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(other) {
        return this.excluded.indexOf(other) > -1;
      }
    }
    class Schema {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(spec) {
        this.linebreakReplacement = null;
        this.cached = /* @__PURE__ */ Object.create(null);
        let instanceSpec = this.spec = {};
        for (let prop in spec)
          instanceSpec[prop] = spec[prop];
        instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        let contentExprCache = /* @__PURE__ */ Object.create(null);
        for (let prop in this.nodes) {
          if (prop in this.marks)
            throw new RangeError(prop + " can not be both a node and a mark");
          let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
          type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
          type.inlineContent = type.contentMatch.inlineContent;
          if (type.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!type.isInline || !type.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = type;
          }
          type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (let prop in this.marks) {
          let type = this.marks[prop], excl = type.spec.excludes;
          type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this);
        this.markFromJSON = this.markFromJSON.bind(this);
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(type, attrs = null, content, marks) {
        if (typeof type == "string")
          type = this.nodeType(type);
        else if (!(type instanceof NodeType$1))
          throw new RangeError("Invalid node type: " + type);
        else if (type.schema != this)
          throw new RangeError("Node type from different schema used (" + type.name + ")");
        return type.createChecked(attrs, content, marks);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(text, marks) {
        let type = this.nodes.text;
        return new TextNode(type, type.defaultAttrs, text, Mark$1.setFrom(marks));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(type, attrs) {
        if (typeof type == "string")
          type = this.marks[type];
        return type.create(attrs);
      }
      /**
      Deserialize a node from its JSON representation. This method is
      bound.
      */
      nodeFromJSON(json) {
        return Node$1.fromJSON(this, json);
      }
      /**
      Deserialize a mark from its JSON representation. This method is
      bound.
      */
      markFromJSON(json) {
        return Mark$1.fromJSON(this, json);
      }
      /**
      @internal
      */
      nodeType(name) {
        let found2 = this.nodes[name];
        if (!found2)
          throw new RangeError("Unknown node type: " + name);
        return found2;
      }
    }
    function gatherMarks(schema, marks) {
      let found2 = [];
      for (let i2 = 0; i2 < marks.length; i2++) {
        let name = marks[i2], mark = schema.marks[name], ok2 = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (let prop in schema.marks) {
            let mark2 = schema.marks[prop];
            if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
              found2.push(ok2 = mark2);
          }
        }
        if (!ok2)
          throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
      }
      return found2;
    }
    function isTagRule(rule) {
      return rule.tag != null;
    }
    function isStyleRule(rule) {
      return rule.style != null;
    }
    let DOMParser$1 = class DOMParser2 {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(schema, rules2) {
        this.schema = schema;
        this.rules = rules2;
        this.tags = [];
        this.styles = [];
        let matchedStyles = this.matchedStyles = [];
        rules2.forEach((rule) => {
          if (isTagRule(rule)) {
            this.tags.push(rule);
          } else if (isStyleRule(rule)) {
            let prop = /[^=]*/.exec(rule.style)[0];
            if (matchedStyles.indexOf(prop) < 0)
              matchedStyles.push(prop);
            this.styles.push(rule);
          }
        });
        this.normalizeLists = !this.tags.some((r) => {
          if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
            return false;
          let node = schema.nodes[r.node];
          return node.contentMatch.matchType(node);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(dom, options = {}) {
        let context = new ParseContext(this, options, false);
        context.addAll(dom, Mark$1.none, options.from, options.to);
        return context.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(dom, options = {}) {
        let context = new ParseContext(this, options, true);
        context.addAll(dom, Mark$1.none, options.from, options.to);
        return Slice.maxOpen(context.finish());
      }
      /**
      @internal
      */
      matchTag(dom, context, after) {
        for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
          let rule = this.tags[i2];
          if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
            if (rule.getAttrs) {
              let result = rule.getAttrs(dom);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(prop, value, context, after) {
        for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
          let rule = this.styles[i2], style2 = rule.style;
          if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
            continue;
          if (rule.getAttrs) {
            let result = rule.getAttrs(value);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
      /**
      @internal
      */
      static schemaRules(schema) {
        let result = [];
        function insert(rule) {
          let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
          for (; i2 < result.length; i2++) {
            let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
            if (nextPriority < priority)
              break;
          }
          result.splice(i2, 0, rule);
        }
        for (let name in schema.marks) {
          let rules2 = schema.marks[name].spec.parseDOM;
          if (rules2)
            rules2.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.mark || rule.ignore || rule.clearMark))
                rule.mark = name;
            });
        }
        for (let name in schema.nodes) {
          let rules2 = schema.nodes[name].spec.parseDOM;
          if (rules2)
            rules2.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.node || rule.ignore || rule.mark))
                rule.node = name;
            });
        }
        return result;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(schema) {
        return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
      }
    };
    const blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    const ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    const listTags = { ol: true, ul: true };
    const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
    function wsOptionsFor(type, preserveWhitespace, base2) {
      if (preserveWhitespace != null)
        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
      return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & -5;
    }
    class NodeContext {
      constructor(type, attrs, marks, solid, match, options) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.solid = solid;
        this.options = options;
        this.content = [];
        this.activeMarks = Mark$1.none;
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      }
      findWrapping(node) {
        if (!this.match) {
          if (!this.type)
            return [];
          let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
          if (fill) {
            this.match = this.type.contentMatch.matchFragment(fill);
          } else {
            let start = this.type.contentMatch, wrap2;
            if (wrap2 = start.findWrapping(node.type)) {
              this.match = start;
              return wrap2;
            } else {
              return null;
            }
          }
        }
        return this.match.findWrapping(node.type);
      }
      finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) {
          let last = this.content[this.content.length - 1], m;
          if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
            let text = last;
            if (last.text.length == m[0].length)
              this.content.pop();
            else
              this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
          }
        }
        let content = Fragment.from(this.content);
        if (!openEnd && this.match)
          content = content.append(this.match.fillBefore(Fragment.empty, true));
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
      }
      inlineContext(node) {
        if (this.type)
          return this.type.inlineContent;
        if (this.content.length)
          return this.content[0].isInline;
        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
      }
    }
    class ParseContext {
      constructor(parser, options, isOpen) {
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        this.localPreserveWS = false;
        let topNode = options.topNode, topContext;
        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
          topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);
        else
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(dom, marks) {
        if (dom.nodeType == 3)
          this.addTextNode(dom, marks);
        else if (dom.nodeType == 1)
          this.addElement(dom, marks);
      }
      addTextNode(dom, marks) {
        let value = dom.nodeValue;
        let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
        if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
          if (!preserveWS) {
            value = value.replace(/[ \t\r\n\u000c]+/g, " ");
            if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
              let nodeBefore = top.content[top.content.length - 1];
              let domNodeBefore = dom.previousSibling;
              if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                value = value.slice(1);
            }
          } else if (preserveWS !== "full") {
            value = value.replace(/\r?\n|\r/g, " ");
          } else {
            value = value.replace(/\r\n?/g, "\n");
          }
          if (value)
            this.insertNode(this.parser.schema.text(value), marks);
          this.findInText(dom);
        } else {
          this.findInside(dom);
        }
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(dom, marks, matchAfter) {
        let outerWS = this.localPreserveWS, top = this.top;
        if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
          this.localPreserveWS = true;
        let name = dom.nodeName.toLowerCase(), ruleID;
        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
          normalizeList(dom);
        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
          this.findInside(dom);
          this.ignoreFallback(dom, marks);
        } else if (!rule || rule.skip || rule.closeParent) {
          if (rule && rule.closeParent)
            this.open = Math.max(0, this.open - 1);
          else if (rule && rule.skip.nodeType)
            dom = rule.skip;
          let sync, oldNeedsBlock = this.needsBlock;
          if (blockTags.hasOwnProperty(name)) {
            if (top.content.length && top.content[0].isInline && this.open) {
              this.open--;
              top = this.top;
            }
            sync = true;
            if (!top.type)
              this.needsBlock = true;
          } else if (!dom.firstChild) {
            this.leafFallback(dom, marks);
            break out;
          }
          let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
          if (innerMarks)
            this.addAll(dom, innerMarks);
          if (sync)
            this.sync(top);
          this.needsBlock = oldNeedsBlock;
        } else {
          let innerMarks = this.readStyles(dom, marks);
          if (innerMarks)
            this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
        }
        this.localPreserveWS = outerWS;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(dom, marks) {
        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
          this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
      }
      // Called for ignored nodes
      ignoreFallback(dom, marks) {
        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
          this.findPlace(this.parser.schema.text("-"), marks);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(dom, marks) {
        let styles = dom.style;
        if (styles && styles.length)
          for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
            let name = this.parser.matchedStyles[i2], value = styles.getPropertyValue(name);
            if (value)
              for (let after = void 0; ; ) {
                let rule = this.parser.matchStyle(name, value, this, after);
                if (!rule)
                  break;
                if (rule.ignore)
                  return null;
                if (rule.clearMark)
                  marks = marks.filter((m) => !rule.clearMark(m));
                else
                  marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
                if (rule.consuming === false)
                  after = rule;
                else
                  break;
              }
          }
        return marks;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(dom, rule, marks, continueAfter) {
        let sync, nodeType;
        if (rule.node) {
          nodeType = this.parser.schema.nodes[rule.node];
          if (!nodeType.isLeaf) {
            let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
            if (inner) {
              sync = true;
              marks = inner;
            }
          } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {
            this.leafFallback(dom, marks);
          }
        } else {
          let markType = this.parser.schema.marks[rule.mark];
          marks = marks.concat(markType.create(rule.attrs));
        }
        let startIn = this.top;
        if (nodeType && nodeType.isLeaf) {
          this.findInside(dom);
        } else if (continueAfter) {
          this.addElement(dom, marks, continueAfter);
        } else if (rule.getContent) {
          this.findInside(dom);
          rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks));
        } else {
          let contentDOM = dom;
          if (typeof rule.contentElement == "string")
            contentDOM = dom.querySelector(rule.contentElement);
          else if (typeof rule.contentElement == "function")
            contentDOM = rule.contentElement(dom);
          else if (rule.contentElement)
            contentDOM = rule.contentElement;
          this.findAround(dom, contentDOM, true);
          this.addAll(contentDOM, marks);
          this.findAround(dom, contentDOM, false);
        }
        if (sync && this.sync(startIn))
          this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(parent, marks, startIndex, endIndex) {
        let index = startIndex || 0;
        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
          this.findAtPoint(parent, index);
          this.addDOM(dom, marks);
        }
        this.findAtPoint(parent, index);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(node, marks) {
        let route, sync;
        for (let depth = this.open; depth >= 0; depth--) {
          let cx = this.nodes[depth];
          let found2 = cx.findWrapping(node);
          if (found2 && (!route || route.length > found2.length)) {
            route = found2;
            sync = cx;
            if (!found2.length)
              break;
          }
          if (cx.solid)
            break;
        }
        if (!route)
          return null;
        this.sync(sync);
        for (let i2 = 0; i2 < route.length; i2++)
          marks = this.enterInner(route[i2], null, marks, false);
        return marks;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(node, marks) {
        if (node.isInline && this.needsBlock && !this.top.type) {
          let block = this.textblockFromContext();
          if (block)
            marks = this.enterInner(block, null, marks);
        }
        let innerMarks = this.findPlace(node, marks);
        if (innerMarks) {
          this.closeExtra();
          let top = this.top;
          if (top.match)
            top.match = top.match.matchType(node.type);
          let nodeMarks = Mark$1.none;
          for (let m of innerMarks.concat(node.marks))
            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
              nodeMarks = m.addToSet(nodeMarks);
          top.content.push(node.mark(nodeMarks));
          return true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(type, attrs, marks, preserveWS) {
        let innerMarks = this.findPlace(type.create(attrs), marks);
        if (innerMarks)
          innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
        return innerMarks;
      }
      // Open a node of the given type
      enterInner(type, attrs, marks, solid = false, preserveWS) {
        this.closeExtra();
        let top = this.top;
        top.match = top.match && top.match.matchType(type);
        let options = wsOptionsFor(type, preserveWS, top.options);
        if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
          options |= OPT_OPEN_LEFT;
        let applyMarks = Mark$1.none;
        marks = marks.filter((m) => {
          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
            applyMarks = m.addToSet(applyMarks);
            return false;
          }
          return true;
        });
        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
        this.open++;
        return marks;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(openEnd = false) {
        let i2 = this.nodes.length - 1;
        if (i2 > this.open) {
          for (; i2 > this.open; i2--)
            this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(to2) {
        for (let i2 = this.open; i2 >= 0; i2--) {
          if (this.nodes[i2] == to2) {
            this.open = i2;
            return true;
          } else if (this.localPreserveWS) {
            this.nodes[i2].options |= OPT_PRESERVE_WS;
          }
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let pos = 0;
        for (let i2 = this.open; i2 >= 0; i2--) {
          let content = this.nodes[i2].content;
          for (let j = content.length - 1; j >= 0; j--)
            pos += content[j].nodeSize;
          if (i2)
            pos++;
        }
        return pos;
      }
      findAtPoint(parent, offset) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == parent && this.find[i2].offset == offset)
              this.find[i2].pos = this.currentPos;
          }
      }
      findInside(parent) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
              this.find[i2].pos = this.currentPos;
          }
      }
      findAround(parent, content, before) {
        if (parent != content && this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
              let pos = content.compareDocumentPosition(this.find[i2].node);
              if (pos & (before ? 2 : 4))
                this.find[i2].pos = this.currentPos;
            }
          }
      }
      findInText(textNode) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == textNode)
              this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
          }
      }
      // Determines whether the given context string matches this context.
      matchesContext(context) {
        if (context.indexOf("|") > -1)
          return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        let parts = context.split("/");
        let option = this.options.context;
        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        let match = (i2, depth) => {
          for (; i2 >= 0; i2--) {
            let part = parts[i2];
            if (part == "") {
              if (i2 == parts.length - 1 || i2 == 0)
                continue;
              for (; depth >= minDepth; depth--)
                if (match(i2 - 1, depth))
                  return true;
              return false;
            } else {
              let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
              if (!next || next.name != part && !next.isInGroup(part))
                return false;
              depth--;
            }
          }
          return true;
        };
        return match(parts.length - 1, this.open);
      }
      textblockFromContext() {
        let $context = this.options.context;
        if ($context)
          for (let d = $context.depth; d >= 0; d--) {
            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs)
              return deflt;
          }
        for (let name in this.parser.schema.nodes) {
          let type = this.parser.schema.nodes[name];
          if (type.isTextblock && type.defaultAttrs)
            return type;
        }
      }
    }
    function normalizeList(dom) {
      for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function copy(obj) {
      let copy2 = {};
      for (let prop in obj)
        copy2[prop] = obj[prop];
      return copy2;
    }
    function markMayApply(markType, nodeType) {
      let nodes = nodeType.schema.nodes;
      for (let name in nodes) {
        let parent = nodes[name];
        if (!parent.allowsMarkType(markType))
          continue;
        let seen = [], scan = (match) => {
          seen.push(match);
          for (let i2 = 0; i2 < match.edgeCount; i2++) {
            let { type, next } = match.edge(i2);
            if (type == nodeType)
              return true;
            if (seen.indexOf(next) < 0 && scan(next))
              return true;
          }
        };
        if (scan(parent.contentMatch))
          return true;
      }
    }
    class DOMSerializer {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(nodes, marks) {
        this.nodes = nodes;
        this.marks = marks;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(fragment, options = {}, target) {
        if (!target)
          target = doc$1(options).createDocumentFragment();
        let top = target, active = [];
        fragment.forEach((node) => {
          if (active.length || node.marks.length) {
            let keep = 0, rendered = 0;
            while (keep < active.length && rendered < node.marks.length) {
              let next = node.marks[rendered];
              if (!this.marks[next.type.name]) {
                rendered++;
                continue;
              }
              if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                break;
              keep++;
              rendered++;
            }
            while (keep < active.length)
              top = active.pop()[1];
            while (rendered < node.marks.length) {
              let add = node.marks[rendered++];
              let markDOM = this.serializeMark(add, node.isInline, options);
              if (markDOM) {
                active.push([add, top]);
                top.appendChild(markDOM.dom);
                top = markDOM.contentDOM || markDOM.dom;
              }
            }
          }
          top.appendChild(this.serializeNodeInner(node, options));
        });
        return target;
      }
      /**
      @internal
      */
      serializeNodeInner(node, options) {
        let { dom, contentDOM } = renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs);
        if (contentDOM) {
          if (node.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(node.content, options, contentDOM);
        }
        return dom;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(node, options = {}) {
        let dom = this.serializeNodeInner(node, options);
        for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
          let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options);
          if (wrap2) {
            (wrap2.contentDOM || wrap2.dom).appendChild(dom);
            dom = wrap2.dom;
          }
        }
        return dom;
      }
      /**
      @internal
      */
      serializeMark(mark, inline, options = {}) {
        let toDOM = this.marks[mark.type.name];
        return toDOM && renderSpec(doc$1(options), toDOM(mark, inline), null, mark.attrs);
      }
      static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
        return renderSpec(doc2, structure, xmlNS, blockArraysIn);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(schema) {
        return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(schema) {
        let result = gatherToDOM(schema.nodes);
        if (!result.text)
          result.text = (node) => node.text;
        return result;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(schema) {
        return gatherToDOM(schema.marks);
      }
    }
    function gatherToDOM(obj) {
      let result = {};
      for (let name in obj) {
        let toDOM = obj[name].spec.toDOM;
        if (toDOM)
          result[name] = toDOM;
      }
      return result;
    }
    function doc$1(options) {
      return options.document || window.document;
    }
    const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
    function suspiciousAttributes(attrs) {
      let value = suspiciousAttributeCache.get(attrs);
      if (value === void 0)
        suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
      return value;
    }
    function suspiciousAttributesInner(attrs) {
      let result = null;
      function scan(value) {
        if (value && typeof value == "object") {
          if (Array.isArray(value)) {
            if (typeof value[0] == "string") {
              if (!result)
                result = [];
              result.push(value);
            } else {
              for (let i2 = 0; i2 < value.length; i2++)
                scan(value[i2]);
            }
          } else {
            for (let prop in value)
              scan(value[prop]);
          }
        }
      }
      scan(attrs);
      return result;
    }
    function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
      if (typeof structure == "string")
        return { dom: doc2.createTextNode(structure) };
      if (structure.nodeType != null)
        return { dom: structure };
      if (structure.dom && structure.dom.nodeType != null)
        return structure;
      let tagName = structure[0], suspicious;
      if (typeof tagName != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      let contentDOM;
      let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      let attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (let name in attrs)
          if (attrs[name] != null) {
            let space2 = name.indexOf(" ");
            if (space2 > 0)
              dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
            else
              dom.setAttribute(name, attrs[name]);
          }
      }
      for (let i2 = start; i2 < structure.length; i2++) {
        let child = structure[i2];
        if (child === 0) {
          if (i2 < structure.length - 1 || i2 > start)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom, contentDOM: dom };
        } else {
          let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM)
              throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    }
    const lower16 = 65535;
    const factor16 = Math.pow(2, 16);
    function makeRecover(index, offset) {
      return index + offset * factor16;
    }
    function recoverIndex(value) {
      return value & lower16;
    }
    function recoverOffset(value) {
      return (value - (value & lower16)) / factor16;
    }
    const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
    class MapResult {
      /**
      @internal
      */
      constructor(pos, delInfo, recover) {
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & DEL_SIDE) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & DEL_ACROSS) > 0;
      }
    }
    class StepMap {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(ranges, inverted = false) {
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && StepMap.empty)
          return StepMap.empty;
      }
      /**
      @internal
      */
      recover(value) {
        let diff = 0, index = recoverIndex(value);
        if (!this.inverted)
          for (let i2 = 0; i2 < index; i2++)
            diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
        return this.ranges[index * 3] + diff + recoverOffset(value);
      }
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      map(pos, assoc = 1) {
        return this._map(pos, assoc, true);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
          if (pos <= end) {
            let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
            let result = start + diff + (side < 0 ? 0 : newSize);
            if (simple)
              return result;
            let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
            let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
            if (assoc < 0 ? pos != start : pos != end)
              del |= DEL_SIDE;
            return new MapResult(result, del, recover);
          }
          diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff, 0, null);
      }
      /**
      @internal
      */
      touches(pos, recover) {
        let diff = 0, index = recoverIndex(recover);
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
          if (pos <= end && i2 == index * 3)
            return true;
          diff += this.ranges[i2 + newIndex] - oldSize;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(f) {
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
          f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
          diff += newSize - oldSize;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new StepMap(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(n) {
        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
      }
    }
    StepMap.empty = new StepMap([]);
    class Mapping {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(maps, mirror, from = 0, to2 = maps ? maps.length : 0) {
        this.mirror = mirror;
        this.from = from;
        this.to = to2;
        this._maps = maps || [];
        this.ownData = !(maps || mirror);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(from = 0, to2 = this.maps.length) {
        return new Mapping(this._maps, this.mirror, from, to2);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(map, mirrors) {
        if (!this.ownData) {
          this._maps = this._maps.slice();
          this.mirror = this.mirror && this.mirror.slice();
          this.ownData = true;
        }
        this.to = this._maps.push(map);
        if (mirrors != null)
          this.setMirror(this._maps.length - 1, mirrors);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(mapping) {
        for (let i2 = 0, startSize = this._maps.length; i2 < mapping._maps.length; i2++) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping._maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(n) {
        if (this.mirror) {
          for (let i2 = 0; i2 < this.mirror.length; i2++)
            if (this.mirror[i2] == n)
              return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(n, m) {
        if (!this.mirror)
          this.mirror = [];
        this.mirror.push(n, m);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(mapping) {
        for (let i2 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i2 >= 0; i2--) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping._maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let inverse = new Mapping();
        inverse.appendMappingInverted(this);
        return inverse;
      }
      /**
      Map a position through this mapping.
      */
      map(pos, assoc = 1) {
        if (this.mirror)
          return this._map(pos, assoc, true);
        for (let i2 = this.from; i2 < this.to; i2++)
          pos = this._maps[i2].map(pos, assoc);
        return pos;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let delInfo = 0;
        for (let i2 = this.from; i2 < this.to; i2++) {
          let map = this._maps[i2], result = map.mapResult(pos, assoc);
          if (result.recover != null) {
            let corr = this.getMirror(i2);
            if (corr != null && corr > i2 && corr < this.to) {
              i2 = corr;
              pos = this._maps[corr].recover(result.recover);
              continue;
            }
          }
          delInfo |= result.delInfo;
          pos = result.pos;
        }
        return simple ? pos : new MapResult(pos, delInfo, null);
      }
    }
    const stepsByID = /* @__PURE__ */ Object.create(null);
    class Step {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return StepMap.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(other) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(schema, json) {
        if (!json || !json.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let type = stepsByID[json.stepType];
        if (!type)
          throw new RangeError(`No step type ${json.stepType} defined`);
        return type.fromJSON(schema, json);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(id2, stepClass) {
        if (id2 in stepsByID)
          throw new RangeError("Duplicate use of step JSON ID " + id2);
        stepsByID[id2] = stepClass;
        stepClass.prototype.jsonID = id2;
        return stepClass;
      }
    }
    class StepResult {
      /**
      @internal
      */
      constructor(doc2, failed) {
        this.doc = doc2;
        this.failed = failed;
      }
      /**
      Create a successful step result.
      */
      static ok(doc2) {
        return new StepResult(doc2, null);
      }
      /**
      Create a failed step result.
      */
      static fail(message) {
        return new StepResult(null, message);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(doc2, from, to2, slice) {
        try {
          return StepResult.ok(doc2.replace(from, to2, slice));
        } catch (e) {
          if (e instanceof ReplaceError)
            return StepResult.fail(e.message);
          throw e;
        }
      }
    }
    function mapFragment(fragment, f, parent) {
      let mapped = [];
      for (let i2 = 0; i2 < fragment.childCount; i2++) {
        let child = fragment.child(i2);
        if (child.content.size)
          child = child.copy(mapFragment(child.content, f, child));
        if (child.isInline)
          child = f(child, parent, i2);
        mapped.push(child);
      }
      return Fragment.fromArray(mapped);
    }
    class AddMarkStep extends Step {
      /**
      Create a mark step.
      */
      constructor(from, to2, mark) {
        super();
        this.from = from;
        this.to = to2;
        this.mark = mark;
      }
      apply(doc2) {
        let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
        let parent = $from.node($from.sharedDepth(this.to));
        let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
          if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
            return node;
          return node.mark(this.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc2, this.from, this.to, slice);
      }
      invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from.deleted && to2.deleted || from.pos >= to2.pos)
          return null;
        return new AddMarkStep(from.pos, to2.pos, this.mark);
      }
      merge(other) {
        if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
      }
    }
    Step.jsonID("addMark", AddMarkStep);
    class RemoveMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(from, to2, mark) {
        super();
        this.from = from;
        this.to = to2;
        this.mark = mark;
      }
      apply(doc2) {
        let oldSlice = doc2.slice(this.from, this.to);
        let slice = new Slice(mapFragment(oldSlice.content, (node) => {
          return node.mark(this.mark.removeFromSet(node.marks));
        }, doc2), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc2, this.from, this.to, slice);
      }
      invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from.deleted && to2.deleted || from.pos >= to2.pos)
          return null;
        return new RemoveMarkStep(from.pos, to2.pos, this.mark);
      }
      merge(other) {
        if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
      }
    }
    Step.jsonID("removeMark", RemoveMarkStep);
    class AddNodeMarkStep extends Step {
      /**
      Create a node mark step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc2) {
        let node = doc2.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
        return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc2) {
        let node = doc2.nodeAt(this.pos);
        if (node) {
          let newSet = this.mark.addToSet(node.marks);
          if (newSet.length == node.marks.length) {
            for (let i2 = 0; i2 < node.marks.length; i2++)
              if (!node.marks[i2].isInSet(newSet))
                return new AddNodeMarkStep(this.pos, node.marks[i2]);
            return new AddNodeMarkStep(this.pos, this.mark);
          }
        }
        return new RemoveNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
      }
    }
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    class RemoveNodeMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc2) {
        let node = doc2.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
        return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc2) {
        let node = doc2.nodeAt(this.pos);
        if (!node || !this.mark.isInSet(node.marks))
          return this;
        return new AddNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
      }
    }
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    class ReplaceStep extends Step {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(from, to2, slice, structure = false) {
        super();
        this.from = from;
        this.to = to2;
        this.slice = slice;
        this.structure = structure;
      }
      apply(doc2) {
        if (this.structure && contentBetween(doc2, this.from, this.to))
          return StepResult.fail("Structure replace would overwrite content");
        return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
      }
      getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      }
      invert(doc2) {
        return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
      }
      map(mapping) {
        let from = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        if (from.deletedAcross && to2.deletedAcross)
          return null;
        return new ReplaceStep(from.pos, Math.max(from.pos, to2.pos), this.slice);
      }
      merge(other) {
        if (!(other instanceof ReplaceStep) || other.structure || this.structure)
          return null;
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new ReplaceStep(other.from, this.to, slice, this.structure);
        } else {
          return null;
        }
      }
      toJSON() {
        let json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
      }
    }
    Step.jsonID("replace", ReplaceStep);
    class ReplaceAroundStep extends Step {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(from, to2, gapFrom, gapTo, slice, insert, structure = false) {
        super();
        this.from = from;
        this.to = to2;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice;
        this.insert = insert;
        this.structure = structure;
      }
      apply(doc2) {
        if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
          return StepResult.fail("Structure gap-replace would overwrite content");
        let gap = doc2.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
          return StepResult.fail("Gap is not a flat range");
        let inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted)
          return StepResult.fail("Content does not fit in gap");
        return StepResult.fromReplace(doc2, this.from, this.to, inserted);
      }
      getMap() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(doc2) {
        let gap = this.gapTo - this.gapFrom;
        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(mapping) {
        let from = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
        let gapTo = this.to == this.gapTo ? to2.pos : mapping.map(this.gapTo, 1);
        if (from.deletedAcross && to2.deletedAcross || gapFrom < from.pos || gapTo > to2.pos)
          return null;
        return new ReplaceAroundStep(from.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let json = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
      }
    }
    Step.jsonID("replaceAround", ReplaceAroundStep);
    function contentBetween(doc2, from, to2) {
      let $from = doc2.resolve(from), dist = to2 - from, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        let next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf)
            return true;
          next = next.firstChild;
          dist--;
        }
      }
      return false;
    }
    function addMark(tr2, from, to2, mark) {
      let removed = [], added = [];
      let removing, adding;
      tr2.doc.nodesBetween(from, to2, (node, pos, parent) => {
        if (!node.isInline)
          return;
        let marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to2);
          let newSet = mark.addToSet(marks);
          for (let i2 = 0; i2 < marks.length; i2++) {
            if (!marks[i2].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i2]))
                removing.to = end;
              else
                removed.push(removing = new RemoveMarkStep(start, end, marks[i2]));
            }
          }
          if (adding && adding.to == start)
            adding.to = end;
          else
            added.push(adding = new AddMarkStep(start, end, mark));
        }
      });
      removed.forEach((s) => tr2.step(s));
      added.forEach((s) => tr2.step(s));
    }
    function removeMark(tr2, from, to2, mark) {
      let matched = [], step = 0;
      tr2.doc.nodesBetween(from, to2, (node, pos) => {
        if (!node.isInline)
          return;
        step++;
        let toRemove = null;
        if (mark instanceof MarkType) {
          let set = node.marks, found2;
          while (found2 = mark.isInSet(set)) {
            (toRemove || (toRemove = [])).push(found2);
            set = found2.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks))
            toRemove = [mark];
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          let end = Math.min(pos + node.nodeSize, to2);
          for (let i2 = 0; i2 < toRemove.length; i2++) {
            let style2 = toRemove[i2], found2;
            for (let j = 0; j < matched.length; j++) {
              let m = matched[j];
              if (m.step == step - 1 && style2.eq(matched[j].style))
                found2 = m;
            }
            if (found2) {
              found2.to = end;
              found2.step = step;
            } else {
              matched.push({ style: style2, from: Math.max(pos, from), to: end, step });
            }
          }
        }
      });
      matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
    }
    function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
      let node = tr2.doc.nodeAt(pos);
      let replSteps = [], cur = pos + 1;
      for (let i2 = 0; i2 < node.childCount; i2++) {
        let child = node.child(i2), end = cur + child.nodeSize;
        let allowed = match.matchType(child.type);
        if (!allowed) {
          replSteps.push(new ReplaceStep(cur, end, Slice.empty));
        } else {
          match = allowed;
          for (let j = 0; j < child.marks.length; j++)
            if (!parentType.allowsMarkType(child.marks[j].type))
              tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
          if (clearNewlines && child.isText && parentType.whitespace != "pre") {
            let m, newline = /\r?\n|\r/g, slice;
            while (m = newline.exec(child.text)) {
              if (!slice)
                slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
              replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
            }
          }
        }
        cur = end;
      }
      if (!match.validEnd) {
        let fill = match.fillBefore(Fragment.empty, true);
        tr2.replace(cur, cur, new Slice(fill, 0, 0));
      }
      for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
        tr2.step(replSteps[i2]);
    }
    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
    }
    function liftTarget(range2) {
      let parent = range2.parent;
      let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
      for (let depth = range2.depth; ; --depth) {
        let node = range2.$from.node(depth);
        let index = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
        if (depth < range2.depth && node.canReplace(index, endIndex, content))
          return depth;
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
          break;
      }
      return null;
    }
    function lift$2(tr2, range2, target) {
      let { $from, $to, depth } = range2;
      let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      let start = gapStart, end = gapEnd;
      let before = Fragment.empty, openStart = 0;
      for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $from.index(d) > 0) {
          splitting = true;
          before = Fragment.from($from.node(d).copy(before));
          openStart++;
        } else {
          start--;
        }
      let after = Fragment.empty, openEnd = 0;
      for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $to.after(d + 1) < $to.end(d)) {
          splitting = true;
          after = Fragment.from($to.node(d).copy(after));
          openEnd++;
        } else {
          end++;
        }
      tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
    }
    function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
      let around = findWrappingOutside(range2, nodeType);
      let inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner)
        return null;
      return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
    }
    function withAttrs(type) {
      return { type, attrs: null };
    }
    function findWrappingOutside(range2, type) {
      let { parent, startIndex, endIndex } = range2;
      let around = parent.contentMatchAt(startIndex).findWrapping(type);
      if (!around)
        return null;
      let outer = around.length ? around[0] : type;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    function findWrappingInside(range2, type) {
      let { parent, startIndex, endIndex } = range2;
      let inner = parent.child(startIndex);
      let inside = type.contentMatch.findWrapping(inner.type);
      if (!inside)
        return null;
      let lastType = inside.length ? inside[inside.length - 1] : type;
      let innerMatch = lastType.contentMatch;
      for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
        innerMatch = innerMatch.matchType(parent.child(i2).type);
      if (!innerMatch || !innerMatch.validEnd)
        return null;
      return inside;
    }
    function wrap(tr2, range2, wrappers) {
      let content = Fragment.empty;
      for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
        if (content.size) {
          let match = wrappers[i2].type.contentMatch.matchFragment(content);
          if (!match || !match.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
      }
      let start = range2.start, end = range2.end;
      tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
    }
    function setBlockType$1(tr2, from, to2, type, attrs) {
      if (!type.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let mapFrom = tr2.steps.length;
      tr2.doc.nodesBetween(from, to2, (node, pos) => {
        let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
        if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
          let convertNewlines = null;
          if (type.schema.linebreakReplacement) {
            let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
            if (pre && !supportLinebreak)
              convertNewlines = false;
            else if (!pre && supportLinebreak)
              convertNewlines = true;
          }
          if (convertNewlines === false)
            replaceLinebreaks(tr2, node, pos, mapFrom);
          clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
          let mapping = tr2.mapping.slice(mapFrom);
          let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
          if (convertNewlines === true)
            replaceNewlines(tr2, node, pos, mapFrom);
          return false;
        }
      });
    }
    function replaceNewlines(tr2, node, pos, mapFrom) {
      node.forEach((child, offset) => {
        if (child.isText) {
          let m, newline = /\r?\n|\r/g;
          while (m = newline.exec(child.text)) {
            let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
            tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function replaceLinebreaks(tr2, node, pos, mapFrom) {
      node.forEach((child, offset) => {
        if (child.type == child.type.schema.linebreakReplacement) {
          let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset);
          tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
        }
      });
    }
    function canChangeType(doc2, pos, type) {
      let $pos = doc2.resolve(pos), index = $pos.index();
      return $pos.parent.canReplaceWith(index, index + 1, type);
    }
    function setNodeMarkup(tr2, pos, type, attrs, marks) {
      let node = tr2.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at given position");
      if (!type)
        type = node.type;
      let newNode = type.create(attrs, null, marks || node.marks);
      if (node.isLeaf)
        return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
      if (!type.validContent(node.content))
        throw new RangeError("Invalid content for node type " + type.name);
      tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
    }
    function canSplit(doc2, pos, depth = 1, typesAfter) {
      let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
      let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
      if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
        return false;
      for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
        let node = $pos.node(d), index2 = $pos.index(d);
        if (node.type.spec.isolating)
          return false;
        let rest = node.content.cutByIndex(index2, node.childCount);
        let overrideChild = typesAfter && typesAfter[i2 + 1];
        if (overrideChild)
          rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
        let after = typesAfter && typesAfter[i2] || node;
        if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
          return false;
      }
      let index = $pos.indexAfter(base2);
      let baseType = typesAfter && typesAfter[0];
      return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
    }
    function split(tr2, pos, depth = 1, typesAfter) {
      let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
      for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
        before = Fragment.from($pos.node(d).copy(before));
        let typeAfter = typesAfter && typesAfter[i2];
        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
    }
    function canJoin(doc2, pos) {
      let $pos = doc2.resolve(pos), index = $pos.index();
      return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
    }
    function canAppendWithSubstitutedLinebreaks(a, b) {
      if (!b.content.size)
        a.type.compatibleContent(b.type);
      let match = a.contentMatchAt(a.childCount);
      let { linebreakReplacement } = a.type.schema;
      for (let i2 = 0; i2 < b.childCount; i2++) {
        let child = b.child(i2);
        let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
        match = match.matchType(type);
        if (!match)
          return false;
        if (!a.type.allowsMarks(child.marks))
          return false;
      }
      return match.validEnd;
    }
    function joinable(a, b) {
      return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
    }
    function joinPoint(doc2, pos, dir = -1) {
      let $pos = doc2.resolve(pos);
      for (let d = $pos.depth; ; d--) {
        let before, after, index = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index++;
          after = $pos.node(d).maybeChild(index);
        } else {
          before = $pos.node(d).maybeChild(index - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1))
          return pos;
        if (d == 0)
          break;
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }
    function join(tr2, pos, depth) {
      let convertNewlines = null;
      let { linebreakReplacement } = tr2.doc.type.schema;
      let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
      if (linebreakReplacement && beforeType.inlineContent) {
        let pre = beforeType.whitespace == "pre";
        let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      let mapFrom = tr2.steps.length;
      if (convertNewlines === false) {
        let $after = tr2.doc.resolve(pos + depth);
        replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
      }
      if (beforeType.inlineContent)
        clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
      let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
      tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
      if (convertNewlines === true) {
        let $full = tr2.doc.resolve(start);
        replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
      }
      return tr2;
    }
    function insertPoint(doc2, pos, nodeType) {
      let $pos = doc2.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
        return pos;
      if ($pos.parentOffset == 0)
        for (let d = $pos.depth - 1; d >= 0; d--) {
          let index = $pos.index(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType))
            return $pos.before(d + 1);
          if (index > 0)
            return null;
        }
      if ($pos.parentOffset == $pos.parent.content.size)
        for (let d = $pos.depth - 1; d >= 0; d--) {
          let index = $pos.indexAfter(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType))
            return $pos.after(d + 1);
          if (index < $pos.node(d).childCount)
            return null;
        }
      return null;
    }
    function dropPoint(doc2, pos, slice) {
      let $pos = doc2.resolve(pos);
      if (!slice.content.size)
        return pos;
      let content = slice.content;
      for (let i2 = 0; i2 < slice.openStart; i2++)
        content = content.firstChild.content;
      for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (let d = $pos.depth; d >= 0; d--) {
          let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          let parent = $pos.node(d), fits = false;
          if (pass == 1) {
            fits = parent.canReplace(insertPos, insertPos, content);
          } else {
            let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
            fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
          }
          if (fits)
            return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
      }
      return null;
    }
    function replaceStep(doc2, from, to2 = from, slice = Slice.empty) {
      if (from == to2 && !slice.size)
        return null;
      let $from = doc2.resolve(from), $to = doc2.resolve(to2);
      if (fitsTrivially($from, $to, slice))
        return new ReplaceStep(from, to2, slice);
      return new Fitter($from, $to, slice).fit();
    }
    function fitsTrivially($from, $to, slice) {
      return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
    }
    class Fitter {
      constructor($from, $to, unplaced) {
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = Fragment.empty;
        for (let i2 = 0; i2 <= $from.depth; i2++) {
          let node = $from.node(i2);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i2))
          });
        }
        for (let i2 = $from.depth; i2 > 0; i2--)
          this.placed = Fragment.from($from.node(i2).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        while (this.unplaced.size) {
          let fit = this.findFittable();
          if (fit)
            this.placeNodes(fit);
          else
            this.openMore() || this.dropNode();
        }
        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
        if (!$to)
          return null;
        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
        while (openStart && openEnd && content.childCount == 1) {
          content = content.firstChild.content;
          openStart--;
          openEnd--;
        }
        let slice = new Slice(content, openStart, openEnd);
        if (moveInline > -1)
          return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
        if (slice.size || $from.pos != this.$to.pos)
          return new ReplaceStep($from.pos, $to.pos, slice);
        return null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let startDepth = this.unplaced.openStart;
        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
          let node = cur.firstChild;
          if (cur.childCount > 1)
            openEnd = 0;
          if (node.type.spec.isolating && openEnd <= d) {
            startDepth = d;
            break;
          }
          cur = node.content;
        }
        for (let pass = 1; pass <= 2; pass++) {
          for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
            let fragment, parent = null;
            if (sliceDepth) {
              parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
              fragment = parent.content;
            } else {
              fragment = this.unplaced.content;
            }
            let first2 = fragment.firstChild;
            for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
              let { type, match } = this.frontier[frontierDepth], wrap2, inject2 = null;
              if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
                return { sliceDepth, frontierDepth, parent, inject: inject2 };
              else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
                return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
              if (parent && match.matchType(parent.type))
                break;
            }
          }
        }
      }
      openMore() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (!inner.childCount || inner.firstChild.isLeaf)
          return false;
        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
        return true;
      }
      dropNode() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (inner.childCount <= 1 && openStart > 0) {
          let openAtEnd = content.size - openStart <= openStart + inner.size;
          this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
        } else {
          this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
        }
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth, frontierDepth, parent, inject: inject2, wrap: wrap2 }) {
        while (this.depth > frontierDepth)
          this.closeFrontierNode();
        if (wrap2)
          for (let i2 = 0; i2 < wrap2.length; i2++)
            this.openFrontierNode(wrap2[i2]);
        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
        let openStart = slice.openStart - sliceDepth;
        let taken = 0, add = [];
        let { match, type } = this.frontier[frontierDepth];
        if (inject2) {
          for (let i2 = 0; i2 < inject2.childCount; i2++)
            add.push(inject2.child(i2));
          match = match.matchFragment(inject2);
        }
        let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
        while (taken < fragment.childCount) {
          let next = fragment.child(taken), matches2 = match.matchType(next.type);
          if (!matches2)
            break;
          taken++;
          if (taken > 1 || openStart == 0 || next.content.size) {
            match = matches2;
            add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
          }
        }
        let toEnd = taken == fragment.childCount;
        if (!toEnd)
          openEndCount = -1;
        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
        this.frontier[frontierDepth].match = match;
        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
          this.closeFrontierNode();
        for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
          let node = cur.lastChild;
          this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
          cur = node.content;
        }
        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let top = this.frontier[this.depth], level;
        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
          return -1;
        let { depth } = this.$to, after = this.$to.after(depth);
        while (depth > 1 && after == this.$to.end(--depth))
          ++after;
        return after;
      }
      findCloseLevel($to) {
        scan: for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
          let { match, type } = this.frontier[i2];
          let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
          let fit = contentAfterFits($to, i2, type, match, dropInner);
          if (!fit)
            continue;
          for (let d = i2 - 1; d >= 0; d--) {
            let { match: match2, type: type3 } = this.frontier[d];
            let matches2 = contentAfterFits($to, d, type3, match2, true);
            if (!matches2 || matches2.childCount)
              continue scan;
          }
          return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
        }
      }
      close($to) {
        let close2 = this.findCloseLevel($to);
        if (!close2)
          return null;
        while (this.depth > close2.depth)
          this.closeFrontierNode();
        if (close2.fit.childCount)
          this.placed = addToFragment(this.placed, close2.depth, close2.fit);
        $to = close2.move;
        for (let d = close2.depth + 1; d <= $to.depth; d++) {
          let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
          this.openFrontierNode(node.type, node.attrs, add);
        }
        return $to;
      }
      openFrontierNode(type, attrs = null, content) {
        let top = this.frontier[this.depth];
        top.match = top.match.matchType(type);
        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
        this.frontier.push({ type, match: type.contentMatch });
      }
      closeFrontierNode() {
        let open = this.frontier.pop();
        let add = open.match.fillBefore(Fragment.empty, true);
        if (add.childCount)
          this.placed = addToFragment(this.placed, this.frontier.length, add);
      }
    }
    function dropFromFragment(fragment, depth, count) {
      if (depth == 0)
        return fragment.cutByIndex(count, fragment.childCount);
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
    }
    function addToFragment(fragment, depth, content) {
      if (depth == 0)
        return fragment.append(content);
      return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
    }
    function contentAt(fragment, depth) {
      for (let i2 = 0; i2 < depth; i2++)
        fragment = fragment.firstChild.content;
      return fragment;
    }
    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0)
        return node;
      let frag = node.content;
      if (openStart > 1)
        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0)
          frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
      }
      return node.copy(frag);
    }
    function contentAfterFits($to, depth, type, match, open) {
      let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index == node.childCount && !type.compatibleContent(node.type))
        return null;
      let fit = match.fillBefore(node.content, true, index);
      return fit && !invalidMarks(type, node.content, index) ? fit : null;
    }
    function invalidMarks(type, fragment, start) {
      for (let i2 = start; i2 < fragment.childCount; i2++)
        if (!type.allowsMarks(fragment.child(i2).marks))
          return true;
      return false;
    }
    function definesContent(type) {
      return type.spec.defining || type.spec.definingForContent;
    }
    function replaceRange(tr2, from, to2, slice) {
      if (!slice.size)
        return tr2.deleteRange(from, to2);
      let $from = tr2.doc.resolve(from), $to = tr2.doc.resolve(to2);
      if (fitsTrivially($from, $to, slice))
        return tr2.step(new ReplaceStep(from, to2, slice));
      let targetDepths = coveredDepths($from, tr2.doc.resolve(to2));
      if (targetDepths[targetDepths.length - 1] == 0)
        targetDepths.pop();
      let preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        let spec = $from.node(d).type.spec;
        if (spec.defining || spec.definingAsContext || spec.isolating)
          break;
        if (targetDepths.indexOf(d) > -1)
          preferredTarget = d;
        else if ($from.before(d) == pos)
          targetDepths.splice(1, 0, -d);
      }
      let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      let leftNodes = [], preferredDepth = slice.openStart;
      for (let content = slice.content, i2 = 0; ; i2++) {
        let node = content.firstChild;
        leftNodes.push(node);
        if (i2 == slice.openStart)
          break;
        content = node.content;
      }
      for (let d = preferredDepth - 1; d >= 0; d--) {
        let leftNode = leftNodes[d], def2 = definesContent(leftNode.type);
        if (def2 && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
          preferredDepth = d;
        else if (def2 || !leftNode.type.isTextblock)
          break;
      }
      for (let j = slice.openStart; j >= 0; j--) {
        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        let insert = leftNodes[openDepth];
        if (!insert)
          continue;
        for (let i2 = 0; i2 < targetDepths.length; i2++) {
          let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index, index, insert.type, insert.marks))
            return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
        }
      }
      let startSteps = tr2.steps.length;
      for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
        tr2.replace(from, to2, slice);
        if (tr2.steps.length > startSteps)
          break;
        let depth = targetDepths[i2];
        if (depth < 0)
          continue;
        from = $from.before(depth);
        to2 = $to.after(depth);
      }
    }
    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        let first2 = fragment.firstChild;
        fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
      }
      if (depth > newOpen) {
        let match = parent.contentMatchAt(0);
        let start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
      }
      return fragment;
    }
    function replaceRangeWith(tr2, from, to2, node) {
      if (!node.isInline && from == to2 && tr2.doc.resolve(from).parent.content.size) {
        let point = insertPoint(tr2.doc, from, node.type);
        if (point != null)
          from = to2 = point;
      }
      tr2.replaceRange(from, to2, new Slice(Fragment.from(node), 0, 0));
    }
    function deleteRange$1(tr2, from, to2) {
      let $from = tr2.doc.resolve(from), $to = tr2.doc.resolve(to2);
      let covered = coveredDepths($from, $to);
      for (let i2 = 0; i2 < covered.length; i2++) {
        let depth = covered[i2], last = i2 == covered.length - 1;
        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
          return tr2.delete($from.start(depth), $to.end(depth));
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
          return tr2.delete($from.before(depth), $to.after(depth));
      }
      for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to2 > $from.end(d) && $to.end(d) - to2 != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
          return tr2.delete($from.before(d), to2);
      }
      tr2.delete(from, to2);
    }
    function coveredDepths($from, $to) {
      let result = [], minDepth = Math.min($from.depth, $to.depth);
      for (let d = minDepth; d >= 0; d--) {
        let start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
          break;
        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
          result.push(d);
      }
      return result;
    }
    class AttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(pos, attr, value) {
        super();
        this.pos = pos;
        this.attr = attr;
        this.value = value;
      }
      apply(doc2) {
        let node = doc2.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at attribute step's position");
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in node.attrs)
          attrs[name] = node.attrs[name];
        attrs[this.attr] = this.value;
        let updated = node.type.create(attrs, null, node.marks);
        return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc2) {
        return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(schema, json) {
        if (typeof json.pos != "number" || typeof json.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new AttrStep(json.pos, json.attr, json.value);
      }
    }
    Step.jsonID("attr", AttrStep);
    class DocAttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(attr, value) {
        super();
        this.attr = attr;
        this.value = value;
      }
      apply(doc2) {
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in doc2.attrs)
          attrs[name] = doc2.attrs[name];
        attrs[this.attr] = this.value;
        let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
        return StepResult.ok(updated);
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc2) {
        return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
      }
      map(mapping) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(schema, json) {
        if (typeof json.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new DocAttrStep(json.attr, json.value);
      }
    }
    Step.jsonID("docAttr", DocAttrStep);
    let TransformError = class extends Error {
    };
    TransformError = function TransformError2(message) {
      let err = Error.call(this, message);
      err.__proto__ = TransformError2.prototype;
      return err;
    };
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    class Transform {
      /**
      Create a transform that starts with the given document.
      */
      constructor(doc2) {
        this.doc = doc2;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(step) {
        let result = this.maybeStep(step);
        if (result.failed)
          throw new TransformError(result.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(step) {
        let result = step.apply(this.doc);
        if (!result.failed)
          this.addStep(step, result.doc);
        return result;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(step, doc2) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc2;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(from, to2 = from, slice = Slice.empty) {
        let step = replaceStep(this.doc, from, to2, slice);
        if (step)
          this.step(step);
        return this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(from, to2, content) {
        return this.replace(from, to2, new Slice(Fragment.from(content), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(from, to2) {
        return this.replace(from, to2, Slice.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(pos, content) {
        return this.replaceWith(pos, pos, content);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(from, to2, slice) {
        replaceRange(this, from, to2, slice);
        return this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(from, to2, node) {
        replaceRangeWith(this, from, to2, node);
        return this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(from, to2) {
        deleteRange$1(this, from, to2);
        return this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(range2, target) {
        lift$2(this, range2, target);
        return this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(pos, depth = 1) {
        join(this, pos, depth);
        return this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(range2, wrappers) {
        wrap(this, range2, wrappers);
        return this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(from, to2 = from, type, attrs = null) {
        setBlockType$1(this, from, to2, type, attrs);
        return this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(pos, type, attrs = null, marks) {
        setNodeMarkup(this, pos, type, attrs, marks);
        return this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(pos, attr, value) {
        this.step(new AttrStep(pos, attr, value));
        return this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(attr, value) {
        this.step(new DocAttrStep(attr, value));
        return this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(pos, mark) {
        this.step(new AddNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(pos, mark) {
        if (!(mark instanceof Mark$1)) {
          let node = this.doc.nodeAt(pos);
          if (!node)
            throw new RangeError("No node at position " + pos);
          mark = mark.isInSet(node.marks);
          if (!mark)
            return this;
        }
        this.step(new RemoveNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(pos, depth = 1, typesAfter) {
        split(this, pos, depth, typesAfter);
        return this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(from, to2, mark) {
        addMark(this, from, to2, mark);
        return this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(from, to2, mark) {
        removeMark(this, from, to2, mark);
        return this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(pos, parentType, match) {
        clearIncompatible(this, pos, parentType, match);
        return this;
      }
    }
    const classesById = /* @__PURE__ */ Object.create(null);
    class Selection {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor($anchor, $head, ranges) {
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++)
          if (ranges[i2].$from.pos != ranges[i2].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(tr2, content = Slice.empty) {
        let lastNode = content.content.lastChild, lastParent = null;
        for (let i2 = 0; i2 < content.openEnd; i2++) {
          lastParent = lastNode;
          lastNode = lastNode.lastChild;
        }
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
          tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
          if (i2 == 0)
            selectionToInsertionEnd$1(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(tr2, node) {
        let mapFrom = tr2.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr2.mapping.slice(mapFrom);
          let from = mapping.map($from.pos), to2 = mapping.map($to.pos);
          if (i2) {
            tr2.deleteRange(from, to2);
          } else {
            tr2.replaceRangeWith(from, to2, node);
            selectionToInsertionEnd$1(tr2, mapFrom, node.isInline ? -1 : 1);
          }
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom($pos, dir, textOnly = false) {
        let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner)
          return inner;
        for (let depth = $pos.depth - 1; depth >= 0; depth--) {
          let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
          if (found2)
            return found2;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near($pos, bias = 1) {
        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(doc2) {
        return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(doc2) {
        return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(doc2, json) {
        if (!json || !json.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let cls = classesById[json.type];
        if (!cls)
          throw new RangeError(`No selection type ${json.type} defined`);
        return cls.fromJSON(doc2, json);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(id2, selectionClass) {
        if (id2 in classesById)
          throw new RangeError("Duplicate use of selection JSON ID " + id2);
        classesById[id2] = selectionClass;
        selectionClass.prototype.jsonID = id2;
        return selectionClass;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
      }
    }
    Selection.prototype.visible = true;
    class SelectionRange {
      /**
      Create a range.
      */
      constructor($from, $to) {
        this.$from = $from;
        this.$to = $to;
      }
    }
    let warnedAboutTextSelection = false;
    function checkTextSelection($pos) {
      if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
        warnedAboutTextSelection = true;
        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
      }
    }
    class TextSelection extends Selection {
      /**
      Construct a text selection between the given points.
      */
      constructor($anchor, $head = $anchor) {
        checkTextSelection($anchor);
        checkTextSelection($head);
        super($anchor, $head);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(doc2, mapping) {
        let $head = doc2.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent)
          return Selection.near($head);
        let $anchor = doc2.resolve(mapping.map(this.anchor));
        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
      }
      replace(tr2, content = Slice.empty) {
        super.replace(tr2, content);
        if (content == Slice.empty) {
          let marks = this.$from.marksAcross(this.$to);
          if (marks)
            tr2.ensureMarks(marks);
        }
      }
      eq(other) {
        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
      }
      getBookmark() {
        return new TextBookmark(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc2, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(doc2, anchor, head = anchor) {
        let $anchor = doc2.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between($anchor, $head, bias) {
        let dPos = $anchor.pos - $head.pos;
        if (!bias || dPos)
          bias = dPos >= 0 ? 1 : -1;
        if (!$head.parent.inlineContent) {
          let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
          if (found2)
            $head = found2.$head;
          else
            return Selection.near($head, bias);
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0)
              $anchor = $head;
          }
        }
        return new TextSelection($anchor, $head);
      }
    }
    Selection.jsonID("text", TextSelection);
    class TextBookmark {
      constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      map(mapping) {
        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
      }
      resolve(doc2) {
        return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
      }
    }
    class NodeSelection extends Selection {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor($pos) {
        let node = $pos.nodeAfter;
        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        super($pos, $end);
        this.node = node;
      }
      map(doc2, mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        let $pos = doc2.resolve(pos);
        if (deleted)
          return Selection.near($pos);
        return new NodeSelection($pos);
      }
      content() {
        return new Slice(Fragment.from(this.node), 0, 0);
      }
      eq(other) {
        return other instanceof NodeSelection && other.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new NodeBookmark(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(doc2, json) {
        if (typeof json.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new NodeSelection(doc2.resolve(json.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(doc2, from) {
        return new NodeSelection(doc2.resolve(from));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
      }
    }
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    class NodeBookmark {
      constructor(anchor) {
        this.anchor = anchor;
      }
      map(mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
      }
      resolve(doc2) {
        let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node))
          return new NodeSelection($pos);
        return Selection.near($pos);
      }
    }
    class AllSelection extends Selection {
      /**
      Create an all-selection over the given document.
      */
      constructor(doc2) {
        super(doc2.resolve(0), doc2.resolve(doc2.content.size));
      }
      replace(tr2, content = Slice.empty) {
        if (content == Slice.empty) {
          tr2.delete(0, tr2.doc.content.size);
          let sel = Selection.atStart(tr2.doc);
          if (!sel.eq(tr2.selection))
            tr2.setSelection(sel);
        } else {
          super.replace(tr2, content);
        }
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(doc2) {
        return new AllSelection(doc2);
      }
      map(doc2) {
        return new AllSelection(doc2);
      }
      eq(other) {
        return other instanceof AllSelection;
      }
      getBookmark() {
        return AllBookmark;
      }
    }
    Selection.jsonID("all", AllSelection);
    const AllBookmark = {
      map() {
        return this;
      },
      resolve(doc2) {
        return new AllSelection(doc2);
      }
    };
    function findSelectionIn(doc2, node, pos, index, dir, text = false) {
      if (node.inlineContent)
        return TextSelection.create(doc2, pos);
      for (let i2 = index - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
        let child = node.child(i2);
        if (!child.isAtom) {
          let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner)
            return inner;
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
      }
      return null;
    }
    function selectionToInsertionEnd$1(tr2, startLen, bias) {
      let last = tr2.steps.length - 1;
      if (last < startLen)
        return;
      let step = tr2.steps[last];
      if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
        return;
      let map = tr2.mapping.maps[last], end;
      map.forEach((_from, _to, _newFrom, newTo) => {
        if (end == null)
          end = newTo;
      });
      tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
    }
    const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
    class Transaction extends Transform {
      /**
      @internal
      */
      constructor(state) {
        super(state.doc);
        this.curSelectionFor = 0;
        this.updated = 0;
        this.meta = /* @__PURE__ */ Object.create(null);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.storedMarks = state.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(selection) {
        if (selection.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & -3;
        this.storedMarks = null;
        return this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & UPDATED_SEL) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(marks) {
        this.storedMarks = marks;
        this.updated |= UPDATED_MARKS;
        return this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(marks) {
        if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
          this.setStoredMarks(marks);
        return this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & UPDATED_MARKS) > 0;
      }
      /**
      @internal
      */
      addStep(step, doc2) {
        super.addStep(step, doc2);
        this.updated = this.updated & -3;
        this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(time2) {
        this.time = time2;
        return this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(slice) {
        this.selection.replace(this, slice);
        return this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(node, inheritMarks = true) {
        let selection = this.selection;
        if (inheritMarks)
          node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
        selection.replaceWith(this, node);
        return this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        this.selection.replace(this);
        return this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(text, from, to2) {
        let schema = this.doc.type.schema;
        if (from == null) {
          if (!text)
            return this.deleteSelection();
          return this.replaceSelectionWith(schema.text(text), true);
        } else {
          if (to2 == null)
            to2 = from;
          to2 = to2 == null ? from : to2;
          if (!text)
            return this.deleteRange(from, to2);
          let marks = this.storedMarks;
          if (!marks) {
            let $from = this.doc.resolve(from);
            marks = to2 == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
          }
          this.replaceRangeWith(from, to2, schema.text(text, marks));
          if (!this.selection.empty)
            this.setSelection(Selection.near(this.selection.$to));
          return this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let _ in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & UPDATED_SCROLL) > 0;
      }
    }
    function bind(f, self2) {
      return !self2 || !f ? f : f.bind(self2);
    }
    class FieldDesc {
      constructor(name, desc, self2) {
        this.name = name;
        this.init = bind(desc.init, self2);
        this.apply = bind(desc.apply, self2);
      }
    }
    const baseFields = [
      new FieldDesc("doc", {
        init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply(tr2) {
          return tr2.doc;
        }
      }),
      new FieldDesc("selection", {
        init(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply(tr2) {
          return tr2.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init(config) {
          return config.storedMarks || null;
        },
        apply(tr2, _marks, _old, state) {
          return state.selection.$cursor ? tr2.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init() {
          return 0;
        },
        apply(tr2, prev) {
          return tr2.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    class Configuration {
      constructor(schema, plugins) {
        this.schema = schema;
        this.plugins = [];
        this.pluginsByKey = /* @__PURE__ */ Object.create(null);
        this.fields = baseFields.slice();
        if (plugins)
          plugins.forEach((plugin2) => {
            if (this.pluginsByKey[plugin2.key])
              throw new RangeError("Adding different instances of a keyed plugin (" + plugin2.key + ")");
            this.plugins.push(plugin2);
            this.pluginsByKey[plugin2.key] = plugin2;
            if (plugin2.spec.state)
              this.fields.push(new FieldDesc(plugin2.key, plugin2.spec.state, plugin2));
          });
      }
    }
    class EditorState {
      /**
      @internal
      */
      constructor(config) {
        this.config = config;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(tr2) {
        return this.applyTransaction(tr2).state;
      }
      /**
      @internal
      */
      filterTransaction(tr2, ignore = -1) {
        for (let i2 = 0; i2 < this.config.plugins.length; i2++)
          if (i2 != ignore) {
            let plugin2 = this.config.plugins[i2];
            if (plugin2.spec.filterTransaction && !plugin2.spec.filterTransaction.call(plugin2, tr2, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(rootTr) {
        if (!this.filterTransaction(rootTr))
          return { state: this, transactions: [] };
        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
        for (; ; ) {
          let haveNew = false;
          for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
            let plugin2 = this.config.plugins[i2];
            if (plugin2.spec.appendTransaction) {
              let n = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
              let tr2 = n < trs.length && plugin2.spec.appendTransaction.call(plugin2, n ? trs.slice(n) : trs, oldState, newState);
              if (tr2 && newState.filterTransaction(tr2, i2)) {
                tr2.setMeta("appendedTransaction", rootTr);
                if (!seen) {
                  seen = [];
                  for (let j = 0; j < this.config.plugins.length; j++)
                    seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
                }
                trs.push(tr2);
                newState = newState.applyInner(tr2);
                haveNew = true;
              }
              if (seen)
                seen[i2] = { state: newState, n: trs.length };
            }
          }
          if (!haveNew)
            return { state: newState, transactions: trs };
        }
      }
      /**
      @internal
      */
      applyInner(tr2) {
        if (!tr2.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let newInstance = new EditorState(this.config), fields = this.config.fields;
        for (let i2 = 0; i2 < fields.length; i2++) {
          let field = fields[i2];
          newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
        }
        return newInstance;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new Transaction(this);
      }
      /**
      Create a new state.
      */
      static create(config) {
        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
        let instance = new EditorState($config);
        for (let i2 = 0; i2 < $config.fields.length; i2++)
          instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
        return instance;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(config) {
        let $config = new Configuration(this.schema, config.plugins);
        let fields = $config.fields, instance = new EditorState($config);
        for (let i2 = 0; i2 < fields.length; i2++) {
          let name = fields[i2].name;
          instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
        }
        return instance;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(pluginFields) {
        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks)
          result.storedMarks = this.storedMarks.map((m) => m.toJSON());
        if (pluginFields && typeof pluginFields == "object")
          for (let prop in pluginFields) {
            if (prop == "doc" || prop == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let plugin2 = pluginFields[prop], state = plugin2.spec.state;
            if (state && state.toJSON)
              result[prop] = state.toJSON.call(plugin2, this[plugin2.key]);
          }
        return result;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(config, json, pluginFields) {
        if (!json)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!config.schema)
          throw new RangeError("Required config field 'schema' missing");
        let $config = new Configuration(config.schema, config.plugins);
        let instance = new EditorState($config);
        $config.fields.forEach((field) => {
          if (field.name == "doc") {
            instance.doc = Node$1.fromJSON(config.schema, json.doc);
          } else if (field.name == "selection") {
            instance.selection = Selection.fromJSON(instance.doc, json.selection);
          } else if (field.name == "storedMarks") {
            if (json.storedMarks)
              instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
          } else {
            if (pluginFields)
              for (let prop in pluginFields) {
                let plugin2 = pluginFields[prop], state = plugin2.spec.state;
                if (plugin2.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                  instance[field.name] = state.fromJSON.call(plugin2, config, json[prop], instance);
                  return;
                }
              }
            instance[field.name] = field.init(config, instance);
          }
        });
        return instance;
      }
    }
    function bindProps(obj, self2, target) {
      for (let prop in obj) {
        let val = obj[prop];
        if (val instanceof Function)
          val = val.bind(self2);
        else if (prop == "handleDOMEvents")
          val = bindProps(val, self2, {});
        target[prop] = val;
      }
      return target;
    }
    class Plugin {
      /**
      Create a plugin.
      */
      constructor(spec) {
        this.spec = spec;
        this.props = {};
        if (spec.props)
          bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    }
    const keys = /* @__PURE__ */ Object.create(null);
    function createKey(name) {
      if (name in keys)
        return name + "$" + ++keys[name];
      keys[name] = 0;
      return name + "$";
    }
    class PluginKey {
      /**
      Create a plugin key.
      */
      constructor(name = "key") {
        this.key = createKey(name);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(state) {
        return state.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    }
    const domIndex = function(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling;
        if (!node)
          return index;
      }
    };
    const parentNode = function(node) {
      let parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    let reusedRange = null;
    const textRange = function(node, from, to2) {
      let range2 = reusedRange || (reusedRange = document.createRange());
      range2.setEnd(node, to2 == null ? node.nodeValue.length : to2);
      range2.setStart(node, from || 0);
      return range2;
    };
    const clearReusedRange = function() {
      reusedRange = null;
    };
    const isEquivalentPosition = function(node, off2, targetNode, targetOff) {
      return targetNode && (scanFor(node, off2, targetNode, targetOff, -1) || scanFor(node, off2, targetNode, targetOff, 1));
    };
    const atomElements = /^(img|br|input|textarea|hr)$/i;
    function scanFor(node, off2, targetNode, targetOff, dir) {
      for (; ; ) {
        if (node == targetNode && off2 == targetOff)
          return true;
        if (off2 == (dir < 0 ? 0 : nodeSize(node))) {
          let parent = node.parentNode;
          if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
            return false;
          off2 = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off2 + (dir < 0 ? -1 : 0)];
          if (node.contentEditable == "false")
            return false;
          off2 = dir < 0 ? nodeSize(node) : 0;
        } else {
          return false;
        }
      }
    }
    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function textNodeBefore$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset)
          return node;
        if (node.nodeType == 1 && offset > 0) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node);
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function textNodeAfter$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset < node.nodeValue.length)
          return node;
        if (node.nodeType == 1 && offset < node.childNodes.length) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset];
          offset = 0;
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node) + 1;
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function isOnEdge(node, offset, parent) {
      for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
        if (node == parent)
          return true;
        let index = domIndex(node);
        node = node.parentNode;
        if (!node)
          return false;
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
      }
    }
    function hasBlockDesc(dom) {
      let desc;
      for (let cur = dom; cur; cur = cur.parentNode)
        if (desc = cur.pmViewDesc)
          break;
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
    }
    const selectionCollapsed = function(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    function keyEvent(keyCode, key) {
      let event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event;
    }
    function deepActiveElement(doc2) {
      let elt = doc2.activeElement;
      while (elt && elt.shadowRoot)
        elt = elt.shadowRoot.activeElement;
      return elt;
    }
    function caretFromPoint(doc2, x, y) {
      if (doc2.caretPositionFromPoint) {
        try {
          let pos = doc2.caretPositionFromPoint(x, y);
          if (pos)
            return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
        } catch (_) {
        }
      }
      if (doc2.caretRangeFromPoint) {
        let range2 = doc2.caretRangeFromPoint(x, y);
        if (range2)
          return { node: range2.startContainer, offset: Math.min(nodeSize(range2.startContainer), range2.startOffset) };
      }
    }
    const nav = typeof navigator != "undefined" ? navigator : null;
    const doc = typeof document != "undefined" ? document : null;
    const agent = nav && nav.userAgent || "";
    const ie_edge = /Edge\/(\d+)/.exec(agent);
    const ie_upto10 = /MSIE \d/.exec(agent);
    const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
    const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
    const chrome = !!_chrome;
    const chrome_version = _chrome ? +_chrome[1] : 0;
    const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
    const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
    const windows = nav ? /Win/.test(nav.platform) : false;
    const android = /Android \d/.test(agent);
    const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
    const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function windowRect(doc2) {
      let vp2 = doc2.defaultView && doc2.defaultView.visualViewport;
      if (vp2)
        return {
          left: 0,
          right: vp2.width,
          top: 0,
          bottom: vp2.height
        };
      return {
        left: 0,
        right: doc2.documentElement.clientWidth,
        top: 0,
        bottom: doc2.documentElement.clientHeight
      };
    }
    function getSide(value, side) {
      return typeof value == "number" ? value : value[side];
    }
    function clientRect(node) {
      let rect = node.getBoundingClientRect();
      let scaleX = rect.width / node.offsetWidth || 1;
      let scaleY = rect.height / node.offsetHeight || 1;
      return {
        left: rect.left,
        right: rect.left + node.clientWidth * scaleX,
        top: rect.top,
        bottom: rect.top + node.clientHeight * scaleY
      };
    }
    function scrollRectIntoView(view, rect, startDOM) {
      let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      let doc2 = view.dom.ownerDocument;
      for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
        if (!parent)
          break;
        if (parent.nodeType != 1)
          continue;
        let elt = parent;
        let atTop = elt == doc2.body;
        let bounding = atTop ? windowRect(doc2) : clientRect(elt);
        let moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
          moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
          moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
          moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
          moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        if (moveX || moveY) {
          if (atTop) {
            doc2.defaultView.scrollBy(moveX, moveY);
          } else {
            let startX = elt.scrollLeft, startY = elt.scrollTop;
            if (moveY)
              elt.scrollTop += moveY;
            if (moveX)
              elt.scrollLeft += moveX;
            let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
            rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
          }
        }
        if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
          break;
      }
    }
    function storeScrollPos(view) {
      let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      let refDOM, refTop;
      for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        let dom = view.root.elementFromPoint(x, y);
        if (!dom || dom == view.dom || !view.dom.contains(dom))
          continue;
        let localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break;
        }
      }
      return { refDOM, refTop, stack: scrollStack(view.dom) };
    }
    function scrollStack(dom) {
      let stack2 = [], doc2 = dom.ownerDocument;
      for (let cur = dom; cur; cur = parentNode(cur)) {
        stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
        if (dom == doc2)
          break;
      }
      return stack2;
    }
    function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
      let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
    }
    function restoreScrollStack(stack2, dTop) {
      for (let i2 = 0; i2 < stack2.length; i2++) {
        let { dom, top, left } = stack2[i2];
        if (dom.scrollTop != top + dTop)
          dom.scrollTop = top + dTop;
        if (dom.scrollLeft != left)
          dom.scrollLeft = left;
      }
    }
    let preventScrollSupported = null;
    function focusPreventScroll(dom) {
      if (dom.setActive)
        return dom.setActive();
      if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
      let stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = { preventScroll: true };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }
    function findOffsetInNode(node, coords) {
      let closest, dxClosest = 2e8, coordsClosest, offset = 0;
      let rowBot = coords.top, rowTop = coords.top;
      let firstBelow, coordsBelow;
      for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        let rects;
        if (child.nodeType == 1)
          rects = child.getClientRects();
        else if (child.nodeType == 3)
          rects = textRange(child).getClientRects();
        else
          continue;
        for (let i2 = 0; i2 < rects.length; i2++) {
          let rect = rects[i2];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? {
                left: rect.right < coords.left ? rect.right : rect.left,
                top: coords.top
              } : coords;
              if (child.nodeType == 1 && dx)
                offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
              continue;
            }
          } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
            firstBelow = child;
            coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
            offset = childIndex + 1;
        }
      }
      if (!closest && firstBelow) {
        closest = firstBelow;
        coordsClosest = coordsBelow;
        dxClosest = 0;
      }
      if (closest && closest.nodeType == 3)
        return findOffsetInText(closest, coordsClosest);
      if (!closest || dxClosest && closest.nodeType == 1)
        return { node, offset };
      return findOffsetInNode(closest, coordsClosest);
    }
    function findOffsetInText(node, coords) {
      let len = node.nodeValue.length;
      let range2 = document.createRange();
      for (let i2 = 0; i2 < len; i2++) {
        range2.setEnd(node, i2 + 1);
        range2.setStart(node, i2);
        let rect = singleRect(range2, 1);
        if (rect.top == rect.bottom)
          continue;
        if (inRect(coords, rect))
          return { node, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      }
      return { node, offset: 0 };
    }
    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
    }
    function targetKludge(dom, coords) {
      let parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
        return parent;
      return dom;
    }
    function posFromElement(view, elt, coords) {
      let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        let rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias);
    }
    function posFromCaret(view, node, offset, coords) {
      let outsideBlock = -1;
      for (let cur = node, sawBlock = false; ; ) {
        if (cur == view.dom)
          break;
        let desc = view.docView.nearestDesc(cur, true), rect;
        if (!desc)
          return null;
        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
        ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
          if (desc.node.isBlock && desc.parent) {
            if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
              outsideBlock = desc.posBefore;
            else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
              outsideBlock = desc.posAfter;
            sawBlock = true;
          }
          if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
            let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
            return before ? desc.posBefore : desc.posAfter;
          }
        }
        cur = desc.dom.parentNode;
      }
      return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
    }
    function elementFromPoint(element, coords, box) {
      let len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
          let child = element.childNodes[i2];
          if (child.nodeType == 1) {
            let rects = child.getClientRects();
            for (let j = 0; j < rects.length; j++) {
              let rect = rects[j];
              if (inRect(coords, rect))
                return elementFromPoint(child, coords, rect);
            }
          }
          if ((i2 = (i2 + 1) % len) == startI)
            break;
        }
      }
      return element;
    }
    function posAtCoords(view, coords) {
      let doc2 = view.dom.ownerDocument, node, offset = 0;
      let caret = caretFromPoint(doc2, coords.left, coords.top);
      if (caret)
        ({ node, offset } = caret);
      let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
      let pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        let box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box))
          return null;
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt)
          return null;
      }
      if (safari) {
        for (let p2 = elt; node && p2; p2 = parentNode(p2))
          if (p2.draggable)
            node = void 0;
      }
      elt = targetKludge(elt, coords);
      if (node) {
        if (gecko && node.nodeType == 1) {
          offset = Math.min(offset, node.childNodes.length);
          if (offset < node.childNodes.length) {
            let next = node.childNodes[offset], box;
            if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
              offset++;
          }
        }
        let prev;
        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
          offset--;
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
          pos = view.state.doc.content.size;
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
          pos = posFromCaret(view, node, offset, coords);
      }
      if (pos == null)
        pos = posFromElement(view, elt, coords);
      let desc = view.docView.nearestDesc(elt, true);
      return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
    }
    function nonZero(rect) {
      return rect.top < rect.bottom || rect.left < rect.right;
    }
    function singleRect(target, bias) {
      let rects = target.getClientRects();
      if (rects.length) {
        let first2 = rects[bias < 0 ? 0 : rects.length - 1];
        if (nonZero(first2))
          return first2;
      }
      return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
    }
    const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function coordsAtPos(view, pos, side) {
      let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
      let supportEmptyRange = webkit || gecko;
      if (node.nodeType == 3) {
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          let rect = singleRect(textRange(node, offset, offset), side);
          if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top)
                return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
          return rect;
        } else {
          let from = offset, to2 = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) {
            to2++;
            takeSide = -1;
          } else if (side >= 0 && offset == node.nodeValue.length) {
            from--;
            takeSide = 1;
          } else if (side < 0) {
            from--;
          } else {
            to2++;
          }
          return flattenV(singleRect(textRange(node, from, to2), takeSide), takeSide < 0);
        }
      }
      let $dom = view.state.doc.resolve(pos - (atom || 0));
      if (!$dom.parent.inlineContent) {
        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
          let before = node.childNodes[offset - 1];
          if (before.nodeType == 1)
            return flattenH(before.getBoundingClientRect(), false);
        }
        if (atom == null && offset < nodeSize(node)) {
          let after = node.childNodes[offset];
          if (after.nodeType == 1)
            return flattenH(after.getBoundingClientRect(), true);
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
      }
      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
        let before = node.childNodes[offset - 1];
        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
        if (target)
          return flattenV(singleRect(target, 1), false);
      }
      if (atom == null && offset < nodeSize(node)) {
        let after = node.childNodes[offset];
        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
          after = after.nextSibling;
        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
        if (target)
          return flattenV(singleRect(target, -1), true);
      }
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
    }
    function flattenV(rect, left) {
      if (rect.width == 0)
        return rect;
      let x = left ? rect.left : rect.right;
      return { top: rect.top, bottom: rect.bottom, left: x, right: x };
    }
    function flattenH(rect, top) {
      if (rect.height == 0)
        return rect;
      let y = top ? rect.top : rect.bottom;
      return { top: y, bottom: y, left: rect.left, right: rect.right };
    }
    function withFlushedState(view, state, f) {
      let viewState = view.state, active = view.root.activeElement;
      if (viewState != state)
        view.updateState(state);
      if (active != view.dom)
        view.focus();
      try {
        return f();
      } finally {
        if (viewState != state)
          view.updateState(viewState);
        if (active != view.dom && active)
          active.focus();
      }
    }
    function endOfTextblockVertical(view, state, dir) {
      let sel = state.selection;
      let $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state, () => {
        let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
        for (; ; ) {
          let nearest = view.docView.nearestDesc(dom, true);
          if (!nearest)
            break;
          if (nearest.node.isBlock) {
            dom = nearest.contentDOM || nearest.dom;
            break;
          }
          dom = nearest.dom.parentNode;
        }
        let coords = coordsAtPos(view, $pos.pos, 1);
        for (let child = dom.firstChild; child; child = child.nextSibling) {
          let boxes;
          if (child.nodeType == 1)
            boxes = child.getClientRects();
          else if (child.nodeType == 3)
            boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
          else
            continue;
          for (let i2 = 0; i2 < boxes.length; i2++) {
            let box = boxes[i2];
            if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    const maybeRTL = /[\u0590-\u08ac]/;
    function endOfTextblockHorizontal(view, state, dir) {
      let { $head } = state.selection;
      if (!$head.parent.isTextblock)
        return false;
      let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      let sel = view.domSelection();
      if (!sel)
        return $head.pos == $head.start() || $head.pos == $head.end();
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
        return dir == "left" || dir == "backward" ? atStart : atEnd;
      return withFlushedState(view, state, () => {
        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
        let oldBidiLevel = sel.caretBidiLevel;
        sel.modify("move", dir, "character");
        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
        try {
          sel.collapse(anchorNode, anchorOffset);
          if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
            sel.extend(oldNode, oldOff);
        } catch (_) {
        }
        if (oldBidiLevel != null)
          sel.caretBidiLevel = oldBidiLevel;
        return result;
      });
    }
    let cachedState = null;
    let cachedDir = null;
    let cachedResult = false;
    function endOfTextblock(view, state, dir) {
      if (cachedState == state && cachedDir == dir)
        return cachedResult;
      cachedState = state;
      cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
    }
    const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
    class ViewDesc {
      constructor(parent, children, dom, contentDOM) {
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        dom.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(widget) {
        return false;
      }
      matchesMark(mark) {
        return false;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return false;
      }
      matchesHack(nodeName) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(event) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let size2 = 0;
        for (let i2 = 0; i2 < this.children.length; i2++)
          size2 += this.children[i2].size;
        return size2;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0;
        if (this.dom.pmViewDesc == this)
          this.dom.pmViewDesc = void 0;
        for (let i2 = 0; i2 < this.children.length; i2++)
          this.children[i2].destroy();
      }
      posBeforeChild(child) {
        for (let i2 = 0, pos = this.posAtStart; ; i2++) {
          let cur = this.children[i2];
          if (cur == child)
            return pos;
          pos += cur.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(dom, offset, bias) {
        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
          if (bias < 0) {
            let domBefore, desc;
            if (dom == this.contentDOM) {
              domBefore = dom.childNodes[offset - 1];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domBefore = dom.previousSibling;
            }
            while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
              domBefore = domBefore.previousSibling;
            return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
          } else {
            let domAfter, desc;
            if (dom == this.contentDOM) {
              domAfter = dom.childNodes[offset];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domAfter = dom.nextSibling;
            }
            while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
              domAfter = domAfter.nextSibling;
            return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
          }
        }
        let atEnd;
        if (dom == this.dom && this.contentDOM) {
          atEnd = offset > domIndex(this.contentDOM);
        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
          atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
        } else if (this.dom.firstChild) {
          if (offset == 0)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = false;
                break;
              }
              if (search.previousSibling)
                break;
            }
          if (atEnd == null && offset == dom.childNodes.length)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = true;
                break;
              }
              if (search.nextSibling)
                break;
            }
        }
        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(dom, onlyNodes = false) {
        for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
          let desc = this.getDesc(cur), nodeDOM;
          if (desc && (!onlyNodes || desc.node)) {
            if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
              first2 = false;
            else
              return desc;
          }
        }
      }
      getDesc(dom) {
        let desc = dom.pmViewDesc;
        for (let cur = desc; cur; cur = cur.parent)
          if (cur == this)
            return desc;
      }
      posFromDOM(dom, offset, bias) {
        for (let scan = dom; scan; scan = scan.parentNode) {
          let desc = this.getDesc(scan);
          if (desc)
            return desc.localPosFromDOM(dom, offset, bias);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(pos) {
        for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (offset == pos && end != offset) {
            while (!child.border && child.children.length) {
              for (let i3 = 0; i3 < child.children.length; i3++) {
                let inner = child.children[i3];
                if (inner.size) {
                  child = inner;
                  break;
                }
              }
            }
            return child;
          }
          if (pos < end)
            return child.descAt(pos - offset - child.border);
          offset = end;
        }
      }
      domFromPos(pos, side) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: pos + 1 };
        let i2 = 0, offset = 0;
        for (let curPos = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = curPos + child.size;
          if (end > pos || child instanceof TrailingHackViewDesc) {
            offset = pos - curPos;
            break;
          }
          curPos = end;
        }
        if (offset)
          return this.children[i2].domFromPos(offset - this.children[i2].border, side);
        for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
        }
        if (side <= 0) {
          let prev, enter2 = true;
          for (; ; i2--, enter2 = false) {
            prev = i2 ? this.children[i2 - 1] : null;
            if (!prev || prev.dom.parentNode == this.contentDOM)
              break;
          }
          if (prev && side && enter2 && !prev.border && !prev.domAtom)
            return prev.domFromPos(prev.size, side);
          return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
        } else {
          let next, enter2 = true;
          for (; ; i2++, enter2 = false) {
            next = i2 < this.children.length ? this.children[i2] : null;
            if (!next || next.dom.parentNode == this.contentDOM)
              break;
          }
          if (next && enter2 && !next.border && !next.domAtom)
            return next.domFromPos(0, side);
          return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(from, to2, base2 = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let fromOffset = -1, toOffset = -1;
        for (let offset = base2, i2 = 0; ; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (fromOffset == -1 && from <= end) {
            let childBase = offset + child.border;
            if (from >= childBase && to2 <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
              return child.parseRange(from, to2, childBase);
            from = offset;
            for (let j = i2; j > 0; j--) {
              let prev = this.children[j - 1];
              if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                fromOffset = domIndex(prev.dom) + 1;
                break;
              }
              from -= prev.size;
            }
            if (fromOffset == -1)
              fromOffset = 0;
          }
          if (fromOffset > -1 && (end > to2 || i2 == this.children.length - 1)) {
            to2 = end;
            for (let j = i2 + 1; j < this.children.length; j++) {
              let next = this.children[j];
              if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                toOffset = domIndex(next.dom);
                break;
              }
              to2 += next.size;
            }
            if (toOffset == -1)
              toOffset = this.contentDOM.childNodes.length;
            break;
          }
          offset = end;
        }
        return { node: this.contentDOM, from, to: to2, fromOffset, toOffset };
      }
      emptyChildAt(side) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let child = this.children[side < 0 ? 0 : this.children.length - 1];
        return child.size == 0 || child.emptyChildAt(side);
      }
      domAfterPos(pos) {
        let { node, offset } = this.domFromPos(pos, 0);
        if (node.nodeType != 1 || offset == node.childNodes.length)
          throw new RangeError("No node after pos " + pos);
        return node.childNodes[offset];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(anchor, head, view, force = false) {
        let from = Math.min(anchor, head), to2 = Math.max(anchor, head);
        for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (from > offset && to2 < end)
            return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);
          offset = end;
        }
        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
        let domSel = view.root.getSelection();
        let selRange = view.domSelectionRange();
        let brKludge = false;
        if ((gecko || safari) && anchor == head) {
          let { node, offset } = anchorDOM;
          if (node.nodeType == 3) {
            brKludge = !!(offset && node.nodeValue[offset - 1] == "\n");
            if (brKludge && offset == node.nodeValue.length) {
              for (let scan = node, after; scan; scan = scan.parentNode) {
                if (after = scan.nextSibling) {
                  if (after.nodeName == "BR")
                    anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                  break;
                }
                let desc = scan.pmViewDesc;
                if (desc && desc.node && desc.node.isBlock)
                  break;
              }
            }
          } else {
            let prev = node.childNodes[offset - 1];
            brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
          }
        }
        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
          let after = selRange.focusNode.childNodes[selRange.focusOffset];
          if (after && after.contentEditable == "false")
            force = true;
        }
        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
          return;
        let domSelExtended = false;
        if ((domSel.extend || anchor == head) && !brKludge) {
          domSel.collapse(anchorDOM.node, anchorDOM.offset);
          try {
            if (anchor != head)
              domSel.extend(headDOM.node, headDOM.offset);
            domSelExtended = true;
          } catch (_) {
          }
        }
        if (!domSelExtended) {
          if (anchor > head) {
            let tmp = anchorDOM;
            anchorDOM = headDOM;
            headDOM = tmp;
          }
          let range2 = document.createRange();
          range2.setEnd(headDOM.node, headDOM.offset);
          range2.setStart(anchorDOM.node, anchorDOM.offset);
          domSel.removeAllRanges();
          domSel.addRange(range2);
        }
      }
      ignoreMutation(mutation) {
        return !this.contentDOM && mutation.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(from, to2) {
        for (let offset = 0, i2 = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (offset == end ? from <= end && to2 >= offset : from < end && to2 > offset) {
            let startInside = offset + child.border, endInside = end - child.border;
            if (from >= startInside && to2 <= endInside) {
              this.dirty = from == offset || to2 == end ? CONTENT_DIRTY : CHILD_DIRTY;
              if (from == startInside && to2 == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
                child.dirty = NODE_DIRTY;
              else
                child.markDirty(from - startInside, to2 - startInside);
              return;
            } else {
              child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
            }
          }
          offset = end;
        }
        this.dirty = CONTENT_DIRTY;
      }
      markParentsDirty() {
        let level = 1;
        for (let node = this.parent; node; node = node.parent, level++) {
          let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (node.dirty < dirty)
            node.dirty = dirty;
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      isText(text) {
        return false;
      }
    }
    class WidgetViewDesc extends ViewDesc {
      constructor(parent, widget, view, pos) {
        let self2, dom = widget.type.toDOM;
        if (typeof dom == "function")
          dom = dom(view, () => {
            if (!self2)
              return pos;
            if (self2.parent)
              return self2.parent.posBeforeChild(self2);
          });
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            let wrap2 = document.createElement("span");
            wrap2.appendChild(dom);
            dom = wrap2;
          }
          dom.contentEditable = "false";
          dom.classList.add("ProseMirror-widget");
        }
        super(parent, [], dom, null);
        this.widget = widget;
        this.widget = widget;
        self2 = this;
      }
      matchesWidget(widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(event) {
        let stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false;
      }
      ignoreMutation(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom);
        super.destroy();
      }
      get domAtom() {
        return true;
      }
      get side() {
        return this.widget.type.side;
      }
    }
    class CompositionViewDesc extends ViewDesc {
      constructor(parent, dom, textDOM, text) {
        super(parent, [], dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(dom, offset) {
        if (dom != this.textDOM)
          return this.posAtStart + (offset ? this.size : 0);
        return this.posAtStart + offset;
      }
      domFromPos(pos) {
        return { node: this.textDOM, offset: pos };
      }
      ignoreMutation(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      }
    }
    class MarkViewDesc extends ViewDesc {
      constructor(parent, mark, dom, contentDOM, spec) {
        super(parent, [], dom, contentDOM);
        this.mark = mark;
        this.spec = spec;
      }
      static create(parent, mark, inline, view) {
        let custom = view.nodeViews[mark.type.name];
        let spec = custom && custom(mark, view, inline);
        if (!spec || !spec.dom)
          spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
      }
      parseRule() {
        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
          return null;
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(mark) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark);
      }
      markDirty(from, to2) {
        super.markDirty(from, to2);
        if (this.dirty != NOT_DIRTY) {
          let parent = this.parent;
          while (!parent.node)
            parent = parent.parent;
          if (parent.dirty < this.dirty)
            parent.dirty = this.dirty;
          this.dirty = NOT_DIRTY;
        }
      }
      slice(from, to2, view) {
        let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
        let nodes = this.children, size2 = this.size;
        if (to2 < size2)
          nodes = replaceNodes(nodes, to2, size2, view);
        if (from > 0)
          nodes = replaceNodes(nodes, 0, from, view);
        for (let i2 = 0; i2 < nodes.length; i2++)
          nodes[i2].parent = copy2;
        copy2.children = nodes;
        return copy2;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
    }
    class NodeViewDesc extends ViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        super(parent, [], dom, contentDOM);
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        this.nodeDOM = nodeDOM;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(parent, node, outerDeco, innerDeco, view, pos) {
        let custom = view.nodeViews[node.type.name], descObj;
        let spec = custom && custom(node, view, () => {
          if (!descObj)
            return pos;
          if (descObj.parent)
            return descObj.parent.posBeforeChild(descObj);
        }, outerDeco, innerDeco);
        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
          if (!dom)
            dom = document.createTextNode(node.text);
          else if (dom.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!dom) {
          let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
          ({ dom, contentDOM } = spec2);
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable"))
            dom.contentEditable = "false";
          if (node.type.spec.draggable)
            dom.draggable = true;
        }
        let nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);
        if (spec)
          return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
        else if (node.isText)
          return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
        else
          return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre")
          rule.preserveWhitespace = "full";
        if (!this.contentDOM) {
          rule.getContent = () => this.node.content;
        } else if (!this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
            let child = this.children[i2];
            if (this.dom.contains(child.dom.parentNode)) {
              rule.contentElement = child.dom.parentNode;
              break;
            }
          }
          if (!rule.contentElement)
            rule.getContent = () => Fragment.empty;
        }
        return rule;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(view, pos) {
        let inline = this.node.inlineContent, off2 = pos;
        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
        let localComposition = composition && composition.pos > -1 ? composition : null;
        let compositionInChild = composition && composition.pos < 0;
        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
        iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
          if (widget.spec.marks)
            updater.syncToMarks(widget.spec.marks, inline, view);
          else if (widget.type.side >= 0 && !insideNode)
            updater.syncToMarks(i2 == this.node.childCount ? Mark$1.none : this.node.child(i2).marks, inline, view);
          updater.placeWidget(widget, view, off2);
        }, (child, outerDeco, innerDeco, i2) => {
          updater.syncToMarks(child.marks, inline, view);
          let compIndex;
          if (updater.findNodeMatch(child, outerDeco, innerDeco, i2)) ;
          else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
          else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off2)) ;
          else {
            updater.addNode(child, outerDeco, innerDeco, view, off2);
          }
          off2 += child.nodeSize;
        });
        updater.syncToMarks([], inline, view);
        if (this.node.isTextblock)
          updater.addTextblockHacks();
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (localComposition)
            this.protectLocalComposition(view, localComposition);
          renderDescs(this.contentDOM, this.children, view);
          if (ios)
            iosHacks(this.dom);
        }
      }
      localCompositionInfo(view, pos) {
        let { from, to: to2 } = view.state.selection;
        if (!(view.state.selection instanceof TextSelection) || from < pos || to2 > pos + this.node.content.size)
          return null;
        let textNode = view.input.compositionNode;
        if (!textNode || !this.dom.contains(textNode.parentNode))
          return null;
        if (this.node.inlineContent) {
          let text = textNode.nodeValue;
          let textPos = findTextInFragment(this.node.content, text, from - pos, to2 - pos);
          return textPos < 0 ? null : { node: textNode, pos: textPos, text };
        } else {
          return { node: textNode, pos: -1, text: "" };
        }
      }
      protectLocalComposition(view, { node, pos, text }) {
        if (this.getDesc(node))
          return;
        let topNode = node;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM)
            break;
          while (topNode.previousSibling)
            topNode.parentNode.removeChild(topNode.previousSibling);
          while (topNode.nextSibling)
            topNode.parentNode.removeChild(topNode.nextSibling);
          if (topNode.pmViewDesc)
            topNode.pmViewDesc = void 0;
        }
        let desc = new CompositionViewDesc(this, topNode, node, text);
        view.input.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
          return false;
        this.updateInner(node, outerDeco, innerDeco, view);
        return true;
      }
      updateInner(node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM)
          this.updateChildren(view, this.posAtStart);
        this.dirty = NOT_DIRTY;
      }
      updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco))
          return;
        let needsWrap = this.nodeDOM.nodeType != 1;
        let oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = void 0;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      }
      // Mark this node as being the selected node.
      selectNode() {
        if (this.nodeDOM.nodeType == 1)
          this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
          this.dom.draggable = true;
      }
      // Remove selected node marking from this node.
      deselectNode() {
        if (this.nodeDOM.nodeType == 1) {
          this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.removeAttribute("draggable");
        }
      }
      get domAtom() {
        return this.node.isAtom;
      }
    }
    function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc2);
      let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
      if (docView.contentDOM)
        docView.updateChildren(view, 0);
      return docView;
    }
    class TextViewDesc extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
      }
      parseRule() {
        let skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco)
          skip = skip.parentNode;
        return { skip: skip || true };
      }
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
          return false;
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node.text;
          if (view.trackWrites == this.nodeDOM)
            view.trackWrites = null;
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true;
      }
      inParent() {
        let parentDOM = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
          if (n == parentDOM)
            return true;
        return false;
      }
      domFromPos(pos) {
        return { node: this.nodeDOM, offset: pos };
      }
      localPosFromDOM(dom, offset, bias) {
        if (dom == this.nodeDOM)
          return this.posAtStart + Math.min(offset, this.node.text.length);
        return super.localPosFromDOM(dom, offset, bias);
      }
      ignoreMutation(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      }
      slice(from, to2, view) {
        let node = this.node.cut(from, to2), dom = document.createTextNode(node.text);
        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
      }
      markDirty(from, to2) {
        super.markDirty(from, to2);
        if (this.dom != this.nodeDOM && (from == 0 || to2 == this.nodeDOM.nodeValue.length))
          this.dirty = NODE_DIRTY;
      }
      get domAtom() {
        return false;
      }
      isText(text) {
        return this.node.text == text;
      }
    }
    class TrailingHackViewDesc extends ViewDesc {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(nodeName) {
        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    }
    class CustomNodeViewDesc extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY)
          return false;
        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
          let result = this.spec.update(node, outerDeco, innerDeco);
          if (result)
            this.updateInner(node, outerDeco, innerDeco, view);
          return result;
        } else if (!this.contentDOM && !node.isLeaf) {
          return false;
        } else {
          return super.update(node, outerDeco, innerDeco, view);
        }
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(anchor, head, view, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
      stopEvent(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
    }
    function renderDescs(parentDOM, descs, view) {
      let dom = parentDOM.firstChild, written = false;
      for (let i2 = 0; i2 < descs.length; i2++) {
        let desc = descs[i2], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) {
            dom = rm(dom);
            written = true;
          }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          let pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) {
        dom = rm(dom);
        written = true;
      }
      if (written && view.trackWrites == parentDOM)
        view.trackWrites = null;
    }
    const OuterDecoLevel = function(nodeName) {
      if (nodeName)
        this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    const noDeco = [new OuterDecoLevel()];
    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0)
        return noDeco;
      let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
      for (let i2 = 0; i2 < outerDeco.length; i2++) {
        let attrs = outerDeco[i2].type.attrs;
        if (!attrs)
          continue;
        if (attrs.nodeName)
          result.push(top = new OuterDecoLevel(attrs.nodeName));
        for (let name in attrs) {
          let val = attrs[name];
          if (val == null)
            continue;
          if (needsWrap && result.length == 1)
            result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
          if (name == "class")
            top.class = (top.class ? top.class + " " : "") + val;
          else if (name == "style")
            top.style = (top.style ? top.style + ";" : "") + val;
          else if (name != "nodeName")
            top[name] = val;
        }
      }
      return result;
    }
    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      if (prevComputed == noDeco && curComputed == noDeco)
        return nodeDOM;
      let curDOM = nodeDOM;
      for (let i2 = 0; i2 < curComputed.length; i2++) {
        let deco = curComputed[i2], prev = prevComputed[i2];
        if (i2) {
          let parent;
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM;
    }
    function patchAttributes(dom, prev, cur) {
      for (let name in prev)
        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
          dom.removeAttribute(name);
      for (let name in cur)
        if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
          dom.setAttribute(name, cur[name]);
      if (prev.class != cur.class) {
        let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
        let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
        for (let i2 = 0; i2 < prevList.length; i2++)
          if (curList.indexOf(prevList[i2]) == -1)
            dom.classList.remove(prevList[i2]);
        for (let i2 = 0; i2 < curList.length; i2++)
          if (prevList.indexOf(curList[i2]) == -1)
            dom.classList.add(curList[i2]);
        if (dom.classList.length == 0)
          dom.removeAttribute("class");
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop.exec(prev.style))
            dom.style.removeProperty(m[1]);
        }
        if (cur.style)
          dom.style.cssText += cur.style;
      }
    }
    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
    }
    function sameOuterDeco(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!a[i2].type.eq(b[i2].type))
          return false;
      return true;
    }
    function rm(dom) {
      let next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    class ViewTreeUpdater {
      constructor(top, lock, view) {
        this.lock = lock;
        this.view = view;
        this.index = 0;
        this.stack = [];
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(start, end) {
        if (start == end)
          return;
        for (let i2 = start; i2 < end; i2++)
          this.top.children[i2].destroy();
        this.top.children.splice(start, end - start);
        this.changed = true;
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(marks, inline, view) {
        let keep = 0, depth = this.stack.length >> 1;
        let maxKeep = Math.min(depth, marks.length);
        while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
          keep++;
        while (keep < depth) {
          this.destroyRest();
          this.top.dirty = NOT_DIRTY;
          this.index = this.stack.pop();
          this.top = this.stack.pop();
          depth--;
        }
        while (depth < marks.length) {
          this.stack.push(this.top, this.index + 1);
          let found2 = -1;
          for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
            let next = this.top.children[i2];
            if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
              found2 = i2;
              break;
            }
          }
          if (found2 > -1) {
            if (found2 > this.index) {
              this.changed = true;
              this.destroyBetween(this.index, found2);
            }
            this.top = this.top.children[this.index];
          } else {
            let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
            this.top.children.splice(this.index, 0, markDesc);
            this.top = markDesc;
            this.changed = true;
          }
          this.index = 0;
          depth++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(node, outerDeco, innerDeco, index) {
        let found2 = -1, targetDesc;
        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
          found2 = this.top.children.indexOf(targetDesc, this.index);
        } else {
          for (let i2 = this.index, e = Math.min(this.top.children.length, i2 + 5); i2 < e; i2++) {
            let child = this.top.children[i2];
            if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
              found2 = i2;
              break;
            }
          }
        }
        if (found2 < 0)
          return false;
        this.destroyBetween(this.index, found2);
        this.index++;
        return true;
      }
      updateNodeAt(node, outerDeco, innerDeco, index, view) {
        let child = this.top.children[index];
        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
          child.dirty = CONTENT_DIRTY;
        if (!child.update(node, outerDeco, innerDeco, view))
          return false;
        this.destroyBetween(this.index, index);
        this.index++;
        return true;
      }
      findIndexWithChild(domNode) {
        for (; ; ) {
          let parent = domNode.parentNode;
          if (!parent)
            return -1;
          if (parent == this.top.contentDOM) {
            let desc = domNode.pmViewDesc;
            if (desc)
              for (let i2 = this.index; i2 < this.top.children.length; i2++) {
                if (this.top.children[i2] == desc)
                  return i2;
              }
            return -1;
          }
          domNode = parent;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
        for (let i2 = this.index; i2 < this.top.children.length; i2++) {
          let next = this.top.children[i2];
          if (next instanceof NodeViewDesc) {
            let preMatch2 = this.preMatch.matched.get(next);
            if (preMatch2 != null && preMatch2 != index)
              return false;
            let nextDOM = next.dom, updated;
            let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
            if (!locked && next.update(node, outerDeco, innerDeco, view)) {
              this.destroyBetween(this.index, i2);
              if (next.dom != nextDOM)
                this.changed = true;
              this.index++;
              return true;
            } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
              this.destroyBetween(this.index, i2);
              this.top.children[this.index] = updated;
              if (updated.contentDOM) {
                updated.dirty = CONTENT_DIRTY;
                updated.updateChildren(view, pos + 1);
                updated.dirty = NOT_DIRTY;
              }
              this.changed = true;
              this.index++;
              return true;
            }
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
          return null;
        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (wrapper.contentDOM) {
          wrapper.children = next.children;
          next.children = [];
          for (let ch2 of wrapper.children)
            ch2.parent = wrapper;
        }
        next.destroy();
        return wrapper;
      }
      // Insert the node as a newly created node desc.
      addNode(node, outerDeco, innerDeco, view, pos) {
        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (desc.contentDOM)
          desc.updateChildren(view, pos + 1);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
      placeWidget(widget, view, pos) {
        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
          this.index++;
        } else {
          let desc = new WidgetViewDesc(this.top, widget, view, pos);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let lastChild = this.top.children[this.index - 1], parent = this.top;
        while (lastChild instanceof MarkViewDesc) {
          parent = lastChild;
          lastChild = parent.children[parent.children.length - 1];
        }
        if (!lastChild || // Empty textblock
        !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
          if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
            this.addHackNode("IMG", parent);
          this.addHackNode("BR", this.top);
        }
      }
      addHackNode(nodeName, parent) {
        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
          this.index++;
        } else {
          let dom = document.createElement(nodeName);
          if (nodeName == "IMG") {
            dom.className = "ProseMirror-separator";
            dom.alt = "";
          }
          if (nodeName == "BR")
            dom.className = "ProseMirror-trailingBreak";
          let hack = new TrailingHackViewDesc(this.top, [], dom, null);
          if (parent != this.top)
            parent.children.push(hack);
          else
            parent.children.splice(this.index++, 0, hack);
          this.changed = true;
        }
      }
      isLocked(node) {
        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
      }
    }
    function preMatch(frag, parentDesc) {
      let curDesc = parentDesc, descI = curDesc.children.length;
      let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
      outer: while (fI > 0) {
        let desc;
        for (; ; ) {
          if (descI) {
            let next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        let node = desc.node;
        if (!node)
          continue;
        if (node != frag.child(fI - 1))
          break;
        --fI;
        matched.set(desc, fI);
        matches2.push(desc);
      }
      return { index: fI, matched, matches: matches2.reverse() };
    }
    function compareSide(a, b) {
      return a.type.side - b.type.side;
    }
    function iterDeco(parent, deco, onWidget, onNode) {
      let locals = deco.locals(parent), offset = 0;
      if (locals.length == 0) {
        for (let i2 = 0; i2 < parent.childCount; i2++) {
          let child = parent.child(i2);
          onNode(child, locals, deco.forChild(offset, child), i2);
          offset += child.nodeSize;
        }
        return;
      }
      let decoIndex = 0, active = [], restNode = null;
      for (let parentIndex = 0; ; ) {
        let widget, widgets;
        while (decoIndex < locals.length && locals[decoIndex].to == offset) {
          let next = locals[decoIndex++];
          if (next.widget) {
            if (!widget)
              widget = next;
            else
              (widgets || (widgets = [widget])).push(next);
          }
        }
        if (widget) {
          if (widgets) {
            widgets.sort(compareSide);
            for (let i2 = 0; i2 < widgets.length; i2++)
              onWidget(widgets[i2], parentIndex, !!restNode);
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }
        let child, index;
        if (restNode) {
          index = -1;
          child = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index = parentIndex;
          child = parent.child(parentIndex++);
        } else {
          break;
        }
        for (let i2 = 0; i2 < active.length; i2++)
          if (active[i2].to <= offset)
            active.splice(i2--, 1);
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
          active.push(locals[decoIndex++]);
        let end = offset + child.nodeSize;
        if (child.isText) {
          let cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
            cutAt = locals[decoIndex].from;
          for (let i2 = 0; i2 < active.length; i2++)
            if (active[i2].to < cutAt)
              cutAt = active[i2].to;
          if (cutAt < end) {
            restNode = child.cut(cutAt - offset);
            child = child.cut(0, cutAt - offset);
            end = cutAt;
            index = -1;
          }
        } else {
          while (decoIndex < locals.length && locals[decoIndex].to < end)
            decoIndex++;
        }
        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
        onNode(child, outerDeco, deco.forChild(offset, child), index);
        offset = end;
      }
    }
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        let oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }
    function findTextInFragment(frag, text, from, to2) {
      for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to2; ) {
        let child = frag.child(i2++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText)
          continue;
        let str = child.text;
        while (i2 < frag.childCount) {
          let next = frag.child(i2++);
          pos += next.nodeSize;
          if (!next.isText)
            break;
          str += next.text;
        }
        if (pos >= from) {
          if (pos >= to2 && str.slice(to2 - text.length - childStart, to2 - childStart) == text)
            return to2 - text.length;
          let found2 = childStart < to2 ? str.lastIndexOf(text, to2 - childStart - 1) : -1;
          if (found2 >= 0 && found2 + text.length + childStart >= from)
            return childStart + found2;
          if (from == to2 && str.length >= to2 + text.length - childStart && str.slice(to2 - childStart, to2 - childStart + text.length) == text)
            return to2;
        }
      }
      return -1;
    }
    function replaceNodes(nodes, from, to2, view, replacement) {
      let result = [];
      for (let i2 = 0, off2 = 0; i2 < nodes.length; i2++) {
        let child = nodes[i2], start = off2, end = off2 += child.size;
        if (start >= to2 || end <= from) {
          result.push(child);
        } else {
          if (start < from)
            result.push(child.slice(0, from - start, view));
          if (replacement) {
            result.push(replacement);
            replacement = void 0;
          }
          if (end > to2)
            result.push(child.slice(to2 - start, child.size, view));
        }
      }
      return result;
    }
    function selectionFromDOM(view, origin = null) {
      let domSel = view.domSelectionRange(), doc2 = view.state.doc;
      if (!domSel.focusNode)
        return null;
      let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
      if (head < 0)
        return null;
      let $head = doc2.resolve(head), anchor, selection;
      if (selectionCollapsed(domSel)) {
        anchor = head;
        while (nearestDesc && !nearestDesc.node)
          nearestDesc = nearestDesc.parent;
        let nearestDescNode = nearestDesc.node;
        if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          let pos = nearestDesc.posBefore;
          selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
        }
      } else {
        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
          let min = head, max = head;
          for (let i2 = 0; i2 < domSel.rangeCount; i2++) {
            let range2 = domSel.getRangeAt(i2);
            min = Math.min(min, view.docView.posFromDOM(range2.startContainer, range2.startOffset, 1));
            max = Math.max(max, view.docView.posFromDOM(range2.endContainer, range2.endOffset, -1));
          }
          if (min < 0)
            return null;
          [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];
          $head = doc2.resolve(head);
        } else {
          anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
        }
        if (anchor < 0)
          return null;
      }
      let $anchor = doc2.resolve(anchor);
      if (!selection) {
        let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection;
    }
    function editorOwnsSelection(view) {
      return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
    }
    function selectionToDOM(view, force = false) {
      let sel = view.state.selection;
      syncNodeSelection(view, sel);
      if (!editorOwnsSelection(view))
        return;
      if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
          view.input.mouseDown.delayedSelectionSync = true;
          view.domObserver.setCurSelection();
          return;
        }
      }
      view.domObserver.disconnectSelection();
      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
          if (!sel.$from.parent.inlineContent)
            resetEditableFrom = temporarilyEditableNear(view, sel.from);
          if (!sel.empty && !sel.$from.parent.inlineContent)
            resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
        view.docView.setSelection(anchor, head, view, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom)
            resetEditable(resetEditableFrom);
          if (resetEditableTo)
            resetEditable(resetEditableTo);
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document)
            removeClassOnSelectionChange(view);
        }
      }
      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }
    const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    function temporarilyEditableNear(view, pos) {
      let { node, offset } = view.docView.domFromPos(pos, 0);
      let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      let before = offset ? node.childNodes[offset - 1] : null;
      if (safari && after && after.contentEditable == "false")
        return setEditable(after);
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after)
          return setEditable(after);
        else if (before)
          return setEditable(before);
      }
    }
    function setEditable(element) {
      element.contentEditable = "true";
      if (safari && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
      }
      return element;
    }
    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
      }
    }
    function removeClassOnSelectionChange(view) {
      let doc2 = view.dom.ownerDocument;
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      let domSel = view.domSelectionRange();
      let node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
          setTimeout(() => {
            if (!editorOwnsSelection(view) || view.state.selection.visible)
              view.dom.classList.remove("ProseMirror-hideselection");
          }, 20);
        }
      });
    }
    function selectCursorWrapper(view) {
      let domSel = view.domSelection(), range2 = document.createRange();
      if (!domSel)
        return;
      let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img)
        range2.setStart(node.parentNode, domIndex(node) + 1);
      else
        range2.setStart(node, 0);
      range2.collapse(true);
      domSel.removeAllRanges();
      domSel.addRange(range2);
      if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }
    function syncNodeSelection(view, sel) {
      if (sel instanceof NodeSelection) {
        let desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc)
            desc.selectNode();
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent)
          view.lastSelectedViewDesc.deselectNode();
        view.lastSelectedViewDesc = void 0;
      }
    }
    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
    }
    function hasFocusAndSelection(view) {
      if (view.editable && !view.hasFocus())
        return false;
      return hasSelection(view);
    }
    function hasSelection(view) {
      let sel = view.domSelectionRange();
      if (!sel.anchorNode)
        return false;
      try {
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
      } catch (_) {
        return false;
      }
    }
    function anchorInRightPlace(view) {
      let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      let domSel = view.domSelectionRange();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
    }
    function moveSelectionBlock(state, dir) {
      let { $anchor, $head } = state.selection;
      let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && Selection.findFrom($start, dir);
    }
    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true;
    }
    function selectHorizontally(view, dir, mods) {
      let sel = view.state.selection;
      if (sel instanceof TextSelection) {
        if (mods.indexOf("s") > -1) {
          let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
          if (!node || node.isText || !node.isLeaf)
            return false;
          let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
          return apply(view, new TextSelection(sel.$anchor, $newHead));
        } else if (!sel.empty) {
          return false;
        } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
          let next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof NodeSelection)
            return apply(view, next);
          return false;
        } else if (!(mac$2 && mods.indexOf("m") > -1)) {
          let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
          if (!node || node.isText)
            return false;
          let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
          if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
            return false;
          if (NodeSelection.isSelectable(node)) {
            return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
          } else if (webkit) {
            return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
          } else {
            return false;
          }
        }
      } else if (sel instanceof NodeSelection && sel.node.isInline) {
        return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
      } else {
        let next = moveSelectionBlock(view.state, dir);
        if (next)
          return apply(view, next);
        return false;
      }
    }
    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isIgnorable(dom, dir) {
      let desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
    }
    function skipIgnoredNodes(view, dir) {
      return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
    }
    function skipIgnoredNodesBefore(view) {
      let sel = view.domSelectionRange();
      let node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      let moveNode, moveOffset, force = false;
      if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))
        force = true;
      for (; ; ) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break;
          } else {
            let before = node.childNodes[offset - 1];
            if (isIgnorable(before, -1)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else
              break;
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          let prev = node.previousSibling;
          while (prev && isIgnorable(prev, -1)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force)
        setSelFocus(view, node, offset);
      else if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function skipIgnoredNodesAfter(view) {
      let sel = view.domSelectionRange();
      let node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      let len = nodeLen(node);
      let moveNode, moveOffset;
      for (; ; ) {
        if (offset < len) {
          if (node.nodeType != 1)
            break;
          let after = node.childNodes[offset];
          if (isIgnorable(after, 1)) {
            moveNode = node;
            moveOffset = ++offset;
          } else
            break;
        } else if (isBlockNode(node)) {
          break;
        } else {
          let next = node.nextSibling;
          while (next && isIgnorable(next, 1)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function isBlockNode(dom) {
      let desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock;
    }
    function textNodeAfter(node, offset) {
      while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      }
      while (node && offset < node.childNodes.length) {
        let next = node.childNodes[offset];
        if (next.nodeType == 3)
          return next;
        if (next.nodeType == 1 && next.contentEditable == "false")
          break;
        node = next;
        offset = 0;
      }
    }
    function textNodeBefore(node, offset) {
      while (node && !offset && !hasBlockDesc(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      }
      while (node && offset) {
        let next = node.childNodes[offset - 1];
        if (next.nodeType == 3)
          return next;
        if (next.nodeType == 1 && next.contentEditable == "false")
          break;
        node = next;
        offset = node.childNodes.length;
      }
    }
    function setSelFocus(view, node, offset) {
      if (node.nodeType != 3) {
        let before, after;
        if (after = textNodeAfter(node, offset)) {
          node = after;
          offset = 0;
        } else if (before = textNodeBefore(node, offset)) {
          node = before;
          offset = before.nodeValue.length;
        }
      }
      let sel = view.domSelection();
      if (!sel)
        return;
      if (selectionCollapsed(sel)) {
        let range2 = document.createRange();
        range2.setEnd(node, offset);
        range2.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range2);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      let { state } = view;
      setTimeout(() => {
        if (view.state == state)
          selectionToDOM(view);
      }, 50);
    }
    function findDirection(view, pos) {
      let $pos = view.state.doc.resolve(pos);
      if (!(chrome || windows) && $pos.parent.inlineContent) {
        let coords = view.coordsAtPos(pos);
        if (pos > $pos.start()) {
          let before = view.coordsAtPos(pos - 1);
          let mid = (before.top + before.bottom) / 2;
          if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
            return before.left < coords.left ? "ltr" : "rtl";
        }
        if (pos < $pos.end()) {
          let after = view.coordsAtPos(pos + 1);
          let mid = (after.top + after.bottom) / 2;
          if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
            return after.left > coords.left ? "ltr" : "rtl";
        }
      }
      let computed2 = getComputedStyle(view.dom).direction;
      return computed2 == "rtl" ? "rtl" : "ltr";
    }
    function selectVertically(view, dir, mods) {
      let sel = view.state.selection;
      if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
        return false;
      if (mac$2 && mods.indexOf("m") > -1)
        return false;
      let { $from, $to } = sel;
      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
      }
      if (!$from.parent.inlineContent) {
        let side = dir < 0 ? $from : $to;
        let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
      }
      return false;
    }
    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof TextSelection))
        return true;
      let { $head, $anchor, empty: empty2 } = view.state.selection;
      if (!$head.sameParent($anchor))
        return true;
      if (!empty2)
        return false;
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
        return true;
      let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        let tr2 = view.state.tr;
        if (dir < 0)
          tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
        else
          tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
        view.dispatch(tr2);
        return true;
      }
      return false;
    }
    function switchEditable(view, node, state) {
      view.domObserver.stop();
      node.contentEditable = state;
      view.domObserver.start();
    }
    function safariDownArrowBug(view) {
      if (!safari || view.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode, focusOffset } = view.domSelectionRange();
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        let child = focusNode.firstChild;
        switchEditable(view, child, "true");
        setTimeout(() => switchEditable(view, child, "false"), 20);
      }
      return false;
    }
    function getMods(event) {
      let result = "";
      if (event.ctrlKey)
        result += "c";
      if (event.metaKey)
        result += "m";
      if (event.altKey)
        result += "a";
      if (event.shiftKey)
        result += "s";
      return result;
    }
    function captureKeyDown(view, event) {
      let code2 = event.keyCode, mods = getMods(event);
      if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
      } else if (code2 == 46 && !event.shiftKey || mac$2 && code2 == 68 && mods == "c") {
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
      } else if (code2 == 13 || code2 == 27) {
        return true;
      } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
        let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
      } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
        let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
      } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
      } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
      } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
        return true;
      }
      return false;
    }
    function serializeForClipboard(view, slice) {
      view.someProp("transformCopied", (f) => {
        slice = f(slice, view);
      });
      let context = [], { content, openStart, openEnd } = slice;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        let node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }
      let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
      let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
      wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
      let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
          let wrapper = doc2.createElement(needsWrap[i2]);
          while (wrap2.firstChild)
            wrapper.appendChild(wrap2.firstChild);
          wrap2.appendChild(wrapper);
          wrappers++;
        }
        firstChild = wrap2.firstChild;
      }
      if (firstChild && firstChild.nodeType == 1)
        firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
      let text = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
      return { dom: wrap2, text, slice };
    }
    function parseFromClipboard(view, text, html, plainText, $context) {
      let inCode = $context.parent.type.spec.code;
      let dom, slice;
      if (!html && !text)
        return null;
      let asText = text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", (f) => {
          text = f(text, inCode || plainText, view);
        });
        if (inCode)
          return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
        let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
        if (parsed) {
          slice = parsed;
        } else {
          let marks = $context.marks();
          let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
          dom = document.createElement("div");
          text.split(/(?:\r\n?|\n)+/).forEach((block) => {
            let p2 = dom.appendChild(document.createElement("p"));
            if (block)
              p2.appendChild(serializer.serializeNode(schema.text(block, marks)));
          });
        }
      } else {
        view.someProp("transformPastedHTML", (f) => {
          html = f(html, view);
        });
        dom = readHTML(html);
        if (webkit)
          restoreReplacedSpaces(dom);
      }
      let contextNode = dom && dom.querySelector("[data-pm-slice]");
      let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
      if (sliceData && sliceData[3])
        for (let i2 = +sliceData[3]; i2 > 0; i2--) {
          let child = dom.firstChild;
          while (child && child.nodeType != 1)
            child = child.nextSibling;
          if (!child)
            break;
          dom = child;
        }
      if (!slice) {
        let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, {
          preserveWhitespace: !!(asText || sliceData),
          context: $context,
          ruleFromNode(dom2) {
            if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
              return { ignore: true };
            return null;
          }
        });
      }
      if (sliceData) {
        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
      } else {
        slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
        if (slice.openStart || slice.openEnd) {
          let openStart = 0, openEnd = 0;
          for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
          }
          for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
          }
          slice = closeSlice(slice, openStart, openEnd);
        }
      }
      view.someProp("transformPasted", (f) => {
        slice = f(slice, view);
      });
      return slice;
    }
    const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2)
        return fragment;
      for (let d = $context.depth; d >= 0; d--) {
        let parent = $context.node(d);
        let match = parent.contentMatchAt($context.index(d));
        let lastWrap, result = [];
        fragment.forEach((node) => {
          if (!result)
            return;
          let wrap2 = match.findWrapping(node.type), inLast;
          if (!wrap2)
            return result = null;
          if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length)
              result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
            let wrapped = withWrappers(node, wrap2);
            result.push(wrapped);
            match = match.matchType(wrapped.type);
            lastWrap = wrap2;
          }
        });
        if (result)
          return Fragment.from(result);
      }
      return fragment;
    }
    function withWrappers(node, wrap2, from = 0) {
      for (let i2 = wrap2.length - 1; i2 >= from; i2--)
        node = wrap2[i2].create(null, Fragment.from(node));
      return node;
    }
    function addToSibling(wrap2, lastWrap, node, sibling, depth) {
      if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
        let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner)
          return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        let match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
          return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
      }
    }
    function closeRight(node, depth) {
      if (depth == 0)
        return node;
      let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
      return node.copy(fragment.append(fill));
    }
    function closeRange(fragment, side, from, to2, depth, openEnd) {
      let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (fragment.childCount > 1)
        openEnd = 0;
      if (depth < to2 - 1)
        inner = closeRange(inner, side, from, to2, depth + 1, openEnd);
      if (depth >= from)
        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
    }
    function closeSlice(slice, openStart, openEnd) {
      if (openStart < slice.openStart)
        slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
      if (openEnd < slice.openEnd)
        slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
      return slice;
    }
    const wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    let _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
    }
    let _policy = null;
    function maybeWrapTrusted(html) {
      let trustedTypes = window.trustedTypes;
      if (!trustedTypes)
        return html;
      if (!_policy)
        _policy = trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
      return _policy.createHTML(html);
    }
    function readHTML(html) {
      let metas = /^(\s*<meta [^>]*>)*/.exec(html);
      if (metas)
        html = html.slice(metas[0].length);
      let elt = detachedDoc().createElement("div");
      let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
      if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
        html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
      elt.innerHTML = maybeWrapTrusted(html);
      if (wrap2)
        for (let i2 = 0; i2 < wrap2.length; i2++)
          elt = elt.querySelector(wrap2[i2]) || elt;
      return elt;
    }
    function restoreReplacedSpaces(dom) {
      let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let i2 = 0; i2 < nodes.length; i2++) {
        let node = nodes[i2];
        if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
          node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
      }
    }
    function addContext(slice, context) {
      if (!slice.size)
        return slice;
      let schema = slice.content.firstChild.type.schema, array;
      try {
        array = JSON.parse(context);
      } catch (e) {
        return slice;
      }
      let { content, openStart, openEnd } = slice;
      for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
        let type = schema.nodes[array[i2]];
        if (!type || type.hasRequiredAttrs())
          break;
        content = Fragment.from(type.create(array[i2 + 1], content));
        openStart++;
        openEnd++;
      }
      return new Slice(content, openStart, openEnd);
    }
    const handlers = {};
    const editHandlers = {};
    const passiveHandlers = { touchstart: true, touchmove: true };
    class InputState {
      constructor() {
        this.shiftKey = false;
        this.mouseDown = null;
        this.lastKeyCode = null;
        this.lastKeyCodeTime = 0;
        this.lastClick = { time: 0, x: 0, y: 0, type: "" };
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastIOSEnter = 0;
        this.lastIOSEnterFallbackTimeout = -1;
        this.lastFocus = 0;
        this.lastTouch = 0;
        this.lastChromeDelete = 0;
        this.composing = false;
        this.compositionNode = null;
        this.composingTimeout = -1;
        this.compositionNodes = [];
        this.compositionEndedAt = -2e8;
        this.compositionID = 1;
        this.compositionPendingChanges = 0;
        this.domChangeCount = 0;
        this.eventHandlers = /* @__PURE__ */ Object.create(null);
        this.hideSelectionGuard = null;
      }
    }
    function initInput(view) {
      for (let event in handlers) {
        let handler = handlers[event];
        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
          if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
            handler(view, event2);
        }, passiveHandlers[event] ? { passive: true } : void 0);
      }
      if (safari)
        view.dom.addEventListener("input", () => null);
      ensureListeners(view);
    }
    function setSelectionOrigin(view, origin) {
      view.input.lastSelectionOrigin = origin;
      view.input.lastSelectionTime = Date.now();
    }
    function destroyInput(view) {
      view.domObserver.stop();
      for (let type in view.input.eventHandlers)
        view.dom.removeEventListener(type, view.input.eventHandlers[type]);
      clearTimeout(view.input.composingTimeout);
      clearTimeout(view.input.lastIOSEnterFallbackTimeout);
    }
    function ensureListeners(view) {
      view.someProp("handleDOMEvents", (currentHandlers) => {
        for (let type in currentHandlers)
          if (!view.input.eventHandlers[type])
            view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
      });
    }
    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", (handlers2) => {
        let handler = handlers2[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false;
      });
    }
    function eventBelongsToView(view, event) {
      if (!event.bubbles)
        return true;
      if (event.defaultPrevented)
        return false;
      for (let node = event.target; node != view.dom; node = node.parentNode)
        if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
          return false;
      return true;
    }
    function dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
        handlers[event.type](view, event);
    }
    editHandlers.keydown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event))
        return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13)
        return;
      if (event.keyCode != 229)
        view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        let now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = (view, event) => {
      if (event.keyCode == 16)
        view.input.shiftKey = false;
    };
    editHandlers.keypress = (view, _event) => {
      let event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
        return;
      if (view.someProp("handleKeyPress", (f) => f(view, event))) {
        event.preventDefault();
        return;
      }
      let sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        let text = String.fromCharCode(event.charCode);
        if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
          view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        event.preventDefault();
      }
    };
    function eventCoords(event) {
      return { left: event.clientX, top: event.clientY };
    }
    function isNear(event, click) {
      let dx = click.x - event.clientX, dy2 = click.y - event.clientY;
      return dx * dx + dy2 * dy2 < 100;
    }
    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1)
        return false;
      let $pos = view.state.doc.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
          return true;
      }
      return false;
    }
    function updateSelection(view, selection, origin) {
      if (!view.focused)
        view.focus();
      if (view.state.selection.eq(selection))
        return;
      let tr2 = view.state.tr.setSelection(selection);
      tr2.setMeta("pointer", true);
      view.dispatch(tr2);
    }
    function selectClickedLeaf(view, inside) {
      if (inside == -1)
        return false;
      let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && NodeSelection.isSelectable(node)) {
        updateSelection(view, new NodeSelection($pos));
        return true;
      }
      return false;
    }
    function selectClickedNode(view, inside) {
      if (inside == -1)
        return false;
      let sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof NodeSelection)
        selectedNode = sel.node;
      let $pos = view.state.doc.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
        if (NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
            selectAt = $pos.before(sel.$from.depth);
          else
            selectAt = $pos.before(i2);
          break;
        }
      }
      if (selectAt != null) {
        updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
        return true;
      } else {
        return false;
      }
    }
    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
    }
    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
    }
    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
    }
    function defaultTripleClick(view, inside, event) {
      if (event.button != 0)
        return false;
      let doc2 = view.state.doc;
      if (inside == -1) {
        if (doc2.inlineContent) {
          updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
          return true;
        }
        return false;
      }
      let $pos = doc2.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
        let nodePos = $pos.before(i2);
        if (node.inlineContent)
          updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
        else if (NodeSelection.isSelectable(node))
          updateSelection(view, NodeSelection.create(doc2, nodePos));
        else
          continue;
        return true;
      }
    }
    function forceDOMFlush(view) {
      return endComposition(view);
    }
    const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
    handlers.mousedown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.shiftKey;
      let flushed = forceDOMFlush(view);
      let now = Date.now(), type = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
        if (view.input.lastClick.type == "singleClick")
          type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
          type = "tripleClick";
      }
      view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      let pos = view.posAtCoords(eventCoords(event));
      if (!pos)
        return;
      if (type == "singleClick") {
        if (view.input.mouseDown)
          view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    class MouseDown {
      constructor(view, pos, event, flushed) {
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        let targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          let $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        const target = flushed ? null : event.target;
        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
        let { selection } = view.state;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
          this.mightDrag = {
            node: targetNode,
            pos: targetPos,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
          };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.draggable = true;
          if (this.mightDrag.setUneditable)
            setTimeout(() => {
              if (this.view.input.mouseDown == this)
                this.target.setAttribute("contentEditable", "false");
            }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.removeAttribute("draggable");
          if (this.mightDrag.setUneditable)
            this.target.removeAttribute("contentEditable");
          this.view.domObserver.start();
        }
        if (this.delayedSelectionSync)
          setTimeout(() => selectionToDOM(this.view));
        this.view.input.mouseDown = null;
      }
      up(event) {
        this.done();
        if (!this.view.dom.contains(event.target))
          return;
        let pos = this.pos;
        if (this.view.state.doc != this.startDoc)
          pos = this.view.posAtCoords(eventCoords(event));
        this.updateAllowDefault(event);
        if (this.allowDefault || !pos) {
          setSelectionOrigin(this.view, "pointer");
        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
          event.preventDefault();
        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
          updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
          event.preventDefault();
        } else {
          setSelectionOrigin(this.view, "pointer");
        }
      }
      move(event) {
        this.updateAllowDefault(event);
        setSelectionOrigin(this.view, "pointer");
        if (event.buttons == 0)
          this.done();
      }
      updateAllowDefault(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
          this.allowDefault = true;
      }
    }
    handlers.touchstart = (view) => {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = (view) => {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = (view) => forceDOMFlush(view);
    function inOrNearComposition(view, event) {
      if (view.composing)
        return true;
      if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
        view.input.compositionEndedAt = -2e8;
        return true;
      }
      return false;
    }
    const timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
      if (!view.composing) {
        view.domObserver.flush();
        let { state } = view, $pos = state.selection.$to;
        if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view, !state.selection.empty);
          if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            let sel = view.domSelectionRange();
            for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
              let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before)
                break;
              if (before.nodeType == 3) {
                let sel2 = view.domSelection();
                if (sel2)
                  sel2.collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = (view, event) => {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
        view.input.compositionNode = null;
        if (view.input.compositionPendingChanges)
          Promise.resolve().then(() => view.domObserver.flush());
        view.input.compositionID++;
        scheduleComposeEnd(view, 20);
      }
    };
    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.input.composingTimeout);
      if (delay > -1)
        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
    }
    function clearComposition(view) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = timestampFromCustomEvent();
      }
      while (view.input.compositionNodes.length > 0)
        view.input.compositionNodes.pop().markParentsDirty();
    }
    function findCompositionNode(view) {
      let sel = view.domSelectionRange();
      if (!sel.focusNode)
        return null;
      let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
      let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
      if (textBefore && textAfter && textBefore != textAfter) {
        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
        if (textBefore == lastChanged || textAfter == lastChanged)
          return lastChanged;
        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
          return textAfter;
        } else if (view.input.compositionNode == textAfter) {
          let descBefore = textBefore.pmViewDesc;
          if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
            return textAfter;
        }
      }
      return textBefore || textAfter;
    }
    function timestampFromCustomEvent() {
      let event = document.createEvent("Event");
      event.initEvent("event", true, true);
      return event.timeStamp;
    }
    function endComposition(view, restarting = false) {
      if (android && view.domObserver.flushingSoon >= 0)
        return;
      view.domObserver.forceFlush();
      clearComposition(view);
      if (restarting || view.docView && view.docView.dirty) {
        let sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection))
          view.dispatch(view.state.tr.setSelection(sel));
        else if ((view.markCursor || restarting) && !view.state.selection.empty)
          view.dispatch(view.state.tr.deleteSelection());
        else
          view.updateState(view.state);
        return true;
      }
      return false;
    }
    function captureCopy(view, dom) {
      if (!view.dom.parentNode)
        return;
      let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap2.appendChild(dom);
      wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let sel = getSelection(), range2 = document.createRange();
      range2.selectNodeContents(dom);
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range2);
      setTimeout(() => {
        if (wrap2.parentNode)
          wrap2.parentNode.removeChild(wrap2);
        view.focus();
      }, 50);
    }
    const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = (view, _event) => {
      let event = _event;
      let sel = view.state.selection, cut2 = event.type == "cut";
      if (sel.empty)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut2)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function sliceSingleNode(slice) {
      return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
    }
    function capturePaste(view, event) {
      if (!view.dom.parentNode)
        return;
      let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
      let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText)
        target.contentEditable = "true";
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      setTimeout(() => {
        view.focus();
        if (target.parentNode)
          target.parentNode.removeChild(target);
        if (plainText)
          doPaste(view, target.value, null, plain, event);
        else
          doPaste(view, target.textContent, target.innerHTML, plain, event);
      }, 50);
    }
    function doPaste(view, text, html, preferPlain, event) {
      let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
      if (view.someProp("handlePaste", (f) => f(view, event, slice || Slice.empty)))
        return true;
      if (!slice)
        return false;
      let singleNode = sliceSingleNode(slice);
      let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
      view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true;
    }
    function getText$1(clipboardData) {
      let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
      if (text)
        return text;
      let uris = clipboardData.getData("text/uri-list");
      return uris ? uris.replace(/\r?\n/g, " ") : "";
    }
    editHandlers.paste = (view, _event) => {
      let event = _event;
      if (view.composing && !android)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event))
        event.preventDefault();
      else
        capturePaste(view, event);
    };
    class Dragging {
      constructor(slice, move, node) {
        this.slice = slice;
        this.move = move;
        this.node = node;
      }
    }
    const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
    handlers.dragstart = (view, _event) => {
      let event = _event;
      let mouseDown = view.input.mouseDown;
      if (mouseDown)
        mouseDown.done();
      if (!event.dataTransfer)
        return;
      let sel = view.state.selection;
      let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      let node;
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
      else if (mouseDown && mouseDown.mightDrag) {
        node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
      } else if (event.target && event.target.nodeType == 1) {
        let desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView)
          node = NodeSelection.create(view.state.doc, desc.posBefore);
      }
      let draggedSlice = (node || view.state.selection).content();
      let { dom, text, slice } = serializeForClipboard(view, draggedSlice);
      if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
        event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text);
      view.dragging = new Dragging(slice, !event[dragCopyModifier], node);
    };
    handlers.dragend = (view) => {
      let dragging = view.dragging;
      window.setTimeout(() => {
        if (view.dragging == dragging)
          view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
    editHandlers.drop = (view, _event) => {
      let event = _event;
      let dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer)
        return;
      let eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos)
        return;
      let $mouse = view.state.doc.resolve(eventPos.pos);
      let slice = dragging && dragging.slice;
      if (slice) {
        view.someProp("transformPasted", (f) => {
          slice = f(slice, view);
        });
      } else {
        slice = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      let move = !!(dragging && !event[dragCopyModifier]);
      if (view.someProp("handleDrop", (f) => f(view, event, slice || Slice.empty, move))) {
        event.preventDefault();
        return;
      }
      if (!slice)
        return;
      event.preventDefault();
      let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null)
        insertPos = $mouse.pos;
      let tr2 = view.state.tr;
      if (move) {
        let { node } = dragging;
        if (node)
          node.replace(tr2);
        else
          tr2.deleteSelection();
      }
      let pos = tr2.mapping.map(insertPos);
      let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      let beforeInsert = tr2.doc;
      if (isNode)
        tr2.replaceRangeWith(pos, pos, slice.content.firstChild);
      else
        tr2.replaceRange(pos, pos, slice);
      if (tr2.doc.eq(beforeInsert))
        return;
      let $pos = tr2.doc.resolve(pos);
      if (isNode && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr2.setSelection(new NodeSelection($pos));
      } else {
        let end = tr2.mapping.map(insertPos);
        tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
        tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr2.setMeta("uiEvent", "drop"));
    };
    handlers.focus = (view) => {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(() => {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
            selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = (view, _event) => {
      let event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
          view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = (view, _event) => {
      let event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        let { domChangeCount } = view.input;
        setTimeout(() => {
          if (view.input.domChangeCount != domChangeCount)
            return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
            return;
          let { $cursor } = view.state.selection;
          if ($cursor && $cursor.pos > 0)
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let prop in editHandlers)
      handlers[prop] = editHandlers[prop];
    function compareObjs(a, b) {
      if (a == b)
        return true;
      for (let p2 in a)
        if (a[p2] !== b[p2])
          return false;
      for (let p2 in b)
        if (!(p2 in a))
          return false;
      return true;
    }
    class WidgetType {
      constructor(toDOM, spec) {
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      map(mapping, span, offset, oldOffset) {
        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        return deleted ? null : new Decoration(pos - offset, pos - offset, this);
      }
      valid() {
        return true;
      }
      eq(other) {
        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
      }
      destroy(node) {
        if (this.spec.destroy)
          this.spec.destroy(node);
      }
    }
    class InlineType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset, oldOffset) {
        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
        let to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
        return from >= to2 ? null : new Decoration(from, to2, this);
      }
      valid(_, span) {
        return span.from < span.to;
      }
      eq(other) {
        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      static is(span) {
        return span.type instanceof InlineType;
      }
      destroy() {
      }
    }
    class NodeType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset, oldOffset) {
        let from = mapping.mapResult(span.from + oldOffset, 1);
        if (from.deleted)
          return null;
        let to2 = mapping.mapResult(span.to + oldOffset, -1);
        if (to2.deleted || to2.pos <= from.pos)
          return null;
        return new Decoration(from.pos - offset, to2.pos - offset, this);
      }
      valid(node, span) {
        let { index, offset } = node.content.findIndex(span.from), child;
        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
      }
      eq(other) {
        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      destroy() {
      }
    }
    class Decoration {
      /**
      @internal
      */
      constructor(from, to2, type) {
        this.from = from;
        this.to = to2;
        this.type = type;
      }
      /**
      @internal
      */
      copy(from, to2) {
        return new Decoration(from, to2, this.type);
      }
      /**
      @internal
      */
      eq(other, offset = 0) {
        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
      }
      /**
      @internal
      */
      map(mapping, offset, oldOffset) {
        return this.type.map(mapping, this, offset, oldOffset);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(pos, toDOM, spec) {
        return new Decoration(pos, pos, new WidgetType(toDOM, spec));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(from, to2, attrs, spec) {
        return new Decoration(from, to2, new InlineType(attrs, spec));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(from, to2, attrs, spec) {
        return new Decoration(from, to2, new NodeType(attrs, spec));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof InlineType;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof WidgetType;
      }
    }
    const none = [], noSpec = {};
    class DecorationSet {
      /**
      @internal
      */
      constructor(local, children) {
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(doc2, decorations) {
        return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(start, end, predicate) {
        let result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
      }
      findInner(start, end, result, offset, predicate) {
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let span = this.local[i2];
          if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
            result.push(span.copy(span.from + offset, span.to + offset));
        }
        for (let i2 = 0; i2 < this.children.length; i2 += 3) {
          if (this.children[i2] < end && this.children[i2 + 1] > start) {
            let childOff = this.children[i2] + 1;
            this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
          }
        }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(mapping, doc2, options) {
        if (this == empty || mapping.maps.length == 0)
          return this;
        return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
      }
      /**
      @internal
      */
      mapInner(mapping, node, offset, oldOffset, options) {
        let newLocal;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let mapped = this.local[i2].map(mapping, offset, oldOffset);
          if (mapped && mapped.type.valid(node, mapped))
            (newLocal || (newLocal = [])).push(mapped);
          else if (options.onRemove)
            options.onRemove(this.local[i2].spec);
        }
        if (this.children.length)
          return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
        else
          return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(doc2, decorations) {
        if (!decorations.length)
          return this;
        if (this == empty)
          return DecorationSet.create(doc2, decorations);
        return this.addInner(doc2, decorations, 0);
      }
      addInner(doc2, decorations, offset) {
        let children, childIndex = 0;
        doc2.forEach((childNode, childOffset) => {
          let baseOffset = childOffset + offset, found2;
          if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
            return;
          if (!children)
            children = this.children.slice();
          while (childIndex < children.length && children[childIndex] < childOffset)
            childIndex += 3;
          if (children[childIndex] == childOffset)
            children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
          else
            children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
          childIndex += 3;
        });
        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
        for (let i2 = 0; i2 < local.length; i2++)
          if (!local[i2].type.valid(doc2, local[i2]))
            local.splice(i2--, 1);
        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(decorations) {
        if (decorations.length == 0 || this == empty)
          return this;
        return this.removeInner(decorations, 0);
      }
      removeInner(decorations, offset) {
        let children = this.children, local = this.local;
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let found2;
          let from = children[i2] + offset, to2 = children[i2 + 1] + offset;
          for (let j = 0, span; j < decorations.length; j++)
            if (span = decorations[j]) {
              if (span.from > from && span.to < to2) {
                decorations[j] = null;
                (found2 || (found2 = [])).push(span);
              }
            }
          if (!found2)
            continue;
          if (children == this.children)
            children = this.children.slice();
          let removed = children[i2 + 2].removeInner(found2, from + 1);
          if (removed != empty) {
            children[i2 + 2] = removed;
          } else {
            children.splice(i2, 3);
            i2 -= 3;
          }
        }
        if (local.length) {
          for (let i2 = 0, span; i2 < decorations.length; i2++)
            if (span = decorations[i2]) {
              for (let j = 0; j < local.length; j++)
                if (local[j].eq(span, offset)) {
                  if (local == this.local)
                    local = this.local.slice();
                  local.splice(j--, 1);
                }
            }
        }
        if (children == this.children && local == this.local)
          return this;
        return local.length || children.length ? new DecorationSet(local, children) : empty;
      }
      forChild(offset, node) {
        if (this == empty)
          return this;
        if (node.isLeaf)
          return DecorationSet.empty;
        let child, local;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] >= offset) {
            if (this.children[i2] == offset)
              child = this.children[i2 + 2];
            break;
          }
        let start = offset + 1, end = start + node.content.size;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let dec = this.local[i2];
          if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
            let from = Math.max(start, dec.from) - start, to2 = Math.min(end, dec.to) - start;
            if (from < to2)
              (local || (local = [])).push(dec.copy(from, to2));
          }
        }
        if (local) {
          let localSet = new DecorationSet(local.sort(byPos), none);
          return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
      }
      /**
      @internal
      */
      eq(other) {
        if (this == other)
          return true;
        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
          return false;
        for (let i2 = 0; i2 < this.local.length; i2++)
          if (!this.local[i2].eq(other.local[i2]))
            return false;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(node) {
        return removeOverlap(this.localsInner(node));
      }
      /**
      @internal
      */
      localsInner(node) {
        if (this == empty)
          return none;
        if (node.inlineContent || !this.local.some(InlineType.is))
          return this.local;
        let result = [];
        for (let i2 = 0; i2 < this.local.length; i2++) {
          if (!(this.local[i2].type instanceof InlineType))
            result.push(this.local[i2]);
        }
        return result;
      }
      forEachSet(f) {
        f(this);
      }
    }
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    const empty = DecorationSet.empty;
    class DecorationGroup {
      constructor(members) {
        this.members = members;
      }
      map(mapping, doc2) {
        const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
        return DecorationGroup.from(mappedDecos);
      }
      forChild(offset, child) {
        if (child.isLeaf)
          return DecorationSet.empty;
        let found2 = [];
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let result = this.members[i2].forChild(offset, child);
          if (result == empty)
            continue;
          if (result instanceof DecorationGroup)
            found2 = found2.concat(result.members);
          else
            found2.push(result);
        }
        return DecorationGroup.from(found2);
      }
      eq(other) {
        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
          return false;
        for (let i2 = 0; i2 < this.members.length; i2++)
          if (!this.members[i2].eq(other.members[i2]))
            return false;
        return true;
      }
      locals(node) {
        let result, sorted = true;
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let locals = this.members[i2].localsInner(node);
          if (!locals.length)
            continue;
          if (!result) {
            result = locals;
          } else {
            if (sorted) {
              result = result.slice();
              sorted = false;
            }
            for (let j = 0; j < locals.length; j++)
              result.push(locals[j]);
          }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(members) {
        switch (members.length) {
          case 0:
            return empty;
          case 1:
            return members[0];
          default:
            return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
        }
      }
      forEachSet(f) {
        for (let i2 = 0; i2 < this.members.length; i2++)
          this.members[i2].forEachSet(f);
      }
    }
    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
      let children = oldChildren.slice();
      for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
        let moved = 0;
        mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
          let dSize = newEnd - newStart - (oldEnd - oldStart);
          for (let i3 = 0; i3 < children.length; i3 += 3) {
            let end = children[i3 + 1];
            if (end < 0 || oldStart > end + baseOffset - moved)
              continue;
            let start = children[i3] + baseOffset - moved;
            if (oldEnd >= start) {
              children[i3 + 1] = oldStart <= start ? -2 : -1;
            } else if (oldStart >= baseOffset && dSize) {
              children[i3] += dSize;
              children[i3 + 1] += dSize;
            }
          }
          moved += dSize;
        });
        baseOffset = mapping.maps[i2].map(baseOffset, -1);
      }
      let mustRebuild = false;
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] < 0) {
          if (children[i2 + 1] == -2) {
            mustRebuild = true;
            children[i2 + 1] = -1;
            continue;
          }
          let from = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from - offset;
          if (fromLocal < 0 || fromLocal >= node.content.size) {
            mustRebuild = true;
            continue;
          }
          let to2 = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to2 - offset;
          let { index, offset: childOffset } = node.content.findIndex(fromLocal);
          let childNode = node.maybeChild(index);
          if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
            let mapped = children[i2 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i2] + oldOffset + 1, options);
            if (mapped != empty) {
              children[i2] = fromLocal;
              children[i2 + 1] = toLocal;
              children[i2 + 2] = mapped;
            } else {
              children[i2 + 1] = -2;
              mustRebuild = true;
            }
          } else {
            mustRebuild = true;
          }
        }
      if (mustRebuild) {
        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
        let built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (let i2 = 0; i2 < children.length; i2 += 3)
          if (children[i2 + 1] < 0) {
            children.splice(i2, 3);
            i2 -= 3;
          }
        for (let i2 = 0, j = 0; i2 < built.children.length; i2 += 3) {
          let from = built.children[i2];
          while (j < children.length && children[j] < from)
            j += 3;
          children.splice(j, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
        }
      }
      return new DecorationSet(newLocal.sort(byPos), children);
    }
    function moveSpans(spans, offset) {
      if (!offset || !spans.length)
        return spans;
      let result = [];
      for (let i2 = 0; i2 < spans.length; i2++) {
        let span = spans[i2];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result;
    }
    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
      function gather(set, oldOffset2) {
        for (let i2 = 0; i2 < set.local.length; i2++) {
          let mapped = set.local[i2].map(mapping, offset, oldOffset2);
          if (mapped)
            decorations.push(mapped);
          else if (options.onRemove)
            options.onRemove(set.local[i2].spec);
        }
        for (let i2 = 0; i2 < set.children.length; i2 += 3)
          gather(set.children[i2 + 2], set.children[i2] + oldOffset2 + 1);
      }
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] == -1)
          gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
      return decorations;
    }
    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf)
        return null;
      let end = offset + node.nodeSize, found2 = null;
      for (let i2 = 0, span; i2 < spans.length; i2++) {
        if ((span = spans[i2]) && span.from > offset && span.to < end) {
          (found2 || (found2 = [])).push(span);
          spans[i2] = null;
        }
      }
      return found2;
    }
    function withoutNulls(array) {
      let result = [];
      for (let i2 = 0; i2 < array.length; i2++)
        if (array[i2] != null)
          result.push(array[i2]);
      return result;
    }
    function buildTree(spans, node, offset, options) {
      let children = [], hasNulls = false;
      node.forEach((childNode, localStart) => {
        let found2 = takeSpansForNode(spans, childNode, localStart + offset);
        if (found2) {
          hasNulls = true;
          let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
          if (subtree != empty)
            children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
      });
      let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (let i2 = 0; i2 < locals.length; i2++)
        if (!locals[i2].type.valid(node, locals[i2])) {
          if (options.onRemove)
            options.onRemove(locals[i2].spec);
          locals.splice(i2--, 1);
        }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty;
    }
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to;
    }
    function removeOverlap(spans) {
      let working = spans;
      for (let i2 = 0; i2 < working.length - 1; i2++) {
        let span = working[i2];
        if (span.from != span.to)
          for (let j = i2 + 1; j < working.length; j++) {
            let next = working[j];
            if (next.from == span.from) {
              if (next.to != span.to) {
                if (working == spans)
                  working = spans.slice();
                working[j] = next.copy(next.from, span.to);
                insertAhead(working, j + 1, next.copy(span.to, next.to));
              }
              continue;
            } else {
              if (next.from < span.to) {
                if (working == spans)
                  working = spans.slice();
                working[i2] = span.copy(span.from, next.from);
                insertAhead(working, j, span.copy(next.from, span.to));
              }
              break;
            }
          }
      }
      return working;
    }
    function insertAhead(array, i2, deco) {
      while (i2 < array.length && byPos(deco, array[i2]) > 0)
        i2++;
      array.splice(i2, 0, deco);
    }
    function viewDecorations(view) {
      let found2 = [];
      view.someProp("decorations", (f) => {
        let result = f(view.state);
        if (result && result != empty)
          found2.push(result);
      });
      if (view.cursorWrapper)
        found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
      return DecorationGroup.from(found2);
    }
    const observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    const useCharData = ie$1 && ie_version <= 11;
    class SelectionState {
      constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      set(sel) {
        this.anchorNode = sel.anchorNode;
        this.anchorOffset = sel.anchorOffset;
        this.focusNode = sel.focusNode;
        this.focusOffset = sel.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(sel) {
        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
      }
    }
    class DOMObserver {
      constructor(view, handleDOMChange) {
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState();
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.lastChangedTextNode = null;
        this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
          for (let i2 = 0; i2 < mutations.length; i2++)
            this.queue.push(mutations[i2]);
          if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
            this.flushSoon();
          else
            this.flush();
        });
        if (useCharData) {
          this.onCharData = (e) => {
            this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
            this.flushSoon();
          };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        if (this.flushingSoon < 0)
          this.flushingSoon = window.setTimeout(() => {
            this.flushingSoon = -1;
            this.flush();
          }, 20);
      }
      forceFlush() {
        if (this.flushingSoon > -1) {
          window.clearTimeout(this.flushingSoon);
          this.flushingSoon = -1;
          this.flush();
        }
      }
      start() {
        if (this.observer) {
          this.observer.takeRecords();
          this.observer.observe(this.view.dom, observeOptions);
        }
        if (this.onCharData)
          this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let take = this.observer.takeRecords();
          if (take.length) {
            for (let i2 = 0; i2 < take.length; i2++)
              this.queue.push(take[i2]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        if (this.onCharData)
          this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true;
        setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (!hasFocusAndSelection(this.view))
          return;
        if (this.suppressingSelectionUpdates)
          return selectionToDOM(this.view);
        if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
          let sel = this.view.domSelectionRange();
          if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            return this.flushSoon();
        }
        this.flush();
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(sel) {
        if (!sel.focusNode)
          return true;
        let ancestors = /* @__PURE__ */ new Set(), container;
        for (let scan = sel.focusNode; scan; scan = parentNode(scan))
          ancestors.add(scan);
        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
          if (ancestors.has(scan)) {
            container = scan;
            break;
          }
        let desc = container && this.view.docView.nearestDesc(container);
        if (desc && desc.ignoreMutation({
          type: "selection",
          target: container.nodeType == 3 ? container.parentNode : container
        })) {
          this.setCurSelection();
          return true;
        }
      }
      pendingRecords() {
        if (this.observer)
          for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
      }
      flush() {
        let { view } = this;
        if (!view.docView || this.flushingSoon > -1)
          return;
        let mutations = this.pendingRecords();
        if (mutations.length)
          this.queue = [];
        let sel = view.domSelectionRange();
        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
        let from = -1, to2 = -1, typeOver = false, added = [];
        if (view.editable) {
          for (let i2 = 0; i2 < mutations.length; i2++) {
            let result = this.registerMutation(mutations[i2], added);
            if (result) {
              from = from < 0 ? result.from : Math.min(result.from, from);
              to2 = to2 < 0 ? result.to : Math.max(result.to, to2);
              if (result.typeOver)
                typeOver = true;
            }
          }
        }
        if (gecko && added.length) {
          let brs = added.filter((n) => n.nodeName == "BR");
          if (brs.length == 2) {
            let [a, b] = brs;
            if (a.parentNode && a.parentNode.parentNode == b.parentNode)
              b.remove();
            else
              a.remove();
          } else {
            let { focusNode } = this.currentSelection;
            for (let br2 of brs) {
              let parent = br2.parentNode;
              if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
                br2.remove();
            }
          }
        }
        let readSel = null;
        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
          view.input.lastFocus = 0;
          selectionToDOM(view);
          this.currentSelection.set(sel);
        } else if (from > -1 || newSel) {
          if (from > -1) {
            view.docView.markDirty(from, to2);
            checkCSS(view);
          }
          this.handleDOMChange(from, to2, typeOver, added);
          if (view.docView && view.docView.dirty)
            view.updateState(view.state);
          else if (!this.currentSelection.eq(sel))
            selectionToDOM(view);
          this.currentSelection.set(sel);
        }
      }
      registerMutation(mut, added) {
        if (added.indexOf(mut.target) > -1)
          return null;
        let desc = this.view.docView.nearestDesc(mut.target);
        if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
          return null;
        if (!desc || desc.ignoreMutation(mut))
          return null;
        if (mut.type == "childList") {
          for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
            let node = mut.addedNodes[i2];
            added.push(node);
            if (node.nodeType == 3)
              this.lastChangedTextNode = node;
          }
          if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
            return { from: desc.posBefore, to: desc.posAfter };
          let prev = mut.previousSibling, next = mut.nextSibling;
          if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
            for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
              let { previousSibling, nextSibling } = mut.addedNodes[i2];
              if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
                prev = previousSibling;
              if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
                next = nextSibling;
            }
          }
          let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
          let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
          let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
          let to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
          return { from, to: to2 };
        } else if (mut.type == "attributes") {
          return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
        } else {
          this.lastChangedTextNode = mut.target;
          return {
            from: desc.posAtStart,
            to: desc.posAtEnd,
            // An event was generated for a text change that didn't change
            // any text. Mark the dom change to fall back to assuming the
            // selection was typed over with an identical value if it can't
            // find another change.
            typeOver: mut.target.nodeValue == mut.oldValue
          };
        }
      }
    }
    let cssChecked = /* @__PURE__ */ new WeakMap();
    let cssCheckWarned = false;
    function checkCSS(view) {
      if (cssChecked.has(view))
        return;
      cssChecked.set(view, null);
      if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
        view.requiresGeckoHackNode = gecko;
        if (cssCheckWarned)
          return;
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
        cssCheckWarned = true;
      }
    }
    function rangeToSelectionRange(view, range2) {
      let anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
      let focusNode = range2.endContainer, focusOffset = range2.endOffset;
      let currentAnchor = view.domAtPos(view.state.selection.anchor);
      if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
      return { anchorNode, anchorOffset, focusNode, focusOffset };
    }
    function safariShadowSelectionRange(view, selection) {
      if (selection.getComposedRanges) {
        let range2 = selection.getComposedRanges(view.root)[0];
        if (range2)
          return rangeToSelectionRange(view, range2);
      }
      let found2;
      function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found2 = event.getTargetRanges()[0];
      }
      view.dom.addEventListener("beforeinput", read, true);
      document.execCommand("indent");
      view.dom.removeEventListener("beforeinput", read, true);
      return found2 ? rangeToSelectionRange(view, found2) : null;
    }
    function blockParent(view, node) {
      for (let p2 = node.parentNode; p2 && p2 != view.dom; p2 = p2.parentNode) {
        let desc = view.docView.nearestDesc(p2, true);
        if (desc && desc.node.isBlock)
          return p2;
      }
      return null;
    }
    function parseBetween(view, from_, to_) {
      let { node: parent, fromOffset, toOffset, from, to: to2 } = view.docView.parseRange(from_, to_);
      let domSel = view.domSelectionRange();
      let find2;
      let anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find2 = [{ node: anchor, offset: domSel.anchorOffset }];
        if (!selectionCollapsed(domSel))
          find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
      }
      if (chrome && view.input.lastKeyCode === 8) {
        for (let off2 = toOffset; off2 > fromOffset; off2--) {
          let node = parent.childNodes[off2 - 1], desc = node.pmViewDesc;
          if (node.nodeName == "BR" && !desc) {
            toOffset = off2;
            break;
          }
          if (!desc || desc.size)
            break;
        }
      }
      let startDoc = view.state.doc;
      let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
      let $from = startDoc.resolve(from);
      let sel = null, doc2 = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find2,
        ruleFromNode,
        context: $from
      });
      if (find2 && find2[0].pos != null) {
        let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
        if (head == null)
          head = anchor2;
        sel = { anchor: anchor2 + from, head: head + from };
      }
      return { doc: doc2, sel, from, to: to2 };
    }
    function ruleFromNode(dom) {
      let desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule();
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          let skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return { skip };
        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return { ignore: true };
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return { ignore: true };
      }
      return null;
    }
    const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function readDOMChange(view, from, to2, typeOver, addedNodes) {
      let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
      view.input.compositionPendingChanges = 0;
      if (from < 0) {
        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
        let newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
            return;
          let tr3 = view.state.tr.setSelection(newSel);
          if (origin == "pointer")
            tr3.setMeta("pointer", true);
          else if (origin == "key")
            tr3.scrollIntoView();
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
        return;
      }
      let $before = view.state.doc.resolve(from);
      let shared = $before.sharedDepth(to2);
      from = $before.before(shared + 1);
      to2 = view.state.doc.resolve(to2).after(shared + 1);
      let sel = view.state.selection;
      let parse = parseBetween(view, from, to2);
      let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
      let preferredPos, preferredSide;
      if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.input.lastKeyCode = null;
      let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if (change)
        view.input.domChangeCount++;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (!change) {
        if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = { start: sel.from, endA: sel.to, endB: sel.to };
        } else {
          if (parse.sel) {
            let sel2 = resolveSelection(view, view.state.doc, parse.sel);
            if (sel2 && !sel2.eq(view.state.selection)) {
              let tr3 = view.state.tr.setSelection(sel2);
              if (compositionID)
                tr3.setMeta("composition", compositionID);
              view.dispatch(tr3);
            }
          }
          return;
        }
      }
      if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
          change.endB += view.state.selection.to - change.endA;
          change.endA = view.state.selection.to;
        }
      }
      if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " ") {
        change.start--;
        change.endA--;
        change.endB--;
      }
      let $from = parse.doc.resolveNoCache(change.start - parse.from);
      let $to = parse.doc.resolveNoCache(change.endB - parse.from);
      let $fromA = doc2.resolve(change.start);
      let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
      let nextSel;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
        if (android && chrome)
          view.domObserver.suppressSelectionUpdates();
        return;
      }
      if (chrome && change.endB == change.start)
        view.input.lastChromeDelete = Date.now();
      if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(() => {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
        }, 20);
      }
      let chFrom = change.start, chTo = change.endA;
      let tr2, storedMarks, markChange;
      if (inlineChange) {
        if ($from.pos == $to.pos) {
          if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(() => selectionToDOM(view), 20);
          }
          tr2 = view.state.tr.delete(chFrom, chTo);
          storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
        } else if (
          // Adding or removing a mark
          change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
        ) {
          tr2 = view.state.tr;
          if (markChange.type == "add")
            tr2.addMark(chFrom, chTo, markChange.mark);
          else
            tr2.removeMark(chFrom, chTo, markChange.mark);
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
            return;
          tr2 = view.state.tr.insertText(text, chFrom, chTo);
        }
      }
      if (!tr2)
        tr2 = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
      if (parse.sel) {
        let sel2 = resolveSelection(view, tr2.doc, parse.sel);
        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
          tr2.setSelection(sel2);
      }
      if (storedMarks)
        tr2.ensureMarks(storedMarks);
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2.scrollIntoView());
    }
    function resolveSelection(view, doc2, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
        return null;
      return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
    }
    function isMarkChange(cur, prev) {
      let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      let added = curMarks, removed = prevMarks, type, mark, update;
      for (let i2 = 0; i2 < prevMarks.length; i2++)
        added = prevMarks[i2].removeFromSet(added);
      for (let i2 = 0; i2 < curMarks.length; i2++)
        removed = curMarks[i2].removeFromSet(removed);
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = (node) => node.mark(mark.addToSet(node.marks));
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = (node) => node.mark(mark.removeFromSet(node.marks));
      } else {
        return null;
      }
      let updated = [];
      for (let i2 = 0; i2 < prev.childCount; i2++)
        updated.push(update(prev.child(i2)));
      if (Fragment.from(updated).eq(cur))
        return { mark, type };
    }
    function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
      if (
        // The content must have shrunk
        end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
        skipClosingAndOpening($newStart, true, false) < $newEnd.pos
      )
        return false;
      let $start = old.resolve(start);
      if (!$newStart.parent.isTextblock) {
        let after = $start.nodeAfter;
        return after != null && end == start + after.nodeSize;
      }
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
        return false;
      let $next = old.resolve(skipClosingAndOpening($start, true, true));
      if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
        return false;
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
    }
    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end;
    }
    function findDiff(a, b, pos, preferredPos, preferredSide) {
      let start = a.findDiffStart(b, pos);
      if (start == null)
        return null;
      let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
      if (preferredSide == "end") {
        let adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
          start += move ? 1 : -1;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= move;
        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
          start += move ? 1 : -1;
        endA = start + (endA - endB);
        endB = start;
      }
      return { start, endA, endB };
    }
    function isSurrogatePair(str) {
      if (str.length != 2)
        return false;
      let a = str.charCodeAt(0), b = str.charCodeAt(1);
      return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
    }
    class EditorView {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(place, props) {
        this._root = null;
        this.focused = false;
        this.trackWrites = null;
        this.mounted = false;
        this.markCursor = null;
        this.cursorWrapper = null;
        this.lastSelectedViewDesc = void 0;
        this.input = new InputState();
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        this.requiresGeckoHackNode = false;
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild)
            place.appendChild(this.dom);
          else if (typeof place == "function")
            place(this.dom);
          else if (place.mount)
            this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, (from, to2, typeOver, added) => readDOMChange(this, from, to2, typeOver, added));
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let prev = this._props;
          this._props = {};
          for (let name in prev)
            this._props[name] = prev[name];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(props) {
        if (props.handleDOMEvents != this._props.handleDOMEvents)
          ensureListeners(this);
        let prevProps = this._props;
        this._props = props;
        if (props.plugins) {
          props.plugins.forEach(checkStateComponent);
          this.directPlugins = props.plugins;
        }
        this.updateStateInner(props.state, prevProps);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(props) {
        let updated = {};
        for (let name in this._props)
          updated[name] = this._props[name];
        updated.state = this.state;
        for (let name in props)
          updated[name] = props[name];
        this.update(updated);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(state) {
        this.updateStateInner(state, this._props);
      }
      updateStateInner(state, prevProps) {
        var _a2;
        let prev = this.state, redraw = false, updateSel = false;
        if (state.storedMarks && this.composing) {
          clearComposition(this);
          updateSel = true;
        }
        this.state = state;
        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
          let nodeViews = buildNodeViews(this);
          if (changedNodeViews(nodeViews, this.nodeViews)) {
            this.nodeViews = nodeViews;
            redraw = true;
          }
        }
        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
          ensureListeners(this);
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
        if (updateDoc || !state.selection.eq(prev.selection))
          updateSel = true;
        let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
        if (updateSel) {
          this.domObserver.stop();
          let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
          if (updateDoc) {
            let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
            if (this.composing)
              this.input.compositionNode = findCompositionNode(this);
            if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
              this.docView.updateOuterDeco(outerDeco);
              this.docView.destroy();
              this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
            }
            if (chromeKludge && !this.trackWrites)
              forceSelUpdate = true;
          }
          if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
            selectionToDOM(this, forceSelUpdate);
          } else {
            syncNodeSelection(this, state.selection);
            this.domObserver.setCurSelection();
          }
          this.domObserver.start();
        }
        this.updatePluginViews(prev);
        if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc))
          this.updateDraggedNode(this.dragging, prev);
        if (scroll == "reset") {
          this.dom.scrollTop = 0;
        } else if (scroll == "to selection") {
          this.scrollToSelection();
        } else if (oldScrollPos) {
          resetScrollPos(oldScrollPos);
        }
      }
      /**
      @internal
      */
      scrollToSelection() {
        let startDOM = this.domSelectionRange().focusNode;
        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
        else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
        else if (this.state.selection instanceof NodeSelection) {
          let target = this.docView.domAfterPos(this.state.selection.from);
          if (target.nodeType == 1)
            scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
        }
      }
      destroyPluginViews() {
        let view;
        while (view = this.pluginViews.pop())
          if (view.destroy)
            view.destroy();
      }
      updatePluginViews(prevState) {
        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins;
          this.destroyPluginViews();
          for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
            let plugin2 = this.directPlugins[i2];
            if (plugin2.spec.view)
              this.pluginViews.push(plugin2.spec.view(this));
          }
          for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
            let plugin2 = this.state.plugins[i2];
            if (plugin2.spec.view)
              this.pluginViews.push(plugin2.spec.view(this));
          }
        } else {
          for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
            let pluginView = this.pluginViews[i2];
            if (pluginView.update)
              pluginView.update(this, prevState);
          }
        }
      }
      updateDraggedNode(dragging, prev) {
        let sel = dragging.node, found2 = -1;
        if (this.state.doc.nodeAt(sel.from) == sel.node) {
          found2 = sel.from;
        } else {
          let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
          let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
          if (moved == sel.node)
            found2 = movedPos;
        }
        this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
      }
      someProp(propName, f) {
        let prop = this._props && this._props[propName], value;
        if (prop != null && (value = f ? f(prop) : prop))
          return value;
        for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
          let prop2 = this.directPlugins[i2].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
        let plugins = this.state.plugins;
        if (plugins)
          for (let i2 = 0; i2 < plugins.length; i2++) {
            let prop2 = plugins[i2].props[propName];
            if (prop2 != null && (value = f ? f(prop2) : prop2))
              return value;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (ie$1) {
          let node = this.root.activeElement;
          if (node == this.dom)
            return true;
          if (!node || !this.dom.contains(node))
            return false;
          while (node && this.dom != node && this.dom.contains(node)) {
            if (node.contentEditable == "false")
              return false;
            node = node.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop();
        if (this.editable)
          focusPreventScroll(this.dom);
        selectionToDOM(this);
        this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let cached = this._root;
        if (cached == null)
          for (let search = this.dom.parentNode; search; search = search.parentNode) {
            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
              if (!search.getSelection)
                Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
              return this._root = search;
            }
          }
        return cached || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(coords) {
        return posAtCoords(this, coords);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(pos, side = 1) {
        return coordsAtPos(this, pos, side);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(pos, side = 0) {
        return this.docView.domFromPos(pos, side);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(pos) {
        let desc = this.docView.descAt(pos);
        return desc ? desc.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimesfor example when interpreting an event
      targetyou don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(node, offset, bias = -1) {
        let pos = this.docView.posFromDOM(node, offset, bias);
        if (pos == null)
          throw new RangeError("DOM position not inside the editor");
        return pos;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(dir, state) {
        return endOfTextblock(this, state || this.state, dir);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(html, event) {
        return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(text, event) {
        return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(slice) {
        return serializeForClipboard(this, slice);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        if (!this.docView)
          return;
        destroyInput(this);
        this.destroyPluginViews();
        if (this.mounted) {
          this.docView.update(this.state.doc, [], viewDecorations(this), this);
          this.dom.textContent = "";
        } else if (this.dom.parentNode) {
          this.dom.parentNode.removeChild(this.dom);
        }
        this.docView.destroy();
        this.docView = null;
        clearReusedRange();
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(event) {
        return dispatchEvent(this, event);
      }
      /**
      Dispatch a transaction. Will call
      [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
      when given, and otherwise defaults to applying the transaction to
      the current state and calling
      [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
      This method is bound to the view instance, so that it can be
      easily passed around.
      */
      dispatch(tr2) {
        let dispatchTransaction = this._props.dispatchTransaction;
        if (dispatchTransaction)
          dispatchTransaction.call(this, tr2);
        else
          this.updateState(this.state.apply(tr2));
      }
      /**
      @internal
      */
      domSelectionRange() {
        let sel = this.domSelection();
        if (!sel)
          return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    }
    function computeDocDeco(view) {
      let attrs = /* @__PURE__ */ Object.create(null);
      attrs.class = "ProseMirror";
      attrs.contenteditable = String(view.editable);
      view.someProp("attributes", (value) => {
        if (typeof value == "function")
          value = value(view.state);
        if (value)
          for (let attr in value) {
            if (attr == "class")
              attrs.class += " " + value[attr];
            else if (attr == "style")
              attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
            else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
              attrs[attr] = String(value[attr]);
          }
      });
      if (!attrs.translate)
        attrs.translate = "no";
      return [Decoration.node(0, view.state.doc.content.size, attrs)];
    }
    function updateCursorWrapper(view) {
      if (view.markCursor) {
        let dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        dom.setAttribute("alt", "");
        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
      } else {
        view.cursorWrapper = null;
      }
    }
    function getEditable(view) {
      return !view.someProp("editable", (value) => value(view.state) === false);
    }
    function selectionContextChanged(sel1, sel2) {
      let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
    }
    function buildNodeViews(view) {
      let result = /* @__PURE__ */ Object.create(null);
      function add(obj) {
        for (let prop in obj)
          if (!Object.prototype.hasOwnProperty.call(result, prop))
            result[prop] = obj[prop];
      }
      view.someProp("nodeViews", add);
      view.someProp("markViews", add);
      return result;
    }
    function changedNodeViews(a, b) {
      let nA = 0, nB = 0;
      for (let prop in a) {
        if (a[prop] != b[prop])
          return true;
        nA++;
      }
      for (let _ in b)
        nB++;
      return nA != nB;
    }
    function checkStateComponent(plugin2) {
      if (plugin2.spec.state || plugin2.spec.filterTransaction || plugin2.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
    for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
    for (var i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
    function keyName(event) {
      var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      if (name == "Esc") name = "Escape";
      if (name == "Del") name = "Delete";
      if (name == "Left") name = "ArrowLeft";
      if (name == "Up") name = "ArrowUp";
      if (name == "Right") name = "ArrowRight";
      if (name == "Down") name = "ArrowDown";
      return name;
    }
    const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function normalizeKeyName$1(name) {
      let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space")
        result = " ";
      let alt, ctrl, shift2, meta;
      for (let i2 = 0; i2 < parts.length - 1; i2++) {
        let mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod))
          meta = true;
        else if (/^a(lt)?$/i.test(mod))
          alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
          ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
          shift2 = true;
        else if (/^mod$/i.test(mod)) {
          if (mac)
            meta = true;
          else
            ctrl = true;
        } else
          throw new Error("Unrecognized modifier name: " + mod);
      }
      if (alt)
        result = "Alt-" + result;
      if (ctrl)
        result = "Ctrl-" + result;
      if (meta)
        result = "Meta-" + result;
      if (shift2)
        result = "Shift-" + result;
      return result;
    }
    function normalize(map) {
      let copy2 = /* @__PURE__ */ Object.create(null);
      for (let prop in map)
        copy2[normalizeKeyName$1(prop)] = map[prop];
      return copy2;
    }
    function modifiers(name, event, shift2 = true) {
      if (event.altKey)
        name = "Alt-" + name;
      if (event.ctrlKey)
        name = "Ctrl-" + name;
      if (event.metaKey)
        name = "Meta-" + name;
      if (shift2 && event.shiftKey)
        name = "Shift-" + name;
      return name;
    }
    function keymap(bindings) {
      return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
    }
    function keydownHandler(bindings) {
      let map = normalize(bindings);
      return function(view, event) {
        let name = keyName(event), baseName, direct = map[modifiers(name, event)];
        if (direct && direct(view.state, view.dispatch, view))
          return true;
        if (name.length == 1 && name != " ") {
          if (event.shiftKey) {
            let noShift = map[modifiers(name, event, false)];
            if (noShift && noShift(view.state, view.dispatch, view))
              return true;
          }
          if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
            let fromCode = map[modifiers(baseName, event)];
            if (fromCode && fromCode(view.state, view.dispatch, view))
              return true;
          }
        }
        return false;
      };
    }
    const deleteSelection$1 = (state, dispatch) => {
      if (state.selection.empty)
        return false;
      if (dispatch)
        dispatch(state.tr.deleteSelection().scrollIntoView());
      return true;
    };
    function atBlockStart(state, view) {
      let { $cursor } = state.selection;
      if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
        return null;
      return $cursor;
    }
    const joinBackward$1 = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      if (!$cut) {
        let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
        if (target == null)
          return false;
        if (dispatch)
          dispatch(state.tr.lift(range2, target).scrollIntoView());
        return true;
      }
      let before = $cut.nodeBefore;
      if (deleteBarrier(state, $cut, dispatch, -1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        for (let depth = $cursor.depth; ; depth--) {
          let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
              let tr2 = state.tr.step(delStep);
              tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
              dispatch(tr2.scrollIntoView());
            }
            return true;
          }
          if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
            break;
        }
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
      }
      return false;
    };
    const joinTextblockBackward$1 = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    const joinTextblockForward$1 = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    function joinTextblocksAround(state, $cut, dispatch) {
      let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
      for (; !beforeText.isTextblock; beforePos--) {
        if (beforeText.type.spec.isolating)
          return false;
        let child = beforeText.lastChild;
        if (!child)
          return false;
        beforeText = child;
      }
      let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
      for (; !afterText.isTextblock; afterPos++) {
        if (afterText.type.spec.isolating)
          return false;
        let child = afterText.firstChild;
        if (!child)
          return false;
        afterText = child;
      }
      let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
      if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
        return false;
      if (dispatch) {
        let tr2 = state.tr.step(step);
        tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
    function textblockAt(node, side, only = false) {
      for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
        if (scan.isTextblock)
          return true;
        if (only && scan.childCount != 1)
          return false;
      }
      return false;
    }
    const selectNodeBackward$1 = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
          return false;
        $cut = findCutBefore($head);
      }
      let node = $cut && $cut.nodeBefore;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      return true;
    };
    function findCutBefore($pos) {
      if (!$pos.parent.type.spec.isolating)
        for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
          if ($pos.index(i2) > 0)
            return $pos.doc.resolve($pos.before(i2 + 1));
          if ($pos.node(i2).type.spec.isolating)
            break;
        }
      return null;
    }
    function atBlockEnd(state, view) {
      let { $cursor } = state.selection;
      if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
        return null;
      return $cursor;
    }
    const joinForward$1 = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      if (!$cut)
        return false;
      let after = $cut.nodeAfter;
      if (deleteBarrier(state, $cut, dispatch, 1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr2 = state.tr.step(delStep);
            tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
            dispatch(tr2.scrollIntoView());
          }
          return true;
        }
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
      }
      return false;
    };
    const selectNodeForward$1 = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
          return false;
        $cut = findCutAfter($head);
      }
      let node = $cut && $cut.nodeAfter;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
      return true;
    };
    function findCutAfter($pos) {
      if (!$pos.parent.type.spec.isolating)
        for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
          let parent = $pos.node(i2);
          if ($pos.index(i2) + 1 < parent.childCount)
            return $pos.doc.resolve($pos.after(i2 + 1));
          if (parent.type.spec.isolating)
            break;
        }
      return null;
    }
    const joinUp$1 = (state, dispatch) => {
      let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
          return false;
        point = sel.from;
      } else {
        point = joinPoint(state.doc, sel.from, -1);
        if (point == null)
          return false;
      }
      if (dispatch) {
        let tr2 = state.tr.join(point);
        if (nodeSel)
          tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    const joinDown$1 = (state, dispatch) => {
      let sel = state.selection, point;
      if (sel instanceof NodeSelection) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
          return false;
        point = sel.to;
      } else {
        point = joinPoint(state.doc, sel.to, 1);
        if (point == null)
          return false;
      }
      if (dispatch)
        dispatch(state.tr.join(point).scrollIntoView());
      return true;
    };
    const lift$1 = (state, dispatch) => {
      let { $from, $to } = state.selection;
      let range2 = $from.blockRange($to), target = range2 && liftTarget(range2);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range2, target).scrollIntoView());
      return true;
    };
    const newlineInCode$1 = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      if (dispatch)
        dispatch(state.tr.insertText("\n").scrollIntoView());
      return true;
    };
    function defaultBlockAt$1(match) {
      for (let i2 = 0; i2 < match.edgeCount; i2++) {
        let { type } = match.edge(i2);
        if (type.isTextblock && !type.hasRequiredAttrs())
          return type;
      }
      return null;
    }
    const exitCode$1 = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after));
      if (!type || !above.canReplaceWith(after, after, type))
        return false;
      if (dispatch) {
        let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    const createParagraphNear$1 = (state, dispatch) => {
      let sel = state.selection, { $from, $to } = sel;
      if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
        return false;
      let type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock)
        return false;
      if (dispatch) {
        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        let tr2 = state.tr.insert(side, type.createAndFill());
        tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    };
    const liftEmptyBlock$1 = (state, dispatch) => {
      let { $cursor } = state.selection;
      if (!$cursor || $cursor.parent.content.size)
        return false;
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        let before = $cursor.before();
        if (canSplit(state.doc, before)) {
          if (dispatch)
            dispatch(state.tr.split(before).scrollIntoView());
          return true;
        }
      }
      let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range2, target).scrollIntoView());
      return true;
    };
    function splitBlockAs(splitNode) {
      return (state, dispatch) => {
        let { $from, $to } = state.selection;
        if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
          if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
            return false;
          if (dispatch)
            dispatch(state.tr.split($from.pos).scrollIntoView());
          return true;
        }
        if (!$from.depth)
          return false;
        let types2 = [];
        let splitDepth, deflt, atEnd = false, atStart = false;
        for (let d = $from.depth; ; d--) {
          let node = $from.node(d);
          if (node.isBlock) {
            atEnd = $from.end(d) == $from.pos + ($from.depth - d);
            atStart = $from.start(d) == $from.pos - ($from.depth - d);
            deflt = defaultBlockAt$1($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
            types2.unshift(atEnd && deflt ? { type: deflt } : null);
            splitDepth = d;
            break;
          } else {
            if (d == 1)
              return false;
            types2.unshift(null);
          }
        }
        let tr2 = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
          tr2.deleteSelection();
        let splitPos = tr2.mapping.map($from.pos);
        let can = canSplit(tr2.doc, splitPos, types2.length, types2);
        if (!can) {
          types2[0] = deflt ? { type: deflt } : null;
          can = canSplit(tr2.doc, splitPos, types2.length, types2);
        }
        tr2.split(splitPos, types2.length, types2);
        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
          let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
          if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
        }
        if (dispatch)
          dispatch(tr2.scrollIntoView());
        return true;
      };
    }
    const splitBlock$1 = splitBlockAs();
    const selectParentNode$1 = (state, dispatch) => {
      let { $from, to: to2 } = state.selection, pos;
      let same = $from.sharedDepth(to2);
      if (same == 0)
        return false;
      pos = $from.before(same);
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
      return true;
    };
    function joinMaybeClear(state, $pos, dispatch) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
      if (!before || !after || !before.type.compatibleContent(after.type))
        return false;
      if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
        if (dispatch)
          dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
        return true;
      }
      if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
        return false;
      if (dispatch)
        dispatch(state.tr.join($pos.pos).scrollIntoView());
      return true;
    }
    function deleteBarrier(state, $cut, dispatch, dir) {
      let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
      let isolated = before.type.spec.isolating || after.type.spec.isolating;
      if (!isolated && joinMaybeClear(state, $cut, dispatch))
        return true;
      let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
      if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
          let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
          for (let i2 = conn.length - 1; i2 >= 0; i2--)
            wrap2 = Fragment.from(conn[i2].create(null, wrap2));
          wrap2 = Fragment.from(before.copy(wrap2));
          let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
          let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
          if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
            tr2.join($joinAt.pos);
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
      let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
      let range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && liftTarget(range2);
      if (target != null && target >= $cut.depth) {
        if (dispatch)
          dispatch(state.tr.lift(range2, target).scrollIntoView());
        return true;
      }
      if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
        let at2 = before, wrap2 = [];
        for (; ; ) {
          wrap2.push(at2);
          if (at2.isTextblock)
            break;
          at2 = at2.lastChild;
        }
        let afterText = after, afterDepth = 1;
        for (; !afterText.isTextblock; afterText = afterText.firstChild)
          afterDepth++;
        if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
          if (dispatch) {
            let end = Fragment.empty;
            for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
              end = Fragment.from(wrap2[i2].copy(end));
            let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
            dispatch(tr2.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function selectTextblockSide(side) {
      return function(state, dispatch) {
        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
        let depth = $pos.depth;
        while ($pos.node(depth).isInline) {
          if (!depth)
            return false;
          depth--;
        }
        if (!$pos.node(depth).isTextblock)
          return false;
        if (dispatch)
          dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
        return true;
      };
    }
    const selectTextblockStart$1 = selectTextblockSide(-1);
    const selectTextblockEnd$1 = selectTextblockSide(1);
    function wrapIn$1(nodeType, attrs = null) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range2 = $from.blockRange($to), wrapping = range2 && findWrapping(range2, nodeType, attrs);
        if (!wrapping)
          return false;
        if (dispatch)
          dispatch(state.tr.wrap(range2, wrapping).scrollIntoView());
        return true;
      };
    }
    function setBlockType(nodeType, attrs = null) {
      return function(state, dispatch) {
        let applicable = false;
        for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
          let { $from: { pos: from }, $to: { pos: to2 } } = state.selection.ranges[i2];
          state.doc.nodesBetween(from, to2, (node, pos) => {
            if (applicable)
              return false;
            if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
              return;
            if (node.type == nodeType) {
              applicable = true;
            } else {
              let $pos = state.doc.resolve(pos), index = $pos.index();
              applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
            }
          });
        }
        if (!applicable)
          return false;
        if (dispatch) {
          let tr2 = state.tr;
          for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
            let { $from: { pos: from }, $to: { pos: to2 } } = state.selection.ranges[i2];
            tr2.setBlockType(from, to2, nodeType, attrs);
          }
          dispatch(tr2.scrollIntoView());
        }
        return true;
      };
    }
    function chainCommands(...commands2) {
      return function(state, dispatch, view) {
        for (let i2 = 0; i2 < commands2.length; i2++)
          if (commands2[i2](state, dispatch, view))
            return true;
        return false;
      };
    }
    chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
    chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
    ({
      "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock$1)
    });
    typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
    function wrapInList$1(listType, attrs = null) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range2 = $from.blockRange($to);
        if (!range2)
          return false;
        let tr2 = dispatch ? state.tr : null;
        if (!wrapRangeInList(tr2, range2, listType, attrs))
          return false;
        if (dispatch)
          dispatch(tr2.scrollIntoView());
        return true;
      };
    }
    function wrapRangeInList(tr2, range2, listType, attrs = null) {
      let doJoin = false, outerRange = range2, doc2 = range2.$from.doc;
      if (range2.depth >= 2 && range2.$from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
        if (range2.$from.index(range2.depth - 1) == 0)
          return false;
        let $insert = doc2.resolve(range2.start - 2);
        outerRange = new NodeRange($insert, $insert, range2.depth);
        if (range2.endIndex < range2.parent.childCount)
          range2 = new NodeRange(range2.$from, doc2.resolve(range2.$to.end(range2.depth)), range2.depth);
        doJoin = true;
      }
      let wrap2 = findWrapping(outerRange, listType, attrs, range2);
      if (!wrap2)
        return false;
      if (tr2)
        doWrapInList(tr2, range2, wrap2, doJoin, listType);
      return true;
    }
    function doWrapInList(tr2, range2, wrappers, joinBefore, listType) {
      let content = Fragment.empty;
      for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
        content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
      tr2.step(new ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content, 0, 0), wrappers.length, true));
      let found2 = 0;
      for (let i2 = 0; i2 < wrappers.length; i2++)
        if (wrappers[i2].type == listType)
          found2 = i2 + 1;
      let splitDepth = wrappers.length - found2;
      let splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
      for (let i2 = range2.startIndex, e = range2.endIndex, first2 = true; i2 < e; i2++, first2 = false) {
        if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
          tr2.split(splitPos, splitDepth);
          splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(i2).nodeSize;
      }
      return tr2;
    }
    function liftListItem$1(itemType) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range2)
          return false;
        if (!dispatch)
          return true;
        if ($from.node(range2.depth - 1).type == itemType)
          return liftToOuterList(state, dispatch, itemType, range2);
        else
          return liftOutOfList(state, dispatch, range2);
      };
    }
    function liftToOuterList(state, dispatch, itemType, range2) {
      let tr2 = state.tr, end = range2.end, endOfList = range2.$to.end(range2.depth);
      if (end < endOfList) {
        tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
        range2 = new NodeRange(tr2.doc.resolve(range2.$from.pos), tr2.doc.resolve(endOfList), range2.depth);
      }
      const target = liftTarget(range2);
      if (target == null)
        return false;
      tr2.lift(range2, target);
      let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
      if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
        tr2.join($after.pos);
      dispatch(tr2.scrollIntoView());
      return true;
    }
    function liftOutOfList(state, dispatch, range2) {
      let tr2 = state.tr, list = range2.parent;
      for (let pos = range2.end, i2 = range2.endIndex - 1, e = range2.startIndex; i2 > e; i2--) {
        pos -= list.child(i2).nodeSize;
        tr2.delete(pos - 1, pos + 1);
      }
      let $start = tr2.doc.resolve(range2.start), item = $start.nodeAfter;
      if (tr2.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize)
        return false;
      let atStart = range2.startIndex == 0, atEnd = range2.endIndex == list.childCount;
      let parent = $start.node(-1), indexBefore = $start.index(-1);
      if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
        return false;
      let start = $start.pos, end = start + item.nodeSize;
      tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
      dispatch(tr2.scrollIntoView());
      return true;
    }
    function sinkListItem$1(itemType) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range2)
          return false;
        let startIndex = range2.startIndex;
        if (startIndex == 0)
          return false;
        let parent = range2.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType)
          return false;
        if (dispatch) {
          let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
          let inner = Fragment.from(nestedBefore ? itemType.create() : null);
          let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
          let before = range2.start, after = range2.end;
          dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    function createChainableState(config) {
      const { state, transaction } = config;
      let { selection } = transaction;
      let { doc: doc2 } = transaction;
      let { storedMarks } = transaction;
      return {
        ...state,
        apply: state.apply.bind(state),
        applyTransaction: state.applyTransaction.bind(state),
        plugins: state.plugins,
        schema: state.schema,
        reconfigure: state.reconfigure.bind(state),
        toJSON: state.toJSON.bind(state),
        get storedMarks() {
          return storedMarks;
        },
        get selection() {
          return selection;
        },
        get doc() {
          return doc2;
        },
        get tr() {
          selection = transaction.selection;
          doc2 = transaction.doc;
          storedMarks = transaction.storedMarks;
          return transaction;
        }
      };
    }
    class CommandManager {
      constructor(props) {
        this.editor = props.editor;
        this.rawCommands = this.editor.extensionManager.commands;
        this.customState = props.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const { tr: tr2 } = state;
        const props = this.buildProps(tr2);
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const method = (...args) => {
            const callback = command2(...args)(props);
            if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
              view.dispatch(tr2);
            }
            return callback;
          };
          return [name, method];
        }));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(startTr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const callbacks2 = [];
        const hasStartTransaction = !!startTr;
        const tr2 = startTr || state.tr;
        const run2 = () => {
          if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callbacks2.every((callback) => callback === true);
        };
        const chain = {
          ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            const chainedCommand = (...args) => {
              const props = this.buildProps(tr2, shouldDispatch);
              const callback = command2(...args)(props);
              callbacks2.push(callback);
              return chain;
            };
            return [name, chainedCommand];
          })),
          run: run2
        };
        return chain;
      }
      createCan(startTr) {
        const { rawCommands, state } = this;
        const dispatch = false;
        const tr2 = startTr || state.tr;
        const props = this.buildProps(tr2, dispatch);
        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
        }));
        return {
          ...formattedCommands,
          chain: () => this.createChain(tr2, dispatch)
        };
      }
      buildProps(tr2, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const props = {
          tr: tr2,
          editor,
          view,
          state: createChainableState({
            state,
            transaction: tr2
          }),
          dispatch: shouldDispatch ? () => void 0 : void 0,
          chain: () => this.createChain(tr2, shouldDispatch),
          can: () => this.createCan(tr2),
          get commands() {
            return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
              return [name, (...args) => command2(...args)(props)];
            }));
          }
        };
        return props;
      }
    }
    class EventEmitter {
      constructor() {
        this.callbacks = {};
      }
      on(event, fn) {
        if (!this.callbacks[event]) {
          this.callbacks[event] = [];
        }
        this.callbacks[event].push(fn);
        return this;
      }
      emit(event, ...args) {
        const callbacks2 = this.callbacks[event];
        if (callbacks2) {
          callbacks2.forEach((callback) => callback.apply(this, args));
        }
        return this;
      }
      off(event, fn) {
        const callbacks2 = this.callbacks[event];
        if (callbacks2) {
          if (fn) {
            this.callbacks[event] = callbacks2.filter((callback) => callback !== fn);
          } else {
            delete this.callbacks[event];
          }
        }
        return this;
      }
      once(event, fn) {
        const onceFn = (...args) => {
          this.off(event, onceFn);
          fn.apply(this, args);
        };
        return this.on(event, onceFn);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    }
    function getExtensionField(extension, field, context) {
      if (extension.config[field] === void 0 && extension.parent) {
        return getExtensionField(extension.parent, field, context);
      }
      if (typeof extension.config[field] === "function") {
        const value = extension.config[field].bind({
          ...context,
          parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
        });
        return value;
      }
      return extension.config[field];
    }
    function splitExtensions(extensions) {
      const baseExtensions = extensions.filter((extension) => extension.type === "extension");
      const nodeExtensions = extensions.filter((extension) => extension.type === "node");
      const markExtensions = extensions.filter((extension) => extension.type === "mark");
      return {
        baseExtensions,
        nodeExtensions,
        markExtensions
      };
    }
    function getAttributesFromExtensions(extensions) {
      const extensionAttributes = [];
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
      const defaultAttribute = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      extensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          extensions: nodeAndMarkExtensions
        };
        const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
        if (!addGlobalAttributes) {
          return;
        }
        const globalAttributes = addGlobalAttributes();
        globalAttributes.forEach((globalAttribute) => {
          globalAttribute.types.forEach((type) => {
            Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
              extensionAttributes.push({
                type,
                name,
                attribute: {
                  ...defaultAttribute,
                  ...attribute
                }
              });
            });
          });
        });
      });
      nodeAndMarkExtensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addAttributes = getExtensionField(extension, "addAttributes", context);
        if (!addAttributes) {
          return;
        }
        const attributes = addAttributes();
        Object.entries(attributes).forEach(([name, attribute]) => {
          const mergedAttr = {
            ...defaultAttribute,
            ...attribute
          };
          if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
            mergedAttr.default = mergedAttr.default();
          }
          if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
            delete mergedAttr.default;
          }
          extensionAttributes.push({
            type: extension.name,
            name,
            attribute: mergedAttr
          });
        });
      });
      return extensionAttributes;
    }
    function getNodeType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.nodes[nameOrType]) {
          throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.nodes[nameOrType];
      }
      return nameOrType;
    }
    function mergeAttributes(...objects) {
      return objects.filter((item) => !!item).reduce((items, item) => {
        const mergedAttributes = { ...items };
        Object.entries(item).forEach(([key, value]) => {
          const exists2 = mergedAttributes[key];
          if (!exists2) {
            mergedAttributes[key] = value;
            return;
          }
          if (key === "class") {
            const valueClasses = value ? String(value).split(" ") : [];
            const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
            const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
            mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
          } else if (key === "style") {
            const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const styleMap = /* @__PURE__ */ new Map();
            existingStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            newStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
          } else {
            mergedAttributes[key] = value;
          }
        });
        return mergedAttributes;
      }, {});
    }
    function getRenderedAttributes(nodeOrMark, extensionAttributes) {
      return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
        if (!item.attribute.renderHTML) {
          return {
            [item.name]: nodeOrMark.attrs[item.name]
          };
        }
        return item.attribute.renderHTML(nodeOrMark.attrs) || {};
      }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function callOrReturn(value, context = void 0, ...props) {
      if (isFunction(value)) {
        if (context) {
          return value.bind(context)(...props);
        }
        return value(...props);
      }
      return value;
    }
    function isEmptyObject(value = {}) {
      return Object.keys(value).length === 0 && value.constructor === Object;
    }
    function fromString(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
        return Number(value);
      }
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
      return value;
    }
    function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
      if ("style" in parseRule) {
        return parseRule;
      }
      return {
        ...parseRule,
        getAttrs: (node) => {
          const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
          if (oldAttributes === false) {
            return false;
          }
          const newAttributes = extensionAttributes.reduce((items, item) => {
            const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
            if (value === null || value === void 0) {
              return items;
            }
            return {
              ...items,
              [item.name]: value
            };
          }, {});
          return { ...oldAttributes, ...newAttributes };
        }
      };
    }
    function cleanUpSchemaItem(data) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(data).filter(([key, value]) => {
          if (key === "attrs" && isEmptyObject(value)) {
            return false;
          }
          return value !== null && value !== void 0;
        })
      );
    }
    function getSchemaByResolvedExtensions(extensions, editor) {
      var _a2;
      const allAttributes = getAttributesFromExtensions(extensions);
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a2 === void 0 ? void 0 : _a2.name;
      const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor
        };
        const extraNodeFields = extensions.reduce((fields, e) => {
          const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
          return {
            ...fields,
            ...extendNodeSchema ? extendNodeSchema(extension) : {}
          };
        }, {});
        const schema = cleanUpSchemaItem({
          ...extraNodeFields,
          content: callOrReturn(getExtensionField(extension, "content", context)),
          marks: callOrReturn(getExtensionField(extension, "marks", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          inline: callOrReturn(getExtensionField(extension, "inline", context)),
          atom: callOrReturn(getExtensionField(extension, "atom", context)),
          selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
          draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
          linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
          defining: callOrReturn(getExtensionField(extension, "defining", context)),
          isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a3;
            return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
          }))
        });
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (node) => renderHTML({
            node,
            HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
          });
        }
        const renderText = getExtensionField(extension, "renderText", context);
        if (renderText) {
          schema.toText = renderText;
        }
        return [extension.name, schema];
      }));
      const marks = Object.fromEntries(markExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor
        };
        const extraMarkFields = extensions.reduce((fields, e) => {
          const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
          return {
            ...fields,
            ...extendMarkSchema ? extendMarkSchema(extension) : {}
          };
        }, {});
        const schema = cleanUpSchemaItem({
          ...extraMarkFields,
          inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
          excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a3;
            return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
          }))
        });
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (mark) => renderHTML({
            mark,
            HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
          });
        }
        return [extension.name, schema];
      }));
      return new Schema({
        topNode,
        nodes,
        marks
      });
    }
    function getSchemaTypeByName(name, schema) {
      return schema.nodes[name] || schema.marks[name] || null;
    }
    function isExtensionRulesEnabled(extension, enabled) {
      if (Array.isArray(enabled)) {
        return enabled.some((enabledExtension) => {
          const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
          return name === extension.name;
        });
      }
      return enabled;
    }
    function getHTMLFromFragment(fragment, schema) {
      const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
      const temporaryDocument = document.implementation.createHTMLDocument();
      const container = temporaryDocument.createElement("div");
      container.appendChild(documentFragment);
      return container.innerHTML;
    }
    const getTextContentFromNodes = ($from, maxMatch = 500) => {
      let textBefore = "";
      const sliceEndPos = $from.parentOffset;
      $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
        var _a2, _b2;
        const chunk = ((_b2 = (_a2 = node.type.spec).toText) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
          node,
          pos,
          parent,
          index
        })) || node.textContent || "%leaf%";
        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
      });
      return textBefore;
    };
    function isRegExp(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    }
    class InputRule {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    }
    const inputRuleMatcherHandler = (text, find2) => {
      if (isRegExp(find2)) {
        return find2.exec(text);
      }
      const inputRuleMatch = find2(text);
      if (!inputRuleMatch) {
        return null;
      }
      const result = [inputRuleMatch.text];
      result.index = inputRuleMatch.index;
      result.input = text;
      result.data = inputRuleMatch.data;
      if (inputRuleMatch.replaceWith) {
        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
        }
        result.push(inputRuleMatch.replaceWith);
      }
      return result;
    };
    function run$1(config) {
      var _a2;
      const { editor, from, to: to2, text, rules: rules2, plugin: plugin2 } = config;
      const { view } = editor;
      if (view.composing) {
        return false;
      }
      const $from = view.state.doc.resolve(from);
      if (
        // check for code node
        $from.parent.type.spec.code || !!((_a2 = $from.nodeBefore || $from.nodeAfter) === null || _a2 === void 0 ? void 0 : _a2.marks.find((mark) => mark.type.spec.code))
      ) {
        return false;
      }
      let matched = false;
      const textBefore = getTextContentFromNodes($from) + text;
      rules2.forEach((rule) => {
        if (matched) {
          return;
        }
        const match = inputRuleMatcherHandler(textBefore, rule.find);
        if (!match) {
          return;
        }
        const tr2 = view.state.tr;
        const state = createChainableState({
          state: view.state,
          transaction: tr2
        });
        const range2 = {
          from: from - (match[0].length - text.length),
          to: to2
        };
        const { commands: commands2, chain, can } = new CommandManager({
          editor,
          state
        });
        const handler = rule.handler({
          state,
          range: range2,
          match,
          commands: commands2,
          chain,
          can
        });
        if (handler === null || !tr2.steps.length) {
          return;
        }
        tr2.setMeta(plugin2, {
          transform: tr2,
          from,
          to: to2,
          text
        });
        view.dispatch(tr2);
        matched = true;
      });
      return matched;
    }
    function inputRulesPlugin(props) {
      const { editor, rules: rules2 } = props;
      const plugin2 = new Plugin({
        state: {
          init() {
            return null;
          },
          apply(tr2, prev, state) {
            const stored = tr2.getMeta(plugin2);
            if (stored) {
              return stored;
            }
            const simulatedInputMeta = tr2.getMeta("applyInputRules");
            const isSimulatedInput = !!simulatedInputMeta;
            if (isSimulatedInput) {
              setTimeout(() => {
                let { text } = simulatedInputMeta;
                if (typeof text === "string") {
                  text = text;
                } else {
                  text = getHTMLFromFragment(Fragment.from(text), state.schema);
                }
                const { from } = simulatedInputMeta;
                const to2 = from + text.length;
                run$1({
                  editor,
                  from,
                  to: to2,
                  text,
                  rules: rules2,
                  plugin: plugin2
                });
              });
            }
            return tr2.selectionSet || tr2.docChanged ? null : prev;
          }
        },
        props: {
          handleTextInput(view, from, to2, text) {
            return run$1({
              editor,
              from,
              to: to2,
              text,
              rules: rules2,
              plugin: plugin2
            });
          },
          handleDOMEvents: {
            compositionend: (view) => {
              setTimeout(() => {
                const { $cursor } = view.state.selection;
                if ($cursor) {
                  run$1({
                    editor,
                    from: $cursor.pos,
                    to: $cursor.pos,
                    text: "",
                    rules: rules2,
                    plugin: plugin2
                  });
                }
              });
              return false;
            }
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(view, event) {
            if (event.key !== "Enter") {
              return false;
            }
            const { $cursor } = view.state.selection;
            if ($cursor) {
              return run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "\n",
                rules: rules2,
                plugin: plugin2
              });
            }
            return false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return plugin2;
    }
    function getType(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    function isPlainObject(value) {
      if (getType(value) !== "Object") {
        return false;
      }
      return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
    }
    function mergeDeep(target, source) {
      const output = { ...target };
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isPlainObject(source[key]) && isPlainObject(target[key])) {
            output[key] = mergeDeep(target[key], source[key]);
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    class Mark {
      constructor(config = {}) {
        this.type = "mark";
        this.name = "mark";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new Mark(config);
      }
      configure(options = {}) {
        const extension = this.extend({
          ...this.config,
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        });
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Mark(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      static handleExit({ editor, mark }) {
        const { tr: tr2 } = editor.state;
        const currentPos = editor.state.selection.$from;
        const isAtEnd = currentPos.pos === currentPos.end();
        if (isAtEnd) {
          const currentMarks = currentPos.marks();
          const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (!isInMark) {
            return false;
          }
          const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (removeMark2) {
            tr2.removeStoredMark(removeMark2);
          }
          tr2.insertText(" ", currentPos.pos);
          editor.view.dispatch(tr2);
          return true;
        }
        return false;
      }
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    class PasteRule {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    }
    const pasteRuleMatcherHandler = (text, find2, event) => {
      if (isRegExp(find2)) {
        return [...text.matchAll(find2)];
      }
      const matches2 = find2(text, event);
      if (!matches2) {
        return [];
      }
      return matches2.map((pasteRuleMatch) => {
        const result = [pasteRuleMatch.text];
        result.index = pasteRuleMatch.index;
        result.input = text;
        result.data = pasteRuleMatch.data;
        if (pasteRuleMatch.replaceWith) {
          if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
          }
          result.push(pasteRuleMatch.replaceWith);
        }
        return result;
      });
    };
    function run(config) {
      const { editor, state, from, to: to2, rule, pasteEvent, dropEvent } = config;
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handlers2 = [];
      state.doc.nodesBetween(from, to2, (node, pos) => {
        if (!node.isTextblock || node.type.spec.code) {
          return;
        }
        const resolvedFrom = Math.max(from, pos);
        const resolvedTo = Math.min(to2, pos + node.content.size);
        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "");
        const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
        matches2.forEach((match) => {
          if (match.index === void 0) {
            return;
          }
          const start = resolvedFrom + match.index + 1;
          const end = start + match[0].length;
          const range2 = {
            from: state.tr.mapping.map(start),
            to: state.tr.mapping.map(end)
          };
          const handler = rule.handler({
            state,
            range: range2,
            match,
            commands: commands2,
            chain,
            can,
            pasteEvent,
            dropEvent
          });
          handlers2.push(handler);
        });
      });
      const success = handlers2.every((handler) => handler !== null);
      return success;
    }
    let tiptapDragFromOtherEditor = null;
    const createClipboardPasteEvent = (text) => {
      var _a2;
      const event = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.setData("text/html", text);
      return event;
    };
    function pasteRulesPlugin(props) {
      const { editor, rules: rules2 } = props;
      let dragSourceElement = null;
      let isPastedFromProseMirror = false;
      let isDroppedFromProseMirror = false;
      let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      let dropEvent;
      try {
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      } catch {
        dropEvent = null;
      }
      const processEvent = ({ state, from, to: to2, rule, pasteEvt }) => {
        const tr2 = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr2
        });
        const handler = run({
          editor,
          state: chainableState,
          from: Math.max(from - 1, 0),
          to: to2.b - 1,
          rule,
          pasteEvent: pasteEvt,
          dropEvent
        });
        if (!handler || !tr2.steps.length) {
          return;
        }
        try {
          dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
        } catch {
          dropEvent = null;
        }
        pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
        return tr2;
      };
      const plugins = rules2.map((rule) => {
        return new Plugin({
          // we register a global drag handler to track the current drag source element
          view(view) {
            const handleDragstart = (event) => {
              var _a2;
              dragSourceElement = ((_a2 = view.dom.parentElement) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
              if (dragSourceElement) {
                tiptapDragFromOtherEditor = editor;
              }
            };
            const handleDragend = () => {
              if (tiptapDragFromOtherEditor) {
                tiptapDragFromOtherEditor = null;
              }
            };
            window.addEventListener("dragstart", handleDragstart);
            window.addEventListener("dragend", handleDragend);
            return {
              destroy() {
                window.removeEventListener("dragstart", handleDragstart);
                window.removeEventListener("dragend", handleDragend);
              }
            };
          },
          props: {
            handleDOMEvents: {
              drop: (view, event) => {
                isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
                dropEvent = event;
                if (!isDroppedFromProseMirror) {
                  const dragFromOtherEditor = tiptapDragFromOtherEditor;
                  if (dragFromOtherEditor) {
                    setTimeout(() => {
                      const selection = dragFromOtherEditor.state.selection;
                      if (selection) {
                        dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                      }
                    }, 10);
                  }
                }
                return false;
              },
              paste: (_view, event) => {
                var _a2;
                const html = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/html");
                pasteEvent = event;
                isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
                return false;
              }
            }
          },
          appendTransaction: (transactions, oldState, state) => {
            const transaction = transactions[0];
            const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
            const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
            const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
            const isSimulatedPaste = !!simulatedPasteMeta;
            if (!isPaste && !isDrop && !isSimulatedPaste) {
              return;
            }
            if (isSimulatedPaste) {
              let { text } = simulatedPasteMeta;
              if (typeof text === "string") {
                text = text;
              } else {
                text = getHTMLFromFragment(Fragment.from(text), state.schema);
              }
              const { from: from2 } = simulatedPasteMeta;
              const to3 = from2 + text.length;
              const pasteEvt = createClipboardPasteEvent(text);
              return processEvent({
                rule,
                state,
                from: from2,
                to: { b: to3 },
                pasteEvt
              });
            }
            const from = oldState.doc.content.findDiffStart(state.doc.content);
            const to2 = oldState.doc.content.findDiffEnd(state.doc.content);
            if (!isNumber(from) || !to2 || from === to2.b) {
              return;
            }
            return processEvent({
              rule,
              state,
              from,
              to: to2,
              pasteEvt: pasteEvent
            });
          }
        });
      });
      return plugins;
    }
    function findDuplicates(items) {
      const filtered = items.filter((el2, index) => items.indexOf(el2) !== index);
      return Array.from(new Set(filtered));
    }
    class ExtensionManager {
      constructor(extensions, editor) {
        this.splittableMarks = [];
        this.editor = editor;
        this.extensions = ExtensionManager.resolve(extensions);
        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
        this.setupExtensions();
      }
      /**
       * Returns a flattened and sorted extension list while
       * also checking for duplicated extensions and warns the user.
       * @param extensions An array of Tiptap extensions
       * @returns An flattened and sorted array of Tiptap extensions
       */
      static resolve(extensions) {
        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
        const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
        if (duplicatedNames.length) {
          console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
        }
        return resolvedExtensions;
      }
      /**
       * Create a flattened array of extensions by traversing the `addExtensions` field.
       * @param extensions An array of Tiptap extensions
       * @returns A flattened array of Tiptap extensions
       */
      static flatten(extensions) {
        return extensions.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage
          };
          const addExtensions = getExtensionField(extension, "addExtensions", context);
          if (addExtensions) {
            return [extension, ...this.flatten(addExtensions())];
          }
          return extension;
        }).flat(10);
      }
      /**
       * Sort extensions by priority.
       * @param extensions An array of Tiptap extensions
       * @returns A sorted array of Tiptap extensions by priority
       */
      static sort(extensions) {
        const defaultPriority = 100;
        return extensions.sort((a, b) => {
          const priorityA = getExtensionField(a, "priority") || defaultPriority;
          const priorityB = getExtensionField(b, "priority") || defaultPriority;
          if (priorityA > priorityB) {
            return -1;
          }
          if (priorityA < priorityB) {
            return 1;
          }
          return 0;
        });
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((commands2, extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const addCommands = getExtensionField(extension, "addCommands", context);
          if (!addCommands) {
            return commands2;
          }
          return {
            ...commands2,
            ...addCommands()
          };
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor } = this;
        const extensions = ExtensionManager.sort([...this.extensions].reverse());
        const inputRules = [];
        const pasteRules = [];
        const allPlugins = extensions.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const plugins = [];
          const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
          let defaultBindings = {};
          if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
            defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });
          }
          if (addKeyboardShortcuts) {
            const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
              return [shortcut, () => method({ editor })];
            }));
            defaultBindings = { ...defaultBindings, ...bindings };
          }
          const keyMapPlugin = keymap(defaultBindings);
          plugins.push(keyMapPlugin);
          const addInputRules = getExtensionField(extension, "addInputRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
            inputRules.push(...addInputRules());
          }
          const addPasteRules = getExtensionField(extension, "addPasteRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
            pasteRules.push(...addPasteRules());
          }
          const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
          if (addProseMirrorPlugins) {
            const proseMirrorPlugins = addProseMirrorPlugins();
            plugins.push(...proseMirrorPlugins);
          }
          return plugins;
        }).flat();
        return [
          inputRulesPlugin({
            editor,
            rules: inputRules
          }),
          ...pasteRulesPlugin({
            editor,
            rules: pasteRules
          }),
          ...allPlugins
        ];
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return getAttributesFromExtensions(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor } = this;
        const { nodeExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
          const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor,
            type: getNodeType(extension.name, this.schema)
          };
          const addNodeView = getExtensionField(extension, "addNodeView", context);
          if (!addNodeView) {
            return [];
          }
          const nodeview = (node, view, getPos, decorations, innerDecorations) => {
            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
            return addNodeView()({
              // pass-through
              node,
              view,
              getPos,
              decorations,
              innerDecorations,
              // tiptap-specific
              editor,
              extension,
              HTMLAttributes
            });
          };
          return [extension.name, nodeview];
        }));
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        this.extensions.forEach((extension) => {
          var _a2;
          this.editor.extensionStorage[extension.name] = extension.storage;
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          if (extension.type === "mark") {
            const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a2 !== void 0 ? _a2 : true;
            if (keepOnSplit) {
              this.splittableMarks.push(extension.name);
            }
          }
          const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
          const onCreate = getExtensionField(extension, "onCreate", context);
          const onUpdate = getExtensionField(extension, "onUpdate", context);
          const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
          const onTransaction = getExtensionField(extension, "onTransaction", context);
          const onFocus = getExtensionField(extension, "onFocus", context);
          const onBlur = getExtensionField(extension, "onBlur", context);
          const onDestroy = getExtensionField(extension, "onDestroy", context);
          if (onBeforeCreate) {
            this.editor.on("beforeCreate", onBeforeCreate);
          }
          if (onCreate) {
            this.editor.on("create", onCreate);
          }
          if (onUpdate) {
            this.editor.on("update", onUpdate);
          }
          if (onSelectionUpdate) {
            this.editor.on("selectionUpdate", onSelectionUpdate);
          }
          if (onTransaction) {
            this.editor.on("transaction", onTransaction);
          }
          if (onFocus) {
            this.editor.on("focus", onFocus);
          }
          if (onBlur) {
            this.editor.on("blur", onBlur);
          }
          if (onDestroy) {
            this.editor.on("destroy", onDestroy);
          }
        });
      }
    }
    class Extension {
      constructor(config = {}) {
        this.type = "extension";
        this.name = "extension";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new Extension(config);
      }
      configure(options = {}) {
        const extension = this.extend({
          ...this.config,
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        });
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Extension({ ...this.config, ...extendedConfig });
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    }
    function getTextBetween(startNode, range2, options) {
      const { from, to: to2 } = range2;
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      let text = "";
      startNode.nodesBetween(from, to2, (node, pos, parent, index) => {
        var _a2;
        if (node.isBlock && pos > from) {
          text += blockSeparator;
        }
        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
        if (textSerializer) {
          if (parent) {
            text += textSerializer({
              node,
              pos,
              parent,
              index,
              range: range2
            });
          }
          return false;
        }
        if (node.isText) {
          text += (_a2 = node === null || node === void 0 ? void 0 : node.text) === null || _a2 === void 0 ? void 0 : _a2.slice(Math.max(from, pos) - pos, to2 - pos);
        }
      });
      return text;
    }
    function getTextSerializersFromSchema(schema) {
      return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
    }
    const ClipboardTextSerializer = Extension.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor } = this;
                const { state, schema } = editor;
                const { doc: doc2, selection } = state;
                const { ranges } = selection;
                const from = Math.min(...ranges.map((range3) => range3.$from.pos));
                const to2 = Math.max(...ranges.map((range3) => range3.$to.pos));
                const textSerializers = getTextSerializersFromSchema(schema);
                const range2 = { from, to: to2 };
                return getTextBetween(doc2, range2, {
                  ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                  textSerializers
                });
              }
            }
          })
        ];
      }
    });
    const blur = () => ({ editor, view }) => {
      requestAnimationFrame(() => {
        var _a2;
        if (!editor.isDestroyed) {
          view.dom.blur();
          (_a2 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
        }
      });
      return true;
    };
    const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
      return commands2.setContent("", emitUpdate);
    };
    const clearNodes = () => ({ state, tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const { ranges } = selection;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(({ $from, $to }) => {
        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const { doc: doc2, mapping } = tr2;
          const $mappedFrom = doc2.resolve(mapping.map(pos));
          const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
          const nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = liftTarget(nodeRange);
          if (node.type.isTextblock) {
            const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
            tr2.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr2.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
    const command = (fn) => (props) => {
      return fn(props);
    };
    const createParagraphNear = () => ({ state, dispatch }) => {
      return createParagraphNear$1(state, dispatch);
    };
    const cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
      const { state } = editor;
      const contentSlice = state.doc.slice(originRange.from, originRange.to);
      tr2.deleteRange(originRange.from, originRange.to);
      const newPos = tr2.mapping.map(targetPos);
      tr2.insert(newPos, contentSlice.content);
      tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
      return true;
    };
    const deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      const $pos = tr2.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to2 = $pos.after(depth);
            tr2.delete(from, to2).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    const deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const $pos = tr2.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            const from = $pos.before(depth);
            const to2 = $pos.after(depth);
            tr2.delete(from, to2).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    const deleteRange = (range2) => ({ tr: tr2, dispatch }) => {
      const { from, to: to2 } = range2;
      if (dispatch) {
        tr2.delete(from, to2);
      }
      return true;
    };
    const deleteSelection = () => ({ state, dispatch }) => {
      return deleteSelection$1(state, dispatch);
    };
    const enter = () => ({ commands: commands2 }) => {
      return commands2.keyboardShortcut("Enter");
    };
    const exitCode = () => ({ state, dispatch }) => {
      return exitCode$1(state, dispatch);
    };
    function objectIncludes(object1, object22, options = { strict: true }) {
      const keys2 = Object.keys(object22);
      if (!keys2.length) {
        return true;
      }
      return keys2.every((key) => {
        if (options.strict) {
          return object22[key] === object1[key];
        }
        if (isRegExp(object22[key])) {
          return object22[key].test(object1[key]);
        }
        return object22[key] === object1[key];
      });
    }
    function findMarkInSet(marks, type, attributes = {}) {
      return marks.find((item) => {
        return item.type === type && objectIncludes(
          // Only check equality for the attributes that are provided
          Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
          attributes
        );
      });
    }
    function isMarkInSet(marks, type, attributes = {}) {
      return !!findMarkInSet(marks, type, attributes);
    }
    function getMarkRange($pos, type, attributes) {
      var _a2;
      if (!$pos || !type) {
        return;
      }
      let start = $pos.parent.childAfter($pos.parentOffset);
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
        start = $pos.parent.childBefore($pos.parentOffset);
      }
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
        return;
      }
      attributes = attributes || ((_a2 = start.node.marks[0]) === null || _a2 === void 0 ? void 0 : _a2.attrs);
      const mark = findMarkInSet([...start.node.marks], type, attributes);
      if (!mark) {
        return;
      }
      let startIndex = start.index;
      let startPos = $pos.start() + start.offset;
      let endIndex = startIndex + 1;
      let endPos = startPos + start.node.nodeSize;
      while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
        startIndex -= 1;
        startPos -= $pos.parent.child(startIndex).nodeSize;
      }
      while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
        endPos += $pos.parent.child(endIndex).nodeSize;
        endIndex += 1;
      }
      return {
        from: startPos,
        to: endPos
      };
    }
    function getMarkType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.marks[nameOrType]) {
          throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.marks[nameOrType];
      }
      return nameOrType;
    }
    const extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc: doc2, selection } = tr2;
      const { $from, from, to: to2 } = selection;
      if (dispatch) {
        const range2 = getMarkRange($from, type, attributes);
        if (range2 && range2.from <= from && range2.to >= to2) {
          const newSelection = TextSelection.create(doc2, range2.from, range2.to);
          tr2.setSelection(newSelection);
        }
      }
      return true;
    };
    const first = (commands2) => (props) => {
      const items = typeof commands2 === "function" ? commands2(props) : commands2;
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        if (items[i2](props)) {
          return true;
        }
      }
      return false;
    };
    function isTextSelection(value) {
      return value instanceof TextSelection;
    }
    function minMax(value = 0, min = 0, max = 0) {
      return Math.min(Math.max(value, min), max);
    }
    function resolveFocusPosition(doc2, position = null) {
      if (!position) {
        return null;
      }
      const selectionAtStart = Selection.atStart(doc2);
      const selectionAtEnd = Selection.atEnd(doc2);
      if (position === "start" || position === true) {
        return selectionAtStart;
      }
      if (position === "end") {
        return selectionAtEnd;
      }
      const minPos = selectionAtStart.from;
      const maxPos = selectionAtEnd.to;
      if (position === "all") {
        return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
      }
      return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
    }
    function isAndroid() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function isiOS() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    const focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
      options = {
        scrollIntoView: true,
        ...options
      };
      const delayedFocus = () => {
        if (isiOS() || isAndroid()) {
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr2.setSelection(selection);
        }
        if (isSameSelection && tr2.storedMarks) {
          tr2.setStoredMarks(tr2.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
    const forEach = (items, fn) => (props) => {
      return items.every((item, index) => fn(item, { ...props, index }));
    };
    const insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
      return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
    };
    const removeWhitespaces = (node) => {
      const children = node.childNodes;
      for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
        const child = children[i2];
        if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
          node.removeChild(child);
        } else if (child.nodeType === 1) {
          removeWhitespaces(child);
        }
      }
      return node;
    };
    function elementFromString(value) {
      const wrappedValue = `<body>${value}</body>`;
      const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
      return removeWhitespaces(html);
    }
    function createNodeFromContent(content, schema, options) {
      if (content instanceof Node$1 || content instanceof Fragment) {
        return content;
      }
      options = {
        slice: true,
        parseOptions: {},
        ...options
      };
      const isJSONContent = typeof content === "object" && content !== null;
      const isTextContent = typeof content === "string";
      if (isJSONContent) {
        try {
          const isArrayContent = Array.isArray(content) && content.length > 0;
          if (isArrayContent) {
            return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
          }
          const node = schema.nodeFromJSON(content);
          if (options.errorOnInvalidContent) {
            node.check();
          }
          return node;
        } catch (error) {
          if (options.errorOnInvalidContent) {
            throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
          }
          console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
          return createNodeFromContent("", schema, options);
        }
      }
      if (isTextContent) {
        if (options.errorOnInvalidContent) {
          let hasInvalidContent = false;
          let invalidContent = "";
          const contentCheckSchema = new Schema({
            topNode: schema.spec.topNode,
            marks: schema.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: schema.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (e) => {
                      hasInvalidContent = true;
                      invalidContent = typeof e === "string" ? e : e.outerHTML;
                      return null;
                    }
                  }
                ]
              }
            })
          });
          if (options.slice) {
            DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
          } else {
            DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
          }
          if (options.errorOnInvalidContent && hasInvalidContent) {
            throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
          }
        }
        const parser = DOMParser$1.fromSchema(schema);
        if (options.slice) {
          return parser.parseSlice(elementFromString(content), options.parseOptions).content;
        }
        return parser.parse(elementFromString(content), options.parseOptions);
      }
      return createNodeFromContent("", schema, options);
    }
    function selectionToInsertionEnd(tr2, startLen, bias) {
      const last = tr2.steps.length - 1;
      if (last < startLen) {
        return;
      }
      const step = tr2.steps[last];
      if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
        return;
      }
      const map = tr2.mapping.maps[last];
      let end = 0;
      map.forEach((_from, _to, _newFrom, newTo) => {
        if (end === 0) {
          end = newTo;
        }
      });
      tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
    }
    const isFragment = (nodeOrFragment) => {
      return !("type" in nodeOrFragment);
    };
    const insertContentAt = (position, value, options) => ({ tr: tr2, dispatch, editor }) => {
      var _a2;
      if (dispatch) {
        options = {
          parseOptions: editor.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false,
          ...options
        };
        let content;
        try {
          content = createNodeFromContent(value, editor.schema, {
            parseOptions: {
              preserveWhitespace: "full",
              ...options.parseOptions
            },
            errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
          });
        } catch (e) {
          editor.emit("contentError", {
            editor,
            error: e,
            disableCollaboration: () => {
              if (editor.storage.collaboration) {
                editor.storage.collaboration.isDisabled = true;
              }
            }
          });
          return false;
        }
        let { from, to: to2 } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content) ? content : [content];
        nodes.forEach((node) => {
          node.check();
          isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (from === to2 && isOnlyBlockContent) {
          const { parent } = tr2.doc.resolve(from);
          const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            from -= 1;
            to2 += 1;
          }
        }
        let newContent;
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            newContent = value.map((v) => v.text || "").join("");
          } else if (value instanceof Fragment) {
            let text = "";
            value.forEach((node) => {
              if (node.text) {
                text += node.text;
              }
            });
            newContent = text;
          } else if (typeof value === "object" && !!value && !!value.text) {
            newContent = value.text;
          } else {
            newContent = value;
          }
          tr2.insertText(newContent, from, to2);
        } else {
          newContent = content;
          tr2.replaceWith(from, to2, newContent);
        }
        if (options.updateSelection) {
          selectionToInsertionEnd(tr2, tr2.steps.length - 1, -1);
        }
        if (options.applyInputRules) {
          tr2.setMeta("applyInputRules", { from, text: newContent });
        }
        if (options.applyPasteRules) {
          tr2.setMeta("applyPasteRules", { from, text: newContent });
        }
      }
      return true;
    };
    const joinUp = () => ({ state, dispatch }) => {
      return joinUp$1(state, dispatch);
    };
    const joinDown = () => ({ state, dispatch }) => {
      return joinDown$1(state, dispatch);
    };
    const joinBackward = () => ({ state, dispatch }) => {
      return joinBackward$1(state, dispatch);
    };
    const joinForward = () => ({ state, dispatch }) => {
      return joinForward$1(state, dispatch);
    };
    const joinItemBackward = () => ({ state, dispatch, tr: tr2 }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr2.join(point, 2);
        if (dispatch) {
          dispatch(tr2);
        }
        return true;
      } catch {
        return false;
      }
    };
    const joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr2.join(point, 2);
        if (dispatch) {
          dispatch(tr2);
        }
        return true;
      } catch {
        return false;
      }
    };
    const joinTextblockBackward = () => ({ state, dispatch }) => {
      return joinTextblockBackward$1(state, dispatch);
    };
    const joinTextblockForward = () => ({ state, dispatch }) => {
      return joinTextblockForward$1(state, dispatch);
    };
    function isMacOS() {
      return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
    }
    function normalizeKeyName(name) {
      const parts = name.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result === "Space") {
        result = " ";
      }
      let alt;
      let ctrl;
      let shift2;
      let meta;
      for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
        const mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          meta = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift2 = true;
        } else if (/^mod$/i.test(mod)) {
          if (isiOS() || isMacOS()) {
            meta = true;
          } else {
            ctrl = true;
          }
        } else {
          throw new Error(`Unrecognized modifier name: ${mod}`);
        }
      }
      if (alt) {
        result = `Alt-${result}`;
      }
      if (ctrl) {
        result = `Ctrl-${result}`;
      }
      if (meta) {
        result = `Meta-${result}`;
      }
      if (shift2) {
        result = `Shift-${result}`;
      }
      return result;
    }
    const keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
      const keys2 = normalizeKeyName(name).split(/-(?!$)/);
      const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
      const event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys2.includes("Alt"),
        ctrlKey: keys2.includes("Ctrl"),
        metaKey: keys2.includes("Meta"),
        shiftKey: keys2.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
        const newStep = step.map(tr2.mapping);
        if (newStep && dispatch) {
          tr2.maybeStep(newStep);
        }
      });
      return true;
    };
    function isNodeActive(state, typeOrName, attributes = {}) {
      const { from, to: to2, empty: empty2 } = state.selection;
      const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
      const nodeRanges = [];
      state.doc.nodesBetween(from, to2, (node, pos) => {
        if (node.isText) {
          return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to2, pos + node.nodeSize);
        nodeRanges.push({
          node,
          from: relativeFrom,
          to: relativeTo
        });
      });
      const selectionRange = to2 - from;
      const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
        if (!type) {
          return true;
        }
        return type.name === nodeRange.node.type.name;
      }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
      if (empty2) {
        return !!matchedNodeRanges.length;
      }
      const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
      return range2 >= selectionRange;
    }
    const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (!isActive2) {
        return false;
      }
      return lift$1(state, dispatch);
    };
    const liftEmptyBlock = () => ({ state, dispatch }) => {
      return liftEmptyBlock$1(state, dispatch);
    };
    const liftListItem = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return liftListItem$1(type)(state, dispatch);
    };
    const newlineInCode = () => ({ state, dispatch }) => {
      return newlineInCode$1(state, dispatch);
    };
    function getSchemaTypeNameByName(name, schema) {
      if (schema.nodes[name]) {
        return "node";
      }
      if (schema.marks[name]) {
        return "mark";
      }
      return null;
    }
    function deleteProps(obj, propOrProps) {
      const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
      return Object.keys(obj).reduce((newObj, prop) => {
        if (!props.includes(prop)) {
          newObj[prop] = obj[prop];
        }
        return newObj;
      }, {});
    }
    const resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr2.selection.ranges.forEach((range2) => {
          state.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
    const scrollIntoView = () => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        tr2.scrollIntoView();
      }
      return true;
    };
    const selectAll = () => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        const selection = new AllSelection(tr2.doc);
        tr2.setSelection(selection);
      }
      return true;
    };
    const selectNodeBackward = () => ({ state, dispatch }) => {
      return selectNodeBackward$1(state, dispatch);
    };
    const selectNodeForward = () => ({ state, dispatch }) => {
      return selectNodeForward$1(state, dispatch);
    };
    const selectParentNode = () => ({ state, dispatch }) => {
      return selectParentNode$1(state, dispatch);
    };
    const selectTextblockEnd = () => ({ state, dispatch }) => {
      return selectTextblockEnd$1(state, dispatch);
    };
    const selectTextblockStart = () => ({ state, dispatch }) => {
      return selectTextblockStart$1(state, dispatch);
    };
    function createDocument(content, schema, parseOptions = {}, options = {}) {
      return createNodeFromContent(content, schema, {
        slice: false,
        parseOptions,
        errorOnInvalidContent: options.errorOnInvalidContent
      });
    }
    const setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr: tr2, dispatch, commands: commands2 }) => {
      var _a2, _b2;
      const { doc: doc2 } = tr2;
      if (parseOptions.preserveWhitespace !== "full") {
        const document2 = createDocument(content, editor.schema, parseOptions, {
          errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
        });
        if (dispatch) {
          tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
        }
        return true;
      }
      if (dispatch) {
        tr2.setMeta("preventUpdate", !emitUpdate);
      }
      return commands2.insertContentAt({ from: 0, to: doc2.content.size }, content, {
        parseOptions,
        errorOnInvalidContent: (_b2 = options.errorOnInvalidContent) !== null && _b2 !== void 0 ? _b2 : editor.options.enableContentCheck
      });
    };
    function getMarkAttributes(state, typeOrName) {
      const type = getMarkType(typeOrName, state.schema);
      const { from, to: to2, empty: empty2 } = state.selection;
      const marks = [];
      if (empty2) {
        if (state.storedMarks) {
          marks.push(...state.storedMarks);
        }
        marks.push(...state.selection.$head.marks());
      } else {
        state.doc.nodesBetween(from, to2, (node) => {
          marks.push(...node.marks);
        });
      }
      const mark = marks.find((markItem) => markItem.type.name === type.name);
      if (!mark) {
        return {};
      }
      return { ...mark.attrs };
    }
    function combineTransactionSteps(oldDoc, transactions) {
      const transform = new Transform(oldDoc);
      transactions.forEach((transaction) => {
        transaction.steps.forEach((step) => {
          transform.step(step);
        });
      });
      return transform;
    }
    function defaultBlockAt(match) {
      for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
        const { type } = match.edge(i2);
        if (type.isTextblock && !type.hasRequiredAttrs()) {
          return type;
        }
      }
      return null;
    }
    function findChildren(node, predicate) {
      const nodesWithPos = [];
      node.descendants((child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function findChildrenInRange(node, range2, predicate) {
      const nodesWithPos = [];
      node.nodesBetween(range2.from, range2.to, (child, pos) => {
        if (predicate(child)) {
          nodesWithPos.push({
            node: child,
            pos
          });
        }
      });
      return nodesWithPos;
    }
    function findParentNodeClosestToPos($pos, predicate) {
      for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
        const node = $pos.node(i2);
        if (predicate(node)) {
          return {
            pos: i2 > 0 ? $pos.before(i2) : 0,
            start: $pos.start(i2),
            depth: i2,
            node
          };
        }
      }
    }
    function findParentNode(predicate) {
      return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
    }
    function getText(node, options) {
      const range2 = {
        from: 0,
        to: node.content.size
      };
      return getTextBetween(node, range2, options);
    }
    function getNodeAttributes(state, typeOrName) {
      const type = getNodeType(typeOrName, state.schema);
      const { from, to: to2 } = state.selection;
      const nodes = [];
      state.doc.nodesBetween(from, to2, (node2) => {
        nodes.push(node2);
      });
      const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
      if (!node) {
        return {};
      }
      return { ...node.attrs };
    }
    function getAttributes(state, typeOrName) {
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (schemaType === "node") {
        return getNodeAttributes(state, typeOrName);
      }
      if (schemaType === "mark") {
        return getMarkAttributes(state, typeOrName);
      }
      return {};
    }
    function removeDuplicates(array, by2 = JSON.stringify) {
      const seen = {};
      return array.filter((item) => {
        const key = by2(item);
        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
      });
    }
    function simplifyChangedRanges(changes) {
      const uniqueChanges = removeDuplicates(changes);
      return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
        const rest = uniqueChanges.filter((_, i2) => i2 !== index);
        return !rest.some((otherChange) => {
          return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
        });
      });
    }
    function getChangedRanges(transform) {
      const { mapping, steps } = transform;
      const changes = [];
      mapping.maps.forEach((stepMap, index) => {
        const ranges = [];
        if (!stepMap.ranges.length) {
          const { from, to: to2 } = steps[index];
          if (from === void 0 || to2 === void 0) {
            return;
          }
          ranges.push({ from, to: to2 });
        } else {
          stepMap.forEach((from, to2) => {
            ranges.push({ from, to: to2 });
          });
        }
        ranges.forEach(({ from, to: to2 }) => {
          const newStart = mapping.slice(index).map(from, -1);
          const newEnd = mapping.slice(index).map(to2);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          changes.push({
            oldRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            }
          });
        });
      });
      return simplifyChangedRanges(changes);
    }
    function getMarksBetween(from, to2, doc2) {
      const marks = [];
      if (from === to2) {
        doc2.resolve(from).marks().forEach((mark) => {
          const $pos = doc2.resolve(from);
          const range2 = getMarkRange($pos, mark.type);
          if (!range2) {
            return;
          }
          marks.push({
            mark,
            ...range2
          });
        });
      } else {
        doc2.nodesBetween(from, to2, (node, pos) => {
          if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
            return;
          }
          marks.push(...node.marks.map((mark) => ({
            from: pos,
            to: pos + node.nodeSize,
            mark
          })));
        });
      }
      return marks;
    }
    function getSplittedAttributes(extensionAttributes, typeName, attributes) {
      return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
        const extensionAttribute = extensionAttributes.find((item) => {
          return item.type === typeName && item.name === name;
        });
        if (!extensionAttribute) {
          return false;
        }
        return extensionAttribute.attribute.keepOnSplit;
      }));
    }
    function isMarkActive(state, typeOrName, attributes = {}) {
      const { empty: empty2, ranges } = state.selection;
      const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
      if (empty2) {
        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
          if (!type) {
            return true;
          }
          return type.name === mark.type.name;
        }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
      }
      let selectionRange = 0;
      const markRanges = [];
      ranges.forEach(({ $from, $to }) => {
        const from = $from.pos;
        const to2 = $to.pos;
        state.doc.nodesBetween(from, to2, (node, pos) => {
          if (!node.isText && !node.marks.length) {
            return;
          }
          const relativeFrom = Math.max(from, pos);
          const relativeTo = Math.min(to2, pos + node.nodeSize);
          const range3 = relativeTo - relativeFrom;
          selectionRange += range3;
          markRanges.push(...node.marks.map((mark) => ({
            mark,
            from: relativeFrom,
            to: relativeTo
          })));
        });
      });
      if (selectionRange === 0) {
        return false;
      }
      const matchedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return type.name === markRange.mark.type.name;
      }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const excludedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return markRange.mark.type !== type && markRange.mark.type.excludes(type);
      }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
      return range2 >= selectionRange;
    }
    function isActive(state, name, attributes = {}) {
      if (!name) {
        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
      }
      const schemaType = getSchemaTypeNameByName(name, state.schema);
      if (schemaType === "node") {
        return isNodeActive(state, name, attributes);
      }
      if (schemaType === "mark") {
        return isMarkActive(state, name, attributes);
      }
      return false;
    }
    function isList(name, extensions) {
      const { nodeExtensions } = splitExtensions(extensions);
      const extension = nodeExtensions.find((item) => item.name === name);
      if (!extension) {
        return false;
      }
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const group = callOrReturn(getExtensionField(extension, "group", context));
      if (typeof group !== "string") {
        return false;
      }
      return group.split(" ").includes("list");
    }
    function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
      var _a2;
      if (ignoreWhitespace) {
        if (node.type.name === "hardBreak") {
          return true;
        }
        if (node.isText) {
          return /^\s*$/m.test((_a2 = node.text) !== null && _a2 !== void 0 ? _a2 : "");
        }
      }
      if (node.isText) {
        return !node.text;
      }
      if (node.isAtom || node.isLeaf) {
        return false;
      }
      if (node.content.childCount === 0) {
        return true;
      }
      if (checkChildren) {
        let isContentEmpty = true;
        node.content.forEach((childNode) => {
          if (isContentEmpty === false) {
            return;
          }
          if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
            isContentEmpty = false;
          }
        });
        return isContentEmpty;
      }
      return false;
    }
    function isNodeSelection(value) {
      return value instanceof NodeSelection;
    }
    function posToDOMRect(view, from, to2) {
      const minPos = 0;
      const maxPos = view.state.doc.content.size;
      const resolvedFrom = minMax(from, minPos, maxPos);
      const resolvedEnd = minMax(to2, minPos, maxPos);
      const start = view.coordsAtPos(resolvedFrom);
      const end = view.coordsAtPos(resolvedEnd, -1);
      const top = Math.min(start.top, end.top);
      const bottom = Math.max(start.bottom, end.bottom);
      const left = Math.min(start.left, end.left);
      const right = Math.max(start.right, end.right);
      const width = right - left;
      const height = bottom - top;
      const x = left;
      const y = top;
      const data = {
        top,
        bottom,
        left,
        right,
        width,
        height,
        x,
        y
      };
      return {
        ...data,
        toJSON: () => data
      };
    }
    function canSetMark(state, tr2, newMarkType) {
      var _a2;
      const { selection } = tr2;
      let cursor = null;
      if (isTextSelection(selection)) {
        cursor = selection.$cursor;
      }
      if (cursor) {
        const currentMarks = (_a2 = state.storedMarks) !== null && _a2 !== void 0 ? _a2 : cursor.marks();
        return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
      }
      const { ranges } = selection;
      return ranges.some(({ $from, $to }) => {
        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
          if (someNodeSupportsMark) {
            return false;
          }
          if (node.isInline) {
            const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
            const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
            someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
          }
          return !someNodeSupportsMark;
        });
        return someNodeSupportsMark;
      });
    }
    const setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      const { selection } = tr2;
      const { empty: empty2, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty2) {
          const oldAttributes = getMarkAttributes(state, type);
          tr2.addStoredMark(type.create({
            ...oldAttributes,
            ...attributes
          }));
        } else {
          ranges.forEach((range2) => {
            const from = range2.$from.pos;
            const to2 = range2.$to.pos;
            state.doc.nodesBetween(from, to2, (node, pos) => {
              const trimmedFrom = Math.max(pos, from);
              const trimmedTo = Math.min(pos + node.nodeSize, to2);
              const someHasMark = node.marks.find((mark) => mark.type === type);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type === mark.type) {
                    tr2.addMark(trimmedFrom, trimmedTo, type.create({
                      ...mark.attrs,
                      ...attributes
                    }));
                  }
                });
              } else {
                tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state, tr2, type);
    };
    const setMeta = (key, value) => ({ tr: tr2 }) => {
      tr2.setMeta(key, value);
      return true;
    };
    const setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
      const type = getNodeType(typeOrName, state.schema);
      let attributesToCopy;
      if (state.selection.$anchor.sameParent(state.selection.$head)) {
        attributesToCopy = state.selection.$anchor.parent.attrs;
      }
      if (!type.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
      }
      return chain().command(({ commands: commands2 }) => {
        const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
        if (canSetBlock) {
          return true;
        }
        return commands2.clearNodes();
      }).command(({ state: updatedState }) => {
        return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
      }).run();
    };
    const setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        const { doc: doc2 } = tr2;
        const from = minMax(position, 0, doc2.content.size);
        const selection = NodeSelection.create(doc2, from);
        tr2.setSelection(selection);
      }
      return true;
    };
    const setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
      if (dispatch) {
        const { doc: doc2 } = tr2;
        const { from, to: to2 } = typeof position === "number" ? { from: position, to: position } : position;
        const minPos = TextSelection.atStart(doc2).from;
        const maxPos = TextSelection.atEnd(doc2).to;
        const resolvedFrom = minMax(from, minPos, maxPos);
        const resolvedEnd = minMax(to2, minPos, maxPos);
        const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
        tr2.setSelection(selection);
      }
      return true;
    };
    const sinkListItem = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return sinkListItem$1(type)(state, dispatch);
    };
    function ensureMarks(state, splittableMarks) {
      const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
      if (marks) {
        const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
        state.tr.ensureMarks(filteredMarks);
      }
    }
    const splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
      const { selection, doc: doc2 } = tr2;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr2.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      const atEnd = $to.parentOffset === $to.parent.content.size;
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types2 = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types2);
      if (!types2 && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types2 = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (dispatch) {
        if (can) {
          if (selection instanceof TextSelection) {
            tr2.deleteSelection();
          }
          tr2.split(tr2.mapping.map($from.pos), 1, types2);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            const first2 = tr2.mapping.map($from.before());
            const $first = tr2.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr2.scrollIntoView();
      }
      return can;
    };
    const splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch, editor }) => {
      var _a2;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      const node = state.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          let wrap2 = Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap2 = Fragment.from($from.node(d).copy(wrap2));
          }
          const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          const newNextTypeAttributes2 = {
            ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
            ...overrideAttrs
          };
          const nextType2 = ((_a2 = type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
          const start = $from.before($from.depth - (depthBefore - 1));
          tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
          let sel = -1;
          tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
          }
          tr2.scrollIntoView();
        }
        return true;
      }
      const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      const newTypeAttributes = {
        ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
        ...overrideAttrs
      };
      const newNextTypeAttributes = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      tr2.delete($from.pos, $to.pos);
      const types2 = nextType ? [
        { type, attrs: newTypeAttributes },
        { type: nextType, attrs: newNextTypeAttributes }
      ] : [{ type, attrs: newTypeAttributes }];
      if (!canSplit(tr2.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        tr2.split($from.pos, 2, types2).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr2.ensureMarks(filteredMarks);
      }
      return true;
    };
    const joinListBackwards = (tr2, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr2.selection);
      if (!list) {
        return true;
      }
      const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
      if (before === void 0) {
        return true;
      }
      const nodeBefore = tr2.doc.nodeAt(before);
      const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
      if (!canJoinBackwards) {
        return true;
      }
      tr2.join(list.pos);
      return true;
    };
    const joinListForwards = (tr2, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr2.selection);
      if (!list) {
        return true;
      }
      const after = tr2.doc.resolve(list.start).after(list.depth);
      if (after === void 0) {
        return true;
      }
      const nodeAfter = tr2.doc.nodeAt(after);
      const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
      if (!canJoinForwards) {
        return true;
      }
      tr2.join(after);
      return true;
    };
    const toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
      const { extensions, splittableMarks } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection, storedMarks } = state;
      const { $from, $to } = selection;
      const range2 = $from.blockRange($to);
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (!range2) {
        return false;
      }
      const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
      if (range2.depth >= 1 && parentList && range2.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
          return chain().command(() => {
            tr2.setNodeMarkup(parentList.pos, listType);
            return true;
          }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain().command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
      }
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr2.ensureMarks(filteredMarks);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    };
    const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
      const { extendEmptyMarkRange = false } = options;
      const type = getMarkType(typeOrName, state.schema);
      const isActive2 = isMarkActive(state, type, attributes);
      if (isActive2) {
        return commands2.unsetMark(type, { extendEmptyMarkRange });
      }
      return commands2.setMark(type, attributes);
    };
    const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      let attributesToCopy;
      if (state.selection.$anchor.sameParent(state.selection.$head)) {
        attributesToCopy = state.selection.$anchor.parent.attrs;
      }
      if (isActive2) {
        return commands2.setNode(toggleType, attributesToCopy);
      }
      return commands2.setNode(type, { ...attributesToCopy, ...attributes });
    };
    const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return commands2.lift(type);
      }
      return commands2.wrapIn(type, attributes);
    };
    const undoInputRule = () => ({ state, dispatch }) => {
      const plugins = state.plugins;
      for (let i2 = 0; i2 < plugins.length; i2 += 1) {
        const plugin2 = plugins[i2];
        let undoable;
        if (plugin2.spec.isInputRules && (undoable = plugin2.getState(state))) {
          if (dispatch) {
            const tr2 = state.tr;
            const toUndo = undoable.transform;
            for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              const marks = tr2.doc.resolve(undoable.from).marks();
              tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr2.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
    const unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
      const { selection } = tr2;
      const { empty: empty2, ranges } = selection;
      if (empty2) {
        return true;
      }
      if (dispatch) {
        ranges.forEach((range2) => {
          tr2.removeMark(range2.$from.pos, range2.$to.pos);
        });
      }
      return true;
    };
    const unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
      var _a2;
      const { extendEmptyMarkRange = false } = options;
      const { selection } = tr2;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty: empty2, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty2 && extendEmptyMarkRange) {
        let { from, to: to2 } = selection;
        const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) === null || _a2 === void 0 ? void 0 : _a2.attrs;
        const range2 = getMarkRange($from, type, attrs);
        if (range2) {
          from = range2.from;
          to2 = range2.to;
        }
        tr2.removeMark(from, to2, type);
      } else {
        ranges.forEach((range2) => {
          tr2.removeMark(range2.$from.pos, range2.$to.pos, type);
        });
      }
      tr2.removeStoredMark(type);
      return true;
    };
    const updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr2.selection.ranges.forEach((range2) => {
          const from = range2.$from.pos;
          const to2 = range2.$to.pos;
          let lastPos;
          let lastNode;
          let trimmedFrom;
          let trimmedTo;
          if (tr2.selection.empty) {
            state.doc.nodesBetween(from, to2, (node, pos) => {
              if (nodeType && nodeType === node.type) {
                trimmedFrom = Math.max(pos, from);
                trimmedTo = Math.min(pos + node.nodeSize, to2);
                lastPos = pos;
                lastNode = node;
              }
            });
          } else {
            state.doc.nodesBetween(from, to2, (node, pos) => {
              if (pos < from && nodeType && nodeType === node.type) {
                trimmedFrom = Math.max(pos, from);
                trimmedTo = Math.min(pos + node.nodeSize, to2);
                lastPos = pos;
                lastNode = node;
              }
              if (pos >= from && pos <= to2) {
                if (nodeType && nodeType === node.type) {
                  tr2.setNodeMarkup(pos, void 0, {
                    ...node.attrs,
                    ...attributes
                  });
                }
                if (markType && node.marks.length) {
                  node.marks.forEach((mark) => {
                    if (markType === mark.type) {
                      const trimmedFrom2 = Math.max(pos, from);
                      const trimmedTo2 = Math.min(pos + node.nodeSize, to2);
                      tr2.addMark(trimmedFrom2, trimmedTo2, markType.create({
                        ...mark.attrs,
                        ...attributes
                      }));
                    }
                  });
                }
              }
            });
          }
          if (lastNode) {
            if (lastPos !== void 0) {
              tr2.setNodeMarkup(lastPos, void 0, {
                ...lastNode.attrs,
                ...attributes
              });
            }
            if (markType && lastNode.marks.length) {
              lastNode.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      return true;
    };
    const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapIn$1(type, attributes)(state, dispatch);
    };
    const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapInList$1(type, attributes)(state, dispatch);
    };
    var commands = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur,
      clearContent,
      clearNodes,
      command,
      createParagraphNear,
      cut,
      deleteCurrentNode,
      deleteNode,
      deleteRange,
      deleteSelection,
      enter,
      exitCode,
      extendMarkRange,
      first,
      focus,
      forEach,
      insertContent,
      insertContentAt,
      joinBackward,
      joinDown,
      joinForward,
      joinItemBackward,
      joinItemForward,
      joinTextblockBackward,
      joinTextblockForward,
      joinUp,
      keyboardShortcut,
      lift,
      liftEmptyBlock,
      liftListItem,
      newlineInCode,
      resetAttributes,
      scrollIntoView,
      selectAll,
      selectNodeBackward,
      selectNodeForward,
      selectParentNode,
      selectTextblockEnd,
      selectTextblockStart,
      setContent,
      setMark,
      setMeta,
      setNode,
      setNodeSelection,
      setTextSelection,
      sinkListItem,
      splitBlock,
      splitListItem,
      toggleList,
      toggleMark,
      toggleNode,
      toggleWrap,
      undoInputRule,
      unsetAllMarks,
      unsetMark,
      updateAttributes,
      wrapIn,
      wrapInList
    });
    const Commands = Extension.create({
      name: "commands",
      addCommands() {
        return {
          ...commands
        };
      }
    });
    const Drop = Extension.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tiptapDrop"),
            props: {
              handleDrop: (_, e, slice, moved) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice,
                  moved
                });
              }
            }
          })
        ];
      }
    });
    const Editable = Extension.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    });
    const FocusEvents = Extension.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor } = this;
        return [
          new Plugin({
            key: new PluginKey("focusEvents"),
            props: {
              handleDOMEvents: {
                focus: (view, event) => {
                  editor.isFocused = true;
                  const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                },
                blur: (view, event) => {
                  editor.isFocused = false;
                  const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    const Keymap = Extension.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.undoInputRule(),
          // maybe convert first text block node to default node
          () => commands2.command(({ tr: tr2 }) => {
            const { selection, doc: doc2 } = tr2;
            const { empty: empty2, $anchor } = selection;
            const { pos, parent } = $anchor;
            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
            const parentIsIsolating = $parentPos.parent.type.spec.isolating;
            const parentPos = $anchor.pos - $anchor.parentOffset;
            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
            if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
              return false;
            }
            return commands2.clearNodes();
          }),
          () => commands2.deleteSelection(),
          () => commands2.joinBackward(),
          () => commands2.selectNodeBackward()
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.deleteSelection(),
          () => commands2.deleteCurrentNode(),
          () => commands2.joinForward(),
          () => commands2.selectNodeForward()
        ]);
        const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.newlineInCode(),
          () => commands2.createParagraphNear(),
          () => commands2.liftEmptyBlock(),
          () => commands2.splitBlock()
        ]);
        const baseKeymap = {
          Enter: handleEnter,
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: handleBackspace,
          "Mod-Backspace": handleBackspace,
          "Shift-Backspace": handleBackspace,
          Delete: handleDelete,
          "Mod-Delete": handleDelete,
          "Mod-a": () => this.editor.commands.selectAll()
        };
        const pcKeymap = {
          ...baseKeymap
        };
        const macKeymap = {
          ...baseKeymap,
          "Ctrl-h": handleBackspace,
          "Alt-Backspace": handleBackspace,
          "Ctrl-d": handleDelete,
          "Ctrl-Alt-Backspace": handleDelete,
          "Alt-Delete": handleDelete,
          "Alt-d": handleDelete,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        if (isiOS() || isMacOS()) {
          return macKeymap;
        }
        return pcKeymap;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
          // with many other commands.
          new Plugin({
            key: new PluginKey("clearDocument"),
            appendTransaction: (transactions, oldState, newState) => {
              if (transactions.some((tr3) => tr3.getMeta("composition"))) {
                return;
              }
              const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
              const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
              if (!docChanges || ignoreTr) {
                return;
              }
              const { empty: empty2, from, to: to2 } = oldState.selection;
              const allFrom = Selection.atStart(oldState.doc).from;
              const allEnd = Selection.atEnd(oldState.doc).to;
              const allWasSelected = from === allFrom && to2 === allEnd;
              if (empty2 || !allWasSelected) {
                return;
              }
              const isEmpty = isNodeEmpty(newState.doc);
              if (!isEmpty) {
                return;
              }
              const tr2 = newState.tr;
              const state = createChainableState({
                state: newState,
                transaction: tr2
              });
              const { commands: commands2 } = new CommandManager({
                editor: this.editor,
                state
              });
              commands2.clearNodes();
              if (!tr2.steps.length) {
                return;
              }
              return tr2;
            }
          })
        ];
      }
    });
    const Paste = Extension.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tiptapPaste"),
            props: {
              handlePaste: (_view, e, slice) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice
                });
              }
            }
          })
        ];
      }
    });
    const Tabindex = Extension.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    class NodePos {
      get name() {
        return this.node.type.name;
      }
      constructor(pos, editor, isBlock = false, node = null) {
        this.currentNode = null;
        this.actualDepth = null;
        this.isBlock = isBlock;
        this.resolvedPos = pos;
        this.editor = editor;
        this.currentNode = node;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var _a2;
        return (_a2 = this.actualDepth) !== null && _a2 !== void 0 ? _a2 : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(content) {
        let from = this.from;
        let to2 = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          from = this.from + 1;
          to2 = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from, to: to2 }, content);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        if (this.isBlock) {
          return this.pos;
        }
        return this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        if (this.isBlock) {
          return this.pos + this.size;
        }
        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0) {
          return null;
        }
        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
        const $pos = this.resolvedPos.doc.resolve(parentPos);
        return new NodePos($pos, this.editor);
      }
      get before() {
        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.from - 3);
        }
        return new NodePos($pos, this.editor);
      }
      get after() {
        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.to + 3);
        }
        return new NodePos($pos, this.editor);
      }
      get children() {
        const children = [];
        this.node.content.forEach((node, offset) => {
          const isBlock = node.isBlock && !node.isTextblock;
          const isNonTextAtom = node.isAtom && !node.isText;
          const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
          const $pos = this.resolvedPos.doc.resolve(targetPos);
          if (!isBlock && $pos.depth <= this.depth) {
            return;
          }
          const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);
          if (isBlock) {
            childNodePos.actualDepth = this.depth + 1;
          }
          children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));
        });
        return children;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const children = this.children;
        return children[children.length - 1] || null;
      }
      closest(selector, attributes = {}) {
        let node = null;
        let currentNode = this.parent;
        while (currentNode && !node) {
          if (currentNode.node.type.name === selector) {
            if (Object.keys(attributes).length > 0) {
              const nodeAttributes = currentNode.node.attrs;
              const attrKeys = Object.keys(attributes);
              for (let index = 0; index < attrKeys.length; index += 1) {
                const key = attrKeys[index];
                if (nodeAttributes[key] !== attributes[key]) {
                  break;
                }
              }
            } else {
              node = currentNode;
            }
          }
          currentNode = currentNode.parent;
        }
        return node;
      }
      querySelector(selector, attributes = {}) {
        return this.querySelectorAll(selector, attributes, true)[0] || null;
      }
      querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
        let nodes = [];
        if (!this.children || this.children.length === 0) {
          return nodes;
        }
        const attrKeys = Object.keys(attributes);
        this.children.forEach((childPos) => {
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          if (childPos.node.type.name === selector) {
            const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
            if (doesAllAttributesMatch) {
              nodes.push(childPos);
            }
          }
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
        });
        return nodes;
      }
      setAttribute(attributes) {
        const { tr: tr2 } = this.editor.state;
        tr2.setNodeMarkup(this.from, void 0, {
          ...this.node.attrs,
          ...attributes
        });
        this.editor.view.dispatch(tr2);
      }
    }
    const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    function createStyleTag(style2, nonce, suffix2) {
      const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${""}]`);
      if (tiptapStyleTag !== null) {
        return tiptapStyleTag;
      }
      const styleNode = document.createElement("style");
      if (nonce) {
        styleNode.setAttribute("nonce", nonce);
      }
      styleNode.setAttribute(`data-tiptap-style${""}`, "");
      styleNode.innerHTML = style2;
      document.getElementsByTagName("head")[0].appendChild(styleNode);
      return styleNode;
    }
    class Editor extends EventEmitter {
      constructor(options = {}) {
        super();
        this.isFocused = false;
        this.isInitialized = false;
        this.extensionStorage = {};
        this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error }) => {
            throw error;
          },
          onPaste: () => null,
          onDrop: () => null
        };
        this.isCapturingTransaction = false;
        this.capturedTransaction = null;
        this.setOptions(options);
        this.createExtensionManager();
        this.createCommandManager();
        this.createSchema();
        this.on("beforeCreate", this.options.onBeforeCreate);
        this.emit("beforeCreate", { editor: this });
        this.on("contentError", this.options.onContentError);
        this.createView();
        this.injectCSS();
        this.on("create", this.options.onCreate);
        this.on("update", this.options.onUpdate);
        this.on("selectionUpdate", this.options.onSelectionUpdate);
        this.on("transaction", this.options.onTransaction);
        this.on("focus", this.options.onFocus);
        this.on("blur", this.options.onBlur);
        this.on("destroy", this.options.onDestroy);
        this.on("drop", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));
        this.on("paste", ({ event, slice }) => this.options.onPaste(event, slice));
        window.setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.commands.focus(this.options.autofocus);
          this.emit("create", { editor: this });
          this.isInitialized = true;
        }, 0);
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        if (this.options.injectCSS && document) {
          this.css = createStyleTag(style, this.options.injectNonce);
        }
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(options = {}) {
        this.options = {
          ...this.options,
          ...options
        };
        if (!this.view || !this.state || this.isDestroyed) {
          return;
        }
        if (this.options.editorProps) {
          this.view.setProps(this.options.editorProps);
        }
        this.view.updateState(this.state);
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(editable, emitUpdate = true) {
        this.setOptions({ editable });
        if (emitUpdate) {
          this.emit("update", { editor: this, transaction: this.state.tr });
        }
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
        return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(plugin2, handlePlugins) {
        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin2, [...this.state.plugins]) : [...this.state.plugins, plugin2];
        const state = this.state.reconfigure({ plugins });
        this.view.updateState(state);
        return state;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(nameOrPluginKeyToRemove) {
        if (this.isDestroyed) {
          return void 0;
        }
        const prevPlugins = this.state.plugins;
        let plugins = prevPlugins;
        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
          const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
          plugins = prevPlugins.filter((plugin2) => !plugin2.key.startsWith(name));
        });
        if (prevPlugins.length === plugins.length) {
          return void 0;
        }
        const state = this.state.reconfigure({
          plugins
        });
        this.view.updateState(state);
        return state;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var _a2, _b2;
        const coreExtensions = this.options.enableCoreExtensions ? [
          Editable,
          ClipboardTextSerializer.configure({
            blockSeparator: (_b2 = (_a2 = this.options.coreExtensionOptions) === null || _a2 === void 0 ? void 0 : _a2.clipboardTextSerializer) === null || _b2 === void 0 ? void 0 : _b2.blockSeparator
          }),
          Commands,
          FocusEvents,
          Keymap,
          Tabindex,
          Drop,
          Paste
        ].filter((ext) => {
          if (typeof this.options.enableCoreExtensions === "object") {
            return this.options.enableCoreExtensions[ext.name] !== false;
          }
          return true;
        }) : [];
        const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
          return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
        });
        this.extensionManager = new ExtensionManager(allExtensions, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new CommandManager({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
        var _a2;
        let doc2;
        try {
          doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
        } catch (e) {
          if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
            throw e;
          }
          this.emit("contentError", {
            editor: this,
            error: e,
            disableCollaboration: () => {
              if (this.storage.collaboration) {
                this.storage.collaboration.isDisabled = true;
              }
              this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
              this.createExtensionManager();
            }
          });
          doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
        }
        const selection = resolveFocusPosition(doc2, this.options.autofocus);
        this.view = new EditorView(this.options.element, {
          ...this.options.editorProps,
          attributes: {
            // add `role="textbox"` to the editor element
            role: "textbox",
            ...(_a2 = this.options.editorProps) === null || _a2 === void 0 ? void 0 : _a2.attributes
          },
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: EditorState.create({
            doc: doc2,
            selection: selection || void 0
          })
        });
        const newState = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(newState);
        this.createNodeViews();
        this.prependClass();
        const dom = this.view.dom;
        dom.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
        if (this.view.isDestroyed) {
          return;
        }
        this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
      }
      captureTransaction(fn) {
        this.isCapturingTransaction = true;
        fn();
        this.isCapturingTransaction = false;
        const tr2 = this.capturedTransaction;
        this.capturedTransaction = null;
        return tr2;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(transaction) {
        if (this.view.isDestroyed) {
          return;
        }
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = transaction;
            return;
          }
          transaction.steps.forEach((step) => {
            var _a2;
            return (_a2 = this.capturedTransaction) === null || _a2 === void 0 ? void 0 : _a2.step(step);
          });
          return;
        }
        const state = this.state.apply(transaction);
        const selectionHasChanged = !this.state.selection.eq(state.selection);
        this.emit("beforeTransaction", {
          editor: this,
          transaction,
          nextState: state
        });
        this.view.updateState(state);
        this.emit("transaction", {
          editor: this,
          transaction
        });
        if (selectionHasChanged) {
          this.emit("selectionUpdate", {
            editor: this,
            transaction
          });
        }
        const focus2 = transaction.getMeta("focus");
        const blur2 = transaction.getMeta("blur");
        if (focus2) {
          this.emit("focus", {
            editor: this,
            event: focus2.event,
            transaction
          });
        }
        if (blur2) {
          this.emit("blur", {
            editor: this,
            event: blur2.event,
            transaction
          });
        }
        if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
          return;
        }
        this.emit("update", {
          editor: this,
          transaction
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(nameOrType) {
        return getAttributes(this.state, nameOrType);
      }
      isActive(nameOrAttributes, attributesOrUndefined) {
        const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
        const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
        return isActive(this.state, name, attributes);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return getHTMLFromFragment(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(options) {
        const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
        return getText(this.state.doc, {
          blockSeparator,
          textSerializers: {
            ...getTextSerializersFromSchema(this.schema),
            ...textSerializers
          }
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return isNodeEmpty(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       *
       * @deprecated
       */
      getCharacterCount() {
        console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
        return this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        this.emit("destroy");
        if (this.view) {
          const dom = this.view.dom;
          if (dom && dom.editor) {
            delete dom.editor;
          }
          this.view.destroy();
        }
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var _a2;
        return !((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.docView);
      }
      $node(selector, attributes) {
        var _a2;
        return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector, attributes)) || null;
      }
      $nodes(selector, attributes) {
        var _a2;
        return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
      }
      $pos(pos) {
        const $pos = this.state.doc.resolve(pos);
        return new NodePos($pos, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    }
    function markInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range: range2, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr: tr2 } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range2.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type) => type === config.type && type !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range2.to) {
              tr2.delete(textEnd, range2.to);
            }
            if (textStart > range2.from) {
              tr2.delete(range2.from + startSpaces, textStart);
            }
            const markEnd = range2.from + startSpaces + captureGroup.length;
            tr2.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr2.removeStoredMark(config.type);
          }
        }
      });
    }
    function nodeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range: range2, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const { tr: tr2 } = state;
          const start = range2.from;
          let end = range2.to;
          const newNode = config.type.create(attributes);
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            let matchStart = start + offset;
            if (matchStart > end) {
              matchStart = end;
            } else {
              end = matchStart + match[1].length;
            }
            const lastChar = match[0][match[0].length - 1];
            tr2.insertText(lastChar, start + match[0].length - 1);
            tr2.replaceWith(matchStart, end, newNode);
          } else if (match[0]) {
            const insertionStart = config.type.isInline ? start : start - 1;
            tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
          }
          tr2.scrollIntoView();
        }
      });
    }
    function textblockTypeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range: range2, match }) => {
          const $start = state.doc.resolve(range2.from);
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
            return null;
          }
          state.tr.delete(range2.from, range2.to).setBlockType(range2.from, range2.from, config.type, attributes);
        }
      });
    }
    function textInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range: range2, match }) => {
          let insert = config.replace;
          let start = range2.from;
          const end = range2.to;
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            insert += match[0].slice(offset + match[1].length);
            start += offset;
            const cutOff = start - end;
            if (cutOff > 0) {
              insert = match[0].slice(offset - cutOff, offset) + insert;
              start = end;
            }
          }
          state.tr.insertText(insert, start, end);
        }
      });
    }
    function wrappingInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range: range2, match, chain }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const tr2 = state.tr.delete(range2.from, range2.to);
          const $start = tr2.doc.resolve(range2.from);
          const blockRange = $start.blockRange();
          const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
          if (!wrapping) {
            return null;
          }
          tr2.wrap(blockRange, wrapping);
          if (config.keepMarks && config.editor) {
            const { selection, storedMarks } = state;
            const { splittableMarks } = config.editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            if (marks) {
              const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
              tr2.ensureMarks(filteredMarks);
            }
          }
          if (config.keepAttributes) {
            const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
            chain().updateAttributes(nodeType, attributes).run();
          }
          const before = tr2.doc.resolve(range2.from - 1).nodeBefore;
          if (before && before.type === config.type && canJoin(tr2.doc, range2.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
            tr2.join(range2.from - 1);
          }
        }
      });
    }
    class Node {
      constructor(config = {}) {
        this.type = "node";
        this.name = "node";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = {
          ...this.config,
          ...config
        };
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new Node(config);
      }
      configure(options = {}) {
        const extension = this.extend({
          ...this.config,
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        });
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new Node(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    }
    class NodeView {
      constructor(component, props, options) {
        this.isDragging = false;
        this.component = component;
        this.editor = props.editor;
        this.options = {
          stopEvent: null,
          ignoreMutation: null,
          ...options
        };
        this.extension = props.extension;
        this.node = props.node;
        this.decorations = props.decorations;
        this.innerDecorations = props.innerDecorations;
        this.view = props.view;
        this.HTMLAttributes = props.HTMLAttributes;
        this.getPos = props.getPos;
        this.mount();
      }
      mount() {
        return;
      }
      get dom() {
        return this.editor.view.dom;
      }
      get contentDOM() {
        return null;
      }
      onDragStart(event) {
        var _a2, _b2, _c2, _d2, _e, _f2, _g2;
        const { view } = this.editor;
        const target = event.target;
        const dragHandle = target.nodeType === 3 ? (_a2 = target.parentElement) === null || _a2 === void 0 ? void 0 : _a2.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
        if (!this.dom || ((_b2 = this.contentDOM) === null || _b2 === void 0 ? void 0 : _b2.contains(target)) || !dragHandle) {
          return;
        }
        let x = 0;
        let y = 0;
        if (this.dom !== dragHandle) {
          const domBox = this.dom.getBoundingClientRect();
          const handleBox = dragHandle.getBoundingClientRect();
          const offsetX = (_c2 = event.offsetX) !== null && _c2 !== void 0 ? _c2 : (_d2 = event.nativeEvent) === null || _d2 === void 0 ? void 0 : _d2.offsetX;
          const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f2 = event.nativeEvent) === null || _f2 === void 0 ? void 0 : _f2.offsetY;
          x = handleBox.x - domBox.x + offsetX;
          y = handleBox.y - domBox.y + offsetY;
        }
        (_g2 = event.dataTransfer) === null || _g2 === void 0 ? void 0 : _g2.setDragImage(this.dom, x, y);
        const pos = this.getPos();
        if (typeof pos !== "number") {
          return;
        }
        const selection = NodeSelection.create(view.state.doc, pos);
        const transaction = view.state.tr.setSelection(selection);
        view.dispatch(transaction);
      }
      stopEvent(event) {
        var _a2;
        if (!this.dom) {
          return false;
        }
        if (typeof this.options.stopEvent === "function") {
          return this.options.stopEvent({ event });
        }
        const target = event.target;
        const isInElement = this.dom.contains(target) && !((_a2 = this.contentDOM) === null || _a2 === void 0 ? void 0 : _a2.contains(target));
        if (!isInElement) {
          return false;
        }
        const isDragEvent = event.type.startsWith("drag");
        const isDropEvent = event.type === "drop";
        const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
        if (isInput && !isDropEvent && !isDragEvent) {
          return true;
        }
        const { isEditable } = this.editor;
        const { isDragging } = this;
        const isDraggable = !!this.node.type.spec.draggable;
        const isSelectable = NodeSelection.isSelectable(this.node);
        const isCopyEvent = event.type === "copy";
        const isPasteEvent = event.type === "paste";
        const isCutEvent = event.type === "cut";
        const isClickEvent = event.type === "mousedown";
        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
          event.preventDefault();
        }
        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
          event.preventDefault();
          return false;
        }
        if (isDraggable && isEditable && !isDragging && isClickEvent) {
          const dragHandle = target.closest("[data-drag-handle]");
          const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
          if (isValidDragHandle) {
            this.isDragging = true;
            document.addEventListener("dragend", () => {
              this.isDragging = false;
            }, { once: true });
            document.addEventListener("drop", () => {
              this.isDragging = false;
            }, { once: true });
            document.addEventListener("mouseup", () => {
              this.isDragging = false;
            }, { once: true });
          }
        }
        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
          return false;
        }
        return true;
      }
      /**
       * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
       * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
       * @return `true` if it can safely be ignored.
       */
      ignoreMutation(mutation) {
        if (!this.dom || !this.contentDOM) {
          return true;
        }
        if (typeof this.options.ignoreMutation === "function") {
          return this.options.ignoreMutation({ mutation });
        }
        if (this.node.isLeaf || this.node.isAtom) {
          return true;
        }
        if (mutation.type === "selection") {
          return false;
        }
        if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
          const changedNodes = [
            ...Array.from(mutation.addedNodes),
            ...Array.from(mutation.removedNodes)
          ];
          if (changedNodes.every((node) => node.isContentEditable)) {
            return false;
          }
        }
        if (this.contentDOM === mutation.target && mutation.type === "attributes") {
          return true;
        }
        if (this.contentDOM.contains(mutation.target)) {
          return false;
        }
        return true;
      }
      /**
       * Update the attributes of the prosemirror node.
       */
      updateAttributes(attributes) {
        this.editor.commands.command(({ tr: tr2 }) => {
          const pos = this.getPos();
          if (typeof pos !== "number") {
            return false;
          }
          tr2.setNodeMarkup(pos, void 0, {
            ...this.node.attrs,
            ...attributes
          });
          return true;
        });
      }
      /**
       * Delete the node.
       */
      deleteNode() {
        const from = this.getPos();
        if (typeof from !== "number") {
          return;
        }
        const to2 = from + this.node.nodeSize;
        this.editor.commands.deleteRange({ from, to: to2 });
      }
    }
    function markPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state, range: range2, match, pasteEvent }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr: tr2 } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = range2.to;
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range2.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type) => type === config.type && type !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range2.to) {
              tr2.delete(textEnd, range2.to);
            }
            if (textStart > range2.from) {
              tr2.delete(range2.from + startSpaces, textStart);
            }
            markEnd = range2.from + startSpaces + captureGroup.length;
            tr2.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr2.removeStoredMark(config.type);
          }
        }
      });
    }
    function escapeForRegEx(string2) {
      return string2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var W_ = Object.defineProperty;
    var G_ = (n2, e, t) => e in n2 ? W_(n2, e, { enumerable: true, configurable: true, writable: true, value: t }) : n2[e] = t;
    var cn = (n2, e, t) => G_(n2, typeof e != "symbol" ? e + "" : e, t);
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function Vc(n2, e, t) {
      for (let o = 0; ; o++) {
        if (o == n2.childCount || o == e.childCount)
          return n2.childCount == e.childCount ? null : t;
        let i2 = n2.child(o), s = e.child(o);
        if (i2 == s) {
          t += i2.nodeSize;
          continue;
        }
        if (!i2.sameMarkup(s))
          return t;
        if (i2.isText && i2.text != s.text) {
          for (let r = 0; i2.text[r] == s.text[r]; r++)
            t++;
          return t;
        }
        if (i2.content.size || s.content.size) {
          let r = Vc(i2.content, s.content, t + 1);
          if (r != null)
            return r;
        }
        t += i2.nodeSize;
      }
    }
    function Wc(n2, e, t, o) {
      for (let i2 = n2.childCount, s = e.childCount; ; ) {
        if (i2 == 0 || s == 0)
          return i2 == s ? null : { a: t, b: o };
        let r = n2.child(--i2), a = e.child(--s), l = r.nodeSize;
        if (r == a) {
          t -= l, o -= l;
          continue;
        }
        if (!r.sameMarkup(a))
          return { a: t, b: o };
        if (r.isText && r.text != a.text) {
          let u = 0, c2 = Math.min(r.text.length, a.text.length);
          for (; u < c2 && r.text[r.text.length - u - 1] == a.text[a.text.length - u - 1]; )
            u++, t--, o--;
          return { a: t, b: o };
        }
        if (r.content.size || a.content.size) {
          let u = Wc(r.content, a.content, t - 1, o - 1);
          if (u)
            return u;
        }
        t -= l, o -= l;
      }
    }
    class W {
      /**
      @internal
      */
      constructor(e, t) {
        if (this.content = e, this.size = t || 0, t == null)
          for (let o = 0; o < e.length; o++)
            this.size += e[o].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(e, t, o, i2 = 0, s) {
        for (let r = 0, a = 0; a < t; r++) {
          let l = this.content[r], u = a + l.nodeSize;
          if (u > e && o(l, i2 + a, s || null, r) !== false && l.content.size) {
            let c2 = a + 1;
            l.nodesBetween(Math.max(0, e - c2), Math.min(l.content.size, t - c2), o, i2 + c2);
          }
          a = u;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(e) {
        this.nodesBetween(0, this.size, e);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(e, t, o, i2) {
        let s = "", r = true;
        return this.nodesBetween(e, t, (a, l) => {
          let u = a.isText ? a.text.slice(Math.max(e, l) - l, t - l) : a.isLeaf ? i2 ? typeof i2 == "function" ? i2(a) : i2 : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
          a.isBlock && (a.isLeaf && u || a.isTextblock) && o && (r ? r = false : s += o), s += u;
        }, 0), s;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(e) {
        if (!e.size)
          return this;
        if (!this.size)
          return e;
        let t = this.lastChild, o = e.firstChild, i2 = this.content.slice(), s = 0;
        for (t.isText && t.sameMarkup(o) && (i2[i2.length - 1] = t.withText(t.text + o.text), s = 1); s < e.content.length; s++)
          i2.push(e.content[s]);
        return new W(i2, this.size + e.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(e, t = this.size) {
        if (e == 0 && t == this.size)
          return this;
        let o = [], i2 = 0;
        if (t > e)
          for (let s = 0, r = 0; r < t; s++) {
            let a = this.content[s], l = r + a.nodeSize;
            l > e && ((r < e || l > t) && (a.isText ? a = a.cut(Math.max(0, e - r), Math.min(a.text.length, t - r)) : a = a.cut(Math.max(0, e - r - 1), Math.min(a.content.size, t - r - 1))), o.push(a), i2 += a.nodeSize), r = l;
          }
        return new W(o, i2);
      }
      /**
      @internal
      */
      cutByIndex(e, t) {
        return e == t ? W.empty : e == 0 && t == this.content.length ? this : new W(this.content.slice(e, t));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(e, t) {
        let o = this.content[e];
        if (o == t)
          return this;
        let i2 = this.content.slice(), s = this.size + t.nodeSize - o.nodeSize;
        return i2[e] = t, new W(i2, s);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(e) {
        return new W([e].concat(this.content), this.size + e.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(e) {
        return new W(this.content.concat(e), this.size + e.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(e) {
        if (this.content.length != e.content.length)
          return false;
        for (let t = 0; t < this.content.length; t++)
          if (!this.content[t].eq(e.content[t]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(e) {
        let t = this.content[e];
        if (!t)
          throw new RangeError("Index " + e + " out of range for " + this);
        return t;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(e) {
        return this.content[e] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(e) {
        for (let t = 0, o = 0; t < this.content.length; t++) {
          let i2 = this.content[t];
          e(i2, o, t), o += i2.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(e, t = 0) {
        return Vc(this, e, t);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(e, t = this.size, o = e.size) {
        return Wc(this, e, t, o);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(e, t = -1) {
        if (e == 0)
          return os$1(0, e);
        if (e == this.size)
          return os$1(this.content.length, e);
        if (e > this.size || e < 0)
          throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let o = 0, i2 = 0; ; o++) {
          let s = this.child(o), r = i2 + s.nodeSize;
          if (r >= e)
            return r == e || t > 0 ? os$1(o + 1, r) : os$1(o, i2);
          i2 = r;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((e) => e.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(e, t) {
        if (!t)
          return W.empty;
        if (!Array.isArray(t))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new W(t.map(e.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(e) {
        if (!e.length)
          return W.empty;
        let t, o = 0;
        for (let i2 = 0; i2 < e.length; i2++) {
          let s = e[i2];
          o += s.nodeSize, i2 && s.isText && e[i2 - 1].sameMarkup(s) ? (t || (t = e.slice(0, i2)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
        }
        return new W(t || e, o);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(e) {
        if (!e)
          return W.empty;
        if (e instanceof W)
          return e;
        if (Array.isArray(e))
          return this.fromArray(e);
        if (e.attrs)
          return new W([e], e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }
    W.empty = new W([], 0);
    const Pr = { index: 0, offset: 0 };
    function os$1(n2, e) {
      return Pr.index = n2, Pr.offset = e, Pr;
    }
    function ga(n2, e) {
      if (n2 === e)
        return true;
      if (!(n2 && typeof n2 == "object") || !(e && typeof e == "object"))
        return false;
      let t = Array.isArray(n2);
      if (Array.isArray(e) != t)
        return false;
      if (t) {
        if (n2.length != e.length)
          return false;
        for (let o = 0; o < n2.length; o++)
          if (!ga(n2[o], e[o]))
            return false;
      } else {
        for (let o in n2)
          if (!(o in e) || !ga(n2[o], e[o]))
            return false;
        for (let o in e)
          if (!(o in n2))
            return false;
      }
      return true;
    }
    class Fn {
      /**
      @internal
      */
      constructor(e, t) {
        this.type = e, this.attrs = t;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(e) {
        let t, o = false;
        for (let i2 = 0; i2 < e.length; i2++) {
          let s = e[i2];
          if (this.eq(s))
            return e;
          if (this.type.excludes(s.type))
            t || (t = e.slice(0, i2));
          else {
            if (s.type.excludes(this.type))
              return e;
            !o && s.type.rank > this.type.rank && (t || (t = e.slice(0, i2)), t.push(this), o = true), t && t.push(s);
          }
        }
        return t || (t = e.slice()), o || t.push(this), t;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(e) {
        for (let t = 0; t < e.length; t++)
          if (this.eq(e[t]))
            return e.slice(0, t).concat(e.slice(t + 1));
        return e;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(e) {
        for (let t = 0; t < e.length; t++)
          if (this.eq(e[t]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(e) {
        return this == e || this.type == e.type && ga(this.attrs, e.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let e = { type: this.type.name };
        for (let t in this.attrs) {
          e.attrs = this.attrs;
          break;
        }
        return e;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(e, t) {
        if (!t)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let o = e.marks[t.type];
        if (!o)
          throw new RangeError(`There is no mark type ${t.type} in this schema`);
        let i2 = o.create(t.attrs);
        return o.checkAttrs(i2.attrs), i2;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(e, t) {
        if (e == t)
          return true;
        if (e.length != t.length)
          return false;
        for (let o = 0; o < e.length; o++)
          if (!e[o].eq(t[o]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
          return Fn.none;
        if (e instanceof Fn)
          return [e];
        let t = e.slice();
        return t.sort((o, i2) => o.type.rank - i2.type.rank), t;
      }
    }
    Fn.none = [];
    class mm extends Error {
    }
    class G {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragmenti.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(e, t, o) {
        this.content = e, this.openStart = t, this.openEnd = o;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(e, t) {
        let o = Yc(this.content, e + this.openStart, t);
        return o && new G(o, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(e, t) {
        return new G(Gc(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let e = { content: this.content.toJSON() };
        return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(e, t) {
        if (!t)
          return G.empty;
        let o = t.openStart || 0, i2 = t.openEnd || 0;
        if (typeof o != "number" || typeof i2 != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new G(W.fromJSON(e, t.content), o, i2);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(e, t = true) {
        let o = 0, i2 = 0;
        for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
          o++;
        for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
          i2++;
        return new G(e, o, i2);
      }
    }
    G.empty = new G(W.empty, 0, 0);
    function Gc(n2, e, t) {
      let { index: o, offset: i2 } = n2.findIndex(e), s = n2.maybeChild(o), { index: r, offset: a } = n2.findIndex(t);
      if (i2 == e || s.isText) {
        if (a != t && !n2.child(r).isText)
          throw new RangeError("Removing non-flat range");
        return n2.cut(0, e).append(n2.cut(t));
      }
      if (o != r)
        throw new RangeError("Removing non-flat range");
      return n2.replaceChild(o, s.copy(Gc(s.content, e - i2 - 1, t - i2 - 1)));
    }
    function Yc(n2, e, t, o) {
      let { index: i2, offset: s } = n2.findIndex(e), r = n2.maybeChild(i2);
      if (s == e || r.isText)
        return n2.cut(0, e).append(t).append(n2.cut(e));
      let a = Yc(r.content, e - s - 1, t);
      return a && n2.replaceChild(i2, r.copy(a));
    }
    function fm(n2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let t in n2) {
        let o = n2[t];
        if (!o.hasDefault)
          return null;
        e[t] = o.default;
      }
      return e;
    }
    function gm(n2, e) {
      let t = /* @__PURE__ */ Object.create(null);
      for (let o in n2) {
        let i2 = e && e[o];
        if (i2 === void 0) {
          let s = n2[o];
          if (s.hasDefault)
            i2 = s.default;
          else
            throw new RangeError("No value supplied for attribute " + o);
        }
        t[o] = i2;
      }
      return t;
    }
    function hm(n2, e, t, o) {
      for (let i2 in e)
        if (!(i2 in n2))
          throw new RangeError(`Unsupported attribute ${i2} for ${t} of type ${i2}`);
      for (let i2 in n2) {
        let s = n2[i2];
        s.validate && s.validate(e[i2]);
      }
    }
    function vm(n2, e) {
      let t = /* @__PURE__ */ Object.create(null);
      if (e)
        for (let o in e)
          t[o] = new km(n2, o, e[o]);
      return t;
    }
    function bm(n2, e, t) {
      let o = t.split("|");
      return (i2) => {
        let s = i2 === null ? "null" : typeof i2;
        if (o.indexOf(s) < 0)
          throw new RangeError(`Expected value of type ${o} for attribute ${e} on type ${n2}, got ${s}`);
      };
    }
    class km {
      constructor(e, t, o) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(o, "default"), this.default = o.default, this.validate = typeof o.validate == "string" ? bm(e, t, o.validate) : o.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    }
    class Ya {
      /**
      @internal
      */
      constructor(e, t, o, i2) {
        this.name = e, this.rank = t, this.schema = o, this.spec = i2, this.attrs = vm(e, i2.attrs), this.excluded = null;
        let s = fm(this.attrs);
        this.instance = s ? new Fn(this, s) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(e = null) {
        return !e && this.instance ? this.instance : new Fn(this, gm(this.attrs, e));
      }
      /**
      @internal
      */
      static compile(e, t) {
        let o = /* @__PURE__ */ Object.create(null), i2 = 0;
        return e.forEach((s, r) => o[s] = new Ya(s, i2++, t, r)), o;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(e) {
        for (var t = 0; t < e.length; t++)
          e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
        return e;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(e) {
        for (let t = 0; t < e.length; t++)
          if (e[t].type == this)
            return e[t];
      }
      /**
      @internal
      */
      checkAttrs(e) {
        hm(this.attrs, e, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(e) {
        return this.excluded.indexOf(e) > -1;
      }
    }
    function ym(n2) {
      return n2.tag != null;
    }
    function jm(n2) {
      return n2.style != null;
    }
    let wm = class ha {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(e, t) {
        this.schema = e, this.rules = t, this.tags = [], this.styles = [];
        let o = this.matchedStyles = [];
        t.forEach((i2) => {
          if (ym(i2))
            this.tags.push(i2);
          else if (jm(i2)) {
            let s = /[^=]*/.exec(i2.style)[0];
            o.indexOf(s) < 0 && o.push(s), this.styles.push(i2);
          }
        }), this.normalizeLists = !this.tags.some((i2) => {
          if (!/^(ul|ol)\b/.test(i2.tag) || !i2.node)
            return false;
          let s = e.nodes[i2.node];
          return s.contentMatch.matchType(s);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(e, t = {}) {
        let o = new Ql(this, t, false);
        return o.addAll(e, Fn.none, t.from, t.to), o.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(e, t = {}) {
        let o = new Ql(this, t, true);
        return o.addAll(e, Fn.none, t.from, t.to), G.maxOpen(o.finish());
      }
      /**
      @internal
      */
      matchTag(e, t, o) {
        for (let i2 = o ? this.tags.indexOf(o) + 1 : 0; i2 < this.tags.length; i2++) {
          let s = this.tags[i2];
          if (Sm(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
            if (s.getAttrs) {
              let r = s.getAttrs(e);
              if (r === false)
                continue;
              s.attrs = r || void 0;
            }
            return s;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(e, t, o, i2) {
        for (let s = i2 ? this.styles.indexOf(i2) + 1 : 0; s < this.styles.length; s++) {
          let r = this.styles[s], a = r.style;
          if (!(a.indexOf(e) != 0 || r.context && !o.matchesContext(r.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
            if (r.getAttrs) {
              let l = r.getAttrs(t);
              if (l === false)
                continue;
              r.attrs = l || void 0;
            }
            return r;
          }
        }
      }
      /**
      @internal
      */
      static schemaRules(e) {
        let t = [];
        function o(i2) {
          let s = i2.priority == null ? 50 : i2.priority, r = 0;
          for (; r < t.length; r++) {
            let a = t[r];
            if ((a.priority == null ? 50 : a.priority) < s)
              break;
          }
          t.splice(r, 0, i2);
        }
        for (let i2 in e.marks) {
          let s = e.marks[i2].spec.parseDOM;
          s && s.forEach((r) => {
            o(r = eu(r)), r.mark || r.ignore || r.clearMark || (r.mark = i2);
          });
        }
        for (let i2 in e.nodes) {
          let s = e.nodes[i2].spec.parseDOM;
          s && s.forEach((r) => {
            o(r = eu(r)), r.node || r.ignore || r.mark || (r.node = i2);
          });
        }
        return t;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new ha(e, ha.schemaRules(e)));
      }
    };
    const Jc = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    }, Em = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    }, Zc = { ol: true, ul: true }, Ai = 1, va = 2, Es = 4;
    function Xl(n2, e, t) {
      return e != null ? (e ? Ai : 0) | (e === "full" ? va : 0) : n2 && n2.whitespace == "pre" ? Ai | va : t & -5;
    }
    class is {
      constructor(e, t, o, i2, s, r) {
        this.type = e, this.attrs = t, this.marks = o, this.solid = i2, this.options = r, this.content = [], this.activeMarks = Fn.none, this.match = s || (r & Es ? null : e.contentMatch);
      }
      findWrapping(e) {
        if (!this.match) {
          if (!this.type)
            return [];
          let t = this.type.contentMatch.fillBefore(W.from(e));
          if (t)
            this.match = this.type.contentMatch.matchFragment(t);
          else {
            let o = this.type.contentMatch, i2;
            return (i2 = o.findWrapping(e.type)) ? (this.match = o, i2) : null;
          }
        }
        return this.match.findWrapping(e.type);
      }
      finish(e) {
        if (!(this.options & Ai)) {
          let o = this.content[this.content.length - 1], i2;
          if (o && o.isText && (i2 = /[ \t\r\n\u000c]+$/.exec(o.text))) {
            let s = o;
            o.text.length == i2[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i2[0].length));
          }
        }
        let t = W.from(this.content);
        return !e && this.match && (t = t.append(this.match.fillBefore(W.empty, true))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
      }
      inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Jc.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
      }
    }
    class Ql {
      constructor(e, t, o) {
        this.parser = e, this.options = t, this.isOpen = o, this.open = 0, this.localPreserveWS = false;
        let i2 = t.topNode, s, r = Xl(null, t.preserveWhitespace, 0) | (o ? Es : 0);
        i2 ? s = new is(i2.type, i2.attrs, Fn.none, true, t.topMatch || i2.type.contentMatch, r) : o ? s = new is(null, null, Fn.none, true, null, r) : s = new is(e.schema.topNodeType, null, Fn.none, true, null, r), this.nodes = [s], this.find = t.findPositions, this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(e, t) {
        e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
      }
      addTextNode(e, t) {
        let o = e.nodeValue, i2 = this.top, s = i2.options & va ? "full" : this.localPreserveWS || (i2.options & Ai) > 0;
        if (s === "full" || i2.inlineContext(e) || /[^ \t\r\n\u000c]/.test(o)) {
          if (s)
            s !== "full" ? o = o.replace(/\r?\n|\r/g, " ") : o = o.replace(/\r\n?/g, `
`);
          else if (o = o.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(o) && this.open == this.nodes.length - 1) {
            let r = i2.content[i2.content.length - 1], a = e.previousSibling;
            (!r || a && a.nodeName == "BR" || r.isText && /[ \t\r\n\u000c]$/.test(r.text)) && (o = o.slice(1));
          }
          o && this.insertNode(this.parser.schema.text(o), t), this.findInText(e);
        } else
          this.findInside(e);
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(e, t, o) {
        let i2 = this.localPreserveWS, s = this.top;
        (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
        let r = e.nodeName.toLowerCase(), a;
        Zc.hasOwnProperty(r) && this.parser.normalizeLists && Cm(e);
        let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, o));
        e: if (l ? l.ignore : Em.hasOwnProperty(r))
          this.findInside(e), this.ignoreFallback(e, t);
        else if (!l || l.skip || l.closeParent) {
          l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
          let u, c2 = this.needsBlock;
          if (Jc.hasOwnProperty(r))
            s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), u = true, s.type || (this.needsBlock = true);
          else if (!e.firstChild) {
            this.leafFallback(e, t);
            break e;
          }
          let d = l && l.skip ? t : this.readStyles(e, t);
          d && this.addAll(e, d), u && this.sync(s), this.needsBlock = c2;
        } else {
          let u = this.readStyles(e, t);
          u && this.addElementByRule(e, l, u, l.consuming === false ? a : void 0);
        }
        this.localPreserveWS = i2;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(e, t) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
      }
      // Called for ignored nodes
      ignoreFallback(e, t) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(e, t) {
        let o = e.style;
        if (o && o.length)
          for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
            let s = this.parser.matchedStyles[i2], r = o.getPropertyValue(s);
            if (r)
              for (let a = void 0; ; ) {
                let l = this.parser.matchStyle(s, r, this, a);
                if (!l)
                  break;
                if (l.ignore)
                  return null;
                if (l.clearMark ? t = t.filter((u) => !l.clearMark(u)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === false)
                  a = l;
                else
                  break;
              }
          }
        return t;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(e, t, o, i2) {
        let s, r;
        if (t.node)
          if (r = this.parser.schema.nodes[t.node], r.isLeaf)
            this.insertNode(r.create(t.attrs), o) || this.leafFallback(e, o);
          else {
            let l = this.enter(r, t.attrs || null, o, t.preserveWhitespace);
            l && (s = true, o = l);
          }
        else {
          let l = this.parser.schema.marks[t.mark];
          o = o.concat(l.create(t.attrs));
        }
        let a = this.top;
        if (r && r.isLeaf)
          this.findInside(e);
        else if (i2)
          this.addElement(e, o, i2);
        else if (t.getContent)
          this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, o));
        else {
          let l = e;
          typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, true), this.addAll(l, o), this.findAround(e, l, false);
        }
        s && this.sync(a) && this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(e, t, o, i2) {
        let s = o || 0;
        for (let r = o ? e.childNodes[o] : e.firstChild, a = i2 == null ? null : e.childNodes[i2]; r != a; r = r.nextSibling, ++s)
          this.findAtPoint(e, s), this.addDOM(r, t);
        this.findAtPoint(e, s);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(e, t) {
        let o, i2;
        for (let s = this.open; s >= 0; s--) {
          let r = this.nodes[s], a = r.findWrapping(e);
          if (a && (!o || o.length > a.length) && (o = a, i2 = r, !a.length) || r.solid)
            break;
        }
        if (!o)
          return null;
        this.sync(i2);
        for (let s = 0; s < o.length; s++)
          t = this.enterInner(o[s], null, t, false);
        return t;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(e, t) {
        if (e.isInline && this.needsBlock && !this.top.type) {
          let i2 = this.textblockFromContext();
          i2 && (t = this.enterInner(i2, null, t));
        }
        let o = this.findPlace(e, t);
        if (o) {
          this.closeExtra();
          let i2 = this.top;
          i2.match && (i2.match = i2.match.matchType(e.type));
          let s = Fn.none;
          for (let r of o.concat(e.marks))
            (i2.type ? i2.type.allowsMarkType(r.type) : nu(r.type, e.type)) && (s = r.addToSet(s));
          return i2.content.push(e.mark(s)), true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(e, t, o, i2) {
        let s = this.findPlace(e.create(t), o);
        return s && (s = this.enterInner(e, t, o, true, i2)), s;
      }
      // Open a node of the given type
      enterInner(e, t, o, i2 = false, s) {
        this.closeExtra();
        let r = this.top;
        r.match = r.match && r.match.matchType(e);
        let a = Xl(e, s, r.options);
        r.options & Es && r.content.length == 0 && (a |= Es);
        let l = Fn.none;
        return o = o.filter((u) => (r.type ? r.type.allowsMarkType(u.type) : nu(u.type, e)) ? (l = u.addToSet(l), false) : true), this.nodes.push(new is(e, t, l, i2, null, a)), this.open++, o;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(e = false) {
        let t = this.nodes.length - 1;
        if (t > this.open) {
          for (; t > this.open; t--)
            this.nodes[t - 1].content.push(this.nodes[t].finish(e));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(e) {
        for (let t = this.open; t >= 0; t--) {
          if (this.nodes[t] == e)
            return this.open = t, true;
          this.localPreserveWS && (this.nodes[t].options |= Ai);
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let t = this.open; t >= 0; t--) {
          let o = this.nodes[t].content;
          for (let i2 = o.length - 1; i2 >= 0; i2--)
            e += o[i2].nodeSize;
          t && e++;
        }
        return e;
      }
      findAtPoint(e, t) {
        if (this.find)
          for (let o = 0; o < this.find.length; o++)
            this.find[o].node == e && this.find[o].offset == t && (this.find[o].pos = this.currentPos);
      }
      findInside(e) {
        if (this.find)
          for (let t = 0; t < this.find.length; t++)
            this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
      }
      findAround(e, t, o) {
        if (e != t && this.find)
          for (let i2 = 0; i2 < this.find.length; i2++)
            this.find[i2].pos == null && e.nodeType == 1 && e.contains(this.find[i2].node) && t.compareDocumentPosition(this.find[i2].node) & (o ? 2 : 4) && (this.find[i2].pos = this.currentPos);
      }
      findInText(e) {
        if (this.find)
          for (let t = 0; t < this.find.length; t++)
            this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
      }
      // Determines whether the given context string matches this context.
      matchesContext(e) {
        if (e.indexOf("|") > -1)
          return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let t = e.split("/"), o = this.options.context, i2 = !this.isOpen && (!o || o.parent.type == this.nodes[0].type), s = -(o ? o.depth + 1 : 0) + (i2 ? 0 : 1), r = (a, l) => {
          for (; a >= 0; a--) {
            let u = t[a];
            if (u == "") {
              if (a == t.length - 1 || a == 0)
                continue;
              for (; l >= s; l--)
                if (r(a - 1, l))
                  return true;
              return false;
            } else {
              let c2 = l > 0 || l == 0 && i2 ? this.nodes[l].type : o && l >= s ? o.node(l - s).type : null;
              if (!c2 || c2.name != u && !c2.isInGroup(u))
                return false;
              l--;
            }
          }
          return true;
        };
        return r(t.length - 1, this.open);
      }
      textblockFromContext() {
        let e = this.options.context;
        if (e)
          for (let t = e.depth; t >= 0; t--) {
            let o = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
            if (o && o.isTextblock && o.defaultAttrs)
              return o;
          }
        for (let t in this.parser.schema.nodes) {
          let o = this.parser.schema.nodes[t];
          if (o.isTextblock && o.defaultAttrs)
            return o;
        }
      }
    }
    function Cm(n2) {
      for (let e = n2.firstChild, t = null; e; e = e.nextSibling) {
        let o = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        o && Zc.hasOwnProperty(o) && t ? (t.appendChild(e), e = t) : o == "li" ? t = e : o && (t = null);
      }
    }
    function Sm(n2, e) {
      return (n2.matches || n2.msMatchesSelector || n2.webkitMatchesSelector || n2.mozMatchesSelector).call(n2, e);
    }
    function eu(n2) {
      let e = {};
      for (let t in n2)
        e[t] = n2[t];
      return e;
    }
    function nu(n2, e) {
      let t = e.schema.nodes;
      for (let o in t) {
        let i2 = t[o];
        if (!i2.allowsMarkType(n2))
          continue;
        let s = [], r = (a) => {
          s.push(a);
          for (let l = 0; l < a.edgeCount; l++) {
            let { type: u, next: c2 } = a.edge(l);
            if (u == e || s.indexOf(c2) < 0 && r(c2))
              return true;
          }
        };
        if (r(i2.contentMatch))
          return true;
      }
    }
    class jr {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(e, t) {
        this.nodes = e, this.marks = t;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(e, t = {}, o) {
        o || (o = $r(t).createDocumentFragment());
        let i2 = o, s = [];
        return e.forEach((r) => {
          if (s.length || r.marks.length) {
            let a = 0, l = 0;
            for (; a < s.length && l < r.marks.length; ) {
              let u = r.marks[l];
              if (!this.marks[u.type.name]) {
                l++;
                continue;
              }
              if (!u.eq(s[a][0]) || u.type.spec.spanning === false)
                break;
              a++, l++;
            }
            for (; a < s.length; )
              i2 = s.pop()[1];
            for (; l < r.marks.length; ) {
              let u = r.marks[l++], c2 = this.serializeMark(u, r.isInline, t);
              c2 && (s.push([u, i2]), i2.appendChild(c2.dom), i2 = c2.contentDOM || c2.dom);
            }
          }
          i2.appendChild(this.serializeNodeInner(r, t));
        }), o;
      }
      /**
      @internal
      */
      serializeNodeInner(e, t) {
        let { dom: o, contentDOM: i2 } = Cs($r(t), this.nodes[e.type.name](e), null, e.attrs);
        if (i2) {
          if (e.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(e.content, t, i2);
        }
        return o;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(e, t = {}) {
        let o = this.serializeNodeInner(e, t);
        for (let i2 = e.marks.length - 1; i2 >= 0; i2--) {
          let s = this.serializeMark(e.marks[i2], e.isInline, t);
          s && ((s.contentDOM || s.dom).appendChild(o), o = s.dom);
        }
        return o;
      }
      /**
      @internal
      */
      serializeMark(e, t, o = {}) {
        let i2 = this.marks[e.type.name];
        return i2 && Cs($r(o), i2(e, t), null, e.attrs);
      }
      static renderSpec(e, t, o = null, i2) {
        return Cs(e, t, o, i2);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new jr(this.nodesFromSchema(e), this.marksFromSchema(e)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(e) {
        let t = tu(e.nodes);
        return t.text || (t.text = (o) => o.text), t;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(e) {
        return tu(e.marks);
      }
    }
    function tu(n2) {
      let e = {};
      for (let t in n2) {
        let o = n2[t].spec.toDOM;
        o && (e[t] = o);
      }
      return e;
    }
    function $r(n2) {
      return n2.document || window.document;
    }
    const ou = /* @__PURE__ */ new WeakMap();
    function xm(n2) {
      let e = ou.get(n2);
      return e === void 0 && ou.set(n2, e = Tm(n2)), e;
    }
    function Tm(n2) {
      let e = null;
      function t(o) {
        if (o && typeof o == "object")
          if (Array.isArray(o))
            if (typeof o[0] == "string")
              e || (e = []), e.push(o);
            else
              for (let i2 = 0; i2 < o.length; i2++)
                t(o[i2]);
          else
            for (let i2 in o)
              t(o[i2]);
      }
      return t(n2), e;
    }
    function Cs(n2, e, t, o) {
      if (typeof e == "string")
        return { dom: n2.createTextNode(e) };
      if (e.nodeType != null)
        return { dom: e };
      if (e.dom && e.dom.nodeType != null)
        return e;
      let i2 = e[0], s;
      if (typeof i2 != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (o && (s = xm(o)) && s.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let r = i2.indexOf(" ");
      r > 0 && (t = i2.slice(0, r), i2 = i2.slice(r + 1));
      let a, l = t ? n2.createElementNS(t, i2) : n2.createElement(i2), u = e[1], c2 = 1;
      if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
        c2 = 2;
        for (let d in u)
          if (u[d] != null) {
            let p2 = d.indexOf(" ");
            p2 > 0 ? l.setAttributeNS(d.slice(0, p2), d.slice(p2 + 1), u[d]) : l.setAttribute(d, u[d]);
          }
      }
      for (let d = c2; d < e.length; d++) {
        let p2 = e[d];
        if (p2 === 0) {
          if (d < e.length - 1 || d > c2)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom: l, contentDOM: l };
        } else {
          let { dom: _, contentDOM: m } = Cs(n2, p2, t, o);
          if (l.appendChild(_), m) {
            if (a)
              throw new RangeError("Multiple content holes");
            a = m;
          }
        }
      }
      return { dom: l, contentDOM: a };
    }
    const Xc = 65535, Qc = Math.pow(2, 16);
    function Am(n2, e) {
      return n2 + e * Qc;
    }
    function iu(n2) {
      return n2 & Xc;
    }
    function Nm(n2) {
      return (n2 - (n2 & Xc)) / Qc;
    }
    const ed = 1, nd = 2, Ss = 4, td = 8;
    class ba {
      /**
      @internal
      */
      constructor(e, t, o) {
        this.pos = e, this.delInfo = t, this.recover = o;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & td) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (ed | Ss)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (nd | Ss)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & Ss) > 0;
      }
    }
    class Xn {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(e, t = false) {
        if (this.ranges = e, this.inverted = t, !e.length && Xn.empty)
          return Xn.empty;
      }
      /**
      @internal
      */
      recover(e) {
        let t = 0, o = iu(e);
        if (!this.inverted)
          for (let i2 = 0; i2 < o; i2++)
            t += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
        return this.ranges[o * 3] + t + Nm(e);
      }
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      map(e, t = 1) {
        return this._map(e, t, true);
      }
      /**
      @internal
      */
      _map(e, t, o) {
        let i2 = 0, s = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? i2 : 0);
          if (l > e)
            break;
          let u = this.ranges[a + s], c2 = this.ranges[a + r], d = l + u;
          if (e <= d) {
            let p2 = u ? e == l ? -1 : e == d ? 1 : t : t, _ = l + i2 + (p2 < 0 ? 0 : c2);
            if (o)
              return _;
            let m = e == (t < 0 ? l : d) ? null : Am(a / 3, e - l), f = e == l ? nd : e == d ? ed : Ss;
            return (t < 0 ? e != l : e != d) && (f |= td), new ba(_, f, m);
          }
          i2 += c2 - u;
        }
        return o ? e + i2 : new ba(e + i2, 0, null);
      }
      /**
      @internal
      */
      touches(e, t) {
        let o = 0, i2 = iu(t), s = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
        for (let a = 0; a < this.ranges.length; a += 3) {
          let l = this.ranges[a] - (this.inverted ? o : 0);
          if (l > e)
            break;
          let u = this.ranges[a + s], c2 = l + u;
          if (e <= c2 && a == i2 * 3)
            return true;
          o += this.ranges[a + r] - u;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(e) {
        let t = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
        for (let i2 = 0, s = 0; i2 < this.ranges.length; i2 += 3) {
          let r = this.ranges[i2], a = r - (this.inverted ? s : 0), l = r + (this.inverted ? 0 : s), u = this.ranges[i2 + t], c2 = this.ranges[i2 + o];
          e(a, a + u, l, l + c2), s += c2 - u;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new Xn(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(e) {
        return e == 0 ? Xn.empty : new Xn(e < 0 ? [0, -e, 0] : [0, 0, e]);
      }
    }
    Xn.empty = new Xn([]);
    class Ni {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(e, t, o = 0, i2 = e ? e.length : 0) {
        this.mirror = t, this.from = o, this.to = i2, this._maps = e || [], this.ownData = !(e || t);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(e = 0, t = this.maps.length) {
        return new Ni(this._maps, this.mirror, e, t);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(e, t) {
        this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(e) {
        for (let t = 0, o = this._maps.length; t < e._maps.length; t++) {
          let i2 = e.getMirror(t);
          this.appendMap(e._maps[t], i2 != null && i2 < t ? o + i2 : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(e) {
        if (this.mirror) {
          for (let t = 0; t < this.mirror.length; t++)
            if (this.mirror[t] == e)
              return this.mirror[t + (t % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(e, t) {
        this.mirror || (this.mirror = []), this.mirror.push(e, t);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(e) {
        for (let t = e.maps.length - 1, o = this._maps.length + e._maps.length; t >= 0; t--) {
          let i2 = e.getMirror(t);
          this.appendMap(e._maps[t].invert(), i2 != null && i2 > t ? o - i2 - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let e = new Ni();
        return e.appendMappingInverted(this), e;
      }
      /**
      Map a position through this mapping.
      */
      map(e, t = 1) {
        if (this.mirror)
          return this._map(e, t, true);
        for (let o = this.from; o < this.to; o++)
          e = this._maps[o].map(e, t);
        return e;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(e, t = 1) {
        return this._map(e, t, false);
      }
      /**
      @internal
      */
      _map(e, t, o) {
        let i2 = 0;
        for (let s = this.from; s < this.to; s++) {
          let r = this._maps[s], a = r.mapResult(e, t);
          if (a.recover != null) {
            let l = this.getMirror(s);
            if (l != null && l > s && l < this.to) {
              s = l, e = this._maps[l].recover(a.recover);
              continue;
            }
          }
          i2 |= a.delInfo, e = a.pos;
        }
        return o ? e : new ba(e, i2, null);
      }
    }
    const zr = /* @__PURE__ */ Object.create(null);
    class In {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return Xn.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(e) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(e, t) {
        if (!t || !t.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let o = zr[t.stepType];
        if (!o)
          throw new RangeError(`No step type ${t.stepType} defined`);
        return o.fromJSON(e, t);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(e, t) {
        if (e in zr)
          throw new RangeError("Duplicate use of step JSON ID " + e);
        return zr[e] = t, t.prototype.jsonID = e, t;
      }
    }
    class mn {
      /**
      @internal
      */
      constructor(e, t) {
        this.doc = e, this.failed = t;
      }
      /**
      Create a successful step result.
      */
      static ok(e) {
        return new mn(e, null);
      }
      /**
      Create a failed step result.
      */
      static fail(e) {
        return new mn(null, e);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(e, t, o, i2) {
        try {
          return mn.ok(e.replace(t, o, i2));
        } catch (s) {
          if (s instanceof mm)
            return mn.fail(s.message);
          throw s;
        }
      }
    }
    function Ja(n2, e, t) {
      let o = [];
      for (let i2 = 0; i2 < n2.childCount; i2++) {
        let s = n2.child(i2);
        s.content.size && (s = s.copy(Ja(s.content, e, s))), s.isInline && (s = e(s, t, i2)), o.push(s);
      }
      return W.fromArray(o);
    }
    class ro extends In {
      /**
      Create a mark step.
      */
      constructor(e, t, o) {
        super(), this.from = e, this.to = t, this.mark = o;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), o = e.resolve(this.from), i2 = o.node(o.sharedDepth(this.to)), s = new G(Ja(t.content, (r, a) => !r.isAtom || !a.type.allowsMarkType(this.mark.type) ? r : r.mark(this.mark.addToSet(r.marks)), i2), t.openStart, t.openEnd);
        return mn.fromReplace(e, this.from, this.to, s);
      }
      invert() {
        return new Lt(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return t.deleted && o.deleted || t.pos >= o.pos ? null : new ro(t.pos, o.pos, this.mark);
      }
      merge(e) {
        return e instanceof ro && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ro(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new ro(t.from, t.to, e.markFromJSON(t.mark));
      }
    }
    In.jsonID("addMark", ro);
    class Lt extends In {
      /**
      Create a mark-removing step.
      */
      constructor(e, t, o) {
        super(), this.from = e, this.to = t, this.mark = o;
      }
      apply(e) {
        let t = e.slice(this.from, this.to), o = new G(Ja(t.content, (i2) => i2.mark(this.mark.removeFromSet(i2.marks)), e), t.openStart, t.openEnd);
        return mn.fromReplace(e, this.from, this.to, o);
      }
      invert() {
        return new ro(this.from, this.to, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return t.deleted && o.deleted || t.pos >= o.pos ? null : new Lt(t.pos, o.pos, this.mark);
      }
      merge(e) {
        return e instanceof Lt && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Lt(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new Lt(t.from, t.to, e.markFromJSON(t.mark));
      }
    }
    In.jsonID("removeMark", Lt);
    class ao extends In {
      /**
      Create a node mark step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return mn.fail("No node at mark step's position");
        let o = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
        return mn.fromReplace(e, this.pos, this.pos + 1, new G(W.from(o), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        if (t) {
          let o = this.mark.addToSet(t.marks);
          if (o.length == t.marks.length) {
            for (let i2 = 0; i2 < t.marks.length; i2++)
              if (!t.marks[i2].isInSet(o))
                return new ao(this.pos, t.marks[i2]);
            return new ao(this.pos, this.mark);
          }
        }
        return new Xo(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new ao(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new ao(t.pos, e.markFromJSON(t.mark));
      }
    }
    In.jsonID("addNodeMark", ao);
    class Xo extends In {
      /**
      Create a mark-removing step.
      */
      constructor(e, t) {
        super(), this.pos = e, this.mark = t;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return mn.fail("No node at mark step's position");
        let o = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
        return mn.fromReplace(e, this.pos, this.pos + 1, new G(W.from(o), 0, t.isLeaf ? 0 : 1));
      }
      invert(e) {
        let t = e.nodeAt(this.pos);
        return !t || !this.mark.isInSet(t.marks) ? this : new ao(this.pos, this.mark);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new Xo(t.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new Xo(t.pos, e.markFromJSON(t.mark));
      }
    }
    In.jsonID("removeNodeMark", Xo);
    class Mn extends In {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(e, t, o, i2 = false) {
        super(), this.from = e, this.to = t, this.slice = o, this.structure = i2;
      }
      apply(e) {
        return this.structure && ka(e, this.from, this.to) ? mn.fail("Structure replace would overwrite content") : mn.fromReplace(e, this.from, this.to, this.slice);
      }
      getMap() {
        return new Xn([this.from, this.to - this.from, this.slice.size]);
      }
      invert(e) {
        return new Mn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
      }
      map(e) {
        let t = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
        return t.deletedAcross && o.deletedAcross ? null : new Mn(t.pos, Math.max(t.pos, o.pos), this.slice);
      }
      merge(e) {
        if (!(e instanceof Mn) || e.structure || this.structure)
          return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
          let t = this.slice.size + e.slice.size == 0 ? G.empty : new G(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
          return new Mn(this.from, this.to + (e.to - e.from), t, this.structure);
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
          let t = this.slice.size + e.slice.size == 0 ? G.empty : new G(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
          return new Mn(e.from, this.to, t, this.structure);
        } else
          return null;
      }
      toJSON() {
        let e = { stepType: "replace", from: this.from, to: this.to };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new Mn(t.from, t.to, G.fromJSON(e, t.slice), !!t.structure);
      }
    }
    In.jsonID("replace", Mn);
    class yt extends In {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(e, t, o, i2, s, r, a = false) {
        super(), this.from = e, this.to = t, this.gapFrom = o, this.gapTo = i2, this.slice = s, this.insert = r, this.structure = a;
      }
      apply(e) {
        if (this.structure && (ka(e, this.from, this.gapFrom) || ka(e, this.gapTo, this.to)))
          return mn.fail("Structure gap-replace would overwrite content");
        let t = e.slice(this.gapFrom, this.gapTo);
        if (t.openStart || t.openEnd)
          return mn.fail("Gap is not a flat range");
        let o = this.slice.insertAt(this.insert, t.content);
        return o ? mn.fromReplace(e, this.from, this.to, o) : mn.fail("Content does not fit in gap");
      }
      getMap() {
        return new Xn([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(e) {
        let t = this.gapTo - this.gapFrom;
        return new yt(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(e) {
        let t = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1), i2 = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? o.pos : e.map(this.gapTo, 1);
        return t.deletedAcross && o.deletedAcross || i2 < t.pos || s > o.pos ? null : new yt(t.pos, o.pos, i2, s, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let e = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new yt(t.from, t.to, t.gapFrom, t.gapTo, G.fromJSON(e, t.slice), t.insert, !!t.structure);
      }
    }
    In.jsonID("replaceAround", yt);
    function ka(n2, e, t) {
      let o = n2.resolve(e), i2 = t - e, s = o.depth;
      for (; i2 > 0 && s > 0 && o.indexAfter(s) == o.node(s).childCount; )
        s--, i2--;
      if (i2 > 0) {
        let r = o.node(s).maybeChild(o.indexAfter(s));
        for (; i2 > 0; ) {
          if (!r || r.isLeaf)
            return true;
          r = r.firstChild, i2--;
        }
      }
      return false;
    }
    function Om(n2, e, t, o) {
      let i2 = [], s = [], r, a;
      n2.doc.nodesBetween(e, t, (l, u, c2) => {
        if (!l.isInline)
          return;
        let d = l.marks;
        if (!o.isInSet(d) && c2.type.allowsMarkType(o.type)) {
          let p2 = Math.max(u, e), _ = Math.min(u + l.nodeSize, t), m = o.addToSet(d);
          for (let f = 0; f < d.length; f++)
            d[f].isInSet(m) || (r && r.to == p2 && r.mark.eq(d[f]) ? r.to = _ : i2.push(r = new Lt(p2, _, d[f])));
          a && a.to == p2 ? a.to = _ : s.push(a = new ro(p2, _, o));
        }
      }), i2.forEach((l) => n2.step(l)), s.forEach((l) => n2.step(l));
    }
    function Mm(n2, e, t, o) {
      let i2 = [], s = 0;
      n2.doc.nodesBetween(e, t, (r, a) => {
        if (!r.isInline)
          return;
        s++;
        let l = null;
        if (o instanceof Ya) {
          let u = r.marks, c2;
          for (; c2 = o.isInSet(u); )
            (l || (l = [])).push(c2), u = c2.removeFromSet(u);
        } else o ? o.isInSet(r.marks) && (l = [o]) : l = r.marks;
        if (l && l.length) {
          let u = Math.min(a + r.nodeSize, t);
          for (let c2 = 0; c2 < l.length; c2++) {
            let d = l[c2], p2;
            for (let _ = 0; _ < i2.length; _++) {
              let m = i2[_];
              m.step == s - 1 && d.eq(i2[_].style) && (p2 = m);
            }
            p2 ? (p2.to = u, p2.step = s) : i2.push({ style: d, from: Math.max(a, e), to: u, step: s });
          }
        }
      }), i2.forEach((r) => n2.step(new Lt(r.from, r.to, r.style)));
    }
    function Za(n2, e, t, o = t.contentMatch, i2 = true) {
      let s = n2.doc.nodeAt(e), r = [], a = e + 1;
      for (let l = 0; l < s.childCount; l++) {
        let u = s.child(l), c2 = a + u.nodeSize, d = o.matchType(u.type);
        if (!d)
          r.push(new Mn(a, c2, G.empty));
        else {
          o = d;
          for (let p2 = 0; p2 < u.marks.length; p2++)
            t.allowsMarkType(u.marks[p2].type) || n2.step(new Lt(a, c2, u.marks[p2]));
          if (i2 && u.isText && t.whitespace != "pre") {
            let p2, _ = /\r?\n|\r/g, m;
            for (; p2 = _.exec(u.text); )
              m || (m = new G(W.from(t.schema.text(" ", t.allowedMarks(u.marks))), 0, 0)), r.push(new Mn(a + p2.index, a + p2.index + p2[0].length, m));
          }
        }
        a = c2;
      }
      if (!o.validEnd) {
        let l = o.fillBefore(W.empty, true);
        n2.replace(a, a, new G(l, 0, 0));
      }
      for (let l = r.length - 1; l >= 0; l--)
        n2.step(r[l]);
    }
    function Rm(n2, e, t) {
      let { $from: o, $to: i2, depth: s } = e, r = o.before(s + 1), a = i2.after(s + 1), l = r, u = a, c2 = W.empty, d = 0;
      for (let m = s, f = false; m > t; m--)
        f || o.index(m) > 0 ? (f = true, c2 = W.from(o.node(m).copy(c2)), d++) : l--;
      let p2 = W.empty, _ = 0;
      for (let m = s, f = false; m > t; m--)
        f || i2.after(m + 1) < i2.end(m) ? (f = true, p2 = W.from(i2.node(m).copy(p2)), _++) : u++;
      n2.step(new yt(l, u, r, a, new G(c2.append(p2), d, _), c2.size - d, true));
    }
    function Im(n2, e, t) {
      let o = W.empty;
      for (let r = t.length - 1; r >= 0; r--) {
        if (o.size) {
          let a = t[r].type.contentMatch.matchFragment(o);
          if (!a || !a.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        o = W.from(t[r].type.create(t[r].attrs, o));
      }
      let i2 = e.start, s = e.end;
      n2.step(new yt(i2, s, i2, s, new G(o, 0, 0), t.length, true));
    }
    function Lm(n2, e, t, o, i2) {
      if (!o.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let s = n2.steps.length;
      n2.doc.nodesBetween(e, t, (r, a) => {
        let l = typeof i2 == "function" ? i2(r) : i2;
        if (r.isTextblock && !r.hasMarkup(o, l) && Dm(n2.doc, n2.mapping.slice(s).map(a), o)) {
          let u = null;
          if (o.schema.linebreakReplacement) {
            let _ = o.whitespace == "pre", m = !!o.contentMatch.matchType(o.schema.linebreakReplacement);
            _ && !m ? u = false : !_ && m && (u = true);
          }
          u === false && id(n2, r, a, s), Za(n2, n2.mapping.slice(s).map(a, 1), o, void 0, u === null);
          let c2 = n2.mapping.slice(s), d = c2.map(a, 1), p2 = c2.map(a + r.nodeSize, 1);
          return n2.step(new yt(d, p2, d + 1, p2 - 1, new G(W.from(o.create(l, null, r.marks)), 0, 0), 1, true)), u === true && od(n2, r, a, s), false;
        }
      });
    }
    function od(n2, e, t, o) {
      e.forEach((i2, s) => {
        if (i2.isText) {
          let r, a = /\r?\n|\r/g;
          for (; r = a.exec(i2.text); ) {
            let l = n2.mapping.slice(o).map(t + 1 + s + r.index);
            n2.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function id(n2, e, t, o) {
      e.forEach((i2, s) => {
        if (i2.type == i2.type.schema.linebreakReplacement) {
          let r = n2.mapping.slice(o).map(t + 1 + s);
          n2.replaceWith(r, r + 1, e.type.schema.text(`
`));
        }
      });
    }
    function Dm(n2, e, t) {
      let o = n2.resolve(e), i2 = o.index();
      return o.parent.canReplaceWith(i2, i2 + 1, t);
    }
    function Bm(n2, e, t, o, i2) {
      let s = n2.doc.nodeAt(e);
      if (!s)
        throw new RangeError("No node at given position");
      t || (t = s.type);
      let r = t.create(o, null, i2 || s.marks);
      if (s.isLeaf)
        return n2.replaceWith(e, e + s.nodeSize, r);
      if (!t.validContent(s.content))
        throw new RangeError("Invalid content for node type " + t.name);
      n2.step(new yt(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new G(W.from(r), 0, 0), 1, true));
    }
    function Pm(n2, e, t = 1, o) {
      let i2 = n2.doc.resolve(e), s = W.empty, r = W.empty;
      for (let a = i2.depth, l = i2.depth - t, u = t - 1; a > l; a--, u--) {
        s = W.from(i2.node(a).copy(s));
        let c2 = o && o[u];
        r = W.from(c2 ? c2.type.create(c2.attrs, r) : i2.node(a).copy(r));
      }
      n2.step(new Mn(e, e, new G(s.append(r), t, t), true));
    }
    function $m(n2, e, t) {
      let o = null, { linebreakReplacement: i2 } = n2.doc.type.schema, s = n2.doc.resolve(e - t), r = s.node().type;
      if (i2 && r.inlineContent) {
        let c2 = r.whitespace == "pre", d = !!r.contentMatch.matchType(i2);
        c2 && !d ? o = false : !c2 && d && (o = true);
      }
      let a = n2.steps.length;
      if (o === false) {
        let c2 = n2.doc.resolve(e + t);
        id(n2, c2.node(), c2.before(), a);
      }
      r.inlineContent && Za(n2, e + t - 1, r, s.node().contentMatchAt(s.index()), o == null);
      let l = n2.mapping.slice(a), u = l.map(e - t);
      if (n2.step(new Mn(u, l.map(e + t, -1), G.empty, true)), o === true) {
        let c2 = n2.doc.resolve(u);
        od(n2, c2.node(), c2.before(), n2.steps.length);
      }
      return n2;
    }
    function zm(n2, e, t) {
      let o = n2.resolve(e);
      if (o.parent.canReplaceWith(o.index(), o.index(), t))
        return e;
      if (o.parentOffset == 0)
        for (let i2 = o.depth - 1; i2 >= 0; i2--) {
          let s = o.index(i2);
          if (o.node(i2).canReplaceWith(s, s, t))
            return o.before(i2 + 1);
          if (s > 0)
            return null;
        }
      if (o.parentOffset == o.parent.content.size)
        for (let i2 = o.depth - 1; i2 >= 0; i2--) {
          let s = o.indexAfter(i2);
          if (o.node(i2).canReplaceWith(s, s, t))
            return o.after(i2 + 1);
          if (s < o.node(i2).childCount)
            return null;
        }
      return null;
    }
    function sd(n2, e, t) {
      let o = n2.resolve(e);
      if (!t.content.size)
        return e;
      let i2 = t.content;
      for (let s = 0; s < t.openStart; s++)
        i2 = i2.firstChild.content;
      for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
        for (let r = o.depth; r >= 0; r--) {
          let a = r == o.depth ? 0 : o.pos <= (o.start(r + 1) + o.end(r + 1)) / 2 ? -1 : 1, l = o.index(r) + (a > 0 ? 1 : 0), u = o.node(r), c2 = false;
          if (s == 1)
            c2 = u.canReplace(l, l, i2);
          else {
            let d = u.contentMatchAt(l).findWrapping(i2.firstChild.type);
            c2 = d && u.canReplaceWith(l, l, d[0]);
          }
          if (c2)
            return a == 0 ? o.pos : a < 0 ? o.before(r + 1) : o.after(r + 1);
        }
      return null;
    }
    function Fm(n2, e, t = e, o = G.empty) {
      if (e == t && !o.size)
        return null;
      let i2 = n2.resolve(e), s = n2.resolve(t);
      return rd(i2, s, o) ? new Mn(e, t, o) : new Hm(i2, s, o).fit();
    }
    function rd(n2, e, t) {
      return !t.openStart && !t.openEnd && n2.start() == e.start() && n2.parent.canReplace(n2.index(), e.index(), t.content);
    }
    class Hm {
      constructor(e, t, o) {
        this.$from = e, this.$to = t, this.unplaced = o, this.frontier = [], this.placed = W.empty;
        for (let i2 = 0; i2 <= e.depth; i2++) {
          let s = e.node(i2);
          this.frontier.push({
            type: s.type,
            match: s.contentMatchAt(e.indexAfter(i2))
          });
        }
        for (let i2 = e.depth; i2 > 0; i2--)
          this.placed = W.from(e.node(i2).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        for (; this.unplaced.size; ) {
          let u = this.findFittable();
          u ? this.placeNodes(u) : this.openMore() || this.dropNode();
        }
        let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, o = this.$from, i2 = this.close(e < 0 ? this.$to : o.doc.resolve(e));
        if (!i2)
          return null;
        let s = this.placed, r = o.depth, a = i2.depth;
        for (; r && a && s.childCount == 1; )
          s = s.firstChild.content, r--, a--;
        let l = new G(s, r, a);
        return e > -1 ? new yt(o.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || o.pos != this.$to.pos ? new Mn(o.pos, i2.pos, l) : null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let e = this.unplaced.openStart;
        for (let t = this.unplaced.content, o = 0, i2 = this.unplaced.openEnd; o < e; o++) {
          let s = t.firstChild;
          if (t.childCount > 1 && (i2 = 0), s.type.spec.isolating && i2 <= o) {
            e = o;
            break;
          }
          t = s.content;
        }
        for (let t = 1; t <= 2; t++)
          for (let o = t == 1 ? e : this.unplaced.openStart; o >= 0; o--) {
            let i2, s = null;
            o ? (s = Fr(this.unplaced.content, o - 1).firstChild, i2 = s.content) : i2 = this.unplaced.content;
            let r = i2.firstChild;
            for (let a = this.depth; a >= 0; a--) {
              let { type: l, match: u } = this.frontier[a], c2, d = null;
              if (t == 1 && (r ? u.matchType(r.type) || (d = u.fillBefore(W.from(r), false)) : s && l.compatibleContent(s.type)))
                return { sliceDepth: o, frontierDepth: a, parent: s, inject: d };
              if (t == 2 && r && (c2 = u.findWrapping(r.type)))
                return { sliceDepth: o, frontierDepth: a, parent: s, wrap: c2 };
              if (s && u.matchType(s.type))
                break;
            }
          }
      }
      openMore() {
        let { content: e, openStart: t, openEnd: o } = this.unplaced, i2 = Fr(e, t);
        return !i2.childCount || i2.firstChild.isLeaf ? false : (this.unplaced = new G(e, t + 1, Math.max(o, i2.size + t >= e.size - o ? t + 1 : 0)), true);
      }
      dropNode() {
        let { content: e, openStart: t, openEnd: o } = this.unplaced, i2 = Fr(e, t);
        if (i2.childCount <= 1 && t > 0) {
          let s = e.size - t <= t + i2.size;
          this.unplaced = new G(gi(e, t - 1, 1), t - 1, s ? t - 1 : o);
        } else
          this.unplaced = new G(gi(e, t, 1), t, o);
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth: e, frontierDepth: t, parent: o, inject: i2, wrap: s }) {
        for (; this.depth > t; )
          this.closeFrontierNode();
        if (s)
          for (let f = 0; f < s.length; f++)
            this.openFrontierNode(s[f]);
        let r = this.unplaced, a = o ? o.content : r.content, l = r.openStart - e, u = 0, c2 = [], { match: d, type: p2 } = this.frontier[t];
        if (i2) {
          for (let f = 0; f < i2.childCount; f++)
            c2.push(i2.child(f));
          d = d.matchFragment(i2);
        }
        let _ = a.size + e - (r.content.size - r.openEnd);
        for (; u < a.childCount; ) {
          let f = a.child(u), b = d.matchType(f.type);
          if (!b)
            break;
          u++, (u > 1 || l == 0 || f.content.size) && (d = b, c2.push(ad(f.mark(p2.allowedMarks(f.marks)), u == 1 ? l : 0, u == a.childCount ? _ : -1)));
        }
        let m = u == a.childCount;
        m || (_ = -1), this.placed = hi(this.placed, t, W.from(c2)), this.frontier[t].match = d, m && _ < 0 && o && o.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let f = 0, b = a; f < _; f++) {
          let h2 = b.lastChild;
          this.frontier.push({ type: h2.type, match: h2.contentMatchAt(h2.childCount) }), b = h2.content;
        }
        this.unplaced = m ? e == 0 ? G.empty : new G(gi(r.content, e - 1, 1), e - 1, _ < 0 ? r.openEnd : e - 1) : new G(gi(r.content, e, u), r.openStart, r.openEnd);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let e = this.frontier[this.depth], t;
        if (!e.type.isTextblock || !Hr(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
          return -1;
        let { depth: o } = this.$to, i2 = this.$to.after(o);
        for (; o > 1 && i2 == this.$to.end(--o); )
          ++i2;
        return i2;
      }
      findCloseLevel(e) {
        e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
          let { match: o, type: i2 } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), r = Hr(e, t, i2, o, s);
          if (r) {
            for (let a = t - 1; a >= 0; a--) {
              let { match: l, type: u } = this.frontier[a], c2 = Hr(e, a, u, l, true);
              if (!c2 || c2.childCount)
                continue e;
            }
            return { depth: t, fit: r, move: s ? e.doc.resolve(e.after(t + 1)) : e };
          }
        }
      }
      close(e) {
        let t = this.findCloseLevel(e);
        if (!t)
          return null;
        for (; this.depth > t.depth; )
          this.closeFrontierNode();
        t.fit.childCount && (this.placed = hi(this.placed, t.depth, t.fit)), e = t.move;
        for (let o = t.depth + 1; o <= e.depth; o++) {
          let i2 = e.node(o), s = i2.type.contentMatch.fillBefore(i2.content, true, e.index(o));
          this.openFrontierNode(i2.type, i2.attrs, s);
        }
        return e;
      }
      openFrontierNode(e, t = null, o) {
        let i2 = this.frontier[this.depth];
        i2.match = i2.match.matchType(e), this.placed = hi(this.placed, this.depth, W.from(e.create(t, o))), this.frontier.push({ type: e, match: e.contentMatch });
      }
      closeFrontierNode() {
        let t = this.frontier.pop().match.fillBefore(W.empty, true);
        t.childCount && (this.placed = hi(this.placed, this.frontier.length, t));
      }
    }
    function gi(n2, e, t) {
      return e == 0 ? n2.cutByIndex(t, n2.childCount) : n2.replaceChild(0, n2.firstChild.copy(gi(n2.firstChild.content, e - 1, t)));
    }
    function hi(n2, e, t) {
      return e == 0 ? n2.append(t) : n2.replaceChild(n2.childCount - 1, n2.lastChild.copy(hi(n2.lastChild.content, e - 1, t)));
    }
    function Fr(n2, e) {
      for (let t = 0; t < e; t++)
        n2 = n2.firstChild.content;
      return n2;
    }
    function ad(n2, e, t) {
      if (e <= 0)
        return n2;
      let o = n2.content;
      return e > 1 && (o = o.replaceChild(0, ad(o.firstChild, e - 1, o.childCount == 1 ? t - 1 : 0))), e > 0 && (o = n2.type.contentMatch.fillBefore(o).append(o), t <= 0 && (o = o.append(n2.type.contentMatch.matchFragment(o).fillBefore(W.empty, true)))), n2.copy(o);
    }
    function Hr(n2, e, t, o, i2) {
      let s = n2.node(e), r = i2 ? n2.indexAfter(e) : n2.index(e);
      if (r == s.childCount && !t.compatibleContent(s.type))
        return null;
      let a = o.fillBefore(s.content, true, r);
      return a && !Um(t, s.content, r) ? a : null;
    }
    function Um(n2, e, t) {
      for (let o = t; o < e.childCount; o++)
        if (!n2.allowsMarks(e.child(o).marks))
          return true;
      return false;
    }
    function qm(n2) {
      return n2.spec.defining || n2.spec.definingForContent;
    }
    function Km(n2, e, t, o) {
      if (!o.size)
        return n2.deleteRange(e, t);
      let i2 = n2.doc.resolve(e), s = n2.doc.resolve(t);
      if (rd(i2, s, o))
        return n2.step(new Mn(e, t, o));
      let r = ud(i2, n2.doc.resolve(t));
      r[r.length - 1] == 0 && r.pop();
      let a = -(i2.depth + 1);
      r.unshift(a);
      for (let p2 = i2.depth, _ = i2.pos - 1; p2 > 0; p2--, _--) {
        let m = i2.node(p2).type.spec;
        if (m.defining || m.definingAsContext || m.isolating)
          break;
        r.indexOf(p2) > -1 ? a = p2 : i2.before(p2) == _ && r.splice(1, 0, -p2);
      }
      let l = r.indexOf(a), u = [], c2 = o.openStart;
      for (let p2 = o.content, _ = 0; ; _++) {
        let m = p2.firstChild;
        if (u.push(m), _ == o.openStart)
          break;
        p2 = m.content;
      }
      for (let p2 = c2 - 1; p2 >= 0; p2--) {
        let _ = u[p2], m = qm(_.type);
        if (m && !_.sameMarkup(i2.node(Math.abs(a) - 1)))
          c2 = p2;
        else if (m || !_.type.isTextblock)
          break;
      }
      for (let p2 = o.openStart; p2 >= 0; p2--) {
        let _ = (p2 + c2 + 1) % (o.openStart + 1), m = u[_];
        if (m)
          for (let f = 0; f < r.length; f++) {
            let b = r[(f + l) % r.length], h2 = true;
            b < 0 && (h2 = false, b = -b);
            let y = i2.node(b - 1), C = i2.index(b - 1);
            if (y.canReplaceWith(C, C, m.type, m.marks))
              return n2.replace(i2.before(b), h2 ? s.after(b) : t, new G(ld(o.content, 0, o.openStart, _), _, o.openEnd));
          }
      }
      let d = n2.steps.length;
      for (let p2 = r.length - 1; p2 >= 0 && (n2.replace(e, t, o), !(n2.steps.length > d)); p2--) {
        let _ = r[p2];
        _ < 0 || (e = i2.before(_), t = s.after(_));
      }
    }
    function ld(n2, e, t, o, i2) {
      if (e < t) {
        let s = n2.firstChild;
        n2 = n2.replaceChild(0, s.copy(ld(s.content, e + 1, t, o, s)));
      }
      if (e > o) {
        let s = i2.contentMatchAt(0), r = s.fillBefore(n2).append(n2);
        n2 = r.append(s.matchFragment(r).fillBefore(W.empty, true));
      }
      return n2;
    }
    function Vm(n2, e, t, o) {
      if (!o.isInline && e == t && n2.doc.resolve(e).parent.content.size) {
        let i2 = zm(n2.doc, e, o.type);
        i2 != null && (e = t = i2);
      }
      n2.replaceRange(e, t, new G(W.from(o), 0, 0));
    }
    function Wm(n2, e, t) {
      let o = n2.doc.resolve(e), i2 = n2.doc.resolve(t), s = ud(o, i2);
      for (let r = 0; r < s.length; r++) {
        let a = s[r], l = r == s.length - 1;
        if (l && a == 0 || o.node(a).type.contentMatch.validEnd)
          return n2.delete(o.start(a), i2.end(a));
        if (a > 0 && (l || o.node(a - 1).canReplace(o.index(a - 1), i2.indexAfter(a - 1))))
          return n2.delete(o.before(a), i2.after(a));
      }
      for (let r = 1; r <= o.depth && r <= i2.depth; r++)
        if (e - o.start(r) == o.depth - r && t > o.end(r) && i2.end(r) - t != i2.depth - r && o.start(r - 1) == i2.start(r - 1) && o.node(r - 1).canReplace(o.index(r - 1), i2.index(r - 1)))
          return n2.delete(o.before(r), t);
      n2.delete(e, t);
    }
    function ud(n2, e) {
      let t = [], o = Math.min(n2.depth, e.depth);
      for (let i2 = o; i2 >= 0; i2--) {
        let s = n2.start(i2);
        if (s < n2.pos - (n2.depth - i2) || e.end(i2) > e.pos + (e.depth - i2) || n2.node(i2).type.spec.isolating || e.node(i2).type.spec.isolating)
          break;
        (s == e.start(i2) || i2 == n2.depth && i2 == e.depth && n2.parent.inlineContent && e.parent.inlineContent && i2 && e.start(i2 - 1) == s - 1) && t.push(i2);
      }
      return t;
    }
    class Yo extends In {
      /**
      Construct an attribute step.
      */
      constructor(e, t, o) {
        super(), this.pos = e, this.attr = t, this.value = o;
      }
      apply(e) {
        let t = e.nodeAt(this.pos);
        if (!t)
          return mn.fail("No node at attribute step's position");
        let o = /* @__PURE__ */ Object.create(null);
        for (let s in t.attrs)
          o[s] = t.attrs[s];
        o[this.attr] = this.value;
        let i2 = t.type.create(o, null, t.marks);
        return mn.fromReplace(e, this.pos, this.pos + 1, new G(W.from(i2), 0, t.isLeaf ? 0 : 1));
      }
      getMap() {
        return Xn.empty;
      }
      invert(e) {
        return new Yo(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
      }
      map(e) {
        let t = e.mapResult(this.pos, 1);
        return t.deletedAfter ? null : new Yo(t.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.pos != "number" || typeof t.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Yo(t.pos, t.attr, t.value);
      }
    }
    In.jsonID("attr", Yo);
    class Oi extends In {
      /**
      Construct an attribute step.
      */
      constructor(e, t) {
        super(), this.attr = e, this.value = t;
      }
      apply(e) {
        let t = /* @__PURE__ */ Object.create(null);
        for (let i2 in e.attrs)
          t[i2] = e.attrs[i2];
        t[this.attr] = this.value;
        let o = e.type.create(t, e.content, e.marks);
        return mn.ok(o);
      }
      getMap() {
        return Xn.empty;
      }
      invert(e) {
        return new Oi(this.attr, e.attrs[this.attr]);
      }
      map(e) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(e, t) {
        if (typeof t.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new Oi(t.attr, t.value);
      }
    }
    In.jsonID("docAttr", Oi);
    let Qo = class extends Error {
    };
    Qo = function n(e) {
      let t = Error.call(this, e);
      return t.__proto__ = n.prototype, t;
    };
    Qo.prototype = Object.create(Error.prototype);
    Qo.prototype.constructor = Qo;
    Qo.prototype.name = "TransformError";
    class Gm {
      /**
      Create a transform that starts with the given document.
      */
      constructor(e) {
        this.doc = e, this.steps = [], this.docs = [], this.mapping = new Ni();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(e) {
        let t = this.maybeStep(e);
        if (t.failed)
          throw new Qo(t.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(e) {
        let t = e.apply(this.doc);
        return t.failed || this.addStep(e, t.doc), t;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(e, t) {
        this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(e, t = e, o = G.empty) {
        let i2 = Fm(this.doc, e, t, o);
        return i2 && this.step(i2), this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(e, t, o) {
        return this.replace(e, t, new G(W.from(o), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(e, t) {
        return this.replace(e, t, G.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(e, t) {
        return this.replaceWith(e, e, t);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(e, t, o) {
        return Km(this, e, t, o), this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(e, t, o) {
        return Vm(this, e, t, o), this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(e, t) {
        return Wm(this, e, t), this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(e, t) {
        return Rm(this, e, t), this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(e, t = 1) {
        return $m(this, e, t), this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(e, t) {
        return Im(this, e, t), this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(e, t = e, o, i2 = null) {
        return Lm(this, e, t, o, i2), this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(e, t, o = null, i2) {
        return Bm(this, e, t, o, i2), this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(e, t, o) {
        return this.step(new Yo(e, t, o)), this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(e, t) {
        return this.step(new Oi(e, t)), this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(e, t) {
        return this.step(new ao(e, t)), this;
      }
      /**
      Remove a mark (or a mark of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(e, t) {
        if (!(t instanceof Fn)) {
          let o = this.doc.nodeAt(e);
          if (!o)
            throw new RangeError("No node at position " + e);
          if (t = t.isInSet(o.marks), !t)
            return this;
        }
        return this.step(new Xo(e, t)), this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(e, t = 1, o) {
        return Pm(this, e, t, o), this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(e, t, o) {
        return Om(this, e, t, o), this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(e, t, o) {
        return Mm(this, e, t, o), this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(e, t, o) {
        return Za(this, e, t, o), this;
      }
    }
    const Ur = /* @__PURE__ */ Object.create(null);
    class Te {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor(e, t, o) {
        this.$anchor = e, this.$head = t, this.ranges = o || [new cd(e.min(t), e.max(t))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let e = this.ranges;
        for (let t = 0; t < e.length; t++)
          if (e[t].$from.pos != e[t].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(e, t = G.empty) {
        let o = t.content.lastChild, i2 = null;
        for (let a = 0; a < t.openEnd; a++)
          i2 = o, o = o.lastChild;
        let s = e.steps.length, r = this.ranges;
        for (let a = 0; a < r.length; a++) {
          let { $from: l, $to: u } = r[a], c2 = e.mapping.slice(s);
          e.replaceRange(c2.map(l.pos), c2.map(u.pos), a ? G.empty : t), a == 0 && au(e, s, (o ? o.isInline : i2 && i2.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(e, t) {
        let o = e.steps.length, i2 = this.ranges;
        for (let s = 0; s < i2.length; s++) {
          let { $from: r, $to: a } = i2[s], l = e.mapping.slice(o), u = l.map(r.pos), c2 = l.map(a.pos);
          s ? e.deleteRange(u, c2) : (e.replaceRangeWith(u, c2, t), au(e, o, t.isInline ? -1 : 1));
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom(e, t, o = false) {
        let i2 = e.parent.inlineContent ? new Ce(e) : Fo(e.node(0), e.parent, e.pos, e.index(), t, o);
        if (i2)
          return i2;
        for (let s = e.depth - 1; s >= 0; s--) {
          let r = t < 0 ? Fo(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, o) : Fo(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, o);
          if (r)
            return r;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near(e, t = 1) {
        return this.findFrom(e, t) || this.findFrom(e, -t) || new Dt(e.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(e) {
        return Fo(e, e, 0, 0, 1) || new Dt(e);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(e) {
        return Fo(e, e, e.content.size, e.childCount, -1) || new Dt(e);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(e, t) {
        if (!t || !t.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let o = Ur[t.type];
        if (!o)
          throw new RangeError(`No selection type ${t.type} defined`);
        return o.fromJSON(e, t);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(e, t) {
        if (e in Ur)
          throw new RangeError("Duplicate use of selection JSON ID " + e);
        return Ur[e] = t, t.prototype.jsonID = e, t;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return Ce.between(this.$anchor, this.$head).getBookmark();
      }
    }
    Te.prototype.visible = true;
    class cd {
      /**
      Create a range.
      */
      constructor(e, t) {
        this.$from = e, this.$to = t;
      }
    }
    let su = false;
    function ru(n2) {
      !su && !n2.parent.inlineContent && (su = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n2.parent.type.name + ")"));
    }
    class Ce extends Te {
      /**
      Construct a text selection between the given points.
      */
      constructor(e, t = e) {
        ru(e), ru(t), super(e, t);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(e, t) {
        let o = e.resolve(t.map(this.head));
        if (!o.parent.inlineContent)
          return Te.near(o);
        let i2 = e.resolve(t.map(this.anchor));
        return new Ce(i2.parent.inlineContent ? i2 : o, o);
      }
      replace(e, t = G.empty) {
        if (super.replace(e, t), t == G.empty) {
          let o = this.$from.marksAcross(this.$to);
          o && e.ensureMarks(o);
        }
      }
      eq(e) {
        return e instanceof Ce && e.anchor == this.anchor && e.head == this.head;
      }
      getBookmark() {
        return new wr(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.anchor != "number" || typeof t.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new Ce(e.resolve(t.anchor), e.resolve(t.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(e, t, o = t) {
        let i2 = e.resolve(t);
        return new this(i2, o == t ? i2 : e.resolve(o));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between(e, t, o) {
        let i2 = e.pos - t.pos;
        if ((!o || i2) && (o = i2 >= 0 ? 1 : -1), !t.parent.inlineContent) {
          let s = Te.findFrom(t, o, true) || Te.findFrom(t, -o, true);
          if (s)
            t = s.$head;
          else
            return Te.near(t, o);
        }
        return e.parent.inlineContent || (i2 == 0 ? e = t : (e = (Te.findFrom(e, -o, true) || Te.findFrom(e, o, true)).$anchor, e.pos < t.pos != i2 < 0 && (e = t))), new Ce(e, t);
      }
    }
    Te.jsonID("text", Ce);
    class wr {
      constructor(e, t) {
        this.anchor = e, this.head = t;
      }
      map(e) {
        return new wr(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        return Ce.between(e.resolve(this.anchor), e.resolve(this.head));
      }
    }
    class xe extends Te {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor(e) {
        let t = e.nodeAfter, o = e.node(0).resolve(e.pos + t.nodeSize);
        super(e, o), this.node = t;
      }
      map(e, t) {
        let { deleted: o, pos: i2 } = t.mapResult(this.anchor), s = e.resolve(i2);
        return o ? Te.near(s) : new xe(s);
      }
      content() {
        return new G(W.from(this.node), 0, 0);
      }
      eq(e) {
        return e instanceof xe && e.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new Xa(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new xe(e.resolve(t.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(e, t) {
        return new xe(e.resolve(t));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== false;
      }
    }
    xe.prototype.visible = false;
    Te.jsonID("node", xe);
    class Xa {
      constructor(e) {
        this.anchor = e;
      }
      map(e) {
        let { deleted: t, pos: o } = e.mapResult(this.anchor);
        return t ? new wr(o, o) : new Xa(o);
      }
      resolve(e) {
        let t = e.resolve(this.anchor), o = t.nodeAfter;
        return o && xe.isSelectable(o) ? new xe(t) : Te.near(t);
      }
    }
    class Dt extends Te {
      /**
      Create an all-selection over the given document.
      */
      constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size));
      }
      replace(e, t = G.empty) {
        if (t == G.empty) {
          e.delete(0, e.doc.content.size);
          let o = Te.atStart(e.doc);
          o.eq(e.selection) || e.setSelection(o);
        } else
          super.replace(e, t);
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(e) {
        return new Dt(e);
      }
      map(e) {
        return new Dt(e);
      }
      eq(e) {
        return e instanceof Dt;
      }
      getBookmark() {
        return Ym;
      }
    }
    Te.jsonID("all", Dt);
    const Ym = {
      map() {
        return this;
      },
      resolve(n2) {
        return new Dt(n2);
      }
    };
    function Fo(n2, e, t, o, i2, s = false) {
      if (e.inlineContent)
        return Ce.create(n2, t);
      for (let r = o - (i2 > 0 ? 0 : 1); i2 > 0 ? r < e.childCount : r >= 0; r += i2) {
        let a = e.child(r);
        if (a.isAtom) {
          if (!s && xe.isSelectable(a))
            return xe.create(n2, t - (i2 < 0 ? a.nodeSize : 0));
        } else {
          let l = Fo(n2, a, t + i2, i2 < 0 ? a.childCount : 0, i2, s);
          if (l)
            return l;
        }
        t += a.nodeSize * i2;
      }
      return null;
    }
    function au(n2, e, t) {
      let o = n2.steps.length - 1;
      if (o < e)
        return;
      let i2 = n2.steps[o];
      if (!(i2 instanceof Mn || i2 instanceof yt))
        return;
      let s = n2.mapping.maps[o], r;
      s.forEach((a, l, u, c2) => {
        r == null && (r = c2);
      }), n2.setSelection(Te.near(n2.doc.resolve(r), t));
    }
    function lu(n2, e) {
      return !e || !n2 ? n2 : n2.bind(e);
    }
    class ss {
      constructor(e, t, o) {
        this.name = e, this.init = lu(t.init, o), this.apply = lu(t.apply, o);
      }
    }
    new ss("doc", {
      init(n2) {
        return n2.doc || n2.schema.topNodeType.createAndFill();
      },
      apply(n2) {
        return n2.doc;
      }
    }), new ss("selection", {
      init(n2, e) {
        return n2.selection || Te.atStart(e.doc);
      },
      apply(n2) {
        return n2.selection;
      }
    }), new ss("storedMarks", {
      init(n2) {
        return n2.storedMarks || null;
      },
      apply(n2, e, t, o) {
        return o.selection.$cursor ? n2.storedMarks : null;
      }
    }), new ss("scrollToSelection", {
      init() {
        return 0;
      },
      apply(n2, e) {
        return n2.scrolledIntoView ? e + 1 : e;
      }
    });
    function dd(n2, e, t) {
      for (let o in n2) {
        let i2 = n2[o];
        i2 instanceof Function ? i2 = i2.bind(e) : o == "handleDOMEvents" && (i2 = dd(i2, e, {})), t[o] = i2;
      }
      return t;
    }
    class dn {
      /**
      Create a plugin.
      */
      constructor(e) {
        this.spec = e, this.props = {}, e.props && dd(e.props, this, this.props), this.key = e.key ? e.key.key : pd("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    const qr = /* @__PURE__ */ Object.create(null);
    function pd(n2) {
      return n2 in qr ? n2 + "$" + ++qr[n2] : (qr[n2] = 0, n2 + "$");
    }
    class en {
      /**
      Create a plugin key.
      */
      constructor(e = "key") {
        this.key = pd(e);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(e) {
        return e.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(e) {
        return e[this.key];
      }
    }
    var Kn = "top", ct = "bottom", dt = "right", Vn = "left", Qa = "auto", Wi = [Kn, ct, dt, Vn], ei = "start", Mi = "end", Jm = "clippingParents", _d = "viewport", pi = "popper", Zm = "reference", uu = /* @__PURE__ */ Wi.reduce(function(n2, e) {
      return n2.concat([e + "-" + ei, e + "-" + Mi]);
    }, []), md = /* @__PURE__ */ [].concat(Wi, [Qa]).reduce(function(n2, e) {
      return n2.concat([e, e + "-" + ei, e + "-" + Mi]);
    }, []), Xm = "beforeRead", Qm = "read", ef = "afterRead", nf = "beforeMain", tf = "main", of = "afterMain", sf = "beforeWrite", rf = "write", af = "afterWrite", lf = [Xm, Qm, ef, nf, tf, of, sf, rf, af];
    function Pt(n2) {
      return n2 ? (n2.nodeName || "").toLowerCase() : null;
    }
    function nt(n2) {
      if (n2 == null)
        return window;
      if (n2.toString() !== "[object Window]") {
        var e = n2.ownerDocument;
        return e && e.defaultView || window;
      }
      return n2;
    }
    function Mo(n2) {
      var e = nt(n2).Element;
      return n2 instanceof e || n2 instanceof Element;
    }
    function ut(n2) {
      var e = nt(n2).HTMLElement;
      return n2 instanceof e || n2 instanceof HTMLElement;
    }
    function el(n2) {
      if (typeof ShadowRoot > "u")
        return false;
      var e = nt(n2).ShadowRoot;
      return n2 instanceof e || n2 instanceof ShadowRoot;
    }
    function uf(n2) {
      var e = n2.state;
      Object.keys(e.elements).forEach(function(t) {
        var o = e.styles[t] || {}, i2 = e.attributes[t] || {}, s = e.elements[t];
        !ut(s) || !Pt(s) || (Object.assign(s.style, o), Object.keys(i2).forEach(function(r) {
          var a = i2[r];
          a === false ? s.removeAttribute(r) : s.setAttribute(r, a === true ? "" : a);
        }));
      });
    }
    function cf(n2) {
      var e = n2.state, t = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
        Object.keys(e.elements).forEach(function(o) {
          var i2 = e.elements[o], s = e.attributes[o] || {}, r = Object.keys(e.styles.hasOwnProperty(o) ? e.styles[o] : t[o]), a = r.reduce(function(l, u) {
            return l[u] = "", l;
          }, {});
          !ut(i2) || !Pt(i2) || (Object.assign(i2.style, a), Object.keys(s).forEach(function(l) {
            i2.removeAttribute(l);
          }));
        });
      };
    }
    const fd = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: uf,
      effect: cf,
      requires: ["computeStyles"]
    };
    function Bt(n2) {
      return n2.split("-")[0];
    }
    var Co = Math.max, Is = Math.min, ni = Math.round;
    function ya() {
      var n2 = navigator.userAgentData;
      return n2 != null && n2.brands && Array.isArray(n2.brands) ? n2.brands.map(function(e) {
        return e.brand + "/" + e.version;
      }).join(" ") : navigator.userAgent;
    }
    function gd() {
      return !/^((?!chrome|android).)*safari/i.test(ya());
    }
    function ti(n2, e, t) {
      e === void 0 && (e = false), t === void 0 && (t = false);
      var o = n2.getBoundingClientRect(), i2 = 1, s = 1;
      e && ut(n2) && (i2 = n2.offsetWidth > 0 && ni(o.width) / n2.offsetWidth || 1, s = n2.offsetHeight > 0 && ni(o.height) / n2.offsetHeight || 1);
      var r = Mo(n2) ? nt(n2) : window, a = r.visualViewport, l = !gd() && t, u = (o.left + (l && a ? a.offsetLeft : 0)) / i2, c2 = (o.top + (l && a ? a.offsetTop : 0)) / s, d = o.width / i2, p2 = o.height / s;
      return {
        width: d,
        height: p2,
        top: c2,
        right: u + d,
        bottom: c2 + p2,
        left: u,
        x: u,
        y: c2
      };
    }
    function nl(n2) {
      var e = ti(n2), t = n2.offsetWidth, o = n2.offsetHeight;
      return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), {
        x: n2.offsetLeft,
        y: n2.offsetTop,
        width: t,
        height: o
      };
    }
    function hd(n2, e) {
      var t = e.getRootNode && e.getRootNode();
      if (n2.contains(e))
        return true;
      if (t && el(t)) {
        var o = e;
        do {
          if (o && n2.isSameNode(o))
            return true;
          o = o.parentNode || o.host;
        } while (o);
      }
      return false;
    }
    function Gt(n2) {
      return nt(n2).getComputedStyle(n2);
    }
    function df(n2) {
      return ["table", "td", "th"].indexOf(Pt(n2)) >= 0;
    }
    function go(n2) {
      return ((Mo(n2) ? n2.ownerDocument : (
        // $FlowFixMe[prop-missing]
        n2.document
      )) || window.document).documentElement;
    }
    function Er(n2) {
      return Pt(n2) === "html" ? n2 : (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        n2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        n2.parentNode || // DOM Element detected
        (el(n2) ? n2.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        go(n2)
      );
    }
    function cu(n2) {
      return !ut(n2) || // https://github.com/popperjs/popper-core/issues/837
      Gt(n2).position === "fixed" ? null : n2.offsetParent;
    }
    function pf(n2) {
      var e = /firefox/i.test(ya()), t = /Trident/i.test(ya());
      if (t && ut(n2)) {
        var o = Gt(n2);
        if (o.position === "fixed")
          return null;
      }
      var i2 = Er(n2);
      for (el(i2) && (i2 = i2.host); ut(i2) && ["html", "body"].indexOf(Pt(i2)) < 0; ) {
        var s = Gt(i2);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
          return i2;
        i2 = i2.parentNode;
      }
      return null;
    }
    function Gi(n2) {
      for (var e = nt(n2), t = cu(n2); t && df(t) && Gt(t).position === "static"; )
        t = cu(t);
      return t && (Pt(t) === "html" || Pt(t) === "body" && Gt(t).position === "static") ? e : t || pf(n2) || e;
    }
    function tl(n2) {
      return ["top", "bottom"].indexOf(n2) >= 0 ? "x" : "y";
    }
    function bi(n2, e, t) {
      return Co(n2, Is(e, t));
    }
    function _f(n2, e, t) {
      var o = bi(n2, e, t);
      return o > t ? t : o;
    }
    function vd() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function bd(n2) {
      return Object.assign({}, vd(), n2);
    }
    function kd(n2, e) {
      return e.reduce(function(t, o) {
        return t[o] = n2, t;
      }, {});
    }
    var mf = function(e, t) {
      return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
        placement: t.placement
      })) : e, bd(typeof e != "number" ? e : kd(e, Wi));
    };
    function ff(n2) {
      var e, t = n2.state, o = n2.name, i2 = n2.options, s = t.elements.arrow, r = t.modifiersData.popperOffsets, a = Bt(t.placement), l = tl(a), u = [Vn, dt].indexOf(a) >= 0, c2 = u ? "height" : "width";
      if (!(!s || !r)) {
        var d = mf(i2.padding, t), p2 = nl(s), _ = l === "y" ? Kn : Vn, m = l === "y" ? ct : dt, f = t.rects.reference[c2] + t.rects.reference[l] - r[l] - t.rects.popper[c2], b = r[l] - t.rects.reference[l], h2 = Gi(s), y = h2 ? l === "y" ? h2.clientHeight || 0 : h2.clientWidth || 0 : 0, C = f / 2 - b / 2, v = d[_], x = y - p2[c2] - d[m], S = y / 2 - p2[c2] / 2 + C, F = bi(v, S, x), Y = l;
        t.modifiersData[o] = (e = {}, e[Y] = F, e.centerOffset = F - S, e);
      }
    }
    function gf(n2) {
      var e = n2.state, t = n2.options, o = t.element, i2 = o === void 0 ? "[data-popper-arrow]" : o;
      i2 != null && (typeof i2 == "string" && (i2 = e.elements.popper.querySelector(i2), !i2) || hd(e.elements.popper, i2) && (e.elements.arrow = i2));
    }
    const hf = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: ff,
      effect: gf,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function oi(n2) {
      return n2.split("-")[1];
    }
    var vf = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function bf(n2, e) {
      var t = n2.x, o = n2.y, i2 = e.devicePixelRatio || 1;
      return {
        x: ni(t * i2) / i2 || 0,
        y: ni(o * i2) / i2 || 0
      };
    }
    function du(n2) {
      var e, t = n2.popper, o = n2.popperRect, i2 = n2.placement, s = n2.variation, r = n2.offsets, a = n2.position, l = n2.gpuAcceleration, u = n2.adaptive, c2 = n2.roundOffsets, d = n2.isFixed, p2 = r.x, _ = p2 === void 0 ? 0 : p2, m = r.y, f = m === void 0 ? 0 : m, b = typeof c2 == "function" ? c2({
        x: _,
        y: f
      }) : {
        x: _,
        y: f
      };
      _ = b.x, f = b.y;
      var h2 = r.hasOwnProperty("x"), y = r.hasOwnProperty("y"), C = Vn, v = Kn, x = window;
      if (u) {
        var S = Gi(t), F = "clientHeight", Y = "clientWidth";
        if (S === nt(t) && (S = go(t), Gt(S).position !== "static" && a === "absolute" && (F = "scrollHeight", Y = "scrollWidth")), S = S, i2 === Kn || (i2 === Vn || i2 === dt) && s === Mi) {
          v = ct;
          var q = d && S === x && x.visualViewport ? x.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            S[F]
          );
          f -= q - o.height, f *= l ? 1 : -1;
        }
        if (i2 === Vn || (i2 === Kn || i2 === ct) && s === Mi) {
          C = dt;
          var K = d && S === x && x.visualViewport ? x.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            S[Y]
          );
          _ -= K - o.width, _ *= l ? 1 : -1;
        }
      }
      var ie2 = Object.assign({
        position: a
      }, u && vf), ce = c2 === true ? bf({
        x: _,
        y: f
      }, nt(t)) : {
        x: _,
        y: f
      };
      if (_ = ce.x, f = ce.y, l) {
        var ve;
        return Object.assign({}, ie2, (ve = {}, ve[v] = y ? "0" : "", ve[C] = h2 ? "0" : "", ve.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + _ + "px, " + f + "px)" : "translate3d(" + _ + "px, " + f + "px, 0)", ve));
      }
      return Object.assign({}, ie2, (e = {}, e[v] = y ? f + "px" : "", e[C] = h2 ? _ + "px" : "", e.transform = "", e));
    }
    function kf(n2) {
      var e = n2.state, t = n2.options, o = t.gpuAcceleration, i2 = o === void 0 ? true : o, s = t.adaptive, r = s === void 0 ? true : s, a = t.roundOffsets, l = a === void 0 ? true : a, u = {
        placement: Bt(e.placement),
        variation: oi(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: i2,
        isFixed: e.options.strategy === "fixed"
      };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, du(Object.assign({}, u, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: r,
        roundOffsets: l
      })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, du(Object.assign({}, u, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    }
    const yf = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: kf,
      data: {}
    };
    var rs = {
      passive: true
    };
    function jf(n2) {
      var e = n2.state, t = n2.instance, o = n2.options, i2 = o.scroll, s = i2 === void 0 ? true : i2, r = o.resize, a = r === void 0 ? true : r, l = nt(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return s && u.forEach(function(c2) {
        c2.addEventListener("scroll", t.update, rs);
      }), a && l.addEventListener("resize", t.update, rs), function() {
        s && u.forEach(function(c2) {
          c2.removeEventListener("scroll", t.update, rs);
        }), a && l.removeEventListener("resize", t.update, rs);
      };
    }
    const wf = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function() {
      },
      effect: jf,
      data: {}
    };
    var Ef = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function xs(n2) {
      return n2.replace(/left|right|bottom|top/g, function(e) {
        return Ef[e];
      });
    }
    var Cf = {
      start: "end",
      end: "start"
    };
    function pu(n2) {
      return n2.replace(/start|end/g, function(e) {
        return Cf[e];
      });
    }
    function ol(n2) {
      var e = nt(n2), t = e.pageXOffset, o = e.pageYOffset;
      return {
        scrollLeft: t,
        scrollTop: o
      };
    }
    function il(n2) {
      return ti(go(n2)).left + ol(n2).scrollLeft;
    }
    function Sf(n2, e) {
      var t = nt(n2), o = go(n2), i2 = t.visualViewport, s = o.clientWidth, r = o.clientHeight, a = 0, l = 0;
      if (i2) {
        s = i2.width, r = i2.height;
        var u = gd();
        (u || !u && e === "fixed") && (a = i2.offsetLeft, l = i2.offsetTop);
      }
      return {
        width: s,
        height: r,
        x: a + il(n2),
        y: l
      };
    }
    function xf(n2) {
      var e, t = go(n2), o = ol(n2), i2 = (e = n2.ownerDocument) == null ? void 0 : e.body, s = Co(t.scrollWidth, t.clientWidth, i2 ? i2.scrollWidth : 0, i2 ? i2.clientWidth : 0), r = Co(t.scrollHeight, t.clientHeight, i2 ? i2.scrollHeight : 0, i2 ? i2.clientHeight : 0), a = -o.scrollLeft + il(n2), l = -o.scrollTop;
      return Gt(i2 || t).direction === "rtl" && (a += Co(t.clientWidth, i2 ? i2.clientWidth : 0) - s), {
        width: s,
        height: r,
        x: a,
        y: l
      };
    }
    function sl(n2) {
      var e = Gt(n2), t = e.overflow, o = e.overflowX, i2 = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(t + i2 + o);
    }
    function yd(n2) {
      return ["html", "body", "#document"].indexOf(Pt(n2)) >= 0 ? n2.ownerDocument.body : ut(n2) && sl(n2) ? n2 : yd(Er(n2));
    }
    function ki(n2, e) {
      var t;
      e === void 0 && (e = []);
      var o = yd(n2), i2 = o === ((t = n2.ownerDocument) == null ? void 0 : t.body), s = nt(o), r = i2 ? [s].concat(s.visualViewport || [], sl(o) ? o : []) : o, a = e.concat(r);
      return i2 ? a : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        a.concat(ki(Er(r)))
      );
    }
    function ja(n2) {
      return Object.assign({}, n2, {
        left: n2.x,
        top: n2.y,
        right: n2.x + n2.width,
        bottom: n2.y + n2.height
      });
    }
    function Tf(n2, e) {
      var t = ti(n2, false, e === "fixed");
      return t.top = t.top + n2.clientTop, t.left = t.left + n2.clientLeft, t.bottom = t.top + n2.clientHeight, t.right = t.left + n2.clientWidth, t.width = n2.clientWidth, t.height = n2.clientHeight, t.x = t.left, t.y = t.top, t;
    }
    function _u(n2, e, t) {
      return e === _d ? ja(Sf(n2, t)) : Mo(e) ? Tf(e, t) : ja(xf(go(n2)));
    }
    function Af(n2) {
      var e = ki(Er(n2)), t = ["absolute", "fixed"].indexOf(Gt(n2).position) >= 0, o = t && ut(n2) ? Gi(n2) : n2;
      return Mo(o) ? e.filter(function(i2) {
        return Mo(i2) && hd(i2, o) && Pt(i2) !== "body";
      }) : [];
    }
    function Nf(n2, e, t, o) {
      var i2 = e === "clippingParents" ? Af(n2) : [].concat(e), s = [].concat(i2, [t]), r = s[0], a = s.reduce(function(l, u) {
        var c2 = _u(n2, u, o);
        return l.top = Co(c2.top, l.top), l.right = Is(c2.right, l.right), l.bottom = Is(c2.bottom, l.bottom), l.left = Co(c2.left, l.left), l;
      }, _u(n2, r, o));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function jd(n2) {
      var e = n2.reference, t = n2.element, o = n2.placement, i2 = o ? Bt(o) : null, s = o ? oi(o) : null, r = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
      switch (i2) {
        case Kn:
          l = {
            x: r,
            y: e.y - t.height
          };
          break;
        case ct:
          l = {
            x: r,
            y: e.y + e.height
          };
          break;
        case dt:
          l = {
            x: e.x + e.width,
            y: a
          };
          break;
        case Vn:
          l = {
            x: e.x - t.width,
            y: a
          };
          break;
        default:
          l = {
            x: e.x,
            y: e.y
          };
      }
      var u = i2 ? tl(i2) : null;
      if (u != null) {
        var c2 = u === "y" ? "height" : "width";
        switch (s) {
          case ei:
            l[u] = l[u] - (e[c2] / 2 - t[c2] / 2);
            break;
          case Mi:
            l[u] = l[u] + (e[c2] / 2 - t[c2] / 2);
            break;
        }
      }
      return l;
    }
    function Ri(n2, e) {
      e === void 0 && (e = {});
      var t = e, o = t.placement, i2 = o === void 0 ? n2.placement : o, s = t.strategy, r = s === void 0 ? n2.strategy : s, a = t.boundary, l = a === void 0 ? Jm : a, u = t.rootBoundary, c2 = u === void 0 ? _d : u, d = t.elementContext, p2 = d === void 0 ? pi : d, _ = t.altBoundary, m = _ === void 0 ? false : _, f = t.padding, b = f === void 0 ? 0 : f, h2 = bd(typeof b != "number" ? b : kd(b, Wi)), y = p2 === pi ? Zm : pi, C = n2.rects.popper, v = n2.elements[m ? y : p2], x = Nf(Mo(v) ? v : v.contextElement || go(n2.elements.popper), l, c2, r), S = ti(n2.elements.reference), F = jd({
        reference: S,
        element: C,
        placement: i2
      }), Y = ja(Object.assign({}, C, F)), q = p2 === pi ? Y : S, K = {
        top: x.top - q.top + h2.top,
        bottom: q.bottom - x.bottom + h2.bottom,
        left: x.left - q.left + h2.left,
        right: q.right - x.right + h2.right
      }, ie2 = n2.modifiersData.offset;
      if (p2 === pi && ie2) {
        var ce = ie2[i2];
        Object.keys(K).forEach(function(ve) {
          var he = [dt, ct].indexOf(ve) >= 0 ? 1 : -1, de = [Kn, ct].indexOf(ve) >= 0 ? "y" : "x";
          K[ve] += ce[de] * he;
        });
      }
      return K;
    }
    function Of(n2, e) {
      e === void 0 && (e = {});
      var t = e, o = t.placement, i2 = t.boundary, s = t.rootBoundary, r = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? md : l, c2 = oi(o), d = c2 ? a ? uu : uu.filter(function(m) {
        return oi(m) === c2;
      }) : Wi, p2 = d.filter(function(m) {
        return u.indexOf(m) >= 0;
      });
      p2.length === 0 && (p2 = d);
      var _ = p2.reduce(function(m, f) {
        return m[f] = Ri(n2, {
          placement: f,
          boundary: i2,
          rootBoundary: s,
          padding: r
        })[Bt(f)], m;
      }, {});
      return Object.keys(_).sort(function(m, f) {
        return _[m] - _[f];
      });
    }
    function Mf(n2) {
      if (Bt(n2) === Qa)
        return [];
      var e = xs(n2);
      return [pu(n2), e, pu(e)];
    }
    function Rf(n2) {
      var e = n2.state, t = n2.options, o = n2.name;
      if (!e.modifiersData[o]._skip) {
        for (var i2 = t.mainAxis, s = i2 === void 0 ? true : i2, r = t.altAxis, a = r === void 0 ? true : r, l = t.fallbackPlacements, u = t.padding, c2 = t.boundary, d = t.rootBoundary, p2 = t.altBoundary, _ = t.flipVariations, m = _ === void 0 ? true : _, f = t.allowedAutoPlacements, b = e.options.placement, h2 = Bt(b), y = h2 === b, C = l || (y || !m ? [xs(b)] : Mf(b)), v = [b].concat(C).reduce(function(vn, $e) {
          return vn.concat(Bt($e) === Qa ? Of(e, {
            placement: $e,
            boundary: c2,
            rootBoundary: d,
            padding: u,
            flipVariations: m,
            allowedAutoPlacements: f
          }) : $e);
        }, []), x = e.rects.reference, S = e.rects.popper, F = /* @__PURE__ */ new Map(), Y = true, q = v[0], K = 0; K < v.length; K++) {
          var ie2 = v[K], ce = Bt(ie2), ve = oi(ie2) === ei, he = [Kn, ct].indexOf(ce) >= 0, de = he ? "width" : "height", pe = Ri(e, {
            placement: ie2,
            boundary: c2,
            rootBoundary: d,
            altBoundary: p2,
            padding: u
          }), N = he ? ve ? dt : Vn : ve ? ct : Kn;
          x[de] > S[de] && (N = xs(N));
          var L = xs(N), V = [];
          if (s && V.push(pe[ce] <= 0), a && V.push(pe[N] <= 0, pe[L] <= 0), V.every(function(vn) {
            return vn;
          })) {
            q = ie2, Y = false;
            break;
          }
          F.set(ie2, V);
        }
        if (Y)
          for (var te = m ? 3 : 1, ae = function($e) {
            var Ge = v.find(function(Gn) {
              var Cn = F.get(Gn);
              if (Cn)
                return Cn.slice(0, $e).every(function(ot) {
                  return ot;
                });
            });
            if (Ge)
              return q = Ge, "break";
          }, ye = te; ye > 0; ye--) {
            var Pe = ae(ye);
            if (Pe === "break") break;
          }
        e.placement !== q && (e.modifiersData[o]._skip = true, e.placement = q, e.reset = true);
      }
    }
    const If = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: Rf,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function mu(n2, e, t) {
      return t === void 0 && (t = {
        x: 0,
        y: 0
      }), {
        top: n2.top - e.height - t.y,
        right: n2.right - e.width + t.x,
        bottom: n2.bottom - e.height + t.y,
        left: n2.left - e.width - t.x
      };
    }
    function fu(n2) {
      return [Kn, dt, ct, Vn].some(function(e) {
        return n2[e] >= 0;
      });
    }
    function Lf(n2) {
      var e = n2.state, t = n2.name, o = e.rects.reference, i2 = e.rects.popper, s = e.modifiersData.preventOverflow, r = Ri(e, {
        elementContext: "reference"
      }), a = Ri(e, {
        altBoundary: true
      }), l = mu(r, o), u = mu(a, i2, s), c2 = fu(l), d = fu(u);
      e.modifiersData[t] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: u,
        isReferenceHidden: c2,
        hasPopperEscaped: d
      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": c2,
        "data-popper-escaped": d
      });
    }
    const Df = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: Lf
    };
    function Bf(n2, e, t) {
      var o = Bt(n2), i2 = [Vn, Kn].indexOf(o) >= 0 ? -1 : 1, s = typeof t == "function" ? t(Object.assign({}, e, {
        placement: n2
      })) : t, r = s[0], a = s[1];
      return r = r || 0, a = (a || 0) * i2, [Vn, dt].indexOf(o) >= 0 ? {
        x: a,
        y: r
      } : {
        x: r,
        y: a
      };
    }
    function Pf(n2) {
      var e = n2.state, t = n2.options, o = n2.name, i2 = t.offset, s = i2 === void 0 ? [0, 0] : i2, r = md.reduce(function(c2, d) {
        return c2[d] = Bf(d, e.rects, s), c2;
      }, {}), a = r[e.placement], l = a.x, u = a.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[o] = r;
    }
    const $f = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: Pf
    };
    function zf(n2) {
      var e = n2.state, t = n2.name;
      e.modifiersData[t] = jd({
        reference: e.rects.reference,
        element: e.rects.popper,
        placement: e.placement
      });
    }
    const Ff = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: zf,
      data: {}
    };
    function Hf(n2) {
      return n2 === "x" ? "y" : "x";
    }
    function Uf(n2) {
      var e = n2.state, t = n2.options, o = n2.name, i2 = t.mainAxis, s = i2 === void 0 ? true : i2, r = t.altAxis, a = r === void 0 ? false : r, l = t.boundary, u = t.rootBoundary, c2 = t.altBoundary, d = t.padding, p2 = t.tether, _ = p2 === void 0 ? true : p2, m = t.tetherOffset, f = m === void 0 ? 0 : m, b = Ri(e, {
        boundary: l,
        rootBoundary: u,
        padding: d,
        altBoundary: c2
      }), h2 = Bt(e.placement), y = oi(e.placement), C = !y, v = tl(h2), x = Hf(v), S = e.modifiersData.popperOffsets, F = e.rects.reference, Y = e.rects.popper, q = typeof f == "function" ? f(Object.assign({}, e.rects, {
        placement: e.placement
      })) : f, K = typeof q == "number" ? {
        mainAxis: q,
        altAxis: q
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, q), ie2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, ce = {
        x: 0,
        y: 0
      };
      if (S) {
        if (s) {
          var ve, he = v === "y" ? Kn : Vn, de = v === "y" ? ct : dt, pe = v === "y" ? "height" : "width", N = S[v], L = N + b[he], V = N - b[de], te = _ ? -Y[pe] / 2 : 0, ae = y === ei ? F[pe] : Y[pe], ye = y === ei ? -Y[pe] : -F[pe], Pe = e.elements.arrow, vn = _ && Pe ? nl(Pe) : {
            width: 0,
            height: 0
          }, $e = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : vd(), Ge = $e[he], Gn = $e[de], Cn = bi(0, F[pe], vn[pe]), ot = C ? F[pe] / 2 - te - Cn - Ge - K.mainAxis : ae - Cn - Ge - K.mainAxis, Sn = C ? -F[pe] / 2 + te + Cn + Gn + K.mainAxis : ye + Cn + Gn + K.mainAxis, it = e.elements.arrow && Gi(e.elements.arrow), xt = it ? v === "y" ? it.clientTop || 0 : it.clientLeft || 0 : 0, ft = (ve = ie2 == null ? void 0 : ie2[v]) != null ? ve : 0, Yn = N + ot - ft - xt, gt = N + Sn - ft, ge = bi(_ ? Is(L, Yn) : L, N, _ ? Co(V, gt) : V);
          S[v] = ge, ce[v] = ge - N;
        }
        if (a) {
          var Hn, Nn = v === "x" ? Kn : Vn, se = v === "x" ? ct : dt, Ln = S[x], Ue = x === "y" ? "height" : "width", Me = Ln + b[Nn], Dn = Ln - b[se], un = [Kn, Vn].indexOf(h2) !== -1, ht = (Hn = ie2 == null ? void 0 : ie2[x]) != null ? Hn : 0, Bn = un ? Me : Ln - F[Ue] - Y[Ue] - ht + K.altAxis, P = un ? Ln + F[Ue] + Y[Ue] - ht - K.altAxis : Dn, J = _ && un ? _f(Bn, Ln, P) : bi(_ ? Bn : Me, Ln, _ ? P : Dn);
          S[x] = J, ce[x] = J - Ln;
        }
        e.modifiersData[o] = ce;
      }
    }
    const qf = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: Uf,
      requiresIfExists: ["offset"]
    };
    function Kf(n2) {
      return {
        scrollLeft: n2.scrollLeft,
        scrollTop: n2.scrollTop
      };
    }
    function Vf(n2) {
      return n2 === nt(n2) || !ut(n2) ? ol(n2) : Kf(n2);
    }
    function Wf(n2) {
      var e = n2.getBoundingClientRect(), t = ni(e.width) / n2.offsetWidth || 1, o = ni(e.height) / n2.offsetHeight || 1;
      return t !== 1 || o !== 1;
    }
    function Gf(n2, e, t) {
      t === void 0 && (t = false);
      var o = ut(e), i2 = ut(e) && Wf(e), s = go(e), r = ti(n2, i2, t), a = {
        scrollLeft: 0,
        scrollTop: 0
      }, l = {
        x: 0,
        y: 0
      };
      return (o || !o && !t) && ((Pt(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      sl(s)) && (a = Vf(e)), ut(e) ? (l = ti(e, true), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = il(s))), {
        x: r.left + a.scrollLeft - l.x,
        y: r.top + a.scrollTop - l.y,
        width: r.width,
        height: r.height
      };
    }
    function Yf(n2) {
      var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), o = [];
      n2.forEach(function(s) {
        e.set(s.name, s);
      });
      function i2(s) {
        t.add(s.name);
        var r = [].concat(s.requires || [], s.requiresIfExists || []);
        r.forEach(function(a) {
          if (!t.has(a)) {
            var l = e.get(a);
            l && i2(l);
          }
        }), o.push(s);
      }
      return n2.forEach(function(s) {
        t.has(s.name) || i2(s);
      }), o;
    }
    function Jf(n2) {
      var e = Yf(n2);
      return lf.reduce(function(t, o) {
        return t.concat(e.filter(function(i2) {
          return i2.phase === o;
        }));
      }, []);
    }
    function Zf(n2) {
      var e;
      return function() {
        return e || (e = new Promise(function(t) {
          Promise.resolve().then(function() {
            e = void 0, t(n2());
          });
        })), e;
      };
    }
    function Xf(n2) {
      var e = n2.reduce(function(t, o) {
        var i2 = t[o.name];
        return t[o.name] = i2 ? Object.assign({}, i2, o, {
          options: Object.assign({}, i2.options, o.options),
          data: Object.assign({}, i2.data, o.data)
        }) : o, t;
      }, {});
      return Object.keys(e).map(function(t) {
        return e[t];
      });
    }
    var gu = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function hu() {
      for (var n2 = arguments.length, e = new Array(n2), t = 0; t < n2; t++)
        e[t] = arguments[t];
      return !e.some(function(o) {
        return !(o && typeof o.getBoundingClientRect == "function");
      });
    }
    function Qf(n2) {
      n2 === void 0 && (n2 = {});
      var e = n2, t = e.defaultModifiers, o = t === void 0 ? [] : t, i2 = e.defaultOptions, s = i2 === void 0 ? gu : i2;
      return function(a, l, u) {
        u === void 0 && (u = s);
        var c2 = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, gu, s),
          modifiersData: {},
          elements: {
            reference: a,
            popper: l
          },
          attributes: {},
          styles: {}
        }, d = [], p2 = false, _ = {
          state: c2,
          setOptions: function(h2) {
            var y = typeof h2 == "function" ? h2(c2.options) : h2;
            f(), c2.options = Object.assign({}, s, c2.options, y), c2.scrollParents = {
              reference: Mo(a) ? ki(a) : a.contextElement ? ki(a.contextElement) : [],
              popper: ki(l)
            };
            var C = Jf(Xf([].concat(o, c2.options.modifiers)));
            return c2.orderedModifiers = C.filter(function(v) {
              return v.enabled;
            }), m(), _.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function() {
            if (!p2) {
              var h2 = c2.elements, y = h2.reference, C = h2.popper;
              if (hu(y, C)) {
                c2.rects = {
                  reference: Gf(y, Gi(C), c2.options.strategy === "fixed"),
                  popper: nl(C)
                }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(K) {
                  return c2.modifiersData[K.name] = Object.assign({}, K.data);
                });
                for (var v = 0; v < c2.orderedModifiers.length; v++) {
                  if (c2.reset === true) {
                    c2.reset = false, v = -1;
                    continue;
                  }
                  var x = c2.orderedModifiers[v], S = x.fn, F = x.options, Y = F === void 0 ? {} : F, q = x.name;
                  typeof S == "function" && (c2 = S({
                    state: c2,
                    options: Y,
                    name: q,
                    instance: _
                  }) || c2);
                }
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: Zf(function() {
            return new Promise(function(b) {
              _.forceUpdate(), b(c2);
            });
          }),
          destroy: function() {
            f(), p2 = true;
          }
        };
        if (!hu(a, l))
          return _;
        _.setOptions(u).then(function(b) {
          !p2 && u.onFirstUpdate && u.onFirstUpdate(b);
        });
        function m() {
          c2.orderedModifiers.forEach(function(b) {
            var h2 = b.name, y = b.options, C = y === void 0 ? {} : y, v = b.effect;
            if (typeof v == "function") {
              var x = v({
                state: c2,
                name: h2,
                instance: _,
                options: C
              }), S = function() {
              };
              d.push(x || S);
            }
          });
        }
        function f() {
          d.forEach(function(b) {
            return b();
          }), d = [];
        }
        return _;
      };
    }
    var eg = [wf, Ff, yf, fd, $f, If, qf, hf, Df], ng = /* @__PURE__ */ Qf({
      defaultModifiers: eg
    }), tg = "tippy-box", wd = "tippy-content", og = "tippy-backdrop", Ed = "tippy-arrow", Cd = "tippy-svg-arrow", jo = {
      passive: true,
      capture: true
    }, Sd = function() {
      return document.body;
    };
    function Kr(n2, e, t) {
      if (Array.isArray(n2)) {
        var o = n2[e];
        return o ?? (Array.isArray(t) ? t[e] : t);
      }
      return n2;
    }
    function rl(n2, e) {
      var t = {}.toString.call(n2);
      return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1;
    }
    function xd(n2, e) {
      return typeof n2 == "function" ? n2.apply(void 0, e) : n2;
    }
    function vu(n2, e) {
      if (e === 0)
        return n2;
      var t;
      return function(o) {
        clearTimeout(t), t = setTimeout(function() {
          n2(o);
        }, e);
      };
    }
    function rg(n2) {
      return n2.split(/\s+/).filter(Boolean);
    }
    function Ho(n2) {
      return [].concat(n2);
    }
    function bu(n2, e) {
      n2.indexOf(e) === -1 && n2.push(e);
    }
    function ag(n2) {
      return n2.filter(function(e, t) {
        return n2.indexOf(e) === t;
      });
    }
    function lg(n2) {
      return n2.split("-")[0];
    }
    function Ls(n2) {
      return [].slice.call(n2);
    }
    function ku(n2) {
      return Object.keys(n2).reduce(function(e, t) {
        return n2[t] !== void 0 && (e[t] = n2[t]), e;
      }, {});
    }
    function yi() {
      return document.createElement("div");
    }
    function Ii(n2) {
      return ["Element", "Fragment"].some(function(e) {
        return rl(n2, e);
      });
    }
    function ug(n2) {
      return rl(n2, "NodeList");
    }
    function cg(n2) {
      return rl(n2, "MouseEvent");
    }
    function dg(n2) {
      return !!(n2 && n2._tippy && n2._tippy.reference === n2);
    }
    function pg(n2) {
      return Ii(n2) ? [n2] : ug(n2) ? Ls(n2) : Array.isArray(n2) ? n2 : Ls(document.querySelectorAll(n2));
    }
    function Vr(n2, e) {
      n2.forEach(function(t) {
        t && (t.style.transitionDuration = e + "ms");
      });
    }
    function yu(n2, e) {
      n2.forEach(function(t) {
        t && t.setAttribute("data-state", e);
      });
    }
    function _g(n2) {
      var e, t = Ho(n2), o = t[0];
      return o != null && (e = o.ownerDocument) != null && e.body ? o.ownerDocument : document;
    }
    function mg(n2, e) {
      var t = e.clientX, o = e.clientY;
      return n2.every(function(i2) {
        var s = i2.popperRect, r = i2.popperState, a = i2.props, l = a.interactiveBorder, u = lg(r.placement), c2 = r.modifiersData.offset;
        if (!c2)
          return true;
        var d = u === "bottom" ? c2.top.y : 0, p2 = u === "top" ? c2.bottom.y : 0, _ = u === "right" ? c2.left.x : 0, m = u === "left" ? c2.right.x : 0, f = s.top - o + d > l, b = o - s.bottom - p2 > l, h2 = s.left - t + _ > l, y = t - s.right - m > l;
        return f || b || h2 || y;
      });
    }
    function Wr(n2, e, t) {
      var o = e + "EventListener";
      ["transitionend", "webkitTransitionEnd"].forEach(function(i2) {
        n2[o](i2, t);
      });
    }
    function ju(n2, e) {
      for (var t = e; t; ) {
        var o;
        if (n2.contains(t))
          return true;
        t = t.getRootNode == null || (o = t.getRootNode()) == null ? void 0 : o.host;
      }
      return false;
    }
    var It = {
      isTouch: false
    }, wu = 0;
    function fg() {
      It.isTouch || (It.isTouch = true, window.performance && document.addEventListener("mousemove", Td));
    }
    function Td() {
      var n2 = performance.now();
      n2 - wu < 20 && (It.isTouch = false, document.removeEventListener("mousemove", Td)), wu = n2;
    }
    function gg() {
      var n2 = document.activeElement;
      if (dg(n2)) {
        var e = n2._tippy;
        n2.blur && !e.state.isVisible && n2.blur();
      }
    }
    function hg() {
      document.addEventListener("touchstart", fg, jo), window.addEventListener("blur", gg);
    }
    var vg = typeof window < "u" && typeof document < "u", bg = vg ? (
      // @ts-ignore
      !!window.msCrypto
    ) : false;
    var Nd = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    }, wg = {
      allowHTML: false,
      animation: "fade",
      arrow: true,
      content: "",
      inertia: false,
      maxWidth: 350,
      role: "tooltip",
      theme: "",
      zIndex: 9999
    }, Qn = Object.assign({
      appendTo: Sd,
      aria: {
        content: "auto",
        expanded: "auto"
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: "",
      offset: [0, 10],
      onAfterUpdate: function() {
      },
      onBeforeUpdate: function() {
      },
      onCreate: function() {
      },
      onDestroy: function() {
      },
      onHidden: function() {
      },
      onHide: function() {
      },
      onMount: function() {
      },
      onShow: function() {
      },
      onShown: function() {
      },
      onTrigger: function() {
      },
      onUntrigger: function() {
      },
      onClickOutside: function() {
      },
      placement: "top",
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: "mouseenter focus",
      triggerTarget: null
    }, Nd, wg), Eg = Object.keys(Qn), Cg = function(e) {
      var t = Object.keys(e);
      t.forEach(function(o) {
        Qn[o] = e[o];
      });
    };
    function Od(n2) {
      var e = n2.plugins || [], t = e.reduce(function(o, i2) {
        var s = i2.name, r = i2.defaultValue;
        if (s) {
          var a;
          o[s] = n2[s] !== void 0 ? n2[s] : (a = Qn[s]) != null ? a : r;
        }
        return o;
      }, {});
      return Object.assign({}, n2, t);
    }
    function Sg(n2, e) {
      var t = e ? Object.keys(Od(Object.assign({}, Qn, {
        plugins: e
      }))) : Eg, o = t.reduce(function(i2, s) {
        var r = (n2.getAttribute("data-tippy-" + s) || "").trim();
        if (!r)
          return i2;
        if (s === "content")
          i2[s] = r;
        else
          try {
            i2[s] = JSON.parse(r);
          } catch {
            i2[s] = r;
          }
        return i2;
      }, {});
      return o;
    }
    function Cu(n2, e) {
      var t = Object.assign({}, e, {
        content: xd(e.content, [n2])
      }, e.ignoreAttributes ? {} : Sg(n2, e.plugins));
      return t.aria = Object.assign({}, Qn.aria, t.aria), t.aria = {
        expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded,
        content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content
      }, t;
    }
    var xg = function() {
      return "innerHTML";
    };
    function Ea(n2, e) {
      n2[xg()] = e;
    }
    function Su(n2) {
      var e = yi();
      return n2 === true ? e.className = Ed : (e.className = Cd, Ii(n2) ? e.appendChild(n2) : Ea(e, n2)), e;
    }
    function xu(n2, e) {
      Ii(e.content) ? (Ea(n2, ""), n2.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Ea(n2, e.content) : n2.textContent = e.content);
    }
    function Ca(n2) {
      var e = n2.firstElementChild, t = Ls(e.children);
      return {
        box: e,
        content: t.find(function(o) {
          return o.classList.contains(wd);
        }),
        arrow: t.find(function(o) {
          return o.classList.contains(Ed) || o.classList.contains(Cd);
        }),
        backdrop: t.find(function(o) {
          return o.classList.contains(og);
        })
      };
    }
    function Rd(n2) {
      var e = yi(), t = yi();
      t.className = tg, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1");
      var o = yi();
      o.className = wd, o.setAttribute("data-state", "hidden"), xu(o, n2.props), e.appendChild(t), t.appendChild(o), i2(n2.props, n2.props);
      function i2(s, r) {
        var a = Ca(e), l = a.box, u = a.content, c2 = a.arrow;
        r.theme ? l.setAttribute("data-theme", r.theme) : l.removeAttribute("data-theme"), typeof r.animation == "string" ? l.setAttribute("data-animation", r.animation) : l.removeAttribute("data-animation"), r.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof r.maxWidth == "number" ? r.maxWidth + "px" : r.maxWidth, r.role ? l.setAttribute("role", r.role) : l.removeAttribute("role"), (s.content !== r.content || s.allowHTML !== r.allowHTML) && xu(u, n2.props), r.arrow ? c2 ? s.arrow !== r.arrow && (l.removeChild(c2), l.appendChild(Su(r.arrow))) : l.appendChild(Su(r.arrow)) : c2 && l.removeChild(c2);
      }
      return {
        popper: e,
        onUpdate: i2
      };
    }
    Rd.$$tippy = true;
    var Tg = 1, as = [], Gr = [];
    function Ag(n2, e) {
      var t = Cu(n2, Object.assign({}, Qn, Od(ku(e)))), o, i2, s, r = false, a = false, l = false, u = false, c2, d, p2, _ = [], m = vu(Yn, t.interactiveDebounce), f, b = Tg++, h2 = null, y = ag(t.plugins), C = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      }, v = {
        // properties
        id: b,
        reference: n2,
        popper: yi(),
        popperInstance: h2,
        props: t,
        state: C,
        plugins: y,
        // methods
        clearDelayTimeouts: Bn,
        setProps: P,
        setContent: J,
        show: be,
        hide: Re,
        hideWithInteractivity: pn,
        enable: un,
        disable: ht,
        unmount: Jn,
        destroy: ui
      };
      if (!t.render)
        return v;
      var x = t.render(v), S = x.popper, F = x.onUpdate;
      S.setAttribute("data-tippy-root", ""), S.id = "tippy-" + v.id, v.popper = S, n2._tippy = v, S._tippy = v;
      var Y = y.map(function(A) {
        return A.fn(v);
      }), q = n2.hasAttribute("aria-expanded");
      return it(), te(), N(), L("onCreate", [v]), t.showOnCreate && Me(), S.addEventListener("mouseenter", function() {
        v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
      }), S.addEventListener("mouseleave", function() {
        v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && he().addEventListener("mousemove", m);
      }), v;
      function K() {
        var A = v.props.touch;
        return Array.isArray(A) ? A : [A, 0];
      }
      function ie2() {
        return K()[0] === "hold";
      }
      function ce() {
        var A;
        return !!((A = v.props.render) != null && A.$$tippy);
      }
      function ve() {
        return f || n2;
      }
      function he() {
        var A = ve().parentNode;
        return A ? _g(A) : document;
      }
      function de() {
        return Ca(S);
      }
      function pe(A) {
        return v.state.isMounted && !v.state.isVisible || It.isTouch || c2 && c2.type === "focus" ? 0 : Kr(v.props.delay, A ? 0 : 1, Qn.delay);
      }
      function N(A) {
        A === void 0 && (A = false), S.style.pointerEvents = v.props.interactive && !A ? "" : "none", S.style.zIndex = "" + v.props.zIndex;
      }
      function L(A, X, le) {
        if (le === void 0 && (le = true), Y.forEach(function(Se) {
          Se[A] && Se[A].apply(Se, X);
        }), le) {
          var De;
          (De = v.props)[A].apply(De, X);
        }
      }
      function V() {
        var A = v.props.aria;
        if (A.content) {
          var X = "aria-" + A.content, le = S.id, De = Ho(v.props.triggerTarget || n2);
          De.forEach(function(Se) {
            var bn = Se.getAttribute(X);
            if (v.state.isVisible)
              Se.setAttribute(X, bn ? bn + " " + le : le);
            else {
              var Pn = bn && bn.replace(le, "").trim();
              Pn ? Se.setAttribute(X, Pn) : Se.removeAttribute(X);
            }
          });
        }
      }
      function te() {
        if (!(q || !v.props.aria.expanded)) {
          var A = Ho(v.props.triggerTarget || n2);
          A.forEach(function(X) {
            v.props.interactive ? X.setAttribute("aria-expanded", v.state.isVisible && X === ve() ? "true" : "false") : X.removeAttribute("aria-expanded");
          });
        }
      }
      function ae() {
        he().removeEventListener("mousemove", m), as = as.filter(function(A) {
          return A !== m;
        });
      }
      function ye(A) {
        if (!(It.isTouch && (l || A.type === "mousedown"))) {
          var X = A.composedPath && A.composedPath()[0] || A.target;
          if (!(v.props.interactive && ju(S, X))) {
            if (Ho(v.props.triggerTarget || n2).some(function(le) {
              return ju(le, X);
            })) {
              if (It.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
                return;
            } else
              L("onClickOutside", [v, A]);
            v.props.hideOnClick === true && (v.clearDelayTimeouts(), v.hide(), a = true, setTimeout(function() {
              a = false;
            }), v.state.isMounted || Ge());
          }
        }
      }
      function Pe() {
        l = true;
      }
      function vn() {
        l = false;
      }
      function $e() {
        var A = he();
        A.addEventListener("mousedown", ye, true), A.addEventListener("touchend", ye, jo), A.addEventListener("touchstart", vn, jo), A.addEventListener("touchmove", Pe, jo);
      }
      function Ge() {
        var A = he();
        A.removeEventListener("mousedown", ye, true), A.removeEventListener("touchend", ye, jo), A.removeEventListener("touchstart", vn, jo), A.removeEventListener("touchmove", Pe, jo);
      }
      function Gn(A, X) {
        ot(A, function() {
          !v.state.isVisible && S.parentNode && S.parentNode.contains(S) && X();
        });
      }
      function Cn(A, X) {
        ot(A, X);
      }
      function ot(A, X) {
        var le = de().box;
        function De(Se) {
          Se.target === le && (Wr(le, "remove", De), X());
        }
        if (A === 0)
          return X();
        Wr(le, "remove", d), Wr(le, "add", De), d = De;
      }
      function Sn(A, X, le) {
        le === void 0 && (le = false);
        var De = Ho(v.props.triggerTarget || n2);
        De.forEach(function(Se) {
          Se.addEventListener(A, X, le), _.push({
            node: Se,
            eventType: A,
            handler: X,
            options: le
          });
        });
      }
      function it() {
        ie2() && (Sn("touchstart", ft, {
          passive: true
        }), Sn("touchend", gt, {
          passive: true
        })), rg(v.props.trigger).forEach(function(A) {
          if (A !== "manual")
            switch (Sn(A, ft), A) {
              case "mouseenter":
                Sn("mouseleave", gt);
                break;
              case "focus":
                Sn(bg ? "focusout" : "blur", ge);
                break;
              case "focusin":
                Sn("focusout", ge);
                break;
            }
        });
      }
      function xt() {
        _.forEach(function(A) {
          var X = A.node, le = A.eventType, De = A.handler, Se = A.options;
          X.removeEventListener(le, De, Se);
        }), _ = [];
      }
      function ft(A) {
        var X, le = false;
        if (!(!v.state.isEnabled || Hn(A) || a)) {
          var De = ((X = c2) == null ? void 0 : X.type) === "focus";
          c2 = A, f = A.currentTarget, te(), !v.state.isVisible && cg(A) && as.forEach(function(Se) {
            return Se(A);
          }), A.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || r) && v.props.hideOnClick !== false && v.state.isVisible ? le = true : Me(A), A.type === "click" && (r = !le), le && !De && Dn(A);
        }
      }
      function Yn(A) {
        var X = A.target, le = ve().contains(X) || S.contains(X);
        if (!(A.type === "mousemove" && le)) {
          var De = Ue().concat(S).map(function(Se) {
            var bn, Pn = Se._tippy, Zt = (bn = Pn.popperInstance) == null ? void 0 : bn.state;
            return Zt ? {
              popperRect: Se.getBoundingClientRect(),
              popperState: Zt,
              props: t
            } : null;
          }).filter(Boolean);
          mg(De, A) && (ae(), Dn(A));
        }
      }
      function gt(A) {
        var X = Hn(A) || v.props.trigger.indexOf("click") >= 0 && r;
        if (!X) {
          if (v.props.interactive) {
            v.hideWithInteractivity(A);
            return;
          }
          Dn(A);
        }
      }
      function ge(A) {
        v.props.trigger.indexOf("focusin") < 0 && A.target !== ve() || v.props.interactive && A.relatedTarget && S.contains(A.relatedTarget) || Dn(A);
      }
      function Hn(A) {
        return It.isTouch ? ie2() !== A.type.indexOf("touch") >= 0 : false;
      }
      function Nn() {
        se();
        var A = v.props, X = A.popperOptions, le = A.placement, De = A.offset, Se = A.getReferenceClientRect, bn = A.moveTransition, Pn = ce() ? Ca(S).arrow : null, Zt = Se ? {
          getBoundingClientRect: Se,
          contextElement: Se.contextElement || ve()
        } : n2, ci = {
          name: "$$tippy",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn: function(M) {
            var $ = M.state;
            if (ce()) {
              var _e = de(), Xe = _e.box;
              ["placement", "reference-hidden", "escaped"].forEach(function(Ye) {
                Ye === "placement" ? Xe.setAttribute("data-placement", $.placement) : $.attributes.popper["data-popper-" + Ye] ? Xe.setAttribute("data-" + Ye, "") : Xe.removeAttribute("data-" + Ye);
              }), $.attributes.popper = {};
            }
          }
        }, Un = [{
          name: "offset",
          options: {
            offset: De
          }
        }, {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: "flip",
          options: {
            padding: 5
          }
        }, {
          name: "computeStyles",
          options: {
            adaptive: !bn
          }
        }, ci];
        ce() && Pn && Un.push({
          name: "arrow",
          options: {
            element: Pn,
            padding: 3
          }
        }), Un.push.apply(Un, (X == null ? void 0 : X.modifiers) || []), v.popperInstance = ng(Zt, S, Object.assign({}, X, {
          placement: le,
          onFirstUpdate: p2,
          modifiers: Un
        }));
      }
      function se() {
        v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
      }
      function Ln() {
        var A = v.props.appendTo, X, le = ve();
        v.props.interactive && A === Sd || A === "parent" ? X = le.parentNode : X = xd(A, [le]), X.contains(S) || X.appendChild(S), v.state.isMounted = true, Nn();
      }
      function Ue() {
        return Ls(S.querySelectorAll("[data-tippy-root]"));
      }
      function Me(A) {
        v.clearDelayTimeouts(), A && L("onTrigger", [v, A]), $e();
        var X = pe(true), le = K(), De = le[0], Se = le[1];
        It.isTouch && De === "hold" && Se && (X = Se), X ? o = setTimeout(function() {
          v.show();
        }, X) : v.show();
      }
      function Dn(A) {
        if (v.clearDelayTimeouts(), L("onUntrigger", [v, A]), !v.state.isVisible) {
          Ge();
          return;
        }
        if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(A.type) >= 0 && r)) {
          var X = pe(false);
          X ? i2 = setTimeout(function() {
            v.state.isVisible && v.hide();
          }, X) : s = requestAnimationFrame(function() {
            v.hide();
          });
        }
      }
      function un() {
        v.state.isEnabled = true;
      }
      function ht() {
        v.hide(), v.state.isEnabled = false;
      }
      function Bn() {
        clearTimeout(o), clearTimeout(i2), cancelAnimationFrame(s);
      }
      function P(A) {
        if (!v.state.isDestroyed) {
          L("onBeforeUpdate", [v, A]), xt();
          var X = v.props, le = Cu(n2, Object.assign({}, X, ku(A), {
            ignoreAttributes: true
          }));
          v.props = le, it(), X.interactiveDebounce !== le.interactiveDebounce && (ae(), m = vu(Yn, le.interactiveDebounce)), X.triggerTarget && !le.triggerTarget ? Ho(X.triggerTarget).forEach(function(De) {
            De.removeAttribute("aria-expanded");
          }) : le.triggerTarget && n2.removeAttribute("aria-expanded"), te(), N(), F && F(X, le), v.popperInstance && (Nn(), Ue().forEach(function(De) {
            requestAnimationFrame(De._tippy.popperInstance.forceUpdate);
          })), L("onAfterUpdate", [v, A]);
        }
      }
      function J(A) {
        v.setProps({
          content: A
        });
      }
      function be() {
        var A = v.state.isVisible, X = v.state.isDestroyed, le = !v.state.isEnabled, De = It.isTouch && !v.props.touch, Se = Kr(v.props.duration, 0, Qn.duration);
        if (!(A || X || le || De) && !ve().hasAttribute("disabled") && (L("onShow", [v], false), v.props.onShow(v) !== false)) {
          if (v.state.isVisible = true, ce() && (S.style.visibility = "visible"), N(), $e(), v.state.isMounted || (S.style.transition = "none"), ce()) {
            var bn = de(), Pn = bn.box, Zt = bn.content;
            Vr([Pn, Zt], 0);
          }
          p2 = function() {
            var Un;
            if (!(!v.state.isVisible || u)) {
              if (u = true, S.offsetHeight, S.style.transition = v.props.moveTransition, ce() && v.props.animation) {
                var j = de(), M = j.box, $ = j.content;
                Vr([M, $], Se), yu([M, $], "visible");
              }
              V(), te(), bu(Gr, v), (Un = v.popperInstance) == null || Un.forceUpdate(), L("onMount", [v]), v.props.animation && ce() && Cn(Se, function() {
                v.state.isShown = true, L("onShown", [v]);
              });
            }
          }, Ln();
        }
      }
      function Re() {
        var A = !v.state.isVisible, X = v.state.isDestroyed, le = !v.state.isEnabled, De = Kr(v.props.duration, 1, Qn.duration);
        if (!(A || X || le) && (L("onHide", [v], false), v.props.onHide(v) !== false)) {
          if (v.state.isVisible = false, v.state.isShown = false, u = false, r = false, ce() && (S.style.visibility = "hidden"), ae(), Ge(), N(true), ce()) {
            var Se = de(), bn = Se.box, Pn = Se.content;
            v.props.animation && (Vr([bn, Pn], De), yu([bn, Pn], "hidden"));
          }
          V(), te(), v.props.animation ? ce() && Gn(De, v.unmount) : v.unmount();
        }
      }
      function pn(A) {
        he().addEventListener("mousemove", m), bu(as, m), m(A);
      }
      function Jn() {
        v.state.isVisible && v.hide(), v.state.isMounted && (se(), Ue().forEach(function(A) {
          A._tippy.unmount();
        }), S.parentNode && S.parentNode.removeChild(S), Gr = Gr.filter(function(A) {
          return A !== v;
        }), v.state.isMounted = false, L("onHidden", [v]));
      }
      function ui() {
        !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), xt(), delete n2._tippy, v.state.isDestroyed = true, L("onDestroy", [v]));
      }
    }
    function jt(n2, e) {
      e === void 0 && (e = {});
      var t = Qn.plugins.concat(e.plugins || []);
      hg();
      var o = Object.assign({}, e, {
        plugins: t
      }), i2 = pg(n2);
      var a = i2.reduce(function(l, u) {
        var c2 = u && Ag(u, o);
        return c2 && l.push(c2), l;
      }, []);
      return Ii(n2) ? a[0] : a;
    }
    jt.defaultProps = Qn;
    jt.setDefaultProps = Cg;
    jt.currentInput = It;
    Object.assign({}, fd, {
      effect: function(e) {
        var t = e.state, o = {
          popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(t.elements.popper.style, o.popper), t.styles = o, t.elements.arrow && Object.assign(t.elements.arrow.style, o.arrow);
      }
    });
    jt.setDefaultProps({
      render: Rd
    });
    class Ng {
      constructor({ editor: e, element: t, view: o, tippyOptions: i2 = {}, updateDelay: s = 250, shouldShow: r }) {
        this.preventHide = false, this.shouldShow = ({ view: a, state: l, from: u, to: c2 }) => {
          const { doc: d, selection: p2 } = l, { empty: _ } = p2, m = !d.textBetween(u, c2).length && isTextSelection(l.selection), f = this.element.contains(document.activeElement);
          return !(!(a.hasFocus() || f) || _ || m || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.dragstartHandler = () => {
          this.hide();
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: a }) => {
          var l;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (a) => {
          this.blurHandler({ event: a });
        }, this.handleDebouncedUpdate = (a, l) => {
          const u = !(l != null && l.selection.eq(a.state.selection)), c2 = !(l != null && l.doc.eq(a.state.doc));
          !u && !c2 || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(a, u, c2, l);
          }, this.updateDelay));
        }, this.updateHandler = (a, l, u, c2) => {
          var d, p2, _;
          const { state: m, composing: f } = a, { selection: b } = m;
          if (f || !l && !u)
            return;
          this.createTooltip();
          const { ranges: y } = b, C = Math.min(...y.map((S) => S.$from.pos)), v = Math.max(...y.map((S) => S.$to.pos));
          if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
            editor: this.editor,
            element: this.element,
            view: a,
            state: m,
            oldState: c2,
            from: C,
            to: v
          }))) {
            this.hide();
            return;
          }
          (p2 = this.tippy) === null || p2 === void 0 || p2.setProps({
            getReferenceClientRect: ((_ = this.tippyOptions) === null || _ === void 0 ? void 0 : _.getReferenceClientRect) || (() => {
              if (isNodeSelection(m.selection)) {
                let S = a.nodeDOM(C);
                if (S) {
                  const F = S.dataset.nodeViewWrapper ? S : S.querySelector("[data-node-view-wrapper]");
                  if (F && (S = F.firstChild), S)
                    return S.getBoundingClientRect();
                }
              }
              return posToDOMRect(a, C, v);
            })
          }), this.show();
        }, this.editor = e, this.element = t, this.view = o, this.updateDelay = s, r && (this.shouldShow = r), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i2, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = jt(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "top",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, t) {
        const { state: o } = e, i2 = o.selection.from !== o.selection.to;
        if (this.updateDelay > 0 && i2) {
          this.handleDebouncedUpdate(e, t);
          return;
        }
        const s = !(t != null && t.selection.eq(e.state.selection)), r = !(t != null && t.doc.eq(e.state.doc));
        this.updateHandler(e, s, r, t);
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, t;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const Id = (n2) => new dn({
      key: typeof n2.pluginKey == "string" ? new en(n2.pluginKey) : n2.pluginKey,
      view: (e) => new Ng({ view: e, ...n2 })
    });
    Extension.create({
      name: "bubbleMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "bubbleMenu",
          updateDelay: void 0,
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          Id({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            updateDelay: this.options.updateDelay,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    class Og {
      getTextContent(e) {
        return getText(e, { textSerializers: getTextSerializersFromSchema(this.editor.schema) });
      }
      constructor({ editor: e, element: t, view: o, tippyOptions: i2 = {}, shouldShow: s }) {
        this.preventHide = false, this.shouldShow = ({ view: r, state: a }) => {
          const { selection: l } = a, { $anchor: u, empty: c2 } = l, d = u.depth === 1, p2 = u.parent.isTextblock && !u.parent.type.spec.code && !u.parent.textContent && u.parent.childCount === 0 && !this.getTextContent(u.parent);
          return !(!r.hasFocus() || !c2 || !d || !p2 || !this.editor.isEditable);
        }, this.mousedownHandler = () => {
          this.preventHide = true;
        }, this.focusHandler = () => {
          setTimeout(() => this.update(this.editor.view));
        }, this.blurHandler = ({ event: r }) => {
          var a;
          if (this.preventHide) {
            this.preventHide = false;
            return;
          }
          r != null && r.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(r.relatedTarget)) || (r == null ? void 0 : r.relatedTarget) !== this.editor.view.dom && this.hide();
        }, this.tippyBlurHandler = (r) => {
          this.blurHandler({ event: r });
        }, this.editor = e, this.element = t, this.view = o, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i2, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = jt(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "right",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
      }
      update(e, t) {
        var o, i2, s;
        const { state: r } = e, { doc: a, selection: l } = r, { from: u, to: c2 } = l;
        if (t && t.doc.eq(a) && t.selection.eq(l))
          return;
        if (this.createTooltip(), !((o = this.shouldShow) === null || o === void 0 ? void 0 : o.call(this, {
          editor: this.editor,
          view: e,
          state: r,
          oldState: t
        }))) {
          this.hide();
          return;
        }
        (i2 = this.tippy) === null || i2 === void 0 || i2.setProps({
          getReferenceClientRect: ((s = this.tippyOptions) === null || s === void 0 ? void 0 : s.getReferenceClientRect) || (() => posToDOMRect(e, u, c2))
        }), this.show();
      }
      show() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) === null || e === void 0 || e.hide();
      }
      destroy() {
        var e, t;
        !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
      }
    }
    const Ld = (n2) => new dn({
      key: typeof n2.pluginKey == "string" ? new en(n2.pluginKey) : n2.pluginKey,
      view: (e) => new Og({ view: e, ...n2 })
    });
    Extension.create({
      name: "floatingMenu",
      addOptions() {
        return {
          element: null,
          tippyOptions: {},
          pluginKey: "floatingMenu",
          shouldShow: null
        };
      },
      addProseMirrorPlugins() {
        return this.options.element ? [
          Ld({
            pluginKey: this.options.pluginKey,
            editor: this.editor,
            element: this.options.element,
            tippyOptions: this.options.tippyOptions,
            shouldShow: this.options.shouldShow
          })
        ] : [];
      }
    });
    const Mg = /* @__PURE__ */ defineComponent({
      name: "BubbleMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "bubbleMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(n2, { slots: e }) {
        const t = ref(null);
        return onMounted(() => {
          const { updateDelay: o, editor: i2, pluginKey: s, shouldShow: r, tippyOptions: a } = n2;
          i2.registerPlugin(Id({
            updateDelay: o,
            editor: i2,
            element: t.value,
            pluginKey: s,
            shouldShow: r,
            tippyOptions: a
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: o, editor: i2 } = n2;
          i2.unregisterPlugin(o);
        }), () => {
          var o;
          return h("div", { ref: t }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
        };
      }
    });
    function Tu(n2) {
      return customRef((e, t) => ({
        get() {
          return e(), n2;
        },
        set(o) {
          n2 = o, requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              t();
            });
          });
        }
      }));
    }
    class Dd extends Editor {
      constructor(e = {}) {
        return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = Tu(this.view.state), this.reactiveExtensionStorage = Tu(this.extensionStorage), this.on("beforeTransaction", ({ nextState: t }) => {
          this.reactiveState.value = t, this.reactiveExtensionStorage.value = this.extensionStorage;
        }), markRaw(this);
      }
      get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state;
      }
      get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
      }
      /**
       * Register a ProseMirror plugin.
       */
      registerPlugin(e, t) {
        const o = super.registerPlugin(e, t);
        return this.reactiveState && (this.reactiveState.value = o), o;
      }
      /**
       * Unregister a ProseMirror plugin.
       */
      unregisterPlugin(e) {
        const t = super.unregisterPlugin(e);
        return this.reactiveState && t && (this.reactiveState.value = t), t;
      }
    }
    const Rg = /* @__PURE__ */ defineComponent({
      name: "EditorContent",
      props: {
        editor: {
          default: null,
          type: Object
        }
      },
      setup(n2) {
        const e = ref(), t = getCurrentInstance();
        return watchEffect(() => {
          const o = n2.editor;
          o && o.options.element && e.value && nextTick(() => {
            if (!e.value || !o.options.element.firstChild)
              return;
            const i2 = unref(e.value);
            e.value.append(...o.options.element.childNodes), o.contentComponent = t.ctx._, t && (o.appContext = {
              ...t.appContext,
              // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
              // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
              // @ts-expect-error forward instance's 'provides' into appContext
              provides: t.provides
            }), o.setOptions({
              element: i2
            }), o.createNodeViews();
          });
        }), onBeforeUnmount(() => {
          const o = n2.editor;
          o && (o.contentComponent = null, o.appContext = null);
        }), { rootEl: e };
      },
      render() {
        return h("div", {
          ref: (n2) => {
            this.rootEl = n2;
          }
        });
      }
    }), Ig = /* @__PURE__ */ defineComponent({
      name: "FloatingMenu",
      props: {
        pluginKey: {
          // TODO: TypeScript breaks :(
          // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
          type: null,
          default: "floatingMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        },
        shouldShow: {
          type: Function,
          default: null
        }
      },
      setup(n2, { slots: e }) {
        const t = ref(null);
        return onMounted(() => {
          const { pluginKey: o, editor: i2, tippyOptions: s, shouldShow: r } = n2;
          i2.registerPlugin(Ld({
            pluginKey: o,
            editor: i2,
            element: t.value,
            tippyOptions: s,
            shouldShow: r
          }));
        }), onBeforeUnmount(() => {
          const { pluginKey: o, editor: i2 } = n2;
          i2.unregisterPlugin(o);
        }), () => {
          var o;
          return h("div", { ref: t }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
        };
      }
    }), Yt = /* @__PURE__ */ defineComponent({
      name: "NodeViewContent",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      render() {
        return h(this.as, {
          style: {
            whiteSpace: "pre-wrap"
          },
          "data-node-view-content": ""
        });
      }
    }), al = /* @__PURE__ */ defineComponent({
      name: "NodeViewWrapper",
      props: {
        as: {
          type: String,
          default: "div"
        }
      },
      inject: ["onDragStart", "decorationClasses"],
      render() {
        var n2, e;
        return h(this.as, {
          // @ts-ignore
          class: this.decorationClasses,
          style: {
            whiteSpace: "normal"
          },
          "data-node-view-wrapper": "",
          // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
          onDragstart: this.onDragStart
        }, (e = (n2 = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n2));
      }
    }), Lg = (n2 = {}) => {
      const e = shallowRef();
      return onMounted(() => {
        e.value = new Dd(n2);
      }), onBeforeUnmount(() => {
        var t, o, i2;
        const s = (t = e.value) === null || t === void 0 ? void 0 : t.options.element, r = s == null ? void 0 : s.cloneNode(true);
        (o = s == null ? void 0 : s.parentNode) === null || o === void 0 || o.replaceChild(r, s), (i2 = e.value) === null || i2 === void 0 || i2.destroy();
      }), e;
    };
    class ll {
      constructor(e, { props: t = {}, editor: o }) {
        this.editor = o, this.component = markRaw(e), this.el = document.createElement("div"), this.props = reactive(t), this.renderedComponent = this.renderComponent();
      }
      get element() {
        return this.renderedComponent.el;
      }
      get ref() {
        var e, t, o, i2;
        return !((t = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || t === void 0) && t.exposed ? this.renderedComponent.vNode.component.exposed : (i2 = (o = this.renderedComponent.vNode) === null || o === void 0 ? void 0 : o.component) === null || i2 === void 0 ? void 0 : i2.proxy;
      }
      renderComponent() {
        let e = h(this.component, this.props);
        return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && render$1(e, this.el), { vNode: e, destroy: () => {
          this.el && render$1(null, this.el), this.el = null, e = null;
        }, el: this.el ? this.el.firstElementChild : null };
      }
      updateProps(e = {}) {
        Object.entries(e).forEach(([t, o]) => {
          this.props[t] = o;
        }), this.renderComponent();
      }
      destroy() {
        this.renderedComponent.destroy();
      }
    }
    const En = {
      editor: {
        type: Object,
        required: true
      },
      node: {
        type: Object,
        required: true
      },
      decorations: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        required: true
      },
      extension: {
        type: Object,
        required: true
      },
      getPos: {
        type: Function,
        required: true
      },
      updateAttributes: {
        type: Function,
        required: true
      },
      deleteNode: {
        type: Function,
        required: true
      },
      view: {
        type: Object,
        required: true
      },
      innerDecorations: {
        type: Object,
        required: true
      },
      HTMLAttributes: {
        type: Object,
        required: true
      }
    };
    class Dg extends NodeView {
      mount() {
        const e = {
          editor: this.editor,
          node: this.node,
          decorations: this.decorations,
          innerDecorations: this.innerDecorations,
          view: this.view,
          selected: false,
          extension: this.extension,
          HTMLAttributes: this.HTMLAttributes,
          getPos: () => this.getPos(),
          updateAttributes: (i2 = {}) => this.updateAttributes(i2),
          deleteNode: () => this.deleteNode()
        }, t = this.onDragStart.bind(this);
        this.decorationClasses = ref(this.getDecorationClasses());
        const o = /* @__PURE__ */ defineComponent({
          extends: { ...this.component },
          props: Object.keys(e),
          template: this.component.template,
          setup: (i2) => {
            var s, r;
            return provide("onDragStart", t), provide("decorationClasses", this.decorationClasses), (r = (s = this.component).setup) === null || r === void 0 ? void 0 : r.call(s, i2, {
              expose: () => {
              }
            });
          },
          // add support for scoped styles
          // @ts-ignore
          // eslint-disable-next-line
          __scopeId: this.component.__scopeId,
          // add support for CSS Modules
          // @ts-ignore
          // eslint-disable-next-line
          __cssModules: this.component.__cssModules,
          // add support for vue devtools
          // @ts-ignore
          // eslint-disable-next-line
          __name: this.component.__name,
          // @ts-ignore
          // eslint-disable-next-line
          __file: this.component.__file
        });
        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new ll(o, {
          editor: this.editor,
          props: e
        });
      }
      /**
       * Return the DOM element.
       * This is the element that will be used to display the node view.
       */
      get dom() {
        if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
          throw Error("Please use the NodeViewWrapper component for your node view.");
        return this.renderer.element;
      }
      /**
       * Return the content DOM element.
       * This is the element that will be used to display the rich-text content of the node.
       */
      get contentDOM() {
        return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
      }
      /**
       * On editor selection update, check if the node is selected.
       * If it is, call `selectNode`, otherwise call `deselectNode`.
       */
      handleSelectionUpdate() {
        const { from: e, to: t } = this.editor.state.selection, o = this.getPos();
        if (typeof o == "number")
          if (e <= o && t >= o + this.node.nodeSize) {
            if (this.renderer.props.selected)
              return;
            this.selectNode();
          } else {
            if (!this.renderer.props.selected)
              return;
            this.deselectNode();
          }
      }
      /**
       * On update, update the React component.
       * To prevent unnecessary updates, the `update` option can be used.
       */
      update(e, t, o) {
        const i2 = (s) => {
          this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(s);
        };
        if (typeof this.options.update == "function") {
          const s = this.node, r = this.decorations, a = this.innerDecorations;
          return this.node = e, this.decorations = t, this.innerDecorations = o, this.options.update({
            oldNode: s,
            oldDecorations: r,
            newNode: e,
            newDecorations: t,
            oldInnerDecorations: a,
            innerDecorations: o,
            updateProps: () => i2({ node: e, decorations: t, innerDecorations: o })
          });
        }
        return e.type !== this.node.type ? false : (e === this.node && this.decorations === t && this.innerDecorations === o || (this.node = e, this.decorations = t, this.innerDecorations = o, i2({ node: e, decorations: t, innerDecorations: o })), true);
      }
      /**
       * Select the node.
       * Add the `selected` prop and the `ProseMirror-selectednode` class.
       */
      selectNode() {
        this.renderer.updateProps({
          selected: true
        }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
      }
      /**
       * Deselect the node.
       * Remove the `selected` prop and the `ProseMirror-selectednode` class.
       */
      deselectNode() {
        this.renderer.updateProps({
          selected: false
        }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
      }
      getDecorationClasses() {
        return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
      }
      destroy() {
        this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
      }
    }
    function wt(n2, e) {
      return (t) => {
        if (!t.editor.contentComponent)
          return {};
        const o = typeof n2 == "function" && "__vccOpts" in n2 ? n2.__vccOpts : n2;
        return new Dg(o, t, e);
      };
    }
    const Bg = /^\s*>\s$/, Bd = Node.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["blockquote", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: n2 }) => n2.wrapIn(this.name),
          toggleBlockquote: () => ({ commands: n2 }) => n2.toggleWrap(this.name),
          unsetBlockquote: () => ({ commands: n2 }) => n2.lift(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          wrappingInputRule({
            find: Bg,
            type: this.type
          })
        ];
      }
    }), Pg = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, $g = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, zg = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Fg = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, Hg = Mark.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (n2) => n2.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (n2) => n2.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (n2) => /^(bold(er)?|[5-9]\d{2,})$/.test(n2) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["strong", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: n2 }) => n2.setMark(this.name),
          toggleBold: () => ({ commands: n2 }) => n2.toggleMark(this.name),
          unsetBold: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: Pg,
            type: this.type
          }),
          markInputRule({
            find: zg,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: $g,
            type: this.type
          }),
          markPasteRule({
            find: Fg,
            type: this.type
          })
        ];
      }
    }), Ug = "listItem", Au = "textStyle", Nu = /^\s*([-+*])\s$/, qg = Node.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["ul", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: n2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ug, this.editor.getAttributes(Au)).run() : n2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let n2 = wrappingInputRule({
          find: Nu,
          type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (n2 = wrappingInputRule({
          find: Nu,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => this.editor.getAttributes(Au),
          editor: this.editor
        })), [
          n2
        ];
      }
    }), Kg = /(^|[^`])`([^`]+)`(?!`)/, Vg = /(^|[^`])`([^`]+)`(?!`)/g, Wg = Mark.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["code", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: n2 }) => n2.setMark(this.name),
          toggleCode: () => ({ commands: n2 }) => n2.toggleMark(this.name),
          unsetCode: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: Kg,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: Vg,
            type: this.type
          })
        ];
      }
    }), Gg = /^```([a-z]+)?[\s\n]$/, Yg = /^~~~([a-z]+)?[\s\n]$/, Pd = Node.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (n2) => {
              var e;
              const { languageClassPrefix: t } = this.options, s = [...((e = n2.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((r) => r.startsWith(t)).map((r) => r.replace(t, ""))[0];
              return s || null;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        return [
          "pre",
          mergeAttributes(this.options.HTMLAttributes, e),
          [
            "code",
            {
              class: n2.attrs.language ? this.options.languageClassPrefix + n2.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (n2) => ({ commands: e }) => e.setNode(this.name, n2),
          toggleCodeBlock: (n2) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n2)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: n2, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
            return !n2 || e.parent.type.name !== this.name ? false : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
          },
          // exit node on triple enter
          Enter: ({ editor: n2 }) => {
            if (!this.options.exitOnTripleEnter)
              return false;
            const { state: e } = n2, { selection: t } = e, { $from: o, empty: i2 } = t;
            if (!i2 || o.parent.type !== this.type)
              return false;
            const s = o.parentOffset === o.parent.nodeSize - 2, r = o.parent.textContent.endsWith(`

`);
            return !s || !r ? false : n2.chain().command(({ tr: a }) => (a.delete(o.pos - 2, o.pos), true)).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor: n2 }) => {
            if (!this.options.exitOnArrowDown)
              return false;
            const { state: e } = n2, { selection: t, doc: o } = e, { $from: i2, empty: s } = t;
            if (!s || i2.parent.type !== this.type || !(i2.parentOffset === i2.parent.nodeSize - 2))
              return false;
            const a = i2.after();
            return a === void 0 ? false : o.nodeAt(a) ? n2.commands.command(({ tr: u }) => (u.setSelection(Te.near(o.resolve(a))), true)) : n2.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          textblockTypeInputRule({
            find: Gg,
            type: this.type,
            getAttributes: (n2) => ({
              language: n2[1]
            })
          }),
          textblockTypeInputRule({
            find: Yg,
            type: this.type,
            getAttributes: (n2) => ({
              language: n2[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new dn({
            key: new en("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (n2, e) => {
                if (!e.clipboardData || this.editor.isActive(this.type.name))
                  return false;
                const t = e.clipboardData.getData("text/plain"), o = e.clipboardData.getData("vscode-editor-data"), i2 = o ? JSON.parse(o) : void 0, s = i2 == null ? void 0 : i2.mode;
                if (!t || !s)
                  return false;
                const { tr: r, schema: a } = n2.state, l = a.text(t.replace(/\r\n?/g, `
`));
                return r.replaceSelectionWith(this.type.create({ language: s }, l)), r.selection.$from.parent.type !== this.type && r.setSelection(Ce.near(r.doc.resolve(Math.max(0, r.selection.from - 2)))), r.setMeta("paste", true), n2.dispatch(r), true;
              }
            }
          })
        ];
      }
    }), $d = Node.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    function Jg(n2 = {}) {
      return new dn({
        view(e) {
          return new Zg(e, n2);
        }
      });
    }
    class Zg {
      constructor(e, t) {
        var o;
        this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (o = t.width) !== null && o !== void 0 ? o : 1, this.color = t.color === false ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i2) => {
          let s = (r) => {
            this[i2](r);
          };
          return e.dom.addEventListener(i2, s), { name: i2, handler: s };
        });
      }
      destroy() {
        this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
      }
      update(e, t) {
        this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
      }
      setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
      }
      updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, o;
        if (t) {
          let a = e.nodeBefore, l = e.nodeAfter;
          if (a || l) {
            let u = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
            if (u) {
              let c2 = u.getBoundingClientRect(), d = a ? c2.bottom : c2.top;
              a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), o = { left: c2.left, right: c2.right, top: d - this.width / 2, bottom: d + this.width / 2 };
            }
          }
        }
        if (!o) {
          let a = this.editorView.coordsAtPos(this.cursorPos);
          o = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
        }
        let i2 = this.editorView.dom.offsetParent;
        this.element || (this.element = i2.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
        let s, r;
        if (!i2 || i2 == document.body && getComputedStyle(i2).position == "static")
          s = -pageXOffset, r = -pageYOffset;
        else {
          let a = i2.getBoundingClientRect();
          s = a.left - i2.scrollLeft, r = a.top - i2.scrollTop;
        }
        this.element.style.left = o.left - s + "px", this.element.style.top = o.top - r + "px", this.element.style.width = o.right - o.left + "px", this.element.style.height = o.bottom - o.top + "px";
      }
      scheduleRemoval(e) {
        clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
      }
      dragover(e) {
        if (!this.editorView.editable)
          return;
        let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), o = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i2 = o && o.type.spec.disableDropCursor, s = typeof i2 == "function" ? i2(this.editorView, t, e) : i2;
        if (t && !s) {
          let r = t.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let a = sd(this.editorView.state.doc, r, this.editorView.dragging.slice);
            a != null && (r = a);
          }
          this.setCursor(r), this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
      }
    }
    const Xg = Extension.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          Jg(this.options)
        ];
      }
    });
    var mo = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    }, Ds = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    }, Qg = typeof navigator < "u" && /Mac/.test(navigator.platform), eh = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (var An = 0; An < 10; An++) mo[48 + An] = mo[96 + An] = String(An);
    for (var An = 1; An <= 24; An++) mo[An + 111] = "F" + An;
    for (var An = 65; An <= 90; An++)
      mo[An] = String.fromCharCode(An + 32), Ds[An] = String.fromCharCode(An);
    for (var Yr in mo) Ds.hasOwnProperty(Yr) || (Ds[Yr] = mo[Yr]);
    function nh(n2) {
      var e = Qg && n2.metaKey && n2.shiftKey && !n2.ctrlKey && !n2.altKey || eh && n2.shiftKey && n2.key && n2.key.length == 1 || n2.key == "Unidentified", t = !e && n2.key || (n2.shiftKey ? Ds : mo)[n2.keyCode] || n2.key || "Unidentified";
      return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
    }
    const th = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function oh(n2) {
      let e = n2.split(/-(?!$)/), t = e[e.length - 1];
      t == "Space" && (t = " ");
      let o, i2, s, r;
      for (let a = 0; a < e.length - 1; a++) {
        let l = e[a];
        if (/^(cmd|meta|m)$/i.test(l))
          r = true;
        else if (/^a(lt)?$/i.test(l))
          o = true;
        else if (/^(c|ctrl|control)$/i.test(l))
          i2 = true;
        else if (/^s(hift)?$/i.test(l))
          s = true;
        else if (/^mod$/i.test(l))
          th ? r = true : i2 = true;
        else
          throw new Error("Unrecognized modifier name: " + l);
      }
      return o && (t = "Alt-" + t), i2 && (t = "Ctrl-" + t), r && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
    }
    function ih(n2) {
      let e = /* @__PURE__ */ Object.create(null);
      for (let t in n2)
        e[oh(t)] = n2[t];
      return e;
    }
    function Jr(n2, e, t = true) {
      return e.altKey && (n2 = "Alt-" + n2), e.ctrlKey && (n2 = "Ctrl-" + n2), e.metaKey && (n2 = "Meta-" + n2), t && e.shiftKey && (n2 = "Shift-" + n2), n2;
    }
    function zd(n2) {
      let e = ih(n2);
      return function(t, o) {
        let i2 = nh(o), s, r = e[Jr(i2, o)];
        if (r && r(t.state, t.dispatch, t))
          return true;
        if (i2.length == 1 && i2 != " ") {
          if (o.shiftKey) {
            let a = e[Jr(i2, o, false)];
            if (a && a(t.state, t.dispatch, t))
              return true;
          }
          if ((o.shiftKey || o.altKey || o.metaKey || i2.charCodeAt(0) > 127) && (s = mo[o.keyCode]) && s != i2) {
            let a = e[Jr(s, o)];
            if (a && a(t.state, t.dispatch, t))
              return true;
          }
        }
        return false;
      };
    }
    const Lo = function(n2) {
      for (var e = 0; ; e++)
        if (n2 = n2.previousSibling, !n2)
          return e;
    }, Fd = function(n2, e, t, o) {
      return t && (Ou(n2, e, t, o, -1) || Ou(n2, e, t, o, 1));
    }, sh = /^(img|br|input|textarea|hr)$/i;
    function Ou(n2, e, t, o, i2) {
      for (; ; ) {
        if (n2 == t && e == o)
          return true;
        if (e == (i2 < 0 ? 0 : Bs(n2))) {
          let s = n2.parentNode;
          if (!s || s.nodeType != 1 || ul(n2) || sh.test(n2.nodeName) || n2.contentEditable == "false")
            return false;
          e = Lo(n2) + (i2 < 0 ? 0 : 1), n2 = s;
        } else if (n2.nodeType == 1) {
          if (n2 = n2.childNodes[e + (i2 < 0 ? -1 : 0)], n2.contentEditable == "false")
            return false;
          e = i2 < 0 ? Bs(n2) : 0;
        } else
          return false;
      }
    }
    function Bs(n2) {
      return n2.nodeType == 3 ? n2.nodeValue.length : n2.childNodes.length;
    }
    function rh(n2, e, t) {
      for (let o = e == 0, i2 = e == Bs(n2); o || i2; ) {
        if (n2 == t)
          return true;
        let s = Lo(n2);
        if (n2 = n2.parentNode, !n2)
          return false;
        o = o && s == 0, i2 = i2 && s == Bs(n2);
      }
    }
    function ul(n2) {
      let e;
      for (let t = n2; t && !(e = t.pmViewDesc); t = t.parentNode)
        ;
      return e && e.node && e.node.isBlock && (e.dom == n2 || e.contentDOM == n2);
    }
    const Hd = function(n2) {
      return n2.focusNode && Fd(n2.focusNode, n2.focusOffset, n2.anchorNode, n2.anchorOffset);
    };
    function Ud(n2, e) {
      let t = document.createEvent("Event");
      return t.initEvent("keydown", true, true), t.keyCode = n2, t.key = t.code = e, t;
    }
    const $t = typeof navigator < "u" ? navigator : null, Mu = typeof document < "u" ? document : null, ho = $t && $t.userAgent || "", Sa = /Edge\/(\d+)/.exec(ho), qd = /MSIE \d/.exec(ho), xa = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ho), Yi = !!(qd || xa || Sa), Kd = qd ? document.documentMode : xa ? +xa[1] : Sa ? +Sa[1] : 0, Cr = !Yi && /gecko\/(\d+)/i.test(ho);
    Cr && +(/Firefox\/(\d+)/.exec(ho) || [0, 0])[1];
    const Ta = !Yi && /Chrome\/(\d+)/.exec(ho), vo = !!Ta, Vd = Ta ? +Ta[1] : 0, Do = !Yi && !!$t && /Apple Computer/.test($t.vendor), cl = Do && (/Mobile\/\w+/.test(ho) || !!$t && $t.maxTouchPoints > 2), at = cl || ($t ? /Mac/.test($t.platform) : false), ah = $t ? /Win/.test($t.platform) : false, Ji = /Android \d/.test(ho), dl = !!Mu && "webkitFontSmoothing" in Mu.documentElement.style, lh = dl ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function uh(n2, e = null) {
      let t = n2.domSelectionRange(), o = n2.state.doc;
      if (!t.focusNode)
        return null;
      let i2 = n2.docView.nearestDesc(t.focusNode), s = i2 && i2.size == 0, r = n2.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
      if (r < 0)
        return null;
      let a = o.resolve(r), l, u;
      if (Hd(t)) {
        for (l = r; i2 && !i2.node; )
          i2 = i2.parent;
        let d = i2.node;
        if (i2 && d.isAtom && xe.isSelectable(d) && i2.parent && !(d.isInline && rh(t.focusNode, t.focusOffset, i2.dom))) {
          let p2 = i2.posBefore;
          u = new xe(r == p2 ? a : o.resolve(p2));
        }
      } else {
        if (t instanceof n2.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
          let d = r, p2 = r;
          for (let _ = 0; _ < t.rangeCount; _++) {
            let m = t.getRangeAt(_);
            d = Math.min(d, n2.docView.posFromDOM(m.startContainer, m.startOffset, 1)), p2 = Math.max(p2, n2.docView.posFromDOM(m.endContainer, m.endOffset, -1));
          }
          if (d < 0)
            return null;
          [l, r] = p2 == n2.state.selection.anchor ? [p2, d] : [d, p2], a = o.resolve(r);
        } else
          l = n2.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
        if (l < 0)
          return null;
      }
      let c2 = o.resolve(l);
      if (!u) {
        let d = e == "pointer" || n2.state.selection.head < a.pos && !s ? 1 : -1;
        u = Gd(n2, c2, a, d);
      }
      return u;
    }
    function Wd(n2) {
      return n2.editable ? n2.hasFocus() : _h(n2) && document.activeElement && document.activeElement.contains(n2.dom);
    }
    function pl(n2, e = false) {
      let t = n2.state.selection;
      if (ph(n2, t), !!Wd(n2)) {
        if (!e && n2.input.mouseDown && n2.input.mouseDown.allowDefault && vo) {
          let o = n2.domSelectionRange(), i2 = n2.domObserver.currentSelection;
          if (o.anchorNode && i2.anchorNode && Fd(o.anchorNode, o.anchorOffset, i2.anchorNode, i2.anchorOffset)) {
            n2.input.mouseDown.delayedSelectionSync = true, n2.domObserver.setCurSelection();
            return;
          }
        }
        if (n2.domObserver.disconnectSelection(), n2.cursorWrapper)
          dh(n2);
        else {
          let { anchor: o, head: i2 } = t, s, r;
          Ru && !(t instanceof Ce) && (t.$from.parent.inlineContent || (s = Iu(n2, t.from)), !t.empty && !t.$from.parent.inlineContent && (r = Iu(n2, t.to))), n2.docView.setSelection(o, i2, n2, e), Ru && (s && Lu(s), r && Lu(r)), t.visible ? n2.dom.classList.remove("ProseMirror-hideselection") : (n2.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && ch(n2));
        }
        n2.domObserver.setCurSelection(), n2.domObserver.connectSelection();
      }
    }
    const Ru = Do || vo && Vd < 63;
    function Iu(n2, e) {
      let { node: t, offset: o } = n2.docView.domFromPos(e, 0), i2 = o < t.childNodes.length ? t.childNodes[o] : null, s = o ? t.childNodes[o - 1] : null;
      if (Do && i2 && i2.contentEditable == "false")
        return Zr(i2);
      if ((!i2 || i2.contentEditable == "false") && (!s || s.contentEditable == "false")) {
        if (i2)
          return Zr(i2);
        if (s)
          return Zr(s);
      }
    }
    function Zr(n2) {
      return n2.contentEditable = "true", Do && n2.draggable && (n2.draggable = false, n2.wasDraggable = true), n2;
    }
    function Lu(n2) {
      n2.contentEditable = "false", n2.wasDraggable && (n2.draggable = true, n2.wasDraggable = null);
    }
    function ch(n2) {
      let e = n2.dom.ownerDocument;
      e.removeEventListener("selectionchange", n2.input.hideSelectionGuard);
      let t = n2.domSelectionRange(), o = t.anchorNode, i2 = t.anchorOffset;
      e.addEventListener("selectionchange", n2.input.hideSelectionGuard = () => {
        (t.anchorNode != o || t.anchorOffset != i2) && (e.removeEventListener("selectionchange", n2.input.hideSelectionGuard), setTimeout(() => {
          (!Wd(n2) || n2.state.selection.visible) && n2.dom.classList.remove("ProseMirror-hideselection");
        }, 20));
      });
    }
    function dh(n2) {
      let e = n2.domSelection(), t = document.createRange();
      if (!e)
        return;
      let o = n2.cursorWrapper.dom, i2 = o.nodeName == "IMG";
      i2 ? t.setStart(o.parentNode, Lo(o) + 1) : t.setStart(o, 0), t.collapse(true), e.removeAllRanges(), e.addRange(t), !i2 && !n2.state.selection.visible && Yi && Kd <= 11 && (o.disabled = true, o.disabled = false);
    }
    function ph(n2, e) {
      if (e instanceof xe) {
        let t = n2.docView.descAt(e.from);
        t != n2.lastSelectedViewDesc && (Du(n2), t && t.selectNode(), n2.lastSelectedViewDesc = t);
      } else
        Du(n2);
    }
    function Du(n2) {
      n2.lastSelectedViewDesc && (n2.lastSelectedViewDesc.parent && n2.lastSelectedViewDesc.deselectNode(), n2.lastSelectedViewDesc = void 0);
    }
    function Gd(n2, e, t, o) {
      return n2.someProp("createSelectionBetween", (i2) => i2(n2, e, t)) || Ce.between(e, t, o);
    }
    function _h(n2) {
      let e = n2.domSelectionRange();
      if (!e.anchorNode)
        return false;
      try {
        return n2.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n2.editable || n2.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
      } catch {
        return false;
      }
    }
    function Aa(n2, e) {
      let { $anchor: t, $head: o } = n2.selection, i2 = e > 0 ? t.max(o) : t.min(o), s = i2.parent.inlineContent ? i2.depth ? n2.doc.resolve(e > 0 ? i2.after() : i2.before()) : null : i2;
      return s && Te.findFrom(s, e);
    }
    function no(n2, e) {
      return n2.dispatch(n2.state.tr.setSelection(e).scrollIntoView()), true;
    }
    function Bu(n2, e, t) {
      let o = n2.state.selection;
      if (o instanceof Ce)
        if (t.indexOf("s") > -1) {
          let { $head: i2 } = o, s = i2.textOffset ? null : e < 0 ? i2.nodeBefore : i2.nodeAfter;
          if (!s || s.isText || !s.isLeaf)
            return false;
          let r = n2.state.doc.resolve(i2.pos + s.nodeSize * (e < 0 ? -1 : 1));
          return no(n2, new Ce(o.$anchor, r));
        } else if (o.empty) {
          if (n2.endOfTextblock(e > 0 ? "forward" : "backward")) {
            let i2 = Aa(n2.state, e);
            return i2 && i2 instanceof xe ? no(n2, i2) : false;
          } else if (!(at && t.indexOf("m") > -1)) {
            let i2 = o.$head, s = i2.textOffset ? null : e < 0 ? i2.nodeBefore : i2.nodeAfter, r;
            if (!s || s.isText)
              return false;
            let a = e < 0 ? i2.pos - s.nodeSize : i2.pos;
            return s.isAtom || (r = n2.docView.descAt(a)) && !r.contentDOM ? xe.isSelectable(s) ? no(n2, new xe(e < 0 ? n2.state.doc.resolve(i2.pos - s.nodeSize) : i2)) : dl ? no(n2, new Ce(n2.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : false : false;
          }
        } else return false;
      else {
        if (o instanceof xe && o.node.isInline)
          return no(n2, new Ce(e > 0 ? o.$to : o.$from));
        {
          let i2 = Aa(n2.state, e);
          return i2 ? no(n2, i2) : false;
        }
      }
    }
    function Ps(n2) {
      return n2.nodeType == 3 ? n2.nodeValue.length : n2.childNodes.length;
    }
    function ji(n2, e) {
      let t = n2.pmViewDesc;
      return t && t.size == 0 && (e < 0 || n2.nextSibling || n2.nodeName != "BR");
    }
    function $o(n2, e) {
      return e < 0 ? mh(n2) : fh(n2);
    }
    function mh(n2) {
      let e = n2.domSelectionRange(), t = e.focusNode, o = e.focusOffset;
      if (!t)
        return;
      let i2, s, r = false;
      for (Cr && t.nodeType == 1 && o < Ps(t) && ji(t.childNodes[o], -1) && (r = true); ; )
        if (o > 0) {
          if (t.nodeType != 1)
            break;
          {
            let a = t.childNodes[o - 1];
            if (ji(a, -1))
              i2 = t, s = --o;
            else if (a.nodeType == 3)
              t = a, o = t.nodeValue.length;
            else
              break;
          }
        } else {
          if (Yd(t))
            break;
          {
            let a = t.previousSibling;
            for (; a && ji(a, -1); )
              i2 = t.parentNode, s = Lo(a), a = a.previousSibling;
            if (a)
              t = a, o = Ps(t);
            else {
              if (t = t.parentNode, t == n2.dom)
                break;
              o = 0;
            }
          }
        }
      r ? Na(n2, t, o) : i2 && Na(n2, i2, s);
    }
    function fh(n2) {
      let e = n2.domSelectionRange(), t = e.focusNode, o = e.focusOffset;
      if (!t)
        return;
      let i2 = Ps(t), s, r;
      for (; ; )
        if (o < i2) {
          if (t.nodeType != 1)
            break;
          let a = t.childNodes[o];
          if (ji(a, 1))
            s = t, r = ++o;
          else
            break;
        } else {
          if (Yd(t))
            break;
          {
            let a = t.nextSibling;
            for (; a && ji(a, 1); )
              s = a.parentNode, r = Lo(a) + 1, a = a.nextSibling;
            if (a)
              t = a, o = 0, i2 = Ps(t);
            else {
              if (t = t.parentNode, t == n2.dom)
                break;
              o = i2 = 0;
            }
          }
        }
      s && Na(n2, s, r);
    }
    function Yd(n2) {
      let e = n2.pmViewDesc;
      return e && e.node && e.node.isBlock;
    }
    function gh(n2, e) {
      for (; n2 && e == n2.childNodes.length && !ul(n2); )
        e = Lo(n2) + 1, n2 = n2.parentNode;
      for (; n2 && e < n2.childNodes.length; ) {
        let t = n2.childNodes[e];
        if (t.nodeType == 3)
          return t;
        if (t.nodeType == 1 && t.contentEditable == "false")
          break;
        n2 = t, e = 0;
      }
    }
    function hh(n2, e) {
      for (; n2 && !e && !ul(n2); )
        e = Lo(n2), n2 = n2.parentNode;
      for (; n2 && e; ) {
        let t = n2.childNodes[e - 1];
        if (t.nodeType == 3)
          return t;
        if (t.nodeType == 1 && t.contentEditable == "false")
          break;
        n2 = t, e = n2.childNodes.length;
      }
    }
    function Na(n2, e, t) {
      if (e.nodeType != 3) {
        let s, r;
        (r = gh(e, t)) ? (e = r, t = 0) : (s = hh(e, t)) && (e = s, t = s.nodeValue.length);
      }
      let o = n2.domSelection();
      if (!o)
        return;
      if (Hd(o)) {
        let s = document.createRange();
        s.setEnd(e, t), s.setStart(e, t), o.removeAllRanges(), o.addRange(s);
      } else o.extend && o.extend(e, t);
      n2.domObserver.setCurSelection();
      let { state: i2 } = n2;
      setTimeout(() => {
        n2.state == i2 && pl(n2);
      }, 50);
    }
    function Pu(n2, e) {
      let t = n2.state.doc.resolve(e);
      if (!(vo || ah) && t.parent.inlineContent) {
        let i2 = n2.coordsAtPos(e);
        if (e > t.start()) {
          let s = n2.coordsAtPos(e - 1), r = (s.top + s.bottom) / 2;
          if (r > i2.top && r < i2.bottom && Math.abs(s.left - i2.left) > 1)
            return s.left < i2.left ? "ltr" : "rtl";
        }
        if (e < t.end()) {
          let s = n2.coordsAtPos(e + 1), r = (s.top + s.bottom) / 2;
          if (r > i2.top && r < i2.bottom && Math.abs(s.left - i2.left) > 1)
            return s.left > i2.left ? "ltr" : "rtl";
        }
      }
      return getComputedStyle(n2.dom).direction == "rtl" ? "rtl" : "ltr";
    }
    function $u(n2, e, t) {
      let o = n2.state.selection;
      if (o instanceof Ce && !o.empty || t.indexOf("s") > -1 || at && t.indexOf("m") > -1)
        return false;
      let { $from: i2, $to: s } = o;
      if (!i2.parent.inlineContent || n2.endOfTextblock(e < 0 ? "up" : "down")) {
        let r = Aa(n2.state, e);
        if (r && r instanceof xe)
          return no(n2, r);
      }
      if (!i2.parent.inlineContent) {
        let r = e < 0 ? i2 : s, a = o instanceof Dt ? Te.near(r, e) : Te.findFrom(r, e);
        return a ? no(n2, a) : false;
      }
      return false;
    }
    function zu(n2, e) {
      if (!(n2.state.selection instanceof Ce))
        return true;
      let { $head: t, $anchor: o, empty: i2 } = n2.state.selection;
      if (!t.sameParent(o))
        return true;
      if (!i2)
        return false;
      if (n2.endOfTextblock(e > 0 ? "forward" : "backward"))
        return true;
      let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
      if (s && !s.isText) {
        let r = n2.state.tr;
        return e < 0 ? r.delete(t.pos - s.nodeSize, t.pos) : r.delete(t.pos, t.pos + s.nodeSize), n2.dispatch(r), true;
      }
      return false;
    }
    function Fu(n2, e, t) {
      n2.domObserver.stop(), e.contentEditable = t, n2.domObserver.start();
    }
    function vh(n2) {
      if (!Do || n2.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode: e, focusOffset: t } = n2.domSelectionRange();
      if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let o = e.firstChild;
        Fu(n2, o, "true"), setTimeout(() => Fu(n2, o, "false"), 20);
      }
      return false;
    }
    function bh(n2) {
      let e = "";
      return n2.ctrlKey && (e += "c"), n2.metaKey && (e += "m"), n2.altKey && (e += "a"), n2.shiftKey && (e += "s"), e;
    }
    function kh(n2, e) {
      let t = e.keyCode, o = bh(e);
      if (t == 8 || at && t == 72 && o == "c")
        return zu(n2, -1) || $o(n2, -1);
      if (t == 46 && !e.shiftKey || at && t == 68 && o == "c")
        return zu(n2, 1) || $o(n2, 1);
      if (t == 13 || t == 27)
        return true;
      if (t == 37 || at && t == 66 && o == "c") {
        let i2 = t == 37 ? Pu(n2, n2.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return Bu(n2, i2, o) || $o(n2, i2);
      } else if (t == 39 || at && t == 70 && o == "c") {
        let i2 = t == 39 ? Pu(n2, n2.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return Bu(n2, i2, o) || $o(n2, i2);
      } else {
        if (t == 38 || at && t == 80 && o == "c")
          return $u(n2, -1, o) || $o(n2, -1);
        if (t == 40 || at && t == 78 && o == "c")
          return vh(n2) || $u(n2, 1, o) || $o(n2, 1);
        if (o == (at ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
          return true;
      }
      return false;
    }
    function Jd(n2, e) {
      n2.someProp("transformCopied", (_) => {
        e = _(e, n2);
      });
      let t = [], { content: o, openStart: i2, openEnd: s } = e;
      for (; i2 > 1 && s > 1 && o.childCount == 1 && o.firstChild.childCount == 1; ) {
        i2--, s--;
        let _ = o.firstChild;
        t.push(_.type.name, _.attrs != _.type.defaultAttrs ? _.attrs : null), o = _.content;
      }
      let r = n2.someProp("clipboardSerializer") || jr.fromSchema(n2.state.schema), a = tp(), l = a.createElement("div");
      l.appendChild(r.serializeFragment(o, { document: a }));
      let u = l.firstChild, c2, d = 0;
      for (; u && u.nodeType == 1 && (c2 = np[u.nodeName.toLowerCase()]); ) {
        for (let _ = c2.length - 1; _ >= 0; _--) {
          let m = a.createElement(c2[_]);
          for (; l.firstChild; )
            m.appendChild(l.firstChild);
          l.appendChild(m), d++;
        }
        u = l.firstChild;
      }
      u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i2} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`);
      let p2 = n2.someProp("clipboardTextSerializer", (_) => _(e, n2)) || e.content.textBetween(0, e.content.size, `

`);
      return { dom: l, text: p2, slice: e };
    }
    function Zd(n2, e, t, o, i2) {
      let s = i2.parent.type.spec.code, r, a;
      if (!t && !e)
        return null;
      let l = e && (o || s || !t);
      if (l) {
        if (n2.someProp("transformPastedText", (p2) => {
          e = p2(e, s || o, n2);
        }), s)
          return e ? new G(W.from(n2.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : G.empty;
        let d = n2.someProp("clipboardTextParser", (p2) => p2(e, i2, o, n2));
        if (d)
          a = d;
        else {
          let p2 = i2.marks(), { schema: _ } = n2.state, m = jr.fromSchema(_);
          r = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((f) => {
            let b = r.appendChild(document.createElement("p"));
            f && b.appendChild(m.serializeNode(_.text(f, p2)));
          });
        }
      } else
        n2.someProp("transformPastedHTML", (d) => {
          t = d(t, n2);
        }), r = Eh(t), dl && Ch(r);
      let u = r && r.querySelector("[data-pm-slice]"), c2 = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
      if (c2 && c2[3])
        for (let d = +c2[3]; d > 0; d--) {
          let p2 = r.firstChild;
          for (; p2 && p2.nodeType != 1; )
            p2 = p2.nextSibling;
          if (!p2)
            break;
          r = p2;
        }
      if (a || (a = (n2.someProp("clipboardParser") || n2.someProp("domParser") || wm.fromSchema(n2.state.schema)).parseSlice(r, {
        preserveWhitespace: !!(l || c2),
        context: i2,
        ruleFromNode(p2) {
          return p2.nodeName == "BR" && !p2.nextSibling && p2.parentNode && !yh.test(p2.parentNode.nodeName) ? { ignore: true } : null;
        }
      })), c2)
        a = Sh(Hu(a, +c2[1], +c2[2]), c2[4]);
      else if (a = G.maxOpen(jh(a.content, i2), true), a.openStart || a.openEnd) {
        let d = 0, p2 = 0;
        for (let _ = a.content.firstChild; d < a.openStart && !_.type.spec.isolating; d++, _ = _.firstChild)
          ;
        for (let _ = a.content.lastChild; p2 < a.openEnd && !_.type.spec.isolating; p2++, _ = _.lastChild)
          ;
        a = Hu(a, d, p2);
      }
      return n2.someProp("transformPasted", (d) => {
        a = d(a, n2);
      }), a;
    }
    const yh = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function jh(n2, e) {
      if (n2.childCount < 2)
        return n2;
      for (let t = e.depth; t >= 0; t--) {
        let i2 = e.node(t).contentMatchAt(e.index(t)), s, r = [];
        if (n2.forEach((a) => {
          if (!r)
            return;
          let l = i2.findWrapping(a.type), u;
          if (!l)
            return r = null;
          if (u = r.length && s.length && Qd(l, s, a, r[r.length - 1], 0))
            r[r.length - 1] = u;
          else {
            r.length && (r[r.length - 1] = ep(r[r.length - 1], s.length));
            let c2 = Xd(a, l);
            r.push(c2), i2 = i2.matchType(c2.type), s = l;
          }
        }), r)
          return W.from(r);
      }
      return n2;
    }
    function Xd(n2, e, t = 0) {
      for (let o = e.length - 1; o >= t; o--)
        n2 = e[o].create(null, W.from(n2));
      return n2;
    }
    function Qd(n2, e, t, o, i2) {
      if (i2 < n2.length && i2 < e.length && n2[i2] == e[i2]) {
        let s = Qd(n2, e, t, o.lastChild, i2 + 1);
        if (s)
          return o.copy(o.content.replaceChild(o.childCount - 1, s));
        if (o.contentMatchAt(o.childCount).matchType(i2 == n2.length - 1 ? t.type : n2[i2 + 1]))
          return o.copy(o.content.append(W.from(Xd(t, n2, i2 + 1))));
      }
    }
    function ep(n2, e) {
      if (e == 0)
        return n2;
      let t = n2.content.replaceChild(n2.childCount - 1, ep(n2.lastChild, e - 1)), o = n2.contentMatchAt(n2.childCount).fillBefore(W.empty, true);
      return n2.copy(t.append(o));
    }
    function Oa(n2, e, t, o, i2, s) {
      let r = e < 0 ? n2.firstChild : n2.lastChild, a = r.content;
      return n2.childCount > 1 && (s = 0), i2 < o - 1 && (a = Oa(a, e, t, o, i2 + 1, s)), i2 >= t && (a = e < 0 ? r.contentMatchAt(0).fillBefore(a, s <= i2).append(a) : a.append(r.contentMatchAt(r.childCount).fillBefore(W.empty, true))), n2.replaceChild(e < 0 ? 0 : n2.childCount - 1, r.copy(a));
    }
    function Hu(n2, e, t) {
      return e < n2.openStart && (n2 = new G(Oa(n2.content, -1, e, n2.openStart, 0, n2.openEnd), e, n2.openEnd)), t < n2.openEnd && (n2 = new G(Oa(n2.content, 1, t, n2.openEnd, 0, 0), n2.openStart, t)), n2;
    }
    const np = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    let Uu = null;
    function tp() {
      return Uu || (Uu = document.implementation.createHTMLDocument("title"));
    }
    let Xr = null;
    function wh(n2) {
      let e = window.trustedTypes;
      return e ? (Xr || (Xr = e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), Xr.createHTML(n2)) : n2;
    }
    function Eh(n2) {
      let e = /^(\s*<meta [^>]*>)*/.exec(n2);
      e && (n2 = n2.slice(e[0].length));
      let t = tp().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(n2), i2;
      if ((i2 = o && np[o[1].toLowerCase()]) && (n2 = i2.map((s) => "<" + s + ">").join("") + n2 + i2.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = wh(n2), i2)
        for (let s = 0; s < i2.length; s++)
          t = t.querySelector(i2[s]) || t;
      return t;
    }
    function Ch(n2) {
      let e = n2.querySelectorAll(vo ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let t = 0; t < e.length; t++) {
        let o = e[t];
        o.childNodes.length == 1 && o.textContent == "" && o.parentNode && o.parentNode.replaceChild(n2.ownerDocument.createTextNode(" "), o);
      }
    }
    function Sh(n2, e) {
      if (!n2.size)
        return n2;
      let t = n2.content.firstChild.type.schema, o;
      try {
        o = JSON.parse(e);
      } catch {
        return n2;
      }
      let { content: i2, openStart: s, openEnd: r } = n2;
      for (let a = o.length - 2; a >= 0; a -= 2) {
        let l = t.nodes[o[a]];
        if (!l || l.hasRequiredAttrs())
          break;
        i2 = W.from(l.create(o[a + 1], i2)), s++, r++;
      }
      return new G(i2, s, r);
    }
    const Et = {}, tt = {};
    function lo(n2, e) {
      n2.input.lastSelectionOrigin = e, n2.input.lastSelectionTime = Date.now();
    }
    tt.keydown = (n2, e) => {
      let t = e;
      if (n2.input.shiftKey = t.keyCode == 16 || t.shiftKey, !ip(n2, t) && (n2.input.lastKeyCode = t.keyCode, n2.input.lastKeyCodeTime = Date.now(), !(Ji && vo && t.keyCode == 13)))
        if (t.keyCode != 229 && n2.domObserver.forceFlush(), cl && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
          let o = Date.now();
          n2.input.lastIOSEnter = o, n2.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            n2.input.lastIOSEnter == o && (n2.someProp("handleKeyDown", (i2) => i2(n2, Ud(13, "Enter"))), n2.input.lastIOSEnter = 0);
          }, 200);
        } else n2.someProp("handleKeyDown", (o) => o(n2, t)) || kh(n2, t) ? t.preventDefault() : lo(n2, "key");
    };
    tt.keyup = (n2, e) => {
      e.keyCode == 16 && (n2.input.shiftKey = false);
    };
    tt.keypress = (n2, e) => {
      let t = e;
      if (ip(n2, t) || !t.charCode || t.ctrlKey && !t.altKey || at && t.metaKey)
        return;
      if (n2.someProp("handleKeyPress", (i2) => i2(n2, t))) {
        t.preventDefault();
        return;
      }
      let o = n2.state.selection;
      if (!(o instanceof Ce) || !o.$from.sameParent(o.$to)) {
        let i2 = String.fromCharCode(t.charCode);
        !/[\r\n]/.test(i2) && !n2.someProp("handleTextInput", (s) => s(n2, o.$from.pos, o.$to.pos, i2)) && n2.dispatch(n2.state.tr.insertText(i2).scrollIntoView()), t.preventDefault();
      }
    };
    function Sr(n2) {
      return { left: n2.clientX, top: n2.clientY };
    }
    function xh(n2, e) {
      let t = e.x - n2.clientX, o = e.y - n2.clientY;
      return t * t + o * o < 100;
    }
    function _l(n2, e, t, o, i2) {
      if (o == -1)
        return false;
      let s = n2.state.doc.resolve(o);
      for (let r = s.depth + 1; r > 0; r--)
        if (n2.someProp(e, (a) => r > s.depth ? a(n2, t, s.nodeAfter, s.before(r), i2, true) : a(n2, t, s.node(r), s.before(r), i2, false)))
          return true;
      return false;
    }
    function Jo(n2, e, t) {
      if (n2.focused || n2.focus(), n2.state.selection.eq(e))
        return;
      let o = n2.state.tr.setSelection(e);
      o.setMeta("pointer", true), n2.dispatch(o);
    }
    function Th(n2, e) {
      if (e == -1)
        return false;
      let t = n2.state.doc.resolve(e), o = t.nodeAfter;
      return o && o.isAtom && xe.isSelectable(o) ? (Jo(n2, new xe(t)), true) : false;
    }
    function Ah(n2, e) {
      if (e == -1)
        return false;
      let t = n2.state.selection, o, i2;
      t instanceof xe && (o = t.node);
      let s = n2.state.doc.resolve(e);
      for (let r = s.depth + 1; r > 0; r--) {
        let a = r > s.depth ? s.nodeAfter : s.node(r);
        if (xe.isSelectable(a)) {
          o && t.$from.depth > 0 && r >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i2 = s.before(t.$from.depth) : i2 = s.before(r);
          break;
        }
      }
      return i2 != null ? (Jo(n2, xe.create(n2.state.doc, i2)), true) : false;
    }
    function Nh(n2, e, t, o, i2) {
      return _l(n2, "handleClickOn", e, t, o) || n2.someProp("handleClick", (s) => s(n2, e, o)) || (i2 ? Ah(n2, t) : Th(n2, t));
    }
    function Oh(n2, e, t, o) {
      return _l(n2, "handleDoubleClickOn", e, t, o) || n2.someProp("handleDoubleClick", (i2) => i2(n2, e, o));
    }
    function Mh(n2, e, t, o) {
      return _l(n2, "handleTripleClickOn", e, t, o) || n2.someProp("handleTripleClick", (i2) => i2(n2, e, o)) || Rh(n2, t, o);
    }
    function Rh(n2, e, t) {
      if (t.button != 0)
        return false;
      let o = n2.state.doc;
      if (e == -1)
        return o.inlineContent ? (Jo(n2, Ce.create(o, 0, o.content.size)), true) : false;
      let i2 = o.resolve(e);
      for (let s = i2.depth + 1; s > 0; s--) {
        let r = s > i2.depth ? i2.nodeAfter : i2.node(s), a = i2.before(s);
        if (r.inlineContent)
          Jo(n2, Ce.create(o, a + 1, a + 1 + r.content.size));
        else if (xe.isSelectable(r))
          Jo(n2, xe.create(o, a));
        else
          continue;
        return true;
      }
    }
    function ml(n2) {
      return $s(n2);
    }
    const op = at ? "metaKey" : "ctrlKey";
    Et.mousedown = (n2, e) => {
      let t = e;
      n2.input.shiftKey = t.shiftKey;
      let o = ml(n2), i2 = Date.now(), s = "singleClick";
      i2 - n2.input.lastClick.time < 500 && xh(t, n2.input.lastClick) && !t[op] && (n2.input.lastClick.type == "singleClick" ? s = "doubleClick" : n2.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n2.input.lastClick = { time: i2, x: t.clientX, y: t.clientY, type: s };
      let r = n2.posAtCoords(Sr(t));
      r && (s == "singleClick" ? (n2.input.mouseDown && n2.input.mouseDown.done(), n2.input.mouseDown = new Ih(n2, r, t, !!o)) : (s == "doubleClick" ? Oh : Mh)(n2, r.pos, r.inside, t) ? t.preventDefault() : lo(n2, "pointer"));
    };
    class Ih {
      constructor(e, t, o, i2) {
        this.view = e, this.pos = t, this.event = o, this.flushed = i2, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!o[op], this.allowDefault = o.shiftKey;
        let s, r;
        if (t.inside > -1)
          s = e.state.doc.nodeAt(t.inside), r = t.inside;
        else {
          let c2 = e.state.doc.resolve(t.pos);
          s = c2.parent, r = c2.depth ? c2.before() : 0;
        }
        const a = i2 ? null : o.target, l = a ? e.docView.nearestDesc(a, true) : null;
        this.target = l && l.dom.nodeType == 1 ? l.dom : null;
        let { selection: u } = e.state;
        (o.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== false || u instanceof xe && u.from <= r && u.to > r) && (this.mightDrag = {
          node: s,
          pos: r,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && Cr && !this.target.hasAttribute("contentEditable"))
        }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
          this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
        }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), lo(e, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => pl(this.view)), this.view.input.mouseDown = null;
      }
      up(e) {
        if (this.done(), !this.view.dom.contains(e.target))
          return;
        let t = this.pos;
        this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Sr(e))), this.updateAllowDefault(e), this.allowDefault || !t ? lo(this.view, "pointer") : Nh(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        Do && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        vo && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Jo(this.view, Te.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : lo(this.view, "pointer");
      }
      move(e) {
        this.updateAllowDefault(e), lo(this.view, "pointer"), e.buttons == 0 && this.done();
      }
      updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
      }
    }
    Et.touchstart = (n2) => {
      n2.input.lastTouch = Date.now(), ml(n2), lo(n2, "pointer");
    };
    Et.touchmove = (n2) => {
      n2.input.lastTouch = Date.now(), lo(n2, "pointer");
    };
    Et.contextmenu = (n2) => ml(n2);
    function ip(n2, e) {
      return n2.composing ? true : Do && Math.abs(e.timeStamp - n2.input.compositionEndedAt) < 500 ? (n2.input.compositionEndedAt = -2e8, true) : false;
    }
    const Lh = Ji ? 5e3 : -1;
    tt.compositionstart = tt.compositionupdate = (n2) => {
      if (!n2.composing) {
        n2.domObserver.flush();
        let { state: e } = n2, t = e.selection.$to;
        if (e.selection instanceof Ce && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((o) => o.type.spec.inclusive === false)))
          n2.markCursor = n2.state.storedMarks || t.marks(), $s(n2, true), n2.markCursor = null;
        else if ($s(n2, !e.selection.empty), Cr && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
          let o = n2.domSelectionRange();
          for (let i2 = o.focusNode, s = o.focusOffset; i2 && i2.nodeType == 1 && s != 0; ) {
            let r = s < 0 ? i2.lastChild : i2.childNodes[s - 1];
            if (!r)
              break;
            if (r.nodeType == 3) {
              let a = n2.domSelection();
              a && a.collapse(r, r.nodeValue.length);
              break;
            } else
              i2 = r, s = -1;
          }
        }
        n2.input.composing = true;
      }
      sp(n2, Lh);
    };
    tt.compositionend = (n2, e) => {
      n2.composing && (n2.input.composing = false, n2.input.compositionEndedAt = e.timeStamp, n2.input.compositionPendingChanges = n2.domObserver.pendingRecords().length ? n2.input.compositionID : 0, n2.input.compositionNode = null, n2.input.compositionPendingChanges && Promise.resolve().then(() => n2.domObserver.flush()), n2.input.compositionID++, sp(n2, 20));
    };
    function sp(n2, e) {
      clearTimeout(n2.input.composingTimeout), e > -1 && (n2.input.composingTimeout = setTimeout(() => $s(n2), e));
    }
    function Dh(n2) {
      for (n2.composing && (n2.input.composing = false, n2.input.compositionEndedAt = Bh()); n2.input.compositionNodes.length > 0; )
        n2.input.compositionNodes.pop().markParentsDirty();
    }
    function Bh() {
      let n2 = document.createEvent("Event");
      return n2.initEvent("event", true, true), n2.timeStamp;
    }
    function $s(n2, e = false) {
      if (!(Ji && n2.domObserver.flushingSoon >= 0)) {
        if (n2.domObserver.forceFlush(), Dh(n2), e || n2.docView && n2.docView.dirty) {
          let t = uh(n2);
          return t && !t.eq(n2.state.selection) ? n2.dispatch(n2.state.tr.setSelection(t)) : (n2.markCursor || e) && !n2.state.selection.empty ? n2.dispatch(n2.state.tr.deleteSelection()) : n2.updateState(n2.state), true;
        }
        return false;
      }
    }
    function Ph(n2, e) {
      if (!n2.dom.parentNode)
        return;
      let t = n2.dom.parentNode.appendChild(document.createElement("div"));
      t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let o = getSelection(), i2 = document.createRange();
      i2.selectNodeContents(e), n2.dom.blur(), o.removeAllRanges(), o.addRange(i2), setTimeout(() => {
        t.parentNode && t.parentNode.removeChild(t), n2.focus();
      }, 50);
    }
    const Di = Yi && Kd < 15 || cl && lh < 604;
    Et.copy = tt.cut = (n2, e) => {
      let t = e, o = n2.state.selection, i2 = t.type == "cut";
      if (o.empty)
        return;
      let s = Di ? null : t.clipboardData, r = o.content(), { dom: a, text: l } = Jd(n2, r);
      s ? (t.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : Ph(n2, a), i2 && n2.dispatch(n2.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function $h(n2) {
      return n2.openStart == 0 && n2.openEnd == 0 && n2.content.childCount == 1 ? n2.content.firstChild : null;
    }
    function zh(n2, e) {
      if (!n2.dom.parentNode)
        return;
      let t = n2.input.shiftKey || n2.state.selection.$from.parent.type.spec.code, o = n2.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
      t || (o.contentEditable = "true"), o.style.cssText = "position: fixed; left: -10000px; top: 10px", o.focus();
      let i2 = n2.input.shiftKey && n2.input.lastKeyCode != 45;
      setTimeout(() => {
        n2.focus(), o.parentNode && o.parentNode.removeChild(o), t ? Ma(n2, o.value, null, i2, e) : Ma(n2, o.textContent, o.innerHTML, i2, e);
      }, 50);
    }
    function Ma(n2, e, t, o, i2) {
      let s = Zd(n2, e, t, o, n2.state.selection.$from);
      if (n2.someProp("handlePaste", (l) => l(n2, i2, s || G.empty)))
        return true;
      if (!s)
        return false;
      let r = $h(s), a = r ? n2.state.tr.replaceSelectionWith(r, o) : n2.state.tr.replaceSelection(s);
      return n2.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
    }
    function rp(n2) {
      let e = n2.getData("text/plain") || n2.getData("Text");
      if (e)
        return e;
      let t = n2.getData("text/uri-list");
      return t ? t.replace(/\r?\n/g, " ") : "";
    }
    tt.paste = (n2, e) => {
      let t = e;
      if (n2.composing && !Ji)
        return;
      let o = Di ? null : t.clipboardData, i2 = n2.input.shiftKey && n2.input.lastKeyCode != 45;
      o && Ma(n2, rp(o), o.getData("text/html"), i2, t) ? t.preventDefault() : zh(n2, t);
    };
    class Fh {
      constructor(e, t, o) {
        this.slice = e, this.move = t, this.node = o;
      }
    }
    const ap = at ? "altKey" : "ctrlKey";
    Et.dragstart = (n2, e) => {
      let t = e, o = n2.input.mouseDown;
      if (o && o.done(), !t.dataTransfer)
        return;
      let i2 = n2.state.selection, s = i2.empty ? null : n2.posAtCoords(Sr(t)), r;
      if (!(s && s.pos >= i2.from && s.pos <= (i2 instanceof xe ? i2.to - 1 : i2.to))) {
        if (o && o.mightDrag)
          r = xe.create(n2.state.doc, o.mightDrag.pos);
        else if (t.target && t.target.nodeType == 1) {
          let d = n2.docView.nearestDesc(t.target, true);
          d && d.node.type.spec.draggable && d != n2.docView && (r = xe.create(n2.state.doc, d.posBefore));
        }
      }
      let a = (r || n2.state.selection).content(), { dom: l, text: u, slice: c2 } = Jd(n2, a);
      (!t.dataTransfer.files.length || !vo || Vd > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Di ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Di || t.dataTransfer.setData("text/plain", u), n2.dragging = new Fh(c2, !t[ap], r);
    };
    Et.dragend = (n2) => {
      let e = n2.dragging;
      window.setTimeout(() => {
        n2.dragging == e && (n2.dragging = null);
      }, 50);
    };
    tt.dragover = tt.dragenter = (n2, e) => e.preventDefault();
    tt.drop = (n2, e) => {
      let t = e, o = n2.dragging;
      if (n2.dragging = null, !t.dataTransfer)
        return;
      let i2 = n2.posAtCoords(Sr(t));
      if (!i2)
        return;
      let s = n2.state.doc.resolve(i2.pos), r = o && o.slice;
      r ? n2.someProp("transformPasted", (m) => {
        r = m(r, n2);
      }) : r = Zd(n2, rp(t.dataTransfer), Di ? null : t.dataTransfer.getData("text/html"), false, s);
      let a = !!(o && !t[ap]);
      if (n2.someProp("handleDrop", (m) => m(n2, t, r || G.empty, a))) {
        t.preventDefault();
        return;
      }
      if (!r)
        return;
      t.preventDefault();
      let l = r ? sd(n2.state.doc, s.pos, r) : s.pos;
      l == null && (l = s.pos);
      let u = n2.state.tr;
      if (a) {
        let { node: m } = o;
        m ? m.replace(u) : u.deleteSelection();
      }
      let c2 = u.mapping.map(l), d = r.openStart == 0 && r.openEnd == 0 && r.content.childCount == 1, p2 = u.doc;
      if (d ? u.replaceRangeWith(c2, c2, r.content.firstChild) : u.replaceRange(c2, c2, r), u.doc.eq(p2))
        return;
      let _ = u.doc.resolve(c2);
      if (d && xe.isSelectable(r.content.firstChild) && _.nodeAfter && _.nodeAfter.sameMarkup(r.content.firstChild))
        u.setSelection(new xe(_));
      else {
        let m = u.mapping.map(l);
        u.mapping.maps[u.mapping.maps.length - 1].forEach((f, b, h2, y) => m = y), u.setSelection(Gd(n2, _, u.doc.resolve(m)));
      }
      n2.focus(), n2.dispatch(u.setMeta("uiEvent", "drop"));
    };
    Et.focus = (n2) => {
      n2.input.lastFocus = Date.now(), n2.focused || (n2.domObserver.stop(), n2.dom.classList.add("ProseMirror-focused"), n2.domObserver.start(), n2.focused = true, setTimeout(() => {
        n2.docView && n2.hasFocus() && !n2.domObserver.currentSelection.eq(n2.domSelectionRange()) && pl(n2);
      }, 20));
    };
    Et.blur = (n2, e) => {
      let t = e;
      n2.focused && (n2.domObserver.stop(), n2.dom.classList.remove("ProseMirror-focused"), n2.domObserver.start(), t.relatedTarget && n2.dom.contains(t.relatedTarget) && n2.domObserver.currentSelection.clear(), n2.focused = false);
    };
    Et.beforeinput = (n2, e) => {
      if (vo && Ji && e.inputType == "deleteContentBackward") {
        n2.domObserver.flushSoon();
        let { domChangeCount: o } = n2.input;
        setTimeout(() => {
          if (n2.input.domChangeCount != o || (n2.dom.blur(), n2.focus(), n2.someProp("handleKeyDown", (s) => s(n2, Ud(8, "Backspace")))))
            return;
          let { $cursor: i2 } = n2.state.selection;
          i2 && i2.pos > 0 && n2.dispatch(n2.state.tr.delete(i2.pos - 1, i2.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let n2 in tt)
      Et[n2] = tt[n2];
    function Bi(n2, e) {
      if (n2 == e)
        return true;
      for (let t in n2)
        if (n2[t] !== e[t])
          return false;
      for (let t in e)
        if (!(t in n2))
          return false;
      return true;
    }
    class zs {
      constructor(e, t) {
        this.toDOM = e, this.spec = t || So, this.side = this.spec.side || 0;
      }
      map(e, t, o, i2) {
        let { pos: s, deleted: r } = e.mapResult(t.from + i2, this.side < 0 ? -1 : 1);
        return r ? null : new hn(s - o, s - o, this);
      }
      valid() {
        return true;
      }
      eq(e) {
        return this == e || e instanceof zs && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Bi(this.spec, e.spec));
      }
      destroy(e) {
        this.spec.destroy && this.spec.destroy(e);
      }
    }
    class co {
      constructor(e, t) {
        this.attrs = e, this.spec = t || So;
      }
      map(e, t, o, i2) {
        let s = e.map(t.from + i2, this.spec.inclusiveStart ? -1 : 1) - o, r = e.map(t.to + i2, this.spec.inclusiveEnd ? 1 : -1) - o;
        return s >= r ? null : new hn(s, r, this);
      }
      valid(e, t) {
        return t.from < t.to;
      }
      eq(e) {
        return this == e || e instanceof co && Bi(this.attrs, e.attrs) && Bi(this.spec, e.spec);
      }
      static is(e) {
        return e.type instanceof co;
      }
      destroy() {
      }
    }
    class fl {
      constructor(e, t) {
        this.attrs = e, this.spec = t || So;
      }
      map(e, t, o, i2) {
        let s = e.mapResult(t.from + i2, 1);
        if (s.deleted)
          return null;
        let r = e.mapResult(t.to + i2, -1);
        return r.deleted || r.pos <= s.pos ? null : new hn(s.pos - o, r.pos - o, this);
      }
      valid(e, t) {
        let { index: o, offset: i2 } = e.content.findIndex(t.from), s;
        return i2 == t.from && !(s = e.child(o)).isText && i2 + s.nodeSize == t.to;
      }
      eq(e) {
        return this == e || e instanceof fl && Bi(this.attrs, e.attrs) && Bi(this.spec, e.spec);
      }
      destroy() {
      }
    }
    class hn {
      /**
      @internal
      */
      constructor(e, t, o) {
        this.from = e, this.to = t, this.type = o;
      }
      /**
      @internal
      */
      copy(e, t) {
        return new hn(e, t, this.type);
      }
      /**
      @internal
      */
      eq(e, t = 0) {
        return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
      }
      /**
      @internal
      */
      map(e, t, o) {
        return this.type.map(e, this, t, o);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(e, t, o) {
        return new hn(e, e, new zs(t, o));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(e, t, o, i2) {
        return new hn(e, t, new co(o, i2));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(e, t, o, i2) {
        return new hn(e, t, new fl(o, i2));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof co;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof zs;
      }
    }
    const Uo = [], So = {};
    class He {
      /**
      @internal
      */
      constructor(e, t) {
        this.local = e.length ? e : Uo, this.children = t.length ? t : Uo;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(e, t) {
        return t.length ? Fs(t, e, 0, So) : $n;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(e, t, o) {
        let i2 = [];
        return this.findInner(e ?? 0, t ?? 1e9, i2, 0, o), i2;
      }
      findInner(e, t, o, i2, s) {
        for (let r = 0; r < this.local.length; r++) {
          let a = this.local[r];
          a.from <= t && a.to >= e && (!s || s(a.spec)) && o.push(a.copy(a.from + i2, a.to + i2));
        }
        for (let r = 0; r < this.children.length; r += 3)
          if (this.children[r] < t && this.children[r + 1] > e) {
            let a = this.children[r] + 1;
            this.children[r + 2].findInner(e - a, t - a, o, i2 + a, s);
          }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(e, t, o) {
        return this == $n || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, o || So);
      }
      /**
      @internal
      */
      mapInner(e, t, o, i2, s) {
        let r;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a].map(e, o, i2);
          l && l.type.valid(t, l) ? (r || (r = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
        }
        return this.children.length ? Hh(this.children, r || [], e, t, o, i2, s) : r ? new He(r.sort(xo), Uo) : $n;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(e, t) {
        return t.length ? this == $n ? He.create(e, t) : this.addInner(e, t, 0) : this;
      }
      addInner(e, t, o) {
        let i2, s = 0;
        e.forEach((a, l) => {
          let u = l + o, c2;
          if (c2 = up(t, a, u)) {
            for (i2 || (i2 = this.children.slice()); s < i2.length && i2[s] < l; )
              s += 3;
            i2[s] == l ? i2[s + 2] = i2[s + 2].addInner(a, c2, u + 1) : i2.splice(s, 0, l, l + a.nodeSize, Fs(c2, a, u + 1, So)), s += 3;
          }
        });
        let r = lp(s ? cp(t) : t, -o);
        for (let a = 0; a < r.length; a++)
          r[a].type.valid(e, r[a]) || r.splice(a--, 1);
        return new He(r.length ? this.local.concat(r).sort(xo) : this.local, i2 || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(e) {
        return e.length == 0 || this == $n ? this : this.removeInner(e, 0);
      }
      removeInner(e, t) {
        let o = this.children, i2 = this.local;
        for (let s = 0; s < o.length; s += 3) {
          let r, a = o[s] + t, l = o[s + 1] + t;
          for (let c2 = 0, d; c2 < e.length; c2++)
            (d = e[c2]) && d.from > a && d.to < l && (e[c2] = null, (r || (r = [])).push(d));
          if (!r)
            continue;
          o == this.children && (o = this.children.slice());
          let u = o[s + 2].removeInner(r, a + 1);
          u != $n ? o[s + 2] = u : (o.splice(s, 3), s -= 3);
        }
        if (i2.length) {
          for (let s = 0, r; s < e.length; s++)
            if (r = e[s])
              for (let a = 0; a < i2.length; a++)
                i2[a].eq(r, t) && (i2 == this.local && (i2 = this.local.slice()), i2.splice(a--, 1));
        }
        return o == this.children && i2 == this.local ? this : i2.length || o.length ? new He(i2, o) : $n;
      }
      forChild(e, t) {
        if (this == $n)
          return this;
        if (t.isLeaf)
          return He.empty;
        let o, i2;
        for (let a = 0; a < this.children.length; a += 3)
          if (this.children[a] >= e) {
            this.children[a] == e && (o = this.children[a + 2]);
            break;
          }
        let s = e + 1, r = s + t.content.size;
        for (let a = 0; a < this.local.length; a++) {
          let l = this.local[a];
          if (l.from < r && l.to > s && l.type instanceof co) {
            let u = Math.max(s, l.from) - s, c2 = Math.min(r, l.to) - s;
            u < c2 && (i2 || (i2 = [])).push(l.copy(u, c2));
          }
        }
        if (i2) {
          let a = new He(i2.sort(xo), Uo);
          return o ? new wo([a, o]) : a;
        }
        return o || $n;
      }
      /**
      @internal
      */
      eq(e) {
        if (this == e)
          return true;
        if (!(e instanceof He) || this.local.length != e.local.length || this.children.length != e.children.length)
          return false;
        for (let t = 0; t < this.local.length; t++)
          if (!this.local[t].eq(e.local[t]))
            return false;
        for (let t = 0; t < this.children.length; t += 3)
          if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(e) {
        return gl(this.localsInner(e));
      }
      /**
      @internal
      */
      localsInner(e) {
        if (this == $n)
          return Uo;
        if (e.inlineContent || !this.local.some(co.is))
          return this.local;
        let t = [];
        for (let o = 0; o < this.local.length; o++)
          this.local[o].type instanceof co || t.push(this.local[o]);
        return t;
      }
      forEachSet(e) {
        e(this);
      }
    }
    He.empty = new He([], []);
    He.removeOverlap = gl;
    const $n = He.empty;
    class wo {
      constructor(e) {
        this.members = e;
      }
      map(e, t) {
        const o = this.members.map((i2) => i2.map(e, t, So));
        return wo.from(o);
      }
      forChild(e, t) {
        if (t.isLeaf)
          return He.empty;
        let o = [];
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let s = this.members[i2].forChild(e, t);
          s != $n && (s instanceof wo ? o = o.concat(s.members) : o.push(s));
        }
        return wo.from(o);
      }
      eq(e) {
        if (!(e instanceof wo) || e.members.length != this.members.length)
          return false;
        for (let t = 0; t < this.members.length; t++)
          if (!this.members[t].eq(e.members[t]))
            return false;
        return true;
      }
      locals(e) {
        let t, o = true;
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let s = this.members[i2].localsInner(e);
          if (s.length)
            if (!t)
              t = s;
            else {
              o && (t = t.slice(), o = false);
              for (let r = 0; r < s.length; r++)
                t.push(s[r]);
            }
        }
        return t ? gl(o ? t : t.sort(xo)) : Uo;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(e) {
        switch (e.length) {
          case 0:
            return $n;
          case 1:
            return e[0];
          default:
            return new wo(e.every((t) => t instanceof He) ? e : e.reduce((t, o) => t.concat(o instanceof He ? o : o.members), []));
        }
      }
      forEachSet(e) {
        for (let t = 0; t < this.members.length; t++)
          this.members[t].forEachSet(e);
      }
    }
    function Hh(n2, e, t, o, i2, s, r) {
      let a = n2.slice();
      for (let u = 0, c2 = s; u < t.maps.length; u++) {
        let d = 0;
        t.maps[u].forEach((p2, _, m, f) => {
          let b = f - m - (_ - p2);
          for (let h2 = 0; h2 < a.length; h2 += 3) {
            let y = a[h2 + 1];
            if (y < 0 || p2 > y + c2 - d)
              continue;
            let C = a[h2] + c2 - d;
            _ >= C ? a[h2 + 1] = p2 <= C ? -2 : -1 : p2 >= c2 && b && (a[h2] += b, a[h2 + 1] += b);
          }
          d += b;
        }), c2 = t.maps[u].map(c2, -1);
      }
      let l = false;
      for (let u = 0; u < a.length; u += 3)
        if (a[u + 1] < 0) {
          if (a[u + 1] == -2) {
            l = true, a[u + 1] = -1;
            continue;
          }
          let c2 = t.map(n2[u] + s), d = c2 - i2;
          if (d < 0 || d >= o.content.size) {
            l = true;
            continue;
          }
          let p2 = t.map(n2[u + 1] + s, -1), _ = p2 - i2, { index: m, offset: f } = o.content.findIndex(d), b = o.maybeChild(m);
          if (b && f == d && f + b.nodeSize == _) {
            let h2 = a[u + 2].mapInner(t, b, c2 + 1, n2[u] + s + 1, r);
            h2 != $n ? (a[u] = d, a[u + 1] = _, a[u + 2] = h2) : (a[u + 1] = -2, l = true);
          } else
            l = true;
        }
      if (l) {
        let u = Uh(a, n2, e, t, i2, s, r), c2 = Fs(u, o, 0, r);
        e = c2.local;
        for (let d = 0; d < a.length; d += 3)
          a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
        for (let d = 0, p2 = 0; d < c2.children.length; d += 3) {
          let _ = c2.children[d];
          for (; p2 < a.length && a[p2] < _; )
            p2 += 3;
          a.splice(p2, 0, c2.children[d], c2.children[d + 1], c2.children[d + 2]);
        }
      }
      return new He(e.sort(xo), a);
    }
    function lp(n2, e) {
      if (!e || !n2.length)
        return n2;
      let t = [];
      for (let o = 0; o < n2.length; o++) {
        let i2 = n2[o];
        t.push(new hn(i2.from + e, i2.to + e, i2.type));
      }
      return t;
    }
    function Uh(n2, e, t, o, i2, s, r) {
      function a(l, u) {
        for (let c2 = 0; c2 < l.local.length; c2++) {
          let d = l.local[c2].map(o, i2, u);
          d ? t.push(d) : r.onRemove && r.onRemove(l.local[c2].spec);
        }
        for (let c2 = 0; c2 < l.children.length; c2 += 3)
          a(l.children[c2 + 2], l.children[c2] + u + 1);
      }
      for (let l = 0; l < n2.length; l += 3)
        n2[l + 1] == -1 && a(n2[l + 2], e[l] + s + 1);
      return t;
    }
    function up(n2, e, t) {
      if (e.isLeaf)
        return null;
      let o = t + e.nodeSize, i2 = null;
      for (let s = 0, r; s < n2.length; s++)
        (r = n2[s]) && r.from > t && r.to < o && ((i2 || (i2 = [])).push(r), n2[s] = null);
      return i2;
    }
    function cp(n2) {
      let e = [];
      for (let t = 0; t < n2.length; t++)
        n2[t] != null && e.push(n2[t]);
      return e;
    }
    function Fs(n2, e, t, o) {
      let i2 = [], s = false;
      e.forEach((a, l) => {
        let u = up(n2, a, l + t);
        if (u) {
          s = true;
          let c2 = Fs(u, a, t + l + 1, o);
          c2 != $n && i2.push(l, l + a.nodeSize, c2);
        }
      });
      let r = lp(s ? cp(n2) : n2, -t).sort(xo);
      for (let a = 0; a < r.length; a++)
        r[a].type.valid(e, r[a]) || (o.onRemove && o.onRemove(r[a].spec), r.splice(a--, 1));
      return r.length || i2.length ? new He(r, i2) : $n;
    }
    function xo(n2, e) {
      return n2.from - e.from || n2.to - e.to;
    }
    function gl(n2) {
      let e = n2;
      for (let t = 0; t < e.length - 1; t++) {
        let o = e[t];
        if (o.from != o.to)
          for (let i2 = t + 1; i2 < e.length; i2++) {
            let s = e[i2];
            if (s.from == o.from) {
              s.to != o.to && (e == n2 && (e = n2.slice()), e[i2] = s.copy(s.from, o.to), qu(e, i2 + 1, s.copy(o.to, s.to)));
              continue;
            } else {
              s.from < o.to && (e == n2 && (e = n2.slice()), e[t] = o.copy(o.from, s.from), qu(e, i2, o.copy(s.from, o.to)));
              break;
            }
          }
      }
      return e;
    }
    function qu(n2, e, t) {
      for (; e < n2.length && xo(t, n2[e]) > 0; )
        e++;
      n2.splice(e, 0, t);
    }
    class sn extends Te {
      /**
      Create a gap cursor.
      */
      constructor(e) {
        super(e, e);
      }
      map(e, t) {
        let o = e.resolve(t.map(this.head));
        return sn.valid(o) ? new sn(o) : Te.near(o);
      }
      content() {
        return G.empty;
      }
      eq(e) {
        return e instanceof sn && e.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(e, t) {
        if (typeof t.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new sn(e.resolve(t.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new hl(this.anchor);
      }
      /**
      @internal
      */
      static valid(e) {
        let t = e.parent;
        if (t.isTextblock || !qh(e) || !Kh(e))
          return false;
        let o = t.type.spec.allowGapCursor;
        if (o != null)
          return o;
        let i2 = t.contentMatchAt(e.index()).defaultType;
        return i2 && i2.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom(e, t, o = false) {
        e: for (; ; ) {
          if (!o && sn.valid(e))
            return e;
          let i2 = e.pos, s = null;
          for (let r = e.depth; ; r--) {
            let a = e.node(r);
            if (t > 0 ? e.indexAfter(r) < a.childCount : e.index(r) > 0) {
              s = a.child(t > 0 ? e.indexAfter(r) : e.index(r) - 1);
              break;
            } else if (r == 0)
              return null;
            i2 += t;
            let l = e.doc.resolve(i2);
            if (sn.valid(l))
              return l;
          }
          for (; ; ) {
            let r = t > 0 ? s.firstChild : s.lastChild;
            if (!r) {
              if (s.isAtom && !s.isText && !xe.isSelectable(s)) {
                e = e.doc.resolve(i2 + s.nodeSize * t), o = false;
                continue e;
              }
              break;
            }
            s = r, i2 += t;
            let a = e.doc.resolve(i2);
            if (sn.valid(a))
              return a;
          }
          return null;
        }
      }
    }
    sn.prototype.visible = false;
    sn.findFrom = sn.findGapCursorFrom;
    Te.jsonID("gapcursor", sn);
    class hl {
      constructor(e) {
        this.pos = e;
      }
      map(e) {
        return new hl(e.map(this.pos));
      }
      resolve(e) {
        let t = e.resolve(this.pos);
        return sn.valid(t) ? new sn(t) : Te.near(t);
      }
    }
    function qh(n2) {
      for (let e = n2.depth; e >= 0; e--) {
        let t = n2.index(e), o = n2.node(e);
        if (t == 0) {
          if (o.type.spec.isolating)
            return true;
          continue;
        }
        for (let i2 = o.child(t - 1); ; i2 = i2.lastChild) {
          if (i2.childCount == 0 && !i2.inlineContent || i2.isAtom || i2.type.spec.isolating)
            return true;
          if (i2.inlineContent)
            return false;
        }
      }
      return true;
    }
    function Kh(n2) {
      for (let e = n2.depth; e >= 0; e--) {
        let t = n2.indexAfter(e), o = n2.node(e);
        if (t == o.childCount) {
          if (o.type.spec.isolating)
            return true;
          continue;
        }
        for (let i2 = o.child(t); ; i2 = i2.firstChild) {
          if (i2.childCount == 0 && !i2.inlineContent || i2.isAtom || i2.type.spec.isolating)
            return true;
          if (i2.inlineContent)
            return false;
        }
      }
      return true;
    }
    function Vh() {
      return new dn({
        props: {
          decorations: Jh,
          createSelectionBetween(n2, e, t) {
            return e.pos == t.pos && sn.valid(t) ? new sn(t) : null;
          },
          handleClick: Gh,
          handleKeyDown: Wh,
          handleDOMEvents: { beforeinput: Yh }
        }
      });
    }
    const Wh = zd({
      ArrowLeft: ls("horiz", -1),
      ArrowRight: ls("horiz", 1),
      ArrowUp: ls("vert", -1),
      ArrowDown: ls("vert", 1)
    });
    function ls(n2, e) {
      const t = n2 == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
      return function(o, i2, s) {
        let r = o.selection, a = e > 0 ? r.$to : r.$from, l = r.empty;
        if (r instanceof Ce) {
          if (!s.endOfTextblock(t) || a.depth == 0)
            return false;
          l = false, a = o.doc.resolve(e > 0 ? a.after() : a.before());
        }
        let u = sn.findGapCursorFrom(a, e, l);
        return u ? (i2 && i2(o.tr.setSelection(new sn(u))), true) : false;
      };
    }
    function Gh(n2, e, t) {
      if (!n2 || !n2.editable)
        return false;
      let o = n2.state.doc.resolve(e);
      if (!sn.valid(o))
        return false;
      let i2 = n2.posAtCoords({ left: t.clientX, top: t.clientY });
      return i2 && i2.inside > -1 && xe.isSelectable(n2.state.doc.nodeAt(i2.inside)) ? false : (n2.dispatch(n2.state.tr.setSelection(new sn(o))), true);
    }
    function Yh(n2, e) {
      if (e.inputType != "insertCompositionText" || !(n2.state.selection instanceof sn))
        return false;
      let { $from: t } = n2.state.selection, o = t.parent.contentMatchAt(t.index()).findWrapping(n2.state.schema.nodes.text);
      if (!o)
        return false;
      let i2 = W.empty;
      for (let r = o.length - 1; r >= 0; r--)
        i2 = W.from(o[r].createAndFill(null, i2));
      let s = n2.state.tr.replace(t.pos, t.pos, new G(i2, 0, 0));
      return s.setSelection(Ce.near(s.doc.resolve(t.pos + 1))), n2.dispatch(s), false;
    }
    function Jh(n2) {
      if (!(n2.selection instanceof sn))
        return null;
      let e = document.createElement("div");
      return e.className = "ProseMirror-gapcursor", He.create(n2.doc, [hn.widget(n2.selection.head, e, { key: "gapcursor" })]);
    }
    const Zh = Extension.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          Vh()
        ];
      },
      extendNodeSchema(n2) {
        var e;
        const t = {
          name: n2.name,
          options: n2.options,
          storage: n2.storage
        };
        return {
          allowGapCursor: (e = callOrReturn(getExtensionField(n2, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
        };
      }
    }), Xh = Node.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["br", mergeAttributes(this.options.HTMLAttributes, n2)];
      },
      renderText() {
        return `
`;
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: n2, chain: e, state: t, editor: o }) => n2.first([
            () => n2.exitCode(),
            () => n2.command(() => {
              const { selection: i2, storedMarks: s } = t;
              if (i2.$from.parent.type.spec.isolating)
                return false;
              const { keepMarks: r } = this.options, { splittableMarks: a } = o.extensionManager, l = s || i2.$to.parentOffset && i2.$from.marks();
              return e().insertContent({ type: this.name }).command(({ tr: u, dispatch: c2 }) => {
                if (c2 && l && r) {
                  const d = l.filter((p2) => a.includes(p2.type.name));
                  u.ensureMarks(d);
                }
                return true;
              }).run();
            })
          ])
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    }), dp = Node.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((n2) => ({
          tag: `h${n2}`,
          attrs: { level: n2 }
        }));
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        return [`h${this.options.levels.includes(n2.attrs.level) ? n2.attrs.level : this.options.levels[0]}`, mergeAttributes(this.options.HTMLAttributes, e), 0];
      },
      addCommands() {
        return {
          setHeading: (n2) => ({ commands: e }) => this.options.levels.includes(n2.level) ? e.setNode(this.name, n2) : false,
          toggleHeading: (n2) => ({ commands: e }) => this.options.levels.includes(n2.level) ? e.toggleNode(this.name, "paragraph", n2) : false
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((n2, e) => ({
          ...n2,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((n2) => textblockTypeInputRule({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n2}})\\s$`),
          type: this.type,
          getAttributes: {
            level: n2
          }
        }));
      }
    });
    var Hs = 200, jn = function() {
    };
    jn.prototype.append = function(e) {
      return e.length ? (e = jn.from(e), !this.length && e || e.length < Hs && this.leafAppend(e) || this.length < Hs && e.leafPrepend(this) || this.appendInner(e)) : this;
    };
    jn.prototype.prepend = function(e) {
      return e.length ? jn.from(e).append(this) : this;
    };
    jn.prototype.appendInner = function(e) {
      return new Qh(this, e);
    };
    jn.prototype.slice = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? jn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
    };
    jn.prototype.get = function(e) {
      if (!(e < 0 || e >= this.length))
        return this.getInner(e);
    };
    jn.prototype.forEach = function(e, t, o) {
      t === void 0 && (t = 0), o === void 0 && (o = this.length), t <= o ? this.forEachInner(e, t, o, 0) : this.forEachInvertedInner(e, t, o, 0);
    };
    jn.prototype.map = function(e, t, o) {
      t === void 0 && (t = 0), o === void 0 && (o = this.length);
      var i2 = [];
      return this.forEach(function(s, r) {
        return i2.push(e(s, r));
      }, t, o), i2;
    };
    jn.from = function(e) {
      return e instanceof jn ? e : e && e.length ? new pp(e) : jn.empty;
    };
    var pp = /* @__PURE__ */ function(n2) {
      function e(o) {
        n2.call(this), this.values = o;
      }
      n2 && (e.__proto__ = n2), e.prototype = Object.create(n2 && n2.prototype), e.prototype.constructor = e;
      var t = { length: { configurable: true }, depth: { configurable: true } };
      return e.prototype.flatten = function() {
        return this.values;
      }, e.prototype.sliceInner = function(i2, s) {
        return i2 == 0 && s == this.length ? this : new e(this.values.slice(i2, s));
      }, e.prototype.getInner = function(i2) {
        return this.values[i2];
      }, e.prototype.forEachInner = function(i2, s, r, a) {
        for (var l = s; l < r; l++)
          if (i2(this.values[l], a + l) === false)
            return false;
      }, e.prototype.forEachInvertedInner = function(i2, s, r, a) {
        for (var l = s - 1; l >= r; l--)
          if (i2(this.values[l], a + l) === false)
            return false;
      }, e.prototype.leafAppend = function(i2) {
        if (this.length + i2.length <= Hs)
          return new e(this.values.concat(i2.flatten()));
      }, e.prototype.leafPrepend = function(i2) {
        if (this.length + i2.length <= Hs)
          return new e(i2.flatten().concat(this.values));
      }, t.length.get = function() {
        return this.values.length;
      }, t.depth.get = function() {
        return 0;
      }, Object.defineProperties(e.prototype, t), e;
    }(jn);
    jn.empty = new pp([]);
    var Qh = /* @__PURE__ */ function(n2) {
      function e(t, o) {
        n2.call(this), this.left = t, this.right = o, this.length = t.length + o.length, this.depth = Math.max(t.depth, o.depth) + 1;
      }
      return n2 && (e.__proto__ = n2), e.prototype = Object.create(n2 && n2.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten());
      }, e.prototype.getInner = function(o) {
        return o < this.left.length ? this.left.get(o) : this.right.get(o - this.left.length);
      }, e.prototype.forEachInner = function(o, i2, s, r) {
        var a = this.left.length;
        if (i2 < a && this.left.forEachInner(o, i2, Math.min(s, a), r) === false || s > a && this.right.forEachInner(o, Math.max(i2 - a, 0), Math.min(this.length, s) - a, r + a) === false)
          return false;
      }, e.prototype.forEachInvertedInner = function(o, i2, s, r) {
        var a = this.left.length;
        if (i2 > a && this.right.forEachInvertedInner(o, i2 - a, Math.max(s, a) - a, r + a) === false || s < a && this.left.forEachInvertedInner(o, Math.min(i2, a), s, r) === false)
          return false;
      }, e.prototype.sliceInner = function(o, i2) {
        if (o == 0 && i2 == this.length)
          return this;
        var s = this.left.length;
        return i2 <= s ? this.left.slice(o, i2) : o >= s ? this.right.slice(o - s, i2 - s) : this.left.slice(o, s).append(this.right.slice(0, i2 - s));
      }, e.prototype.leafAppend = function(o) {
        var i2 = this.right.leafAppend(o);
        if (i2)
          return new e(this.left, i2);
      }, e.prototype.leafPrepend = function(o) {
        var i2 = this.left.leafPrepend(o);
        if (i2)
          return new e(i2, this.right);
      }, e.prototype.appendInner = function(o) {
        return this.left.depth >= Math.max(this.right.depth, o.depth) + 1 ? new e(this.left, new e(this.right, o)) : new e(this, o);
      }, e;
    }(jn);
    const ev = 500;
    class bt {
      constructor(e, t) {
        this.items = e, this.eventCount = t;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(e, t) {
        if (this.eventCount == 0)
          return null;
        let o = this.items.length;
        for (; ; o--)
          if (this.items.get(o - 1).selection) {
            --o;
            break;
          }
        let i2, s;
        t && (i2 = this.remapping(o, this.items.length), s = i2.maps.length);
        let r = e.tr, a, l, u = [], c2 = [];
        return this.items.forEach((d, p2) => {
          if (!d.step) {
            i2 || (i2 = this.remapping(o, p2 + 1), s = i2.maps.length), s--, c2.push(d);
            return;
          }
          if (i2) {
            c2.push(new Ot(d.map));
            let _ = d.step.map(i2.slice(s)), m;
            _ && r.maybeStep(_).doc && (m = r.mapping.maps[r.mapping.maps.length - 1], u.push(new Ot(m, void 0, void 0, u.length + c2.length))), s--, m && i2.appendMap(m, s);
          } else
            r.maybeStep(d.step);
          if (d.selection)
            return a = i2 ? d.selection.map(i2.slice(s)) : d.selection, l = new bt(this.items.slice(0, o).append(c2.reverse().concat(u)), this.eventCount - 1), false;
        }, this.items.length, 0), { remaining: l, transform: r, selection: a };
      }
      // Create a new branch with the given transform added.
      addTransform(e, t, o, i2) {
        let s = [], r = this.eventCount, a = this.items, l = !i2 && a.length ? a.get(a.length - 1) : null;
        for (let c2 = 0; c2 < e.steps.length; c2++) {
          let d = e.steps[c2].invert(e.docs[c2]), p2 = new Ot(e.mapping.maps[c2], d, t), _;
          (_ = l && l.merge(p2)) && (p2 = _, c2 ? s.pop() : a = a.slice(0, a.length - 1)), s.push(p2), t && (r++, t = void 0), i2 || (l = p2);
        }
        let u = r - o.depth;
        return u > tv && (a = nv(a, u), r -= u), new bt(a.append(s), r);
      }
      remapping(e, t) {
        let o = new Ni();
        return this.items.forEach((i2, s) => {
          let r = i2.mirrorOffset != null && s - i2.mirrorOffset >= e ? o.maps.length - i2.mirrorOffset : void 0;
          o.appendMap(i2.map, r);
        }, e, t), o;
      }
      addMaps(e) {
        return this.eventCount == 0 ? this : new bt(this.items.append(e.map((t) => new Ot(t))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(e, t) {
        if (!this.eventCount)
          return this;
        let o = [], i2 = Math.max(0, this.items.length - t), s = e.mapping, r = e.steps.length, a = this.eventCount;
        this.items.forEach((p2) => {
          p2.selection && a--;
        }, i2);
        let l = t;
        this.items.forEach((p2) => {
          let _ = s.getMirror(--l);
          if (_ == null)
            return;
          r = Math.min(r, _);
          let m = s.maps[_];
          if (p2.step) {
            let f = e.steps[_].invert(e.docs[_]), b = p2.selection && p2.selection.map(s.slice(l + 1, _));
            b && a++, o.push(new Ot(m, f, b));
          } else
            o.push(new Ot(m));
        }, i2);
        let u = [];
        for (let p2 = t; p2 < r; p2++)
          u.push(new Ot(s.maps[p2]));
        let c2 = this.items.slice(0, i2).append(u).append(o), d = new bt(c2, a);
        return d.emptyItemCount() > ev && (d = d.compress(this.items.length - o.length)), d;
      }
      emptyItemCount() {
        let e = 0;
        return this.items.forEach((t) => {
          t.step || e++;
        }), e;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(e = this.items.length) {
        let t = this.remapping(0, e), o = t.maps.length, i2 = [], s = 0;
        return this.items.forEach((r, a) => {
          if (a >= e)
            i2.push(r), r.selection && s++;
          else if (r.step) {
            let l = r.step.map(t.slice(o)), u = l && l.getMap();
            if (o--, u && t.appendMap(u, o), l) {
              let c2 = r.selection && r.selection.map(t.slice(o));
              c2 && s++;
              let d = new Ot(u.invert(), l, c2), p2, _ = i2.length - 1;
              (p2 = i2.length && i2[_].merge(d)) ? i2[_] = p2 : i2.push(d);
            }
          } else r.map && o--;
        }, this.items.length, 0), new bt(jn.from(i2.reverse()), s);
      }
    }
    bt.empty = new bt(jn.empty, 0);
    function nv(n2, e) {
      let t;
      return n2.forEach((o, i2) => {
        if (o.selection && e-- == 0)
          return t = i2, false;
      }), n2.slice(t);
    }
    class Ot {
      constructor(e, t, o, i2) {
        this.map = e, this.step = t, this.selection = o, this.mirrorOffset = i2;
      }
      merge(e) {
        if (this.step && e.step && !e.selection) {
          let t = e.step.merge(this.step);
          if (t)
            return new Ot(t.getMap().invert(), t, this.selection);
        }
      }
    }
    class to {
      constructor(e, t, o, i2, s) {
        this.done = e, this.undone = t, this.prevRanges = o, this.prevTime = i2, this.prevComposition = s;
      }
    }
    const tv = 20;
    function ov(n2, e, t, o) {
      let i2 = t.getMeta(To), s;
      if (i2)
        return i2.historyState;
      t.getMeta(rv) && (n2 = new to(n2.done, n2.undone, null, 0, -1));
      let r = t.getMeta("appendedTransaction");
      if (t.steps.length == 0)
        return n2;
      if (r && r.getMeta(To))
        return r.getMeta(To).redo ? new to(n2.done.addTransform(t, void 0, o, Ts(e)), n2.undone, Ku(t.mapping.maps), n2.prevTime, n2.prevComposition) : new to(n2.done, n2.undone.addTransform(t, void 0, o, Ts(e)), null, n2.prevTime, n2.prevComposition);
      if (t.getMeta("addToHistory") !== false && !(r && r.getMeta("addToHistory") === false)) {
        let a = t.getMeta("composition"), l = n2.prevTime == 0 || !r && n2.prevComposition != a && (n2.prevTime < (t.time || 0) - o.newGroupDelay || !iv(t, n2.prevRanges)), u = r ? Qr(n2.prevRanges, t.mapping) : Ku(t.mapping.maps);
        return new to(n2.done.addTransform(t, l ? e.selection.getBookmark() : void 0, o, Ts(e)), bt.empty, u, t.time, a ?? n2.prevComposition);
      } else return (s = t.getMeta("rebased")) ? new to(n2.done.rebased(t, s), n2.undone.rebased(t, s), Qr(n2.prevRanges, t.mapping), n2.prevTime, n2.prevComposition) : new to(n2.done.addMaps(t.mapping.maps), n2.undone.addMaps(t.mapping.maps), Qr(n2.prevRanges, t.mapping), n2.prevTime, n2.prevComposition);
    }
    function iv(n2, e) {
      if (!e)
        return false;
      if (!n2.docChanged)
        return true;
      let t = false;
      return n2.mapping.maps[0].forEach((o, i2) => {
        for (let s = 0; s < e.length; s += 2)
          o <= e[s + 1] && i2 >= e[s] && (t = true);
      }), t;
    }
    function Ku(n2) {
      let e = [];
      for (let t = n2.length - 1; t >= 0 && e.length == 0; t--)
        n2[t].forEach((o, i2, s, r) => e.push(s, r));
      return e;
    }
    function Qr(n2, e) {
      if (!n2)
        return null;
      let t = [];
      for (let o = 0; o < n2.length; o += 2) {
        let i2 = e.map(n2[o], 1), s = e.map(n2[o + 1], -1);
        i2 <= s && t.push(i2, s);
      }
      return t;
    }
    function sv(n2, e, t) {
      let o = Ts(e), i2 = To.get(e).spec.config, s = (t ? n2.undone : n2.done).popEvent(e, o);
      if (!s)
        return null;
      let r = s.selection.resolve(s.transform.doc), a = (t ? n2.done : n2.undone).addTransform(s.transform, e.selection.getBookmark(), i2, o), l = new to(t ? a : s.remaining, t ? s.remaining : a, null, 0, -1);
      return s.transform.setSelection(r).setMeta(To, { redo: t, historyState: l });
    }
    let ea = false, Vu = null;
    function Ts(n2) {
      let e = n2.plugins;
      if (Vu != e) {
        ea = false, Vu = e;
        for (let t = 0; t < e.length; t++)
          if (e[t].spec.historyPreserveItems) {
            ea = true;
            break;
          }
      }
      return ea;
    }
    const To = new en("history"), rv = new en("closeHistory");
    function av(n2 = {}) {
      return n2 = {
        depth: n2.depth || 100,
        newGroupDelay: n2.newGroupDelay || 500
      }, new dn({
        key: To,
        state: {
          init() {
            return new to(bt.empty, bt.empty, null, 0, -1);
          },
          apply(e, t, o) {
            return ov(t, o, e, n2);
          }
        },
        config: n2,
        props: {
          handleDOMEvents: {
            beforeinput(e, t) {
              let o = t.inputType, i2 = o == "historyUndo" ? mp : o == "historyRedo" ? fp : null;
              return i2 ? (t.preventDefault(), i2(e.state, e.dispatch)) : false;
            }
          }
        }
      });
    }
    function _p(n2, e) {
      return (t, o) => {
        let i2 = To.getState(t);
        if (!i2 || (n2 ? i2.undone : i2.done).eventCount == 0)
          return false;
        if (o) {
          let s = sv(i2, t, n2);
          s && o(s.scrollIntoView());
        }
        return true;
      };
    }
    const mp = _p(false), fp = _p(true), lv = Extension.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state: n2, dispatch: e }) => mp(n2, e),
          redo: () => ({ state: n2, dispatch: e }) => fp(n2, e)
        };
      },
      addProseMirrorPlugins() {
        return [
          av(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-": () => this.editor.commands.undo(),
          "Shift-Mod-": () => this.editor.commands.redo()
        };
      }
    }), gp = Node.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["hr", mergeAttributes(this.options.HTMLAttributes, n2)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain: n2, state: e }) => {
            const { selection: t } = e, { $from: o, $to: i2 } = t, s = n2();
            return o.parentOffset === 0 ? s.insertContentAt({
              from: Math.max(o.pos - 1, 0),
              to: i2.pos
            }, {
              type: this.name
            }) : isNodeSelection(t) ? s.insertContentAt(i2.pos, {
              type: this.name
            }) : s.insertContent({ type: this.name }), s.command(({ tr: r, dispatch: a }) => {
              var l;
              if (a) {
                const { $to: u } = r.selection, c2 = u.end();
                if (u.nodeAfter)
                  u.nodeAfter.isTextblock ? r.setSelection(Ce.create(r.doc, u.pos + 1)) : u.nodeAfter.isBlock ? r.setSelection(xe.create(r.doc, u.pos)) : r.setSelection(Ce.create(r.doc, u.pos));
                else {
                  const d = (l = u.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                  d && (r.insert(c2, d), r.setSelection(Ce.create(r.doc, c2 + 1)));
                }
                r.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: /^(?:---|-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    }), uv = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, cv = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, dv = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, pv = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, _v = Mark.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (n2) => n2.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (n2) => n2.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["em", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: n2 }) => n2.setMark(this.name),
          toggleItalic: () => ({ commands: n2 }) => n2.toggleMark(this.name),
          unsetItalic: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: uv,
            type: this.type
          }),
          markInputRule({
            find: dv,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: cv,
            type: this.type
          }),
          markPasteRule({
            find: pv,
            type: this.type
          })
        ];
      }
    }), mv = Node.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["li", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    }), fv = "listItem", Wu = "textStyle", Gu = /^(\d+)\.\s$/, gv = Node.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (n2) => n2.hasAttribute("start") ? parseInt(n2.getAttribute("start") || "", 10) : 1
          },
          type: {
            default: void 0,
            parseHTML: (n2) => n2.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        const { start: e, ...t } = n2;
        return e === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, t), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: n2, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(fv, this.editor.getAttributes(Wu)).run() : n2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let n2 = wrappingInputRule({
          find: Gu,
          type: this.type,
          getAttributes: (e) => ({ start: +e[1] }),
          joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (n2 = wrappingInputRule({
          find: Gu,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Wu) }),
          joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
          editor: this.editor
        })), [
          n2
        ];
      }
    }), hp = Node.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["p", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: n2 }) => n2.setNode(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    }), hv = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, vv = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, bv = Mark.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (n2) => n2.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["s", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: n2 }) => n2.setMark(this.name),
          toggleStrike: () => ({ commands: n2 }) => n2.toggleMark(this.name),
          unsetStrike: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: hv,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: vv,
            type: this.type
          })
        ];
      }
    }), kv = Node.create({
      name: "text",
      group: "inline"
    }), yv = Extension.create({
      name: "starterKit",
      addExtensions() {
        var n2, e, t, o, i2, s, r, a, l, u, c2, d, p2, _, m, f, b, h2;
        const y = [];
        return this.options.bold !== false && y.push(Hg.configure((n2 = this.options) === null || n2 === void 0 ? void 0 : n2.bold)), this.options.blockquote !== false && y.push(Bd.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && y.push(qg.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== false && y.push(Wg.configure((o = this.options) === null || o === void 0 ? void 0 : o.code)), this.options.codeBlock !== false && y.push(Pd.configure((i2 = this.options) === null || i2 === void 0 ? void 0 : i2.codeBlock)), this.options.document !== false && y.push($d.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)), this.options.dropcursor !== false && y.push(Xg.configure((r = this.options) === null || r === void 0 ? void 0 : r.dropcursor)), this.options.gapcursor !== false && y.push(Zh.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && y.push(Xh.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== false && y.push(dp.configure((u = this.options) === null || u === void 0 ? void 0 : u.heading)), this.options.history !== false && y.push(lv.configure((c2 = this.options) === null || c2 === void 0 ? void 0 : c2.history)), this.options.horizontalRule !== false && y.push(gp.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== false && y.push(_v.configure((p2 = this.options) === null || p2 === void 0 ? void 0 : p2.italic)), this.options.listItem !== false && y.push(mv.configure((_ = this.options) === null || _ === void 0 ? void 0 : _.listItem)), this.options.orderedList !== false && y.push(gv.configure((m = this.options) === null || m === void 0 ? void 0 : m.orderedList)), this.options.paragraph !== false && y.push(hp.configure((f = this.options) === null || f === void 0 ? void 0 : f.paragraph)), this.options.strike !== false && y.push(bv.configure((b = this.options) === null || b === void 0 ? void 0 : b.strike)), this.options.text !== false && y.push(kv.configure((h2 = this.options) === null || h2 === void 0 ? void 0 : h2.text)), y;
      }
    }), jv = (n2) => {
      if (!n2.children.length)
        return;
      const e = n2.querySelectorAll("span");
      e && e.forEach((t) => {
        var o, i2;
        const s = t.getAttribute("style"), r = (i2 = (o = t.parentElement) === null || o === void 0 ? void 0 : o.closest("span")) === null || i2 === void 0 ? void 0 : i2.getAttribute("style");
        t.setAttribute("style", `${r};${s}`);
      });
    }, wv = Mark.create({
      name: "textStyle",
      priority: 101,
      addOptions() {
        return {
          HTMLAttributes: {},
          mergeNestedSpanStyles: false
        };
      },
      parseHTML() {
        return [
          {
            tag: "span",
            getAttrs: (n2) => n2.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && jv(n2), {}) : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["span", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          removeEmptyTextStyle: () => ({ tr: n2 }) => {
            const { selection: e } = n2;
            return n2.doc.nodesBetween(e.from, e.to, (t, o) => {
              if (t.isTextblock)
                return true;
              t.marks.filter((i2) => i2.type === this.type).some((i2) => Object.values(i2.attrs).some((s) => !!s)) || n2.removeMark(o, o + t.nodeSize, this.type);
            }), true;
          }
        };
      }
    }), ue = /* @__PURE__ */ defineComponent({
      __name: "OIcon",
      props: {
        name: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        small: {
          type: Boolean,
          default: false
        }
      },
      setup(n2) {
        return (e, t) => (openBlock(), createElementBlock("span", {
          class: normalizeClass(["o-icon", { small: n2.small }]),
          style: normalizeStyle({ color: n2.color })
        }, [
          createBaseVNode("i", {
            class: normalizeClass(["yiitip-icon", `icon-${n2.name}`])
          }, null, 2)
        ], 6));
      }
    }), Yu = {
      isoName: "en-us",
      nativeName: "English (US)",
      diagram: {
        name: "Text Diagram",
        flow: "Flow Diagram",
        sequence: "Sequence Diagram",
        class: "Class Diagram",
        state: "State Diagram",
        gantt: "Gantt Diagram",
        tips: "Generation of diagram and chart from text in a similar manner as markdown"
      },
      editor: {
        add: "Add",
        addMore: "Add More",
        url: "URL",
        bold: "Bold",
        italic: "Italic",
        strikethrough: "Strikethrough",
        underline: "Underline",
        textFormat: "More text format",
        list: "List",
        unorderedList: "Unordered List",
        orderedList: "Ordered List",
        todoList: "Todo List",
        subscript: "Subscript",
        superscript: "Superscript",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Toggle Fullscreen",
        quote: "Quote",
        left: "Left align",
        center: "Center align",
        right: "Right align",
        justify: "Justify align",
        print: "Print",
        outdent: "Decrease indentation",
        indent: "Increase indentation",
        indentDropdown: "Indent",
        removeFormat: "Remove formatting",
        formatting: "Formatting",
        fontFamily: "Font Family",
        defaultFont: "Default Font",
        fontSize: "Font Size",
        align: "Align",
        hr: "Insert Horizontal Rule",
        undo: "Undo",
        redo: "Redo",
        heading: "Heading & Paragraph",
        heading1: "Heading 1",
        heading2: "Heading 2",
        heading3: "Heading 3",
        heading4: "Heading 4",
        heading5: "Heading 5",
        headings: "Headings",
        paragraph: "Paragraph",
        code: "Code",
        codeBlock: "Code Block",
        size1: "Very small",
        size2: "A bit small",
        size3: "Normal",
        size4: "Medium-large",
        size5: "Big",
        size6: "Very big",
        size7: "Maximum",
        viewSource: "View Source",
        textColor: "Text Color",
        highlightColor: "Highlight Color",
        default: "Default",
        lineHeight: "Line Height",
        blockquote: "Blockquote",
        table: "Table",
        photo: "Insert Photo",
        video: "Insert Video",
        formula: "Formula",
        inlineFormula: "Inline",
        blockFormula: "Block",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancel",
        color: "Color",
        edit: "Edit",
        link: "Link",
        linkAddress: "Link Address",
        ok: "Ok",
        preview: "Preview",
        template: "Template",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        replace: "Replace",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        more: "More",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Image Preferences",
        ratio: "Ratio",
        size: "Size",
        width: "Width",
        height: "Height",
        src: "Image Source",
        caption: "Caption",
        link: "Link",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, Ev = {
      isoName: "pl",
      nativeName: "Polski",
      diagram: {
        name: "Schemat tekstowy",
        flow: "Schemat przepywu",
        sequence: "Schemat sekwencji",
        class: "Schemat klas",
        state: "Diagram stanu",
        gantt: "Diagram Gantta",
        tips: "Generowanie diagramu i wykresu z tekstu w podobny sposb jak markdown"
      },
      editor: {
        add: "Dodaj",
        addMore: "Dodaj wicej",
        url: "URL",
        bold: "Pogrubienie",
        italic: "Kursywa",
        strikethrough: "Przekrelenie",
        underline: "Podkrelenie",
        textFormat: "More text format",
        unorderedList: "Lista wypunktowana",
        orderedList: "Lista numerowana",
        list: "List",
        todoList: "Lista rzeczy do zrobienia",
        subscript: "Indeks dolny",
        superscript: "Indeks grny",
        hyperlink: "Hipercze",
        toggleFullscreen: "Przecz na tryb penoekranowy",
        quote: "Zacytuj",
        left: "Wyrwnaj do lewej",
        center: "Wyrwnaj do rodka",
        right: "Wyrwnaj do prawej",
        justify: "Wyjustuj",
        print: "Drukuj",
        outdent: "Zmniejsz wcicie",
        indent: "Zwiksz wcicie",
        indentDropdown: "Wcicie",
        removeFormat: "Usu formatowanie",
        formatting: "Formatowanie",
        fontFamily: "Nazwa czcionki",
        defaultFont: "Domylna czcionka",
        fontSize: "Rozmiar czcionki",
        align: "Wyrwnanie",
        hr: "Wstaw poziom lini",
        undo: "Cofnij",
        redo: "Przywr",
        heading: "Heading & Paragraph",
        heading1: "Nagwek 1",
        heading2: "Nagwek 2",
        heading3: "Nagwek 3",
        heading4: "Nagwek 4",
        heading5: "Nagwek 5",
        headings: "Nagwki",
        paragraph: "Paragraf",
        code: "Kod",
        codeBlock: "Blok kodu",
        size1: "Bardzo maa",
        size2: "Maa",
        size3: "Normalna",
        size4: "rednio-dua",
        size5: "Dua",
        size6: "Bardzo dua",
        size7: "Maksymalna",
        viewSource: "Poka rdo",
        textColor: "Kolor czcionki",
        highlightColor: "Kolor wyrnienia",
        default: "Dymylny",
        lineHeight: "Wysoko linii",
        blockquote: "Cytat",
        table: "Tabela",
        photo: "Wstaw obraz",
        video: "Insert Video",
        formula: "Formua",
        inlineFormula: "Formua w treci",
        blockFormula: "Blokowa formua",
        thirdPartyService: "Third party services",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Anuluj",
        edit: "Edycja",
        link: "cze",
        linkAddress: "Adres cza",
        ok: "Ok",
        preview: "Podgld",
        template: "Szablon",
        example: "Example",
        submit: "Submit",
        settings: "Settings",
        remove: "Remove",
        help: "Help",
        back: "Back",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferencje obrazu",
        ratio: "Ratio",
        size: "Rozmiar",
        width: "Szeroko",
        height: "Wysoko",
        src: "rdo obrazu",
        caption: "Nagwek",
        link: "cze",
        lockAspectRatio: "Lock aspect ratio",
        unlockAspectRatio: "Unlock aspect ratio",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Video",
        map: "Map",
        design: "Design",
        develop: "Develop",
        data: "Data",
        others: "Others",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, Cv = {
      isoName: "pt-br",
      nativeName: "Portugus (BR)",
      diagram: {
        name: "Diagrama de Texto",
        flow: "Diagrama de Fluxo",
        sequence: "Diagrama de sequncia",
        class: "Diagrama de Classe",
        state: "Diagrama de Estado",
        gantt: "Diagrama de Gantt",
        tips: "Gerao de diagrama ou grfico a partir de texto semelhante a markdown"
      },
      editor: {
        add: "Adicionar",
        addMore: "Adicione Mais",
        url: "URL",
        bold: "Negrito",
        italic: "Itlico",
        strikethrough: "Tachar",
        underline: "Sublinhado",
        textFormat: "Mais formatos de textos",
        list: "Lista",
        unorderedList: "Lista com Marcadores",
        orderedList: "Lista Numerada",
        todoList: "Lista de afazer",
        subscript: "Subscrito",
        superscript: "Sobrescrito",
        hyperlink: "Hyperlink",
        toggleFullscreen: "Alternar tela-cheia",
        quote: "Citao",
        left: "Alinhar  esquerda",
        center: "Alinhar ao centro",
        right: "Alinhar  direita",
        justify: "Justificar",
        print: "Imprimir",
        outdent: "Diminuir recuo",
        indent: "Aumentar recuo",
        indentDropdown: "Recuo",
        removeFormat: "Limpar formatao",
        formatting: "Formatao",
        fontFamily: "Fonte",
        defaultFont: "Fonte Padro",
        fontSize: "Tamanho da fontee",
        align: "Alinhamento",
        hr: "Linha Horizontal",
        undo: "Desfazer",
        redo: "Refazer",
        heading: "Heading & Paragraph",
        heading1: "Ttulo 1",
        heading2: "Ttulo 2",
        heading3: "Ttulo 3",
        heading4: "Ttulo 4",
        heading5: "Ttulo 5",
        headings: "Estilos de Pargrafo",
        paragraph: "Pargrafo",
        code: "Cdigo",
        codeBlock: "Bloco de Cdigo",
        size1: "Muito Pequeno",
        size2: "Pequeno",
        size3: "Normal",
        size4: "Mdio",
        size5: "Grande",
        size6: "Enorme",
        size7: "Mximo",
        viewSource: "Cdigo Fonte",
        textColor: "Cor do texto",
        highlightColor: "Cor do fundo",
        default: "Padro",
        lineHeight: "Espao entre linhas",
        blockquote: "Bloco de citao",
        table: "Tabela",
        photo: "Inserir Foto",
        video: "Insert Video",
        formula: "Frmula",
        inlineFormula: "Linha",
        blockFormula: "Bloco",
        thirdPartyService: "Servios de terceiros",
        horizontal: "Horizontal Rule",
        callout: "Callout",
        emoji: "Emoji",
        defaultColor: "Default Color",
        noColor: "No Color",
        delete: "Delete",
        duplicate: "Duplicate"
      },
      label: {
        ai: "AI",
        cancel: "Cancelar",
        edit: "Editar",
        link: "Link",
        linkAddress: "Endereo do Link",
        ok: "Ok",
        preview: "Pr Visualizao",
        template: "Modelo",
        example: "Exemplo",
        submit: "Enviar",
        settings: "Configuraes",
        remove: "Excluir",
        help: "Ajuda",
        back: "Voltar",
        styles: "Styles",
        basic: "Basic",
        basicBlocks: "Basic Blocks",
        common: "Common",
        media: "Media",
        image: "Image",
        video: "Video",
        model: "Model",
        modelViewer: "Model Viewer",
        toc: "Table of Contents",
        untitled: "Untitled",
        typeForCommands: "Type '/' for commands",
        empty: "Empty",
        emptyTips: "Press Enter to continue with an empty note, or select following",
        copy: "Copy",
        cut: "Cut",
        search: "Search"
      },
      table: {
        cellBackground: "Cell Background",
        insert: "Insert Table",
        remove: "Remove Table",
        addColumn: "Add Column",
        removeColumn: "Remove Column",
        addRow: "Add Row",
        removeRow: "Remove Row",
        merge: "Merge/Unmerge Cells"
      },
      image: {
        preferences: "Preferncias da Imagem",
        ratio: "Ratio",
        size: "Tamanho",
        width: "Largura",
        height: "Altura",
        src: "Origem da imagem",
        caption: "Legenda",
        link: "Link",
        lockAspectRatio: "Bloquear proporo",
        unlockAspectRatio: "Desbloquear proporo",
        original: "Original",
        small: "Small",
        medium: "Medium",
        large: "Large"
      },
      embed: {
        video: "Vdeo",
        map: "Mapa",
        design: "Design",
        develop: "Desenvolvimento",
        data: "Dados",
        others: "Outros",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "Youku",
        iqiyi: "iQiyi",
        bilibili: "Bilibili",
        qqvideo: "QQ Video",
        google_map: "Google Map",
        amap: "AMap",
        baidu_map: "Baidu Map",
        modao: "Modao",
        lanhu: "Lanhu",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "Jinshuju",
        iframe: "IFrame",
        linkTips: "Link or embed code",
        linkWarning: "Invalid link"
      },
      link: {
        back: "Back to main menu",
        edit: "Edit Link",
        off: "Disable Link",
        open: "Open Link",
        open_in_new_tab: "Open in new tab"
      }
    }, Ju = {
      isoName: "zh-hans",
      nativeName: "",
      diagram: {
        name: "",
        flow: "",
        sequence: "",
        class: "",
        state: "",
        gantt: "",
        tips: "Markdown"
      },
      editor: {
        add: "",
        addMore: "",
        url: "URL",
        bold: "",
        italic: "",
        strikethrough: "",
        underline: "",
        textFormat: "",
        list: "",
        unorderedList: "",
        orderedList: "",
        todoList: "",
        subscript: "",
        superscript: "",
        hyperlink: "",
        toggleFullscreen: "",
        quote: "",
        left: "",
        center: "",
        right: "",
        justify: "",
        print: "",
        outdent: "",
        indent: "",
        indentDropdown: "",
        removeFormat: "",
        formatting: "",
        fontFamily: "",
        defaultFont: "",
        fontSize: "",
        align: "",
        hr: "",
        undo: "",
        redo: "",
        heading: "",
        heading1: "",
        heading2: "",
        heading3: "",
        heading4: "",
        heading5: "",
        headings: "",
        paragraph: "",
        code: "",
        codeBlock: "",
        size1: "",
        size2: "",
        size3: "",
        size4: "",
        size5: "",
        size6: "",
        size7: "",
        viewSource: "",
        textColor: "",
        highlightColor: "",
        default: "",
        lineHeight: "",
        blockquote: "",
        table: "",
        photo: "",
        video: "",
        formula: "",
        inlineFormula: "",
        blockFormula: "",
        thirdPartyService: "",
        horizontal: "",
        callout: "",
        emoji: "",
        defaultColor: "",
        noColor: "",
        delete: "",
        duplicate: ""
      },
      label: {
        ai: "AI",
        cancel: "",
        color: "",
        edit: "",
        link: "",
        linkAddress: "",
        ok: "",
        preview: "",
        template: "",
        example: "",
        submit: "",
        settings: "",
        remove: "",
        replace: "",
        help: "",
        back: "",
        styles: "",
        basic: "",
        basicBlocks: "",
        common: "",
        media: "",
        image: "",
        video: "",
        model: "",
        modelViewer: "",
        more: "",
        toc: "",
        untitled: "",
        typeForCommands: " '/' ",
        empty: "",
        emptyTips: "",
        copy: "",
        cut: "",
        search: ""
      },
      table: {
        cellBackground: "",
        insert: "",
        remove: "",
        addColumn: "",
        removeColumn: "",
        addRow: "",
        removeRow: "",
        merge: "/ "
      },
      image: {
        preferences: "",
        ratio: "",
        size: "",
        width: "",
        height: "",
        src: "",
        caption: "",
        link: "",
        lockAspectRatio: "",
        unlockAspectRatio: "",
        original: "",
        small: "",
        medium: "",
        large: ""
      },
      embed: {
        video: "",
        map: "",
        design: "",
        develop: "",
        data: "",
        others: "",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "",
        iqiyi: "",
        bilibili: "Bilibili",
        qqvideo: "",
        google_map: "",
        amap: "",
        baidu_map: "",
        modao: "",
        lanhu: "",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "",
        iframe: "IFrame",
        linkTips: "",
        linkWarning: ""
      },
      link: {
        back: "",
        edit: "",
        off: "",
        open: "",
        open_in_new_tab: ""
      }
    }, Sv = {
      isoName: "zh-hant",
      nativeName: "",
      diagram: {
        name: "",
        flow: "",
        sequence: "",
        class: "",
        state: "",
        gantt: "",
        tips: "Markdown"
      },
      editor: {
        add: "",
        addMore: "",
        url: "URL",
        bold: "",
        italic: "",
        strikethrough: "",
        underline: "",
        textFormat: "",
        list: "",
        unorderedList: "",
        orderedList: "",
        todoList: "",
        subscript: "",
        superscript: "",
        hyperlink: "",
        toggleFullscreen: "",
        quote: "",
        left: "",
        center: "",
        right: "",
        justify: "",
        print: "",
        outdent: "",
        indent: "",
        indentDropdown: "",
        removeFormat: "",
        formatting: "",
        fontFamily: "",
        defaultFont: "",
        fontSize: "",
        align: "",
        hr: "",
        undo: "",
        redo: "",
        heading: "",
        heading1: "",
        heading2: "",
        heading3: "",
        heading4: "",
        heading5: "",
        headings: "",
        paragraph: "",
        code: "",
        codeBlock: "",
        size1: "",
        size2: "",
        size3: "",
        size4: "",
        size5: "",
        size6: "",
        size7: "",
        viewSource: "",
        textColor: "",
        highlightColor: "",
        default: "",
        lineHeight: "",
        blockquote: "",
        table: "",
        photo: "",
        video: "",
        formula: "",
        inlineFormula: "",
        blockFormula: "",
        thirdPartyService: "",
        horizontal: "",
        callout: "",
        emoji: "",
        defaultColor: "",
        noColor: "",
        delete: "",
        duplicate: ""
      },
      label: {
        ai: "AI",
        cancel: "",
        edit: "",
        link: "",
        linkAddress: "",
        ok: "",
        preview: "",
        template: "",
        example: "",
        submit: "",
        settings: "",
        remove: "",
        help: "",
        back: "",
        styles: "",
        basic: "",
        basicBlocks: "",
        common: "",
        media: "",
        image: "",
        video: "",
        model: "",
        modelViewer: "",
        toc: "",
        untitled: "",
        typeForCommands: " '/' ",
        empty: "",
        emptyTips: "",
        copy: "",
        cut: "",
        search: ""
      },
      table: {
        cellBackground: "",
        insert: "",
        remove: "",
        addColumn: "",
        removeColumn: "",
        addRow: "",
        removeRow: "",
        merge: "/ "
      },
      image: {
        preferences: "",
        ratio: "",
        size: "",
        width: "",
        height: "",
        src: "",
        caption: "",
        link: "",
        lockAspectRatio: "",
        unlockAspectRatio: "",
        original: "",
        small: "",
        medium: "",
        large: ""
      },
      embed: {
        video: "",
        map: "",
        design: "",
        develop: "",
        data: "",
        others: "",
        youtube: "Youtube",
        vimeo: "Vimeo",
        netflix: "Netflix",
        youku: "",
        iqiyi: "",
        bilibili: "Bilibili",
        qqvideo: "",
        google_map: "",
        amap: "",
        baidu_map: "",
        modao: "",
        lanhu: "",
        figma: "Figma",
        canva: "Canva",
        processon: "ProcessOn",
        codepen: "CodePen",
        google_forms: "Google Forms",
        jinshuju: "",
        iframe: "IFrame",
        linkTips: "",
        linkWarning: ""
      },
      link: {
        back: "",
        edit: "",
        off: "",
        open: "",
        open_in_new_tab: ""
      }
    }, vp = {
      en: Yu,
      "en-us": Yu,
      pl: Ev,
      "pt-br": Cv,
      zh: Ju,
      "zh-hans": Ju,
      "zh-hant": Sv
    }, xv = "en", Tv = vp[xv], Av = (n2) => vp[n2] || Tv;
    function Ae() {
      const n2 = inject("locale", { value: "en" }), e = computed(() => Av(n2.value));
      function t(o) {
        return o.split(".").reduce((i2, s) => {
          if (i2) return i2[s];
        }, e.value);
      }
      return {
        locale: n2,
        message: e,
        tr: t
      };
    }
    function xr() {
      const n2 = inject("darkMode", { value: false }), e = computed(() => n2.value ? "dark" : "light");
      return {
        darkMode: n2,
        theme: e
      };
    }
    function Le() {
      const n2 = inject("isEditable", { value: true });
      function e(o, i2, s = {}) {
        if (!o.isEditable) return;
        const r = o == null ? void 0 : o.chain().focus(), a = o == null ? void 0 : o.commands;
        t(a, r, i2, s);
      }
      function t(o, i2, s, r = {}) {
        switch (console.log("command", s, r), s) {
          // case 'aiViewer':
          // 	focus.setAiViewer({
          // 		content: 'init',
          // 	}).run()
          // 	break
          case "backColor":
            r.color ? o.setHighlight({ color: r.color }) : o.unsetHighlight();
            break;
          case "blockquote":
            i2.toggleBlockquote().run();
            break;
          case "bold":
            i2.toggleBold().run();
            break;
          case "bulletList":
            i2.toggleBulletList().run();
            break;
          case "callout":
            i2.toggleCallout().run();
            break;
          case "clearFormat":
            i2.unsetAllMarks().run();
            break;
          case "code":
            i2.toggleCode().run();
            break;
          case "codeBlock":
            o.toggleCodeBlock({ language: "bash" });
            break;
          // case 'columns':
          // 	commands.setColumns(2)
          // 	break
          case "content":
            o.insertContent(r.content);
            break;
          case "fontFamily":
            o.setFontFamily(r.fontFamily);
            break;
          case "foreColor":
            o.setColor(r.color);
            break;
          case "heading":
            i2.toggleHeading(r).run();
            break;
          case "horizontalRule":
            i2.setHorizontalRule().run();
            break;
          case "image":
            i2.setImage({
              src: "init"
            }).run();
            break;
          case "imageUpdate":
            i2.setImage(
              r
            ).run();
            break;
          case "italic":
            i2.toggleItalic().run();
            break;
          case "linkSet":
            i2.extendMarkRange("link").setLink(
              r
            ).run();
            break;
          case "linkUnset":
            i2.extendMarkRange("link").unsetLink().run();
            break;
          // case 'modelViewer':
          // 	focus.setModelViewer({
          // 		src: 'init',
          // 	}).run()
          // 	break
          // case 'modelViewerUpdate':
          // 	focus.setModelViewer(options).run()
          // 	break
          case "orderedList":
            i2.toggleOrderedList().run();
            break;
          case "paragraph":
            i2.setParagraph().run();
            break;
          case "strike":
            i2.toggleStrike().run();
            break;
          case "table":
            i2.insertTable({
              rows: 3,
              cols: 3,
              withHeaderRow: true
            }).run();
            break;
          case "tableAddColumn":
            i2.addColumnAfter().run();
            break;
          case "tableAddRow":
            i2.addRowAfter().run();
            break;
          case "tableCellAttribute":
            i2.setCellAttribute(r.name, r.value).run();
            break;
          case "tableDeleteColumn":
            i2.deleteColumn().run();
            break;
          case "tableDeleteRow":
            i2.deleteRow().run();
            break;
          case "tableDelete":
            i2.deleteTable().run();
            break;
          case "tableInsert":
            i2.insertTable(r).run();
            break;
          case "tableMergeCells":
            i2.mergeCells().run();
            break;
          case "tableSelectColumn":
            i2.selectColumn(r.pos).run();
            break;
          case "tableSelectRow":
            i2.selectRow(r.pos).run();
            break;
          case "tableSplitCell":
            i2.splitCell().run();
            break;
          case "taskList":
            o.toggleTaskList();
            break;
          case "textAlign":
            i2.setTextAlign(r.textAlign).run();
            break;
          case "underline":
            i2.toggleUnderline().run();
            break;
          case "video":
            i2.setVideo({
              src: "init"
            }).run();
        }
      }
      return {
        isEditable: n2,
        run: e,
        onCommand: t
      };
    }
    const bo = /* @__PURE__ */ defineComponent({
      __name: "OTooltip",
      props: {
        placement: {
          type: String,
          default: "top"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
          // default: 'click'
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 100
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        }
      },
      setup(n2) {
        const e = n2, { theme: t } = xr(), o = ref(), i2 = ref(), s = ref();
        function r() {
          s.value = jt(o.value, {
            appendTo: () => document.body,
            animation: "perspective",
            // scale, shift-away
            content: i2.value,
            duration: e.duration,
            delay: e.delay,
            interactive: true,
            offset: e.offset,
            placement: e.placement,
            trigger: e.trigger
          });
        }
        function a() {
          s.value.setProps({
            theme: t.value
          });
        }
        return watch(t, (l) => {
          a();
        }), onMounted(() => {
          r();
        }), (l, u) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: o,
          "data-tippy-role": "tooltip"
        }, [
          renderSlot(l.$slots, "trigger"),
          createBaseVNode("div", {
            ref_key: "contentRef",
            ref: i2,
            class: "tooltip-content"
          }, [
            renderSlot(l.$slots, "default")
          ], 512)
        ], 512));
      }
    }), Ke = /* @__PURE__ */ defineComponent({
      __name: "OMenubarBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n2, { emit: e }) {
        const t = e;
        return (o, i2) => (openBlock(), createBlock(bo, {
          class: "o-tooltip",
          placement: n2.placement
        }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n2.contentClass]),
              style: normalizeStyle(n2.contentStyle),
              onClick: i2[0] || (i2[0] = (s) => t("click", s))
            }, [
              createVNode(ue, {
                name: n2.icon,
                color: n2.color,
                class: normalizeClass(n2.iconClass)
              }, null, 8, ["name", "color", "class"])
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n2.tooltip), 1)
          ]),
          _: 1
        }, 8, ["placement"]));
      }
    }), Nv = /* @__PURE__ */ defineComponent({
      __name: "OSimpleCommandBtn",
      props: {
        name: {
          type: String,
          default: ""
        },
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { run: t } = Le(), { tr: o } = Ae(), i2 = computed(() => ({
          aiViewer: { icon: "auto_awesome", tooltip: o("label.ai") },
          blockquote: { icon: "format_quote_open", tooltip: o("editor.blockquote") },
          bold: { icon: "format_bold", tooltip: o("editor.bold") },
          callout: { icon: "card_text", tooltip: o("editor.callout") },
          clearFormat: { icon: "format_clear", tooltip: o("editor.removeFormat") },
          code: { icon: "code", tooltip: o("editor.code") },
          codeBlock: { icon: "code_braces", tooltip: o("editor.codeBlock") },
          columns: {
            icon: "splitscreen_vertical_add",
            tooltip: "Column",
            rotate: true
          },
          horizontalRule: { icon: "horizontal_rule", tooltip: o("editor.hr") },
          italic: { icon: "format_italic", tooltip: o("editor.italic") },
          image: { icon: "image", tooltip: o("editor.photo") },
          linkUnset: { icon: "link_off", tooltip: o("link.off") },
          modelViewer: { icon: "3d_rotation", tooltip: o("label.modelViewer") },
          strike: {
            icon: "format_strikethrough",
            tooltip: o("editor.strikethrough")
          },
          underline: { icon: "format_underlined", tooltip: o("editor.underline") },
          video: { icon: "videocam", tooltip: o("editor.video") }
        })), s = computed(() => i2.value[e.name] || {
          icon: "",
          isActive: false,
          command: () => {
          }
        });
        function r() {
          t(e.editor, e.name);
        }
        return (a, l) => {
          var u;
          return openBlock(), createBlock(Ke, {
            class: "o-simple-command-btn",
            icon: s.value.icon,
            tooltip: s.value.tooltip,
            "content-class": {
              "is-active": (u = n2.editor) == null ? void 0 : u.isActive(n2.name),
              "rotate-90": s.value.rotate
            },
            onClick: r
          }, null, 8, ["icon", "tooltip", "content-class"]);
        };
      }
    }), Ov = { class: "o-block-placeholder" }, Mv = { class: "icon" }, Rv = { class: "placeholder" }, bp = /* @__PURE__ */ defineComponent({
      __name: "OBlockPlaceholder",
      props: {
        icon: {
          type: String,
          default: "image"
        },
        placeholder: {
          type: String,
          default: ""
        }
      },
      setup(n2) {
        return (e, t) => (openBlock(), createElementBlock("section", Ov, [
          createBaseVNode("div", Mv, [
            createVNode(unref(ue), { name: n2.icon }, null, 8, ["name"])
          ]),
          createBaseVNode("div", Rv, toDisplayString(n2.placeholder), 1)
        ]));
      }
    }), ze = {
      amber: "#ffc107",
      blue: "#2172e0",
      brown: "#795548",
      cyan: "#00bcd4",
      deepOrange: "#ff5722",
      deepPurple: "#673ab7",
      green: "#4caf50",
      indigo: "#3f51b5",
      lightBlue: "#03a9f4",
      lightGreen: "#8bc34a",
      lime: "#cddc39",
      orange: "#ff9800",
      purple: "#9c27b0",
      pink: "#e91e63",
      red: "#f44336",
      teal: "#009688",
      yellow: "#ffeb3b"
    }, Zi = [
      {
        label: "editor.paragraph",
        value: "paragraph",
        icon: "title",
        // title, format_paragraph, local_parking
        color: "",
        style: true,
        group: "label.basic"
      },
      {
        label: "editor.heading1",
        value: "heading",
        icon: "format_h1",
        color: ze.blue,
        style: true,
        options: { level: 1 }
      },
      {
        label: "editor.heading2",
        value: "heading",
        icon: "format_h2",
        color: ze.blue,
        style: true,
        options: { level: 2 }
      },
      {
        label: "editor.heading3",
        value: "heading",
        icon: "format_h3",
        color: ze.blue,
        style: true,
        options: { level: 3 }
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        color: ze.indigo,
        style: true
      },
      {
        label: "editor.unorderedList",
        value: "bulletList",
        icon: "format_list_bulleted",
        color: ze.indigo,
        style: true
      },
      {
        label: "editor.orderedList",
        value: "orderedList",
        icon: "format_list_numbered",
        color: ze.indigo,
        style: true
      },
      {
        label: "editor.blockquote",
        value: "blockquote",
        icon: "format_quote_open",
        color: ze.brown,
        style: true
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        color: ze.lightBlue,
        style: true
      },
      {
        label: "editor.horizontal",
        value: "horizontalRule",
        icon: "horizontal_rule",
        color: ze.blue
      },
      {
        label: "editor.callout",
        value: "callout",
        color: ze.deepOrange,
        icon: "card_text",
        style: false
      },
      {
        label: "editor.emoji",
        value: "emoji",
        icon: "emoji_emotions",
        color: ze.blue
      }
    ], Us = Zi.filter((n2) => n2.style), Pi = [
      {
        label: "label.ai",
        value: "aiViewer",
        icon: "auto_awesome",
        color: ze.purple,
        tips: "ai",
        group: "label.ai"
      },
      {
        label: "editor.callout",
        value: "callout",
        icon: "card_text",
        color: ze.deepOrange,
        tips: "callout",
        group: "label.common"
      },
      {
        label: "editor.table",
        value: "table",
        icon: "window",
        tips: "table",
        color: ze.cyan
      },
      {
        label: "editor.codeBlock",
        value: "codeBlock",
        icon: "code_braces",
        tips: "code",
        color: ze.blue
      },
      {
        label: "editor.todoList",
        value: "taskList",
        icon: "check_box",
        tips: "task",
        color: ze.indigo
      },
      {
        label: "label.image",
        value: "image",
        icon: "image",
        color: ze.amber,
        tips: "image",
        group: "label.media"
      },
      {
        label: "label.video",
        value: "video",
        icon: "videocam",
        tips: "video",
        color: ze.purple
      },
      {
        label: "label.model",
        value: "modelViewer",
        icon: "3d_rotation",
        tips: "model",
        color: ze.purple
      }
    ], vl = [...Zi, ...Pi], Zu = [
      {
        label: "editor.duplicate",
        value: "duplicate",
        icon: "content_copy",
        color: ze.blue,
        tips: "Ctrl+D",
        group: "label.common",
        filter: "common"
      },
      {
        label: "editor.delete",
        value: "delete",
        icon: "delete",
        tips: "Ctrl+D",
        color: ze.deepOrange,
        filter: "common"
      },
      {
        label: "label.replace",
        value: "replace",
        icon: "cached",
        tips: "Ctrl+R",
        color: ze.blue,
        filter: "image,video,model"
      },
      {
        label: "label.color",
        value: "palette",
        icon: "palette",
        color: ze.purple,
        filter: "callout",
        component: "OCalloutColorBoard"
      }
    ], Iv = {
      key: 1,
      class: "group o-tips"
    }, Lv = { class: "suffix o-tips" }, Dv = {
      key: 1,
      class: "item"
    }, ri = /* @__PURE__ */ defineComponent({
      __name: "OBlockMenu",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        },
        colorful: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: Boolean,
          default: false
        }
      },
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: i2 } = Ae(), s = ref([]), r = computed(() => {
          var _;
          return (_ = t.node) == null ? void 0 : _.type.name;
        }), a = computed(() => {
          const _ = Zu.filter(
            (f) => {
              var b;
              return ((b = f.filter) == null ? void 0 : b.indexOf("common")) >= 0;
            }
          ), m = Zu.filter(
            (f) => {
              var b;
              return ((b = f.filter) == null ? void 0 : b.indexOf(r.value)) >= 0;
            }
          );
          if (m.length > 0) {
            const f = m[0];
            f.group = `editor.${r.value}`;
          }
          return [..._, ...m];
        });
        function l(_) {
          switch (_.component) {
            case "OCalloutColorBoard":
              return yp;
            default:
              return null;
          }
        }
        function u(_) {
          o("action", _), setTimeout(() => {
            c2(_);
          }, 0);
        }
        function c2(_) {
          switch (_.value) {
            case "delete":
              t.deleteNode();
              break;
            case "duplicate":
              d();
              break;
          }
        }
        function d() {
          var h2, y, C;
          const _ = t.node.nodeSize, m = t.getPos() + _, f = JSON.parse(JSON.stringify(t.node));
          (h2 = t.editor) == null || h2.commands.insertContentAt(m, {
            type: "paragraph"
          }), (y = t.editor) == null || y.commands.insertContentAt(m, f);
          const b = m + _ + 1;
          (C = t.editor) == null || C.commands.focus(b);
        }
        function p2(_, m) {
          switch (console.log("select", _, m), m.name) {
            case "backColor":
              t.updateAttributes({ backColor: m.value });
              break;
            case "foreColor":
              t.updateAttributes({ borderColor: m.value });
              break;
          }
        }
        return (_, m) => (openBlock(), createBlock(unref(Ct), {
          class: "o-block-menu",
          hoverable: "",
          clickable: ""
        }, {
          default: withCtx(() => [
            a.value.length ? (openBlock(true), createElementBlock(Fragment$1, { key: 0 }, renderList(a.value, (f, b) => (openBlock(), createElementBlock(Fragment$1, { key: b }, [
              f.group ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                b > 0 ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                n2.showGroup ? (openBlock(), createElementBlock("div", Iv, toDisplayString(unref(i2)(f.group)), 1)) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true),
              l(f) ? (openBlock(), createBlock(unref(We), {
                key: 1,
                ref_for: true,
                ref: s.value[f.value],
                offset: [0, 16],
                placement: "right"
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(_t), {
                    class: "item",
                    clickable: ""
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: f.icon,
                        color: n2.colorful ? f.color : ""
                      }, null, 8, ["name", "color"])
                    ]),
                    suffix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: "navigate_next",
                        class: "o-tips"
                      })
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(i2)(f.label)), 1)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(l(f)), {
                    onSelect: (h2) => p2(f, h2)
                  }, null, 40, ["onSelect"]))
                ]),
                _: 2
              }, 1536)) : (openBlock(), createBlock(unref(_t), {
                key: 2,
                class: "item",
                clickable: "",
                onClick: (h2) => u(f)
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ue), {
                    name: f.icon,
                    color: n2.colorful ? f.color : ""
                  }, null, 8, ["name", "color"])
                ]),
                suffix: withCtx(() => [
                  createBaseVNode("div", Lv, toDisplayString(f.tips), 1)
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString(unref(i2)(f.label)), 1)
                ]),
                _: 2
              }, 1032, ["onClick"]))
            ], 64))), 128)) : (openBlock(), createElementBlock("div", Dv, "No result"))
          ]),
          _: 1
        }));
      }
    }), $i = /* @__PURE__ */ defineComponent({
      __name: "OBlockPopover",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        placement: {
          type: String,
          default: "bottom-center"
        },
        showArrow: {
          type: Boolean,
          default: false
        },
        hideClickOutside: {
          type: Boolean,
          default: false
        },
        tippyClass: {
          type: String,
          default: ""
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        }
      },
      emits: ["update:modelValue", "show", "hide"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = ref();
        function s(a) {
          o("update:modelValue", a);
        }
        function r() {
          t.hideClickOutside && o("update:modelValue", false);
        }
        return watch(
          () => t.modelValue,
          (a) => {
            var l, u;
            console.log("modelValue", a), a ? (l = i2.value) == null || l.setShow(true) : (u = i2.value) == null || u.setShow(false);
          }
        ), onMounted(() => {
          var a;
          t.modelValue && ((a = i2.value) == null || a.setShow(true));
        }), (a, l) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          placement: n2.placement,
          "tippy-class": n2.tippyClass,
          trigger: "manual",
          arrow: n2.showArrow,
          offset: n2.offset,
          show: n2.modelValue,
          "onUpdate:show": s,
          onClickoutside: r
        }, {
          trigger: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          default: withCtx(() => [
            renderSlot(a.$slots, "popover-content")
          ]),
          _: 3
        }, 8, ["placement", "tippy-class", "arrow", "offset", "show"]));
      }
    }), Bv = { class: "o-block-toolbar editable-only" }, Pv = { class: "button-group" }, kp = /* @__PURE__ */ defineComponent({
      __name: "OBlockToolbar",
      props: {
        ...En,
        type: {
          type: String,
          default: "link"
        }
      },
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: s } = Ae(), r = ref();
        function a(l) {
          var u;
          o("action", l), (u = r.value) == null || u.setShow(false);
        }
        return (l, u) => (openBlock(), createElementBlock("div", Bv, [
          createBaseVNode("section", Pv, [
            renderSlot(l.$slots, "default"),
            createVNode(unref(We), {
              ref_key: "popover",
              ref: r,
              placement: "bottom-end",
              size: "medium",
              trigger: "click",
              "show-arrow": false
            }, {
              trigger: withCtx(() => [
                createVNode(unref(yn), {
                  icon: "more_horiz",
                  tooltip: unref(s)("label.more")
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createVNode(unref(ri), mergeProps(t, { onAction: a }), null, 16)
              ]),
              _: 1
            }, 512)
          ])
        ]));
      }
    }), $v = { class: "o-callout-color-board" }, zv = { class: "fore-colors" }, Fv = { class: "color-row" }, Hv = { class: "color-row" }, Uv = { class: "back-colors" }, qv = { class: "color-row" }, Kv = { class: "color-row" }, yp = /* @__PURE__ */ defineComponent({
      __name: "OCalloutColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = e;
        function o(r, a) {
          t("select", {
            name: r,
            value: a.value
          });
        }
        const i2 = computed(() => [
          { label: "Grey", value: "#e9e9e9" },
          { label: "Brown", value: "#ffd591" },
          { label: "Orange", value: "#ffbb96" },
          { label: "Yellow", value: "#fff08f" },
          { label: "Green", value: "#b7eb8f" },
          { label: "Blue", value: "#91d5ff" },
          { label: "Purple", value: "#d3adf7" },
          { label: "Pink", value: "#ffadd2" },
          { label: "Red", value: "#ffa39e" }
        ]), s = computed(() => [
          { label: "Grey", value: "#F5F5F5" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (r, a) => (openBlock(), createElementBlock("section", $v, [
          createBaseVNode("section", zv, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Border color", -1)),
            createBaseVNode("div", Fv, [
              createVNode(unref(Ke), {
                icon: "slash_forward",
                tooltip: "No color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => o("foreColor", { value: "" }))
              }),
              n2.foreColor ? (openBlock(), createBlock(unref(Ke), {
                key: 0,
                tooltip: "Last used",
                "content-style": { borderColor: n2.foreColor },
                onClick: a[1] || (a[1] = (l) => o("foreColor", { value: n2.foreColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", Hv, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(i2.value, (l, u) => (openBlock(), createBlock(unref(Ke), {
                key: `col-${u}`,
                tooltip: l.label,
                "content-style": { borderColor: l.value },
                onClick: (c2) => o("foreColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", Uv, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", qv, [
              createVNode(unref(Ke), {
                icon: "slash_forward",
                tooltip: "Default Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => o("backColor", { value: "#F5F5F5" }))
              }),
              n2.backColor ? (openBlock(), createBlock(unref(Ke), {
                key: 0,
                "content-style": { backgroundColor: n2.backColor },
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[3] || (a[3] = (l) => o("backColor", { value: n2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", Kv, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (l, u) => (openBlock(), createBlock(unref(Ke), {
                key: `col-${u}`,
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (c2) => o("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), bl = /* @__PURE__ */ defineComponent({
      __name: "OContextMenu",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        clientX: {
          type: Number,
          default: 0
        },
        clientY: {
          type: Number,
          default: 0
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["update:modelValue"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = ref();
        computed(() => {
          var a;
          return t.clientX || ((a = t.event) == null ? void 0 : a.clientX) || 0;
        }), computed(() => {
          var a;
          return t.clientY || ((a = t.event) == null ? void 0 : a.clientY) || 0;
        });
        function s(a) {
          o("update:modelValue", a);
        }
        function r() {
          o("update:modelValue", false);
        }
        return watch(
          () => t.modelValue,
          (a) => {
            var l;
            a ? setTimeout(() => {
              var u;
              (u = i2.value) == null || u.setShow(a);
            }, 0) : (l = i2.value) == null || l.setShow(a);
          }
        ), (a, l) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          placement: "bottom-start",
          trigger: "manual",
          show: n2.modelValue,
          "show-arrow": false,
          event: n2.event,
          "onUpdate:show": s,
          onClickoutside: r
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["show", "event"]));
      }
    }), Vv = { class: "o-color-board" }, Wv = { class: "cell-container" }, Gv = { class: "label" }, Yv = ["onClick"], kl = /* @__PURE__ */ defineComponent({
      __name: "OColorBoard",
      props: {
        defaultColor: {
          type: String,
          default: ""
        },
        defaultLabel: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = n2, o = e;
        function i2(l) {
          o("select", l.hex);
        }
        function s(l) {
          return t.activeColor === l;
        }
        function r(l) {
          return "abc";
        }
        const a = computed(() => [
          [
            { label: "color", rgb: "rgb(0, 0, 0)", hex: "#000000" },
            { label: "color", rgb: "rgb(38, 38, 38)", hex: "#262626" },
            { label: "color", rgb: "rgb(89, 89, 89)", hex: "#595959" },
            { label: "color", rgb: "rgb(140, 140, 140)", hex: "#8c8c8c" },
            { label: "color", rgb: "rgb(191, 191, 191)", hex: "#bfbfbf" },
            { label: "color", rgb: "rgb(217, 217, 217)", hex: "#d9d9d9" },
            { label: "color", rgb: "rgb(233, 233, 233)", hex: "#e9e9e9" },
            { label: "color", rgb: "rgb(245, 245, 245)", hex: "#f5f5f5" },
            {
              label: "color",
              rgb: "rgb(250, 250, 250)",
              hex: "#fafafa",
              border: true
            },
            {
              label: "color",
              rgb: "rgb(255, 255, 255)",
              hex: "#ffffff",
              border: true
            }
          ],
          [
            { label: "color", rgb: "rgb(245, 34, 45)", hex: "#f5222d" },
            { label: "color", rgb: "rgb(250, 84, 28)", hex: "#fa541c" },
            { label: "color", rgb: "rgb(250, 140, 22)", hex: "#fa8c16" },
            { label: "color", rgb: "rgb(250, 219, 20)", hex: "#fadb14" },
            { label: "color", rgb: "rgb(82, 196, 26)", hex: "#52c41a" },
            { label: "color", rgb: "rgb(19, 194, 194)", hex: "#13c2c2" },
            { label: "color", rgb: "rgb(24, 144, 255)", hex: "#1890ff" },
            { label: "color", rgb: "rgb(47, 84, 235)", hex: "#2f54eb" },
            { label: "color", rgb: "rgb(114, 46, 209)", hex: "#722ed1" },
            { label: "color", rgb: "rgb(235, 47, 150)", hex: "#eb2f96" }
          ],
          [
            { label: "color", rgb: "rgb(255, 232, 230)", hex: "#ffe8e6" },
            { label: "color", rgb: "rgb(255, 236, 224)", hex: "#ffece0" },
            { label: "color", rgb: "rgb(255, 239, 209)", hex: "#ffefd1" },
            { label: "color", rgb: "rgb(255, 248, 189)", hex: "#fff8bd" },
            { label: "color", rgb: "rgb(228, 247, 210)", hex: "#e4f7d2" },
            { label: "color", rgb: "rgb(211, 245, 240)", hex: "#d3f5f0" },
            { label: "color", rgb: "rgb(212, 238, 252)", hex: "#d4eefc" },
            { label: "color", rgb: "rgb(222, 232, 252)", hex: "#dee8fc" },
            { label: "color", rgb: "rgb(239, 225, 250)", hex: "#efe1fa" },
            { label: "color", rgb: "rgb(250, 225, 235)", hex: "#fae1eb" }
          ],
          [
            { label: "color", rgb: "rgb(255, 163, 158)", hex: "#ffa39e" },
            { label: "color", rgb: "rgb(255, 187, 150)", hex: "#ffbb96" },
            { label: "color", rgb: "rgb(255, 213, 145)", hex: "#ffd591" },
            { label: "color", rgb: "rgb(255, 240, 143)", hex: "#fff08f" },
            { label: "color", rgb: "rgb(183, 235, 143)", hex: "#b7eb8f" },
            { label: "color", rgb: "rgb(135, 232, 222)", hex: "#87e8de" },
            { label: "color", rgb: "rgb(145, 213, 255)", hex: "#91d5ff" },
            { label: "color", rgb: "rgb(173, 198, 255)", hex: "#adc6ff" },
            { label: "color", rgb: "rgb(211, 173, 247)", hex: "#d3adf7" },
            { label: "color", rgb: "rgb(255, 173, 210)", hex: "#ffadd2" }
          ],
          [
            { label: "color", rgb: "rgb(255, 77, 79)", hex: "#ff4d4f" },
            { label: "color", rgb: "rgb(255, 122, 69)", hex: "#ff7a45" },
            { label: "color", rgb: "rgb(255, 169, 64)", hex: "#ffa940" },
            { label: "color", rgb: "rgb(255, 236, 61)", hex: "#ffec3d" },
            { label: "color", rgb: "rgb(115, 209, 61)", hex: "#73d13d" },
            { label: "color", rgb: "rgb(54, 207, 201)", hex: "#36cfc9" },
            { label: "color", rgb: "rgb(64, 169, 255)", hex: "#40a9ff" },
            { label: "color", rgb: "rgb(89, 126, 247)", hex: "#597ef7" },
            { label: "color", rgb: "rgb(146, 84, 222)", hex: "#9254de" },
            { label: "color", rgb: "rgb(247, 89, 171)", hex: "#f759ab" }
          ],
          [
            { label: "color", rgb: "rgb(207, 19, 34)", hex: "#cf1322" },
            { label: "color", rgb: "rgb(212, 56, 13)", hex: "#d4380d" },
            { label: "color", rgb: "rgb(212, 107, 8)", hex: "#d46b08" },
            { label: "color", rgb: "rgb(212, 177, 6)", hex: "#d4b106" },
            { label: "color", rgb: "rgb(56, 158, 13)", hex: "#389e0d" },
            { label: "color", rgb: "rgb(8, 151, 156)", hex: "#08979c" },
            { label: "color", rgb: "rgb(9, 109, 217)", hex: "#096dd9" },
            { label: "color", rgb: "rgb(29, 57, 196)", hex: "#1d39c4" },
            { label: "color", rgb: "rgb(83, 29, 171)", hex: "#531dab" },
            { label: "color", rgb: "rgb(196, 29, 127)", hex: "#c41d7f" }
          ],
          [
            { label: "color", rgb: "rgb(130, 0, 20)", hex: "#820014" },
            { label: "color", rgb: "rgb(135, 20, 0)", hex: "#871400" },
            { label: "color", rgb: "rgb(135, 56, 0)", hex: "#873800" },
            { label: "color", rgb: "rgb(97, 71, 0)", hex: "#614700" },
            { label: "color", rgb: "rgb(19, 82, 0)", hex: "#135200" },
            { label: "color", rgb: "rgb(0, 71, 79)", hex: "#00474f" },
            { label: "color", rgb: "rgb(0, 58, 140)", hex: "#003a8c" },
            { label: "color", rgb: "rgb(6, 17, 120)", hex: "#061178" },
            { label: "color", rgb: "rgb(34, 7, 94)", hex: "#22075e" },
            { label: "color", rgb: "rgb(120, 6, 80)", hex: "#780650" }
          ]
        ]);
        return (l, u) => (openBlock(), createElementBlock("section", Vv, [
          createBaseVNode("div", {
            class: "default-color",
            onClick: u[0] || (u[0] = (c2) => i2({ hex: n2.defaultColor }))
          }, [
            createBaseVNode("div", Wv, [
              createBaseVNode("div", {
                class: "cell border",
                style: normalizeStyle({ background: n2.defaultColor })
              }, [
                createVNode(unref(ue), { name: "slash_forward" })
              ], 4)
            ]),
            createBaseVNode("div", Gv, toDisplayString(n2.defaultLabel), 1)
          ]),
          (openBlock(true), createElementBlock(Fragment$1, null, renderList(a.value, (c2, d) => (openBlock(), createElementBlock("div", {
            class: "color-row",
            key: `row-${d}`
          }, [
            (openBlock(true), createElementBlock(Fragment$1, null, renderList(c2, (p2, _) => (openBlock(), createElementBlock("div", {
              class: "",
              key: `col-${_}`
            }, [
              createBaseVNode("div", {
                class: "cell-container",
                onClick: (m) => i2(p2)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["cell", { border: p2.border }]),
                  style: normalizeStyle({ backgroundColor: p2.hex })
                }, [
                  s(p2.hex) ? (openBlock(), createBlock(unref(ue), {
                    key: 0,
                    name: "done",
                    style: normalizeStyle({ color: r(p2.rgb) })
                  }, null, 8, ["style"])) : createCommentVNode("", true)
                ], 6)
              ], 8, Yv)
            ]))), 128))
          ]))), 128))
        ]));
      }
    }), yn = /* @__PURE__ */ defineComponent({
      __name: "OCommandBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n2, { emit: e }) {
        const t = e;
        return (o, i2) => (openBlock(), createBlock(unref(bo), { placement: n2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n2.contentClass]),
              style: normalizeStyle(n2.contentStyle),
              onClick: i2[0] || (i2[0] = (s) => t("click", s))
            }, [
              createVNode(unref(ue), {
                name: n2.icon,
                color: n2.color,
                class: normalizeClass(n2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(o.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), Ra = /* @__PURE__ */ defineComponent({
      __name: "OCommonBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        background: {
          type: String,
          default: ""
        },
        tooltip: {
          type: String,
          default: ""
        },
        placement: {
          type: String,
          default: "top"
        },
        disabled: {
          type: Boolean,
          default: false
        },
        contentClass: {
          type: [String, Object],
          default: ""
        },
        contentStyle: {
          type: [String, Object],
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        }
      },
      emits: ["click"],
      setup(n2, { emit: e }) {
        const t = e;
        return (o, i2) => (openBlock(), createBlock(unref(bo), { placement: n2.placement }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-menubar-btn o-command-btn o-btn", n2.contentClass]),
              style: normalizeStyle(n2.contentStyle),
              onClick: i2[0] || (i2[0] = (s) => t("click", s))
            }, [
              createVNode(unref(ue), {
                name: n2.icon,
                color: n2.color,
                class: normalizeClass(n2.iconClass)
              }, null, 8, ["name", "color", "class"]),
              renderSlot(o.$slots, "default")
            ], 6)
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString(n2.tooltip), 1)
          ]),
          _: 3
        }, 8, ["placement"]));
      }
    }), Jv = {
      key: 0,
      class: "o-doc-toc toc"
    }, Zv = { class: "mini-view" }, Xv = { class: "toc__list" }, Qv = { class: "main-view" }, e0 = { class: "toc__title" }, n0 = { class: "toc__list" }, t0 = ["onClick"], o0 = /* @__PURE__ */ defineComponent({
      __name: "ODocToc",
      props: {
        editor: {
          type: Editor
        },
        maxLevel: {
          type: Number,
          default: 3
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), o = ref([]), i2 = ref("");
        function s() {
          var c2;
          i2.value = window.location.hash, (c2 = e.editor) == null || c2.on("update", a), setTimeout(() => {
            r(), a();
          }, 0);
        }
        function r() {
          const c2 = document.querySelector(".yiitap"), d = c2 == null ? void 0 : c2.parentElement;
          d == null || d.addEventListener("scroll", l);
        }
        function a() {
          var d;
          const c2 = [];
          (d = e.editor) == null || d.state.doc.descendants((p2, _) => {
            if (p2.type.name === "heading") {
              const m = p2.attrs["data-id"];
              c2.push({
                level: p2.attrs.level,
                text: p2.textContent,
                id: m
              });
            }
          }), o.value = c2;
        }
        function l(c2) {
          for (const d of o.value) {
            const _ = document.querySelector(`[data-id="${d.id}"]`).getBoundingClientRect();
            if (_.top >= 0 && _.top < window.innerHeight / 2) {
              i2.value = d.id;
              break;
            }
          }
        }
        function u(c2) {
          i2.value = c2.id;
          const d = document.querySelector(`[data-id="${c2.id}"]`);
          d && d.scrollIntoView({ behavior: "smooth", block: "start" });
        }
        return watch(
          () => e.editor,
          (c2) => {
            s();
          }
        ), (c2, d) => o.value.length ? (openBlock(), createElementBlock("section", Jv, [
          createVNode(unref(We), {
            ref: "popover",
            "tippy-class": "o-toc-popover",
            placement: "left-start",
            offset: [0, -50],
            delay: 0,
            duration: 100
          }, {
            trigger: withCtx(() => [
              createBaseVNode("div", Zv, [
                createBaseVNode("ul", Xv, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(o.value, (p2, _) => (openBlock(), createElementBlock(Fragment$1, { key: _ }, [
                    p2.level <= Math.max(Math.min(n2.maxLevel, 3), 2) ? (openBlock(), createElementBlock("li", {
                      key: 0,
                      class: normalizeClass(["toc__item", [
                        i2.value === p2.id ? "selected" : "",
                        `toc__item--${p2.level}`
                      ]])
                    }, null, 2)) : createCommentVNode("", true)
                  ], 64))), 128))
                ])
              ])
            ]),
            default: withCtx(() => [
              createBaseVNode("div", Qv, [
                createBaseVNode("div", e0, toDisplayString(unref(t)("label.toc")), 1),
                createBaseVNode("ul", n0, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(o.value, (p2, _) => (openBlock(), createElementBlock("li", {
                    class: normalizeClass(["toc__item", `toc__item--${p2.level}`]),
                    key: _
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(["heading", { selected: i2.value === p2.id }]),
                      onClick: (m) => u(p2)
                    }, toDisplayString(p2.text), 11, t0)
                  ], 2))), 128))
                ])
              ])
            ]),
            _: 1
          }, 512)
        ])) : createCommentVNode("", true);
      }
    }), yl = (n2, e) => {
      const t = n2.__vccOpts || n2;
      for (const [o, i2] of e)
        t[o] = i2;
      return t;
    }, VC = /* @__PURE__ */ yl(o0, [["__scopeId", "data-v-0c365cf2"]]), jl = /* @__PURE__ */ JSON.parse('[{"name":"Smileys & Emotion","slug":"smileys_emotion","emojis":[{"emoji":"","skin_tone_support":false,"name":"grinning face","slug":"grinning_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"grinning face with big eyes","slug":"grinning_face_with_big_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"grinning face with smiling eyes","slug":"grinning_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"beaming face with smiling eyes","slug":"beaming_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"grinning squinting face","slug":"grinning_squinting_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"grinning face with sweat","slug":"grinning_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rolling on the floor laughing","slug":"rolling_on_the_floor_laughing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"face with tears of joy","slug":"face_with_tears_of_joy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"slightly smiling face","slug":"slightly_smiling_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"upside-down face","slug":"upside_down_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"melting face","slug":"melting_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"winking face","slug":"winking_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"smiling face with smiling eyes","slug":"smiling_face_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"smiling face with halo","slug":"smiling_face_with_halo","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with hearts","slug":"smiling_face_with_hearts","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with heart-eyes","slug":"smiling_face_with_heart_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"star-struck","slug":"star_struck","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"face blowing a kiss","slug":"face_blowing_a_kiss","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kissing face","slug":"kissing_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face","slug":"smiling_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kissing face with closed eyes","slug":"kissing_face_with_closed_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kissing face with smiling eyes","slug":"kissing_face_with_smiling_eyes","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with tear","slug":"smiling_face_with_tear","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"face savoring food","slug":"face_savoring_food","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face with tongue","slug":"face_with_tongue","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"winking face with tongue","slug":"winking_face_with_tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"zany face","slug":"zany_face","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"squinting face with tongue","slug":"squinting_face_with_tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"money-mouth face","slug":"money_mouth_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with open hands","slug":"smiling_face_with_open_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with hand over mouth","slug":"face_with_hand_over_mouth","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"face with open eyes and hand over mouth","slug":"face_with_open_eyes_and_hand_over_mouth","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"face with peeking eye","slug":"face_with_peeking_eye","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"shushing face","slug":"shushing_face","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"thinking face","slug":"thinking_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"saluting face","slug":"saluting_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"zipper-mouth face","slug":"zipper_mouth_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with raised eyebrow","slug":"face_with_raised_eyebrow","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"neutral face","slug":"neutral_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"expressionless face","slug":"expressionless_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face without mouth","slug":"face_without_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"dotted line face","slug":"dotted_line_face","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"face in clouds","slug":"face_in_clouds","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":false,"name":"smirking face","slug":"smirking_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"unamused face","slug":"unamused_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face with rolling eyes","slug":"face_with_rolling_eyes","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"grimacing face","slug":"grimacing_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face exhaling","slug":"face_exhaling","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":false,"name":"lying face","slug":"lying_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"shaking face","slug":"shaking_face","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"head shaking horizontally","slug":"head_shaking_horizontally","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"head shaking vertically","slug":"head_shaking_vertically","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"relieved face","slug":"relieved_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pensive face","slug":"pensive_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sleepy face","slug":"sleepy_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"drooling face","slug":"drooling_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"sleeping face","slug":"sleeping_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with bags under eyes","slug":"face_with_bags_under_eyes","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"","skin_tone_support":false,"name":"face with medical mask","slug":"face_with_medical_mask","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face with thermometer","slug":"face_with_thermometer","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with head-bandage","slug":"face_with_head_bandage","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"nauseated face","slug":"nauseated_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"face vomiting","slug":"face_vomiting","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"sneezing face","slug":"sneezing_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"hot face","slug":"hot_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"cold face","slug":"cold_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"woozy face","slug":"woozy_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"face with crossed-out eyes","slug":"face_with_crossed_out_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face with spiral eyes","slug":"face_with_spiral_eyes","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":false,"name":"exploding head","slug":"exploding_head","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"cowboy hat face","slug":"cowboy_hat_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"partying face","slug":"partying_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"disguised face","slug":"disguised_face","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with sunglasses","slug":"smiling_face_with_sunglasses","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"nerd face","slug":"nerd_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with monocle","slug":"face_with_monocle","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"confused face","slug":"confused_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"face with diagonal mouth","slug":"face_with_diagonal_mouth","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"worried face","slug":"worried_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"slightly frowning face","slug":"slightly_frowning_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"frowning face","slug":"frowning_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"face with open mouth","slug":"face_with_open_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hushed face","slug":"hushed_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"astonished face","slug":"astonished_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flushed face","slug":"flushed_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pleading face","slug":"pleading_face","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"face holding back tears","slug":"face_holding_back_tears","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"frowning face with open mouth","slug":"frowning_face_with_open_mouth","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"anguished face","slug":"anguished_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"fearful face","slug":"fearful_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"anxious face with sweat","slug":"anxious_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sad but relieved face","slug":"sad_but_relieved_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"crying face","slug":"crying_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"loudly crying face","slug":"loudly_crying_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face screaming in fear","slug":"face_screaming_in_fear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"confounded face","slug":"confounded_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"persevering face","slug":"persevering_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"disappointed face","slug":"disappointed_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"downcast face with sweat","slug":"downcast_face_with_sweat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"weary face","slug":"weary_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tired face","slug":"tired_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"yawning face","slug":"yawning_face","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"face with steam from nose","slug":"face_with_steam_from_nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"enraged face","slug":"enraged_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"angry face","slug":"angry_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"face with symbols on mouth","slug":"face_with_symbols_on_mouth","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"smiling face with horns","slug":"smiling_face_with_horns","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"angry face with horns","slug":"angry_face_with_horns","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"skull","slug":"skull","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"skull and crossbones","slug":"skull_and_crossbones","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"pile of poo","slug":"pile_of_poo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clown face","slug":"clown_face","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"ogre","slug":"ogre","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"goblin","slug":"goblin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ghost","slug":"ghost","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"alien","slug":"alien","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"alien monster","slug":"alien_monster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"robot","slug":"robot","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"grinning cat","slug":"grinning_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"grinning cat with smiling eyes","slug":"grinning_cat_with_smiling_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cat with tears of joy","slug":"cat_with_tears_of_joy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"smiling cat with heart-eyes","slug":"smiling_cat_with_heart_eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cat with wry smile","slug":"cat_with_wry_smile","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kissing cat","slug":"kissing_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"weary cat","slug":"weary_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"crying cat","slug":"crying_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pouting cat","slug":"pouting_cat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"see-no-evil monkey","slug":"see_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hear-no-evil monkey","slug":"hear_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"speak-no-evil monkey","slug":"speak_no_evil_monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"love letter","slug":"love_letter","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart with arrow","slug":"heart_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart with ribbon","slug":"heart_with_ribbon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sparkling heart","slug":"sparkling_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"growing heart","slug":"growing_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"beating heart","slug":"beating_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"revolving hearts","slug":"revolving_hearts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"two hearts","slug":"two_hearts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart decoration","slug":"heart_decoration","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart exclamation","slug":"heart_exclamation","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"broken heart","slug":"broken_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart on fire","slug":"heart_on_fire","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":false,"name":"mending heart","slug":"mending_heart","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":false,"name":"red heart","slug":"red_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pink heart","slug":"pink_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"orange heart","slug":"orange_heart","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"yellow heart","slug":"yellow_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"green heart","slug":"green_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"blue heart","slug":"blue_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"light blue heart","slug":"light_blue_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"purple heart","slug":"purple_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"brown heart","slug":"brown_heart","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"black heart","slug":"black_heart","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"grey heart","slug":"grey_heart","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"white heart","slug":"white_heart","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"kiss mark","slug":"kiss_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hundred points","slug":"hundred_points","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"anger symbol","slug":"anger_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"collision","slug":"collision","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dizzy","slug":"dizzy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sweat droplets","slug":"sweat_droplets","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dashing away","slug":"dashing_away","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hole","slug":"hole","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"speech balloon","slug":"speech_balloon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eye in speech bubble","slug":"eye_in_speech_bubble","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"left speech bubble","slug":"left_speech_bubble","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"right anger bubble","slug":"right_anger_bubble","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"thought balloon","slug":"thought_balloon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"ZZZ","slug":"zzz","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"People & Body","slug":"people_body","emojis":[{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"waving hand","slug":"waving_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"raised back of hand","slug":"raised_back_of_hand","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"hand with fingers splayed","slug":"hand_with_fingers_splayed","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raised hand","slug":"raised_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"vulcan salute","slug":"vulcan_salute","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"rightwards hand","slug":"rightwards_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"leftwards hand","slug":"leftwards_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"palm down hand","slug":"palm_down_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"palm up hand","slug":"palm_up_hand","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.0","name":"leftwards pushing hand","slug":"leftwards_pushing_hand","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.0","name":"rightwards pushing hand","slug":"rightwards_pushing_hand","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"OK hand","slug":"ok_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"pinched fingers","slug":"pinched_fingers","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"pinching hand","slug":"pinching_hand","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"victory hand","slug":"victory_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"crossed fingers","slug":"crossed_fingers","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"hand with index finger and thumb crossed","slug":"hand_with_index_finger_and_thumb_crossed","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"love-you gesture","slug":"love_you_gesture","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"sign of the horns","slug":"sign_of_the_horns","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"call me hand","slug":"call_me_hand","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing left","slug":"backhand_index_pointing_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing right","slug":"backhand_index_pointing_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing up","slug":"backhand_index_pointing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"middle finger","slug":"middle_finger","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"backhand index pointing down","slug":"backhand_index_pointing_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"index pointing up","slug":"index_pointing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"index pointing at the viewer","slug":"index_pointing_at_the_viewer","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"thumbs up","slug":"thumbs_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"thumbs down","slug":"thumbs_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raised fist","slug":"raised_fist","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"oncoming fist","slug":"oncoming_fist","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"left-facing fist","slug":"left_facing_fist","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"right-facing fist","slug":"right_facing_fist","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"clapping hands","slug":"clapping_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"raising hands","slug":"raising_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"heart hands","slug":"heart_hands","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"open hands","slug":"open_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"palms up together","slug":"palms_up_together","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"handshake","slug":"handshake","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"folded hands","slug":"folded_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"writing hand","slug":"writing_hand","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"nail polish","slug":"nail_polish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"selfie","slug":"selfie","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"flexed biceps","slug":"flexed_biceps","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mechanical arm","slug":"mechanical_arm","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"mechanical leg","slug":"mechanical_leg","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"leg","slug":"leg","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"foot","slug":"foot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"ear","slug":"ear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"ear with hearing aid","slug":"ear_with_hearing_aid","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"nose","slug":"nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"brain","slug":"brain","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"anatomical heart","slug":"anatomical_heart","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"lungs","slug":"lungs","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"tooth","slug":"tooth","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"bone","slug":"bone","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"eyes","slug":"eyes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eye","slug":"eye","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"tongue","slug":"tongue","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mouth","slug":"mouth","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"biting lip","slug":"biting_lip","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"baby","slug":"baby","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"child","slug":"child","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"boy","slug":"boy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"girl","slug":"girl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person","slug":"person","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person blond hair","slug":"person_blond_hair","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"man","slug":"man","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person beard","slug":"person_beard","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"man beard","slug":"man_beard","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"woman beard","slug":"woman_beard","unicode_version":"13.1","emoji_version":"13.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man red hair","slug":"man_red_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man curly hair","slug":"man_curly_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man white hair","slug":"man_white_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man bald","slug":"man_bald","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"woman","slug":"woman","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman red hair","slug":"woman_red_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person red hair","slug":"person_red_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman curly hair","slug":"woman_curly_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person curly hair","slug":"person_curly_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman white hair","slug":"woman_white_hair","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person white hair","slug":"person_white_hair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman bald","slug":"woman_bald","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person bald","slug":"person_bald","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman blond hair","slug":"woman_blond_hair","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man blond hair","slug":"man_blond_hair","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"older person","slug":"older_person","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"old man","slug":"old_man","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"old woman","slug":"old_woman","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person frowning","slug":"person_frowning","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man frowning","slug":"man_frowning","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman frowning","slug":"woman_frowning","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person pouting","slug":"person_pouting","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man pouting","slug":"man_pouting","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman pouting","slug":"woman_pouting","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person gesturing NO","slug":"person_gesturing_no","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man gesturing NO","slug":"man_gesturing_no","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman gesturing NO","slug":"woman_gesturing_no","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person gesturing OK","slug":"person_gesturing_ok","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man gesturing OK","slug":"man_gesturing_ok","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman gesturing OK","slug":"woman_gesturing_ok","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person tipping hand","slug":"person_tipping_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man tipping hand","slug":"man_tipping_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman tipping hand","slug":"woman_tipping_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person raising hand","slug":"person_raising_hand","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man raising hand","slug":"man_raising_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman raising hand","slug":"woman_raising_hand","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf person","slug":"deaf_person","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf man","slug":"deaf_man","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"deaf woman","slug":"deaf_woman","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person bowing","slug":"person_bowing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man bowing","slug":"man_bowing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman bowing","slug":"woman_bowing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person facepalming","slug":"person_facepalming","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man facepalming","slug":"man_facepalming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman facepalming","slug":"woman_facepalming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person shrugging","slug":"person_shrugging","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man shrugging","slug":"man_shrugging","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman shrugging","slug":"woman_shrugging","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"health worker","slug":"health_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man health worker","slug":"man_health_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman health worker","slug":"woman_health_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"student","slug":"student","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man student","slug":"man_student","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman student","slug":"woman_student","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"teacher","slug":"teacher","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man teacher","slug":"man_teacher","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman teacher","slug":"woman_teacher","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"judge","slug":"judge","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man judge","slug":"man_judge","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman judge","slug":"woman_judge","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"farmer","slug":"farmer","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man farmer","slug":"man_farmer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman farmer","slug":"woman_farmer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"cook","slug":"cook","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man cook","slug":"man_cook","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman cook","slug":"woman_cook","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"mechanic","slug":"mechanic","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man mechanic","slug":"man_mechanic","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman mechanic","slug":"woman_mechanic","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"factory worker","slug":"factory_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man factory worker","slug":"man_factory_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman factory worker","slug":"woman_factory_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"office worker","slug":"office_worker","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man office worker","slug":"man_office_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman office worker","slug":"woman_office_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"scientist","slug":"scientist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man scientist","slug":"man_scientist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman scientist","slug":"woman_scientist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"technologist","slug":"technologist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man technologist","slug":"man_technologist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman technologist","slug":"woman_technologist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"singer","slug":"singer","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man singer","slug":"man_singer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman singer","slug":"woman_singer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"artist","slug":"artist","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man artist","slug":"man_artist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman artist","slug":"woman_artist","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"pilot","slug":"pilot","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man pilot","slug":"man_pilot","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman pilot","slug":"woman_pilot","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"astronaut","slug":"astronaut","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man astronaut","slug":"man_astronaut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman astronaut","slug":"woman_astronaut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"firefighter","slug":"firefighter","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man firefighter","slug":"man_firefighter","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman firefighter","slug":"woman_firefighter","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"police officer","slug":"police_officer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man police officer","slug":"man_police_officer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman police officer","slug":"woman_police_officer","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"detective","slug":"detective","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man detective","slug":"man_detective","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman detective","slug":"woman_detective","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"guard","slug":"guard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man guard","slug":"man_guard","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman guard","slug":"woman_guard","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"ninja","slug":"ninja","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"construction worker","slug":"construction_worker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man construction worker","slug":"man_construction_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman construction worker","slug":"woman_construction_worker","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"person with crown","slug":"person_with_crown","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"prince","slug":"prince","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"princess","slug":"princess","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person wearing turban","slug":"person_wearing_turban","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man wearing turban","slug":"man_wearing_turban","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman wearing turban","slug":"woman_wearing_turban","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person with skullcap","slug":"person_with_skullcap","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman with headscarf","slug":"woman_with_headscarf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person in tuxedo","slug":"person_in_tuxedo","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man in tuxedo","slug":"man_in_tuxedo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman in tuxedo","slug":"woman_in_tuxedo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person with veil","slug":"person_with_veil","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man with veil","slug":"man_with_veil","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman with veil","slug":"woman_with_veil","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"pregnant woman","slug":"pregnant_woman","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"pregnant man","slug":"pregnant_man","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"14.0","name":"pregnant person","slug":"pregnant_person","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"breast-feeding","slug":"breast_feeding","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"woman feeding baby","slug":"woman_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"man feeding baby","slug":"man_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"person feeding baby","slug":"person_feeding_baby","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"baby angel","slug":"baby_angel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"Santa Claus","slug":"santa_claus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"Mrs. Claus","slug":"mrs_claus","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.0","name":"Mx Claus","slug":"mx_claus","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"superhero","slug":"superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man superhero","slug":"man_superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman superhero","slug":"woman_superhero","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"supervillain","slug":"supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"man supervillain","slug":"man_supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"11.0","name":"woman supervillain","slug":"woman_supervillain","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"mage","slug":"mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man mage","slug":"man_mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman mage","slug":"woman_mage","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"fairy","slug":"fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man fairy","slug":"man_fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman fairy","slug":"woman_fairy","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"vampire","slug":"vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man vampire","slug":"man_vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman vampire","slug":"woman_vampire","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"merperson","slug":"merperson","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"merman","slug":"merman","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"mermaid","slug":"mermaid","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"elf","slug":"elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man elf","slug":"man_elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman elf","slug":"woman_elf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"genie","slug":"genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"man genie","slug":"man_genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"woman genie","slug":"woman_genie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"zombie","slug":"zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"man zombie","slug":"man_zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"woman zombie","slug":"woman_zombie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"troll","slug":"troll","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person getting massage","slug":"person_getting_massage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man getting massage","slug":"man_getting_massage","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman getting massage","slug":"woman_getting_massage","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person getting haircut","slug":"person_getting_haircut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man getting haircut","slug":"man_getting_haircut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman getting haircut","slug":"woman_getting_haircut","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person walking","slug":"person_walking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man walking","slug":"man_walking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman walking","slug":"woman_walking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person walking facing right","slug":"person_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman walking facing right","slug":"woman_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man walking facing right","slug":"man_walking_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"person standing","slug":"person_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man standing","slug":"man_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman standing","slug":"woman_standing","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"person kneeling","slug":"person_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man kneeling","slug":"man_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman kneeling","slug":"woman_kneeling","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person kneeling facing right","slug":"person_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman kneeling facing right","slug":"woman_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man kneeling facing right","slug":"man_kneeling_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person with white cane","slug":"person_with_white_cane","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person with white cane facing right","slug":"person_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man with white cane","slug":"man_with_white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man with white cane facing right","slug":"man_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman with white cane","slug":"woman_with_white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman with white cane facing right","slug":"woman_with_white_cane_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person in motorized wheelchair","slug":"person_in_motorized_wheelchair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person in motorized wheelchair facing right","slug":"person_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man in motorized wheelchair","slug":"man_in_motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man in motorized wheelchair facing right","slug":"man_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman in motorized wheelchair","slug":"woman_in_motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman in motorized wheelchair facing right","slug":"woman_in_motorized_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.1","name":"person in manual wheelchair","slug":"person_in_manual_wheelchair","unicode_version":"12.1","emoji_version":"12.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person in manual wheelchair facing right","slug":"person_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"man in manual wheelchair","slug":"man_in_manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man in manual wheelchair facing right","slug":"man_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman in manual wheelchair","slug":"woman_in_manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman in manual wheelchair facing right","slug":"woman_in_manual_wheelchair_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person running","slug":"person_running","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man running","slug":"man_running","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman running","slug":"woman_running","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"person running facing right","slug":"person_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"woman running facing right","slug":"woman_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"15.1","name":"man running facing right","slug":"man_running_facing_right","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"woman dancing","slug":"woman_dancing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"man dancing","slug":"man_dancing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person in suit levitating","slug":"person_in_suit_levitating","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"people with bunny ears","slug":"people_with_bunny_ears","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"men with bunny ears","slug":"men_with_bunny_ears","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"women with bunny ears","slug":"women_with_bunny_ears","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person in steamy room","slug":"person_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man in steamy room","slug":"man_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman in steamy room","slug":"woman_in_steamy_room","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person climbing","slug":"person_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man climbing","slug":"man_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman climbing","slug":"woman_climbing","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"person fencing","slug":"person_fencing","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"horse racing","slug":"horse_racing","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"skier","slug":"skier","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"snowboarder","slug":"snowboarder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person golfing","slug":"person_golfing","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man golfing","slug":"man_golfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman golfing","slug":"woman_golfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person surfing","slug":"person_surfing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man surfing","slug":"man_surfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman surfing","slug":"woman_surfing","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person rowing boat","slug":"person_rowing_boat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man rowing boat","slug":"man_rowing_boat","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman rowing boat","slug":"woman_rowing_boat","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person swimming","slug":"person_swimming","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man swimming","slug":"man_swimming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman swimming","slug":"woman_swimming","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"person bouncing ball","slug":"person_bouncing_ball","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man bouncing ball","slug":"man_bouncing_ball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman bouncing ball","slug":"woman_bouncing_ball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"2.0","name":"person lifting weights","slug":"person_lifting_weights","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man lifting weights","slug":"man_lifting_weights","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman lifting weights","slug":"woman_lifting_weights","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person biking","slug":"person_biking","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man biking","slug":"man_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman biking","slug":"woman_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person mountain biking","slug":"person_mountain_biking","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man mountain biking","slug":"man_mountain_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman mountain biking","slug":"woman_mountain_biking","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person cartwheeling","slug":"person_cartwheeling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man cartwheeling","slug":"man_cartwheeling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman cartwheeling","slug":"woman_cartwheeling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"people wrestling","slug":"people_wrestling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"men wrestling","slug":"men_wrestling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"women wrestling","slug":"women_wrestling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person playing water polo","slug":"person_playing_water_polo","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man playing water polo","slug":"man_playing_water_polo","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman playing water polo","slug":"woman_playing_water_polo","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person playing handball","slug":"person_playing_handball","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man playing handball","slug":"man_playing_handball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman playing handball","slug":"woman_playing_handball","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"3.0","name":"person juggling","slug":"person_juggling","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"man juggling","slug":"man_juggling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"woman juggling","slug":"woman_juggling","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"person in lotus position","slug":"person_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"man in lotus position","slug":"man_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"5.0","name":"woman in lotus position","slug":"woman_in_lotus_position","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"1.0","name":"person taking bath","slug":"person_taking_bath","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"4.0","name":"person in bed","slug":"person_in_bed","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"people holding hands","slug":"people_holding_hands","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"women holding hands","slug":"women_holding_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"woman and man holding hands","slug":"woman_and_man_holding_hands","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"12.0","name":"men holding hands","slug":"men_holding_hands","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss","slug":"kiss","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss woman, man","slug":"kiss_woman_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss man, man","slug":"kiss_man_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"kiss woman, woman","slug":"kiss_woman_woman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart","slug":"couple_with_heart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart woman, man","slug":"couple_with_heart_woman_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart man, man","slug":"couple_with_heart_man_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":true,"skin_tone_support_unicode_version":"13.1","name":"couple with heart woman, woman","slug":"couple_with_heart_woman_woman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, woman, boy","slug":"family_man_woman_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, woman, girl","slug":"family_man_woman_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, woman, girl, boy","slug":"family_man_woman_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, woman, boy, boy","slug":"family_man_woman_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, woman, girl, girl","slug":"family_man_woman_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, man, boy","slug":"family_man_man_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, man, girl","slug":"family_man_man_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, man, girl, boy","slug":"family_man_man_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, man, boy, boy","slug":"family_man_man_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, man, girl, girl","slug":"family_man_man_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, woman, boy","slug":"family_woman_woman_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, woman, girl","slug":"family_woman_woman_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, woman, girl, boy","slug":"family_woman_woman_girl_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, woman, boy, boy","slug":"family_woman_woman_boy_boy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, woman, girl, girl","slug":"family_woman_woman_girl_girl","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"family man, boy","slug":"family_man_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family man, boy, boy","slug":"family_man_boy_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family man, girl","slug":"family_man_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family man, girl, boy","slug":"family_man_girl_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family man, girl, girl","slug":"family_man_girl_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, boy","slug":"family_woman_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, boy, boy","slug":"family_woman_boy_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, girl","slug":"family_woman_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, girl, boy","slug":"family_woman_girl_boy","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"family woman, girl, girl","slug":"family_woman_girl_girl","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"speaking head","slug":"speaking_head","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"bust in silhouette","slug":"bust_in_silhouette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"busts in silhouette","slug":"busts_in_silhouette","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"people hugging","slug":"people_hugging","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"family","slug":"family","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"family adult, adult, child","slug":"family_adult_adult_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"family adult, adult, child, child","slug":"family_adult_adult_child_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"family adult, child","slug":"family_adult_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"family adult, child, child","slug":"family_adult_child_child","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"footprints","slug":"footprints","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fingerprint","slug":"fingerprint","unicode_version":"16.0","emoji_version":"16.0"}]},{"name":"Animals & Nature","slug":"animals_nature","emojis":[{"emoji":"","skin_tone_support":false,"name":"monkey face","slug":"monkey_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"monkey","slug":"monkey","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"gorilla","slug":"gorilla","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"orangutan","slug":"orangutan","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"dog face","slug":"dog_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dog","slug":"dog","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"guide dog","slug":"guide_dog","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"service dog","slug":"service_dog","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"poodle","slug":"poodle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wolf","slug":"wolf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fox","slug":"fox","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"raccoon","slug":"raccoon","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"cat face","slug":"cat_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cat","slug":"cat","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"black cat","slug":"black_cat","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"lion","slug":"lion","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"tiger face","slug":"tiger_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tiger","slug":"tiger","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"leopard","slug":"leopard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"horse face","slug":"horse_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"moose","slug":"moose","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"donkey","slug":"donkey","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"horse","slug":"horse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"unicorn","slug":"unicorn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"zebra","slug":"zebra","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"deer","slug":"deer","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"bison","slug":"bison","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"cow face","slug":"cow_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ox","slug":"ox","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"water buffalo","slug":"water_buffalo","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"cow","slug":"cow","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"pig face","slug":"pig_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pig","slug":"pig","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"boar","slug":"boar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pig nose","slug":"pig_nose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ram","slug":"ram","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"ewe","slug":"ewe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"goat","slug":"goat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"camel","slug":"camel","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"two-hump camel","slug":"two_hump_camel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"llama","slug":"llama","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"giraffe","slug":"giraffe","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"elephant","slug":"elephant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mammoth","slug":"mammoth","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"rhinoceros","slug":"rhinoceros","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"hippopotamus","slug":"hippopotamus","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"mouse face","slug":"mouse_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mouse","slug":"mouse","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"rat","slug":"rat","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hamster","slug":"hamster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rabbit face","slug":"rabbit_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rabbit","slug":"rabbit","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"chipmunk","slug":"chipmunk","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"beaver","slug":"beaver","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"hedgehog","slug":"hedgehog","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bat","slug":"bat","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"bear","slug":"bear","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"polar bear","slug":"polar_bear","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"koala","slug":"koala","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"panda","slug":"panda","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sloth","slug":"sloth","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"otter","slug":"otter","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"skunk","slug":"skunk","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"kangaroo","slug":"kangaroo","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"badger","slug":"badger","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"paw prints","slug":"paw_prints","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"turkey","slug":"turkey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"chicken","slug":"chicken","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rooster","slug":"rooster","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hatching chick","slug":"hatching_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"baby chick","slug":"baby_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"front-facing baby chick","slug":"front_facing_baby_chick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bird","slug":"bird","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"penguin","slug":"penguin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dove","slug":"dove","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"eagle","slug":"eagle","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"duck","slug":"duck","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"swan","slug":"swan","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"owl","slug":"owl","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"dodo","slug":"dodo","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"feather","slug":"feather","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"flamingo","slug":"flamingo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"peacock","slug":"peacock","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"parrot","slug":"parrot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"wing","slug":"wing","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"black bird","slug":"black_bird","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"goose","slug":"goose","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"phoenix","slug":"phoenix","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"frog","slug":"frog","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"crocodile","slug":"crocodile","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"turtle","slug":"turtle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"lizard","slug":"lizard","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"snake","slug":"snake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dragon face","slug":"dragon_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dragon","slug":"dragon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"sauropod","slug":"sauropod","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"T-Rex","slug":"t_rex","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"spouting whale","slug":"spouting_whale","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"whale","slug":"whale","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"dolphin","slug":"dolphin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"seal","slug":"seal","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"fish","slug":"fish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tropical fish","slug":"tropical_fish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"blowfish","slug":"blowfish","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shark","slug":"shark","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"octopus","slug":"octopus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"spiral shell","slug":"spiral_shell","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"coral","slug":"coral","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"jellyfish","slug":"jellyfish","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"crab","slug":"crab","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"lobster","slug":"lobster","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"shrimp","slug":"shrimp","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"squid","slug":"squid","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"oyster","slug":"oyster","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"snail","slug":"snail","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"butterfly","slug":"butterfly","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"bug","slug":"bug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ant","slug":"ant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"honeybee","slug":"honeybee","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"beetle","slug":"beetle","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"lady beetle","slug":"lady_beetle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cricket","slug":"cricket","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"cockroach","slug":"cockroach","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"spider","slug":"spider","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"spider web","slug":"spider_web","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"scorpion","slug":"scorpion","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"mosquito","slug":"mosquito","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"fly","slug":"fly","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"worm","slug":"worm","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"microbe","slug":"microbe","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"bouquet","slug":"bouquet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cherry blossom","slug":"cherry_blossom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white flower","slug":"white_flower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"lotus","slug":"lotus","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"rosette","slug":"rosette","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"rose","slug":"rose","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wilted flower","slug":"wilted_flower","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"hibiscus","slug":"hibiscus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sunflower","slug":"sunflower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"blossom","slug":"blossom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tulip","slug":"tulip","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hyacinth","slug":"hyacinth","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"seedling","slug":"seedling","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"potted plant","slug":"potted_plant","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"evergreen tree","slug":"evergreen_tree","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"deciduous tree","slug":"deciduous_tree","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"palm tree","slug":"palm_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cactus","slug":"cactus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sheaf of rice","slug":"sheaf_of_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"herb","slug":"herb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shamrock","slug":"shamrock","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"four leaf clover","slug":"four_leaf_clover","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"maple leaf","slug":"maple_leaf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fallen leaf","slug":"fallen_leaf","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"leaf fluttering in wind","slug":"leaf_fluttering_in_wind","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"empty nest","slug":"empty_nest","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"nest with eggs","slug":"nest_with_eggs","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"mushroom","slug":"mushroom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"leafless tree","slug":"leafless_tree","unicode_version":"16.0","emoji_version":"16.0"}]},{"name":"Food & Drink","slug":"food_drink","emojis":[{"emoji":"","skin_tone_support":false,"name":"grapes","slug":"grapes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"melon","slug":"melon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"watermelon","slug":"watermelon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tangerine","slug":"tangerine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"lemon","slug":"lemon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"lime","slug":"lime","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"banana","slug":"banana","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pineapple","slug":"pineapple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mango","slug":"mango","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"red apple","slug":"red_apple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"green apple","slug":"green_apple","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pear","slug":"pear","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"peach","slug":"peach","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cherries","slug":"cherries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"strawberry","slug":"strawberry","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"blueberries","slug":"blueberries","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"kiwi fruit","slug":"kiwi_fruit","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"tomato","slug":"tomato","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"olive","slug":"olive","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"coconut","slug":"coconut","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"avocado","slug":"avocado","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"eggplant","slug":"eggplant","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"potato","slug":"potato","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"carrot","slug":"carrot","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"ear of corn","slug":"ear_of_corn","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hot pepper","slug":"hot_pepper","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"bell pepper","slug":"bell_pepper","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"cucumber","slug":"cucumber","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"leafy green","slug":"leafy_green","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"broccoli","slug":"broccoli","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"garlic","slug":"garlic","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"onion","slug":"onion","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"peanuts","slug":"peanuts","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"beans","slug":"beans","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"chestnut","slug":"chestnut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ginger root","slug":"ginger_root","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"pea pod","slug":"pea_pod","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"brown mushroom","slug":"brown_mushroom","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"root vegetable","slug":"root_vegetable","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"","skin_tone_support":false,"name":"bread","slug":"bread","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"croissant","slug":"croissant","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"baguette bread","slug":"baguette_bread","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"flatbread","slug":"flatbread","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"pretzel","slug":"pretzel","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bagel","slug":"bagel","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"pancakes","slug":"pancakes","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"waffle","slug":"waffle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"cheese wedge","slug":"cheese_wedge","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"meat on bone","slug":"meat_on_bone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"poultry leg","slug":"poultry_leg","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cut of meat","slug":"cut_of_meat","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bacon","slug":"bacon","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"hamburger","slug":"hamburger","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"french fries","slug":"french_fries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pizza","slug":"pizza","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hot dog","slug":"hot_dog","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"sandwich","slug":"sandwich","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"taco","slug":"taco","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"burrito","slug":"burrito","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"tamale","slug":"tamale","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"stuffed flatbread","slug":"stuffed_flatbread","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"falafel","slug":"falafel","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"egg","slug":"egg","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"cooking","slug":"cooking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shallow pan of food","slug":"shallow_pan_of_food","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"pot of food","slug":"pot_of_food","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fondue","slug":"fondue","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"bowl with spoon","slug":"bowl_with_spoon","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"green salad","slug":"green_salad","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"popcorn","slug":"popcorn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"butter","slug":"butter","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"salt","slug":"salt","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"canned food","slug":"canned_food","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bento box","slug":"bento_box","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rice cracker","slug":"rice_cracker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rice ball","slug":"rice_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cooked rice","slug":"cooked_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"curry rice","slug":"curry_rice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"steaming bowl","slug":"steaming_bowl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"spaghetti","slug":"spaghetti","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"roasted sweet potato","slug":"roasted_sweet_potato","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"oden","slug":"oden","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sushi","slug":"sushi","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fried shrimp","slug":"fried_shrimp","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fish cake with swirl","slug":"fish_cake_with_swirl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"moon cake","slug":"moon_cake","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"dango","slug":"dango","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dumpling","slug":"dumpling","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"fortune cookie","slug":"fortune_cookie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"takeout box","slug":"takeout_box","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"soft ice cream","slug":"soft_ice_cream","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shaved ice","slug":"shaved_ice","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ice cream","slug":"ice_cream","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"doughnut","slug":"doughnut","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cookie","slug":"cookie","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"birthday cake","slug":"birthday_cake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shortcake","slug":"shortcake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cupcake","slug":"cupcake","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"pie","slug":"pie","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"chocolate bar","slug":"chocolate_bar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"candy","slug":"candy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"lollipop","slug":"lollipop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"custard","slug":"custard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"honey pot","slug":"honey_pot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"baby bottle","slug":"baby_bottle","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"glass of milk","slug":"glass_of_milk","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"hot beverage","slug":"hot_beverage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"teapot","slug":"teapot","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"teacup without handle","slug":"teacup_without_handle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sake","slug":"sake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bottle with popping cork","slug":"bottle_with_popping_cork","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"wine glass","slug":"wine_glass","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cocktail glass","slug":"cocktail_glass","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tropical drink","slug":"tropical_drink","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"beer mug","slug":"beer_mug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clinking beer mugs","slug":"clinking_beer_mugs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clinking glasses","slug":"clinking_glasses","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"tumbler glass","slug":"tumbler_glass","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"pouring liquid","slug":"pouring_liquid","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"cup with straw","slug":"cup_with_straw","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bubble tea","slug":"bubble_tea","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"beverage box","slug":"beverage_box","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"mate","slug":"mate","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"ice","slug":"ice","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"chopsticks","slug":"chopsticks","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"fork and knife with plate","slug":"fork_and_knife_with_plate","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"fork and knife","slug":"fork_and_knife","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"spoon","slug":"spoon","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"kitchen knife","slug":"kitchen_knife","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"jar","slug":"jar","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"amphora","slug":"amphora","unicode_version":"1.0","emoji_version":"1.0"}]},{"name":"Travel & Places","slug":"travel_places","emojis":[{"emoji":"","skin_tone_support":false,"name":"globe showing Europe-Africa","slug":"globe_showing_europe_africa","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"globe showing Americas","slug":"globe_showing_americas","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"globe showing Asia-Australia","slug":"globe_showing_asia_australia","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"globe with meridians","slug":"globe_with_meridians","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"world map","slug":"world_map","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"map of Japan","slug":"map_of_japan","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"compass","slug":"compass","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"snow-capped mountain","slug":"snow_capped_mountain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"mountain","slug":"mountain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"volcano","slug":"volcano","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mount fuji","slug":"mount_fuji","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"camping","slug":"camping","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"beach with umbrella","slug":"beach_with_umbrella","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"desert","slug":"desert","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"desert island","slug":"desert_island","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"national park","slug":"national_park","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"stadium","slug":"stadium","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"classical building","slug":"classical_building","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"building construction","slug":"building_construction","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"brick","slug":"brick","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"rock","slug":"rock","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"wood","slug":"wood","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"hut","slug":"hut","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"houses","slug":"houses","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"derelict house","slug":"derelict_house","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"house","slug":"house","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"house with garden","slug":"house_with_garden","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"office building","slug":"office_building","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese post office","slug":"japanese_post_office","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"post office","slug":"post_office","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hospital","slug":"hospital","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bank","slug":"bank","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hotel","slug":"hotel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"love hotel","slug":"love_hotel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"convenience store","slug":"convenience_store","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"school","slug":"school","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"department store","slug":"department_store","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"factory","slug":"factory","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese castle","slug":"japanese_castle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"castle","slug":"castle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wedding","slug":"wedding","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Tokyo tower","slug":"tokyo_tower","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Statue of Liberty","slug":"statue_of_liberty","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"church","slug":"church","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mosque","slug":"mosque","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hindu temple","slug":"hindu_temple","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"synagogue","slug":"synagogue","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"shinto shrine","slug":"shinto_shrine","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"kaaba","slug":"kaaba","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"fountain","slug":"fountain","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tent","slug":"tent","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"foggy","slug":"foggy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"night with stars","slug":"night_with_stars","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cityscape","slug":"cityscape","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sunrise over mountains","slug":"sunrise_over_mountains","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sunrise","slug":"sunrise","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cityscape at dusk","slug":"cityscape_at_dusk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sunset","slug":"sunset","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bridge at night","slug":"bridge_at_night","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hot springs","slug":"hot_springs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"carousel horse","slug":"carousel_horse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"playground slide","slug":"playground_slide","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"ferris wheel","slug":"ferris_wheel","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"roller coaster","slug":"roller_coaster","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"barber pole","slug":"barber_pole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"circus tent","slug":"circus_tent","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"locomotive","slug":"locomotive","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"railway car","slug":"railway_car","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"high-speed train","slug":"high_speed_train","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bullet train","slug":"bullet_train","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"train","slug":"train","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"metro","slug":"metro","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"light rail","slug":"light_rail","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"station","slug":"station","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tram","slug":"tram","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"monorail","slug":"monorail","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"mountain railway","slug":"mountain_railway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"tram car","slug":"tram_car","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"bus","slug":"bus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"oncoming bus","slug":"oncoming_bus","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"trolleybus","slug":"trolleybus","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"minibus","slug":"minibus","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"ambulance","slug":"ambulance","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fire engine","slug":"fire_engine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"police car","slug":"police_car","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"oncoming police car","slug":"oncoming_police_car","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"taxi","slug":"taxi","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"oncoming taxi","slug":"oncoming_taxi","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"automobile","slug":"automobile","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"oncoming automobile","slug":"oncoming_automobile","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sport utility vehicle","slug":"sport_utility_vehicle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pickup truck","slug":"pickup_truck","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"delivery truck","slug":"delivery_truck","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"articulated lorry","slug":"articulated_lorry","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"tractor","slug":"tractor","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"racing car","slug":"racing_car","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"motorcycle","slug":"motorcycle","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"motor scooter","slug":"motor_scooter","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"manual wheelchair","slug":"manual_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"motorized wheelchair","slug":"motorized_wheelchair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"auto rickshaw","slug":"auto_rickshaw","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"bicycle","slug":"bicycle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kick scooter","slug":"kick_scooter","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"skateboard","slug":"skateboard","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"roller skate","slug":"roller_skate","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"bus stop","slug":"bus_stop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"motorway","slug":"motorway","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"railway track","slug":"railway_track","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"oil drum","slug":"oil_drum","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"fuel pump","slug":"fuel_pump","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wheel","slug":"wheel","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"police car light","slug":"police_car_light","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"horizontal traffic light","slug":"horizontal_traffic_light","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"vertical traffic light","slug":"vertical_traffic_light","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"stop sign","slug":"stop_sign","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"construction","slug":"construction","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"anchor","slug":"anchor","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ring buoy","slug":"ring_buoy","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"sailboat","slug":"sailboat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"canoe","slug":"canoe","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"speedboat","slug":"speedboat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"passenger ship","slug":"passenger_ship","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"ferry","slug":"ferry","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"motor boat","slug":"motor_boat","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"ship","slug":"ship","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"airplane","slug":"airplane","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"small airplane","slug":"small_airplane","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"airplane departure","slug":"airplane_departure","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"airplane arrival","slug":"airplane_arrival","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"parachute","slug":"parachute","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"seat","slug":"seat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"helicopter","slug":"helicopter","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"suspension railway","slug":"suspension_railway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"mountain cableway","slug":"mountain_cableway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"aerial tramway","slug":"aerial_tramway","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"satellite","slug":"satellite","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"rocket","slug":"rocket","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flying saucer","slug":"flying_saucer","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bellhop bell","slug":"bellhop_bell","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"luggage","slug":"luggage","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"hourglass done","slug":"hourglass_done","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hourglass not done","slug":"hourglass_not_done","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"watch","slug":"watch","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"alarm clock","slug":"alarm_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"stopwatch","slug":"stopwatch","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"timer clock","slug":"timer_clock","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"mantelpiece clock","slug":"mantelpiece_clock","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"twelve oclock","slug":"twelve_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"twelve-thirty","slug":"twelve_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"one oclock","slug":"one_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"one-thirty","slug":"one_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"two oclock","slug":"two_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"two-thirty","slug":"two_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"three oclock","slug":"three_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"three-thirty","slug":"three_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"four oclock","slug":"four_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"four-thirty","slug":"four_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"five oclock","slug":"five_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"five-thirty","slug":"five_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"six oclock","slug":"six_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"six-thirty","slug":"six_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"seven oclock","slug":"seven_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"seven-thirty","slug":"seven_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"eight oclock","slug":"eight_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eight-thirty","slug":"eight_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"nine oclock","slug":"nine_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"nine-thirty","slug":"nine_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"ten oclock","slug":"ten_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ten-thirty","slug":"ten_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"eleven oclock","slug":"eleven_o_clock","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eleven-thirty","slug":"eleven_thirty","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"new moon","slug":"new_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"waxing crescent moon","slug":"waxing_crescent_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"first quarter moon","slug":"first_quarter_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"waxing gibbous moon","slug":"waxing_gibbous_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"full moon","slug":"full_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"waning gibbous moon","slug":"waning_gibbous_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"last quarter moon","slug":"last_quarter_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"waning crescent moon","slug":"waning_crescent_moon","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"crescent moon","slug":"crescent_moon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"new moon face","slug":"new_moon_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"first quarter moon face","slug":"first_quarter_moon_face","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"last quarter moon face","slug":"last_quarter_moon_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"thermometer","slug":"thermometer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sun","slug":"sun","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"full moon face","slug":"full_moon_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"sun with face","slug":"sun_with_face","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"ringed planet","slug":"ringed_planet","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"star","slug":"star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"glowing star","slug":"glowing_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shooting star","slug":"shooting_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"milky way","slug":"milky_way","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cloud","slug":"cloud","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sun behind cloud","slug":"sun_behind_cloud","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cloud with lightning and rain","slug":"cloud_with_lightning_and_rain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sun behind small cloud","slug":"sun_behind_small_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sun behind large cloud","slug":"sun_behind_large_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"sun behind rain cloud","slug":"sun_behind_rain_cloud","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"cloud with rain","slug":"cloud_with_rain","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"cloud with snow","slug":"cloud_with_snow","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"cloud with lightning","slug":"cloud_with_lightning","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"tornado","slug":"tornado","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"fog","slug":"fog","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"wind face","slug":"wind_face","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"cyclone","slug":"cyclone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rainbow","slug":"rainbow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"closed umbrella","slug":"closed_umbrella","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"umbrella","slug":"umbrella","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"umbrella with rain drops","slug":"umbrella_with_rain_drops","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"umbrella on ground","slug":"umbrella_on_ground","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"high voltage","slug":"high_voltage","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"snowflake","slug":"snowflake","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"snowman","slug":"snowman","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"snowman without snow","slug":"snowman_without_snow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"comet","slug":"comet","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"fire","slug":"fire","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"droplet","slug":"droplet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"water wave","slug":"water_wave","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"Activities","slug":"activities","emojis":[{"emoji":"","skin_tone_support":false,"name":"jack-o-lantern","slug":"jack_o_lantern","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Christmas tree","slug":"christmas_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fireworks","slug":"fireworks","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sparkler","slug":"sparkler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"firecracker","slug":"firecracker","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"sparkles","slug":"sparkles","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"balloon","slug":"balloon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"party popper","slug":"party_popper","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"confetti ball","slug":"confetti_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tanabata tree","slug":"tanabata_tree","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pine decoration","slug":"pine_decoration","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese dolls","slug":"japanese_dolls","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"carp streamer","slug":"carp_streamer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wind chime","slug":"wind_chime","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"moon viewing ceremony","slug":"moon_viewing_ceremony","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red envelope","slug":"red_envelope","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"ribbon","slug":"ribbon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wrapped gift","slug":"wrapped_gift","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"reminder ribbon","slug":"reminder_ribbon","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"admission tickets","slug":"admission_tickets","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"ticket","slug":"ticket","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"military medal","slug":"military_medal","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"trophy","slug":"trophy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sports medal","slug":"sports_medal","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"1st place medal","slug":"1st_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"2nd place medal","slug":"2nd_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"3rd place medal","slug":"3rd_place_medal","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"soccer ball","slug":"soccer_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"baseball","slug":"baseball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"softball","slug":"softball","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"basketball","slug":"basketball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"volleyball","slug":"volleyball","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"american football","slug":"american_football","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rugby football","slug":"rugby_football","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"tennis","slug":"tennis","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flying disc","slug":"flying_disc","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"bowling","slug":"bowling","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cricket game","slug":"cricket_game","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"field hockey","slug":"field_hockey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"ice hockey","slug":"ice_hockey","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"lacrosse","slug":"lacrosse","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"ping pong","slug":"ping_pong","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"badminton","slug":"badminton","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"boxing glove","slug":"boxing_glove","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"martial arts uniform","slug":"martial_arts_uniform","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"goal net","slug":"goal_net","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"flag in hole","slug":"flag_in_hole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ice skate","slug":"ice_skate","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"fishing pole","slug":"fishing_pole","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"diving mask","slug":"diving_mask","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"running shirt","slug":"running_shirt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"skis","slug":"skis","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sled","slug":"sled","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"curling stone","slug":"curling_stone","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"bullseye","slug":"bullseye","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"yo-yo","slug":"yo_yo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"kite","slug":"kite","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"water pistol","slug":"water_pistol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pool 8 ball","slug":"pool_8_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"crystal ball","slug":"crystal_ball","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"magic wand","slug":"magic_wand","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"video game","slug":"video_game","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"joystick","slug":"joystick","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"slot machine","slug":"slot_machine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"game die","slug":"game_die","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"puzzle piece","slug":"puzzle_piece","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"teddy bear","slug":"teddy_bear","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"piata","slug":"pinata","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"mirror ball","slug":"mirror_ball","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"nesting dolls","slug":"nesting_dolls","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"spade suit","slug":"spade_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heart suit","slug":"heart_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"diamond suit","slug":"diamond_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"club suit","slug":"club_suit","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"chess pawn","slug":"chess_pawn","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"joker","slug":"joker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mahjong red dragon","slug":"mahjong_red_dragon","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flower playing cards","slug":"flower_playing_cards","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"performing arts","slug":"performing_arts","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"framed picture","slug":"framed_picture","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"artist palette","slug":"artist_palette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"thread","slug":"thread","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"sewing needle","slug":"sewing_needle","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"yarn","slug":"yarn","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"knot","slug":"knot","unicode_version":"13.0","emoji_version":"13.0"}]},{"name":"Objects","slug":"objects","emojis":[{"emoji":"","skin_tone_support":false,"name":"glasses","slug":"glasses","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sunglasses","slug":"sunglasses","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"goggles","slug":"goggles","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"lab coat","slug":"lab_coat","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"safety vest","slug":"safety_vest","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"necktie","slug":"necktie","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"t-shirt","slug":"t_shirt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"jeans","slug":"jeans","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"scarf","slug":"scarf","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"gloves","slug":"gloves","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"coat","slug":"coat","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"socks","slug":"socks","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"dress","slug":"dress","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"kimono","slug":"kimono","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sari","slug":"sari","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"one-piece swimsuit","slug":"one_piece_swimsuit","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"briefs","slug":"briefs","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"shorts","slug":"shorts","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"bikini","slug":"bikini","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"womans clothes","slug":"woman_s_clothes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"folding hand fan","slug":"folding_hand_fan","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"purse","slug":"purse","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"handbag","slug":"handbag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clutch bag","slug":"clutch_bag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shopping bags","slug":"shopping_bags","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"backpack","slug":"backpack","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"thong sandal","slug":"thong_sandal","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"mans shoe","slug":"man_s_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"running shoe","slug":"running_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hiking boot","slug":"hiking_boot","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"flat shoe","slug":"flat_shoe","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"high-heeled shoe","slug":"high_heeled_shoe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"womans sandal","slug":"woman_s_sandal","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ballet shoes","slug":"ballet_shoes","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"womans boot","slug":"woman_s_boot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hair pick","slug":"hair_pick","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"crown","slug":"crown","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"womans hat","slug":"woman_s_hat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"top hat","slug":"top_hat","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"graduation cap","slug":"graduation_cap","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"billed cap","slug":"billed_cap","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"military helmet","slug":"military_helmet","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"rescue workers helmet","slug":"rescue_worker_s_helmet","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"prayer beads","slug":"prayer_beads","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"lipstick","slug":"lipstick","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ring","slug":"ring","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"gem stone","slug":"gem_stone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"muted speaker","slug":"muted_speaker","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"speaker low volume","slug":"speaker_low_volume","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"speaker medium volume","slug":"speaker_medium_volume","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"speaker high volume","slug":"speaker_high_volume","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"loudspeaker","slug":"loudspeaker","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"megaphone","slug":"megaphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"postal horn","slug":"postal_horn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"bell","slug":"bell","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bell with slash","slug":"bell_with_slash","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"musical score","slug":"musical_score","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"musical note","slug":"musical_note","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"musical notes","slug":"musical_notes","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"studio microphone","slug":"studio_microphone","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"level slider","slug":"level_slider","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"control knobs","slug":"control_knobs","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"microphone","slug":"microphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"headphone","slug":"headphone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"radio","slug":"radio","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"saxophone","slug":"saxophone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"accordion","slug":"accordion","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"guitar","slug":"guitar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"musical keyboard","slug":"musical_keyboard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"trumpet","slug":"trumpet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"violin","slug":"violin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"banjo","slug":"banjo","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"drum","slug":"drum","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"long drum","slug":"long_drum","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"maracas","slug":"maracas","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"flute","slug":"flute","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"harp","slug":"harp","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"","skin_tone_support":false,"name":"mobile phone","slug":"mobile_phone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mobile phone with arrow","slug":"mobile_phone_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"telephone","slug":"telephone","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"telephone receiver","slug":"telephone_receiver","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pager","slug":"pager","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fax machine","slug":"fax_machine","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"battery","slug":"battery","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"low battery","slug":"low_battery","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"electric plug","slug":"electric_plug","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"laptop","slug":"laptop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"desktop computer","slug":"desktop_computer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"printer","slug":"printer","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"keyboard","slug":"keyboard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"computer mouse","slug":"computer_mouse","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"trackball","slug":"trackball","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"computer disk","slug":"computer_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"floppy disk","slug":"floppy_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"optical disk","slug":"optical_disk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dvd","slug":"dvd","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"abacus","slug":"abacus","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"movie camera","slug":"movie_camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"film frames","slug":"film_frames","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"film projector","slug":"film_projector","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"clapper board","slug":"clapper_board","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"television","slug":"television","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"camera","slug":"camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"camera with flash","slug":"camera_with_flash","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"video camera","slug":"video_camera","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"videocassette","slug":"videocassette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"magnifying glass tilted left","slug":"magnifying_glass_tilted_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"magnifying glass tilted right","slug":"magnifying_glass_tilted_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"candle","slug":"candle","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"light bulb","slug":"light_bulb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flashlight","slug":"flashlight","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red paper lantern","slug":"red_paper_lantern","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"diya lamp","slug":"diya_lamp","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"notebook with decorative cover","slug":"notebook_with_decorative_cover","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"closed book","slug":"closed_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"open book","slug":"open_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"green book","slug":"green_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"blue book","slug":"blue_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"orange book","slug":"orange_book","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"books","slug":"books","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"notebook","slug":"notebook","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ledger","slug":"ledger","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"page with curl","slug":"page_with_curl","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"scroll","slug":"scroll","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"page facing up","slug":"page_facing_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"newspaper","slug":"newspaper","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"rolled-up newspaper","slug":"rolled_up_newspaper","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"bookmark tabs","slug":"bookmark_tabs","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bookmark","slug":"bookmark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"label","slug":"label","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"money bag","slug":"money_bag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"coin","slug":"coin","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"yen banknote","slug":"yen_banknote","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dollar banknote","slug":"dollar_banknote","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"euro banknote","slug":"euro_banknote","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"pound banknote","slug":"pound_banknote","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"money with wings","slug":"money_with_wings","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"credit card","slug":"credit_card","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"receipt","slug":"receipt","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"chart increasing with yen","slug":"chart_increasing_with_yen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"envelope","slug":"envelope","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"e-mail","slug":"e_mail","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"incoming envelope","slug":"incoming_envelope","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"envelope with arrow","slug":"envelope_with_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"outbox tray","slug":"outbox_tray","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"inbox tray","slug":"inbox_tray","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"package","slug":"package","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"closed mailbox with raised flag","slug":"closed_mailbox_with_raised_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"closed mailbox with lowered flag","slug":"closed_mailbox_with_lowered_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"open mailbox with raised flag","slug":"open_mailbox_with_raised_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"open mailbox with lowered flag","slug":"open_mailbox_with_lowered_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"postbox","slug":"postbox","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ballot box with ballot","slug":"ballot_box_with_ballot","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"pencil","slug":"pencil","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black nib","slug":"black_nib","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fountain pen","slug":"fountain_pen","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"pen","slug":"pen","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"paintbrush","slug":"paintbrush","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"crayon","slug":"crayon","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"memo","slug":"memo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"briefcase","slug":"briefcase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"file folder","slug":"file_folder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"open file folder","slug":"open_file_folder","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"card index dividers","slug":"card_index_dividers","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"calendar","slug":"calendar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"tear-off calendar","slug":"tear_off_calendar","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"spiral notepad","slug":"spiral_notepad","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"spiral calendar","slug":"spiral_calendar","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"card index","slug":"card_index","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"chart increasing","slug":"chart_increasing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"chart decreasing","slug":"chart_decreasing","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"bar chart","slug":"bar_chart","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clipboard","slug":"clipboard","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pushpin","slug":"pushpin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"round pushpin","slug":"round_pushpin","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"paperclip","slug":"paperclip","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"linked paperclips","slug":"linked_paperclips","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"straight ruler","slug":"straight_ruler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"triangular ruler","slug":"triangular_ruler","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"scissors","slug":"scissors","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"card file box","slug":"card_file_box","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"file cabinet","slug":"file_cabinet","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"wastebasket","slug":"wastebasket","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"locked","slug":"locked","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"unlocked","slug":"unlocked","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"locked with pen","slug":"locked_with_pen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"locked with key","slug":"locked_with_key","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"key","slug":"key","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"old key","slug":"old_key","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"hammer","slug":"hammer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"axe","slug":"axe","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"pick","slug":"pick","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"hammer and pick","slug":"hammer_and_pick","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"hammer and wrench","slug":"hammer_and_wrench","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"dagger","slug":"dagger","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"crossed swords","slug":"crossed_swords","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"bomb","slug":"bomb","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"boomerang","slug":"boomerang","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"bow and arrow","slug":"bow_and_arrow","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"shield","slug":"shield","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"carpentry saw","slug":"carpentry_saw","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"wrench","slug":"wrench","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"screwdriver","slug":"screwdriver","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"nut and bolt","slug":"nut_and_bolt","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"gear","slug":"gear","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"clamp","slug":"clamp","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"balance scale","slug":"balance_scale","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"white cane","slug":"white_cane","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"link","slug":"link","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"broken chain","slug":"broken_chain","unicode_version":"15.1","emoji_version":"15.1"},{"emoji":"","skin_tone_support":false,"name":"chains","slug":"chains","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"hook","slug":"hook","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"toolbox","slug":"toolbox","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"magnet","slug":"magnet","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"ladder","slug":"ladder","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"shovel","slug":"shovel","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"","skin_tone_support":false,"name":"alembic","slug":"alembic","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"test tube","slug":"test_tube","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"petri dish","slug":"petri_dish","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"dna","slug":"dna","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"microscope","slug":"microscope","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"telescope","slug":"telescope","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"satellite antenna","slug":"satellite_antenna","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"syringe","slug":"syringe","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"drop of blood","slug":"drop_of_blood","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"pill","slug":"pill","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"adhesive bandage","slug":"adhesive_bandage","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"crutch","slug":"crutch","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"stethoscope","slug":"stethoscope","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"x-ray","slug":"x_ray","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"door","slug":"door","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"elevator","slug":"elevator","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"mirror","slug":"mirror","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"window","slug":"window","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"bed","slug":"bed","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"couch and lamp","slug":"couch_and_lamp","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"chair","slug":"chair","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"toilet","slug":"toilet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"plunger","slug":"plunger","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"shower","slug":"shower","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"bathtub","slug":"bathtub","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"mouse trap","slug":"mouse_trap","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"razor","slug":"razor","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"lotion bottle","slug":"lotion_bottle","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"safety pin","slug":"safety_pin","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"broom","slug":"broom","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"basket","slug":"basket","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"roll of paper","slug":"roll_of_paper","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"bucket","slug":"bucket","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"soap","slug":"soap","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"bubbles","slug":"bubbles","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"toothbrush","slug":"toothbrush","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"sponge","slug":"sponge","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"fire extinguisher","slug":"fire_extinguisher","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"shopping cart","slug":"shopping_cart","unicode_version":"3.0","emoji_version":"3.0"},{"emoji":"","skin_tone_support":false,"name":"cigarette","slug":"cigarette","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"coffin","slug":"coffin","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"headstone","slug":"headstone","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"funeral urn","slug":"funeral_urn","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"nazar amulet","slug":"nazar_amulet","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"hamsa","slug":"hamsa","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"moai","slug":"moai","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"placard","slug":"placard","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"identification card","slug":"identification_card","unicode_version":"14.0","emoji_version":"14.0"}]},{"name":"Symbols","slug":"symbols","emojis":[{"emoji":"","skin_tone_support":false,"name":"ATM sign","slug":"atm_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"litter in bin sign","slug":"litter_in_bin_sign","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"potable water","slug":"potable_water","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"wheelchair symbol","slug":"wheelchair_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mens room","slug":"men_s_room","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"womens room","slug":"women_s_room","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"restroom","slug":"restroom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"baby symbol","slug":"baby_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"water closet","slug":"water_closet","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"passport control","slug":"passport_control","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"customs","slug":"customs","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"baggage claim","slug":"baggage_claim","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"left luggage","slug":"left_luggage","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"warning","slug":"warning","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"children crossing","slug":"children_crossing","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"no entry","slug":"no_entry","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"prohibited","slug":"prohibited","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"no bicycles","slug":"no_bicycles","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"no smoking","slug":"no_smoking","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"no littering","slug":"no_littering","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"non-potable water","slug":"non_potable_water","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"no pedestrians","slug":"no_pedestrians","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"no mobile phones","slug":"no_mobile_phones","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"no one under eighteen","slug":"no_one_under_eighteen","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"radioactive","slug":"radioactive","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"biohazard","slug":"biohazard","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"up arrow","slug":"up_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"up-right arrow","slug":"up_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"right arrow","slug":"right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"down-right arrow","slug":"down_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"down arrow","slug":"down_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"down-left arrow","slug":"down_left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"left arrow","slug":"left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"up-left arrow","slug":"up_left_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"up-down arrow","slug":"up_down_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"left-right arrow","slug":"left_right_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"right arrow curving left","slug":"right_arrow_curving_left","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"left arrow curving right","slug":"left_arrow_curving_right","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"right arrow curving up","slug":"right_arrow_curving_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"right arrow curving down","slug":"right_arrow_curving_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"clockwise vertical arrows","slug":"clockwise_vertical_arrows","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"counterclockwise arrows button","slug":"counterclockwise_arrows_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"BACK arrow","slug":"back_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"END arrow","slug":"end_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ON! arrow","slug":"on_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"SOON arrow","slug":"soon_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"TOP arrow","slug":"top_arrow","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"place of worship","slug":"place_of_worship","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"atom symbol","slug":"atom_symbol","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"om","slug":"om","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"star of David","slug":"star_of_david","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"wheel of dharma","slug":"wheel_of_dharma","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"yin yang","slug":"yin_yang","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"latin cross","slug":"latin_cross","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"orthodox cross","slug":"orthodox_cross","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"star and crescent","slug":"star_and_crescent","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"peace symbol","slug":"peace_symbol","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"menorah","slug":"menorah","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"dotted six-pointed star","slug":"dotted_six_pointed_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"khanda","slug":"khanda","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"Aries","slug":"aries","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Taurus","slug":"taurus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Gemini","slug":"gemini","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Cancer","slug":"cancer","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Leo","slug":"leo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Virgo","slug":"virgo","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Libra","slug":"libra","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Scorpio","slug":"scorpio","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Sagittarius","slug":"sagittarius","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Capricorn","slug":"capricorn","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Aquarius","slug":"aquarius","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Pisces","slug":"pisces","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Ophiuchus","slug":"ophiuchus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"shuffle tracks button","slug":"shuffle_tracks_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"repeat button","slug":"repeat_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"repeat single button","slug":"repeat_single_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"play button","slug":"play_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fast-forward button","slug":"fast_forward_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"next track button","slug":"next_track_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"play or pause button","slug":"play_or_pause_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"reverse button","slug":"reverse_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fast reverse button","slug":"fast_reverse_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"last track button","slug":"last_track_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"upwards button","slug":"upwards_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fast up button","slug":"fast_up_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"downwards button","slug":"downwards_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fast down button","slug":"fast_down_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"pause button","slug":"pause_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"stop button","slug":"stop_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"record button","slug":"record_button","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"eject button","slug":"eject_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"cinema","slug":"cinema","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"dim button","slug":"dim_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"bright button","slug":"bright_button","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"antenna bars","slug":"antenna_bars","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wireless","slug":"wireless","unicode_version":"15.0","emoji_version":"15.0"},{"emoji":"","skin_tone_support":false,"name":"vibration mode","slug":"vibration_mode","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"mobile phone off","slug":"mobile_phone_off","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"female sign","slug":"female_sign","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"male sign","slug":"male_sign","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"transgender symbol","slug":"transgender_symbol","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"multiply","slug":"multiply","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"plus","slug":"plus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"minus","slug":"minus","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"divide","slug":"divide","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heavy equals sign","slug":"heavy_equals_sign","unicode_version":"14.0","emoji_version":"14.0"},{"emoji":"","skin_tone_support":false,"name":"infinity","slug":"infinity","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"double exclamation mark","slug":"double_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"exclamation question mark","slug":"exclamation_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red question mark","slug":"red_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white question mark","slug":"white_question_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white exclamation mark","slug":"white_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red exclamation mark","slug":"red_exclamation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"wavy dash","slug":"wavy_dash","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"currency exchange","slug":"currency_exchange","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"heavy dollar sign","slug":"heavy_dollar_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"medical symbol","slug":"medical_symbol","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"recycling symbol","slug":"recycling_symbol","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"fleur-de-lis","slug":"fleur_de_lis","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"trident emblem","slug":"trident_emblem","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"name badge","slug":"name_badge","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese symbol for beginner","slug":"japanese_symbol_for_beginner","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"hollow red circle","slug":"hollow_red_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"check mark button","slug":"check_mark_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"check box with check","slug":"check_box_with_check","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"check mark","slug":"check_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cross mark","slug":"cross_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"cross mark button","slug":"cross_mark_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"curly loop","slug":"curly_loop","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"double curly loop","slug":"double_curly_loop","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"part alternation mark","slug":"part_alternation_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eight-spoked asterisk","slug":"eight_spoked_asterisk","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"eight-pointed star","slug":"eight_pointed_star","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"sparkle","slug":"sparkle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"copyright","slug":"copyright","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"registered","slug":"registered","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"trade mark","slug":"trade_mark","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"splatter","slug":"splatter","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"#","skin_tone_support":false,"name":"keycap #","slug":"keycap_number_sign","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"*","skin_tone_support":false,"name":"keycap *","slug":"keycap_asterisk","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"0","skin_tone_support":false,"name":"keycap 0","slug":"keycap_0","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"1","skin_tone_support":false,"name":"keycap 1","slug":"keycap_1","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"2","skin_tone_support":false,"name":"keycap 2","slug":"keycap_2","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"3","skin_tone_support":false,"name":"keycap 3","slug":"keycap_3","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"4","skin_tone_support":false,"name":"keycap 4","slug":"keycap_4","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"5","skin_tone_support":false,"name":"keycap 5","slug":"keycap_5","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"6","skin_tone_support":false,"name":"keycap 6","slug":"keycap_6","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"7","skin_tone_support":false,"name":"keycap 7","slug":"keycap_7","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"8","skin_tone_support":false,"name":"keycap 8","slug":"keycap_8","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"9","skin_tone_support":false,"name":"keycap 9","slug":"keycap_9","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"keycap 10","slug":"keycap_10","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"input latin uppercase","slug":"input_latin_uppercase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"input latin lowercase","slug":"input_latin_lowercase","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"input numbers","slug":"input_numbers","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"input symbols","slug":"input_symbols","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"input latin letters","slug":"input_latin_letters","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"A button (blood type)","slug":"a_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"AB button (blood type)","slug":"ab_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"B button (blood type)","slug":"b_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"CL button","slug":"cl_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"COOL button","slug":"cool_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"FREE button","slug":"free_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"information","slug":"information","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"ID button","slug":"id_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"circled M","slug":"circled_m","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"NEW button","slug":"new_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"NG button","slug":"ng_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"O button (blood type)","slug":"o_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"OK button","slug":"ok_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"P button","slug":"p_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"SOS button","slug":"sos_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"UP! button","slug":"up_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"VS button","slug":"vs_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese here button","slug":"japanese_here_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese service charge button","slug":"japanese_service_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese monthly amount button","slug":"japanese_monthly_amount_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese not free of charge button","slug":"japanese_not_free_of_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese reserved button","slug":"japanese_reserved_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese bargain button","slug":"japanese_bargain_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese discount button","slug":"japanese_discount_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese free of charge button","slug":"japanese_free_of_charge_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese prohibited button","slug":"japanese_prohibited_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese acceptable button","slug":"japanese_acceptable_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese application button","slug":"japanese_application_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese passing grade button","slug":"japanese_passing_grade_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese vacancy button","slug":"japanese_vacancy_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese congratulations button","slug":"japanese_congratulations_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese secret button","slug":"japanese_secret_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese open for business button","slug":"japanese_open_for_business_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"Japanese no vacancy button","slug":"japanese_no_vacancy_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red circle","slug":"red_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"orange circle","slug":"orange_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"yellow circle","slug":"yellow_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"green circle","slug":"green_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"blue circle","slug":"blue_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"purple circle","slug":"purple_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"brown circle","slug":"brown_circle","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"black circle","slug":"black_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white circle","slug":"white_circle","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red square","slug":"red_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"orange square","slug":"orange_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"yellow square","slug":"yellow_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"green square","slug":"green_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"blue square","slug":"blue_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"purple square","slug":"purple_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"brown square","slug":"brown_square","unicode_version":"12.0","emoji_version":"12.0"},{"emoji":"","skin_tone_support":false,"name":"black large square","slug":"black_large_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white large square","slug":"white_large_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black medium square","slug":"black_medium_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white medium square","slug":"white_medium_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black medium-small square","slug":"black_medium_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white medium-small square","slug":"white_medium_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black small square","slug":"black_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white small square","slug":"white_small_square","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"large orange diamond","slug":"large_orange_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"large blue diamond","slug":"large_blue_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"small orange diamond","slug":"small_orange_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"small blue diamond","slug":"small_blue_diamond","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red triangle pointed up","slug":"red_triangle_pointed_up","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"red triangle pointed down","slug":"red_triangle_pointed_down","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"diamond with a dot","slug":"diamond_with_a_dot","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"radio button","slug":"radio_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"white square button","slug":"white_square_button","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black square button","slug":"black_square_button","unicode_version":"0.6","emoji_version":"0.6"}]},{"name":"Flags","slug":"flags","emojis":[{"emoji":"","skin_tone_support":false,"name":"chequered flag","slug":"chequered_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"triangular flag","slug":"triangular_flag","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"crossed flags","slug":"crossed_flags","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"black flag","slug":"black_flag","unicode_version":"1.0","emoji_version":"1.0"},{"emoji":"","skin_tone_support":false,"name":"white flag","slug":"white_flag","unicode_version":"0.7","emoji_version":"0.7"},{"emoji":"","skin_tone_support":false,"name":"rainbow flag","slug":"rainbow_flag","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"transgender flag","slug":"transgender_flag","unicode_version":"13.0","emoji_version":"13.0"},{"emoji":"","skin_tone_support":false,"name":"pirate flag","slug":"pirate_flag","unicode_version":"11.0","emoji_version":"11.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ascension Island","slug":"flag_ascension_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Andorra","slug":"flag_andorra","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag United Arab Emirates","slug":"flag_united_arab_emirates","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Afghanistan","slug":"flag_afghanistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Antigua & Barbuda","slug":"flag_antigua_barbuda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Anguilla","slug":"flag_anguilla","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Albania","slug":"flag_albania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Armenia","slug":"flag_armenia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Angola","slug":"flag_angola","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Antarctica","slug":"flag_antarctica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Argentina","slug":"flag_argentina","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag American Samoa","slug":"flag_american_samoa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Austria","slug":"flag_austria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Australia","slug":"flag_australia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Aruba","slug":"flag_aruba","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag land Islands","slug":"flag_aland_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Azerbaijan","slug":"flag_azerbaijan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bosnia & Herzegovina","slug":"flag_bosnia_herzegovina","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Barbados","slug":"flag_barbados","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bangladesh","slug":"flag_bangladesh","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Belgium","slug":"flag_belgium","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Burkina Faso","slug":"flag_burkina_faso","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bulgaria","slug":"flag_bulgaria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bahrain","slug":"flag_bahrain","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Burundi","slug":"flag_burundi","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Benin","slug":"flag_benin","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Barthlemy","slug":"flag_st_barthelemy","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bermuda","slug":"flag_bermuda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Brunei","slug":"flag_brunei","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bolivia","slug":"flag_bolivia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Caribbean Netherlands","slug":"flag_caribbean_netherlands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Brazil","slug":"flag_brazil","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bahamas","slug":"flag_bahamas","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bhutan","slug":"flag_bhutan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Bouvet Island","slug":"flag_bouvet_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Botswana","slug":"flag_botswana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Belarus","slug":"flag_belarus","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Belize","slug":"flag_belize","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Canada","slug":"flag_canada","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cocos (Keeling) Islands","slug":"flag_cocos_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Congo - Kinshasa","slug":"flag_congo_kinshasa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Central African Republic","slug":"flag_central_african_republic","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Congo - Brazzaville","slug":"flag_congo_brazzaville","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Switzerland","slug":"flag_switzerland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cte dIvoire","slug":"flag_cote_d_ivoire","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cook Islands","slug":"flag_cook_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Chile","slug":"flag_chile","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cameroon","slug":"flag_cameroon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag China","slug":"flag_china","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Colombia","slug":"flag_colombia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Clipperton Island","slug":"flag_clipperton_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sark","slug":"flag_sark","unicode_version":"16.0","emoji_version":"16.0"},{"emoji":"","skin_tone_support":false,"name":"flag Costa Rica","slug":"flag_costa_rica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cuba","slug":"flag_cuba","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cape Verde","slug":"flag_cape_verde","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Curaao","slug":"flag_curacao","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Christmas Island","slug":"flag_christmas_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cyprus","slug":"flag_cyprus","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Czechia","slug":"flag_czechia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Germany","slug":"flag_germany","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Diego Garcia","slug":"flag_diego_garcia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Djibouti","slug":"flag_djibouti","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Denmark","slug":"flag_denmark","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Dominica","slug":"flag_dominica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Dominican Republic","slug":"flag_dominican_republic","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Algeria","slug":"flag_algeria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ceuta & Melilla","slug":"flag_ceuta_melilla","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ecuador","slug":"flag_ecuador","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Estonia","slug":"flag_estonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Egypt","slug":"flag_egypt","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Western Sahara","slug":"flag_western_sahara","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Eritrea","slug":"flag_eritrea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Spain","slug":"flag_spain","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Ethiopia","slug":"flag_ethiopia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag European Union","slug":"flag_european_union","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Finland","slug":"flag_finland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Fiji","slug":"flag_fiji","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Falkland Islands","slug":"flag_falkland_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Micronesia","slug":"flag_micronesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Faroe Islands","slug":"flag_faroe_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag France","slug":"flag_france","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Gabon","slug":"flag_gabon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag United Kingdom","slug":"flag_united_kingdom","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Grenada","slug":"flag_grenada","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Georgia","slug":"flag_georgia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag French Guiana","slug":"flag_french_guiana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guernsey","slug":"flag_guernsey","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ghana","slug":"flag_ghana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Gibraltar","slug":"flag_gibraltar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Greenland","slug":"flag_greenland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Gambia","slug":"flag_gambia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guinea","slug":"flag_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guadeloupe","slug":"flag_guadeloupe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Equatorial Guinea","slug":"flag_equatorial_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Greece","slug":"flag_greece","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag South Georgia & South Sandwich Islands","slug":"flag_south_georgia_south_sandwich_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guatemala","slug":"flag_guatemala","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guam","slug":"flag_guam","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guinea-Bissau","slug":"flag_guinea_bissau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Guyana","slug":"flag_guyana","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Hong Kong SAR China","slug":"flag_hong_kong_sar_china","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Heard & McDonald Islands","slug":"flag_heard_mcdonald_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Honduras","slug":"flag_honduras","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Croatia","slug":"flag_croatia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Haiti","slug":"flag_haiti","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Hungary","slug":"flag_hungary","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Canary Islands","slug":"flag_canary_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Indonesia","slug":"flag_indonesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ireland","slug":"flag_ireland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Israel","slug":"flag_israel","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Isle of Man","slug":"flag_isle_of_man","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag India","slug":"flag_india","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag British Indian Ocean Territory","slug":"flag_british_indian_ocean_territory","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Iraq","slug":"flag_iraq","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Iran","slug":"flag_iran","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Iceland","slug":"flag_iceland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Italy","slug":"flag_italy","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Jersey","slug":"flag_jersey","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Jamaica","slug":"flag_jamaica","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Jordan","slug":"flag_jordan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Japan","slug":"flag_japan","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Kenya","slug":"flag_kenya","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Kyrgyzstan","slug":"flag_kyrgyzstan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cambodia","slug":"flag_cambodia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Kiribati","slug":"flag_kiribati","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Comoros","slug":"flag_comoros","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Kitts & Nevis","slug":"flag_st_kitts_nevis","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag North Korea","slug":"flag_north_korea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag South Korea","slug":"flag_south_korea","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Kuwait","slug":"flag_kuwait","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Cayman Islands","slug":"flag_cayman_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Kazakhstan","slug":"flag_kazakhstan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Laos","slug":"flag_laos","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Lebanon","slug":"flag_lebanon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Lucia","slug":"flag_st_lucia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Liechtenstein","slug":"flag_liechtenstein","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sri Lanka","slug":"flag_sri_lanka","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Liberia","slug":"flag_liberia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Lesotho","slug":"flag_lesotho","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Lithuania","slug":"flag_lithuania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Luxembourg","slug":"flag_luxembourg","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Latvia","slug":"flag_latvia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Libya","slug":"flag_libya","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Morocco","slug":"flag_morocco","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Monaco","slug":"flag_monaco","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Moldova","slug":"flag_moldova","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Montenegro","slug":"flag_montenegro","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Martin","slug":"flag_st_martin","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Madagascar","slug":"flag_madagascar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Marshall Islands","slug":"flag_marshall_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag North Macedonia","slug":"flag_north_macedonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mali","slug":"flag_mali","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Myanmar (Burma)","slug":"flag_myanmar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mongolia","slug":"flag_mongolia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Macao SAR China","slug":"flag_macao_sar_china","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Northern Mariana Islands","slug":"flag_northern_mariana_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Martinique","slug":"flag_martinique","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mauritania","slug":"flag_mauritania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Montserrat","slug":"flag_montserrat","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Malta","slug":"flag_malta","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mauritius","slug":"flag_mauritius","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Maldives","slug":"flag_maldives","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Malawi","slug":"flag_malawi","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mexico","slug":"flag_mexico","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Malaysia","slug":"flag_malaysia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mozambique","slug":"flag_mozambique","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Namibia","slug":"flag_namibia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag New Caledonia","slug":"flag_new_caledonia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Niger","slug":"flag_niger","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Norfolk Island","slug":"flag_norfolk_island","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Nigeria","slug":"flag_nigeria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Nicaragua","slug":"flag_nicaragua","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Netherlands","slug":"flag_netherlands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Norway","slug":"flag_norway","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Nepal","slug":"flag_nepal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Nauru","slug":"flag_nauru","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Niue","slug":"flag_niue","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag New Zealand","slug":"flag_new_zealand","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Oman","slug":"flag_oman","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Panama","slug":"flag_panama","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Peru","slug":"flag_peru","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag French Polynesia","slug":"flag_french_polynesia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Papua New Guinea","slug":"flag_papua_new_guinea","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Philippines","slug":"flag_philippines","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Pakistan","slug":"flag_pakistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Poland","slug":"flag_poland","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Pierre & Miquelon","slug":"flag_st_pierre_miquelon","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Pitcairn Islands","slug":"flag_pitcairn_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Puerto Rico","slug":"flag_puerto_rico","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Palestinian Territories","slug":"flag_palestinian_territories","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Portugal","slug":"flag_portugal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Palau","slug":"flag_palau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Paraguay","slug":"flag_paraguay","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Qatar","slug":"flag_qatar","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Runion","slug":"flag_reunion","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Romania","slug":"flag_romania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Serbia","slug":"flag_serbia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Russia","slug":"flag_russia","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Rwanda","slug":"flag_rwanda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Saudi Arabia","slug":"flag_saudi_arabia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Solomon Islands","slug":"flag_solomon_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Seychelles","slug":"flag_seychelles","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sudan","slug":"flag_sudan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sweden","slug":"flag_sweden","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Singapore","slug":"flag_singapore","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Helena","slug":"flag_st_helena","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Slovenia","slug":"flag_slovenia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Svalbard & Jan Mayen","slug":"flag_svalbard_jan_mayen","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Slovakia","slug":"flag_slovakia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sierra Leone","slug":"flag_sierra_leone","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag San Marino","slug":"flag_san_marino","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Senegal","slug":"flag_senegal","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Somalia","slug":"flag_somalia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Suriname","slug":"flag_suriname","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag South Sudan","slug":"flag_south_sudan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag So Tom & Prncipe","slug":"flag_sao_tome_principe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag El Salvador","slug":"flag_el_salvador","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Sint Maarten","slug":"flag_sint_maarten","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Syria","slug":"flag_syria","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Eswatini","slug":"flag_eswatini","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tristan da Cunha","slug":"flag_tristan_da_cunha","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Turks & Caicos Islands","slug":"flag_turks_caicos_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Chad","slug":"flag_chad","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag French Southern Territories","slug":"flag_french_southern_territories","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Togo","slug":"flag_togo","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Thailand","slug":"flag_thailand","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tajikistan","slug":"flag_tajikistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tokelau","slug":"flag_tokelau","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Timor-Leste","slug":"flag_timor_leste","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Turkmenistan","slug":"flag_turkmenistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tunisia","slug":"flag_tunisia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tonga","slug":"flag_tonga","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Trkiye","slug":"flag_turkiye","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Trinidad & Tobago","slug":"flag_trinidad_tobago","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tuvalu","slug":"flag_tuvalu","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Taiwan","slug":"flag_taiwan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Tanzania","slug":"flag_tanzania","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Ukraine","slug":"flag_ukraine","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Uganda","slug":"flag_uganda","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag U.S. Outlying Islands","slug":"flag_u_s_outlying_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag United Nations","slug":"flag_united_nations","unicode_version":"4.0","emoji_version":"4.0"},{"emoji":"","skin_tone_support":false,"name":"flag United States","slug":"flag_united_states","unicode_version":"0.6","emoji_version":"0.6"},{"emoji":"","skin_tone_support":false,"name":"flag Uruguay","slug":"flag_uruguay","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Uzbekistan","slug":"flag_uzbekistan","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Vatican City","slug":"flag_vatican_city","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag St. Vincent & Grenadines","slug":"flag_st_vincent_grenadines","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Venezuela","slug":"flag_venezuela","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag British Virgin Islands","slug":"flag_british_virgin_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag U.S. Virgin Islands","slug":"flag_u_s_virgin_islands","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Vietnam","slug":"flag_vietnam","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Vanuatu","slug":"flag_vanuatu","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Wallis & Futuna","slug":"flag_wallis_futuna","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Samoa","slug":"flag_samoa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Kosovo","slug":"flag_kosovo","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Yemen","slug":"flag_yemen","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Mayotte","slug":"flag_mayotte","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag South Africa","slug":"flag_south_africa","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Zambia","slug":"flag_zambia","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag Zimbabwe","slug":"flag_zimbabwe","unicode_version":"2.0","emoji_version":"2.0"},{"emoji":"","skin_tone_support":false,"name":"flag England","slug":"flag_england","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"flag Scotland","slug":"flag_scotland","unicode_version":"5.0","emoji_version":"5.0"},{"emoji":"","skin_tone_support":false,"name":"flag Wales","slug":"flag_wales","unicode_version":"5.0","emoji_version":"5.0"}]}]'), jp = (n2) => {
      const e = [];
      return jl.map((t) => {
        const o = t.emojis.filter(
          (i2) => i2.name.indexOf(n2.toLowerCase()) >= 0
        );
        e.push({
          name: t.name,
          slug: t.slug,
          emojis: o
        });
      }), e;
    }, i0 = {
      smileys_emotion: "emotion",
      people_body: "face",
      animals_nature: "psychiatry",
      food_drink: "carrot",
      travel_places: "airplane",
      activities: "sports_soccer",
      objects: "objects",
      symbols: "yin_yang",
      flags: "flag"
    }, s0 = { class: "o-emoji-select" }, r0 = { key: 0 }, a0 = { class: "groups o-scroll" }, l0 = { class: "items" }, u0 = ["onClick"], c0 = {
      key: 0,
      class: "groups-empty"
    }, d0 = { class: "group-icons" }, p0 = ["onClick"], wl = /* @__PURE__ */ defineComponent({
      __name: "OEmojiSelect",
      props: {
        items: {
          type: Array,
          required: true
        },
        enableSearch: {
          type: Boolean,
          default: false
        }
      },
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = ref(null), s = ref(""), r = ref([]), a = ref([]), l = ref(0), u = computed(() => s.value ? r.value : t.items), c2 = computed(() => {
          let m = false;
          return u.value.map((f) => {
            m = m || f.emojis.length;
          }), m;
        });
        function d() {
          l.value = 0, r.value = s.value ? jp(s.value) : [];
        }
        function p2(m) {
          o("select", m);
        }
        function _(m, f) {
          l.value = f, a.value[f].scrollIntoView({ behavior: "instant", block: "start" });
        }
        return onMounted(() => {
        }), (m, f) => (openBlock(), createElementBlock("section", s0, [
          n2.enableSearch ? (openBlock(), createElementBlock("div", r0, [
            createVNode(unref(ai), {
              ref_key: "input",
              ref: i2,
              modelValue: s.value,
              "onUpdate:modelValue": [
                f[0] || (f[0] = (b) => s.value = b),
                d
              ],
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ue), {
                  name: "search",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])) : createCommentVNode("", true),
          createBaseVNode("section", a0, [
            (openBlock(true), createElementBlock(Fragment$1, null, renderList(u.value, (b, h2) => {
              var y;
              return withDirectives((openBlock(), createElementBlock("div", {
                key: `group-${h2}`,
                class: "group"
              }, [
                createBaseVNode("header", {
                  ref_for: true,
                  ref_key: "groupRefs",
                  ref: a
                }, toDisplayString(b.name), 513),
                createBaseVNode("section", l0, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(b.emojis, (C, v) => (openBlock(), createElementBlock("div", {
                    key: `item-${v}`
                  }, [
                    createBaseVNode("div", {
                      class: "item",
                      onClick: (x) => p2(C)
                    }, toDisplayString(C.emoji), 9, u0)
                  ]))), 128))
                ])
              ], 512)), [
                [vShow, (y = b.emojis) == null ? void 0 : y.length]
              ]);
            }), 128)),
            c2.value ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", c0, ""))
          ]),
          createBaseVNode("section", d0, [
            (openBlock(true), createElementBlock(Fragment$1, null, renderList(u.value, (b, h2) => (openBlock(), createBlock(unref(bo), {
              key: `target-${h2}`,
              delay: 300
            }, {
              trigger: withCtx(() => {
                var y;
                return [
                  withDirectives(createBaseVNode("div", {
                    class: normalizeClass(["item", { active: l.value === h2 }]),
                    onClick: (C) => _(b, h2)
                  }, [
                    createVNode(unref(ue), {
                      name: unref(i0)[b.slug]
                    }, null, 8, ["name"])
                  ], 10, p0), [
                    [vShow, (y = b.emojis) == null ? void 0 : y.length]
                  ])
                ];
              }),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(b.name), 1)
              ]),
              _: 2
            }, 1024))), 128))
          ])
        ]));
      }
    }), na = [
      {
        label: "Arduino",
        value: "arduino",
        icon: "code_blocks"
      },
      {
        label: "Bash",
        value: "bash",
        icon: "code_blocks"
      },
      {
        label: "C",
        value: "c",
        icon: "code_blocks"
      },
      {
        label: "C++",
        value: "cpp",
        icon: "code_blocks"
      },
      {
        label: "C#",
        value: "csharp",
        icon: "code_blocks"
      },
      {
        label: "CSS",
        value: "css",
        icon: "code_blocks"
      },
      {
        label: "Diff",
        value: "diff",
        icon: "code_blocks"
      },
      {
        label: "Go",
        value: "go",
        icon: "code_blocks"
      },
      {
        label: "GraphQL",
        value: "graphql",
        icon: "code_blocks"
      },
      {
        label: "Ini",
        value: "ini",
        icon: "code_blocks"
      },
      {
        label: "Java",
        value: "java",
        icon: "code_blocks"
      },
      {
        label: "JavaScript",
        value: "javascript",
        icon: "code_blocks"
      },
      {
        label: "JSON",
        value: "json",
        icon: "code_blocks"
      },
      {
        label: "Kotlin",
        value: "kotlin",
        icon: "code_blocks"
      },
      {
        label: "Less",
        value: "less",
        icon: "code_blocks"
      },
      {
        label: "Lua",
        value: "lua",
        icon: "code_blocks"
      },
      {
        label: "Makefile",
        value: "makefile",
        icon: "code_blocks"
      },
      {
        label: "Markdown",
        value: "markdown",
        icon: "code_blocks"
      },
      {
        label: "Objective-C",
        value: "objectivec",
        icon: "code_blocks"
      },
      {
        label: "Perl",
        value: "perl",
        icon: "code_blocks"
      },
      {
        label: "PHP",
        value: "php",
        icon: "code_blocks"
      },
      {
        label: "PHP-Template",
        value: "php-template",
        icon: "code_blocks"
      },
      {
        label: "Plain Text",
        value: "plaintext",
        icon: "code_blocks"
      },
      {
        label: "Python",
        value: "python",
        icon: "code_blocks"
      },
      {
        label: "Python-Repl",
        value: "python-repl",
        icon: "code_blocks"
      },
      {
        label: "R",
        value: "r",
        icon: "code_blocks"
      },
      {
        label: "Ruby",
        value: "ruby",
        icon: "code_blocks"
      },
      {
        label: "Rust",
        value: "rust",
        icon: "code_blocks"
      },
      {
        label: "Scss",
        value: "scss",
        icon: "code_blocks"
      },
      {
        label: "Shell",
        value: "shell",
        icon: "code_blocks"
      },
      {
        label: "SQL",
        value: "sql",
        icon: "code_blocks"
      },
      {
        label: "Swift",
        value: "swift",
        icon: "code_blocks"
      },
      {
        label: "TypeScript",
        value: "typescript",
        icon: "code_blocks"
      },
      {
        label: "VB.Net",
        value: "vbnet",
        icon: "code_blocks"
      },
      {
        label: "WebAssembly",
        value: "wasm",
        icon: "code_blocks"
      },
      {
        label: "XML",
        value: "xml",
        icon: "code_blocks"
      },
      {
        label: "YAML",
        value: "yaml",
        icon: "code_blocks"
      }
    ], _0 = { class: "selected-language" }, m0 = { class: "header" }, f0 = { class: "o-scroll" }, g0 = /* @__PURE__ */ defineComponent({
      __name: "OLanguageDropdown",
      props: {
        language: {
          type: String,
          default: "shell"
        }
      },
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = n2, o = e;
        Ae();
        const s = ref(), r = ref(), a = ref(""), l = ref(0), u = ref(""), c2 = computed(() => a.value ? na.filter(
          (h2) => h2.value.toLowerCase().indexOf(a.value.toLowerCase()) >= 0
        ) : na), d = computed(() => na.find((h2) => h2.value === u.value));
        function p2(h2) {
          h2 && setTimeout(() => {
            var y;
            (y = r.value) == null || y.focus(), l.value = 0, window.addEventListener("keyup", b);
          }, 0);
        }
        function _() {
          window.removeEventListener("keyup", b);
        }
        function m(h2) {
          _(), u.value = h2.value, o("select", h2.value);
        }
        function f() {
          m(c2.value[l.value]);
        }
        function b(h2) {
          if (c2.value.length > 0) {
            switch (h2.code) {
              case "ArrowDown":
                l.value = l.value + 1;
                break;
              case "ArrowUp":
                l.value = l.value - 1;
                break;
              case "Enter":
                f();
                break;
            }
            l.value >= c2.value.length && (l.value = 0), l.value < 0 && (l.value = c2.value.length - 1);
          } else
            l.value = 0;
        }
        return onMounted(() => {
          u.value = t.language;
        }), (h2, y) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: s,
          placement: "bottom-start",
          trigger: "click",
          "tippy-class": "o-language-popover dropdown",
          "onUpdate:show": p2
        }, {
          trigger: withCtx(() => [
            createVNode(unref(Wn), { class: "o-dropdown-btn" }, {
              default: withCtx(() => {
                var C;
                return [
                  createBaseVNode("span", _0, toDisplayString((C = d.value) == null ? void 0 : C.label), 1),
                  createVNode(unref(ue), {
                    name: "arrow_drop_down",
                    class: "arrow"
                  })
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("header", m0, [
              createVNode(unref(ai), {
                ref_key: "input",
                ref: r,
                modelValue: a.value,
                "onUpdate:modelValue": y[0] || (y[0] = (C) => a.value = C),
                type: "text",
                placeholder: "Search",
                autofocus: "",
                clearable: ""
              }, {
                prefix: withCtx(() => [
                  createVNode(unref(ue), {
                    name: "search",
                    class: "o-tips"
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createBaseVNode("section", f0, [
              createVNode(unref(Ct), {
                hoverable: "",
                clickable: ""
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(c2.value, (C, v) => (openBlock(), createBlock(unref(_t), {
                    key: v,
                    onClick: (x) => m(C),
                    class: normalizeClass({
                      "is-active": C.value === u.value,
                      "is-select": v === l.value
                    })
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: C.icon
                      }, null, 8, ["name"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(C.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "class"]))), 128))
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 512));
      }
    }), h0 = { class: "o-media-input" }, v0 = { class: "fields" }, b0 = { class: "actions" }, wp = /* @__PURE__ */ defineComponent({
      __name: "OMediaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["input"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: i2 } = Ae(), s = ref(), r = ref(""), a = ref("");
        function l() {
          return a.value ? (r.value = "null", true) : (r.value = "error", false);
        }
        function u() {
          l() && o("input", a.value);
        }
        return onMounted(() => {
          a.value = t.val, setTimeout(() => {
            var c2;
            (c2 = s.value) == null || c2.focus();
          }, 0);
        }), (c2, d) => (openBlock(), createElementBlock("section", h0, [
          createBaseVNode("section", v0, [
            d[1] || (d[1] = createBaseVNode("div", { class: "o-media-title" }, "Link", -1)),
            createVNode(unref(ai), {
              ref_key: "input",
              ref: s,
              modelValue: a.value,
              "onUpdate:modelValue": d[0] || (d[0] = (p2) => a.value = p2),
              status: r.value,
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ue), {
                  name: "link",
                  class: "o-tips"
                })
              ]),
              _: 1
            }, 8, ["modelValue", "status"])
          ]),
          createBaseVNode("footer", b0, [
            createVNode(unref(Wn), {
              type: "info",
              onClick: u
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i2)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), k0 = { class: "o-meta-input" }, y0 = { class: "header" }, j0 = { class: "title" }, w0 = { class: "fields" }, E0 = { class: "actions" }, Ep = /* @__PURE__ */ defineComponent({
      __name: "OMetaInput",
      props: {
        val: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: "Link"
        },
        type: {
          type: String,
          default: "link"
        },
        icon: {
          type: String,
          default: "link"
        },
        secondIcon: {
          type: String,
          default: ""
        },
        secondLabel: {
          type: String,
          default: ""
        }
      },
      emits: ["cancel", "confirm"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: i2 } = Ae(), s = ref(null), r = ref("");
        function a() {
          console.log("confirm", r.value), o("confirm", r.value);
        }
        return onMounted(() => {
          r.value = t.val, setTimeout(() => {
            var l;
            (l = s.value) == null || l.focus();
          }, 0);
        }), (l, u) => (openBlock(), createElementBlock("section", k0, [
          createBaseVNode("section", y0, [
            createBaseVNode("div", j0, toDisplayString(n2.title), 1),
            createBaseVNode("div", null, [
              renderSlot(l.$slots, "header-right")
            ])
          ]),
          createBaseVNode("section", w0, [
            createVNode(unref(ai), {
              ref_key: "input",
              ref: s,
              modelValue: r.value,
              "onUpdate:modelValue": u[0] || (u[0] = (c2) => r.value = c2),
              type: "text",
              autofocus: "",
              clearable: ""
            }, {
              prefix: withCtx(() => [
                createVNode(unref(ue), {
                  name: n2.icon,
                  class: "o-tips"
                }, null, 8, ["name"])
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          createBaseVNode("footer", E0, [
            createVNode(unref(Wn), {
              type: "tertiary",
              onClick: u[1] || (u[1] = (c2) => o("cancel"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i2)("label.cancel")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(Wn), {
              type: "info",
              onClick: a
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i2)("label.ok")), 1)
              ]),
              _: 1
            })
          ])
        ]));
      }
    }), C0 = { class: "o-table-grid" }, S0 = ["onMouseover"], x0 = /* @__PURE__ */ defineComponent({
      __name: "OTableGrid",
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = e, o = ref(6), i2 = ref(6), s = ref(2), r = ref(2);
        function a(u, c2) {
          s.value = u, r.value = c2, o.value === u && o.value < 10 && (o.value += 1), i2.value === c2 && i2.value < 10 && (i2.value += 1);
        }
        function l() {
          t("select", {
            rows: s.value,
            cols: r.value,
            withHeaderRow: true
          });
        }
        return (u, c2) => (openBlock(), createElementBlock("section", C0, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList(o.value, (d, p2) => (openBlock(), createElementBlock("div", {
            class: "rows",
            key: `row-${p2}`
          }, [
            (openBlock(true), createElementBlock(Fragment$1, null, renderList(i2.value, (_, m) => (openBlock(), createElementBlock("div", {
              key: `col-${m}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(["cell", { selected: d <= s.value && _ <= r.value }]),
                onMouseover: (f) => a(d, _),
                onClick: l
              }, null, 42, S0)
            ]))), 128))
          ]))), 128)),
          createBaseVNode("footer", null, toDisplayString(s.value) + " x " + toDisplayString(r.value), 1)
        ]));
      }
    }), T0 = { class: "o-table-cell-background o-button-group" }, A0 = { class: "o-command-btn" }, N0 = /* @__PURE__ */ defineComponent({
      __name: "OTableCellBackground",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(), s = ref("#ffec3d");
        function r() {
          a(s.value);
        }
        function a(l) {
          i2.value.setShow(false), s.value = l, o(e.editor, "tableCellAttribute", {
            name: "background",
            value: s.value
          });
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          placement: "bottom-start",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(bo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", T0, [
                  createBaseVNode("div", {
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, [
                    createVNode(unref(ue), {
                      name: "crop_16_9",
                      class: "arrow"
                    }),
                    createBaseVNode("div", {
                      class: "indicator",
                      style: normalizeStyle(`background: ${s.value}`)
                    }, null, 4)
                  ]),
                  createBaseVNode("div", A0, [
                    createVNode(unref(ue), { name: "arrow_drop_down" })
                  ])
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(kl), {
              "default-color": "",
              "default-label": unref(t)("editor.noColor"),
              onSelect: a
            }, null, 8, ["default-label"])
          ]),
          _: 1
        }, 512));
      }
    }), O0 = { class: "o-simple-color-board" }, M0 = { class: "fore-colors" }, R0 = { class: "color-row" }, I0 = { class: "color-row" }, L0 = { class: "back-colors" }, D0 = { class: "color-row" }, B0 = { class: "color-row" }, P0 = /* @__PURE__ */ defineComponent({
      __name: "OTextColorBoard",
      props: {
        foreColor: {
          type: String,
          default: ""
        },
        backColor: {
          type: String,
          default: ""
        },
        activeColor: {
          type: String,
          default: ""
        }
      },
      emits: ["select"],
      setup(n2, { emit: e }) {
        const t = e;
        function o(r, a) {
          t("select", r, a.value);
        }
        const i2 = computed(() => [
          { label: "Grey", value: "#787774" },
          { label: "Brown", value: "#9F6B53" },
          { label: "Orange", value: "#D9730D" },
          { label: "Yellow", value: "#CB912F" },
          { label: "Green", value: "#448361" },
          { label: "Blue", value: "#337EA9" },
          { label: "Purple", value: "#9065B0" },
          { label: "Pink", value: "#C14C8A" },
          { label: "Red", value: "#D44C47" }
        ]), s = computed(() => [
          { label: "Grey", value: "#F1F1EF" },
          { label: "Brown", value: "#F4EEEE" },
          { label: "Orange", value: "#FAEBDD" },
          { label: "Yellow", value: "#FBF3DB" },
          { label: "Green", value: "#EDF3EC" },
          { label: "Blue", value: "#E7F3F8" },
          { label: "Purple", value: "#F6F3F9" },
          { label: "Pink", value: "#FAF1F5" },
          { label: "Red", value: "#FDEBEC" }
        ]);
        return (r, a) => (openBlock(), createElementBlock("section", O0, [
          createBaseVNode("section", M0, [
            a[4] || (a[4] = createBaseVNode("div", { class: "label o-tips" }, "Color", -1)),
            createBaseVNode("div", R0, [
              createVNode(unref(Ke), {
                icon: "format_text",
                tooltip: "Default color",
                "content-class": "border",
                onClick: a[0] || (a[0] = (l) => o("foreColor", { value: "" }))
              }),
              n2.foreColor ? (openBlock(), createBlock(unref(Ke), {
                key: 0,
                icon: "format_text",
                color: n2.foreColor,
                tooltip: "Last used",
                "content-class": "border",
                onClick: a[1] || (a[1] = (l) => o("foreColor", { value: n2.foreColor }))
              }, null, 8, ["color"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", I0, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(i2.value, (l, u) => (openBlock(), createBlock(unref(Ke), {
                key: `col-${u}`,
                icon: "format_text",
                color: l.value,
                tooltip: l.label,
                onClick: (c2) => o("foreColor", l)
              }, null, 8, ["color", "tooltip", "onClick"]))), 128))
            ])
          ]),
          createBaseVNode("section", L0, [
            a[5] || (a[5] = createBaseVNode("div", { class: "label o-tips" }, "Background", -1)),
            createBaseVNode("div", D0, [
              createVNode(unref(Ke), {
                icon: "slash_forward",
                tooltip: "No Color",
                "content-class": "border",
                onClick: a[2] || (a[2] = (l) => o("backColor", { value: "" }))
              }),
              n2.backColor ? (openBlock(), createBlock(unref(Ke), {
                key: 0,
                icon: "format_text",
                tooltip: "Last used",
                "content-class": "border",
                "content-style": { backgroundColor: n2.backColor },
                onClick: a[3] || (a[3] = (l) => o("backColor", { value: n2.backColor }))
              }, null, 8, ["content-style"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", B0, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (l, u) => (openBlock(), createBlock(unref(Ke), {
                key: `col-${u}`,
                icon: "format_text",
                tooltip: l.label,
                "content-style": { backgroundColor: l.value },
                onClick: (c2) => o("backColor", l)
              }, null, 8, ["tooltip", "content-style", "onClick"]))), 128))
            ])
          ])
        ]));
      }
    }), qs = [
      {
        type: "paragraph",
        content: []
      }
    ], Cp = [
      {
        type: "listItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], Sp = [
      {
        type: "taskItem",
        content: [
          {
            type: "paragraph",
            content: []
          }
        ]
      }
    ], $0 = { class: "o-add-node-view" }, z0 = {
      key: 0,
      class: "view-main"
    }, F0 = { class: "group o-tips" }, H0 = { class: "panel" }, U0 = { class: "group o-tips" }, q0 = {
      key: 1,
      class: "item"
    }, K0 = {
      key: 1,
      class: "view-emoji"
    }, V0 = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: En,
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: s } = Ae();
        Le();
        const a = ref("main"), l = ref(0);
        function u(p2) {
          const _ = t.editor.chain();
          let m = null;
          switch (p2.value) {
            case "blockquote":
              m = {
                content: qs
              };
              break;
            case "callout":
              m = {
                content: qs,
                attrs: { icon: "" }
              };
              break;
            case "codeBlock":
              m = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              m = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              m = {
                attrs: p2.options
              };
              break;
            case "horizontalRule":
              m = {};
              break;
            case "paragraph":
              m = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              m = {
                content: Cp
              };
              break;
            case "taskList":
              m = {
                content: Sp
              };
              break;
            case "table":
              setTimeout(() => {
                _.insertContentAt(d.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1);
              return;
            case "image":
              m = {
                type: "paragraph",
                content: [{ type: p2.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              m = { attrs: { src: "init" } };
              break;
          }
          m && (m.type = m.type || p2.value, setTimeout(() => {
            c2.value ? _.insertContent(m).focus().run() : _.insertContentAt(d.value, m).focus().run();
          }, 1)), o("action", p2);
        }
        const c2 = computed(() => t.node.content.size === 0), d = computed(() => c2.value ? l.value : l.value + t.node.nodeSize);
        return onMounted(() => {
          l.value = t.getPos();
        }), (p2, _) => (openBlock(), createElementBlock("section", $0, [
          a.value === "main" ? (openBlock(), createElementBlock("section", z0, [
            createBaseVNode("section", null, [
              createBaseVNode("div", F0, toDisplayString(unref(s)("label.basic")), 1),
              createBaseVNode("section", H0, [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(Zi), (m, f) => (openBlock(), createBlock(unref(Ke), {
                  key: f,
                  icon: m.icon,
                  tooltip: unref(s)(m.label),
                  quaternary: "",
                  onClick: (b) => u(m)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Pi).length ? (openBlock(true), createElementBlock(Fragment$1, { key: 0 }, renderList(unref(Pi), (m, f) => (openBlock(), createElementBlock(Fragment$1, { key: f }, [
                  m.group ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                    f > 0 ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", U0, toDisplayString(unref(s)(m.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(_t), {
                    class: "item",
                    clickable: "",
                    onClick: (b) => u(m)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: m.icon,
                        color: m.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(s)(m.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", q0, "No result"))
              ]),
              _: 1
            })
          ])) : a.value === "emoji" ? (openBlock(), createElementBlock("section", K0)) : createCommentVNode("", true)
        ]));
      }
    }), W0 = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: En,
      setup(n2) {
        const e = n2, t = ref(null), o = ref(false);
        function i2(r) {
          o.value = r;
        }
        function s() {
          var r;
          (r = t.value) == null || r.setShow(false), o.value = false;
        }
        return (r, a) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: t,
          placement: "left",
          trigger: "mouseenter",
          arrow: "",
          "onUpdate:show": i2
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-node", { "is-selected": o.value }])
            }, [
              createVNode(unref(Wn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ue), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(V0, mergeProps(e, { onAction: s }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), G0 = { class: "o-drag-node-view" }, Y0 = {
      key: 0,
      class: "view-main"
    }, J0 = { key: 0 }, Z0 = { class: "panel" }, X0 = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: En,
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: s } = Ae(), { onCommand: a } = Le(), l = ref("main"), u = ref(["heading", "codeBlock", "paragraph"]), c2 = computed(() => {
          var b, h2;
          const f = (b = t.node) == null ? void 0 : b.content.content;
          if (f.length > 0) {
            const y = f[0];
            if (y.type.name === "image")
              return y.type.name;
          }
          return (h2 = t.node) == null ? void 0 : h2.type.name;
        }), d = computed(() => Us.find((f) => f.value === c2.value));
        function p2(f) {
          var b;
          return f.value === c2.value && ((b = t.editor) == null ? void 0 : b.isActive(c2.value, f.options));
        }
        function _(f) {
          switch (f.value) {
            default:
              m(f);
              break;
          }
          o("action", f);
        }
        function m(f) {
          var C, v, x, S, F;
          const b = t.getPos();
          if (f.value === c2.value && u.value.indexOf(c2.value) < 0) {
            const Y = (C = t.editor) == null ? void 0 : C.isActive(c2.value), q = (v = t.editor) == null ? void 0 : v.commands.lift(c2.value);
            console.log("lift", c2.value, Y, q);
            return;
          }
          const h2 = (x = t.editor) == null ? void 0 : x.commands, y = (S = t.editor) == null ? void 0 : S.chain().focus(b + 1);
          console.log("runCommand", f), a(h2, y, f.value, f.options), (F = t.editor) == null || F.commands.setNodeSelection(b);
        }
        return computed(() => [
          {
            label: "editor.duplicate",
            value: "duplicate",
            icon: "content_copy",
            color: ze.blue,
            tips: "Ctrl+D",
            group: "label.common"
          },
          {
            label: "editor.delete",
            value: "delete",
            icon: "delete",
            tips: "Ctrl+D",
            color: ze.deepOrange
          }
        ]), (f, b) => (openBlock(), createElementBlock("section", G0, [
          l.value === "main" ? (openBlock(), createElementBlock("section", Y0, [
            d.value ? (openBlock(), createElementBlock("section", J0, [
              b[0] || (b[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", Z0, [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(Us), (h2, y) => (openBlock(), createBlock(unref(Ke), {
                  key: y,
                  icon: h2.icon,
                  tooltip: unref(s)(h2.label),
                  "content-class": { "is-active": p2(h2) },
                  quaternary: "",
                  onClick: (C) => _(h2)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(ri), mergeProps(t, {
              colorful: "",
              "show-group": "",
              onAction: _
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), Q0 = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: En,
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e;
        Le();
        const s = ref(null), r = ref(0), a = ref(false), l = ref(["heading", "codeBlock", "paragraph"]), u = ref(false), c2 = computed(() => {
          var y, C;
          const h2 = (y = t.node) == null ? void 0 : y.content.content;
          if (h2.length > 0) {
            const v = h2[0];
            if (v.type.name === "image")
              return v.type.name;
          }
          return (C = t.node) == null ? void 0 : C.type.name;
        }), d = computed(() => {
          var y;
          let h2 = c2.value;
          return h2 === "heading" ? {
            icon: `format_h${((y = t.node.attrs) == null ? void 0 : y.level) || 1}`,
            color: ze.blue
          } : (h2 === "table-wrapper" && (h2 = "table"), vl.find((C) => C.value === h2) || { icon: "title" });
        });
        function p2(h2) {
          var y;
          (y = s.value) == null || y.setShow(false), o("action", h2);
        }
        function _(h2) {
          a.value = h2, console.log("show", h2), h2 && m();
        }
        function m() {
          var y;
          let h2 = t.getPos();
          l.value.includes(c2.value) || (h2 += 1), (y = t.editor) == null || y.commands.setNodeSelection(h2), r.value = h2;
        }
        function f(h2) {
          u.value = true, setTimeout(() => {
            u.value = false;
          }, 10);
        }
        function b(h2) {
          u.value = false;
        }
        return (h2, y) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: s,
          placement: "left",
          size: "medium",
          trigger: "click",
          arrow: "",
          "onUpdate:show": _
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-node", { "is-selected": a.value, "is-dragging": u.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: f,
              onDragend: b
            }, [
              createVNode(unref(Wn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ue), {
                    name: d.value.icon,
                    color: d.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ue), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(X0, mergeProps(t, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), eb = /* @__PURE__ */ defineComponent({
      __name: "index",
      props: En,
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = ref(false), s = ref(0);
        ref(0);
        const r = computed(() => a.value === "paragraph" && t.node.content.size === 0), a = computed(() => {
          var p2, _;
          const d = (p2 = t.node) == null ? void 0 : p2.content.content;
          if (d.length > 0) {
            const m = d[0];
            if (m.type.name === "image")
              return m.type.name;
          }
          return (_ = t.node) == null ? void 0 : _.type.name;
        }), l = computed(() => {
          var d;
          return s.value || ((d = t.node.attrs) == null ? void 0 : d.level);
        }), u = computed(() => a.value === "heading" ? `type-heading-${l.value}` : `type-${a.value}`);
        function c2(d) {
          o("action", d);
        }
        return onMounted(() => {
          s.value = 0;
        }), (d, p2) => {
          var _;
          return (_ = d.editor) != null && _.isEditable ? (openBlock(), createElementBlock("section", {
            key: 0,
            class: normalizeClass(["o-side-node", { "is-active": i2.value, "is-empty": r.value }])
          }, [
            createBaseVNode("section", {
              class: normalizeClass(["action-container", u.value])
            }, [
              createVNode(W0, normalizeProps(guardReactiveProps(t)), null, 16),
              r.value ? createCommentVNode("", true) : (openBlock(), createBlock(Q0, mergeProps({ key: 0 }, t, { onAction: c2 }), null, 16))
            ], 2)
          ], 2)) : createCommentVNode("", true);
        };
      }
    }), Jt = /* @__PURE__ */ defineComponent({
      __name: "ONodeView",
      props: En,
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = inject("sideNode", { value: false });
        return computed(() => {
          const s = {};
          return t.node.attrs["data-id"] && (s["data-id"] = t.node.attrs["data-id"]), s;
        }), (s, r) => (openBlock(), createBlock(unref(al), {
          class: "o-node-view",
          "data-id": s.node.attrs["data-id"]
        }, {
          default: withCtx(() => {
            var a;
            return [
              unref(i2) && ((a = s.editor) != null && a.isEditable) ? (openBlock(), createBlock(eb, mergeProps({ key: 0 }, t, {
                onAction: r[0] || (r[0] = (l) => o("action"))
              }), null, 16)) : createCommentVNode("", true),
              renderSlot(s.$slots, "default")
            ];
          }),
          _: 3
        }, 8, ["data-id"]));
      }
    }), nb = { class: "o-add-node-view" }, tb = {
      key: 0,
      class: "view-main"
    }, ob = { class: "group o-tips" }, ib = { class: "panel" }, sb = { class: "group o-tips" }, rb = {
      key: 1,
      class: "item"
    }, ab = /* @__PURE__ */ defineComponent({
      __name: "AddNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: s } = Ae();
        Le();
        const a = ref("main");
        function l(d) {
          const p2 = t.editor.chain();
          let _ = null;
          switch (d.value) {
            case "blockquote":
              _ = {
                content: qs
              };
              break;
            case "callout":
              _ = {
                content: qs,
                attrs: { icon: "" }
              };
              break;
            case "codeBlock":
              _ = {
                content: [],
                attrs: { language: "shell" }
              };
              break;
            case "emoji":
              _ = {
                type: "paragraph",
                content: [{ type: "text", text: ":" }]
              };
              break;
            case "heading":
              _ = {
                attrs: d.options
              };
              break;
            case "horizontalRule":
              _ = {};
              break;
            case "paragraph":
              _ = {
                content: []
              };
              break;
            case "bulletList":
            case "orderedList":
              _ = {
                content: Cp
              };
              break;
            case "taskList":
              _ = {
                content: Sp
              };
              break;
            case "table":
              setTimeout(() => {
                p2.insertContentAt(c2.value, {
                  type: "paragraph",
                  content: []
                }).insertTable({ rows: 3, cols: 3, withHeaderRow: true }).focus().run();
              }, 1), o("action", d);
              return;
            case "image":
              _ = {
                type: "paragraph",
                content: [{ type: d.value, attrs: { src: "init" } }]
              };
              break;
            case "model-viewer":
              _ = { attrs: { src: "init" } };
              break;
          }
          if (_) {
            const m = c2.value;
            _.type = _.type || d.value, setTimeout(() => {
              u.value ? p2.insertContent(_).focus().run() : p2.insertContentAt(m, _).focus().run();
            }, 1);
          }
          o("action", d);
        }
        const u = computed(() => {
          var d;
          return ((d = t.node) == null ? void 0 : d.content.size) === 0;
        }), c2 = computed(() => u.value ? t.getPos() : t.getPos() + t.node.nodeSize);
        return (d, p2) => (openBlock(), createElementBlock("section", nb, [
          a.value === "main" ? (openBlock(), createElementBlock("section", tb, [
            createBaseVNode("section", null, [
              createBaseVNode("div", ob, toDisplayString(unref(s)("label.basic")), 1),
              createBaseVNode("section", ib, [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(Zi), (_, m) => (openBlock(), createBlock(unref(Ke), {
                  key: m,
                  icon: _.icon,
                  tooltip: unref(s)(_.label),
                  quaternary: "",
                  onClick: (f) => l(_)
                }, null, 8, ["icon", "tooltip", "onClick"]))), 128))
              ])
            ]),
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                unref(Pi).length ? (openBlock(true), createElementBlock(Fragment$1, { key: 0 }, renderList(unref(Pi), (_, m) => (openBlock(), createElementBlock(Fragment$1, { key: m }, [
                  _.group ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                    m > 0 ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                    createBaseVNode("div", sb, toDisplayString(unref(s)(_.group)), 1)
                  ], 64)) : createCommentVNode("", true),
                  createVNode(unref(_t), {
                    class: "item",
                    clickable: "",
                    onClick: (f) => l(_)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: _.icon,
                        color: _.color
                      }, null, 8, ["name", "color"])
                    ]),
                    default: withCtx(() => [
                      createTextVNode(" " + toDisplayString(unref(s)(_.label)), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ], 64))), 128)) : (openBlock(), createElementBlock("div", rb, "No result"))
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ]));
      }
    }), lb = /* @__PURE__ */ defineComponent({
      __name: "AddNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      setup(n2) {
        const e = n2, t = ref(), o = ref(false), i2 = computed(() => {
          var l;
          return ((l = e.node) == null ? void 0 : l.content.size) === 0;
        });
        computed(() => i2.value ? e.getPos() : e.getPos() + e.node.nodeSize);
        function s(l) {
          o.value = l;
        }
        function r() {
          var l;
          (l = t.value) == null || l.setShow(true);
        }
        function a() {
          var l;
          (l = t.value) == null || l.setShow(false), o.value = false;
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: t,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "manual",
          offset: [0, 4],
          "onUpdate:show": s
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-add-btn", { "is-selected": o.value }])
            }, [
              createVNode(unref(Wn), {
                type: "tertiary",
                class: "o-node-btn",
                onClick: r
              }, {
                default: withCtx(() => [
                  createVNode(unref(ue), {
                    name: "add",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 2)
          ]),
          default: withCtx(() => [
            createVNode(ab, mergeProps(e, { onAction: a }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), ub = { class: "o-drag-node-view" }, cb = {
      key: 0,
      class: "view-main"
    }, db = { key: 0 }, pb = { class: "panel" }, _b = /* @__PURE__ */ defineComponent({
      __name: "DragNodeView",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, { tr: s } = Ae(), { onCommand: a } = Le(), l = ref("main"), u = ref(["heading", "codeBlock", "paragraph"]), c2 = computed(() => {
          var b, h2;
          const f = (b = t.node) == null ? void 0 : b.content.content;
          if (f.length > 0) {
            const y = f[0];
            if (y.type.name === "image")
              return y.type.name;
          }
          return (h2 = t.node) == null ? void 0 : h2.type.name;
        }), d = computed(() => Us.find((f) => f.value === c2.value));
        function p2(f) {
          var b;
          return f.value === c2.value && ((b = t.editor) == null ? void 0 : b.isActive(c2.value, f.options));
        }
        function _(f) {
          switch (f.value) {
            case "delete":
              break;
            case "duplicate":
              break;
            default:
              m(f);
              break;
          }
          o("action", f);
        }
        function m(f) {
          var C, v, x, S, F;
          const b = t.getPos();
          if (f.value === c2.value && u.value.indexOf(c2.value) < 0) {
            const Y = (C = t.editor) == null ? void 0 : C.isActive(c2.value), q = (v = t.editor) == null ? void 0 : v.commands.lift(c2.value);
            console.log("lift", c2.value, Y, q);
            return;
          }
          const h2 = (x = t.editor) == null ? void 0 : x.commands, y = (S = t.editor) == null ? void 0 : S.chain().focus(b + 1);
          console.log("runCommand", f), a(h2, y, f.value, f.options), (F = t.editor) == null || F.commands.focus();
        }
        return (f, b) => (openBlock(), createElementBlock("section", ub, [
          l.value === "main" ? (openBlock(), createElementBlock("section", cb, [
            d.value ? (openBlock(), createElementBlock("section", db, [
              b[0] || (b[0] = createBaseVNode("div", { class: "group o-tips" }, "Turn into", -1)),
              createBaseVNode("section", pb, [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(Us), (h2, y) => (openBlock(), createBlock(unref(Ke), {
                  key: y,
                  icon: h2.icon,
                  tooltip: unref(s)(h2.label),
                  "content-class": { "is-active": p2(h2) },
                  quaternary: "",
                  onClick: (C) => _(h2)
                }, null, 8, ["icon", "tooltip", "content-class", "onClick"]))), 128))
              ])
            ])) : createCommentVNode("", true),
            createVNode(unref(ri), mergeProps(t, {
              colorful: "",
              "show-group": "",
              onAction: _
            }), null, 16)
          ])) : createCommentVNode("", true)
        ]));
      }
    }), mb = /* @__PURE__ */ defineComponent({
      __name: "DragNode",
      props: {
        editor: {
          type: Object,
          required: true
        },
        node: {
          type: Object,
          required: true
        },
        getPos: {
          type: Function,
          required: true
        },
        updateAttributes: {
          type: Function,
          required: true
        },
        deleteNode: {
          type: Function,
          required: true
        }
      },
      emits: ["action", "dragstart", "dragend"],
      setup(n2, { emit: e }) {
        const t = n2, o = e;
        Le();
        const s = ref(null), r = ref(false), a = ref(["heading", "codeBlock", "paragraph"]), l = computed(() => {
          var b, h2, y;
          const f = (h2 = (b = t.node) == null ? void 0 : b.content) == null ? void 0 : h2.content;
          if ((f == null ? void 0 : f.length) > 0) {
            const C = f[0];
            if (C.type.name === "image")
              return C.type.name;
          }
          return (y = t.node) == null ? void 0 : y.type.name;
        }), u = computed(() => {
          var b;
          let f = l.value;
          return f === "heading" ? {
            icon: `format_h${((b = t.node.attrs) == null ? void 0 : b.level) || 1}`,
            color: ze.blue
          } : (f === "table-wrapper" && (f = "table"), vl.find((h2) => h2.value === f) || { icon: "title" });
        });
        function c2(f) {
          o("dragstart", f);
        }
        function d(f) {
          o("dragend", f);
        }
        function p2(f) {
          var b;
          (b = s.value) == null || b.setShow(false), o("action", f);
        }
        function _(f) {
          r.value = f, f && m();
        }
        function m() {
          var b;
          let f = t.getPos();
          a.value.includes(l.value) || (f += 1), (b = t.editor) == null || b.commands.setNodeSelection(f);
        }
        return watch(
          () => t.getPos(),
          (f) => {
            var b;
            (b = s.value) == null || b.setShow(false);
          }
        ), (f, b) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: s,
          placement: "left",
          "tippy-class": "dropdown",
          trigger: "click",
          offset: [0, 2],
          "onUpdate:show": _
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["o-drag-btn", { selected: r.value }]),
              contenteditable: "false",
              draggable: "true",
              "data-drag-handle": "",
              onDragstart: c2,
              onDragend: d
            }, [
              createVNode(unref(Wn), {
                type: "tertiary",
                class: "o-node-btn"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ue), {
                    name: u.value.icon,
                    color: u.value.color,
                    small: ""
                  }, null, 8, ["name", "color"]),
                  createVNode(unref(ue), {
                    name: "drag_indicator",
                    small: ""
                  })
                ]),
                _: 1
              })
            ], 34)
          ]),
          default: withCtx(() => [
            createVNode(_b, mergeProps(t, { onAction: p2 }), null, 16)
          ]),
          _: 1
        }, 512));
      }
    }), Wn = /* @__PURE__ */ defineComponent({
      __name: "OBtn",
      props: {
        icon: {
          type: String,
          default: ""
        },
        iconClass: {
          type: [String, Object],
          default: ""
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["click"],
      setup(n2, { emit: e }) {
        const t = e;
        return (o, i2) => (openBlock(), createElementBlock("button", {
          class: normalizeClass(["o-btn", n2.type ? `type-${n2.type}` : ""]),
          onClick: i2[0] || (i2[0] = (s) => t("click", s))
        }, [
          n2.icon ? (openBlock(), createBlock(unref(ue), {
            key: 0,
            name: n2.icon,
            class: normalizeClass(n2.iconClass)
          }, null, 8, ["name", "class"])) : createCommentVNode("", true),
          renderSlot(o.$slots, "default")
        ], 2));
      }
    }), fb = { class: "o-checkbox" }, gb = { class: "o-checkbox__main" }, hb = { class: "o-checkbox__suffix" }, xp = /* @__PURE__ */ defineComponent({
      __name: "OCheckbox",
      props: {
        modelValue: {
          type: Boolean,
          default: false
        },
        label: {
          type: String,
          default: ""
        }
      },
      emits: ["update:modelValue"],
      setup(n2, { emit: e }) {
        const t = n2, o = e, i2 = computed({
          get() {
            return t.modelValue;
          },
          set(s) {
            o("update:modelValue", s);
          }
        });
        return (s, r) => (openBlock(), createElementBlock("div", fb, [
          createBaseVNode("div", gb, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": r[0] || (r[0] = (a) => i2.value = a),
              type: "checkbox"
            }, null, 512), [
              [vModelCheckbox, i2.value]
            ])
          ]),
          createBaseVNode("div", hb, toDisplayString(n2.label), 1)
        ]));
      }
    }), pt = /* @__PURE__ */ defineComponent({
      __name: "ODivider",
      props: {
        vertical: {
          type: Boolean,
          default: false
        }
      },
      setup(n2) {
        return (e, t) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-divider", { "o-divider-vertical": n2.vertical }])
        }, null, 2));
      }
    }), vb = { class: "o-input__prefix" }, bb = { class: "o-input__main" }, kb = { class: "o-input__suffix" }, ai = /* @__PURE__ */ defineComponent({
      __name: "OInput",
      props: {
        modelValue: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: false
        },
        type: {
          type: String,
          default: ""
        }
      },
      emits: ["blur", "update:modelValue"],
      setup(n2, { expose: e, emit: t }) {
        const o = n2, i2 = t, s = ref(null), r = computed({
          get() {
            return o.modelValue;
          },
          set(u) {
            i2("update:modelValue", u);
          }
        });
        function a() {
          var u;
          (u = s.value) == null || u.focus();
        }
        function l() {
          r.value = "", a();
        }
        return e({
          clear: l,
          focus: a
        }), (u, c2) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["o-input", `type-${n2.type}`])
        }, [
          createBaseVNode("div", vb, [
            renderSlot(u.$slots, "prefix")
          ]),
          createBaseVNode("div", bb, [
            withDirectives(createBaseVNode("input", {
              ref_key: "input",
              ref: s,
              "onUpdate:modelValue": c2[0] || (c2[0] = (d) => r.value = d),
              onBlur: c2[1] || (c2[1] = (d) => i2("blur"))
            }, null, 544), [
              [vModelText, r.value]
            ])
          ]),
          createBaseVNode("div", kb, [
            renderSlot(u.$slots, "suffix"),
            n2.clearable && r.value ? (openBlock(), createBlock(ue, {
              key: 0,
              name: "close",
              class: "clear o-tips",
              onClick: l
            })) : createCommentVNode("", true)
          ])
        ], 2));
      }
    }), Ct = /* @__PURE__ */ defineComponent({
      __name: "OList",
      props: {
        clickable: {
          type: Boolean,
          default: false
        },
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(n2) {
        return (e, t) => (openBlock(), createElementBlock("ul", {
          class: normalizeClass(["o-list", { clickable: n2.clickable, hoverable: n2.hoverable }])
        }, [
          renderSlot(e.$slots, "default")
        ], 2));
      }
    }), yb = { class: "o-list-item" }, jb = { class: "o-list-item__prefix" }, wb = { class: "o-list-item__main" }, Eb = { class: "o-list-item__suffix" }, _t = /* @__PURE__ */ defineComponent({
      __name: "OListItem",
      props: {
        hoverable: {
          type: Boolean,
          default: false
        }
      },
      setup(n2) {
        return (e, t) => (openBlock(), createElementBlock("li", yb, [
          createBaseVNode("div", jb, [
            renderSlot(e.$slots, "prefix")
          ]),
          createBaseVNode("div", wb, [
            renderSlot(e.$slots, "default")
          ]),
          createBaseVNode("div", Eb, [
            renderSlot(e.$slots, "suffix")
          ])
        ]));
      }
    }), We = /* @__PURE__ */ defineComponent({
      __name: "OPopover",
      props: {
        disable: {
          type: Boolean,
          default: false
        },
        arrow: {
          type: Boolean,
          default: false
        },
        offset: {
          type: Object,
          default: function() {
            return [0, 10];
          }
        },
        placement: {
          type: String,
          default: "bottom-start"
        },
        trigger: {
          type: String,
          default: "mouseenter focus"
        },
        tippyClass: {
          type: String,
          default: "tippy"
        },
        event: {
          type: Object,
          default: function() {
            return {};
          }
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 200
        }
      },
      emits: ["update:show"],
      setup(n2, { expose: e, emit: t }) {
        const o = n2, i2 = t, { theme: s } = xr(), r = ref(null), a = ref(), l = ref();
        function u(_) {
          var m, f, b, h2;
          _ ? ((f = l.value) == null || f.setProps({
            getReferenceClientRect: (m = o.event) != null && m.clientX ? c2 : null
          }), (b = l.value) == null || b.show()) : (h2 = l.value) == null || h2.hide();
        }
        function c2() {
          var _, m;
          return {
            width: 0,
            height: 0,
            left: o.event.clientX,
            right: o.event.clientX,
            top: o.event.clientY,
            bottom: o.event.clientY,
            x: ((_ = o.event) == null ? void 0 : _.clientX) || 0,
            // add missing x
            y: ((m = o.event) == null ? void 0 : m.clientY) || 0,
            toJSON: () => {
              var f, b;
              return {
                // add toJSON method to satisfy DOMRect
                width: 100,
                height: 100,
                left: ((f = o.event) == null ? void 0 : f.clientX) || 0,
                top: ((b = o.event) == null ? void 0 : b.clientY) || 0
              };
            }
          };
        }
        function d() {
          l.value = jt(r.value, {
            appendTo: () => document.body,
            animation: "shift-away",
            // perspective, scale, shift-away
            arrow: o.arrow,
            content: a.value,
            duration: o.duration,
            delay: o.delay,
            interactive: true,
            offset: o.offset,
            placement: o.placement,
            trigger: o.trigger,
            theme: s.value,
            onShow: (_) => {
              _.popper.classList.add(o.tippyClass || "tippy"), i2("update:show", true);
            },
            onHide: (_) => {
              i2("update:show", false);
            }
          });
        }
        function p2() {
          l.value.setProps({
            theme: s.value
          });
        }
        return watch(s, (_) => {
          p2();
        }), onMounted(() => {
          d();
        }), e({
          setShow: u
        }), (_, m) => (openBlock(), createElementBlock("div", {
          ref_key: "triggerRef",
          ref: r,
          "data-tippy-role": "popover",
          class: "o-popover"
        }, [
          renderSlot(_.$slots, "trigger"),
          n2.disable ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "contentRef",
            ref: a,
            class: "popover-content"
          }, [
            renderSlot(_.$slots, "default")
          ], 512))
        ], 512));
      }
    }), Cb = /* @__PURE__ */ defineComponent({
      __name: "OAlignDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = computed(() => [
          { label: t("editor.left"), value: "left", icon: "format_align_center" },
          {
            label: t("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: t("editor.right"), value: "right", icon: "format_align_right" },
          {
            label: t("editor.justify"),
            value: "justify",
            icon: "format_align_justify"
          }
        ]);
        function r(a) {
          var l;
          (l = i2.value) == null || l.setShow(false), o(e.editor, "textAlign", {
            textAlign: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "format_align_center",
              "content-class": "o-align-dropdown dropdown",
              tooltip: unref(t)("editor.align")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (u, c2) => {
                  var d;
                  return openBlock(), createBlock(unref(_t), {
                    key: c2,
                    class: normalizeClass({ "is-active": (d = n2.editor) == null ? void 0 : d.isActive({ textAlign: u.value }) }),
                    onClick: (p2) => r(u.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = n2.editor) != null && p2.isActive({ textAlign: u.value }) ? (openBlock(), createBlock(unref(ue), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), Sb = { class: "o-align-group" }, xb = /* @__PURE__ */ defineComponent({
      __name: "OAlignGroup",
      props: {
        editor: {
          type: Editor
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = computed(() => [
          { label: t("editor.left"), value: "left", icon: "format_align_left" },
          {
            label: t("editor.center"),
            value: "center",
            icon: "format_align_center"
          },
          { label: t("editor.right"), value: "right", icon: "format_align_right" }
        ]);
        function s(r) {
          o(e.editor, "textAlign", {
            textAlign: r.value
          });
        }
        return (r, a) => (openBlock(), createElementBlock("div", Sb, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList(i2.value, (l, u) => {
            var c2;
            return openBlock(), createBlock(Ke, {
              key: u,
              icon: l.icon,
              tooltip: l.label,
              "content-class": {
                "is-active": (c2 = n2.editor) == null ? void 0 : c2.isActive({ textAlign: l.value })
              },
              onClick: (d) => s(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), Tb = { class: "o-back-color-dropdown o-button-group" }, Ab = /* @__PURE__ */ defineComponent({
      __name: "OBackColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = ref("#ffec3d");
        function r() {
          a(s.value);
        }
        function a(l) {
          i2.value.setShow(false), s.value = l, o(e.editor, "backColor", {
            color: l
          });
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(bo), { trigger: "hover" }, {
              trigger: withCtx(() => [
                createBaseVNode("div", Tb, [
                  createVNode(unref(Wn), {
                    icon: "ink_highlighter",
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${s.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Wn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.highlightColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var c2;
            return [
              createVNode(unref(kl), {
                "default-color": "",
                "default-label": unref(t)("editor.noColor"),
                "active-color": (c2 = n2.editor) == null ? void 0 : c2.getAttributes("highlight").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), Nb = /* @__PURE__ */ defineComponent({
      __name: "OEmojiBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null);
        function s(r) {
          var a;
          (a = i2.value) == null || a.setShow(false), o(e.editor, "content", { content: r.emoji });
        }
        return (r, a) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "o-emoji-popover",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "emoji_emotions",
              "content-class": "o-emoji-btn",
              tooltip: unref(t)("editor.emoji")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(wl), {
              items: unref(jl),
              onSelect: s,
              "enable-search": ""
            }, null, 8, ["items"])
          ]),
          _: 1
        }, 512));
      }
    }), Ob = /* @__PURE__ */ defineComponent({
      __name: "OFontFamilyDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = computed(() => [
          { label: t("editor.default"), value: "system-ui" },
          // todo
          { label: "Arial", value: "Arial", separator: true },
          { label: "Arial Black", value: "Arial Black" },
          { label: "Georgia", value: "Georgia" },
          { label: "Impact", value: "Impact" },
          { label: "Helvetica", value: "Helvetica" },
          { label: "Roboto", value: "Roboto" },
          { label: "Tahoma", value: "Tahoma" },
          { label: "Times New Roman", value: "Times New Roman" },
          { label: "Verdana", value: "Verdana" },
          { label: "Courier New", value: "Courier New", separator: true },
          { label: "Monaco", value: "Monaco" },
          { label: "Monospace", value: "monospace" }
        ]);
        function r(a) {
          var l;
          (l = i2.value) == null || l.setShow(false), o(e.editor, "fontFamily", {
            fontFamily: a
          });
        }
        return (a, l) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "format_font",
              "content-class": "o-font-family-dropdown dropdown",
              tooltip: unref(t)("editor.fontFamily")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (u, c2) => {
                  var d;
                  return openBlock(), createElementBlock(Fragment$1, { key: c2 }, [
                    u.separator ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                    createVNode(unref(_t), {
                      class: normalizeClass({
                        "is-active": (d = n2.editor) == null ? void 0 : d.isActive("textStyle", {
                          fontFamily: u.value
                        })
                      }),
                      onClick: (p2) => r(u.value)
                    }, {
                      suffix: withCtx(() => {
                        var p2;
                        return [
                          (p2 = n2.editor) != null && p2.isActive("textStyle", { fontFamily: u.value }) ? (openBlock(), createBlock(unref(ue), {
                            key: 0,
                            name: "done",
                            small: ""
                          })) : createCommentVNode("", true)
                        ];
                      }),
                      default: withCtx(() => [
                        createBaseVNode("span", {
                          style: normalizeStyle(`font-family: ${u.value}`)
                        }, toDisplayString(u.label), 5)
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])
                  ], 64);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), Mb = { class: "o-fore-color-dropdown o-button-group" }, Rb = /* @__PURE__ */ defineComponent({
      __name: "OForeColorDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = ref("#ff4d4f");
        function r() {
          a(s.value);
        }
        function a(l) {
          var u;
          (u = i2.value) == null || u.setShow(false), s.value = l, o(e.editor, "foreColor", {
            color: l
          });
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(bo), null, {
              trigger: withCtx(() => [
                createBaseVNode("div", Mb, [
                  createVNode(unref(Wn), {
                    icon: "format_color_text",
                    class: "o-command-btn label",
                    onClick: withModifiers(r, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        class: "indicator",
                        style: normalizeStyle(`background: ${s.value}`)
                      }, null, 4)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Wn), {
                    icon: "arrow_drop_down",
                    class: "o-command-btn"
                  })
                ])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(unref(t)("editor.textColor")), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => {
            var c2;
            return [
              createVNode(unref(kl), {
                "default-color": "",
                "default-label": unref(t)("editor.defaultColor"),
                "active-color": (c2 = n2.editor) == null ? void 0 : c2.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), Ib = /* @__PURE__ */ defineComponent({
      __name: "OHeadingDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = computed(() => [
          {
            label: t("editor.paragraph"),
            value: "paragraph",
            valueAlt: "",
            icon: "title"
          },
          {
            label: t("editor.heading1"),
            value: "heading",
            valueAlt: 1,
            icon: "format_h1",
            separator: true
          },
          {
            label: t("editor.heading2"),
            value: "heading",
            valueAlt: 2,
            icon: "format_h2"
          },
          {
            label: t("editor.heading3"),
            value: "heading",
            valueAlt: 3,
            icon: "format_h3"
          },
          {
            label: t("editor.heading4"),
            value: "heading",
            valueAlt: 4,
            icon: "format_h4"
          },
          {
            label: t("editor.heading5"),
            value: "heading",
            valueAlt: 5,
            icon: "format_h5"
          }
        ]);
        function r(l) {
          var u, c2;
          return l.value === "heading" ? (u = e.editor) == null ? void 0 : u.isActive(l.value, { level: l.valueAlt }) : (c2 = e.editor) == null ? void 0 : c2.isActive(l.value);
        }
        function a(l) {
          var u;
          (u = i2.value) == null || u.setShow(false), o(e.editor, l.value, {
            level: l.valueAlt
          });
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "format_header_pound",
              "content-class": "o-heading-dropdown dropdown",
              tooltip: unref(t)("editor.heading")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (c2, d) => (openBlock(), createElementBlock(Fragment$1, { key: d }, [
                  c2.separator ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(_t), {
                    class: normalizeClass({ "is-active": r(c2) }),
                    onClick: (p2) => a(c2)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      r(c2) ? (openBlock(), createBlock(unref(ue), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), Lb = { class: "o-list-dropdown o-button-group" }, Db = /* @__PURE__ */ defineComponent({
      __name: "OListDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = ref();
        function r() {
          o(e.editor, s.value.value);
        }
        function a(u) {
          i2.value.setShow(false), s.value = u, o(e.editor, u.value);
        }
        const l = computed(() => [
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        return onMounted(() => {
          s.value = l.value[0];
        }), (u, c2) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(bo), { trigger: "hover" }, {
              trigger: withCtx(() => {
                var d;
                return [
                  createBaseVNode("div", Lb, [
                    createVNode(unref(Wn), {
                      icon: (d = s.value) == null ? void 0 : d.icon,
                      class: "o-command-btn",
                      onClick: withModifiers(r, ["stop"])
                    }, null, 8, ["icon"]),
                    createVNode(unref(Wn), {
                      icon: "arrow_drop_down",
                      class: "o-command-btn"
                    })
                  ])
                ];
              }),
              default: withCtx(() => {
                var d;
                return [
                  createTextVNode(" " + toDisplayString((d = s.value) == null ? void 0 : d.label), 1)
                ];
              }),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(l.value, (d, p2) => {
                  var _;
                  return openBlock(), createBlock(unref(_t), {
                    key: p2,
                    class: normalizeClass({ "is-active": (_ = n2.editor) == null ? void 0 : _.isActive(d.value) }),
                    onClick: (m) => a(d)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: d.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var m;
                      return [
                        (m = n2.editor) != null && m.isActive(d.value) ? (openBlock(), createBlock(unref(ue), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(d.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), Bb = { class: "o-list-group" }, Pb = /* @__PURE__ */ defineComponent({
      __name: "OListGroup",
      props: {
        editor: {
          type: Editor,
          required: true
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = computed(() => [
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" }
        ]);
        function s(r) {
          o(e.editor, r.value);
        }
        return (r, a) => (openBlock(), createElementBlock("div", Bb, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList(i2.value, (l, u) => {
            var c2;
            return openBlock(), createBlock(Ke, {
              key: u,
              icon: l.icon,
              tooltip: l.label,
              "content-class": { "is-active": (c2 = n2.editor) == null ? void 0 : c2.isActive(l.value) },
              onClick: (d) => s(l)
            }, null, 8, ["icon", "tooltip", "content-class", "onClick"]);
          }), 128))
        ]));
      }
    }), $b = /* @__PURE__ */ defineComponent({
      __name: "OLinkBtn",
      props: {
        editor: {
          type: Editor
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(), s = ref(false), r = ref(""), a = ref(true);
        function l() {
          var p2;
          r.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (r.value = d.href, a.value = d.target === "_blank", console.log("show", s.value, d, a.value));
        }
        function u() {
          var d;
          (d = i2.value) == null || d.setShow(false);
        }
        function c2(d) {
          var p2;
          d ? o(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : o(e.editor, "linkUnset"), (p2 = i2.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: s.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (_) => s.value = _),
            l
          ]
        }, {
          trigger: withCtx(() => {
            var _;
            return [
              createVNode(unref(yn), {
                icon: "link",
                "content-class": { "is-active": (_ = n2.editor) == null ? void 0 : _.isActive("link") },
                tooltip: unref(t)("editor.hyperlink")
              }, null, 8, ["content-class", "tooltip"])
            ];
          }),
          default: withCtx(() => [
            s.value ? (openBlock(), createBlock(unref(Ep), {
              key: 0,
              title: unref(t)("editor.hyperlink"),
              val: r.value,
              icon: "link",
              onCancel: u,
              onConfirm: c2
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(xp), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (_) => a.value = _),
                  label: unref(t)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), zb = /* @__PURE__ */ defineComponent({
      __name: "OLinkEditBtn",
      props: {
        editor: {
          type: Editor,
          required: true
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(), s = ref(false), r = ref(""), a = ref(true);
        function l() {
          var p2;
          r.value = "", a.value = true;
          const d = (p2 = e.editor) == null ? void 0 : p2.getAttributes("link");
          d != null && d.href && (r.value = d.href, a.value = d.target === "_blank");
        }
        function u() {
          var d;
          (d = i2.value) == null || d.setShow(false);
        }
        function c2(d) {
          var p2;
          d ? o(e.editor, "linkSet", {
            href: d,
            target: a.value ? "_blank" : ""
          }) : o(e.editor, "linkUnset"), (p2 = i2.value) == null || p2.setShow(false);
        }
        return (d, p2) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: "",
          show: s.value,
          "onUpdate:show": [
            p2[1] || (p2[1] = (_) => s.value = _),
            l
          ]
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "edit",
              tooltip: unref(t)("link.edit")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            s.value ? (openBlock(), createBlock(unref(Ep), {
              key: 0,
              title: unref(t)("link.edit"),
              val: r.value,
              icon: "link",
              onCancel: u,
              onConfirm: c2
            }, {
              "header-right": withCtx(() => [
                createVNode(unref(xp), {
                  modelValue: a.value,
                  "onUpdate:modelValue": p2[0] || (p2[0] = (_) => a.value = _),
                  label: unref(t)("link.open_in_new_tab")
                }, null, 8, ["modelValue", "label"])
              ]),
              _: 1
            }, 8, ["title", "val"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["show"]));
      }
    }), Fb = /* @__PURE__ */ defineComponent({
      __name: "OLinkOpenBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae();
        function o() {
          var s;
          const i2 = (s = e.editor) == null ? void 0 : s.getAttributes("link");
          i2 != null && i2.href && window.open(i2.href, "target");
        }
        return (i2, s) => (openBlock(), createBlock(Ke, {
          icon: "open_in_new",
          tooltip: unref(t)("link.open"),
          "content-class": "o-link-open-btn",
          onClick: o
        }, null, 8, ["tooltip"]));
      }
    }), Hb = [
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "fore-color",
      "back-color",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "codeBlock",
      "link",
      "image",
      "video",
      "modelViewer",
      "table",
      "callout",
      "emoji",
      "columns",
      "aiViewer"
    ], Ub = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "text-format-dropdown",
      "separator",
      "heading",
      "font-family",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "align-dropdown",
      "separator",
      "horizontalRule",
      "blockquote",
      "list-dropdown",
      "link",
      "image"
    ], qb = [
      "bold",
      "strike",
      "text-color-dropdown",
      "clearFormat",
      "separator",
      "list-group",
      "link",
      "callout",
      "separator",
      "align-dropdown",
      "more"
    ], Kb = ["link-open", "link-edit", "linkUnset"], Vb = ["align-group", "separator", "link"], Wb = [
      "align-group",
      "separator",
      "link-open",
      "link-edit",
      "linkUnset"
    ], Gb = [
      "heading",
      "separator",
      "italic",
      "underline",
      "font-family",
      "separator",
      "code",
      "blockquote"
    ], Yb = [
      "table-group",
      "separator",
      "bold",
      "italic",
      "font-family",
      "text-color-dropdown",
      "separator",
      "align-group"
    ], Jb = [
      "style-dropdown",
      "separator",
      "bold",
      "italic",
      "text-color-dropdown",
      "separator",
      "align-dropdown"
    ], Zb = { class: "o-command-btn" }, Xb = { class: "o-more-bubble" }, Qb = /* @__PURE__ */ defineComponent({
      __name: "OMoreBubble",
      props: {
        editor: {
          type: Editor,
          required: true
        }
      },
      setup(n2) {
        const e = ref();
        return (t, o) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: e,
          offset: [4, 10],
          class: "o-simple-command-btn",
          "tippy-class": "o-more-bubble-popover",
          placement: "top-end",
          size: "medium",
          trigger: "mouseenter"
        }, {
          trigger: withCtx(() => [
            createBaseVNode("div", Zb, [
              createVNode(unref(ue), { name: "more_horiz" })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("section", Xb, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(Gb), (i2, s) => (openBlock(), createElementBlock(Fragment$1, { key: s }, [
                i2 === "separator" ? (openBlock(), createBlock(unref(pt), {
                  key: 0,
                  vertical: ""
                })) : typeof i2 == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Tr)(i2)), {
                  key: 1,
                  name: i2,
                  editor: n2.editor
                }, null, 8, ["name", "editor"])) : createCommentVNode("", true)
              ], 64))), 128))
            ])
          ]),
          _: 1
        }, 512));
      }
    }), ek = /* @__PURE__ */ defineComponent({
      __name: "OStyleDropdown",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = computed(() => [
          { label: t("editor.paragraph"), value: "paragraph", icon: "title" },
          {
            label: t("editor.heading1"),
            value: "heading",
            icon: "format_h1",
            options: { level: 1 }
          },
          {
            label: t("editor.heading2"),
            value: "heading",
            icon: "format_h2",
            options: { level: 2 }
          },
          {
            label: t("editor.heading3"),
            value: "heading",
            icon: "format_h3",
            options: { level: 3 }
          },
          { label: t("editor.todoList"), value: "taskList", icon: "check_box" },
          {
            label: t("editor.unorderedList"),
            value: "bulletList",
            icon: "format_list_bulleted"
          },
          {
            label: t("editor.orderedList"),
            value: "orderedList",
            icon: "format_list_numbered"
          },
          {
            label: t("editor.blockquote"),
            value: "blockquote",
            icon: "format_quote_open"
          },
          {
            label: t("editor.removeFormat"),
            value: "clearFormat",
            icon: "format_clear",
            separator: true
          }
        ]);
        function r(l) {
          var u;
          return (u = e.editor) == null ? void 0 : u.isActive(l.value, l.options);
        }
        function a(l) {
          i2.value.setShow(false), o(e.editor, l.value, l.options);
        }
        return (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click"
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "format_paint",
              "content-class": "o-style-dropdown o-command-btn dropdown",
              tooltip: unref(t)("label.styles")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (c2, d) => (openBlock(), createElementBlock(Fragment$1, { key: d }, [
                  c2.separator ? (openBlock(), createBlock(unref(pt), { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(_t), {
                    class: normalizeClass({ "is-active": r(c2) }),
                    onClick: (p2) => a(c2)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: c2.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => [
                      r(c2) ? (openBlock(), createBlock(unref(ue), {
                        key: 0,
                        name: "done",
                        small: ""
                      })) : createCommentVNode("", true)
                    ]),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(c2.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"])
                ], 64))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), nk = /* @__PURE__ */ defineComponent({
      __name: "OTableBtn",
      props: {
        editor: {
          type: Object
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null);
        function s(r) {
          var a;
          (a = i2.value) == null || a.setShow(false), o(e.editor, "tableInsert", r);
        }
        return (r, a) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          placement: "bottom",
          trigger: "click",
          arrow: ""
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "window",
              "content-class": "o-table-btn",
              tooltip: unref(t)("table.insert")
            }, null, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(x0), { onSelect: s })
          ]),
          _: 1
        }, 512));
      }
    }), tk = { class: "o-table-group" }, ok = /* @__PURE__ */ defineComponent({
      __name: "OTableGroup",
      props: {
        editor: {
          type: Editor,
          required: true
        }
      },
      setup(n2) {
        const { tr: e } = Ae(), { run: t } = Le();
        return (o, i2) => {
          var s, r;
          return openBlock(), createElementBlock("section", tk, [
            (s = n2.editor) != null && s.can().mergeCells() ? (openBlock(), createBlock(unref(Ke), {
              key: 0,
              icon: "cell_merge",
              tooltip: unref(e)("table.merge"),
              onClick: i2[0] || (i2[0] = (a) => unref(t)(n2.editor, "tableMergeCells"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            (r = n2.editor) != null && r.can().splitCell() ? (openBlock(), createBlock(unref(Ke), {
              key: 1,
              icon: "splitscreen_left",
              tooltip: unref(e)("table.split"),
              onClick: i2[1] || (i2[1] = (a) => unref(t)(n2.editor, "tableSplitCell"))
            }, null, 8, ["tooltip"])) : createCommentVNode("", true),
            createVNode(unref(N0), { editor: n2.editor }, null, 8, ["editor"])
          ]);
        };
      }
    }), ik = /* @__PURE__ */ defineComponent({
      __name: "OTextColorDropdown",
      props: {
        editor: {
          type: Editor
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(null), s = ref(""), r = ref("");
        function a(l, u) {
          l === "foreColor" ? (s.value = u, localStorage.setItem("yiitap.text-color.fore", u)) : l === "backColor" && (r.value = u, localStorage.setItem("yiitap.text-color.back", u)), i2.value.setShow(false), o(e.editor, l, {
            color: u
          });
        }
        return onMounted(() => {
          s.value = localStorage.getItem("yiitap.text-color.fore") || "", r.value = localStorage.getItem("yiitap.text-color.back") || "";
        }), (l, u) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          size: "medium",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "format_text",
              "content-class": "o-text-color-dropdown dropdown",
              tooltip: unref(t)("editor.textColor")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => {
            var c2;
            return [
              createVNode(unref(P0), {
                "fore-color": s.value,
                "back-color": r.value,
                "default-label": unref(t)("editor.defaultColor"),
                "active-color": (c2 = n2.editor) == null ? void 0 : c2.getAttributes("textStyle").color,
                onSelect: a
              }, null, 8, ["fore-color", "back-color", "default-label", "active-color"])
            ];
          }),
          _: 1
        }, 512));
      }
    }), sk = /* @__PURE__ */ defineComponent({
      __name: "OTextFormatDropdown",
      props: {
        editor: {
          type: Editor
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { run: o } = Le(), i2 = ref(), s = computed(() => [
          {
            label: t("editor.strikethrough"),
            value: "strike",
            icon: "format_strikethrough"
          },
          {
            label: t("editor.underline"),
            value: "underline",
            icon: "format_underlined"
          },
          { label: t("editor.code"), value: "code", icon: "code" }
        ]);
        function r(a) {
          var l;
          (l = i2.value) == null || l.setShow(false), o(e.editor, a);
        }
        return (a, l) => (openBlock(), createBlock(unref(We), {
          ref_key: "popover",
          ref: i2,
          class: "o-simple-command-btn",
          "tippy-class": "dropdown",
          trigger: "click",
          "show-arrow": false
        }, {
          trigger: withCtx(() => [
            createVNode(unref(yn), {
              icon: "title",
              "content-class": "o-text-format-dropdown dropdown",
              tooltip: unref(t)("editor.textFormat")
            }, {
              default: withCtx(() => [
                createVNode(unref(ue), {
                  name: "arrow_drop_down",
                  class: "arrow"
                })
              ]),
              _: 1
            }, 8, ["tooltip"])
          ]),
          default: withCtx(() => [
            createVNode(unref(Ct), {
              hoverable: "",
              clickable: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(s.value, (u, c2) => {
                  var d;
                  return openBlock(), createBlock(unref(_t), {
                    key: c2,
                    class: normalizeClass({ "is-active": (d = n2.editor) == null ? void 0 : d.isActive(u.value) }),
                    onClick: (p2) => r(u.value)
                  }, {
                    prefix: withCtx(() => [
                      createVNode(unref(ue), {
                        name: u.icon
                      }, null, 8, ["name"])
                    ]),
                    suffix: withCtx(() => {
                      var p2;
                      return [
                        (p2 = n2.editor) != null && p2.isActive(u.value) ? (openBlock(), createBlock(unref(ue), {
                          key: 0,
                          name: "done",
                          small: ""
                        })) : createCommentVNode("", true)
                      ];
                    }),
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(u.label) + " ", 1)
                    ]),
                    _: 2
                  }, 1032, ["class", "onClick"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512));
      }
    }), rk = {
      // 'add-more': 'o-add-more-btn',
      "align-dropdown": Cb,
      "align-group": xb,
      "back-color": Ab,
      "font-family": Ob,
      "fore-color": Rb,
      heading: Ib,
      // 'indent-dropdown': 'o-indent-dropdown',
      // 'line-height': 'o-line-height-dropdown',
      "list-dropdown": Db,
      "list-group": Pb,
      link: $b,
      "link-edit": zb,
      "link-open": Fb,
      // 'image-settings': 'o-image-settings-btn',
      emoji: Nb,
      more: Qb,
      // 'node': 'o-node-btn',
      // 'node-dropdown': 'o-node-dropdown',
      "style-dropdown": ek,
      table: nk,
      "table-group": ok,
      "text-color-dropdown": ik,
      "text-format-dropdown": sk
    }, Tr = (n2) => rk[n2] || Nv, ak = { class: "o-main-menu" }, lk = { class: "left" }, uk = { class: "right" }, ck = /* @__PURE__ */ defineComponent({
      __name: "OMainMenu",
      props: {
        editor: {
          type: Object
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        }
      },
      setup(n2) {
        const e = n2, t = computed(() => {
          var i2;
          let o = e.menu;
          return (i2 = e.editor) != null && i2.isActive("table") && (o = Ub), o.length > 0 ? o : Hb;
        });
        return (o, i2) => (openBlock(), createElementBlock("section", ak, [
          createBaseVNode("section", lk, [
            (openBlock(true), createElementBlock(Fragment$1, null, renderList(t.value, (s, r) => (openBlock(), createElementBlock(Fragment$1, { key: r }, [
              s === "separator" ? (openBlock(), createBlock(unref(pt), {
                key: 0,
                vertical: ""
              })) : typeof s == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Tr)(s)), {
                key: 1,
                name: s,
                editor: n2.editor
              }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(s), {
                key: 2,
                editor: n2.editor
              }, null, 8, ["editor"]))
            ], 64))), 128)),
            renderSlot(o.$slots, "left")
          ]),
          createBaseVNode("section", uk, [
            renderSlot(o.$slots, "right")
          ])
        ]));
      }
    }), dk = {
      key: 0,
      class: "o-bubble-menu"
    }, pk = { class: "container" }, _k = /* @__PURE__ */ defineComponent({
      __name: "OBubbleMenu",
      props: {
        editor: {
          type: Editor
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n2) {
        const e = n2, { tr: t } = Ae();
        xr();
        const i2 = ref(false), s = ref({
          duration: 100,
          placement: "top",
          role: "popover",
          arrow: false,
          // offset: [0, 0]
          onShow: () => {
            i2.value = false;
          }
        });
        function r() {
          i2.value = true;
        }
        function a(p2) {
          const { schema: _ } = e.editor, m = _.marks.link;
          if (!m || !p2) return false;
          const { $from: f, $to: b } = p2;
          return !!getMarkRange(f, m);
        }
        function l({ editor: p2, element: _, view: m, state: f, oldState: b, from: h2, to: y }) {
          var ie2;
          const { doc: C, selection: v } = f, { empty: x } = v, S = !C.textBetween(h2, y).length && isTextSelection(f.selection);
          if (!m.hasFocus() || x || S && p2.isActive("link") && !p2.isActive("image"))
            return false;
          const F = ["image"], Y = ["toc", "video", "model-viewer"], q = v.node, K = (ie2 = q == null ? void 0 : q.type) == null ? void 0 : ie2.name;
          return !(p2.isActive("codeBlock") || Y.indexOf(K) >= 0 || K && !F.includes(K));
        }
        const u = computed(() => {
          if (e.editor) {
            const { state: p2 } = e.editor, { tr: _ } = p2, { selection: m } = _;
            return a(m);
          } else
            return false;
        }), c2 = computed(() => {
          var p2;
          return !i2.value && u.value && !((p2 = e.editor) != null && p2.isActive("image"));
        }), d = computed(() => {
          var _, m;
          let p2 = e.menu;
          return i2.value || ((_ = e.editor) != null && _.isActive("image") ? p2 = u.value ? Wb : Vb : (m = e.editor) != null && m.isActive("table") ? p2 = Yb : u.value && (p2 = Kb)), p2.length > 0 ? p2 : qb;
        });
        return onMounted(() => {
          i2.value = false;
        }), (p2, _) => n2.editor ? (openBlock(), createElementBlock("section", dk, [
          createVNode(unref(Mg), {
            class: normalizeClass(["bubble-menu", n2.menuClass]),
            editor: n2.editor,
            "should-show": l,
            "tippy-options": s.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", pk, [
                c2.value ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                  createVNode(unref(Ke), {
                    icon: "arrow_back",
                    tooltip: unref(t)("link.back"),
                    onClick: r
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(pt), { vertical: "" })
                ], 64)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(d.value, (m, f) => (openBlock(), createElementBlock(Fragment$1, { key: f }, [
                  m === "separator" ? (openBlock(), createBlock(unref(pt), {
                    key: 0,
                    vertical: ""
                  })) : typeof m == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Tr)(m)), {
                    key: 1,
                    name: m,
                    editor: n2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(m), {
                    key: 2,
                    editor: n2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    }), mk = {
      key: 0,
      class: "o-floating-menu"
    }, fk = { class: "container" }, gk = /* @__PURE__ */ defineComponent({
      __name: "OFloatingMenu",
      props: {
        editor: {
          type: Dd
        },
        menu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableToolbar: {
          type: Array,
          default: function() {
            return [];
          }
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n2) {
        const e = n2, t = ref(false), o = ref({
          arrow: false,
          duration: 100,
          role: "popover",
          placement: "right",
          offset: [0, 168]
        });
        function i2() {
          t.value = true;
        }
        function s(u) {
          const { schema: c2 } = e.editor, d = c2.marks.link;
          if (!d || !u) return false;
          const { $from: p2, $to: _ } = u;
          return !!getMarkRange(p2, d);
        }
        const r = computed(() => {
          if (e.editor) {
            const { state: u } = e.editor, { tr: c2 } = u, { selection: d } = c2;
            return s(d);
          } else
            return false;
        }), a = computed(() => !t.value && r.value), l = computed(() => {
          let u = e.menu;
          return u.length > 0 ? u : Jb;
        });
        return (u, c2) => n2.editor ? (openBlock(), createElementBlock("section", mk, [
          createVNode(unref(Ig), {
            class: normalizeClass(["floating-menu", n2.menuClass]),
            editor: n2.editor,
            "tippy-options": o.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", fk, [
                a.value ? (openBlock(), createBlock(unref(Ke), {
                  key: 0,
                  icon: "arrow_back",
                  onClick: i2
                })) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment$1, null, renderList(l.value, (d, p2) => (openBlock(), createElementBlock(Fragment$1, { key: p2 }, [
                  d === "separator" ? (openBlock(), createBlock(unref(pt), {
                    key: 0,
                    vertical: ""
                  })) : typeof d == "string" ? (openBlock(), createBlock(resolveDynamicComponent(unref(Tr)(d)), {
                    key: 1,
                    name: d,
                    editor: n2.editor
                  }, null, 8, ["name", "editor"])) : (openBlock(), createBlock(resolveDynamicComponent(d), {
                    key: 2,
                    editor: n2.editor
                  }, null, 8, ["editor"]))
                ], 64))), 128))
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    function El(n2, e) {
      const t = e == null ? void 0 : e.posAtCoords(n2);
      if (!t)
        return;
      let o = As(t.pos, e);
      if (o !== e.dom) {
        for (; o && o.parentNode && o.parentNode !== e.dom; )
          o = o.parentNode;
        if (o)
          return o;
      }
    }
    function As(n2, e) {
      return e.nodeDOM(n2) || e.domAtPos(n2).node;
    }
    function Cl(n2, e) {
      const t = El(n2, e);
      if (t && t.nodeType === 1) {
        const o = e.docView, i2 = o.nearestDesc(t, true);
        return !i2 || i2 === o ? null : i2.posBefore;
      }
      return null;
    }
    function hk(n2, e) {
      let t, o;
      const i2 = e.resolve(n2.from).node().type.spec.group === "blockContent", s = e.resolve(n2.to).node().type.spec.group === "blockContent", r = Math.min(n2.$anchor.depth, n2.$head.depth);
      if (i2 && s) {
        const a = n2.$from.start(r - 1), l = n2.$to.end(r - 1);
        t = e.resolve(a - 1).pos, o = e.resolve(l + 1).pos;
      } else
        t = n2.from, o = n2.to;
      return { from: t, to: o };
    }
    function vk(n2, e) {
      const t = Cl(n2, e.view);
      return t && t >= 0 ? {
        node: e.state.doc.nodeAt(t),
        pos: t
      } : {
        node: null,
        pos: t
      };
    }
    const Ks = new en("sideMenu");
    class bk {
      constructor() {
        cn(this, "hovered", false);
        cn(this, "coords", { left: 0, top: 0 });
        cn(this, "className", "");
      }
      init(e) {
        return this;
      }
      apply({ tr: e, oldState: t, newState: o }) {
        return e.docChanged ? this : this;
      }
      setHover(e, t, o = "") {
        this.hovered = e, this.coords = t, this.className = o;
      }
    }
    class kk {
      constructor({
        editor: e,
        element: t,
        view: o,
        tippyOptions: i2 = {},
        updateDelay: s = 250
      }) {
        cn(this, "editor");
        cn(this, "element");
        cn(this, "view");
        cn(this, "preventHide", false);
        cn(this, "tippy");
        cn(this, "tippyOptions");
        cn(this, "updateDelay");
        cn(this, "updateDebounceTimer");
        cn(this, "mousedownHandler", () => {
          this.preventHide = true;
        });
        cn(this, "onDragStart", (e2) => {
          this.hide();
        });
        cn(this, "blurHandler", ({ event: e2 }) => {
          var t2;
          e2 != null && e2.relatedTarget && ((t2 = this.element.parentNode) != null && t2.contains(e2.relatedTarget)) || this.hide();
        });
        cn(this, "tippyBlurHandler", (e2) => {
          this.blurHandler({ event: e2 });
        });
        cn(this, "handleDebouncedUpdate", (e2, t2) => {
          const o2 = !(t2 != null && t2.selection.eq(e2.state.selection)), i22 = !(t2 != null && t2.doc.eq(e2.state.doc));
          !o2 && !i22 || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
            this.updateHandler(e2, o2, i22, t2);
          }, this.updateDelay));
        });
        cn(this, "updateHandler", (e2, t2, o2, i22) => {
          var c2, d;
          const { state: s2, composing: r } = e2, { coords: a } = Ks.getState(s2), l = El(a, e2), u = Cl(a, e2);
          !l || u <= 0 || (this.createTooltip(), (d = this.tippy) == null || d.setProps({
            getReferenceClientRect: ((c2 = this.tippyOptions) == null ? void 0 : c2.getReferenceClientRect) || (() => l.getBoundingClientRect())
          }), this.show());
        });
        this.editor = e, this.element = t, this.view = o, this.updateDelay = s, this.view.dom.addEventListener("dragstart", this.onDragStart), this.tippyOptions = i2, this.element.remove(), this.element.style.visibility = "visible";
      }
      createTooltip() {
        const { element: e } = this.editor.options, t = !!e.parentElement;
        this.tippy || !t || (this.tippy = jt(e, {
          duration: 0,
          getReferenceClientRect: null,
          content: this.element,
          interactive: true,
          trigger: "manual",
          placement: "left",
          hideOnClick: "toggle",
          ...this.tippyOptions
        }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener(
          "blur",
          this.tippyBlurHandler
        ));
      }
      update(e, t) {
        const { state: o } = e, i2 = !(t != null && t.selection.eq(e.state.selection)), s = !(t != null && t.doc.eq(e.state.doc));
        this.updateHandler(e, i2, s, t);
      }
      show() {
        var e;
        (e = this.tippy) == null || e.show();
      }
      hide() {
        var e;
        (e = this.tippy) == null || e.hide();
      }
      destroy() {
        var e, t;
        (e = this.tippy) != null && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener(
          "blur",
          this.tippyBlurHandler
        ), (t = this.tippy) == null || t.destroy(), this.view.dom.removeEventListener("dragstart", this.onDragStart);
      }
    }
    const yk = (n2, e) => {
      if (!n2.dataTransfer) return;
      const t = e.view, o = t.dom.getBoundingClientRect(), i2 = {
        left: o.left + o.width / 2,
        // take middle of editor
        top: n2.clientY
      }, s = Cl(i2, t);
      if (s === null) return;
      const r = t.state.selection, a = t.state.doc;
      hk(r, a), t.dispatch(
        t.state.tr.setSelection(xe.create(t.state.doc, s))
      ), wk(t, s);
      const l = t.state.selection.content(), { dom: u, text: c2 } = t.serializeForClipboard(l);
      n2.dataTransfer.clearData(), n2.dataTransfer.setData("text/html", u.innerHTML), n2.dataTransfer.setData("text/plain", c2), n2.dataTransfer.effectAllowed = "move", n2.dataTransfer.setDragImage(Ao, 0, 0), t.dragging = { slice: l, move: true };
    }, jk = (n2, e) => {
      Tp();
    };
    let Ao;
    function wk(n2, e, t = e) {
      const o = n2.domAtPos(e).node.cloneNode(true), i2 = n2.domAtPos(e).node, s = (d, p2) => Array.prototype.indexOf.call(d.children, p2), r = (d) => {
        let p2 = d, _ = p2.parentElement;
        for (; _; ) {
          if (_ === n2.dom)
            return p2;
          p2 = _, _ = p2.parentElement;
        }
        return p2;
      };
      let a = -1, l = -1;
      e === t ? (a = s(
        i2,
        r(As(e, n2))
      ), l = a) : (a = s(
        i2,
        // Expects from position to be just before the first selected block.
        r(As(e + 1, n2))
      ), l = s(
        i2,
        // Expects to position to be just after the last selected block.
        r(As(t - 1, n2))
      ));
      for (let d = i2.childElementCount - 1; d >= 0; d--)
        (d > a || d < l) && o.removeChild(o.children[d]);
      Tp(), Ao = o;
      const c2 = n2.dom.className.split(" ").filter(
        (d) => d !== "ProseMirror" && d !== "yiitap-root" && d !== "yiitap-editor"
      ).join(" ");
      Ao.className += " yiitap-dragging-preview " + c2, document.body.appendChild(Ao);
    }
    function Tp() {
      Ao !== void 0 && (document.body.removeChild(Ao), Ao = void 0);
    }
    class Ek {
      constructor(e) {
        cn(this, "options");
        cn(this, "plugin");
        cn(this, "sideMenuView");
        const t = new bk();
        this.options = e, this.plugin = new dn({
          key: Ks,
          props: {
            handleDOMEvents: {
              mouseover(o, i2) {
                const s = {
                  left: i2.clientX,
                  top: i2.clientY
                }, r = El(s, o), a = (r == null ? void 0 : r.className) || "", l = t.className;
                a.indexOf("o-table-wrapper-view") >= 0 && l.indexOf("o-table-wrapper-view") >= 0 || (t.setHover(true, s, a), o.dispatch(o.state.tr.setMeta(Ks, t)));
              }
            }
          },
          state: {
            init(o, i2) {
              return t.init(i2);
            },
            apply(o, i2, s, r) {
              return t.apply({ tr: o, oldState: s, newState: r });
            }
          },
          view: (o) => (this.sideMenuView = new kk({ view: o, ...e }), this.sideMenuView)
        });
      }
      dragstart(e) {
        yk(e, this.options.editor);
      }
      dragend(e) {
        jk(e, this.options.editor);
      }
    }
    const Ck = /* @__PURE__ */ defineComponent({
      name: "SideMenu",
      props: {
        pluginKey: {
          type: [String, Object],
          default: "sideMenu"
        },
        editor: {
          type: Object,
          required: true
        },
        updateDelay: {
          type: Number,
          default: void 0
        },
        tippyOptions: {
          type: Object,
          default: () => ({})
        }
      },
      setup(n2, { expose: e, slots: t }) {
        const o = ref(null), i2 = ref(), s = (a) => {
          var l;
          (l = i2.value) == null || l.dragstart(a);
        }, r = (a) => {
          var l;
          (l = i2.value) == null || l.dragend(a);
        };
        return onMounted(() => {
          const { pluginKey: a, editor: l, updateDelay: u, tippyOptions: c2 } = n2;
          i2.value = new Ek({
            updateDelay: u,
            editor: l,
            element: o.value,
            pluginKey: a,
            tippyOptions: c2
          }), l.registerPlugin(i2.value.plugin);
        }), onBeforeUnmount(() => {
          const { pluginKey: a, editor: l } = n2;
          l.unregisterPlugin(a);
        }), e({
          ...n2,
          dragstart: s,
          dragend: r
        }), () => {
          var a;
          return h("div", { ref: o }, (a = t.default) == null ? void 0 : a.call(t));
        };
      }
    }), Sk = {
      key: 0,
      class: "o-side-menu"
    }, xk = { class: "container" }, Tk = /* @__PURE__ */ defineComponent({
      __name: "OSideMenu",
      props: {
        editor: {
          type: Editor,
          required: true
        },
        menuClass: {
          type: String,
          default: ""
        }
      },
      setup(n2) {
        const e = n2, t = ref(null), o = ref(null), i2 = ref(0), s = computed(() => ({
          arrow: false,
          duration: 100,
          placement: "left"
          // offset: [0, 0]
        })), r = computed(() => ({
          editor: e.editor,
          node: o.value,
          decorations: [],
          selected: false,
          extension: {},
          getPos: () => i2.value,
          pos: i2.value,
          updateAttributes: l,
          deleteNode: a,
          view: void 0,
          innerDecorations: [],
          HTMLAttributes: void 0
        }));
        function a() {
          var m, f;
          const p2 = i2.value, _ = p2 + ((m = o.value) == null ? void 0 : m.nodeSize);
          (f = e.editor) == null || f.commands.deleteRange({ from: p2, to: _ });
        }
        function l(p2) {
          var _;
          (_ = e.editor) == null || _.commands.command(({ tr: m }) => {
            var f;
            return m.setNodeMarkup(i2.value, void 0, {
              ...(f = o.value) == null ? void 0 : f.attrs,
              ...p2
            }), true;
          });
        }
        function u({ editor: p2, transaction: _ }) {
          let m = { left: 0, top: 0 };
          const f = Ks.getState(e.editor.view.state);
          if (f) {
            m = f.coords;
            const b = vk(m, p2);
            b.node && b.pos > 0 && (o.value = b.node, i2.value = b.pos);
          }
        }
        function c2(p2) {
          var _;
          (_ = t.value) == null || _.dragstart(p2);
        }
        function d(p2) {
          var _;
          (_ = t.value) == null || _.dragend(p2);
        }
        return onMounted(() => {
          var p2;
          (p2 = e.editor) == null || p2.on("transaction", u);
        }), (p2, _) => n2.editor ? (openBlock(), createElementBlock("section", Sk, [
          createVNode(unref(Ck), {
            ref_key: "menu",
            ref: t,
            class: normalizeClass(["side-menu", n2.menuClass]),
            editor: n2.editor,
            "tippy-options": s.value
          }, {
            default: withCtx(() => [
              createBaseVNode("section", xk, [
                o.value ? (openBlock(), createBlock(unref(lb), normalizeProps(mergeProps({ key: 0 }, r.value)), null, 16)) : createCommentVNode("", true),
                o.value ? (openBlock(), createBlock(unref(mb), mergeProps({ key: 1 }, r.value, {
                  onDragstart: c2,
                  onDragend: d
                }), null, 16)) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 8, ["class", "editor", "tippy-options"])
        ])) : createCommentVNode("", true);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Xu = (n2) => {
      const e = /(#[0-9a-f]{3,6})\b/gi, t = [];
      return n2.descendants((o, i2) => {
        o.text && Array.from(o.text.matchAll(e)).forEach((s) => {
          const r = s[0], a = s.index || 0, l = i2 + a, u = l + r.length, c2 = hn.inline(l, u, {
            class: "color",
            style: `--color: ${r}`
          });
          t.push(c2);
        });
      }), He.create(n2, t);
    }, Ak = Extension.create({
      name: "colorHighlighter",
      addProseMirrorPlugins() {
        return [
          new dn({
            key: new en("colorHighlighter"),
            state: {
              init(n2, { doc: e }) {
                return Xu(e);
              },
              apply(n2, e) {
                return n2.docChanged ? Xu(n2.doc) : e;
              }
            },
            props: {
              decorations(n2) {
                return this.getState(n2);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    Extension.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new dn({
            key: new en("focus"),
            props: {
              decorations: ({ doc: n2, selection: e }) => {
                const { isEditable: t, isFocused: o } = this.editor, { anchor: i2 } = e, s = [];
                if (!t || !o)
                  return He.create(n2, []);
                let r = 0;
                this.options.mode === "deepest" && n2.descendants((l, u) => {
                  if (!l.isText) {
                    if (!(i2 >= u && i2 <= u + l.nodeSize - 1))
                      return false;
                    r += 1;
                  }
                });
                let a = 0;
                return n2.descendants((l, u) => {
                  if (l.isText || !(i2 >= u && i2 <= u + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && r - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  s.push(
                    hn.node(u, u + l.nodeSize, {
                      class: this.options.className
                    })
                  );
                }), He.create(n2, s);
              }
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Nk = Extension.create({
      name: "placeholder",
      addOptions() {
        return {
          emptyEditorClass: "is-editor-empty",
          emptyNodeClass: "is-empty",
          placeholder: "Write something ",
          showOnlyWhenEditable: true,
          showOnlyCurrent: true,
          includeChildren: false
        };
      },
      addProseMirrorPlugins() {
        return [
          new dn({
            key: new en("placeholder"),
            props: {
              decorations: ({ doc: n2, selection: e }) => {
                const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: o } = e, i2 = [];
                return t ? (n2.descendants((s, r) => {
                  const a = o >= r && o <= r + s.nodeSize, l = !s.isLeaf && !s.childCount, u = this.options.showOnlyCurrent;
                  if ((a || !u) && l) {
                    const c2 = [this.options.emptyNodeClass];
                    this.editor.isEmpty && c2.push(this.options.emptyEditorClass);
                    const d = hn.node(r, r + s.nodeSize, {
                      class: c2.join(" "),
                      "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                        editor: this.editor,
                        node: s,
                        pos: r,
                        hasAnchor: a
                      }) : this.options.placeholder
                    });
                    i2.push(d);
                  }
                  return this.options.includeChildren;
                }), He.create(n2, i2)) : null;
              }
            }
          })
        ];
      }
    });
    var Ia, La;
    if (typeof WeakMap < "u") {
      let n2 = /* @__PURE__ */ new WeakMap();
      Ia = (e) => n2.get(e), La = (e, t) => (n2.set(e, t), t);
    } else {
      const n2 = [];
      let t = 0;
      Ia = (o) => {
        for (let i2 = 0; i2 < n2.length; i2 += 2)
          if (n2[i2] == o) return n2[i2 + 1];
      }, La = (o, i2) => (t == 10 && (t = 0), n2[t++] = o, n2[t++] = i2);
    }
    var rn = class {
      constructor(n2, e, t, o) {
        this.width = n2, this.height = e, this.map = t, this.problems = o;
      }
      // Find the dimensions of the cell at the given position.
      findCell(n2) {
        for (let e = 0; e < this.map.length; e++) {
          const t = this.map[e];
          if (t != n2) continue;
          const o = e % this.width, i2 = e / this.width | 0;
          let s = o + 1, r = i2 + 1;
          for (let a = 1; s < this.width && this.map[e + a] == t; a++)
            s++;
          for (let a = 1; r < this.height && this.map[e + this.width * a] == t; a++)
            r++;
          return { left: o, top: i2, right: s, bottom: r };
        }
        throw new RangeError(`No cell with offset ${n2} found`);
      }
      // Find the left side of the cell at the given position.
      colCount(n2) {
        for (let e = 0; e < this.map.length; e++)
          if (this.map[e] == n2)
            return e % this.width;
        throw new RangeError(`No cell with offset ${n2} found`);
      }
      // Find the next cell in the given direction, starting from the cell
      // at `pos`, if any.
      nextCell(n2, e, t) {
        const { left: o, right: i2, top: s, bottom: r } = this.findCell(n2);
        return e == "horiz" ? (t < 0 ? o == 0 : i2 == this.width) ? null : this.map[s * this.width + (t < 0 ? o - 1 : i2)] : (t < 0 ? s == 0 : r == this.height) ? null : this.map[o + this.width * (t < 0 ? s - 1 : r)];
      }
      // Get the rectangle spanning the two given cells.
      rectBetween(n2, e) {
        const {
          left: t,
          right: o,
          top: i2,
          bottom: s
        } = this.findCell(n2), {
          left: r,
          right: a,
          top: l,
          bottom: u
        } = this.findCell(e);
        return {
          left: Math.min(t, r),
          top: Math.min(i2, l),
          right: Math.max(o, a),
          bottom: Math.max(s, u)
        };
      }
      // Return the position of all cells that have the top left corner in
      // the given rectangle.
      cellsInRect(n2) {
        const e = [], t = {};
        for (let o = n2.top; o < n2.bottom; o++)
          for (let i2 = n2.left; i2 < n2.right; i2++) {
            const s = o * this.width + i2, r = this.map[s];
            t[r] || (t[r] = true, !(i2 == n2.left && i2 && this.map[s - 1] == r || o == n2.top && o && this.map[s - this.width] == r) && e.push(r));
          }
        return e;
      }
      // Return the position at which the cell at the given row and column
      // starts, or would start, if a cell started there.
      positionAt(n2, e, t) {
        for (let o = 0, i2 = 0; ; o++) {
          const s = i2 + t.child(o).nodeSize;
          if (o == n2) {
            let r = e + n2 * this.width;
            const a = (n2 + 1) * this.width;
            for (; r < a && this.map[r] < i2; ) r++;
            return r == a ? s - 1 : this.map[r];
          }
          i2 = s;
        }
      }
      // Find the table map for the given table node.
      static get(n2) {
        return Ia(n2) || La(n2, Ok(n2));
      }
    };
    function Ok(n2) {
      if (n2.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + n2.type.name);
      const e = Mk(n2), t = n2.childCount, o = [];
      let i2 = 0, s = null;
      const r = [];
      for (let u = 0, c2 = e * t; u < c2; u++) o[u] = 0;
      for (let u = 0, c2 = 0; u < t; u++) {
        const d = n2.child(u);
        c2++;
        for (let m = 0; ; m++) {
          for (; i2 < o.length && o[i2] != 0; ) i2++;
          if (m == d.childCount) break;
          const f = d.child(m), { colspan: b, rowspan: h2, colwidth: y } = f.attrs;
          for (let C = 0; C < h2; C++) {
            if (C + u >= t) {
              (s || (s = [])).push({
                type: "overlong_rowspan",
                pos: c2,
                n: h2 - C
              });
              break;
            }
            const v = i2 + C * e;
            for (let x = 0; x < b; x++) {
              o[v + x] == 0 ? o[v + x] = c2 : (s || (s = [])).push({
                type: "collision",
                row: u,
                pos: c2,
                n: b - x
              });
              const S = y && y[x];
              if (S) {
                const F = (v + x) % e * 2, Y = r[F];
                Y == null || Y != S && r[F + 1] == 1 ? (r[F] = S, r[F + 1] = 1) : Y == S && r[F + 1]++;
              }
            }
          }
          i2 += b, c2 += f.nodeSize;
        }
        const p2 = (u + 1) * e;
        let _ = 0;
        for (; i2 < p2; ) o[i2++] == 0 && _++;
        _ && (s || (s = [])).push({ type: "missing", row: u, n: _ }), c2++;
      }
      (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
      const a = new rn(e, t, o, s);
      let l = false;
      for (let u = 0; !l && u < r.length; u += 2)
        r[u] != null && r[u + 1] < t && (l = true);
      return l && Rk(a, r, n2), a;
    }
    function Mk(n2) {
      let e = -1, t = false;
      for (let o = 0; o < n2.childCount; o++) {
        const i2 = n2.child(o);
        let s = 0;
        if (t)
          for (let r = 0; r < o; r++) {
            const a = n2.child(r);
            for (let l = 0; l < a.childCount; l++) {
              const u = a.child(l);
              r + u.attrs.rowspan > o && (s += u.attrs.colspan);
            }
          }
        for (let r = 0; r < i2.childCount; r++) {
          const a = i2.child(r);
          s += a.attrs.colspan, a.attrs.rowspan > 1 && (t = true);
        }
        e == -1 ? e = s : e != s && (e = Math.max(e, s));
      }
      return e;
    }
    function Rk(n2, e, t) {
      n2.problems || (n2.problems = []);
      const o = {};
      for (let i2 = 0; i2 < n2.map.length; i2++) {
        const s = n2.map[i2];
        if (o[s]) continue;
        o[s] = true;
        const r = t.nodeAt(s);
        if (!r)
          throw new RangeError(`No cell with offset ${s} found`);
        let a = null;
        const l = r.attrs;
        for (let u = 0; u < l.colspan; u++) {
          const c2 = (i2 + u) % n2.width, d = e[c2 * 2];
          d != null && (!l.colwidth || l.colwidth[u] != d) && ((a || (a = Ik(l)))[u] = d);
        }
        a && n2.problems.unshift({
          type: "colwidth mismatch",
          pos: s,
          colwidth: a
        });
      }
    }
    function Ik(n2) {
      if (n2.colwidth) return n2.colwidth.slice();
      const e = [];
      for (let t = 0; t < n2.colspan; t++) e.push(0);
      return e;
    }
    function Rn(n2) {
      let e = n2.cached.tableNodeTypes;
      if (!e) {
        e = n2.cached.tableNodeTypes = {};
        for (const t in n2.nodes) {
          const o = n2.nodes[t], i2 = o.spec.tableRole;
          i2 && (e[i2] = o);
        }
      }
      return e;
    }
    var io = new en("selectingCells");
    function li(n2) {
      for (let e = n2.depth - 1; e > 0; e--)
        if (n2.node(e).type.spec.tableRole == "row")
          return n2.node(0).resolve(n2.before(e + 1));
      return null;
    }
    function Lk(n2) {
      for (let e = n2.depth; e > 0; e--) {
        const t = n2.node(e).type.spec.tableRole;
        if (t === "cell" || t === "header_cell") return n2.node(e);
      }
      return null;
    }
    function St(n2) {
      const e = n2.selection.$head;
      for (let t = e.depth; t > 0; t--)
        if (e.node(t).type.spec.tableRole == "row") return true;
      return false;
    }
    function Ar(n2) {
      const e = n2.selection;
      if ("$anchorCell" in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
      if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
      const t = li(e.$head) || Dk(e.$head);
      if (t)
        return t;
      throw new RangeError(`No cell found around position ${e.head}`);
    }
    function Dk(n2) {
      for (let e = n2.nodeAfter, t = n2.pos; e; e = e.firstChild, t++) {
        const o = e.type.spec.tableRole;
        if (o == "cell" || o == "header_cell") return n2.doc.resolve(t);
      }
      for (let e = n2.nodeBefore, t = n2.pos; e; e = e.lastChild, t--) {
        const o = e.type.spec.tableRole;
        if (o == "cell" || o == "header_cell")
          return n2.doc.resolve(t - e.nodeSize);
      }
    }
    function Da(n2) {
      return n2.parent.type.spec.tableRole == "row" && !!n2.nodeAfter;
    }
    function Bk(n2) {
      return n2.node(0).resolve(n2.pos + n2.nodeAfter.nodeSize);
    }
    function Sl(n2, e) {
      return n2.depth == e.depth && n2.pos >= e.start(-1) && n2.pos <= e.end(-1);
    }
    function Ap(n2, e, t) {
      const o = n2.node(-1), i2 = rn.get(o), s = n2.start(-1), r = i2.nextCell(n2.pos - s, e, t);
      return r == null ? null : n2.node(0).resolve(s + r);
    }
    function Ro(n2, e, t = 1) {
      const o = { ...n2, colspan: n2.colspan - t };
      return o.colwidth && (o.colwidth = o.colwidth.slice(), o.colwidth.splice(e, t), o.colwidth.some((i2) => i2 > 0) || (o.colwidth = null)), o;
    }
    function Np(n2, e, t = 1) {
      const o = { ...n2, colspan: n2.colspan + t };
      if (o.colwidth) {
        o.colwidth = o.colwidth.slice();
        for (let i2 = 0; i2 < t; i2++) o.colwidth.splice(e, 0, 0);
      }
      return o;
    }
    function Pk(n2, e, t) {
      const o = Rn(e.type.schema).header_cell;
      for (let i2 = 0; i2 < n2.height; i2++)
        if (e.nodeAt(n2.map[t + i2 * n2.width]).type != o)
          return false;
      return true;
    }
    var Ve = class qt extends Te {
      // A table selection is identified by its anchor and head cells. The
      // positions given to this constructor should point _before_ two
      // cells in the same table. They may be the same, to select a single
      // cell.
      constructor(e, t = e) {
        const o = e.node(-1), i2 = rn.get(o), s = e.start(-1), r = i2.rectBetween(
          e.pos - s,
          t.pos - s
        ), a = e.node(0), l = i2.cellsInRect(r).filter((c2) => c2 != t.pos - s);
        l.unshift(t.pos - s);
        const u = l.map((c2) => {
          const d = o.nodeAt(c2);
          if (!d)
            throw RangeError(`No cell with offset ${c2} found`);
          const p2 = s + c2 + 1;
          return new cd(
            a.resolve(p2),
            a.resolve(p2 + d.content.size)
          );
        });
        super(u[0].$from, u[0].$to, u), this.$anchorCell = e, this.$headCell = t;
      }
      map(e, t) {
        const o = e.resolve(t.map(this.$anchorCell.pos)), i2 = e.resolve(t.map(this.$headCell.pos));
        if (Da(o) && Da(i2) && Sl(o, i2)) {
          const s = this.$anchorCell.node(-1) != o.node(-1);
          return s && this.isRowSelection() ? qt.rowSelection(o, i2) : s && this.isColSelection() ? qt.colSelection(o, i2) : new qt(o, i2);
        }
        return Ce.between(o, i2);
      }
      // Returns a rectangular slice of table rows containing the selected
      // cells.
      content() {
        const e = this.$anchorCell.node(-1), t = rn.get(e), o = this.$anchorCell.start(-1), i2 = t.rectBetween(
          this.$anchorCell.pos - o,
          this.$headCell.pos - o
        ), s = {}, r = [];
        for (let l = i2.top; l < i2.bottom; l++) {
          const u = [];
          for (let c2 = l * t.width + i2.left, d = i2.left; d < i2.right; d++, c2++) {
            const p2 = t.map[c2];
            if (s[p2]) continue;
            s[p2] = true;
            const _ = t.findCell(p2);
            let m = e.nodeAt(p2);
            if (!m)
              throw RangeError(`No cell with offset ${p2} found`);
            const f = i2.left - _.left, b = _.right - i2.right;
            if (f > 0 || b > 0) {
              let h2 = m.attrs;
              if (f > 0 && (h2 = Ro(h2, 0, f)), b > 0 && (h2 = Ro(
                h2,
                h2.colspan - b,
                b
              )), _.left < i2.left) {
                if (m = m.type.createAndFill(h2), !m)
                  throw RangeError(
                    `Could not create cell with attrs ${JSON.stringify(h2)}`
                  );
              } else
                m = m.type.create(h2, m.content);
            }
            if (_.top < i2.top || _.bottom > i2.bottom) {
              const h2 = {
                ...m.attrs,
                rowspan: Math.min(_.bottom, i2.bottom) - Math.max(_.top, i2.top)
              };
              _.top < i2.top ? m = m.type.createAndFill(h2) : m = m.type.create(h2, m.content);
            }
            u.push(m);
          }
          r.push(e.child(l).copy(W.from(u)));
        }
        const a = this.isColSelection() && this.isRowSelection() ? e : r;
        return new G(W.from(a), 1, 1);
      }
      replace(e, t = G.empty) {
        const o = e.steps.length, i2 = this.ranges;
        for (let r = 0; r < i2.length; r++) {
          const { $from: a, $to: l } = i2[r], u = e.mapping.slice(o);
          e.replace(
            u.map(a.pos),
            u.map(l.pos),
            r ? G.empty : t
          );
        }
        const s = Te.findFrom(
          e.doc.resolve(e.mapping.slice(o).map(this.to)),
          -1
        );
        s && e.setSelection(s);
      }
      replaceWith(e, t) {
        this.replace(e, new G(W.from(t), 0, 0));
      }
      forEachCell(e) {
        const t = this.$anchorCell.node(-1), o = rn.get(t), i2 = this.$anchorCell.start(-1), s = o.cellsInRect(
          o.rectBetween(
            this.$anchorCell.pos - i2,
            this.$headCell.pos - i2
          )
        );
        for (let r = 0; r < s.length; r++)
          e(t.nodeAt(s[r]), i2 + s[r]);
      }
      // True if this selection goes all the way from the top to the
      // bottom of the table.
      isColSelection() {
        const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
        if (Math.min(e, t) > 0) return false;
        const o = e + this.$anchorCell.nodeAfter.attrs.rowspan, i2 = t + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(o, i2) == this.$headCell.node(-1).childCount;
      }
      // Returns the smallest column selection that covers the given anchor
      // and head cell.
      static colSelection(e, t = e) {
        const o = e.node(-1), i2 = rn.get(o), s = e.start(-1), r = i2.findCell(e.pos - s), a = i2.findCell(t.pos - s), l = e.node(0);
        return r.top <= a.top ? (r.top > 0 && (e = l.resolve(s + i2.map[r.left])), a.bottom < i2.height && (t = l.resolve(
          s + i2.map[i2.width * (i2.height - 1) + a.right - 1]
        ))) : (a.top > 0 && (t = l.resolve(s + i2.map[a.left])), r.bottom < i2.height && (e = l.resolve(
          s + i2.map[i2.width * (i2.height - 1) + r.right - 1]
        ))), new qt(e, t);
      }
      // True if this selection goes all the way from the left to the
      // right of the table.
      isRowSelection() {
        const e = this.$anchorCell.node(-1), t = rn.get(e), o = this.$anchorCell.start(-1), i2 = t.colCount(this.$anchorCell.pos - o), s = t.colCount(this.$headCell.pos - o);
        if (Math.min(i2, s) > 0) return false;
        const r = i2 + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(r, a) == t.width;
      }
      eq(e) {
        return e instanceof qt && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
      }
      // Returns the smallest row selection that covers the given anchor
      // and head cell.
      static rowSelection(e, t = e) {
        const o = e.node(-1), i2 = rn.get(o), s = e.start(-1), r = i2.findCell(e.pos - s), a = i2.findCell(t.pos - s), l = e.node(0);
        return r.left <= a.left ? (r.left > 0 && (e = l.resolve(
          s + i2.map[r.top * i2.width]
        )), a.right < i2.width && (t = l.resolve(
          s + i2.map[i2.width * (a.top + 1) - 1]
        ))) : (a.left > 0 && (t = l.resolve(s + i2.map[a.top * i2.width])), r.right < i2.width && (e = l.resolve(
          s + i2.map[i2.width * (r.top + 1) - 1]
        ))), new qt(e, t);
      }
      toJSON() {
        return {
          type: "cell",
          anchor: this.$anchorCell.pos,
          head: this.$headCell.pos
        };
      }
      static fromJSON(e, t) {
        return new qt(e.resolve(t.anchor), e.resolve(t.head));
      }
      static create(e, t, o = t) {
        return new qt(e.resolve(t), e.resolve(o));
      }
      getBookmark() {
        return new $k(this.$anchorCell.pos, this.$headCell.pos);
      }
    };
    Ve.prototype.visible = false;
    Te.jsonID("cell", Ve);
    var $k = class Op {
      constructor(e, t) {
        this.anchor = e, this.head = t;
      }
      map(e) {
        return new Op(e.map(this.anchor), e.map(this.head));
      }
      resolve(e) {
        const t = e.resolve(this.anchor), o = e.resolve(this.head);
        return t.parent.type.spec.tableRole == "row" && o.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && o.index() < o.parent.childCount && Sl(t, o) ? new Ve(t, o) : Te.near(o, 1);
      }
    };
    function zk(n2) {
      if (!(n2.selection instanceof Ve)) return null;
      const e = [];
      return n2.selection.forEachCell((t, o) => {
        e.push(
          hn.node(o, o + t.nodeSize, { class: "selectedCell" })
        );
      }), He.create(n2.doc, e);
    }
    function Fk({ $from: n2, $to: e }) {
      if (n2.pos == e.pos || n2.pos < e.pos - 6) return false;
      let t = n2.pos, o = e.pos, i2 = n2.depth;
      for (; i2 >= 0 && !(n2.after(i2 + 1) < n2.end(i2)); i2--, t++)
        ;
      for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, o--)
        ;
      return t == o && /row|table/.test(n2.node(i2).type.spec.tableRole);
    }
    function Hk({ $from: n2, $to: e }) {
      let t, o;
      for (let i2 = n2.depth; i2 > 0; i2--) {
        const s = n2.node(i2);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
          t = s;
          break;
        }
      }
      for (let i2 = e.depth; i2 > 0; i2--) {
        const s = e.node(i2);
        if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
          o = s;
          break;
        }
      }
      return t !== o && e.parentOffset === 0;
    }
    function Uk(n2, e, t) {
      const o = (e || n2).selection, i2 = (e || n2).doc;
      let s, r;
      if (o instanceof xe && (r = o.node.type.spec.tableRole)) {
        if (r == "cell" || r == "header_cell")
          s = Ve.create(i2, o.from);
        else if (r == "row") {
          const a = i2.resolve(o.from + 1);
          s = Ve.rowSelection(a, a);
        } else if (!t) {
          const a = rn.get(o.node), l = o.from + 1, u = l + a.map[a.width * a.height - 1];
          s = Ve.create(i2, l + 1, u);
        }
      } else o instanceof Ce && Fk(o) ? s = Ce.create(i2, o.from) : o instanceof Ce && Hk(o) && (s = Ce.create(i2, o.$from.start(), o.$from.end()));
      return s && (e || (e = n2.tr)).setSelection(s), e;
    }
    var qk = new en("fix-tables");
    function Mp(n2, e, t, o) {
      const i2 = n2.childCount, s = e.childCount;
      e: for (let r = 0, a = 0; r < s; r++) {
        const l = e.child(r);
        for (let u = a, c2 = Math.min(i2, r + 3); u < c2; u++)
          if (n2.child(u) == l) {
            a = u + 1, t += l.nodeSize;
            continue e;
          }
        o(l, t), a < i2 && n2.child(a).sameMarkup(l) ? Mp(n2.child(a), l, t + 1, o) : l.nodesBetween(0, l.content.size, o, t + 1), t += l.nodeSize;
      }
    }
    function Rp(n2, e) {
      let t;
      const o = (i2, s) => {
        i2.type.spec.tableRole == "table" && (t = Kk(n2, i2, s, t));
      };
      return e ? e.doc != n2.doc && Mp(e.doc, n2.doc, 0, o) : n2.doc.descendants(o), t;
    }
    function Kk(n2, e, t, o) {
      const i2 = rn.get(e);
      if (!i2.problems) return o;
      o || (o = n2.tr);
      const s = [];
      for (let l = 0; l < i2.height; l++) s.push(0);
      for (let l = 0; l < i2.problems.length; l++) {
        const u = i2.problems[l];
        if (u.type == "collision") {
          const c2 = e.nodeAt(u.pos);
          if (!c2) continue;
          const d = c2.attrs;
          for (let p2 = 0; p2 < d.rowspan; p2++) s[u.row + p2] += u.n;
          o.setNodeMarkup(
            o.mapping.map(t + 1 + u.pos),
            null,
            Ro(d, d.colspan - u.n, u.n)
          );
        } else if (u.type == "missing")
          s[u.row] += u.n;
        else if (u.type == "overlong_rowspan") {
          const c2 = e.nodeAt(u.pos);
          if (!c2) continue;
          o.setNodeMarkup(o.mapping.map(t + 1 + u.pos), null, {
            ...c2.attrs,
            rowspan: c2.attrs.rowspan - u.n
          });
        } else if (u.type == "colwidth mismatch") {
          const c2 = e.nodeAt(u.pos);
          if (!c2) continue;
          o.setNodeMarkup(o.mapping.map(t + 1 + u.pos), null, {
            ...c2.attrs,
            colwidth: u.colwidth
          });
        } else if (u.type == "zero_sized") {
          const c2 = o.mapping.map(t);
          o.delete(c2, c2 + e.nodeSize);
        }
      }
      let r, a;
      for (let l = 0; l < s.length; l++)
        s[l] && (r == null && (r = l), a = l);
      for (let l = 0, u = t + 1; l < i2.height; l++) {
        const c2 = e.child(l), d = u + c2.nodeSize, p2 = s[l];
        if (p2 > 0) {
          let _ = "cell";
          c2.firstChild && (_ = c2.firstChild.type.spec.tableRole);
          const m = [];
          for (let b = 0; b < p2; b++) {
            const h2 = Rn(n2.schema)[_].createAndFill();
            h2 && m.push(h2);
          }
          const f = (l == 0 || r == l - 1) && a == l ? u + 1 : d - 1;
          o.insert(o.mapping.map(f), m);
        }
        u = d;
      }
      return o.setMeta(qk, { fixTables: true });
    }
    function zt(n2) {
      const e = n2.selection, t = Ar(n2), o = t.node(-1), i2 = t.start(-1), s = rn.get(o);
      return { ...e instanceof Ve ? s.rectBetween(
        e.$anchorCell.pos - i2,
        e.$headCell.pos - i2
      ) : s.findCell(t.pos - i2), tableStart: i2, map: s, table: o };
    }
    function Ip(n2, { map: e, tableStart: t, table: o }, i2) {
      let s = i2 > 0 ? -1 : 0;
      Pk(e, o, i2 + s) && (s = i2 == 0 || i2 == e.width ? null : 0);
      for (let r = 0; r < e.height; r++) {
        const a = r * e.width + i2;
        if (i2 > 0 && i2 < e.width && e.map[a - 1] == e.map[a]) {
          const l = e.map[a], u = o.nodeAt(l);
          n2.setNodeMarkup(
            n2.mapping.map(t + l),
            null,
            Np(u.attrs, i2 - e.colCount(l))
          ), r += u.attrs.rowspan - 1;
        } else {
          const l = s == null ? Rn(o.type.schema).cell : o.nodeAt(e.map[a + s]).type, u = e.positionAt(r, i2, o);
          n2.insert(n2.mapping.map(t + u), l.createAndFill());
        }
      }
      return n2;
    }
    function Vk(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2);
        e(Ip(n2.tr, t, t.left));
      }
      return true;
    }
    function Wk(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2);
        e(Ip(n2.tr, t, t.right));
      }
      return true;
    }
    function Gk(n2, { map: e, table: t, tableStart: o }, i2) {
      const s = n2.mapping.maps.length;
      for (let r = 0; r < e.height; ) {
        const a = r * e.width + i2, l = e.map[a], u = t.nodeAt(l), c2 = u.attrs;
        if (i2 > 0 && e.map[a - 1] == l || i2 < e.width - 1 && e.map[a + 1] == l)
          n2.setNodeMarkup(
            n2.mapping.slice(s).map(o + l),
            null,
            Ro(c2, i2 - e.colCount(l))
          );
        else {
          const d = n2.mapping.slice(s).map(o + l);
          n2.delete(d, d + u.nodeSize);
        }
        r += c2.rowspan;
      }
    }
    function Yk(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2), o = n2.tr;
        if (t.left == 0 && t.right == t.map.width) return false;
        for (let i2 = t.right - 1; Gk(o, t, i2), i2 != t.left; i2--) {
          const s = t.tableStart ? o.doc.nodeAt(t.tableStart - 1) : o.doc;
          if (!s)
            throw RangeError("No table found");
          t.table = s, t.map = rn.get(s);
        }
        e(o);
      }
      return true;
    }
    function Jk(n2, e, t) {
      var o;
      const i2 = Rn(e.type.schema).header_cell;
      for (let s = 0; s < n2.width; s++)
        if (((o = e.nodeAt(n2.map[s + t * n2.width])) == null ? void 0 : o.type) != i2)
          return false;
      return true;
    }
    function Lp(n2, { map: e, tableStart: t, table: o }, i2) {
      var s;
      let r = t;
      for (let u = 0; u < i2; u++) r += o.child(u).nodeSize;
      const a = [];
      let l = i2 > 0 ? -1 : 0;
      Jk(e, o, i2 + l) && (l = i2 == 0 || i2 == e.height ? null : 0);
      for (let u = 0, c2 = e.width * i2; u < e.width; u++, c2++)
        if (i2 > 0 && i2 < e.height && e.map[c2] == e.map[c2 - e.width]) {
          const d = e.map[c2], p2 = o.nodeAt(d).attrs;
          n2.setNodeMarkup(t + d, null, {
            ...p2,
            rowspan: p2.rowspan + 1
          }), u += p2.colspan - 1;
        } else {
          const d = l == null ? Rn(o.type.schema).cell : (s = o.nodeAt(e.map[c2 + l * e.width])) == null ? void 0 : s.type, p2 = d == null ? void 0 : d.createAndFill();
          p2 && a.push(p2);
        }
      return n2.insert(r, Rn(o.type.schema).row.create(null, a)), n2;
    }
    function Zk(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2);
        e(Lp(n2.tr, t, t.top));
      }
      return true;
    }
    function Xk(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2);
        e(Lp(n2.tr, t, t.bottom));
      }
      return true;
    }
    function Qk(n2, { map: e, table: t, tableStart: o }, i2) {
      let s = 0;
      for (let u = 0; u < i2; u++) s += t.child(u).nodeSize;
      const r = s + t.child(i2).nodeSize, a = n2.mapping.maps.length;
      n2.delete(s + o, r + o);
      const l = /* @__PURE__ */ new Set();
      for (let u = 0, c2 = i2 * e.width; u < e.width; u++, c2++) {
        const d = e.map[c2];
        if (!l.has(d)) {
          if (l.add(d), i2 > 0 && d == e.map[c2 - e.width]) {
            const p2 = t.nodeAt(d).attrs;
            n2.setNodeMarkup(n2.mapping.slice(a).map(d + o), null, {
              ...p2,
              rowspan: p2.rowspan - 1
            }), u += p2.colspan - 1;
          } else if (i2 < e.height && d == e.map[c2 + e.width]) {
            const p2 = t.nodeAt(d), _ = p2.attrs, m = p2.type.create(
              { ..._, rowspan: p2.attrs.rowspan - 1 },
              p2.content
            ), f = e.positionAt(i2 + 1, u, t);
            n2.insert(n2.mapping.slice(a).map(o + f), m), u += _.colspan - 1;
          }
        }
      }
    }
    function ey(n2, e) {
      if (!St(n2)) return false;
      if (e) {
        const t = zt(n2), o = n2.tr;
        if (t.top == 0 && t.bottom == t.map.height) return false;
        for (let i2 = t.bottom - 1; Qk(o, t, i2), i2 != t.top; i2--) {
          const s = t.tableStart ? o.doc.nodeAt(t.tableStart - 1) : o.doc;
          if (!s)
            throw RangeError("No table found");
          t.table = s, t.map = rn.get(t.table);
        }
        e(o);
      }
      return true;
    }
    function Qu(n2) {
      const e = n2.content;
      return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
    }
    function ny({ width: n2, height: e, map: t }, o) {
      let i2 = o.top * n2 + o.left, s = i2, r = (o.bottom - 1) * n2 + o.left, a = i2 + (o.right - o.left - 1);
      for (let l = o.top; l < o.bottom; l++) {
        if (o.left > 0 && t[s] == t[s - 1] || o.right < n2 && t[a] == t[a + 1])
          return true;
        s += n2, a += n2;
      }
      for (let l = o.left; l < o.right; l++) {
        if (o.top > 0 && t[i2] == t[i2 - n2] || o.bottom < e && t[r] == t[r + n2])
          return true;
        i2++, r++;
      }
      return false;
    }
    function ec(n2, e) {
      const t = n2.selection;
      if (!(t instanceof Ve) || t.$anchorCell.pos == t.$headCell.pos)
        return false;
      const o = zt(n2), { map: i2 } = o;
      if (ny(i2, o)) return false;
      if (e) {
        const s = n2.tr, r = {};
        let a = W.empty, l, u;
        for (let c2 = o.top; c2 < o.bottom; c2++)
          for (let d = o.left; d < o.right; d++) {
            const p2 = i2.map[c2 * i2.width + d], _ = o.table.nodeAt(p2);
            if (!(r[p2] || !_))
              if (r[p2] = true, l == null)
                l = p2, u = _;
              else {
                Qu(_) || (a = a.append(_.content));
                const m = s.mapping.map(p2 + o.tableStart);
                s.delete(m, m + _.nodeSize);
              }
          }
        if (l == null || u == null)
          return true;
        if (s.setNodeMarkup(l + o.tableStart, null, {
          ...Np(
            u.attrs,
            u.attrs.colspan,
            o.right - o.left - u.attrs.colspan
          ),
          rowspan: o.bottom - o.top
        }), a.size) {
          const c2 = l + 1 + u.content.size, d = Qu(u) ? l + 1 : c2;
          s.replaceWith(d + o.tableStart, c2 + o.tableStart, a);
        }
        s.setSelection(
          new Ve(s.doc.resolve(l + o.tableStart))
        ), e(s);
      }
      return true;
    }
    function nc(n2, e) {
      const t = Rn(n2.schema);
      return ty(({ node: o }) => t[o.type.spec.tableRole])(n2, e);
    }
    function ty(n2) {
      return (e, t) => {
        var o;
        const i2 = e.selection;
        let s, r;
        if (i2 instanceof Ve) {
          if (i2.$anchorCell.pos != i2.$headCell.pos) return false;
          s = i2.$anchorCell.nodeAfter, r = i2.$anchorCell.pos;
        } else {
          if (s = Lk(i2.$from), !s) return false;
          r = (o = li(i2.$from)) == null ? void 0 : o.pos;
        }
        if (s == null || r == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1)
          return false;
        if (t) {
          let a = s.attrs;
          const l = [], u = a.colwidth;
          a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
          const c2 = zt(e), d = e.tr;
          for (let _ = 0; _ < c2.right - c2.left; _++)
            l.push(
              u ? {
                ...a,
                colwidth: u && u[_] ? [u[_]] : null
              } : a
            );
          let p2;
          for (let _ = c2.top; _ < c2.bottom; _++) {
            let m = c2.map.positionAt(_, c2.left, c2.table);
            _ == c2.top && (m += s.nodeSize);
            for (let f = c2.left, b = 0; f < c2.right; f++, b++)
              f == c2.left && _ == c2.top || d.insert(
                p2 = d.mapping.map(m + c2.tableStart, 1),
                n2({ node: s, row: _, col: f }).createAndFill(l[b])
              );
          }
          d.setNodeMarkup(
            r,
            n2({ node: s, row: c2.top, col: c2.left }),
            l[0]
          ), i2 instanceof Ve && d.setSelection(
            new Ve(
              d.doc.resolve(i2.$anchorCell.pos),
              p2 ? d.doc.resolve(p2) : void 0
            )
          ), t(d);
        }
        return true;
      };
    }
    function oy(n2, e) {
      return function(t, o) {
        if (!St(t)) return false;
        const i2 = Ar(t);
        if (i2.nodeAfter.attrs[n2] === e) return false;
        if (o) {
          const s = t.tr;
          t.selection instanceof Ve ? t.selection.forEachCell((r, a) => {
            r.attrs[n2] !== e && s.setNodeMarkup(a, null, {
              ...r.attrs,
              [n2]: e
            });
          }) : s.setNodeMarkup(i2.pos, null, {
            ...i2.nodeAfter.attrs,
            [n2]: e
          }), o(s);
        }
        return true;
      };
    }
    function iy(n2) {
      return function(e, t) {
        if (!St(e)) return false;
        if (t) {
          const o = Rn(e.schema), i2 = zt(e), s = e.tr, r = i2.map.cellsInRect(
            n2 == "column" ? {
              left: i2.left,
              top: 0,
              right: i2.right,
              bottom: i2.map.height
            } : n2 == "row" ? {
              left: 0,
              top: i2.top,
              right: i2.map.width,
              bottom: i2.bottom
            } : i2
          ), a = r.map((l) => i2.table.nodeAt(l));
          for (let l = 0; l < r.length; l++)
            a[l].type == o.header_cell && s.setNodeMarkup(
              i2.tableStart + r[l],
              o.cell,
              a[l].attrs
            );
          if (s.steps.length == 0)
            for (let l = 0; l < r.length; l++)
              s.setNodeMarkup(
                i2.tableStart + r[l],
                o.header_cell,
                a[l].attrs
              );
          t(s);
        }
        return true;
      };
    }
    function tc(n2, e, t) {
      const o = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: n2 == "row" ? e.map.width : 1,
        bottom: n2 == "column" ? e.map.height : 1
      });
      for (let i2 = 0; i2 < o.length; i2++) {
        const s = e.table.nodeAt(o[i2]);
        if (s && s.type !== t.header_cell)
          return false;
      }
      return true;
    }
    function zi(n2, e) {
      return e = e || { useDeprecatedLogic: false }, e.useDeprecatedLogic ? iy(n2) : function(t, o) {
        if (!St(t)) return false;
        if (o) {
          const i2 = Rn(t.schema), s = zt(t), r = t.tr, a = tc("row", s, i2), l = tc(
            "column",
            s,
            i2
          ), c2 = (n2 === "column" ? a : n2 === "row" ? l : false) ? 1 : 0, d = n2 == "column" ? {
            left: 0,
            top: c2,
            right: 1,
            bottom: s.map.height
          } : n2 == "row" ? {
            left: c2,
            top: 0,
            right: s.map.width,
            bottom: 1
          } : s, p2 = n2 == "column" ? l ? i2.cell : i2.header_cell : n2 == "row" ? a ? i2.cell : i2.header_cell : i2.cell;
          s.map.cellsInRect(d).forEach((_) => {
            const m = _ + s.tableStart, f = r.doc.nodeAt(m);
            f && r.setNodeMarkup(m, p2, f.attrs);
          }), o(r);
        }
        return true;
      };
    }
    zi("row", {
      useDeprecatedLogic: true
    });
    zi("column", {
      useDeprecatedLogic: true
    });
    var sy = zi("cell", {
      useDeprecatedLogic: true
    });
    function ry(n2, e) {
      if (e < 0) {
        const t = n2.nodeBefore;
        if (t) return n2.pos - t.nodeSize;
        for (let o = n2.index(-1) - 1, i2 = n2.before(); o >= 0; o--) {
          const s = n2.node(-1).child(o), r = s.lastChild;
          if (r)
            return i2 - 1 - r.nodeSize;
          i2 -= s.nodeSize;
        }
      } else {
        if (n2.index() < n2.parent.childCount - 1)
          return n2.pos + n2.nodeAfter.nodeSize;
        const t = n2.node(-1);
        for (let o = n2.indexAfter(-1), i2 = n2.after(); o < t.childCount; o++) {
          const s = t.child(o);
          if (s.childCount) return i2 + 1;
          i2 += s.nodeSize;
        }
      }
      return null;
    }
    function oc(n2) {
      return function(e, t) {
        if (!St(e)) return false;
        const o = ry(Ar(e), n2);
        if (o == null) return false;
        if (t) {
          const i2 = e.doc.resolve(o);
          t(
            e.tr.setSelection(Ce.between(i2, Bk(i2))).scrollIntoView()
          );
        }
        return true;
      };
    }
    function ay(n2, e) {
      const t = n2.selection.$anchor;
      for (let o = t.depth; o > 0; o--)
        if (t.node(o).type.spec.tableRole == "table")
          return e && e(
            n2.tr.delete(t.before(o), t.after(o)).scrollIntoView()
          ), true;
      return false;
    }
    function us(n2, e) {
      const t = n2.selection;
      if (!(t instanceof Ve)) return false;
      if (e) {
        const o = n2.tr, i2 = Rn(n2.schema).cell.createAndFill().content;
        t.forEachCell((s, r) => {
          s.content.eq(i2) || o.replace(
            o.mapping.map(r + 1),
            o.mapping.map(r + s.nodeSize - 1),
            new G(i2, 0, 0)
          );
        }), o.docChanged && e(o);
      }
      return true;
    }
    function ly(n2) {
      if (!n2.size) return null;
      let { content: e, openStart: t, openEnd: o } = n2;
      for (; e.childCount == 1 && (t > 0 && o > 0 || e.child(0).type.spec.tableRole == "table"); )
        t--, o--, e = e.child(0).content;
      const i2 = e.child(0), s = i2.type.spec.tableRole, r = i2.type.schema, a = [];
      if (s == "row")
        for (let l = 0; l < e.childCount; l++) {
          let u = e.child(l).content;
          const c2 = l ? 0 : Math.max(0, t - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, o - 1);
          (c2 || d) && (u = Ba(
            Rn(r).row,
            new G(u, c2, d)
          ).content), a.push(u);
        }
      else if (s == "cell" || s == "header_cell")
        a.push(
          t || o ? Ba(
            Rn(r).row,
            new G(e, t, o)
          ).content : e
        );
      else
        return null;
      return uy(r, a);
    }
    function uy(n2, e) {
      const t = [];
      for (let i2 = 0; i2 < e.length; i2++) {
        const s = e[i2];
        for (let r = s.childCount - 1; r >= 0; r--) {
          const { rowspan: a, colspan: l } = s.child(r).attrs;
          for (let u = i2; u < i2 + a; u++)
            t[u] = (t[u] || 0) + l;
        }
      }
      let o = 0;
      for (let i2 = 0; i2 < t.length; i2++) o = Math.max(o, t[i2]);
      for (let i2 = 0; i2 < t.length; i2++)
        if (i2 >= e.length && e.push(W.empty), t[i2] < o) {
          const s = Rn(n2).cell.createAndFill(), r = [];
          for (let a = t[i2]; a < o; a++)
            r.push(s);
          e[i2] = e[i2].append(W.from(r));
        }
      return { height: e.length, width: o, rows: e };
    }
    function Ba(n2, e) {
      const t = n2.createAndFill();
      return new Gm(t).replace(0, t.content.size, e).doc;
    }
    function cy({ width: n2, height: e, rows: t }, o, i2) {
      if (n2 != o) {
        const s = [], r = [];
        for (let a = 0; a < t.length; a++) {
          const l = t[a], u = [];
          for (let c2 = s[a] || 0, d = 0; c2 < o; d++) {
            let p2 = l.child(d % l.childCount);
            c2 + p2.attrs.colspan > o && (p2 = p2.type.createChecked(
              Ro(
                p2.attrs,
                p2.attrs.colspan,
                c2 + p2.attrs.colspan - o
              ),
              p2.content
            )), u.push(p2), c2 += p2.attrs.colspan;
            for (let _ = 1; _ < p2.attrs.rowspan; _++)
              s[a + _] = (s[a + _] || 0) + p2.attrs.colspan;
          }
          r.push(W.from(u));
        }
        t = r, n2 = o;
      }
      if (e != i2) {
        const s = [];
        for (let r = 0, a = 0; r < i2; r++, a++) {
          const l = [], u = t[a % e];
          for (let c2 = 0; c2 < u.childCount; c2++) {
            let d = u.child(c2);
            r + d.attrs.rowspan > i2 && (d = d.type.create(
              {
                ...d.attrs,
                rowspan: Math.max(1, i2 - d.attrs.rowspan)
              },
              d.content
            )), l.push(d);
          }
          s.push(W.from(l));
        }
        t = s, e = i2;
      }
      return { width: n2, height: e, rows: t };
    }
    function dy(n2, e, t, o, i2, s, r) {
      const a = n2.doc.type.schema, l = Rn(a);
      let u, c2;
      if (i2 > e.width)
        for (let d = 0, p2 = 0; d < e.height; d++) {
          const _ = t.child(d);
          p2 += _.nodeSize;
          const m = [];
          let f;
          _.lastChild == null || _.lastChild.type == l.cell ? f = u || (u = l.cell.createAndFill()) : f = c2 || (c2 = l.header_cell.createAndFill());
          for (let b = e.width; b < i2; b++) m.push(f);
          n2.insert(n2.mapping.slice(r).map(p2 - 1 + o), m);
        }
      if (s > e.height) {
        const d = [];
        for (let m = 0, f = (e.height - 1) * e.width; m < Math.max(e.width, i2); m++) {
          const b = m >= e.width ? false : t.nodeAt(e.map[f + m]).type == l.header_cell;
          d.push(
            b ? c2 || (c2 = l.header_cell.createAndFill()) : u || (u = l.cell.createAndFill())
          );
        }
        const p2 = l.row.create(null, W.from(d)), _ = [];
        for (let m = e.height; m < s; m++) _.push(p2);
        n2.insert(n2.mapping.slice(r).map(o + t.nodeSize - 2), _);
      }
      return !!(u || c2);
    }
    function ic(n2, e, t, o, i2, s, r, a) {
      if (r == 0 || r == e.height) return false;
      let l = false;
      for (let u = i2; u < s; u++) {
        const c2 = r * e.width + u, d = e.map[c2];
        if (e.map[c2 - e.width] == d) {
          l = true;
          const p2 = t.nodeAt(d), { top: _, left: m } = e.findCell(d);
          n2.setNodeMarkup(n2.mapping.slice(a).map(d + o), null, {
            ...p2.attrs,
            rowspan: r - _
          }), n2.insert(
            n2.mapping.slice(a).map(e.positionAt(r, m, t)),
            p2.type.createAndFill({
              ...p2.attrs,
              rowspan: _ + p2.attrs.rowspan - r
            })
          ), u += p2.attrs.colspan - 1;
        }
      }
      return l;
    }
    function sc(n2, e, t, o, i2, s, r, a) {
      if (r == 0 || r == e.width) return false;
      let l = false;
      for (let u = i2; u < s; u++) {
        const c2 = u * e.width + r, d = e.map[c2];
        if (e.map[c2 - 1] == d) {
          l = true;
          const p2 = t.nodeAt(d), _ = e.colCount(d), m = n2.mapping.slice(a).map(d + o);
          n2.setNodeMarkup(
            m,
            null,
            Ro(
              p2.attrs,
              r - _,
              p2.attrs.colspan - (r - _)
            )
          ), n2.insert(
            m + p2.nodeSize,
            p2.type.createAndFill(
              Ro(p2.attrs, 0, r - _)
            )
          ), u += p2.attrs.rowspan - 1;
        }
      }
      return l;
    }
    function rc(n2, e, t, o, i2) {
      let s = t ? n2.doc.nodeAt(t - 1) : n2.doc;
      if (!s)
        throw new Error("No table found");
      let r = rn.get(s);
      const { top: a, left: l } = o, u = l + i2.width, c2 = a + i2.height, d = n2.tr;
      let p2 = 0;
      function _() {
        if (s = t ? d.doc.nodeAt(t - 1) : d.doc, !s)
          throw new Error("No table found");
        r = rn.get(s), p2 = d.mapping.maps.length;
      }
      dy(d, r, s, t, u, c2, p2) && _(), ic(d, r, s, t, l, u, a, p2) && _(), ic(d, r, s, t, l, u, c2, p2) && _(), sc(d, r, s, t, a, c2, l, p2) && _(), sc(d, r, s, t, a, c2, u, p2) && _();
      for (let m = a; m < c2; m++) {
        const f = r.positionAt(m, l, s), b = r.positionAt(m, u, s);
        d.replace(
          d.mapping.slice(p2).map(f + t),
          d.mapping.slice(p2).map(b + t),
          new G(i2.rows[m - a], 0, 0)
        );
      }
      _(), d.setSelection(
        new Ve(
          d.doc.resolve(t + r.positionAt(a, l, s)),
          d.doc.resolve(t + r.positionAt(c2 - 1, u - 1, s))
        )
      ), e(d);
    }
    var py = zd({
      ArrowLeft: cs("horiz", -1),
      ArrowRight: cs("horiz", 1),
      ArrowUp: cs("vert", -1),
      ArrowDown: cs("vert", 1),
      "Shift-ArrowLeft": ds("horiz", -1),
      "Shift-ArrowRight": ds("horiz", 1),
      "Shift-ArrowUp": ds("vert", -1),
      "Shift-ArrowDown": ds("vert", 1),
      Backspace: us,
      "Mod-Backspace": us,
      Delete: us,
      "Mod-Delete": us
    });
    function Ns(n2, e, t) {
      return t.eq(n2.selection) ? false : (e && e(n2.tr.setSelection(t).scrollIntoView()), true);
    }
    function cs(n2, e) {
      return (t, o, i2) => {
        if (!i2) return false;
        const s = t.selection;
        if (s instanceof Ve)
          return Ns(
            t,
            o,
            Te.near(s.$headCell, e)
          );
        if (n2 != "horiz" && !s.empty) return false;
        const r = Dp(i2, n2, e);
        if (r == null) return false;
        if (n2 == "horiz")
          return Ns(
            t,
            o,
            Te.near(t.doc.resolve(s.head + e), e)
          );
        {
          const a = t.doc.resolve(r), l = Ap(a, n2, e);
          let u;
          return l ? u = Te.near(l, 1) : e < 0 ? u = Te.near(t.doc.resolve(a.before(-1)), -1) : u = Te.near(t.doc.resolve(a.after(-1)), 1), Ns(t, o, u);
        }
      };
    }
    function ds(n2, e) {
      return (t, o, i2) => {
        if (!i2) return false;
        const s = t.selection;
        let r;
        if (s instanceof Ve)
          r = s;
        else {
          const l = Dp(i2, n2, e);
          if (l == null) return false;
          r = new Ve(t.doc.resolve(l));
        }
        const a = Ap(r.$headCell, n2, e);
        return a ? Ns(
          t,
          o,
          new Ve(r.$anchorCell, a)
        ) : false;
      };
    }
    function _y(n2, e) {
      const t = n2.state.doc, o = li(t.resolve(e));
      return o ? (n2.dispatch(n2.state.tr.setSelection(new Ve(o))), true) : false;
    }
    function my(n2, e, t) {
      if (!St(n2.state)) return false;
      let o = ly(t);
      const i2 = n2.state.selection;
      if (i2 instanceof Ve) {
        o || (o = {
          width: 1,
          height: 1,
          rows: [
            W.from(
              Ba(Rn(n2.state.schema).cell, t)
            )
          ]
        });
        const s = i2.$anchorCell.node(-1), r = i2.$anchorCell.start(-1), a = rn.get(s).rectBetween(
          i2.$anchorCell.pos - r,
          i2.$headCell.pos - r
        );
        return o = cy(o, a.right - a.left, a.bottom - a.top), rc(n2.state, n2.dispatch, r, a, o), true;
      } else if (o) {
        const s = Ar(n2.state), r = s.start(-1);
        return rc(
          n2.state,
          n2.dispatch,
          r,
          rn.get(s.node(-1)).findCell(s.pos - r),
          o
        ), true;
      } else
        return false;
    }
    function fy(n2, e) {
      var t;
      if (e.ctrlKey || e.metaKey) return;
      const o = ac(n2, e.target);
      let i2;
      if (e.shiftKey && n2.state.selection instanceof Ve)
        s(n2.state.selection.$anchorCell, e), e.preventDefault();
      else if (e.shiftKey && o && (i2 = li(n2.state.selection.$anchor)) != null && ((t = ta(n2, e)) == null ? void 0 : t.pos) != i2.pos)
        s(i2, e), e.preventDefault();
      else if (!o)
        return;
      function s(l, u) {
        let c2 = ta(n2, u);
        const d = io.getState(n2.state) == null;
        if (!c2 || !Sl(l, c2))
          if (d) c2 = l;
          else return;
        const p2 = new Ve(l, c2);
        if (d || !n2.state.selection.eq(p2)) {
          const _ = n2.state.tr.setSelection(p2);
          d && _.setMeta(io, l.pos), n2.dispatch(_);
        }
      }
      function r() {
        n2.root.removeEventListener("mouseup", r), n2.root.removeEventListener("dragstart", r), n2.root.removeEventListener("mousemove", a), io.getState(n2.state) != null && n2.dispatch(n2.state.tr.setMeta(io, -1));
      }
      function a(l) {
        const u = l, c2 = io.getState(n2.state);
        let d;
        if (c2 != null)
          d = n2.state.doc.resolve(c2);
        else if (ac(n2, u.target) != o && (d = ta(n2, e), !d))
          return r();
        d && s(d, u);
      }
      n2.root.addEventListener("mouseup", r), n2.root.addEventListener("dragstart", r), n2.root.addEventListener("mousemove", a);
    }
    function Dp(n2, e, t) {
      if (!(n2.state.selection instanceof Ce)) return null;
      const { $head: o } = n2.state.selection;
      for (let i2 = o.depth - 1; i2 >= 0; i2--) {
        const s = o.node(i2);
        if ((t < 0 ? o.index(i2) : o.indexAfter(i2)) != (t < 0 ? 0 : s.childCount)) return null;
        if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
          const a = o.before(i2), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
          return n2.endOfTextblock(l) ? a : null;
        }
      }
      return null;
    }
    function ac(n2, e) {
      for (; e && e != n2.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
          return e;
      return null;
    }
    function ta(n2, e) {
      const t = n2.posAtCoords({
        left: e.clientX,
        top: e.clientY
      });
      return t && t ? li(n2.state.doc.resolve(t.pos)) : null;
    }
    var gy = class {
      constructor(e, t) {
        this.node = e, this.defaultCellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
          "--default-cell-min-width",
          `${t}px`
        ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Pa(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type != this.node.type ? false : (this.node = e, Pa(
          e,
          this.colgroup,
          this.table,
          this.defaultCellMinWidth
        ), true);
      }
      ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
      }
    };
    function Pa(n2, e, t, o, i2, s) {
      var r;
      let a = 0, l = true, u = e.firstChild;
      const c2 = n2.firstChild;
      if (c2) {
        for (let d = 0, p2 = 0; d < c2.childCount; d++) {
          const { colspan: _, colwidth: m } = c2.child(d).attrs;
          for (let f = 0; f < _; f++, p2++) {
            const b = i2 == p2 ? s : m && m[f], h2 = b ? b + "px" : "";
            if (a += b || o, b || (l = false), u)
              u.style.width != h2 && (u.style.width = h2), u = u.nextSibling;
            else {
              const y = document.createElement("col");
              y.style.width = h2, e.appendChild(y);
            }
          }
        }
        for (; u; ) {
          const d = u.nextSibling;
          (r = u.parentNode) == null || r.removeChild(u), u = d;
        }
        l ? (t.style.width = a + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = a + "px");
      }
    }
    var et = new en(
      "tableColumnResizing"
    );
    function hy({
      handleWidth: n2 = 5,
      cellMinWidth: e = 25,
      defaultCellMinWidth: t = 100,
      View: o = gy,
      lastColumnResizable: i2 = true
    } = {}) {
      const s = new dn({
        key: et,
        state: {
          init(r, a) {
            var l, u;
            const c2 = (u = (l = s.spec) == null ? void 0 : l.props) == null ? void 0 : u.nodeViews, d = Rn(a.schema).table.name;
            return o && c2 && (c2[d] = (p2, _) => new o(p2, t, _)), new vy(-1, false);
          },
          apply(r, a) {
            return a.apply(r);
          }
        },
        props: {
          attributes: (r) => {
            const a = et.getState(r);
            return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
          },
          handleDOMEvents: {
            mousemove: (r, a) => {
              by(r, a, n2, i2);
            },
            mouseleave: (r) => {
              ky(r);
            },
            mousedown: (r, a) => {
              yy(r, a, e, t);
            }
          },
          decorations: (r) => {
            const a = et.getState(r);
            if (a && a.activeHandle > -1)
              return Sy(r, a.activeHandle);
          },
          nodeViews: {}
        }
      });
      return s;
    }
    var vy = class Os {
      constructor(e, t) {
        this.activeHandle = e, this.dragging = t;
      }
      apply(e) {
        const t = this, o = e.getMeta(et);
        if (o && o.setHandle != null)
          return new Os(o.setHandle, false);
        if (o && o.setDragging !== void 0)
          return new Os(t.activeHandle, o.setDragging);
        if (t.activeHandle > -1 && e.docChanged) {
          let i2 = e.mapping.map(t.activeHandle, -1);
          return Da(e.doc.resolve(i2)) || (i2 = -1), new Os(i2, t.dragging);
        }
        return t;
      }
    };
    function by(n2, e, t, o) {
      if (!n2.editable) return;
      const i2 = et.getState(n2.state);
      if (i2 && !i2.dragging) {
        const s = wy(e.target);
        let r = -1;
        if (s) {
          const { left: a, right: l } = s.getBoundingClientRect();
          e.clientX - a <= t ? r = lc(n2, e, "left", t) : l - e.clientX <= t && (r = lc(n2, e, "right", t));
        }
        if (r != i2.activeHandle) {
          if (!o && r !== -1) {
            const a = n2.state.doc.resolve(r), l = a.node(-1), u = rn.get(l), c2 = a.start(-1);
            if (u.colCount(a.pos - c2) + a.nodeAfter.attrs.colspan - 1 == u.width - 1)
              return;
          }
          Bp(n2, r);
        }
      }
    }
    function ky(n2) {
      if (!n2.editable) return;
      const e = et.getState(n2.state);
      e && e.activeHandle > -1 && !e.dragging && Bp(n2, -1);
    }
    function yy(n2, e, t, o) {
      var i2;
      if (!n2.editable) return false;
      const s = (i2 = n2.dom.ownerDocument.defaultView) != null ? i2 : window, r = et.getState(n2.state);
      if (!r || r.activeHandle == -1 || r.dragging)
        return false;
      const a = n2.state.doc.nodeAt(r.activeHandle), l = jy(n2, r.activeHandle, a.attrs);
      n2.dispatch(
        n2.state.tr.setMeta(et, {
          setDragging: { startX: e.clientX, startWidth: l }
        })
      );
      function u(d) {
        s.removeEventListener("mouseup", u), s.removeEventListener("mousemove", c2);
        const p2 = et.getState(n2.state);
        p2 != null && p2.dragging && (Ey(
          n2,
          p2.activeHandle,
          uc(p2.dragging, d, t)
        ), n2.dispatch(
          n2.state.tr.setMeta(et, { setDragging: null })
        ));
      }
      function c2(d) {
        if (!d.which) return u(d);
        const p2 = et.getState(n2.state);
        if (p2 && p2.dragging) {
          const _ = uc(p2.dragging, d, t);
          cc(
            n2,
            p2.activeHandle,
            _,
            o
          );
        }
      }
      return cc(
        n2,
        r.activeHandle,
        l,
        o
      ), s.addEventListener("mouseup", u), s.addEventListener("mousemove", c2), e.preventDefault(), true;
    }
    function jy(n2, e, { colspan: t, colwidth: o }) {
      const i2 = o && o[o.length - 1];
      if (i2) return i2;
      const s = n2.domAtPos(e);
      let a = s.node.childNodes[s.offset].offsetWidth, l = t;
      if (o)
        for (let u = 0; u < t; u++)
          o[u] && (a -= o[u], l--);
      return a / l;
    }
    function wy(n2) {
      for (; n2 && n2.nodeName != "TD" && n2.nodeName != "TH"; )
        n2 = n2.classList && n2.classList.contains("ProseMirror") ? null : n2.parentNode;
      return n2;
    }
    function lc(n2, e, t, o) {
      const i2 = t == "right" ? -o : o, s = n2.posAtCoords({
        left: e.clientX + i2,
        top: e.clientY
      });
      if (!s) return -1;
      const { pos: r } = s, a = li(n2.state.doc.resolve(r));
      if (!a) return -1;
      if (t == "right") return a.pos;
      const l = rn.get(a.node(-1)), u = a.start(-1), c2 = l.map.indexOf(a.pos - u);
      return c2 % l.width == 0 ? -1 : u + l.map[c2 - 1];
    }
    function uc(n2, e, t) {
      const o = e.clientX - n2.startX;
      return Math.max(t, n2.startWidth + o);
    }
    function Bp(n2, e) {
      n2.dispatch(
        n2.state.tr.setMeta(et, { setHandle: e })
      );
    }
    function Ey(n2, e, t) {
      const o = n2.state.doc.resolve(e), i2 = o.node(-1), s = rn.get(i2), r = o.start(-1), a = s.colCount(o.pos - r) + o.nodeAfter.attrs.colspan - 1, l = n2.state.tr;
      for (let u = 0; u < s.height; u++) {
        const c2 = u * s.width + a;
        if (u && s.map[c2] == s.map[c2 - s.width]) continue;
        const d = s.map[c2], p2 = i2.nodeAt(d).attrs, _ = p2.colspan == 1 ? 0 : a - s.colCount(d);
        if (p2.colwidth && p2.colwidth[_] == t) continue;
        const m = p2.colwidth ? p2.colwidth.slice() : Cy(p2.colspan);
        m[_] = t, l.setNodeMarkup(r + d, null, { ...p2, colwidth: m });
      }
      l.docChanged && n2.dispatch(l);
    }
    function cc(n2, e, t, o) {
      const i2 = n2.state.doc.resolve(e), s = i2.node(-1), r = i2.start(-1), a = rn.get(s).colCount(i2.pos - r) + i2.nodeAfter.attrs.colspan - 1;
      let l = n2.domAtPos(i2.start(-1)).node;
      for (; l && l.nodeName != "TABLE"; )
        l = l.parentNode;
      l && Pa(
        s,
        l.firstChild,
        l,
        o,
        a,
        t
      );
    }
    function Cy(n2) {
      return Array(n2).fill(0);
    }
    function Sy(n2, e) {
      var t;
      const o = [], i2 = n2.doc.resolve(e), s = i2.node(-1);
      if (!s)
        return He.empty;
      const r = rn.get(s), a = i2.start(-1), l = r.colCount(i2.pos - a) + i2.nodeAfter.attrs.colspan - 1;
      for (let u = 0; u < r.height; u++) {
        const c2 = l + u * r.width;
        if ((l == r.width - 1 || r.map[c2] != r.map[c2 + 1]) && (u == 0 || r.map[c2] != r.map[c2 - r.width])) {
          const d = r.map[c2], p2 = a + d + s.nodeAt(d).nodeSize - 1, _ = document.createElement("div");
          _.className = "column-resize-handle", (t = et.getState(n2)) != null && t.dragging && o.push(
            hn.node(
              a + d,
              a + d + s.nodeAt(d).nodeSize,
              {
                class: "column-resize-dragging"
              }
            )
          ), o.push(hn.widget(p2, _));
        }
      }
      return He.create(n2.doc, o);
    }
    function xy({
      allowTableNodeSelection: n2 = false
    } = {}) {
      return new dn({
        key: io,
        // This piece of state is used to remember when a mouse-drag
        // cell-selection is happening, so that it can continue even as
        // transactions (which might move its anchor cell) come in.
        state: {
          init() {
            return null;
          },
          apply(e, t) {
            const o = e.getMeta(io);
            if (o != null) return o == -1 ? null : o;
            if (t == null || !e.docChanged) return t;
            const { deleted: i2, pos: s } = e.mapping.mapResult(t);
            return i2 ? null : s;
          }
        },
        props: {
          decorations: zk,
          handleDOMEvents: {
            mousedown: fy
          },
          createSelectionBetween(e) {
            return io.getState(e.state) != null ? e.state.selection : null;
          },
          handleTripleClick: _y,
          handleKeyDown: py,
          handlePaste: my
        },
        appendTransaction(e, t, o) {
          return Uk(
            o,
            Rp(o, t),
            n2
          );
        }
      });
    }
    function $a(n2, e) {
      return e ? ["width", `${Math.max(e, n2)}px`] : ["min-width", `${n2}px`];
    }
    function dc(n2, e, t, o, i2, s) {
      var r;
      let a = 0, l = true, u = e.firstChild;
      const c2 = n2.firstChild;
      if (c2 !== null)
        for (let d = 0, p2 = 0; d < c2.childCount; d += 1) {
          const { colspan: _, colwidth: m } = c2.child(d).attrs;
          for (let f = 0; f < _; f += 1, p2 += 1) {
            const b = i2 === p2 ? s : m && m[f], h2 = b ? `${b}px` : "";
            if (a += b || o, b || (l = false), u) {
              if (u.style.width !== h2) {
                const [y, C] = $a(o, b);
                u.style.setProperty(y, C);
              }
              u = u.nextSibling;
            } else {
              const y = document.createElement("col"), [C, v] = $a(o, b);
              y.style.setProperty(C, v), e.appendChild(y);
            }
          }
        }
      for (; u; ) {
        const d = u.nextSibling;
        (r = u.parentNode) === null || r === void 0 || r.removeChild(u), u = d;
      }
      l ? (t.style.width = `${a}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${a}px`);
    }
    class Ty {
      constructor(e, t) {
        this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), dc(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, dc(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    function Ay(n2, e, t, o) {
      let i2 = 0, s = true;
      const r = [], a = n2.firstChild;
      if (!a)
        return {};
      for (let d = 0, p2 = 0; d < a.childCount; d += 1) {
        const { colspan: _, colwidth: m } = a.child(d).attrs;
        for (let f = 0; f < _; f += 1, p2 += 1) {
          const b = t === p2 ? o : m && m[f];
          i2 += b || e, b || (s = false);
          const [h2, y] = $a(e, b);
          r.push([
            "col",
            { style: `${h2}: ${y}` }
          ]);
        }
      }
      const l = s ? `${i2}px` : "", u = s ? "" : `${i2}px`;
      return { colgroup: ["colgroup", {}, ...r], tableWidth: l, tableMinWidth: u };
    }
    function pc(n2, e) {
      return n2.createAndFill();
    }
    function Ny(n2) {
      if (n2.cached.tableNodeTypes)
        return n2.cached.tableNodeTypes;
      const e = {};
      return Object.keys(n2.nodes).forEach((t) => {
        const o = n2.nodes[t];
        o.spec.tableRole && (e[o.spec.tableRole] = o);
      }), n2.cached.tableNodeTypes = e, e;
    }
    function Pp(n2, e, t, o, i2) {
      const s = Ny(n2), r = [], a = [];
      for (let u = 0; u < t; u += 1) {
        const c2 = pc(s.cell);
        if (c2 && a.push(c2), o) {
          const d = pc(s.header_cell);
          d && r.push(d);
        }
      }
      const l = [];
      for (let u = 0; u < e; u += 1)
        l.push(s.row.createChecked(null, o && u === 0 ? r : a));
      return s.table.createChecked(null, l);
    }
    function Oy(n2) {
      return n2 instanceof Ve;
    }
    const ps = ({ editor: n2 }) => {
      const { selection: e } = n2.state;
      if (!Oy(e))
        return false;
      let t = 0;
      const o = findParentNodeClosestToPos(e.ranges[0].$from, (s) => s.type.name === "table");
      return o == null || o.node.descendants((s) => {
        if (s.type.name === "table")
          return false;
        ["tableCell", "tableHeader"].includes(s.type.name) && (t += 1);
      }), t === e.ranges.length ? (n2.commands.deleteTable(), true) : false;
    }, $p = Node.create({
      name: "table",
      // @ts-ignore
      addOptions() {
        return {
          HTMLAttributes: {},
          resizable: false,
          handleWidth: 5,
          cellMinWidth: 25,
          // TODO: fix
          View: Ty,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      content: "tableRow+",
      tableRole: "table",
      isolating: true,
      group: "block",
      parseHTML() {
        return [{ tag: "table" }];
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        const { colgroup: t, tableWidth: o, tableMinWidth: i2 } = Ay(n2, this.options.cellMinWidth);
        return [
          "table",
          mergeAttributes(this.options.HTMLAttributes, e, {
            style: o ? `width: ${o}` : `min-width: ${i2}`
          }),
          t,
          ["tbody", 0]
        ];
      },
      addCommands() {
        return {
          insertTable: ({ rows: n2 = 3, cols: e = 3, withHeaderRow: t = true } = {}) => ({ tr: o, dispatch: i2, editor: s }) => {
            const r = Pp(s.schema, n2, e, t);
            if (i2) {
              const a = o.selection.from + 1;
              o.replaceSelectionWith(r).scrollIntoView().setSelection(Ce.near(o.doc.resolve(a)));
            }
            return true;
          },
          addColumnBefore: () => ({ state: n2, dispatch: e }) => Vk(n2, e),
          addColumnAfter: () => ({ state: n2, dispatch: e }) => Wk(n2, e),
          deleteColumn: () => ({ state: n2, dispatch: e }) => Yk(n2, e),
          addRowBefore: () => ({ state: n2, dispatch: e }) => Zk(n2, e),
          addRowAfter: () => ({ state: n2, dispatch: e }) => Xk(n2, e),
          deleteRow: () => ({ state: n2, dispatch: e }) => ey(n2, e),
          deleteTable: () => ({ state: n2, dispatch: e }) => ay(n2, e),
          mergeCells: () => ({ state: n2, dispatch: e }) => ec(n2, e),
          splitCell: () => ({ state: n2, dispatch: e }) => nc(n2, e),
          toggleHeaderColumn: () => ({ state: n2, dispatch: e }) => zi("column")(n2, e),
          toggleHeaderRow: () => ({ state: n2, dispatch: e }) => zi("row")(n2, e),
          toggleHeaderCell: () => ({ state: n2, dispatch: e }) => sy(n2, e),
          mergeOrSplit: () => ({ state: n2, dispatch: e }) => ec(n2, e) ? true : nc(n2, e),
          setCellAttribute: (n2, e) => ({ state: t, dispatch: o }) => oy(n2, e)(t, o),
          goToNextCell: () => ({ state: n2, dispatch: e }) => oc(1)(n2, e),
          goToPreviousCell: () => ({ state: n2, dispatch: e }) => oc(-1)(n2, e),
          fixTables: () => ({ state: n2, dispatch: e }) => (e && Rp(n2), true),
          setCellSelection: (n2) => ({ tr: e, dispatch: t }) => {
            if (t) {
              const o = Ve.create(e.doc, n2.anchorCell, n2.headCell);
              e.setSelection(o);
            }
            return true;
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          Tab: () => this.editor.commands.goToNextCell() ? true : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : false,
          "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
          Backspace: ps,
          "Mod-Backspace": ps,
          Delete: ps,
          "Mod-Delete": ps
        };
      },
      addProseMirrorPlugins() {
        return [
          ...this.options.resizable && this.editor.isEditable ? [
            hy({
              handleWidth: this.options.handleWidth,
              cellMinWidth: this.options.cellMinWidth,
              defaultCellMinWidth: this.options.cellMinWidth,
              View: this.options.View,
              lastColumnResizable: this.options.lastColumnResizable
            })
          ] : [],
          xy({
            allowTableNodeSelection: this.options.allowTableNodeSelection
          })
        ];
      },
      extendNodeSchema(n2) {
        const e = {
          name: n2.name,
          options: n2.options,
          storage: n2.storage
        };
        return {
          tableRole: callOrReturn(getExtensionField(n2, "tableRole", e))
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function _c(n2, e, t, o, i2, s) {
      let r = 0, a = true, l = e.firstChild;
      const u = n2.firstChild;
      for (let c2 = 0, d = 0; c2 < u.childCount; c2 += 1) {
        const { colspan: p2, colwidth: _ } = u.child(c2).attrs;
        for (let m = 0; m < p2; m += 1, d += 1) {
          const f = i2 === d ? s : _ && _[m], b = f ? `${f}px` : "";
          if (r += f || o, f || (a = false), l)
            l.style.width !== b && (l.style.width = b), l = l.nextSibling;
          else {
            const h2 = document.createElement("col");
            h2.className = `col-${d}`, e.appendChild(h2).style.width = b;
          }
        }
      }
      for (; l; ) {
        const c2 = l.nextSibling;
        l.parentNode.removeChild(l), l = c2;
      }
      a ? (t.style.width = `${r}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${r}px`);
    }
    class My {
      constructor(e, t, o) {
        this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), _c(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(
          document.createElement("tbody")
        );
      }
      update(e) {
        return e.type !== this.node.type ? false : (this.node = e, _c(e, this.colgroup, this.table, this.cellMinWidth), true);
      }
      ignoreMutation(e) {
        return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
      }
    }
    const Ry = $p.extend({
      addOptions() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          HTMLAttributes: {},
          resizable: true,
          handleWidth: 5,
          cellMinWidth: 25,
          View: My,
          lastColumnResizable: true,
          allowTableNodeSelection: false
        };
      },
      addCommands() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          insertTable: (e) => ({ editor: t, commands: o, tr: i2, dispatch: s }) => {
            const { rows: r = 3, cols: a = 3, withHeaderRow: l = true } = e || {}, u = Pp(t.schema, r, a, l);
            if (s) {
              const c2 = i2.selection.anchor + 1;
              o.insertContent({
                type: "table-wrapper",
                content: [u.toJSON()]
              }), i2.scrollIntoView().setSelection(
                Ce.near(i2.doc.resolve(c2))
              );
            }
            return true;
          },
          deleteTable: () => ({ state: e, dispatch: t }) => {
            const o = e.selection.$anchor;
            for (let i2 = o.depth; i2 > 0; i2--)
              if (o.node(i2).type.name === "table-wrapper")
                return t && t(
                  e.tr.delete(o.before(i2), o.after(i2)).scrollIntoView()
                ), true;
            return false;
          },
          selectRow: (e) => ({ tr: t, dispatch: o }) => {
            if (o) {
              const i2 = t.doc.resolve(e), s = Ve.rowSelection(i2);
              t.setSelection(s);
            }
            return true;
          },
          selectColumn: (e) => ({ tr: t, dispatch: o }) => {
            if (o) {
              const i2 = t.doc.resolve(e), s = Ve.colSelection(i2);
              t.setSelection(s);
            }
            return true;
          }
        };
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function Iy({
      node: n2,
      types: e
    }) {
      return Array.isArray(e) && e.includes(n2.type) || n2.type === e;
    }
    function _s({
      node: n2,
      types: e
    }) {
      return n2 ? !Iy({ node: n2, types: e }) : false;
    }
    const Ly = Extension.create({
      name: "trailingNode",
      addOptions() {
        return {
          node: "paragraph",
          notAfter: ["paragraph"]
        };
      },
      addProseMirrorPlugins() {
        const n2 = new en(this.name), e = Object.entries(this.editor.schema.nodes).map(([, t]) => t).filter((t) => this.options.notAfter.includes(t.name));
        return [
          new dn({
            key: n2,
            appendTransaction: (t, o, i2) => {
              const { doc: s, tr: r, schema: a } = i2, l = n2.getState(i2), u = s.content.size, c2 = a.nodes[this.options.node];
              if (!(!l || !c2))
                return r.insert(u, c2.create());
            },
            state: {
              init: (t, o) => {
                const i2 = o.tr.doc.lastChild, s = (i2 == null ? void 0 : i2.firstChild) ?? null;
                return _s({ node: i2, types: e }) || _s({ node: s, types: e });
              },
              apply: (t, o) => {
                var r;
                if (!t.docChanged) return o;
                const i2 = t.doc.lastChild, s = ((r = t.doc.lastChild) == null ? void 0 : r.firstChild) ?? null;
                return _s({ node: i2, types: e }) || _s({ node: s, types: e });
              }
            }
          })
        ];
      }
    });
    var Tn = [];
    for (var oa = 0; oa < 256; ++oa)
      Tn.push((oa + 256).toString(16).slice(1));
    function Dy(n2, e = 0) {
      return (Tn[n2[e + 0]] + Tn[n2[e + 1]] + Tn[n2[e + 2]] + Tn[n2[e + 3]] + "-" + Tn[n2[e + 4]] + Tn[n2[e + 5]] + "-" + Tn[n2[e + 6]] + Tn[n2[e + 7]] + "-" + Tn[n2[e + 8]] + Tn[n2[e + 9]] + "-" + Tn[n2[e + 10]] + Tn[n2[e + 11]] + Tn[n2[e + 12]] + Tn[n2[e + 13]] + Tn[n2[e + 14]] + Tn[n2[e + 15]]).toLowerCase();
    }
    var ms, By = new Uint8Array(16);
    function Py() {
      if (!ms && (ms = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !ms))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return ms(By);
    }
    var $y = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const mc = {
      randomUUID: $y
    };
    function zy(n2, e, t) {
      if (mc.randomUUID && !n2)
        return mc.randomUUID();
      n2 = n2 || {};
      var o = n2.random || (n2.rng || Py)();
      return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, Dy(o);
    }
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Fy = Node.create({
      name: "uniqueID",
      priority: 1e4,
      addOptions: () => ({
        attributeName: "data-id",
        types: ["heading"],
        enableRender: false,
        generateId: () => zy()
      }),
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              [this.options.attributeName]: {
                default: null,
                parseHTML: (n2) => n2.getAttribute(this.options.attributeName),
                renderHTML: (n2) => this.options.enableRender ? {
                  [this.options.attributeName]: n2[this.options.attributeName]
                } : {}
              }
            }
          }
        ];
      },
      addProseMirrorPlugins() {
        return [
          new dn({
            key: new en(this.name),
            props: {
              transformPastedHTML: (n2) => {
                const e = new DOMParser().parseFromString(n2, "text/html"), t = this.options.attributeName;
                return e.querySelectorAll(`[${t}]`).forEach((o) => {
                  o.setAttribute(t, this.options.generateId());
                }), e.body.innerHTML;
              }
            },
            appendTransaction: (n2, e, t) => {
              const o = t.tr, i2 = this.options.attributeName;
              let s = false;
              return t.doc.descendants((r, a) => {
                r.isText || !r.attrs[i2] && this.options.types.includes(r.type.name) && (o.setNodeMarkup(a, void 0, {
                  ...r.attrs,
                  [i2]: this.options.generateId()
                }), s = true);
              }), s ? o : null;
            }
          })
        ];
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function Hy(n2) {
      var e;
      const { char: t, allowSpaces: o, allowToIncludeChar: i2, allowedPrefixes: s, startOfLine: r, $position: a } = n2, l = o && !i2, u = escapeForRegEx(t), c2 = new RegExp(`\\s${u}$`), d = r ? "^" : "", p2 = i2 ? "" : u, _ = l ? new RegExp(`${d}${u}.*?(?=\\s${p2}|$)`, "gm") : new RegExp(`${d}(?:^)?${u}[^\\s${p2}]*`, "gm"), m = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
      if (!m)
        return null;
      const f = a.pos - m.length, b = Array.from(m.matchAll(_)).pop();
      if (!b || b.input === void 0 || b.index === void 0)
        return null;
      const h2 = b.input.slice(Math.max(0, b.index - 1), b.index), y = new RegExp(`^[${s == null ? void 0 : s.join("")}\0]?$`).test(h2);
      if (s !== null && !y)
        return null;
      const C = f + b.index;
      let v = C + b[0].length;
      return l && c2.test(m.slice(v - 1, v + 1)) && (b[0] += " ", v += 1), C < a.pos && v >= a.pos ? {
        range: {
          from: C,
          to: v
        },
        query: b[0].slice(t.length),
        text: b[0]
      } : null;
    }
    const Uy = new en("suggestion");
    function xl({ pluginKey: n2 = Uy, editor: e, char: t = "@", allowSpaces: o = false, allowToIncludeChar: i2 = false, allowedPrefixes: s = [" "], startOfLine: r = false, decorationTag: a = "span", decorationClass: l = "suggestion", command: u = () => null, items: c2 = () => [], render: d = () => ({}), allow: p2 = () => true, findSuggestionMatch: _ = Hy }) {
      let m;
      const f = d == null ? void 0 : d(), b = new dn({
        key: n2,
        view() {
          return {
            update: async (h2, y) => {
              var C, v, x, S, F, Y, q;
              const K = (C = this.key) === null || C === void 0 ? void 0 : C.getState(y), ie2 = (v = this.key) === null || v === void 0 ? void 0 : v.getState(h2.state), ce = K.active && ie2.active && K.range.from !== ie2.range.from, ve = !K.active && ie2.active, he = K.active && !ie2.active, de = !ve && !he && K.query !== ie2.query, pe = ve || ce && de, N = de || ce, L = he || ce && de;
              if (!pe && !N && !L)
                return;
              const V = L && !pe ? K : ie2, te = h2.dom.querySelector(`[data-decoration-id="${V.decorationId}"]`);
              m = {
                editor: e,
                range: V.range,
                query: V.query,
                text: V.text,
                items: [],
                command: (ae) => u({
                  editor: e,
                  range: V.range,
                  props: ae
                }),
                decorationNode: te,
                // virtual node for popper.js or tippy.js
                // this can be used for building popups without a DOM node
                clientRect: te ? () => {
                  var ae;
                  const { decorationId: ye } = (ae = this.key) === null || ae === void 0 ? void 0 : ae.getState(e.state), Pe = h2.dom.querySelector(`[data-decoration-id="${ye}"]`);
                  return (Pe == null ? void 0 : Pe.getBoundingClientRect()) || null;
                } : null
              }, pe && ((x = f == null ? void 0 : f.onBeforeStart) === null || x === void 0 || x.call(f, m)), N && ((S = f == null ? void 0 : f.onBeforeUpdate) === null || S === void 0 || S.call(f, m)), (N || pe) && (m.items = await c2({
                editor: e,
                query: V.query
              })), L && ((F = f == null ? void 0 : f.onExit) === null || F === void 0 || F.call(f, m)), N && ((Y = f == null ? void 0 : f.onUpdate) === null || Y === void 0 || Y.call(f, m)), pe && ((q = f == null ? void 0 : f.onStart) === null || q === void 0 || q.call(f, m));
            },
            destroy: () => {
              var h2;
              m && ((h2 = f == null ? void 0 : f.onExit) === null || h2 === void 0 || h2.call(f, m));
            }
          };
        },
        state: {
          // Initialize the plugin's internal state.
          init() {
            return {
              active: false,
              range: {
                from: 0,
                to: 0
              },
              query: null,
              text: null,
              composing: false
            };
          },
          // Apply changes to the plugin state from a view transaction.
          apply(h2, y, C, v) {
            const { isEditable: x } = e, { composing: S } = e.view, { selection: F } = h2, { empty: Y, from: q } = F, K = { ...y };
            if (K.composing = S, x && (Y || e.view.composing)) {
              (q < y.range.from || q > y.range.to) && !S && !y.composing && (K.active = false);
              const ie2 = _({
                char: t,
                allowSpaces: o,
                allowToIncludeChar: i2,
                allowedPrefixes: s,
                startOfLine: r,
                $position: F.$from
              }), ce = `id_${Math.floor(Math.random() * 4294967295)}`;
              ie2 && p2({
                editor: e,
                state: v,
                range: ie2.range,
                isActive: y.active
              }) ? (K.active = true, K.decorationId = y.decorationId ? y.decorationId : ce, K.range = ie2.range, K.query = ie2.query, K.text = ie2.text) : K.active = false;
            } else
              K.active = false;
            return K.active || (K.decorationId = null, K.range = { from: 0, to: 0 }, K.query = null, K.text = null), K;
          }
        },
        props: {
          // Call the keydown hook if suggestion is active.
          handleKeyDown(h2, y) {
            var C;
            const { active: v, range: x } = b.getState(h2.state);
            return v && ((C = f == null ? void 0 : f.onKeyDown) === null || C === void 0 ? void 0 : C.call(f, { view: h2, event: y, range: x })) || false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(h2) {
            const { active: y, range: C, decorationId: v } = b.getState(h2);
            return y ? He.create(h2.doc, [
              hn.inline(C.from, C.to, {
                nodeName: a,
                class: l,
                "data-decoration-id": v
              })
            ]) : null;
          }
        }
      });
      return b;
    }
    const qy = Extension.create({
      name: "slash-command",
      addOptions() {
        return {
          suggestion: {
            char: "/",
            command: ({
              editor: n2,
              range: e,
              props: t
            }) => {
              t.command({ editor: n2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          xl({
            pluginKey: new en("slash-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), Ky = Extension.create({
      name: "colon-command",
      addOptions() {
        return {
          suggestion: {
            char: ":",
            command: ({
              editor: n2,
              range: e,
              props: t
            }) => {
              t.command({ editor: n2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          xl({
            pluginKey: new en("colon-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), Vy = Extension.create({
      name: "slash-zh-command",
      addOptions() {
        return {
          suggestion: {
            char: "",
            command: ({
              editor: n2,
              range: e,
              props: t
            }) => {
              t.command({ editor: n2, range: e });
            }
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          xl({
            pluginKey: new en("slash-zh-command"),
            editor: this.editor,
            ...this.options.suggestion
          })
        ];
      }
    }), Wy = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2;
        return (t, o) => (openBlock(), createBlock(unref(Jt), mergeProps(e, { class: "o-blockquote-view" }), {
          default: withCtx(() => [
            createBaseVNode("blockquote", null, [
              createVNode(unref(Yt))
            ])
          ]),
          _: 1
        }, 16));
      }
    }), Gy = Bd.extend({
      draggable: true,
      addNodeView() {
        return wt(Wy);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const Yy = Node.create({
      name: "callout",
      group: "block",
      content: "block+",
      draggable: true,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return {
          icon: {
            default: ""
          },
          borderColor: {
            default: "#dddddd"
          },
          borderColorDark: {
            default: "#333333"
          },
          backColor: {
            default: "#eeeeee"
          },
          backColorDark: {
            default: "rgba(101, 117, 133, 0.16)"
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: 'div[data-type="callout"]'
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return [
          "div",
          mergeAttributes(n2, { "data-type": "callout" }),
          0
        ];
      },
      addCommands() {
        return {
          setCallout: () => ({ commands: n2 }) => n2.wrapIn(this.name),
          toggleCallout: () => ({ commands: n2 }) => n2.toggleWrap(this.name),
          unsetCallout: () => ({ commands: n2 }) => n2.lift(this.name)
        };
      }
    }), Jy = { class: "callout-container" }, Zy = { class: "callout-icon" }, Xy = { class: "callout-content" }, Qy = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, { theme: t } = xr(), { isEditable: o } = Le(), i2 = ref(false), s = ref(false), r = ref({}), a = ref(null), l = computed(() => {
          const { selection: v } = e.editor.view.state, x = v.from, S = e.getPos(), F = S + e.node.nodeSize;
          return x >= S && x <= F;
        }), u = computed({
          get() {
            return e.node.attrs.backColor;
          },
          set(v) {
            e.updateAttributes({ backColor: v });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.backColorDark;
          },
          set(v) {
            e.updateAttributes({ backColorDark: v });
          }
        }), d = computed({
          get() {
            return e.node.attrs.borderColor;
          },
          set(v) {
            e.updateAttributes({ borderColor: v });
          }
        }), p2 = computed({
          get() {
            return e.node.attrs.borderColorDark;
          },
          set(v) {
            e.updateAttributes({ borderColorDark: v });
          }
        }), _ = computed(() => t.value === "dark" ? c2.value : u.value), m = computed(() => t.value === "dark" ? p2.value : d.value);
        function f(v) {
          e.updateAttributes({ icon: v });
        }
        function b(v) {
          switch (i2.value = false, v.value) {
            case "palette":
              y(true);
              break;
          }
        }
        function h2(v) {
          i2.value = true, r.value = v;
        }
        function y(v) {
          s.value = v;
        }
        function C(v, x) {
          var S;
          switch (v) {
            case "backColor":
              u.value = x;
              break;
            case "foreColor":
              d.value = x;
              break;
            case "icon":
              f(x.emoji), (S = a.value) == null || S.setShow(false);
              break;
          }
        }
        return watch(l, (v) => {
          y(v);
        }), (v, x) => (openBlock(), createBlock(unref(Jt), mergeProps(e, {
          class: "o-callout-view",
          style: `--callout-border-color: ${m.value}; --callout-back-color: ${_.value}`,
          onContextmenu: withModifiers(h2, ["prevent"])
        }), {
          default: withCtx(() => [
            createBaseVNode("div", Jy, [
              createVNode(unref(We), {
                ref_key: "iconPopover",
                ref: a,
                placement: "bottom-start",
                trigger: "click",
                offset: [0, 0],
                disable: !unref(o)
              }, {
                trigger: withCtx(() => [
                  createBaseVNode("div", Zy, toDisplayString(v.node.attrs.icon), 1)
                ]),
                default: withCtx(() => [
                  createVNode(unref(wl), {
                    items: unref(jl),
                    onSelect: x[0] || (x[0] = (S) => C("icon", S)),
                    "enable-search": ""
                  }, null, 8, ["items"])
                ]),
                _: 1
              }, 8, ["disable"]),
              createBaseVNode("div", Xy, [
                createVNode(unref(Yt))
              ]),
              unref(o) ? (openBlock(), createBlock(unref(bl), {
                key: 0,
                modelValue: i2.value,
                "onUpdate:modelValue": x[1] || (x[1] = (S) => i2.value = S),
                event: r.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(ri), mergeProps(e, { onAction: b }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), ej = Yy.extend({
      addNodeView() {
        return wt(Qy);
      }
    });
    function nj(n2) {
      return n2 && n2.__esModule && Object.prototype.hasOwnProperty.call(n2, "default") ? n2.default : n2;
    }
    function zp(n2) {
      return n2 instanceof Map ? n2.clear = n2.delete = n2.set = function() {
        throw new Error("map is read-only");
      } : n2 instanceof Set && (n2.add = n2.clear = n2.delete = function() {
        throw new Error("set is read-only");
      }), Object.freeze(n2), Object.getOwnPropertyNames(n2).forEach((e) => {
        const t = n2[e], o = typeof t;
        (o === "object" || o === "function") && !Object.isFrozen(t) && zp(t);
      }), n2;
    }
    class fc {
      /**
       * @param {CompiledMode} mode
       */
      constructor(e) {
        e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function Fp(n2) {
      return n2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function uo(n2, ...e) {
      const t = /* @__PURE__ */ Object.create(null);
      for (const o in n2)
        t[o] = n2[o];
      return e.forEach(function(o) {
        for (const i2 in o)
          t[i2] = o[i2];
      }), /** @type {T} */
      t;
    }
    const tj = "</span>", gc = (n2) => !!n2.scope, oj = (n2, { prefix: e }) => {
      if (n2.startsWith("language:"))
        return n2.replace("language:", "language-");
      if (n2.includes(".")) {
        const t = n2.split(".");
        return [
          `${e}${t.shift()}`,
          ...t.map((o, i2) => `${o}${"_".repeat(i2 + 1)}`)
        ].join(" ");
      }
      return `${e}${n2}`;
    };
    class ij {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(e, t) {
        this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(e) {
        this.buffer += Fp(e);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(e) {
        if (!gc(e)) return;
        const t = oj(
          e.scope,
          { prefix: this.classPrefix }
        );
        this.span(t);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(e) {
        gc(e) && (this.buffer += tj);
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(e) {
        this.buffer += `<span class="${e}">`;
      }
    }
    const hc = (n2 = {}) => {
      const e = { children: [] };
      return Object.assign(e, n2), e;
    };
    class Tl {
      constructor() {
        this.rootNode = hc(), this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(e) {
        this.top.children.push(e);
      }
      /** @param {string} scope */
      openNode(e) {
        const t = hc({ scope: e });
        this.add(t), this.stack.push(t);
      }
      closeNode() {
        if (this.stack.length > 1)
          return this.stack.pop();
      }
      closeAllNodes() {
        for (; this.closeNode(); ) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(e) {
        return this.constructor._walk(e, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(e, t) {
        return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((o) => this._walk(e, o)), e.closeNode(t)), e;
      }
      /**
       * @param {Node} node
       */
      static _collapse(e) {
        typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
          Tl._collapse(t);
        }));
      }
    }
    class sj extends Tl {
      /**
       * @param {*} options
       */
      constructor(e) {
        super(), this.options = e;
      }
      /**
       * @param {string} text
       */
      addText(e) {
        e !== "" && this.add(e);
      }
      /** @param {string} scope */
      startScope(e) {
        this.openNode(e);
      }
      endScope() {
        this.closeNode();
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      __addSublanguage(e, t) {
        const o = e.root;
        t && (o.scope = `language:${t}`), this.add(o);
      }
      toHTML() {
        return new ij(this, this.options).value();
      }
      finalize() {
        return this.closeAllNodes(), true;
      }
    }
    function Fi(n2) {
      return n2 ? typeof n2 == "string" ? n2 : n2.source : null;
    }
    function Hp(n2) {
      return Bo("(?=", n2, ")");
    }
    function rj(n2) {
      return Bo("(?:", n2, ")*");
    }
    function aj(n2) {
      return Bo("(?:", n2, ")?");
    }
    function Bo(...n2) {
      return n2.map((t) => Fi(t)).join("");
    }
    function lj(n2) {
      const e = n2[n2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (n2.splice(n2.length - 1, 1), e) : {};
    }
    function Al(...n2) {
      return "(" + (lj(n2).capture ? "" : "?:") + n2.map((o) => Fi(o)).join("|") + ")";
    }
    function Up(n2) {
      return new RegExp(n2.toString() + "|").exec("").length - 1;
    }
    function uj(n2, e) {
      const t = n2 && n2.exec(e);
      return t && t.index === 0;
    }
    const cj = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function Nl(n2, { joinWith: e }) {
      let t = 0;
      return n2.map((o) => {
        t += 1;
        const i2 = t;
        let s = Fi(o), r = "";
        for (; s.length > 0; ) {
          const a = cj.exec(s);
          if (!a) {
            r += s;
            break;
          }
          r += s.substring(0, a.index), s = s.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? r += "\\" + String(Number(a[1]) + i2) : (r += a[0], a[0] === "(" && t++);
        }
        return r;
      }).map((o) => `(${o})`).join(e);
    }
    const dj = /\b\B/, qp = "[a-zA-Z]\\w*", Ol = "[a-zA-Z_]\\w*", Kp = "\\b\\d+(\\.\\d+)?", Vp = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Wp = "\\b(0b[01]+)", pj = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", _j = (n2 = {}) => {
      const e = /^#![ ]*\//;
      return n2.binary && (n2.begin = Bo(
        e,
        /.*\b/,
        n2.binary,
        /\b.*/
      )), uo({
        scope: "meta",
        begin: e,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (t, o) => {
          t.index !== 0 && o.ignoreMatch();
        }
      }, n2);
    }, Hi = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    }, mj = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [Hi]
    }, fj = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [Hi]
    }, gj = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    }, Nr = function(n2, e, t = {}) {
      const o = uo(
        {
          scope: "comment",
          begin: n2,
          end: e,
          contains: []
        },
        t
      );
      o.contains.push({
        scope: "doctag",
        // hack to avoid the space from being included. the space is necessary to
        // match here to prevent the plain text rule below from gobbling up doctags
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const i2 = Al(
        // list of common 1 and 2 letter words in English
        "I",
        "a",
        "is",
        "so",
        "us",
        "to",
        "at",
        "if",
        "in",
        "it",
        "on",
        // note: this is not an exhaustive list of contractions, just popular ones
        /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
        // contractions - can't we'd they're let's, etc
        /[A-Za-z]+[-][a-z]+/,
        // `no-way`, etc.
        /[A-Za-z][a-z]{2,}/
        // allow capitalized words at beginning of sentences
      );
      return o.contains.push(
        {
          // TODO: how to include ", (, ) without breaking grammars that use these for
          // comment delimiters?
          // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
          // ---
          // this tries to find sequences of 3 english words in a row (without any
          // "programming" type syntax) this gives us a strong signal that we've
          // TRULY found a comment - vs perhaps scanning with the wrong language.
          // It's possible to find something that LOOKS like the start of the
          // comment - but then if there is no readable text - good chance it is a
          // false match and not a comment.
          //
          // for a visual example please see:
          // https://github.com/highlightjs/highlight.js/issues/2827
          begin: Bo(
            /[ ]+/,
            // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
            "(",
            i2,
            /[.]?[:]?([.][ ]|[ ])/,
            "){3}"
          )
          // look for 3 words in a row
        }
      ), o;
    }, hj = Nr("//", "$"), vj = Nr("/\\*", "\\*/"), bj = Nr("#", "$"), kj = {
      scope: "number",
      begin: Kp,
      relevance: 0
    }, yj = {
      scope: "number",
      begin: Vp,
      relevance: 0
    }, jj = {
      scope: "number",
      begin: Wp,
      relevance: 0
    }, wj = {
      scope: "regexp",
      begin: /\/(?=[^/\n]*\/)/,
      end: /\/[gimuy]*/,
      contains: [
        Hi,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [Hi]
        }
      ]
    }, Ej = {
      scope: "title",
      begin: qp,
      relevance: 0
    }, Cj = {
      scope: "title",
      begin: Ol,
      relevance: 0
    }, Sj = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + Ol,
      relevance: 0
    }, xj = function(n2) {
      return Object.assign(
        n2,
        {
          /** @type {ModeCallback} */
          "on:begin": (e, t) => {
            t.data._beginMatch = e[1];
          },
          /** @type {ModeCallback} */
          "on:end": (e, t) => {
            t.data._beginMatch !== e[1] && t.ignoreMatch();
          }
        }
      );
    };
    var fs = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      APOS_STRING_MODE: mj,
      BACKSLASH_ESCAPE: Hi,
      BINARY_NUMBER_MODE: jj,
      BINARY_NUMBER_RE: Wp,
      COMMENT: Nr,
      C_BLOCK_COMMENT_MODE: vj,
      C_LINE_COMMENT_MODE: hj,
      C_NUMBER_MODE: yj,
      C_NUMBER_RE: Vp,
      END_SAME_AS_BEGIN: xj,
      HASH_COMMENT_MODE: bj,
      IDENT_RE: qp,
      MATCH_NOTHING_RE: dj,
      METHOD_GUARD: Sj,
      NUMBER_MODE: kj,
      NUMBER_RE: Kp,
      PHRASAL_WORDS_MODE: gj,
      QUOTE_STRING_MODE: fj,
      REGEXP_MODE: wj,
      RE_STARTERS_RE: pj,
      SHEBANG: _j,
      TITLE_MODE: Ej,
      UNDERSCORE_IDENT_RE: Ol,
      UNDERSCORE_TITLE_MODE: Cj
    });
    function Tj(n2, e) {
      n2.input[n2.index - 1] === "." && e.ignoreMatch();
    }
    function Aj(n2, e) {
      n2.className !== void 0 && (n2.scope = n2.className, delete n2.className);
    }
    function Nj(n2, e) {
      e && n2.beginKeywords && (n2.begin = "\\b(" + n2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n2.__beforeBegin = Tj, n2.keywords = n2.keywords || n2.beginKeywords, delete n2.beginKeywords, n2.relevance === void 0 && (n2.relevance = 0));
    }
    function Oj(n2, e) {
      Array.isArray(n2.illegal) && (n2.illegal = Al(...n2.illegal));
    }
    function Mj(n2, e) {
      if (n2.match) {
        if (n2.begin || n2.end) throw new Error("begin & end are not supported with match");
        n2.begin = n2.match, delete n2.match;
      }
    }
    function Rj(n2, e) {
      n2.relevance === void 0 && (n2.relevance = 1);
    }
    const Ij = (n2, e) => {
      if (!n2.beforeMatch) return;
      if (n2.starts) throw new Error("beforeMatch cannot be used with starts");
      const t = Object.assign({}, n2);
      Object.keys(n2).forEach((o) => {
        delete n2[o];
      }), n2.keywords = t.keywords, n2.begin = Bo(t.beforeMatch, Hp(t.begin)), n2.starts = {
        relevance: 0,
        contains: [
          Object.assign(t, { endsParent: true })
        ]
      }, n2.relevance = 0, delete t.beforeMatch;
    }, Lj = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ], Dj = "keyword";
    function Gp(n2, e, t = Dj) {
      const o = /* @__PURE__ */ Object.create(null);
      return typeof n2 == "string" ? i2(t, n2.split(" ")) : Array.isArray(n2) ? i2(t, n2) : Object.keys(n2).forEach(function(s) {
        Object.assign(
          o,
          Gp(n2[s], e, s)
        );
      }), o;
      function i2(s, r) {
        e && (r = r.map((a) => a.toLowerCase())), r.forEach(function(a) {
          const l = a.split("|");
          o[l[0]] = [s, Bj(l[0], l[1])];
        });
      }
    }
    function Bj(n2, e) {
      return e ? Number(e) : Pj(n2) ? 0 : 1;
    }
    function Pj(n2) {
      return Lj.includes(n2.toLowerCase());
    }
    const vc = {}, No = (n2) => {
      console.error(n2);
    }, bc = (n2, ...e) => {
      console.log(`WARN: ${n2}`, ...e);
    }, zo = (n2, e) => {
      vc[`${n2}/${e}`] || (console.log(`Deprecated as of ${n2}. ${e}`), vc[`${n2}/${e}`] = true);
    }, Vs = new Error();
    function Yp(n2, e, { key: t }) {
      let o = 0;
      const i2 = n2[t], s = {}, r = {};
      for (let a = 1; a <= e.length; a++)
        r[a + o] = i2[a], s[a + o] = true, o += Up(e[a - 1]);
      n2[t] = r, n2[t]._emit = s, n2[t]._multi = true;
    }
    function $j(n2) {
      if (Array.isArray(n2.begin)) {
        if (n2.skip || n2.excludeBegin || n2.returnBegin)
          throw No("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Vs;
        if (typeof n2.beginScope != "object" || n2.beginScope === null)
          throw No("beginScope must be object"), Vs;
        Yp(n2, n2.begin, { key: "beginScope" }), n2.begin = Nl(n2.begin, { joinWith: "" });
      }
    }
    function zj(n2) {
      if (Array.isArray(n2.end)) {
        if (n2.skip || n2.excludeEnd || n2.returnEnd)
          throw No("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Vs;
        if (typeof n2.endScope != "object" || n2.endScope === null)
          throw No("endScope must be object"), Vs;
        Yp(n2, n2.end, { key: "endScope" }), n2.end = Nl(n2.end, { joinWith: "" });
      }
    }
    function Fj(n2) {
      n2.scope && typeof n2.scope == "object" && n2.scope !== null && (n2.beginScope = n2.scope, delete n2.scope);
    }
    function Hj(n2) {
      Fj(n2), typeof n2.beginScope == "string" && (n2.beginScope = { _wrap: n2.beginScope }), typeof n2.endScope == "string" && (n2.endScope = { _wrap: n2.endScope }), $j(n2), zj(n2);
    }
    function Uj(n2) {
      function e(r, a) {
        return new RegExp(
          Fi(r),
          "m" + (n2.case_insensitive ? "i" : "") + (n2.unicodeRegex ? "u" : "") + (a ? "g" : "")
        );
      }
      class t {
        constructor() {
          this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += Up(a) + 1;
        }
        compile() {
          this.regexes.length === 0 && (this.exec = () => null);
          const a = this.regexes.map((l) => l[1]);
          this.matcherRe = e(Nl(a, { joinWith: "|" }), true), this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(a) {
          this.matcherRe.lastIndex = this.lastIndex;
          const l = this.matcherRe.exec(a);
          if (!l)
            return null;
          const u = l.findIndex((d, p2) => p2 > 0 && d !== void 0), c2 = this.matchIndexes[u];
          return l.splice(0, u), Object.assign(l, c2);
        }
      }
      class o {
        constructor() {
          this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(a) {
          if (this.multiRegexes[a]) return this.multiRegexes[a];
          const l = new t();
          return this.rules.slice(a).forEach(([u, c2]) => l.addRule(u, c2)), l.compile(), this.multiRegexes[a] = l, l;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(a, l) {
          this.rules.push([a, l]), l.type === "begin" && this.count++;
        }
        /** @param {string} s */
        exec(a) {
          const l = this.getMatcher(this.regexIndex);
          l.lastIndex = this.lastIndex;
          let u = l.exec(a);
          if (this.resumingScanAtSamePosition() && !(u && u.index === this.lastIndex)) {
            const c2 = this.getMatcher(0);
            c2.lastIndex = this.lastIndex + 1, u = c2.exec(a);
          }
          return u && (this.regexIndex += u.position + 1, this.regexIndex === this.count && this.considerAll()), u;
        }
      }
      function i2(r) {
        const a = new o();
        return r.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), r.terminatorEnd && a.addRule(r.terminatorEnd, { type: "end" }), r.illegal && a.addRule(r.illegal, { type: "illegal" }), a;
      }
      function s(r, a) {
        const l = (
          /** @type CompiledMode */
          r
        );
        if (r.isCompiled) return l;
        [
          Aj,
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          Mj,
          Hj,
          Ij
        ].forEach((c2) => c2(r, a)), n2.compilerExtensions.forEach((c2) => c2(r, a)), r.__beforeBegin = null, [
          Nj,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          Oj,
          // default to 1 relevance if not specified
          Rj
        ].forEach((c2) => c2(r, a)), r.isCompiled = true;
        let u = null;
        return typeof r.keywords == "object" && r.keywords.$pattern && (r.keywords = Object.assign({}, r.keywords), u = r.keywords.$pattern, delete r.keywords.$pattern), u = u || /\w+/, r.keywords && (r.keywords = Gp(r.keywords, n2.case_insensitive)), l.keywordPatternRe = e(u, true), a && (r.begin || (r.begin = /\B|\b/), l.beginRe = e(l.begin), !r.end && !r.endsWithParent && (r.end = /\B|\b/), r.end && (l.endRe = e(l.end)), l.terminatorEnd = Fi(l.end) || "", r.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (r.end ? "|" : "") + a.terminatorEnd)), r.illegal && (l.illegalRe = e(
          /** @type {RegExp | string} */
          r.illegal
        )), r.contains || (r.contains = []), r.contains = [].concat(...r.contains.map(function(c2) {
          return qj(c2 === "self" ? r : c2);
        })), r.contains.forEach(function(c2) {
          s(
            /** @type Mode */
            c2,
            l
          );
        }), r.starts && s(r.starts, a), l.matcher = i2(l), l;
      }
      if (n2.compilerExtensions || (n2.compilerExtensions = []), n2.contains && n2.contains.includes("self"))
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      return n2.classNameAliases = uo(n2.classNameAliases || {}), s(
        /** @type Mode */
        n2
      );
    }
    function Jp(n2) {
      return n2 ? n2.endsWithParent || Jp(n2.starts) : false;
    }
    function qj(n2) {
      return n2.variants && !n2.cachedVariants && (n2.cachedVariants = n2.variants.map(function(e) {
        return uo(n2, { variants: null }, e);
      })), n2.cachedVariants ? n2.cachedVariants : Jp(n2) ? uo(n2, { starts: n2.starts ? uo(n2.starts) : null }) : Object.isFrozen(n2) ? uo(n2) : n2;
    }
    var Kj = "11.10.0";
    class Vj extends Error {
      constructor(e, t) {
        super(e), this.name = "HTMLInjectionError", this.html = t;
      }
    }
    const ia = Fp, kc = uo, yc = Symbol("nomatch"), Wj = 7, Zp = function(n2) {
      const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), o = [];
      let i2 = true;
      const s = "Could not find the language '{}', did you forget to load/include a language module?", r = { disableAutodetect: true, name: "Plain text", contains: [] };
      let a = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: sj
      };
      function l(N) {
        return a.noHighlightRe.test(N);
      }
      function u(N) {
        let L = N.className + " ";
        L += N.parentNode ? N.parentNode.className : "";
        const V = a.languageDetectRe.exec(L);
        if (V) {
          const te = q(V[1]);
          return te || (bc(s.replace("{}", V[1])), bc("Falling back to no-highlight mode for this block.", N)), te ? V[1] : "no-highlight";
        }
        return L.split(/\s+/).find((te) => l(te) || q(te));
      }
      function c2(N, L, V) {
        let te = "", ae = "";
        typeof L == "object" ? (te = N, V = L.ignoreIllegals, ae = L.language) : (zo("10.7.0", "highlight(lang, code, ...args) has been deprecated."), zo("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), ae = N, te = L), V === void 0 && (V = true);
        const ye = {
          code: te,
          language: ae
        };
        de("before:highlight", ye);
        const Pe = ye.result ? ye.result : d(ye.language, ye.code, V);
        return Pe.code = ye.code, de("after:highlight", Pe), Pe;
      }
      function d(N, L, V, te) {
        const ae = /* @__PURE__ */ Object.create(null);
        function ye(P, J) {
          return P.keywords[J];
        }
        function Pe() {
          if (!se.keywords) {
            Ue.addText(Me);
            return;
          }
          let P = 0;
          se.keywordPatternRe.lastIndex = 0;
          let J = se.keywordPatternRe.exec(Me), be = "";
          for (; J; ) {
            be += Me.substring(P, J.index);
            const Re = ge.case_insensitive ? J[0].toLowerCase() : J[0], pn = ye(se, Re);
            if (pn) {
              const [Jn, ui] = pn;
              if (Ue.addText(be), be = "", ae[Re] = (ae[Re] || 0) + 1, ae[Re] <= Wj && (Dn += ui), Jn.startsWith("_"))
                be += J[0];
              else {
                const A = ge.classNameAliases[Jn] || Jn;
                Ge(J[0], A);
              }
            } else
              be += J[0];
            P = se.keywordPatternRe.lastIndex, J = se.keywordPatternRe.exec(Me);
          }
          be += Me.substring(P), Ue.addText(be);
        }
        function vn() {
          if (Me === "") return;
          let P = null;
          if (typeof se.subLanguage == "string") {
            if (!e[se.subLanguage]) {
              Ue.addText(Me);
              return;
            }
            P = d(se.subLanguage, Me, true, Ln[se.subLanguage]), Ln[se.subLanguage] = /** @type {CompiledMode} */
            P._top;
          } else
            P = _(Me, se.subLanguage.length ? se.subLanguage : null);
          se.relevance > 0 && (Dn += P.relevance), Ue.__addSublanguage(P._emitter, P.language);
        }
        function $e() {
          se.subLanguage != null ? vn() : Pe(), Me = "";
        }
        function Ge(P, J) {
          P !== "" && (Ue.startScope(J), Ue.addText(P), Ue.endScope());
        }
        function Gn(P, J) {
          let be = 1;
          const Re = J.length - 1;
          for (; be <= Re; ) {
            if (!P._emit[be]) {
              be++;
              continue;
            }
            const pn = ge.classNameAliases[P[be]] || P[be], Jn = J[be];
            pn ? Ge(Jn, pn) : (Me = Jn, Pe(), Me = ""), be++;
          }
        }
        function Cn(P, J) {
          return P.scope && typeof P.scope == "string" && Ue.openNode(ge.classNameAliases[P.scope] || P.scope), P.beginScope && (P.beginScope._wrap ? (Ge(Me, ge.classNameAliases[P.beginScope._wrap] || P.beginScope._wrap), Me = "") : P.beginScope._multi && (Gn(P.beginScope, J), Me = "")), se = Object.create(P, { parent: { value: se } }), se;
        }
        function ot(P, J, be) {
          let Re = uj(P.endRe, be);
          if (Re) {
            if (P["on:end"]) {
              const pn = new fc(P);
              P["on:end"](J, pn), pn.isMatchIgnored && (Re = false);
            }
            if (Re) {
              for (; P.endsParent && P.parent; )
                P = P.parent;
              return P;
            }
          }
          if (P.endsWithParent)
            return ot(P.parent, J, be);
        }
        function Sn(P) {
          return se.matcher.regexIndex === 0 ? (Me += P[0], 1) : (Bn = true, 0);
        }
        function it(P) {
          const J = P[0], be = P.rule, Re = new fc(be), pn = [be.__beforeBegin, be["on:begin"]];
          for (const Jn of pn)
            if (Jn && (Jn(P, Re), Re.isMatchIgnored))
              return Sn(J);
          return be.skip ? Me += J : (be.excludeBegin && (Me += J), $e(), !be.returnBegin && !be.excludeBegin && (Me = J)), Cn(be, P), be.returnBegin ? 0 : J.length;
        }
        function xt(P) {
          const J = P[0], be = L.substring(P.index), Re = ot(se, P, be);
          if (!Re)
            return yc;
          const pn = se;
          se.endScope && se.endScope._wrap ? ($e(), Ge(J, se.endScope._wrap)) : se.endScope && se.endScope._multi ? ($e(), Gn(se.endScope, P)) : pn.skip ? Me += J : (pn.returnEnd || pn.excludeEnd || (Me += J), $e(), pn.excludeEnd && (Me = J));
          do
            se.scope && Ue.closeNode(), !se.skip && !se.subLanguage && (Dn += se.relevance), se = se.parent;
          while (se !== Re.parent);
          return Re.starts && Cn(Re.starts, P), pn.returnEnd ? 0 : J.length;
        }
        function ft() {
          const P = [];
          for (let J = se; J !== ge; J = J.parent)
            J.scope && P.unshift(J.scope);
          P.forEach((J) => Ue.openNode(J));
        }
        let Yn = {};
        function gt(P, J) {
          const be = J && J[0];
          if (Me += P, be == null)
            return $e(), 0;
          if (Yn.type === "begin" && J.type === "end" && Yn.index === J.index && be === "") {
            if (Me += L.slice(J.index, J.index + 1), !i2) {
              const Re = new Error(`0 width match regex (${N})`);
              throw Re.languageName = N, Re.badRule = Yn.rule, Re;
            }
            return 1;
          }
          if (Yn = J, J.type === "begin")
            return it(J);
          if (J.type === "illegal" && !V) {
            const Re = new Error('Illegal lexeme "' + be + '" for mode "' + (se.scope || "<unnamed>") + '"');
            throw Re.mode = se, Re;
          } else if (J.type === "end") {
            const Re = xt(J);
            if (Re !== yc)
              return Re;
          }
          if (J.type === "illegal" && be === "")
            return 1;
          if (ht > 1e5 && ht > J.index * 3)
            throw new Error("potential infinite loop, way more iterations than matches");
          return Me += be, be.length;
        }
        const ge = q(N);
        if (!ge)
          throw No(s.replace("{}", N)), new Error('Unknown language: "' + N + '"');
        const Hn = Uj(ge);
        let Nn = "", se = te || Hn;
        const Ln = {}, Ue = new a.__emitter(a);
        ft();
        let Me = "", Dn = 0, un = 0, ht = 0, Bn = false;
        try {
          if (ge.__emitTokens)
            ge.__emitTokens(L, Ue);
          else {
            for (se.matcher.considerAll(); ; ) {
              ht++, Bn ? Bn = false : se.matcher.considerAll(), se.matcher.lastIndex = un;
              const P = se.matcher.exec(L);
              if (!P) break;
              const J = L.substring(un, P.index), be = gt(J, P);
              un = P.index + be;
            }
            gt(L.substring(un));
          }
          return Ue.finalize(), Nn = Ue.toHTML(), {
            language: N,
            value: Nn,
            relevance: Dn,
            illegal: false,
            _emitter: Ue,
            _top: se
          };
        } catch (P) {
          if (P.message && P.message.includes("Illegal"))
            return {
              language: N,
              value: ia(L),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: P.message,
                index: un,
                context: L.slice(un - 100, un + 100),
                mode: P.mode,
                resultSoFar: Nn
              },
              _emitter: Ue
            };
          if (i2)
            return {
              language: N,
              value: ia(L),
              illegal: false,
              relevance: 0,
              errorRaised: P,
              _emitter: Ue,
              _top: se
            };
          throw P;
        }
      }
      function p2(N) {
        const L = {
          value: ia(N),
          illegal: false,
          relevance: 0,
          _top: r,
          _emitter: new a.__emitter(a)
        };
        return L._emitter.addText(N), L;
      }
      function _(N, L) {
        L = L || a.languages || Object.keys(e);
        const V = p2(N), te = L.filter(q).filter(ie2).map(
          ($e) => d($e, N, false)
        );
        te.unshift(V);
        const ae = te.sort(($e, Ge) => {
          if ($e.relevance !== Ge.relevance) return Ge.relevance - $e.relevance;
          if ($e.language && Ge.language) {
            if (q($e.language).supersetOf === Ge.language)
              return 1;
            if (q(Ge.language).supersetOf === $e.language)
              return -1;
          }
          return 0;
        }), [ye, Pe] = ae, vn = ye;
        return vn.secondBest = Pe, vn;
      }
      function m(N, L, V) {
        const te = L && t[L] || V;
        N.classList.add("hljs"), N.classList.add(`language-${te}`);
      }
      function f(N) {
        let L = null;
        const V = u(N);
        if (l(V)) return;
        if (de(
          "before:highlightElement",
          { el: N, language: V }
        ), N.dataset.highlighted) {
          console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", N);
          return;
        }
        if (N.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(N)), a.throwUnescapedHTML))
          throw new Vj(
            "One of your code blocks includes unescaped HTML.",
            N.innerHTML
          );
        L = N;
        const te = L.textContent, ae = V ? c2(te, { language: V, ignoreIllegals: true }) : _(te);
        N.innerHTML = ae.value, N.dataset.highlighted = "yes", m(N, V, ae.language), N.result = {
          language: ae.language,
          // TODO: remove with version 11.0
          re: ae.relevance,
          relevance: ae.relevance
        }, ae.secondBest && (N.secondBest = {
          language: ae.secondBest.language,
          relevance: ae.secondBest.relevance
        }), de("after:highlightElement", { el: N, result: ae, text: te });
      }
      function b(N) {
        a = kc(a, N);
      }
      const h2 = () => {
        v(), zo("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
      };
      function y() {
        v(), zo("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
      }
      let C = false;
      function v() {
        if (document.readyState === "loading") {
          C = true;
          return;
        }
        document.querySelectorAll(a.cssSelector).forEach(f);
      }
      function x() {
        C && v();
      }
      typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", x, false);
      function S(N, L) {
        let V = null;
        try {
          V = L(n2);
        } catch (te) {
          if (No("Language definition for '{}' could not be registered.".replace("{}", N)), i2)
            No(te);
          else
            throw te;
          V = r;
        }
        V.name || (V.name = N), e[N] = V, V.rawDefinition = L.bind(null, n2), V.aliases && K(V.aliases, { languageName: N });
      }
      function F(N) {
        delete e[N];
        for (const L of Object.keys(t))
          t[L] === N && delete t[L];
      }
      function Y() {
        return Object.keys(e);
      }
      function q(N) {
        return N = (N || "").toLowerCase(), e[N] || e[t[N]];
      }
      function K(N, { languageName: L }) {
        typeof N == "string" && (N = [N]), N.forEach((V) => {
          t[V.toLowerCase()] = L;
        });
      }
      function ie2(N) {
        const L = q(N);
        return L && !L.disableAutodetect;
      }
      function ce(N) {
        N["before:highlightBlock"] && !N["before:highlightElement"] && (N["before:highlightElement"] = (L) => {
          N["before:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        }), N["after:highlightBlock"] && !N["after:highlightElement"] && (N["after:highlightElement"] = (L) => {
          N["after:highlightBlock"](
            Object.assign({ block: L.el }, L)
          );
        });
      }
      function ve(N) {
        ce(N), o.push(N);
      }
      function he(N) {
        const L = o.indexOf(N);
        L !== -1 && o.splice(L, 1);
      }
      function de(N, L) {
        const V = N;
        o.forEach(function(te) {
          te[V] && te[V](L);
        });
      }
      function pe(N) {
        return zo("10.7.0", "highlightBlock will be removed entirely in v12.0"), zo("10.7.0", "Please use highlightElement now."), f(N);
      }
      Object.assign(n2, {
        highlight: c2,
        highlightAuto: _,
        highlightAll: v,
        highlightElement: f,
        // TODO: Remove with v12 API
        highlightBlock: pe,
        configure: b,
        initHighlighting: h2,
        initHighlightingOnLoad: y,
        registerLanguage: S,
        unregisterLanguage: F,
        listLanguages: Y,
        getLanguage: q,
        registerAliases: K,
        autoDetection: ie2,
        inherit: kc,
        addPlugin: ve,
        removePlugin: he
      }), n2.debugMode = function() {
        i2 = false;
      }, n2.safeMode = function() {
        i2 = true;
      }, n2.versionString = Kj, n2.regex = {
        concat: Bo,
        lookahead: Hp,
        either: Al,
        optional: aj,
        anyNumberOfTimes: rj
      };
      for (const N in fs)
        typeof fs[N] == "object" && zp(fs[N]);
      return Object.assign(n2, fs), n2;
    }, ii = Zp({});
    ii.newInstance = () => Zp({});
    var Gj = ii;
    ii.HighlightJS = ii;
    ii.default = ii;
    var Yj = /* @__PURE__ */ nj(Gj);
    function Xp(n2, e = []) {
      return n2.map((t) => {
        const o = [...e, ...t.properties ? t.properties.className : []];
        return t.children ? Xp(t.children, o) : {
          text: t.value,
          classes: o
        };
      }).flat();
    }
    function jc(n2) {
      return n2.value || n2.children || [];
    }
    function Jj(n2) {
      return !!Yj.getLanguage(n2);
    }
    function wc({ doc: n2, name: e, lowlight: t, defaultLanguage: o }) {
      const i2 = [];
      return findChildren(n2, (s) => s.type.name === e).forEach((s) => {
        var r;
        let a = s.pos + 1;
        const l = s.node.attrs.language || o, u = t.listLanguages(), c2 = l && (u.includes(l) || Jj(l) || !((r = t.registered) === null || r === void 0) && r.call(t, l)) ? jc(t.highlight(l, s.node.textContent)) : jc(t.highlightAuto(s.node.textContent));
        Xp(c2).forEach((d) => {
          const p2 = a + d.text.length;
          if (d.classes.length) {
            const _ = hn.inline(a, p2, {
              class: d.classes.join(" ")
            });
            i2.push(_);
          }
          a = p2;
        });
      }), He.create(n2, i2);
    }
    function Zj(n2) {
      return typeof n2 == "function";
    }
    function Xj({ name: n2, lowlight: e, defaultLanguage: t }) {
      if (!["highlight", "highlightAuto", "listLanguages"].every((i2) => Zj(e[i2])))
        throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
      const o = new dn({
        key: new en("lowlight"),
        state: {
          init: (i2, { doc: s }) => wc({
            doc: s,
            name: n2,
            lowlight: e,
            defaultLanguage: t
          }),
          apply: (i2, s, r, a) => {
            const l = r.selection.$head.parent.type.name, u = a.selection.$head.parent.type.name, c2 = findChildren(r.doc, (p2) => p2.type.name === n2), d = findChildren(a.doc, (p2) => p2.type.name === n2);
            return i2.docChanged && ([l, u].includes(n2) || d.length !== c2.length || i2.steps.some((p2) => (
              // @ts-ignore
              p2.from !== void 0 && p2.to !== void 0 && c2.some((_) => (
                // @ts-ignore
                _.pos >= p2.from && _.pos + _.node.nodeSize <= p2.to
              ))
            ))) ? wc({
              doc: i2.doc,
              name: n2,
              lowlight: e,
              defaultLanguage: t
            }) : s.map(i2.mapping, i2.doc);
          }
        },
        props: {
          decorations(i2) {
            return o.getState(i2);
          }
        }
      });
      return o;
    }
    const Qj = Pd.extend({
      addOptions() {
        var n2;
        return {
          ...(n2 = this.parent) === null || n2 === void 0 ? void 0 : n2.call(this),
          lowlight: {},
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      addProseMirrorPlugins() {
        var n2;
        return [
          ...((n2 = this.parent) === null || n2 === void 0 ? void 0 : n2.call(this)) || [],
          Xj({
            name: this.name,
            lowlight: this.options.lowlight,
            defaultLanguage: this.options.defaultLanguage
          })
        ];
      }
    });
    function ew(n2) {
      const e = n2.regex, t = n2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i2 = "[a-zA-Z_]\\w*::", r = "(?!struct)(" + o + "|" + e.optional(i2) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, u = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, c2 = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n2.inherit(u, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i2) + n2.IDENT_RE,
        relevance: 0
      }, _ = e.optional(i2) + n2.IDENT_RE + "\\s*\\(", m = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], f = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], b = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], h2 = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: f,
        keyword: m,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: b
      }, x = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: h2
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          n2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        x,
        d,
        a,
        t,
        n2.C_BLOCK_COMMENT_MODE,
        c2,
        u
      ], F = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, Y = {
        className: "function",
        begin: "(" + r + "[\\*&\\s]+)+" + _,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: v,
            relevance: 0
          },
          {
            begin: _,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              u,
              c2
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              t,
              n2.C_BLOCK_COMMENT_MODE,
              u,
              c2,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n2.C_BLOCK_COMMENT_MODE,
                  u,
                  c2,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          F,
          Y,
          x,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: n2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function nw(n2) {
      const e = {
        type: [
          "boolean",
          "byte",
          "word",
          "String"
        ],
        built_in: [
          "KeyboardController",
          "MouseController",
          "SoftwareSerial",
          "EthernetServer",
          "EthernetClient",
          "LiquidCrystal",
          "RobotControl",
          "GSMVoiceCall",
          "EthernetUDP",
          "EsploraTFT",
          "HttpClient",
          "RobotMotor",
          "WiFiClient",
          "GSMScanner",
          "FileSystem",
          "Scheduler",
          "GSMServer",
          "YunClient",
          "YunServer",
          "IPAddress",
          "GSMClient",
          "GSMModem",
          "Keyboard",
          "Ethernet",
          "Console",
          "GSMBand",
          "Esplora",
          "Stepper",
          "Process",
          "WiFiUDP",
          "GSM_SMS",
          "Mailbox",
          "USBHost",
          "Firmata",
          "PImage",
          "Client",
          "Server",
          "GSMPIN",
          "FileIO",
          "Bridge",
          "Serial",
          "EEPROM",
          "Stream",
          "Mouse",
          "Audio",
          "Servo",
          "File",
          "Task",
          "GPRS",
          "WiFi",
          "Wire",
          "TFT",
          "GSM",
          "SPI",
          "SD"
        ],
        _hints: [
          "setup",
          "loop",
          "runShellCommandAsynchronously",
          "analogWriteResolution",
          "retrieveCallingNumber",
          "printFirmwareVersion",
          "analogReadResolution",
          "sendDigitalPortPair",
          "noListenOnLocalhost",
          "readJoystickButton",
          "setFirmwareVersion",
          "readJoystickSwitch",
          "scrollDisplayRight",
          "getVoiceCallStatus",
          "scrollDisplayLeft",
          "writeMicroseconds",
          "delayMicroseconds",
          "beginTransmission",
          "getSignalStrength",
          "runAsynchronously",
          "getAsynchronously",
          "listenOnLocalhost",
          "getCurrentCarrier",
          "readAccelerometer",
          "messageAvailable",
          "sendDigitalPorts",
          "lineFollowConfig",
          "countryNameWrite",
          "runShellCommand",
          "readStringUntil",
          "rewindDirectory",
          "readTemperature",
          "setClockDivider",
          "readLightSensor",
          "endTransmission",
          "analogReference",
          "detachInterrupt",
          "countryNameRead",
          "attachInterrupt",
          "encryptionType",
          "readBytesUntil",
          "robotNameWrite",
          "readMicrophone",
          "robotNameRead",
          "cityNameWrite",
          "userNameWrite",
          "readJoystickY",
          "readJoystickX",
          "mouseReleased",
          "openNextFile",
          "scanNetworks",
          "noInterrupts",
          "digitalWrite",
          "beginSpeaker",
          "mousePressed",
          "isActionDone",
          "mouseDragged",
          "displayLogos",
          "noAutoscroll",
          "addParameter",
          "remoteNumber",
          "getModifiers",
          "keyboardRead",
          "userNameRead",
          "waitContinue",
          "processInput",
          "parseCommand",
          "printVersion",
          "readNetworks",
          "writeMessage",
          "blinkVersion",
          "cityNameRead",
          "readMessage",
          "setDataMode",
          "parsePacket",
          "isListening",
          "setBitOrder",
          "beginPacket",
          "isDirectory",
          "motorsWrite",
          "drawCompass",
          "digitalRead",
          "clearScreen",
          "serialEvent",
          "rightToLeft",
          "setTextSize",
          "leftToRight",
          "requestFrom",
          "keyReleased",
          "compassRead",
          "analogWrite",
          "interrupts",
          "WiFiServer",
          "disconnect",
          "playMelody",
          "parseFloat",
          "autoscroll",
          "getPINUsed",
          "setPINUsed",
          "setTimeout",
          "sendAnalog",
          "readSlider",
          "analogRead",
          "beginWrite",
          "createChar",
          "motorsStop",
          "keyPressed",
          "tempoWrite",
          "readButton",
          "subnetMask",
          "debugPrint",
          "macAddress",
          "writeGreen",
          "randomSeed",
          "attachGPRS",
          "readString",
          "sendString",
          "remotePort",
          "releaseAll",
          "mouseMoved",
          "background",
          "getXChange",
          "getYChange",
          "answerCall",
          "getResult",
          "voiceCall",
          "endPacket",
          "constrain",
          "getSocket",
          "writeJSON",
          "getButton",
          "available",
          "connected",
          "findUntil",
          "readBytes",
          "exitValue",
          "readGreen",
          "writeBlue",
          "startLoop",
          "IPAddress",
          "isPressed",
          "sendSysex",
          "pauseMode",
          "gatewayIP",
          "setCursor",
          "getOemKey",
          "tuneWrite",
          "noDisplay",
          "loadImage",
          "switchPIN",
          "onRequest",
          "onReceive",
          "changePIN",
          "playFile",
          "noBuffer",
          "parseInt",
          "overflow",
          "checkPIN",
          "knobRead",
          "beginTFT",
          "bitClear",
          "updateIR",
          "bitWrite",
          "position",
          "writeRGB",
          "highByte",
          "writeRed",
          "setSpeed",
          "readBlue",
          "noStroke",
          "remoteIP",
          "transfer",
          "shutdown",
          "hangCall",
          "beginSMS",
          "endWrite",
          "attached",
          "maintain",
          "noCursor",
          "checkReg",
          "checkPUK",
          "shiftOut",
          "isValid",
          "shiftIn",
          "pulseIn",
          "connect",
          "println",
          "localIP",
          "pinMode",
          "getIMEI",
          "display",
          "noBlink",
          "process",
          "getBand",
          "running",
          "beginSD",
          "drawBMP",
          "lowByte",
          "setBand",
          "release",
          "bitRead",
          "prepare",
          "pointTo",
          "readRed",
          "setMode",
          "noFill",
          "remove",
          "listen",
          "stroke",
          "detach",
          "attach",
          "noTone",
          "exists",
          "buffer",
          "height",
          "bitSet",
          "circle",
          "config",
          "cursor",
          "random",
          "IRread",
          "setDNS",
          "endSMS",
          "getKey",
          "micros",
          "millis",
          "begin",
          "print",
          "write",
          "ready",
          "flush",
          "width",
          "isPIN",
          "blink",
          "clear",
          "press",
          "mkdir",
          "rmdir",
          "close",
          "point",
          "yield",
          "image",
          "BSSID",
          "click",
          "delay",
          "read",
          "text",
          "move",
          "peek",
          "beep",
          "rect",
          "line",
          "open",
          "seek",
          "fill",
          "size",
          "turn",
          "stop",
          "home",
          "find",
          "step",
          "tone",
          "sqrt",
          "RSSI",
          "SSID",
          "end",
          "bit",
          "tan",
          "cos",
          "sin",
          "pow",
          "map",
          "abs",
          "max",
          "min",
          "get",
          "run",
          "put"
        ],
        literal: [
          "DIGITAL_MESSAGE",
          "FIRMATA_STRING",
          "ANALOG_MESSAGE",
          "REPORT_DIGITAL",
          "REPORT_ANALOG",
          "INPUT_PULLUP",
          "SET_PIN_MODE",
          "INTERNAL2V56",
          "SYSTEM_RESET",
          "LED_BUILTIN",
          "INTERNAL1V1",
          "SYSEX_START",
          "INTERNAL",
          "EXTERNAL",
          "DEFAULT",
          "OUTPUT",
          "INPUT",
          "HIGH",
          "LOW"
        ]
      }, t = ew(n2), o = (
        /** @type {Record<string,any>} */
        t.keywords
      );
      return o.type = [
        ...o.type,
        ...e.type
      ], o.literal = [
        ...o.literal,
        ...e.literal
      ], o.built_in = [
        ...o.built_in,
        ...e.built_in
      ], o._hints = e._hints, t.name = "Arduino", t.aliases = ["ino"], t.supersetOf = "cpp", t;
    }
    function tw(n2) {
      const e = n2.regex, t = {}, o = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [t]
          }
          // default values
        ]
      };
      Object.assign(t, {
        className: "variable",
        variants: [
          { begin: e.concat(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            "(?![\\w\\d])(?![$])"
          ) },
          o
        ]
      });
      const i2 = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [n2.BACKSLASH_ESCAPE]
      }, s = n2.inherit(
        n2.COMMENT(),
        {
          match: [
            /(^|\s)/,
            /#.*$/
          ],
          scope: {
            2: "comment"
          }
        }
      ), r = {
        begin: /<<-?\s*(?=\w+)/,
        starts: { contains: [
          n2.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })
        ] }
      }, a = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          n2.BACKSLASH_ESCAPE,
          t,
          i2
        ]
      };
      i2.contains.push(a);
      const l = {
        match: /\\"/
      }, u = {
        className: "string",
        begin: /'/,
        end: /'/
      }, c2 = {
        match: /\\'/
      }, d = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [
          {
            begin: /\d+#[0-9a-f]+/,
            className: "number"
          },
          n2.NUMBER_MODE,
          t
        ]
      }, p2 = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ], _ = n2.SHEBANG({
        binary: `(${p2.join("|")})`,
        relevance: 10
      }), m = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [n2.inherit(n2.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      }, f = [
        "if",
        "then",
        "else",
        "elif",
        "fi",
        "time",
        "for",
        "while",
        "until",
        "in",
        "do",
        "done",
        "case",
        "esac",
        "coproc",
        "function",
        "select"
      ], b = [
        "true",
        "false"
      ], h2 = { match: /(\/[a-z._-]+)+/ }, y = [
        "break",
        "cd",
        "continue",
        "eval",
        "exec",
        "exit",
        "export",
        "getopts",
        "hash",
        "pwd",
        "readonly",
        "return",
        "shift",
        "test",
        "times",
        "trap",
        "umask",
        "unset"
      ], C = [
        "alias",
        "bind",
        "builtin",
        "caller",
        "command",
        "declare",
        "echo",
        "enable",
        "help",
        "let",
        "local",
        "logout",
        "mapfile",
        "printf",
        "read",
        "readarray",
        "source",
        "sudo",
        "type",
        "typeset",
        "ulimit",
        "unalias"
      ], v = [
        "autoload",
        "bg",
        "bindkey",
        "bye",
        "cap",
        "chdir",
        "clone",
        "comparguments",
        "compcall",
        "compctl",
        "compdescribe",
        "compfiles",
        "compgroups",
        "compquote",
        "comptags",
        "comptry",
        "compvalues",
        "dirs",
        "disable",
        "disown",
        "echotc",
        "echoti",
        "emulate",
        "fc",
        "fg",
        "float",
        "functions",
        "getcap",
        "getln",
        "history",
        "integer",
        "jobs",
        "kill",
        "limit",
        "log",
        "noglob",
        "popd",
        "print",
        "pushd",
        "pushln",
        "rehash",
        "sched",
        "setcap",
        "setopt",
        "stat",
        "suspend",
        "ttyctl",
        "unfunction",
        "unhash",
        "unlimit",
        "unsetopt",
        "vared",
        "wait",
        "whence",
        "where",
        "which",
        "zcompile",
        "zformat",
        "zftp",
        "zle",
        "zmodload",
        "zparseopts",
        "zprof",
        "zpty",
        "zregexparse",
        "zsocket",
        "zstyle",
        "ztcp"
      ], x = [
        "chcon",
        "chgrp",
        "chown",
        "chmod",
        "cp",
        "dd",
        "df",
        "dir",
        "dircolors",
        "ln",
        "ls",
        "mkdir",
        "mkfifo",
        "mknod",
        "mktemp",
        "mv",
        "realpath",
        "rm",
        "rmdir",
        "shred",
        "sync",
        "touch",
        "truncate",
        "vdir",
        "b2sum",
        "base32",
        "base64",
        "cat",
        "cksum",
        "comm",
        "csplit",
        "cut",
        "expand",
        "fmt",
        "fold",
        "head",
        "join",
        "md5sum",
        "nl",
        "numfmt",
        "od",
        "paste",
        "ptx",
        "pr",
        "sha1sum",
        "sha224sum",
        "sha256sum",
        "sha384sum",
        "sha512sum",
        "shuf",
        "sort",
        "split",
        "sum",
        "tac",
        "tail",
        "tr",
        "tsort",
        "unexpand",
        "uniq",
        "wc",
        "arch",
        "basename",
        "chroot",
        "date",
        "dirname",
        "du",
        "echo",
        "env",
        "expr",
        "factor",
        // "false", // keyword literal already
        "groups",
        "hostid",
        "id",
        "link",
        "logname",
        "nice",
        "nohup",
        "nproc",
        "pathchk",
        "pinky",
        "printenv",
        "printf",
        "pwd",
        "readlink",
        "runcon",
        "seq",
        "sleep",
        "stat",
        "stdbuf",
        "stty",
        "tee",
        "test",
        "timeout",
        // "true", // keyword literal already
        "tty",
        "uname",
        "unlink",
        "uptime",
        "users",
        "who",
        "whoami",
        "yes"
      ];
      return {
        name: "Bash",
        aliases: [
          "sh",
          "zsh"
        ],
        keywords: {
          $pattern: /\b[a-z][a-z0-9._-]+\b/,
          keyword: f,
          literal: b,
          built_in: [
            ...y,
            ...C,
            // Shell modifiers
            "set",
            "shopt",
            ...v,
            ...x
          ]
        },
        contains: [
          _,
          // to catch known shells and boost relevancy
          n2.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          m,
          d,
          s,
          r,
          h2,
          a,
          l,
          u,
          c2,
          t
        ]
      };
    }
    function ow(n2) {
      const e = n2.regex, t = n2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i2 = "[a-zA-Z_]\\w*::", r = "(" + o + "|" + e.optional(i2) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        variants: [
          { begin: "\\b[a-z\\d_]*_t\\b" },
          { match: /\batomic_[a-z]{3,6}\b/ }
        ]
      }, u = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, c2 = {
        className: "number",
        variants: [
          { match: /\b(0b[01']+)/ },
          { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
          { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n2.inherit(u, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i2) + n2.IDENT_RE,
        relevance: 0
      }, _ = e.optional(i2) + n2.IDENT_RE + "\\s*\\(", b = {
        keyword: [
          "asm",
          "auto",
          "break",
          "case",
          "continue",
          "default",
          "do",
          "else",
          "enum",
          "extern",
          "for",
          "fortran",
          "goto",
          "if",
          "inline",
          "register",
          "restrict",
          "return",
          "sizeof",
          "typeof",
          "typeof_unqual",
          "struct",
          "switch",
          "typedef",
          "union",
          "volatile",
          "while",
          "_Alignas",
          "_Alignof",
          "_Atomic",
          "_Generic",
          "_Noreturn",
          "_Static_assert",
          "_Thread_local",
          // aliases
          "alignas",
          "alignof",
          "noreturn",
          "static_assert",
          "thread_local",
          // not a C keyword but is, for all intents and purposes, treated exactly like one.
          "_Pragma"
        ],
        type: [
          "float",
          "double",
          "signed",
          "unsigned",
          "int",
          "short",
          "long",
          "char",
          "void",
          "_Bool",
          "_BitInt",
          "_Complex",
          "_Imaginary",
          "_Decimal32",
          "_Decimal64",
          "_Decimal96",
          "_Decimal128",
          "_Decimal64x",
          "_Decimal128x",
          "_Float16",
          "_Float32",
          "_Float64",
          "_Float128",
          "_Float32x",
          "_Float64x",
          "_Float128x",
          // modifiers
          "const",
          "static",
          "constexpr",
          // aliases
          "complex",
          "bool",
          "imaginary"
        ],
        literal: "true false NULL",
        // TODO: apply hinting work similar to what was done in cpp.js
        built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
      }, h2 = [
        d,
        a,
        t,
        n2.C_BLOCK_COMMENT_MODE,
        c2,
        u
      ], y = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: b,
        contains: h2.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: b,
            contains: h2.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, C = {
        begin: "(" + r + "[\\*&\\s]+)+" + _,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: b,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: b,
            relevance: 0
          },
          {
            begin: _,
            returnBegin: true,
            contains: [n2.inherit(p2, { className: "title.function" })],
            relevance: 0
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: b,
            relevance: 0,
            contains: [
              t,
              n2.C_BLOCK_COMMENT_MODE,
              u,
              c2,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: b,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n2.C_BLOCK_COMMENT_MODE,
                  u,
                  c2,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C",
        aliases: ["h"],
        keywords: b,
        // Until differentiations are added between `c` and `cpp`, `c` will
        // not be auto-detected to avoid auto-detect conflicts between C and C++
        disableAutodetect: true,
        illegal: "</",
        contains: [].concat(
          y,
          C,
          h2,
          [
            d,
            {
              begin: n2.IDENT_RE + "::",
              keywords: b
            },
            {
              className: "class",
              beginKeywords: "enum class struct union",
              end: /[{;:<>=]/,
              contains: [
                { beginKeywords: "final class struct" },
                n2.TITLE_MODE
              ]
            }
          ]
        ),
        exports: {
          preprocessor: d,
          strings: u,
          keywords: b
        }
      };
    }
    function iw(n2) {
      const e = n2.regex, t = n2.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), o = "decltype\\(auto\\)", i2 = "[a-zA-Z_]\\w*::", r = "(?!struct)(" + o + "|" + e.optional(i2) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
        className: "type",
        begin: "\\b[a-z\\d_]*_t\\b"
      }, u = {
        className: "string",
        variants: [
          {
            begin: '(u8?|U|L)?"',
            end: '"',
            illegal: "\\n",
            contains: [n2.BACKSLASH_ESCAPE]
          },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: "."
          },
          n2.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/
          })
        ]
      }, c2 = {
        className: "number",
        variants: [
          // Floating-point literal.
          {
            begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
          },
          // Integer literal.
          {
            begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
            // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
            // literal highlight actually makes it stand out more.
          }
        ],
        relevance: 0
      }, d = {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          n2.inherit(u, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/
          },
          t,
          n2.C_BLOCK_COMMENT_MODE
        ]
      }, p2 = {
        className: "title",
        begin: e.optional(i2) + n2.IDENT_RE,
        relevance: 0
      }, _ = e.optional(i2) + n2.IDENT_RE + "\\s*\\(", m = [
        "alignas",
        "alignof",
        "and",
        "and_eq",
        "asm",
        "atomic_cancel",
        "atomic_commit",
        "atomic_noexcept",
        "auto",
        "bitand",
        "bitor",
        "break",
        "case",
        "catch",
        "class",
        "co_await",
        "co_return",
        "co_yield",
        "compl",
        "concept",
        "const_cast|10",
        "consteval",
        "constexpr",
        "constinit",
        "continue",
        "decltype",
        "default",
        "delete",
        "do",
        "dynamic_cast|10",
        "else",
        "enum",
        "explicit",
        "export",
        "extern",
        "false",
        "final",
        "for",
        "friend",
        "goto",
        "if",
        "import",
        "inline",
        "module",
        "mutable",
        "namespace",
        "new",
        "noexcept",
        "not",
        "not_eq",
        "nullptr",
        "operator",
        "or",
        "or_eq",
        "override",
        "private",
        "protected",
        "public",
        "reflexpr",
        "register",
        "reinterpret_cast|10",
        "requires",
        "return",
        "sizeof",
        "static_assert",
        "static_cast|10",
        "struct",
        "switch",
        "synchronized",
        "template",
        "this",
        "thread_local",
        "throw",
        "transaction_safe",
        "transaction_safe_dynamic",
        "true",
        "try",
        "typedef",
        "typeid",
        "typename",
        "union",
        "using",
        "virtual",
        "volatile",
        "while",
        "xor",
        "xor_eq"
      ], f = [
        "bool",
        "char",
        "char16_t",
        "char32_t",
        "char8_t",
        "double",
        "float",
        "int",
        "long",
        "short",
        "void",
        "wchar_t",
        "unsigned",
        "signed",
        "const",
        "static"
      ], b = [
        "any",
        "auto_ptr",
        "barrier",
        "binary_semaphore",
        "bitset",
        "complex",
        "condition_variable",
        "condition_variable_any",
        "counting_semaphore",
        "deque",
        "false_type",
        "flat_map",
        "flat_set",
        "future",
        "imaginary",
        "initializer_list",
        "istringstream",
        "jthread",
        "latch",
        "lock_guard",
        "multimap",
        "multiset",
        "mutex",
        "optional",
        "ostringstream",
        "packaged_task",
        "pair",
        "promise",
        "priority_queue",
        "queue",
        "recursive_mutex",
        "recursive_timed_mutex",
        "scoped_lock",
        "set",
        "shared_future",
        "shared_lock",
        "shared_mutex",
        "shared_timed_mutex",
        "shared_ptr",
        "stack",
        "string_view",
        "stringstream",
        "timed_mutex",
        "thread",
        "true_type",
        "tuple",
        "unique_lock",
        "unique_ptr",
        "unordered_map",
        "unordered_multimap",
        "unordered_multiset",
        "unordered_set",
        "variant",
        "vector",
        "weak_ptr",
        "wstring",
        "wstring_view"
      ], h2 = [
        "abort",
        "abs",
        "acos",
        "apply",
        "as_const",
        "asin",
        "atan",
        "atan2",
        "calloc",
        "ceil",
        "cerr",
        "cin",
        "clog",
        "cos",
        "cosh",
        "cout",
        "declval",
        "endl",
        "exchange",
        "exit",
        "exp",
        "fabs",
        "floor",
        "fmod",
        "forward",
        "fprintf",
        "fputs",
        "free",
        "frexp",
        "fscanf",
        "future",
        "invoke",
        "isalnum",
        "isalpha",
        "iscntrl",
        "isdigit",
        "isgraph",
        "islower",
        "isprint",
        "ispunct",
        "isspace",
        "isupper",
        "isxdigit",
        "labs",
        "launder",
        "ldexp",
        "log",
        "log10",
        "make_pair",
        "make_shared",
        "make_shared_for_overwrite",
        "make_tuple",
        "make_unique",
        "malloc",
        "memchr",
        "memcmp",
        "memcpy",
        "memset",
        "modf",
        "move",
        "pow",
        "printf",
        "putchar",
        "puts",
        "realloc",
        "scanf",
        "sin",
        "sinh",
        "snprintf",
        "sprintf",
        "sqrt",
        "sscanf",
        "std",
        "stderr",
        "stdin",
        "stdout",
        "strcat",
        "strchr",
        "strcmp",
        "strcpy",
        "strcspn",
        "strlen",
        "strncat",
        "strncmp",
        "strncpy",
        "strpbrk",
        "strrchr",
        "strspn",
        "strstr",
        "swap",
        "tan",
        "tanh",
        "terminate",
        "to_underlying",
        "tolower",
        "toupper",
        "vfprintf",
        "visit",
        "vprintf",
        "vsprintf"
      ], v = {
        type: f,
        keyword: m,
        literal: [
          "NULL",
          "false",
          "nullopt",
          "nullptr",
          "true"
        ],
        built_in: ["_Pragma"],
        _type_hints: b
      }, x = {
        className: "function.dispatch",
        relevance: 0,
        keywords: {
          // Only for relevance, not highlighting.
          _hint: h2
        },
        begin: e.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          n2.IDENT_RE,
          e.lookahead(/(<[^<>]+>|)\s*\(/)
        )
      }, S = [
        x,
        d,
        a,
        t,
        n2.C_BLOCK_COMMENT_MODE,
        c2,
        u
      ], F = {
        // This mode covers expression context where we can't expect a function
        // definition and shouldn't highlight anything that looks like one:
        // `return some()`, `else if()`, `(x*sum(1, 2))`
        variants: [
          {
            begin: /=/,
            end: /;/
          },
          {
            begin: /\(/,
            end: /\)/
          },
          {
            beginKeywords: "new throw return else",
            end: /;/
          }
        ],
        keywords: v,
        contains: S.concat([
          {
            begin: /\(/,
            end: /\)/,
            keywords: v,
            contains: S.concat(["self"]),
            relevance: 0
          }
        ]),
        relevance: 0
      }, Y = {
        className: "function",
        begin: "(" + r + "[\\*&\\s]+)+" + _,
        returnBegin: true,
        end: /[{;=]/,
        excludeEnd: true,
        keywords: v,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          {
            // to prevent it from being confused as the function title
            begin: o,
            keywords: v,
            relevance: 0
          },
          {
            begin: _,
            returnBegin: true,
            contains: [p2],
            relevance: 0
          },
          // needed because we do not have look-behind on the below rule
          // to prevent it from grabbing the final : in a :: pair
          {
            begin: /::/,
            relevance: 0
          },
          // initializers
          {
            begin: /:/,
            endsWithParent: true,
            contains: [
              u,
              c2
            ]
          },
          // allow for multiple declarations, e.g.:
          // extern void f(int), g(char);
          {
            relevance: 0,
            match: /,/
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: v,
            relevance: 0,
            contains: [
              t,
              n2.C_BLOCK_COMMENT_MODE,
              u,
              c2,
              a,
              // Count matching parentheses.
              {
                begin: /\(/,
                end: /\)/,
                keywords: v,
                relevance: 0,
                contains: [
                  "self",
                  t,
                  n2.C_BLOCK_COMMENT_MODE,
                  u,
                  c2,
                  a
                ]
              }
            ]
          },
          a,
          t,
          n2.C_BLOCK_COMMENT_MODE,
          d
        ]
      };
      return {
        name: "C++",
        aliases: [
          "cc",
          "c++",
          "h++",
          "hpp",
          "hh",
          "hxx",
          "cxx"
        ],
        keywords: v,
        illegal: "</",
        classNameAliases: { "function.dispatch": "built_in" },
        contains: [].concat(
          F,
          Y,
          x,
          S,
          [
            d,
            {
              // containers: ie, `vector <int> rooms (9);`
              begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
              end: ">",
              keywords: v,
              contains: [
                "self",
                a
              ]
            },
            {
              begin: n2.IDENT_RE + "::",
              keywords: v
            },
            {
              match: [
                // extra complexity to deal with `enum class` and `enum struct`
                /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                /\s+/,
                /\w+/
              ],
              className: {
                1: "keyword",
                3: "title.class"
              }
            }
          ]
        )
      };
    }
    function sw(n2) {
      const e = [
        "bool",
        "byte",
        "char",
        "decimal",
        "delegate",
        "double",
        "dynamic",
        "enum",
        "float",
        "int",
        "long",
        "nint",
        "nuint",
        "object",
        "sbyte",
        "short",
        "string",
        "ulong",
        "uint",
        "ushort"
      ], t = [
        "public",
        "private",
        "protected",
        "static",
        "internal",
        "protected",
        "abstract",
        "async",
        "extern",
        "override",
        "unsafe",
        "virtual",
        "new",
        "sealed",
        "partial"
      ], o = [
        "default",
        "false",
        "null",
        "true"
      ], i2 = [
        "abstract",
        "as",
        "base",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "do",
        "else",
        "event",
        "explicit",
        "extern",
        "finally",
        "fixed",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "interface",
        "internal",
        "is",
        "lock",
        "namespace",
        "new",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "record",
        "ref",
        "return",
        "scoped",
        "sealed",
        "sizeof",
        "stackalloc",
        "static",
        "struct",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "unchecked",
        "unsafe",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ], s = [
        "add",
        "alias",
        "and",
        "ascending",
        "args",
        "async",
        "await",
        "by",
        "descending",
        "dynamic",
        "equals",
        "file",
        "from",
        "get",
        "global",
        "group",
        "init",
        "into",
        "join",
        "let",
        "nameof",
        "not",
        "notnull",
        "on",
        "or",
        "orderby",
        "partial",
        "record",
        "remove",
        "required",
        "scoped",
        "select",
        "set",
        "unmanaged",
        "value|0",
        "var",
        "when",
        "where",
        "with",
        "yield"
      ], r = {
        keyword: i2.concat(s),
        built_in: e,
        literal: o
      }, a = n2.inherit(n2.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
        className: "number",
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
        ],
        relevance: 0
      }, u = {
        className: "string",
        begin: /"""("*)(?!")(.|\n)*?"""\1/,
        relevance: 1
      }, c2 = {
        className: "string",
        begin: '@"',
        end: '"',
        contains: [{ begin: '""' }]
      }, d = n2.inherit(c2, { illegal: /\n/ }), p2 = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: r
      }, _ = n2.inherit(p2, { illegal: /\n/ }), m = {
        className: "string",
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          n2.BACKSLASH_ESCAPE,
          _
        ]
      }, f = {
        className: "string",
        begin: /\$@"/,
        end: '"',
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          p2
        ]
      }, b = n2.inherit(f, {
        illegal: /\n/,
        contains: [
          { begin: /\{\{/ },
          { begin: /\}\}/ },
          { begin: '""' },
          _
        ]
      });
      p2.contains = [
        f,
        m,
        c2,
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE,
        l,
        n2.C_BLOCK_COMMENT_MODE
      ], _.contains = [
        b,
        m,
        d,
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE,
        l,
        n2.inherit(n2.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
      ];
      const h2 = { variants: [
        u,
        f,
        m,
        c2,
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE
      ] }, y = {
        begin: "<",
        end: ">",
        contains: [
          { beginKeywords: "in out" },
          a
        ]
      }, C = n2.IDENT_RE + "(<" + n2.IDENT_RE + "(\\s*,\\s*" + n2.IDENT_RE + ")*>)?(\\[\\])?", v = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + n2.IDENT_RE,
        relevance: 0
      };
      return {
        name: "C#",
        aliases: [
          "cs",
          "c#"
        ],
        keywords: r,
        illegal: /::/,
        contains: [
          n2.COMMENT(
            "///",
            "$",
            {
              returnBegin: true,
              contains: [
                {
                  className: "doctag",
                  variants: [
                    {
                      begin: "///",
                      relevance: 0
                    },
                    { begin: "<!--|-->" },
                    {
                      begin: "</?",
                      end: ">"
                    }
                  ]
                }
              ]
            }
          ),
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
          },
          h2,
          l,
          {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              { beginKeywords: "where class" },
              a,
              y,
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              a,
              y,
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new return throw await else",
            relevance: 0
          },
          {
            className: "function",
            begin: "(" + C + "\\s+)+" + n2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: r,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: t.join(" "),
                relevance: 0
              },
              {
                begin: n2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                returnBegin: true,
                contains: [
                  n2.TITLE_MODE,
                  y
                ],
                relevance: 0
              },
              { match: /\(\)/ },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: r,
                relevance: 0,
                contains: [
                  h2,
                  l,
                  n2.C_BLOCK_COMMENT_MODE
                ]
              },
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          v
        ]
      };
    }
    const rw = (n2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), aw = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], lw = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], uw = [
      ...aw,
      ...lw
    ], cw = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), dw = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), pw = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), _w = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function mw(n2) {
      const e = n2.regex, t = rw(n2), o = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i2 = "and or not only", s = /@-?\w[\w]*(-\w+)*/, r = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE
      ];
      return {
        name: "CSS",
        case_insensitive: true,
        illegal: /[=|'\$]/,
        keywords: { keyframePosition: "from to" },
        classNameAliases: {
          // for visual continuity with `tag {}` and because we
          // don't have a great class for this?
          keyframePosition: "selector-tag"
        },
        contains: [
          t.BLOCK_COMMENT,
          o,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          t.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\." + r,
            relevance: 0
          },
          t.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            variants: [
              { begin: ":(" + dw.join("|") + ")" },
              { begin: ":(:)?(" + pw.join("|") + ")" }
            ]
          },
          // we may actually need this (12/2020)
          // { // pseudo-selector params
          //   begin: /\(/,
          //   end: /\)/,
          //   contains: [ hljs.CSS_NUMBER_MODE ]
          // },
          t.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + _w.join("|") + ")\\b"
          },
          // attribute values
          {
            begin: /:/,
            end: /[;}{]/,
            contains: [
              t.BLOCK_COMMENT,
              t.HEXCOLOR,
              t.IMPORTANT,
              t.CSS_NUMBER_MODE,
              ...a,
              // needed to highlight these as strings and to avoid issues with
              // illegal characters that might be inside urls that would tigger the
              // languages illegal stack
              {
                begin: /(url|data-uri)\(/,
                end: /\)/,
                relevance: 0,
                // from keywords
                keywords: { built_in: "url data-uri" },
                contains: [
                  ...a,
                  {
                    className: "string",
                    // any character other than `)` as in `url()` will be the start
                    // of a string, which ends with `)` (from the parent mode)
                    begin: /[^)]/,
                    endsWithParent: true,
                    excludeEnd: true
                  }
                ]
              },
              t.FUNCTION_DISPATCH
            ]
          },
          {
            begin: e.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            // break on Less variables @var: ...
            contains: [
              {
                className: "keyword",
                begin: s
              },
              {
                begin: /\s/,
                endsWithParent: true,
                excludeEnd: true,
                relevance: 0,
                keywords: {
                  $pattern: /[a-z-]+/,
                  keyword: i2,
                  attribute: cw.join(" ")
                },
                contains: [
                  {
                    begin: /[a-z-]+(?=:)/,
                    className: "attribute"
                  },
                  ...a,
                  t.CSS_NUMBER_MODE
                ]
              }
            ]
          },
          {
            className: "selector-tag",
            begin: "\\b(" + uw.join("|") + ")\\b"
          }
        ]
      };
    }
    function fw(n2) {
      const e = n2.regex;
      return {
        name: "Diff",
        aliases: ["patch"],
        contains: [
          {
            className: "meta",
            relevance: 10,
            match: e.either(
              /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
              /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
              /^--- +\d+,\d+ +----$/
            )
          },
          {
            className: "comment",
            variants: [
              {
                begin: e.either(
                  /Index: /,
                  /^index/,
                  /={3,}/,
                  /^-{3}/,
                  /^\*{3} /,
                  /^\+{3}/,
                  /^diff --git/
                ),
                end: /$/
              },
              { match: /^\*{15}$/ }
            ]
          },
          {
            className: "addition",
            begin: /^\+/,
            end: /$/
          },
          {
            className: "deletion",
            begin: /^-/,
            end: /$/
          },
          {
            className: "addition",
            begin: /^!/,
            end: /$/
          }
        ]
      };
    }
    function gw(n2) {
      const s = {
        keyword: [
          "break",
          "case",
          "chan",
          "const",
          "continue",
          "default",
          "defer",
          "else",
          "fallthrough",
          "for",
          "func",
          "go",
          "goto",
          "if",
          "import",
          "interface",
          "map",
          "package",
          "range",
          "return",
          "select",
          "struct",
          "switch",
          "type",
          "var"
        ],
        type: [
          "bool",
          "byte",
          "complex64",
          "complex128",
          "error",
          "float32",
          "float64",
          "int8",
          "int16",
          "int32",
          "int64",
          "string",
          "uint8",
          "uint16",
          "uint32",
          "uint64",
          "int",
          "uint",
          "uintptr",
          "rune"
        ],
        literal: [
          "true",
          "false",
          "iota",
          "nil"
        ],
        built_in: [
          "append",
          "cap",
          "close",
          "complex",
          "copy",
          "imag",
          "len",
          "make",
          "new",
          "panic",
          "print",
          "println",
          "real",
          "recover",
          "delete"
        ]
      };
      return {
        name: "Go",
        aliases: ["golang"],
        keywords: s,
        illegal: "</",
        contains: [
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          {
            className: "string",
            variants: [
              n2.QUOTE_STRING_MODE,
              n2.APOS_STRING_MODE,
              {
                begin: "`",
                end: "`"
              }
            ]
          },
          {
            className: "number",
            variants: [
              {
                match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
                // hex without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
                // hex with a present digit before . (making a digit afterwards optional)
                relevance: 0
              },
              {
                match: /-?\b0[oO](_?[0-7])*i?/,
                // leading 0o octal
                relevance: 0
              },
              {
                match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
                // decimal without a present digit before . (making a digit afterwards required)
                relevance: 0
              },
              {
                match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
                // decimal with a present digit before . (making a digit afterwards optional)
                relevance: 0
              }
            ]
          },
          {
            begin: /:=/
            // relevance booster
          },
          {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [
              n2.TITLE_MODE,
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: s,
                illegal: /["']/
              }
            ]
          }
        ]
      };
    }
    function hw(n2) {
      const e = n2.regex, t = /[_A-Za-z][_0-9A-Za-z]*/;
      return {
        name: "GraphQL",
        aliases: ["gql"],
        case_insensitive: true,
        disableAutodetect: false,
        keywords: {
          keyword: [
            "query",
            "mutation",
            "subscription",
            "type",
            "input",
            "schema",
            "directive",
            "interface",
            "union",
            "scalar",
            "fragment",
            "enum",
            "on"
          ],
          literal: [
            "true",
            "false",
            "null"
          ]
        },
        contains: [
          n2.HASH_COMMENT_MODE,
          n2.QUOTE_STRING_MODE,
          n2.NUMBER_MODE,
          {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          },
          {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          },
          {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          },
          {
            scope: "meta",
            match: /@\w+/,
            excludeEnd: true
          },
          {
            scope: "symbol",
            begin: e.concat(t, e.lookahead(/\s*:/)),
            relevance: 0
          }
        ],
        illegal: [
          /[;<']/,
          /BEGIN/
        ]
      };
    }
    function vw(n2) {
      const e = n2.regex, t = {
        className: "number",
        relevance: 0,
        variants: [
          { begin: /([+-]+)?[\d]+_[\d_]+/ },
          { begin: n2.NUMBER_RE }
        ]
      }, o = n2.COMMENT();
      o.variants = [
        {
          begin: /;/,
          end: /$/
        },
        {
          begin: /#/,
          end: /$/
        }
      ];
      const i2 = {
        className: "variable",
        variants: [
          { begin: /\$[\w\d"][\w\d_]*/ },
          { begin: /\$\{(.*?)\}/ }
        ]
      }, s = {
        className: "literal",
        begin: /\bon|off|true|false|yes|no\b/
      }, r = {
        className: "string",
        contains: [n2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: "'''",
            end: "'''",
            relevance: 10
          },
          {
            begin: '"""',
            end: '"""',
            relevance: 10
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: "'",
            end: "'"
          }
        ]
      }, a = {
        begin: /\[/,
        end: /\]/,
        contains: [
          o,
          s,
          i2,
          r,
          t,
          "self"
        ],
        relevance: 0
      }, l = /[A-Za-z0-9_-]+/, u = /"(\\"|[^"])*"/, c2 = /'[^']*'/, d = e.either(
        l,
        u,
        c2
      ), p2 = e.concat(
        d,
        "(\\s*\\.\\s*",
        d,
        ")*",
        e.lookahead(/\s*=\s*[^#\s]/)
      );
      return {
        name: "TOML, also INI",
        aliases: ["toml"],
        case_insensitive: true,
        illegal: /\S/,
        contains: [
          o,
          {
            className: "section",
            begin: /\[+/,
            end: /\]+/
          },
          {
            begin: p2,
            className: "attr",
            starts: {
              end: /$/,
              contains: [
                o,
                a,
                s,
                i2,
                r,
                t
              ]
            }
          }
        ]
      };
    }
    var qo = "[0-9](_*[0-9])*", gs = `\\.(${qo})`, hs = "[0-9a-fA-F](_*[0-9a-fA-F])*", Ec = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${qo})((${gs})|\\.)?|(${gs}))[eE][+-]?(${qo})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${qo})((${gs})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${gs})[fFdD]?\\b` },
        { begin: `\\b(${qo})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hs})\\.?|(${hs})?\\.(${hs}))[pP][+-]?(${qo})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${hs})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function Qp(n2, e, t) {
      return t === -1 ? "" : n2.replace(e, (o) => Qp(n2, e, t - 1));
    }
    function bw(n2) {
      const e = n2.regex, t = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", o = t + Qp("(?:<" + t + "~~~(?:\\s*,\\s*" + t + "~~~)*>)?", /~~~/g, 2), l = {
        keyword: [
          "synchronized",
          "abstract",
          "private",
          "var",
          "static",
          "if",
          "const ",
          "for",
          "while",
          "strictfp",
          "finally",
          "protected",
          "import",
          "native",
          "final",
          "void",
          "enum",
          "else",
          "break",
          "transient",
          "catch",
          "instanceof",
          "volatile",
          "case",
          "assert",
          "package",
          "default",
          "public",
          "try",
          "switch",
          "continue",
          "throws",
          "protected",
          "public",
          "private",
          "module",
          "requires",
          "exports",
          "do",
          "sealed",
          "yield",
          "permits",
          "goto",
          "when"
        ],
        literal: [
          "false",
          "true",
          "null"
        ],
        type: [
          "char",
          "boolean",
          "long",
          "float",
          "int",
          "byte",
          "short",
          "double"
        ],
        built_in: [
          "super",
          "this"
        ]
      }, u = {
        className: "meta",
        begin: "@" + t,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"]
            // allow nested () inside our annotation
          }
        ]
      }, c2 = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: l,
        relevance: 0,
        contains: [n2.C_BLOCK_COMMENT_MODE],
        endsParent: true
      };
      return {
        name: "Java",
        aliases: ["jsp"],
        keywords: l,
        illegal: /<\/|#/,
        contains: [
          n2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/,
                  relevance: 0
                },
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [n2.BACKSLASH_ESCAPE]
          },
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE,
          {
            match: [
              /\b(?:class|interface|enum|extends|implements|new)/,
              /\s+/,
              t
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            // Exceptions for hyphenated keywords
            match: /non-sealed/,
            scope: "keyword"
          },
          {
            begin: [
              e.concat(/(?!else)/, t),
              /\s+/,
              t,
              /\s+/,
              /=(?!=)/
            ],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          },
          {
            begin: [
              /record/,
              /\s+/,
              t
            ],
            className: {
              1: "keyword",
              3: "title.class"
            },
            contains: [
              c2,
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: "new throw return else",
            relevance: 0
          },
          {
            begin: [
              "(?:" + o + "\\s+)",
              n2.UNDERSCORE_IDENT_RE,
              /\s*(?=\()/
            ],
            className: { 2: "title.function" },
            keywords: l,
            contains: [
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: l,
                relevance: 0,
                contains: [
                  u,
                  n2.APOS_STRING_MODE,
                  n2.QUOTE_STRING_MODE,
                  Ec,
                  n2.C_BLOCK_COMMENT_MODE
                ]
              },
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          Ec,
          u
        ]
      };
    }
    const Cc = "[A-Za-z$_][0-9A-Za-z$_]*", kw = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], yw = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], e_ = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], n_ = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], t_ = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], jw = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], ww = [].concat(
      t_,
      e_,
      n_
    );
    function Ew(n2) {
      const e = n2.regex, t = (L, { after: V }) => {
        const te = "</" + L[0].slice(1);
        return L.input.indexOf(te, V) !== -1;
      }, o = Cc, i2 = {
        begin: "<>",
        end: "</>"
      }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, r = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, V) => {
          const te = L[0].length + L.index, ae = L.input[te];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ae === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ae === ","
          ) {
            V.ignoreMatch();
            return;
          }
          ae === ">" && (t(L, { after: te }) || V.ignoreMatch());
          let ye;
          const Pe = L.input.substring(te);
          if (ye = Pe.match(/^\s*=/)) {
            V.ignoreMatch();
            return;
          }
          if ((ye = Pe.match(/^\s+extends\s+/)) && ye.index === 0) {
            V.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: Cc,
        keyword: kw,
        literal: yw,
        built_in: ww,
        "variable.language": jw
      }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c2 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${c2})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${c2})\\b((${u})\\b|\\.)?|(${u})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, _ = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, m = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, f = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, b = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          n2.BACKSLASH_ESCAPE,
          p2
        ]
      }, y = {
        className: "comment",
        variants: [
          n2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: o + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          n2.C_BLOCK_COMMENT_MODE,
          n2.C_LINE_COMMENT_MODE
        ]
      }, C = [
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE,
        _,
        m,
        f,
        b,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = C.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(C)
      });
      const v = [].concat(y, p2.contains), x = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: x
      }, F = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              o,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(o, "(", e.concat(/\./, o), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              o
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, Y = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...e_,
            ...n_
          ]
        }
      }, q = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, K = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              o,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, ie2 = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function ce(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const ve = {
        match: e.concat(
          /\b/,
          ce([
            ...t_,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          o,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, he = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(o, /(?![0-9A-Za-z$_(])/)
        )),
        end: o,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, de = {
        match: [
          /get|set/,
          /\s+/,
          o,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, pe = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          o,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(pe)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: Y },
        illegal: /#(?![$_A-z])/,
        contains: [
          n2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          q,
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE,
          _,
          m,
          f,
          b,
          y,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          Y,
          {
            scope: "attr",
            match: o + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + n2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              y,
              n2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: pe,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: n2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: x
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: i2.begin, end: i2.end },
                  { match: s },
                  {
                    begin: r.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": r.isTrulyOpeningTag,
                    end: r.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: r.begin,
                    end: r.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          K,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + n2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              n2.inherit(n2.TITLE_MODE, { begin: o, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          he,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + o,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ve,
          ie2,
          F,
          de,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function Cw(n2) {
      const e = {
        className: "attr",
        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
        relevance: 1.01
      }, t = {
        match: /[{}[\],:]/,
        className: "punctuation",
        relevance: 0
      }, o = [
        "true",
        "false",
        "null"
      ], i2 = {
        scope: "literal",
        beginKeywords: o.join(" ")
      };
      return {
        name: "JSON",
        aliases: ["jsonc"],
        keywords: {
          literal: o
        },
        contains: [
          e,
          t,
          n2.QUOTE_STRING_MODE,
          i2,
          n2.C_NUMBER_MODE,
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE
        ],
        illegal: "\\S"
      };
    }
    var Ko = "[0-9](_*[0-9])*", vs = `\\.(${Ko})`, bs = "[0-9a-fA-F](_*[0-9a-fA-F])*", Sw = {
      className: "number",
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${Ko})((${vs})|\\.)?|(${vs}))[eE][+-]?(${Ko})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${Ko})((${vs})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${vs})[fFdD]?\\b` },
        { begin: `\\b(${Ko})[fFdD]\\b` },
        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${bs})\\.?|(${bs})?\\.(${bs}))[pP][+-]?(${Ko})[fFdD]?\\b` },
        // DecimalIntegerLiteral
        { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
        // HexIntegerLiteral
        { begin: `\\b0[xX](${bs})[lL]?\\b` },
        // OctalIntegerLiteral
        { begin: "\\b0(_*[0-7])*[lL]?\\b" },
        // BinaryIntegerLiteral
        { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
      ],
      relevance: 0
    };
    function xw(n2) {
      const e = {
        keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
        built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
        literal: "true false null"
      }, t = {
        className: "keyword",
        begin: /\b(break|continue|return|this)\b/,
        starts: { contains: [
          {
            className: "symbol",
            begin: /@\w+/
          }
        ] }
      }, o = {
        className: "symbol",
        begin: n2.UNDERSCORE_IDENT_RE + "@"
      }, i2 = {
        className: "subst",
        begin: /\$\{/,
        end: /\}/,
        contains: [n2.C_NUMBER_MODE]
      }, s = {
        className: "variable",
        begin: "\\$" + n2.UNDERSCORE_IDENT_RE
      }, r = {
        className: "string",
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              s,
              i2
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [n2.BACKSLASH_ESCAPE]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              s,
              i2
            ]
          }
        ]
      };
      i2.contains.push(r);
      const a = {
        className: "meta",
        begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + n2.UNDERSCORE_IDENT_RE + ")?"
      }, l = {
        className: "meta",
        begin: "@" + n2.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              n2.inherit(r, { className: "string" }),
              "self"
            ]
          }
        ]
      }, u = Sw, c2 = n2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [n2.C_BLOCK_COMMENT_MODE] }
      ), d = { variants: [
        {
          className: "type",
          begin: n2.UNDERSCORE_IDENT_RE
        },
        {
          begin: /\(/,
          end: /\)/,
          contains: []
          // defined later
        }
      ] }, p2 = d;
      return p2.variants[1].contains = [d], d.variants[1].contains = [p2], {
        name: "Kotlin",
        aliases: [
          "kt",
          "kts"
        ],
        keywords: e,
        contains: [
          n2.COMMENT(
            "/\\*\\*",
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                }
              ]
            }
          ),
          n2.C_LINE_COMMENT_MODE,
          c2,
          t,
          o,
          a,
          l,
          {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: e,
            relevance: 5,
            contains: [
              {
                begin: n2.UNDERSCORE_IDENT_RE + "\\s*\\(",
                returnBegin: true,
                relevance: 0,
                contains: [n2.UNDERSCORE_TITLE_MODE]
              },
              {
                className: "type",
                begin: /</,
                end: />/,
                keywords: "reified",
                relevance: 0
              },
              {
                className: "params",
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: e,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      d,
                      n2.C_LINE_COMMENT_MODE,
                      c2
                    ],
                    relevance: 0
                  },
                  n2.C_LINE_COMMENT_MODE,
                  c2,
                  a,
                  l,
                  r,
                  n2.C_NUMBER_MODE
                ]
              },
              c2
            ]
          },
          {
            begin: [
              /class|interface|trait/,
              /\s+/,
              n2.UNDERSCORE_IDENT_RE
            ],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [
              { beginKeywords: "public protected internal private constructor" },
              n2.UNDERSCORE_TITLE_MODE,
              {
                className: "type",
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: "type",
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              a,
              l
            ]
          },
          r,
          {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: `
`
          },
          u
        ]
      };
    }
    const Tw = (n2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), Aw = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], Nw = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], Ow = [
      ...Aw,
      ...Nw
    ], Mw = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), o_ = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), i_ = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), Rw = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse(), Iw = o_.concat(i_).sort().reverse();
    function Lw(n2) {
      const e = Tw(n2), t = Iw, o = "and or not only", i2 = "[\\w-]+", s = "(" + i2 + "|@\\{" + i2 + "\\})", r = [], a = [], l = function(C) {
        return {
          // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
          className: "string",
          begin: "~?" + C + ".*?" + C
        };
      }, u = function(C, v, x) {
        return {
          className: C,
          begin: v,
          relevance: x
        };
      }, c2 = {
        $pattern: /[a-z-]+/,
        keyword: o,
        attribute: Mw.join(" ")
      }, d = {
        // used only to properly balance nested parens inside mixin call, def. arg list
        begin: "\\(",
        end: "\\)",
        contains: a,
        keywords: c2,
        relevance: 0
      };
      a.push(
        n2.C_LINE_COMMENT_MODE,
        n2.C_BLOCK_COMMENT_MODE,
        l("'"),
        l('"'),
        e.CSS_NUMBER_MODE,
        // fixme: it does not include dot for numbers like .5em :(
        {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        },
        e.HEXCOLOR,
        d,
        u("variable", "@@?" + i2, 10),
        u("variable", "@\\{" + i2 + "\\}"),
        u("built_in", "~?`[^`]*?`"),
        // inline javascript (or whatever host language) *multiline* string
        {
          // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
          className: "attribute",
          begin: i2 + "\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        },
        e.IMPORTANT,
        { beginKeywords: "and not" },
        e.FUNCTION_DISPATCH
      );
      const p2 = a.concat({
        begin: /\{/,
        end: /\}/,
        contains: r
      }), _ = {
        beginKeywords: "when",
        endsWithParent: true,
        contains: [{ beginKeywords: "and not" }].concat(a)
        // using this form to override VALUEs 'function' match
      }, m = {
        begin: s + "\\s*:",
        returnBegin: true,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + Rw.join("|") + ")\\b",
            end: /(?=:)/,
            starts: {
              endsWithParent: true,
              illegal: "[<=$]",
              relevance: 0,
              contains: a
            }
          }
        ]
      }, f = {
        className: "keyword",
        begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
        starts: {
          end: "[;{}]",
          keywords: c2,
          returnEnd: true,
          contains: a,
          relevance: 0
        }
      }, b = {
        className: "variable",
        variants: [
          // using more strict pattern for higher relevance to increase chances of Less detection.
          // this is *the only* Less specific statement used in most of the sources, so...
          // (well still often loose to the css-parser unless there's '//' comment,
          // simply because 1 variable just can't beat 99 properties :)
          {
            begin: "@" + i2 + "\\s*:",
            relevance: 15
          },
          { begin: "@" + i2 }
        ],
        starts: {
          end: "[;}]",
          returnEnd: true,
          contains: p2
        }
      }, h2 = {
        // first parse unambiguous selectors (i.e. those not starting with tag)
        // then fall into the scary lookahead-discriminator variant.
        // this mode also handles mixin definitions and calls
        variants: [
          {
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
            // mixin calls end with ';'
          },
          {
            begin: s,
            end: /\{/
          }
        ],
        returnBegin: true,
        returnEnd: true,
        illegal: `[<='$"]`,
        relevance: 0,
        contains: [
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          _,
          u("keyword", "all\\b"),
          u("variable", "@\\{" + i2 + "\\}"),
          // otherwise its identified as tag
          {
            begin: "\\b(" + Ow.join("|") + ")\\b",
            className: "selector-tag"
          },
          e.CSS_NUMBER_MODE,
          u("selector-tag", s, 0),
          u("selector-id", "#" + s),
          u("selector-class", "\\." + s, 0),
          u("selector-tag", "&", 0),
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-pseudo",
            begin: ":(" + o_.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + i_.join("|") + ")"
          },
          {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: p2
          },
          // argument list of parametric mixins
          { begin: "!important" },
          // eat !important after mixin call or it will be colored as tag
          e.FUNCTION_DISPATCH
        ]
      }, y = {
        begin: i2 + `:(:)?(${t.join("|")})`,
        returnBegin: true,
        contains: [h2]
      };
      return r.push(
        n2.C_LINE_COMMENT_MODE,
        n2.C_BLOCK_COMMENT_MODE,
        f,
        b,
        y,
        m,
        h2,
        _,
        e.FUNCTION_DISPATCH
      ), {
        name: "Less",
        case_insensitive: true,
        illegal: `[=>'/<($"]`,
        contains: r
      };
    }
    function Dw(n2) {
      const e = "\\[=*\\[", t = "\\]=*\\]", o = {
        begin: e,
        end: t,
        contains: ["self"]
      }, i2 = [
        n2.COMMENT("--(?!" + e + ")", "$"),
        n2.COMMENT(
          "--" + e,
          t,
          {
            contains: [o],
            relevance: 10
          }
        )
      ];
      return {
        name: "Lua",
        aliases: ["pluto"],
        keywords: {
          $pattern: n2.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: (
            // Metatags and globals:
            "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
          )
        },
        contains: i2.concat([
          {
            className: "function",
            beginKeywords: "function",
            end: "\\)",
            contains: [
              n2.inherit(n2.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
              {
                className: "params",
                begin: "\\(",
                endsWithParent: true,
                contains: i2
              }
            ].concat(i2)
          },
          n2.C_NUMBER_MODE,
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE,
          {
            className: "string",
            begin: e,
            end: t,
            contains: [o],
            relevance: 5
          }
        ])
      };
    }
    function Bw(n2) {
      const e = {
        className: "variable",
        variants: [
          {
            begin: "\\$\\(" + n2.UNDERSCORE_IDENT_RE + "\\)",
            contains: [n2.BACKSLASH_ESCAPE]
          },
          { begin: /\$[@%<?\^\+\*]/ }
        ]
      }, t = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          n2.BACKSLASH_ESCAPE,
          e
        ]
      }, o = {
        className: "variable",
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
        contains: [
          e,
          t
          // Added QUOTE_STRING as they can be a part of functions
        ]
      }, i2 = { begin: "^" + n2.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, s = {
        className: "meta",
        begin: /^\.PHONY:/,
        end: /$/,
        keywords: {
          $pattern: /[\.\w]+/,
          keyword: ".PHONY"
        }
      }, r = {
        className: "section",
        begin: /^[^\s]+:/,
        end: /$/,
        contains: [e]
      };
      return {
        name: "Makefile",
        aliases: [
          "mk",
          "mak",
          "make"
        ],
        keywords: {
          $pattern: /[\w-]+/,
          keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
        },
        contains: [
          n2.HASH_COMMENT_MODE,
          e,
          t,
          o,
          i2,
          s,
          r
        ]
      };
    }
    function Pw(n2) {
      const e = n2.regex, t = {
        begin: /<\/?[A-Za-z_]/,
        end: ">",
        subLanguage: "xml",
        relevance: 0
      }, o = {
        begin: "^[-\\*]{3,}",
        end: "$"
      }, i2 = {
        className: "code",
        variants: [
          // TODO: fix to allow these to work with sublanguage also
          { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
          { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
          // needed to allow markdown as a sublanguage to work
          {
            begin: "```",
            end: "```+[ ]*$"
          },
          {
            begin: "~~~",
            end: "~~~+[ ]*$"
          },
          { begin: "`.+?`" },
          {
            begin: "(?=^( {4}|\\t))",
            // use contains to gobble up multiple lines to allow the block to be whatever size
            // but only have a single open/close tag vs one per line
            contains: [
              {
                begin: "^( {4}|\\t)",
                end: "(\\n)$"
              }
            ],
            relevance: 0
          }
        ]
      }, s = {
        className: "bullet",
        begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
        end: "\\s+",
        excludeEnd: true
      }, r = {
        begin: /^\[[^\n]+\]:/,
        returnBegin: true,
        contains: [
          {
            className: "symbol",
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "link",
            begin: /:\s*/,
            end: /$/,
            excludeBegin: true
          }
        ]
      }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
        variants: [
          // too much like nested array access in so many languages
          // to have any real relevance
          {
            begin: /\[.+?\]\[.*?\]/,
            relevance: 0
          },
          // popular internet URLs
          {
            begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
            relevance: 2
          },
          {
            begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
            relevance: 2
          },
          // relative urls
          {
            begin: /\[.+?\]\([./?&#].*?\)/,
            relevance: 1
          },
          // whatever else, lower relevance (might not be a link at all)
          {
            begin: /\[.*?\]\(.*?\)/,
            relevance: 0
          }
        ],
        returnBegin: true,
        contains: [
          {
            // empty strings for alt or link text
            match: /\[(?=\])/
          },
          {
            className: "string",
            relevance: 0,
            begin: "\\[",
            end: "\\]",
            excludeBegin: true,
            returnEnd: true
          },
          {
            className: "link",
            relevance: 0,
            begin: "\\]\\(",
            end: "\\)",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "symbol",
            relevance: 0,
            begin: "\\]\\[",
            end: "\\]",
            excludeBegin: true,
            excludeEnd: true
          }
        ]
      }, u = {
        className: "strong",
        contains: [],
        // defined later
        variants: [
          {
            begin: /_{2}(?!\s)/,
            end: /_{2}/
          },
          {
            begin: /\*{2}(?!\s)/,
            end: /\*{2}/
          }
        ]
      }, c2 = {
        className: "emphasis",
        contains: [],
        // defined later
        variants: [
          {
            begin: /\*(?![*\s])/,
            end: /\*/
          },
          {
            begin: /_(?![_\s])/,
            end: /_/,
            relevance: 0
          }
        ]
      }, d = n2.inherit(u, { contains: [] }), p2 = n2.inherit(c2, { contains: [] });
      u.contains.push(p2), c2.contains.push(d);
      let _ = [
        t,
        l
      ];
      return [
        u,
        c2,
        d,
        p2
      ].forEach((h2) => {
        h2.contains = h2.contains.concat(_);
      }), _ = _.concat(u, c2), {
        name: "Markdown",
        aliases: [
          "md",
          "mkdown",
          "mkd"
        ],
        contains: [
          {
            className: "section",
            variants: [
              {
                begin: "^#{1,6}",
                end: "$",
                contains: _
              },
              {
                begin: "(?=^.+?\\n[=-]{2,}$)",
                contains: [
                  { begin: "^[=-]*$" },
                  {
                    begin: "^",
                    end: "\\n",
                    contains: _
                  }
                ]
              }
            ]
          },
          t,
          s,
          u,
          c2,
          {
            className: "quote",
            begin: "^>\\s+",
            contains: _,
            end: "$"
          },
          i2,
          o,
          l,
          r,
          {
            //https://spec.commonmark.org/0.31.2/#entity-references
            scope: "literal",
            match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
          }
        ]
      };
    }
    function $w(n2) {
      const e = {
        className: "built_in",
        begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
      }, t = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
        "variable.language": [
          "this",
          "super"
        ],
        $pattern: t,
        keyword: [
          "while",
          "export",
          "sizeof",
          "typedef",
          "const",
          "struct",
          "for",
          "union",
          "volatile",
          "static",
          "mutable",
          "if",
          "do",
          "return",
          "goto",
          "enum",
          "else",
          "break",
          "extern",
          "asm",
          "case",
          "default",
          "register",
          "explicit",
          "typename",
          "switch",
          "continue",
          "inline",
          "readonly",
          "assign",
          "readwrite",
          "self",
          "@synchronized",
          "id",
          "typeof",
          "nonatomic",
          "IBOutlet",
          "IBAction",
          "strong",
          "weak",
          "copy",
          "in",
          "out",
          "inout",
          "bycopy",
          "byref",
          "oneway",
          "__strong",
          "__weak",
          "__block",
          "__autoreleasing",
          "@private",
          "@protected",
          "@public",
          "@try",
          "@property",
          "@end",
          "@throw",
          "@catch",
          "@finally",
          "@autoreleasepool",
          "@synthesize",
          "@dynamic",
          "@selector",
          "@optional",
          "@required",
          "@encode",
          "@package",
          "@import",
          "@defs",
          "@compatibility_alias",
          "__bridge",
          "__bridge_transfer",
          "__bridge_retained",
          "__bridge_retain",
          "__covariant",
          "__contravariant",
          "__kindof",
          "_Nonnull",
          "_Nullable",
          "_Null_unspecified",
          "__FUNCTION__",
          "__PRETTY_FUNCTION__",
          "__attribute__",
          "getter",
          "setter",
          "retain",
          "unsafe_unretained",
          "nonnull",
          "nullable",
          "null_unspecified",
          "null_resettable",
          "class",
          "instancetype",
          "NS_DESIGNATED_INITIALIZER",
          "NS_UNAVAILABLE",
          "NS_REQUIRES_SUPER",
          "NS_RETURNS_INNER_POINTER",
          "NS_INLINE",
          "NS_AVAILABLE",
          "NS_DEPRECATED",
          "NS_ENUM",
          "NS_OPTIONS",
          "NS_SWIFT_UNAVAILABLE",
          "NS_ASSUME_NONNULL_BEGIN",
          "NS_ASSUME_NONNULL_END",
          "NS_REFINED_FOR_SWIFT",
          "NS_SWIFT_NAME",
          "NS_SWIFT_NOTHROW",
          "NS_DURING",
          "NS_HANDLER",
          "NS_ENDHANDLER",
          "NS_VALUERETURN",
          "NS_VOIDRETURN"
        ],
        literal: [
          "false",
          "true",
          "FALSE",
          "TRUE",
          "nil",
          "YES",
          "NO",
          "NULL"
        ],
        built_in: [
          "dispatch_once_t",
          "dispatch_queue_t",
          "dispatch_sync",
          "dispatch_async",
          "dispatch_once"
        ],
        type: [
          "int",
          "float",
          "char",
          "unsigned",
          "signed",
          "short",
          "long",
          "double",
          "wchar_t",
          "unichar",
          "void",
          "bool",
          "BOOL",
          "id|0",
          "_Bool"
        ]
      }, l = {
        $pattern: t,
        keyword: [
          "@interface",
          "@class",
          "@protocol",
          "@implementation"
        ]
      };
      return {
        name: "Objective-C",
        aliases: [
          "mm",
          "objc",
          "obj-c",
          "obj-c++",
          "objective-c++"
        ],
        keywords: a,
        illegal: "</",
        contains: [
          e,
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          n2.C_NUMBER_MODE,
          n2.QUOTE_STRING_MODE,
          n2.APOS_STRING_MODE,
          {
            className: "string",
            variants: [
              {
                begin: '@"',
                end: '"',
                illegal: "\\n",
                contains: [n2.BACKSLASH_ESCAPE]
              }
            ]
          },
          {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
            contains: [
              {
                begin: /\\\n/,
                relevance: 0
              },
              n2.inherit(n2.QUOTE_STRING_MODE, { className: "string" }),
              {
                className: "string",
                begin: /<.*?>/,
                end: /$/,
                illegal: "\\n"
              },
              n2.C_LINE_COMMENT_MODE,
              n2.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: "class",
            begin: "(" + l.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: l,
            contains: [n2.UNDERSCORE_TITLE_MODE]
          },
          {
            begin: "\\." + n2.UNDERSCORE_IDENT_RE,
            relevance: 0
          }
        ]
      };
    }
    function zw(n2) {
      const e = n2.regex, t = [
        "abs",
        "accept",
        "alarm",
        "and",
        "atan2",
        "bind",
        "binmode",
        "bless",
        "break",
        "caller",
        "chdir",
        "chmod",
        "chomp",
        "chop",
        "chown",
        "chr",
        "chroot",
        "class",
        "close",
        "closedir",
        "connect",
        "continue",
        "cos",
        "crypt",
        "dbmclose",
        "dbmopen",
        "defined",
        "delete",
        "die",
        "do",
        "dump",
        "each",
        "else",
        "elsif",
        "endgrent",
        "endhostent",
        "endnetent",
        "endprotoent",
        "endpwent",
        "endservent",
        "eof",
        "eval",
        "exec",
        "exists",
        "exit",
        "exp",
        "fcntl",
        "field",
        "fileno",
        "flock",
        "for",
        "foreach",
        "fork",
        "format",
        "formline",
        "getc",
        "getgrent",
        "getgrgid",
        "getgrnam",
        "gethostbyaddr",
        "gethostbyname",
        "gethostent",
        "getlogin",
        "getnetbyaddr",
        "getnetbyname",
        "getnetent",
        "getpeername",
        "getpgrp",
        "getpriority",
        "getprotobyname",
        "getprotobynumber",
        "getprotoent",
        "getpwent",
        "getpwnam",
        "getpwuid",
        "getservbyname",
        "getservbyport",
        "getservent",
        "getsockname",
        "getsockopt",
        "given",
        "glob",
        "gmtime",
        "goto",
        "grep",
        "gt",
        "hex",
        "if",
        "index",
        "int",
        "ioctl",
        "join",
        "keys",
        "kill",
        "last",
        "lc",
        "lcfirst",
        "length",
        "link",
        "listen",
        "local",
        "localtime",
        "log",
        "lstat",
        "lt",
        "ma",
        "map",
        "method",
        "mkdir",
        "msgctl",
        "msgget",
        "msgrcv",
        "msgsnd",
        "my",
        "ne",
        "next",
        "no",
        "not",
        "oct",
        "open",
        "opendir",
        "or",
        "ord",
        "our",
        "pack",
        "package",
        "pipe",
        "pop",
        "pos",
        "print",
        "printf",
        "prototype",
        "push",
        "q|0",
        "qq",
        "quotemeta",
        "qw",
        "qx",
        "rand",
        "read",
        "readdir",
        "readline",
        "readlink",
        "readpipe",
        "recv",
        "redo",
        "ref",
        "rename",
        "require",
        "reset",
        "return",
        "reverse",
        "rewinddir",
        "rindex",
        "rmdir",
        "say",
        "scalar",
        "seek",
        "seekdir",
        "select",
        "semctl",
        "semget",
        "semop",
        "send",
        "setgrent",
        "sethostent",
        "setnetent",
        "setpgrp",
        "setpriority",
        "setprotoent",
        "setpwent",
        "setservent",
        "setsockopt",
        "shift",
        "shmctl",
        "shmget",
        "shmread",
        "shmwrite",
        "shutdown",
        "sin",
        "sleep",
        "socket",
        "socketpair",
        "sort",
        "splice",
        "split",
        "sprintf",
        "sqrt",
        "srand",
        "stat",
        "state",
        "study",
        "sub",
        "substr",
        "symlink",
        "syscall",
        "sysopen",
        "sysread",
        "sysseek",
        "system",
        "syswrite",
        "tell",
        "telldir",
        "tie",
        "tied",
        "time",
        "times",
        "tr",
        "truncate",
        "uc",
        "ucfirst",
        "umask",
        "undef",
        "unless",
        "unlink",
        "unpack",
        "unshift",
        "untie",
        "until",
        "use",
        "utime",
        "values",
        "vec",
        "wait",
        "waitpid",
        "wantarray",
        "warn",
        "when",
        "while",
        "write",
        "x|0",
        "xor",
        "y|0"
      ], o = /[dualxmsipngr]{0,12}/, i2 = {
        $pattern: /[\w.]+/,
        keyword: t.join(" ")
      }, s = {
        className: "subst",
        begin: "[$@]\\{",
        end: "\\}",
        keywords: i2
      }, r = {
        begin: /->\{/,
        end: /\}/
        // contains defined later
      }, a = {
        scope: "attr",
        match: /\s+:\s*\w+(\s*\(.*?\))?/
      }, l = {
        scope: "variable",
        variants: [
          { begin: /\$\d/ },
          {
            begin: e.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              // negative look-ahead tries to avoid matching patterns that are not
              // Perl at all like $ident$, @ident@, etc.
              "(?![A-Za-z])(?![@$%])"
            )
          },
          {
            // Only $= is a special Perl variable and one can't declare @= or %=.
            begin: /[$%@](?!")[^\s\w{=]|\$=/,
            relevance: 0
          }
        ],
        contains: [a]
      }, u = {
        className: "number",
        variants: [
          // decimal numbers:
          // include the case where a number starts with a dot (eg. .9), and
          // the leading 0? avoids mixing the first and second match on 0.x cases
          { match: /0?\.[0-9][0-9_]+\b/ },
          // include the special versioned number (eg. v5.38)
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          // non-decimal numbers:
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ }
        ],
        relevance: 0
      }, c2 = [
        n2.BACKSLASH_ESCAPE,
        s,
        l
      ], d = [
        /!/,
        /\//,
        /\|/,
        /\?/,
        /'/,
        /"/,
        // valid but infrequent and weird
        /#/
        // valid but infrequent and weird
      ], p2 = (f, b, h2 = "\\1") => {
        const y = h2 === "\\1" ? h2 : e.concat(h2, b);
        return e.concat(
          e.concat("(?:", f, ")"),
          b,
          /(?:\\.|[^\\\/])*?/,
          y,
          /(?:\\.|[^\\\/])*?/,
          h2,
          o
        );
      }, _ = (f, b, h2) => e.concat(
        e.concat("(?:", f, ")"),
        b,
        /(?:\\.|[^\\\/])*?/,
        h2,
        o
      ), m = [
        l,
        n2.HASH_COMMENT_MODE,
        n2.COMMENT(
          /^=\w/,
          /=cut/,
          { endsWithParent: true }
        ),
        r,
        {
          className: "string",
          contains: c2,
          variants: [
            {
              begin: "q[qwxr]?\\s*\\(",
              end: "\\)",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\[",
              end: "\\]",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\{",
              end: "\\}",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*\\|",
              end: "\\|",
              relevance: 5
            },
            {
              begin: "q[qwxr]?\\s*<",
              end: ">",
              relevance: 5
            },
            {
              begin: "qw\\s+q",
              end: "q",
              relevance: 5
            },
            {
              begin: "'",
              end: "'",
              contains: [n2.BACKSLASH_ESCAPE]
            },
            {
              begin: '"',
              end: '"'
            },
            {
              begin: "`",
              end: "`",
              contains: [n2.BACKSLASH_ESCAPE]
            },
            {
              begin: /\{\w+\}/,
              relevance: 0
            },
            {
              begin: "-?\\w+\\s*=>",
              relevance: 0
            }
          ]
        },
        u,
        {
          // regexp container
          begin: "(\\/\\/|" + n2.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [
            n2.HASH_COMMENT_MODE,
            {
              className: "regexp",
              variants: [
                // allow matching common delimiters
                { begin: p2("s|tr|y", e.either(...d, { capture: true })) },
                // and then paired delmis
                { begin: p2("s|tr|y", "\\(", "\\)") },
                { begin: p2("s|tr|y", "\\[", "\\]") },
                { begin: p2("s|tr|y", "\\{", "\\}") }
              ],
              relevance: 2
            },
            {
              className: "regexp",
              variants: [
                {
                  // could be a comment in many languages so do not count
                  // as relevant
                  begin: /(m|qr)\/\//,
                  relevance: 0
                },
                // prefix is optional with /regex/
                { begin: _("(?:m|qr)?", /\//, /\//) },
                // allow matching common delimiters
                { begin: _("m|qr", e.either(...d, { capture: true }), /\1/) },
                // allow common paired delmins
                { begin: _("m|qr", /\(/, /\)/) },
                { begin: _("m|qr", /\[/, /\]/) },
                { begin: _("m|qr", /\{/, /\}/) }
              ]
            }
          ]
        },
        {
          className: "function",
          beginKeywords: "sub method",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [n2.TITLE_MODE, a]
        },
        {
          className: "class",
          beginKeywords: "class",
          end: "[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [n2.TITLE_MODE, a, u]
        },
        {
          begin: "-\\w\\b",
          relevance: 0
        },
        {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [
            {
              begin: "^@@.*",
              end: "$",
              className: "comment"
            }
          ]
        }
      ];
      return s.contains = m, r.contains = m, {
        name: "Perl",
        aliases: [
          "pl",
          "pm"
        ],
        keywords: i2,
        contains: m
      };
    }
    function Fw(n2) {
      const e = n2.regex, t = /(?![A-Za-z0-9])(?![$])/, o = e.concat(
        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
        t
      ), i2 = e.concat(
        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
        t
      ), s = e.concat(
        /[A-Z]+/,
        t
      ), r = {
        scope: "variable",
        match: "\\$+" + o
      }, a = {
        scope: "meta",
        variants: [
          { begin: /<\?php/, relevance: 10 },
          // boost for obvious PHP
          { begin: /<\?=/ },
          // less relevant per PSR-1 which says not to use short-tags
          { begin: /<\?/, relevance: 0.1 },
          { begin: /\?>/ }
          // end php tag
        ]
      }, l = {
        scope: "subst",
        variants: [
          { begin: /\$\w+/ },
          {
            begin: /\{\$/,
            end: /\}/
          }
        ]
      }, u = n2.inherit(n2.APOS_STRING_MODE, { illegal: null }), c2 = n2.inherit(n2.QUOTE_STRING_MODE, {
        illegal: null,
        contains: n2.QUOTE_STRING_MODE.contains.concat(l)
      }), d = {
        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
        end: /[ \t]*(\w+)\b/,
        contains: n2.QUOTE_STRING_MODE.contains.concat(l),
        "on:begin": (he, de) => {
          de.data._beginMatch = he[1] || he[2];
        },
        "on:end": (he, de) => {
          de.data._beginMatch !== he[1] && de.ignoreMatch();
        }
      }, p2 = n2.END_SAME_AS_BEGIN({
        begin: /<<<[ \t]*'(\w+)'\n/,
        end: /[ \t]*(\w+)\b/
      }), _ = `[ 	
]`, m = {
        scope: "string",
        variants: [
          c2,
          u,
          d,
          p2
        ]
      }, f = {
        scope: "number",
        variants: [
          { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
          // Binary w/ underscore support
          { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
          // Octals w/ underscore support
          { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
          // Hex w/ underscore support
          // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
          { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
        ],
        relevance: 0
      }, b = [
        "false",
        "null",
        "true"
      ], h2 = [
        // Magic constants:
        // <https://www.php.net/manual/en/language.constants.predefined.php>
        "__CLASS__",
        "__DIR__",
        "__FILE__",
        "__FUNCTION__",
        "__COMPILER_HALT_OFFSET__",
        "__LINE__",
        "__METHOD__",
        "__NAMESPACE__",
        "__TRAIT__",
        // Function that look like language construct or language construct that look like function:
        // List of keywords that may not require parenthesis
        "die",
        "echo",
        "exit",
        "include",
        "include_once",
        "print",
        "require",
        "require_once",
        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
        // Other keywords:
        // <https://www.php.net/manual/en/reserved.php>
        // <https://www.php.net/manual/en/language.types.type-juggling.php>
        "array",
        "abstract",
        "and",
        "as",
        "binary",
        "bool",
        "boolean",
        "break",
        "callable",
        "case",
        "catch",
        "class",
        "clone",
        "const",
        "continue",
        "declare",
        "default",
        "do",
        "double",
        "else",
        "elseif",
        "empty",
        "enddeclare",
        "endfor",
        "endforeach",
        "endif",
        "endswitch",
        "endwhile",
        "enum",
        "eval",
        "extends",
        "final",
        "finally",
        "float",
        "for",
        "foreach",
        "from",
        "global",
        "goto",
        "if",
        "implements",
        "instanceof",
        "insteadof",
        "int",
        "integer",
        "interface",
        "isset",
        "iterable",
        "list",
        "match|0",
        "mixed",
        "new",
        "never",
        "object",
        "or",
        "private",
        "protected",
        "public",
        "readonly",
        "real",
        "return",
        "string",
        "switch",
        "throw",
        "trait",
        "try",
        "unset",
        "use",
        "var",
        "void",
        "while",
        "xor",
        "yield"
      ], y = [
        // Standard PHP library:
        // <https://www.php.net/manual/en/book.spl.php>
        "Error|0",
        "AppendIterator",
        "ArgumentCountError",
        "ArithmeticError",
        "ArrayIterator",
        "ArrayObject",
        "AssertionError",
        "BadFunctionCallException",
        "BadMethodCallException",
        "CachingIterator",
        "CallbackFilterIterator",
        "CompileError",
        "Countable",
        "DirectoryIterator",
        "DivisionByZeroError",
        "DomainException",
        "EmptyIterator",
        "ErrorException",
        "Exception",
        "FilesystemIterator",
        "FilterIterator",
        "GlobIterator",
        "InfiniteIterator",
        "InvalidArgumentException",
        "IteratorIterator",
        "LengthException",
        "LimitIterator",
        "LogicException",
        "MultipleIterator",
        "NoRewindIterator",
        "OutOfBoundsException",
        "OutOfRangeException",
        "OuterIterator",
        "OverflowException",
        "ParentIterator",
        "ParseError",
        "RangeException",
        "RecursiveArrayIterator",
        "RecursiveCachingIterator",
        "RecursiveCallbackFilterIterator",
        "RecursiveDirectoryIterator",
        "RecursiveFilterIterator",
        "RecursiveIterator",
        "RecursiveIteratorIterator",
        "RecursiveRegexIterator",
        "RecursiveTreeIterator",
        "RegexIterator",
        "RuntimeException",
        "SeekableIterator",
        "SplDoublyLinkedList",
        "SplFileInfo",
        "SplFileObject",
        "SplFixedArray",
        "SplHeap",
        "SplMaxHeap",
        "SplMinHeap",
        "SplObjectStorage",
        "SplObserver",
        "SplPriorityQueue",
        "SplQueue",
        "SplStack",
        "SplSubject",
        "SplTempFileObject",
        "TypeError",
        "UnderflowException",
        "UnexpectedValueException",
        "UnhandledMatchError",
        // Reserved interfaces:
        // <https://www.php.net/manual/en/reserved.interfaces.php>
        "ArrayAccess",
        "BackedEnum",
        "Closure",
        "Fiber",
        "Generator",
        "Iterator",
        "IteratorAggregate",
        "Serializable",
        "Stringable",
        "Throwable",
        "Traversable",
        "UnitEnum",
        "WeakReference",
        "WeakMap",
        // Reserved classes:
        // <https://www.php.net/manual/en/reserved.classes.php>
        "Directory",
        "__PHP_Incomplete_Class",
        "parent",
        "php_user_filter",
        "self",
        "static",
        "stdClass"
      ], v = {
        keyword: h2,
        literal: ((he) => {
          const de = [];
          return he.forEach((pe) => {
            de.push(pe), pe.toLowerCase() === pe ? de.push(pe.toUpperCase()) : de.push(pe.toLowerCase());
          }), de;
        })(b),
        built_in: y
      }, x = (he) => he.map((de) => de.replace(/\|\d+$/, "")), S = { variants: [
        {
          match: [
            /new/,
            e.concat(_, "+"),
            // to prevent built ins from being confused as the class constructor call
            e.concat("(?!", x(y).join("\\b|"), "\\b)"),
            i2
          ],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }
      ] }, F = e.concat(o, "\\b(?!\\()"), Y = { variants: [
        {
          match: [
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            F
          ],
          scope: { 2: "variable.constant" }
        },
        {
          match: [
            /::/,
            /class/
          ],
          scope: { 2: "variable.language" }
        },
        {
          match: [
            i2,
            e.concat(
              /::/,
              e.lookahead(/(?!class\b)/)
            ),
            F
          ],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        },
        {
          match: [
            i2,
            e.concat(
              "::",
              e.lookahead(/(?!class\b)/)
            )
          ],
          scope: { 1: "title.class" }
        },
        {
          match: [
            i2,
            /::/,
            /class/
          ],
          scope: {
            1: "title.class",
            3: "variable.language"
          }
        }
      ] }, q = {
        scope: "attr",
        match: e.concat(o, e.lookahead(":"), e.lookahead(/(?!::)/))
      }, K = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: v,
        contains: [
          q,
          r,
          Y,
          n2.C_BLOCK_COMMENT_MODE,
          m,
          f,
          S
        ]
      }, ie2 = {
        relevance: 0,
        match: [
          /\b/,
          // to prevent keywords from being confused as the function title
          e.concat("(?!fn\\b|function\\b|", x(h2).join("\\b|"), "|", x(y).join("\\b|"), "\\b)"),
          o,
          e.concat(_, "*"),
          e.lookahead(/(?=\()/)
        ],
        scope: { 3: "title.function.invoke" },
        contains: [K]
      };
      K.contains.push(ie2);
      const ce = [
        q,
        Y,
        n2.C_BLOCK_COMMENT_MODE,
        m,
        f,
        S
      ], ve = {
        begin: e.concat(
          /#\[\s*\\?/,
          e.either(
            i2,
            s
          )
        ),
        beginScope: "meta",
        end: /]/,
        endScope: "meta",
        keywords: {
          literal: b,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: {
              literal: b,
              keyword: [
                "new",
                "array"
              ]
            },
            contains: [
              "self",
              ...ce
            ]
          },
          ...ce,
          {
            scope: "meta",
            variants: [
              { match: i2 },
              { match: s }
            ]
          }
        ]
      };
      return {
        case_insensitive: false,
        keywords: v,
        contains: [
          ve,
          n2.HASH_COMMENT_MODE,
          n2.COMMENT("//", "$"),
          n2.COMMENT(
            "/\\*",
            "\\*/",
            { contains: [
              {
                scope: "doctag",
                match: "@[A-Za-z]+"
              }
            ] }
          ),
          {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: n2.MATCH_NOTHING_RE,
              contains: [
                {
                  match: /\?>/,
                  scope: "meta",
                  endsParent: true
                }
              ]
            }
          },
          a,
          {
            scope: "variable.language",
            match: /\$this\b/
          },
          r,
          ie2,
          Y,
          {
            match: [
              /const/,
              /\s/,
              o
            ],
            scope: {
              1: "keyword",
              3: "variable.constant"
            }
          },
          S,
          {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [
              { beginKeywords: "use" },
              n2.UNDERSCORE_TITLE_MODE,
              {
                begin: "=>",
                // No markup, just a relevance booster
                endsParent: true
              },
              {
                scope: "params",
                begin: "\\(",
                end: "\\)",
                excludeBegin: true,
                excludeEnd: true,
                keywords: v,
                contains: [
                  "self",
                  ve,
                  r,
                  Y,
                  n2.C_BLOCK_COMMENT_MODE,
                  m,
                  f
                ]
              }
            ]
          },
          {
            scope: "class",
            variants: [
              {
                beginKeywords: "enum",
                illegal: /[($"]/
              },
              {
                beginKeywords: "class interface trait",
                illegal: /[:($"]/
              }
            ],
            relevance: 0,
            end: /\{/,
            excludeEnd: true,
            contains: [
              { beginKeywords: "extends implements" },
              n2.UNDERSCORE_TITLE_MODE
            ]
          },
          // both use and namespace still use "old style" rules (vs multi-match)
          // because the namespace name can include `\` and we still want each
          // element to be treated as its own *individual* title
          {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [n2.inherit(n2.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          },
          {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [
              // TODO: title.function vs title.class
              {
                match: /\b(as|const|function)\b/,
                scope: "keyword"
              },
              // TODO: could be title.class or title.function
              n2.UNDERSCORE_TITLE_MODE
            ]
          },
          m,
          f
        ]
      };
    }
    function Hw(n2) {
      return {
        name: "PHP template",
        subLanguage: "xml",
        contains: [
          {
            begin: /<\?(php|=)?/,
            end: /\?>/,
            subLanguage: "php",
            contains: [
              // We don't want the php closing tag ?> to close the PHP block when
              // inside any of the following blocks:
              {
                begin: "/\\*",
                end: "\\*/",
                skip: true
              },
              {
                begin: 'b"',
                end: '"',
                skip: true
              },
              {
                begin: "b'",
                end: "'",
                skip: true
              },
              n2.inherit(n2.APOS_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              }),
              n2.inherit(n2.QUOTE_STRING_MODE, {
                illegal: null,
                className: null,
                contains: null,
                skip: true
              })
            ]
          }
        ]
      };
    }
    function Uw(n2) {
      return {
        name: "Plain text",
        aliases: [
          "text",
          "txt"
        ],
        disableAutodetect: true
      };
    }
    function qw(n2) {
      const e = n2.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), o = [
        "and",
        "as",
        "assert",
        "async",
        "await",
        "break",
        "case",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "match",
        "nonlocal|10",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield"
      ], a = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: o,
        built_in: [
          "__import__",
          "abs",
          "all",
          "any",
          "ascii",
          "bin",
          "bool",
          "breakpoint",
          "bytearray",
          "bytes",
          "callable",
          "chr",
          "classmethod",
          "compile",
          "complex",
          "delattr",
          "dict",
          "dir",
          "divmod",
          "enumerate",
          "eval",
          "exec",
          "filter",
          "float",
          "format",
          "frozenset",
          "getattr",
          "globals",
          "hasattr",
          "hash",
          "help",
          "hex",
          "id",
          "input",
          "int",
          "isinstance",
          "issubclass",
          "iter",
          "len",
          "list",
          "locals",
          "map",
          "max",
          "memoryview",
          "min",
          "next",
          "object",
          "oct",
          "open",
          "ord",
          "pow",
          "print",
          "property",
          "range",
          "repr",
          "reversed",
          "round",
          "set",
          "setattr",
          "slice",
          "sorted",
          "staticmethod",
          "str",
          "sum",
          "super",
          "tuple",
          "type",
          "vars",
          "zip"
        ],
        literal: [
          "__debug__",
          "Ellipsis",
          "False",
          "None",
          "NotImplemented",
          "True"
        ],
        type: [
          "Any",
          "Callable",
          "Coroutine",
          "Dict",
          "List",
          "Literal",
          "Generic",
          "Optional",
          "Sequence",
          "Set",
          "Tuple",
          "Type",
          "Union"
        ]
      }, l = {
        className: "meta",
        begin: /^(>>>|\.\.\.) /
      }, u = {
        className: "subst",
        begin: /\{/,
        end: /\}/,
        keywords: a,
        illegal: /#/
      }, c2 = {
        begin: /\{\{/,
        relevance: 0
      }, d = {
        className: "string",
        contains: [n2.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              l
            ],
            relevance: 10
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              l,
              c2,
              u
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              l,
              c2,
              u
            ]
          },
          {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          },
          {
            begin: /([uU]|[rR])"/,
            end: /"/,
            relevance: 10
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          },
          {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              c2,
              u
            ]
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [
              n2.BACKSLASH_ESCAPE,
              c2,
              u
            ]
          },
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE
        ]
      }, p2 = "[0-9](_?[0-9])*", _ = `(\\b(${p2}))?\\.(${p2})|\\b(${p2})\\.`, m = `\\b|${o.join("|")}`, f = {
        className: "number",
        relevance: 0,
        variants: [
          // exponentfloat, pointfloat
          // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
          // optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          // Note: no leading \b because floats can start with a decimal point
          // and we don't want to mishandle e.g. `fn(.5)`,
          // no trailing \b for pointfloat because it can end with a decimal point
          // and we don't want to mishandle e.g. `0..hex()`; this should be safe
          // because both MUST contain a decimal point and so cannot be confused with
          // the interior part of an identifier
          {
            begin: `(\\b(${p2})|(${_}))[eE][+-]?(${p2})[jJ]?(?=${m})`
          },
          {
            begin: `(${_})[jJ]?`
          },
          // decinteger, bininteger, octinteger, hexinteger
          // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
          // optionally "long" in Python 2
          // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
          // decinteger is optionally imaginary
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${m})`
          },
          {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${m})`
          },
          {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${m})`
          },
          {
            begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${m})`
          },
          // imagnumber (digitpart-based)
          // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
          {
            begin: `\\b(${p2})[jJ](?=${m})`
          }
        ]
      }, b = {
        className: "comment",
        begin: e.lookahead(/# type:/),
        end: /$/,
        keywords: a,
        contains: [
          {
            // prevent keywords from coloring `type`
            begin: /# type:/
          },
          // comment within a datatype comment includes no keywords
          {
            begin: /#/,
            end: /\b\B/,
            endsWithParent: true
          }
        ]
      }, h2 = {
        className: "params",
        variants: [
          // Exclude params in functions without params
          {
            className: "",
            begin: /\(\s*\)/,
            skip: true
          },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: a,
            contains: [
              "self",
              l,
              f,
              d,
              n2.HASH_COMMENT_MODE
            ]
          }
        ]
      };
      return u.contains = [
        d,
        f,
        l
      ], {
        name: "Python",
        aliases: [
          "py",
          "gyp",
          "ipython"
        ],
        unicodeRegex: true,
        keywords: a,
        illegal: /(<\/|\?)|=>/,
        contains: [
          l,
          f,
          {
            // very common convention
            scope: "variable.language",
            match: /\bself\b/
          },
          {
            // eat "if" prior to string so that it won't accidentally be
            // labeled as an f-string
            beginKeywords: "if",
            relevance: 0
          },
          { match: /\bor\b/, scope: "keyword" },
          d,
          b,
          n2.HASH_COMMENT_MODE,
          {
            match: [
              /\bdef/,
              /\s+/,
              t
            ],
            scope: {
              1: "keyword",
              3: "title.function"
            },
            contains: [h2]
          },
          {
            variants: [
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  t,
                  /\s*/,
                  /\(\s*/,
                  t,
                  /\s*\)/
                ]
              },
              {
                match: [
                  /\bclass/,
                  /\s+/,
                  t
                ]
              }
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              6: "title.class.inherited"
            }
          },
          {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [
              f,
              h2,
              d
            ]
          }
        ]
      };
    }
    function Kw(n2) {
      return {
        aliases: ["pycon"],
        contains: [
          {
            className: "meta.prompt",
            starts: {
              // a space separates the REPL prefix from the actual code
              // this is purely for cleaner HTML output
              end: / |$/,
              starts: {
                end: "$",
                subLanguage: "python"
              }
            },
            variants: [
              { begin: /^>>>(?=[ ]|$)/ },
              { begin: /^\.\.\.(?=[ ]|$)/ }
            ]
          }
        ]
      };
    }
    function Vw(n2) {
      const e = n2.regex, t = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, o = e.either(
        // Special case: only hexadecimal binary powers can contain fractions
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        // Hexadecimal numbers without fraction and optional binary power
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        // Decimal numbers
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ), i2 = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, s = e.either(
        /[()]/,
        /[{}]/,
        /\[\[/,
        /[[\]]/,
        /\\/,
        /,/
      );
      return {
        name: "R",
        keywords: {
          $pattern: t,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: (
            // Builtin constants
            "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
          )
        },
        contains: [
          // Roxygen comments
          n2.COMMENT(
            /#'/,
            /$/,
            { contains: [
              {
                // Handle `@examples` separately to cause all subsequent code
                // until the next `@`-tag on its own line to be kept as-is,
                // preventing highlighting. This code is example R code, so nested
                // doctags shouldnt be treated as such. See
                // `test/markup/r/roxygen.txt` for an example.
                scope: "doctag",
                match: /@examples/,
                starts: {
                  end: e.lookahead(e.either(
                    // end if another doc comment
                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                    // or a line with no comment
                    /\n^(?!#')/
                  )),
                  endsParent: true
                }
              },
              {
                // Handle `@param` to highlight the parameter name following
                // after.
                scope: "doctag",
                begin: "@param",
                end: /$/,
                contains: [
                  {
                    scope: "variable",
                    variants: [
                      { match: t },
                      { match: /`(?:\\.|[^`\\])+`/ }
                    ],
                    endsParent: true
                  }
                ]
              },
              {
                scope: "doctag",
                match: /@[a-zA-Z]+/
              },
              {
                scope: "keyword",
                match: /\\[a-zA-Z]+/
              }
            ] }
          ),
          n2.HASH_COMMENT_MODE,
          {
            scope: "string",
            contains: [n2.BACKSLASH_ESCAPE],
            variants: [
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\(/,
                end: /\)(-*)"/
              }),
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\{/,
                end: /\}(-*)"/
              }),
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]"(-*)\[/,
                end: /\](-*)"/
              }),
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\(/,
                end: /\)(-*)'/
              }),
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\{/,
                end: /\}(-*)'/
              }),
              n2.END_SAME_AS_BEGIN({
                begin: /[rR]'(-*)\[/,
                end: /\](-*)'/
              }),
              {
                begin: '"',
                end: '"',
                relevance: 0
              },
              {
                begin: "'",
                end: "'",
                relevance: 0
              }
            ]
          },
          // Matching numbers immediately following punctuation and operators is
          // tricky since we need to look at the character ahead of a number to
          // ensure the number is not part of an identifier, and we cannot use
          // negative look-behind assertions. So instead we explicitly handle all
          // possible combinations of (operator|punctuation), number.
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            relevance: 0,
            variants: [
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  i2,
                  o
                ]
              },
              {
                scope: {
                  1: "operator",
                  2: "number"
                },
                match: [
                  /%[^%]*%/,
                  o
                ]
              },
              {
                scope: {
                  1: "punctuation",
                  2: "number"
                },
                match: [
                  s,
                  o
                ]
              },
              {
                scope: { 2: "number" },
                match: [
                  /[^a-zA-Z0-9._]|^/,
                  // not part of an identifier, or start of document
                  o
                ]
              }
            ]
          },
          // Operators/punctuation when they're not directly followed by numbers
          {
            // Relevance boost for the most common assignment form.
            scope: { 3: "operator" },
            match: [
              t,
              /\s+/,
              /<-/,
              /\s+/
            ]
          },
          {
            scope: "operator",
            relevance: 0,
            variants: [
              { match: i2 },
              { match: /%[^%]*%/ }
            ]
          },
          {
            scope: "punctuation",
            relevance: 0,
            match: s
          },
          {
            // Escaped identifier
            begin: "`",
            end: "`",
            contains: [{ begin: /\\./ }]
          }
        ]
      };
    }
    function Ww(n2) {
      const e = n2.regex, t = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", o = e.either(
        /\b([A-Z]+[a-z0-9]+)+/,
        // ends in caps
        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
      ), i2 = e.concat(o, /(::\w+)*/), r = {
        "variable.constant": [
          "__FILE__",
          "__LINE__",
          "__ENCODING__"
        ],
        "variable.language": [
          "self",
          "super"
        ],
        keyword: [
          "alias",
          "and",
          "begin",
          "BEGIN",
          "break",
          "case",
          "class",
          "defined",
          "do",
          "else",
          "elsif",
          "end",
          "END",
          "ensure",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "require",
          "rescue",
          "retry",
          "return",
          "then",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          ...[
            "include",
            "extend",
            "prepend",
            "public",
            "private",
            "protected",
            "raise",
            "throw"
          ]
        ],
        built_in: [
          "proc",
          "lambda",
          "attr_accessor",
          "attr_reader",
          "attr_writer",
          "define_method",
          "private_constant",
          "module_function"
        ],
        literal: [
          "true",
          "false",
          "nil"
        ]
      }, a = {
        className: "doctag",
        begin: "@[A-Za-z]+"
      }, l = {
        begin: "#<",
        end: ">"
      }, u = [
        n2.COMMENT(
          "#",
          "$",
          { contains: [a] }
        ),
        n2.COMMENT(
          "^=begin",
          "^=end",
          {
            contains: [a],
            relevance: 10
          }
        ),
        n2.COMMENT("^__END__", n2.MATCH_NOTHING_RE)
      ], c2 = {
        className: "subst",
        begin: /#\{/,
        end: /\}/,
        keywords: r
      }, d = {
        className: "string",
        contains: [
          n2.BACKSLASH_ESCAPE,
          c2
        ],
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /`/,
            end: /`/
          },
          {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          },
          {
            begin: /%[qQwWx]?\[/,
            end: /\]/
          },
          {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          },
          {
            begin: /%[qQwWx]?</,
            end: />/
          },
          {
            begin: /%[qQwWx]?\//,
            end: /\//
          },
          {
            begin: /%[qQwWx]?%/,
            end: /%/
          },
          {
            begin: /%[qQwWx]?-/,
            end: /-/
          },
          {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          },
          // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
          // where ? is the last character of a preceding identifier, as in: `func?4`
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          // heredocs
          {
            // this guard makes sure that we have an entire heredoc and not a false
            // positive (auto-detect, etc.)
            begin: e.concat(
              /<<[-~]?'?/,
              e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
            ),
            contains: [
              n2.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [
                  n2.BACKSLASH_ESCAPE,
                  c2
                ]
              })
            ]
          }
        ]
      }, p2 = "[1-9](_?[0-9])*|0", _ = "[0-9](_?[0-9])*", m = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal integer/float, optionally exponential or rational, optionally imaginary
          { begin: `\\b(${p2})(\\.(${_}))?([eE][+-]?(${_})|r)?i?\\b` },
          // explicit decimal/binary/octal/hexadecimal integer,
          // optionally rational and/or imaginary
          { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
          // 0-prefixed implicit octal integer, optionally rational and/or imaginary
          { begin: "\\b0(_?[0-7])+r?i?\\b" }
        ]
      }, f = {
        variants: [
          {
            match: /\(\)/
          },
          {
            className: "params",
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: true,
            endsParent: true,
            keywords: r
          }
        ]
      }, S = [
        d,
        {
          variants: [
            {
              match: [
                /class\s+/,
                i2,
                /\s+<\s+/,
                i2
              ]
            },
            {
              match: [
                /\b(class|module)\s+/,
                i2
              ]
            }
          ],
          scope: {
            2: "title.class",
            4: "title.class.inherited"
          },
          keywords: r
        },
        {
          match: [
            /(include|extend)\s+/,
            i2
          ],
          scope: {
            2: "title.class"
          },
          keywords: r
        },
        {
          relevance: 0,
          match: [
            i2,
            /\.new[. (]/
          ],
          scope: {
            1: "title.class"
          }
        },
        {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        },
        {
          relevance: 0,
          match: o,
          scope: "title.class"
        },
        {
          match: [
            /def/,
            /\s+/,
            t
          ],
          scope: {
            1: "keyword",
            3: "title.function"
          },
          contains: [
            f
          ]
        },
        {
          // swallow namespace qualifiers before symbols
          begin: n2.IDENT_RE + "::"
        },
        {
          className: "symbol",
          begin: n2.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        },
        {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [
            d,
            { begin: t }
          ],
          relevance: 0
        },
        m,
        {
          // negative-look forward attempts to prevent false matches like:
          // @ident@ or $ident$ that might indicate this is not ruby at all
          className: "variable",
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
        },
        {
          className: "params",
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          // this could be a lot of things (in other languages) other than params
          keywords: r
        },
        {
          // regexp container
          begin: "(" + n2.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [
            {
              className: "regexp",
              contains: [
                n2.BACKSLASH_ESCAPE,
                c2
              ],
              illegal: /\n/,
              variants: [
                {
                  begin: "/",
                  end: "/[a-z]*"
                },
                {
                  begin: /%r\{/,
                  end: /\}[a-z]*/
                },
                {
                  begin: "%r\\(",
                  end: "\\)[a-z]*"
                },
                {
                  begin: "%r!",
                  end: "![a-z]*"
                },
                {
                  begin: "%r\\[",
                  end: "\\][a-z]*"
                }
              ]
            }
          ].concat(l, u),
          relevance: 0
        }
      ].concat(l, u);
      c2.contains = S, f.contains = S;
      const K = [
        {
          begin: /^\s*=>/,
          starts: {
            end: "$",
            contains: S
          }
        },
        {
          className: "meta.prompt",
          begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
          starts: {
            end: "$",
            keywords: r,
            contains: S
          }
        }
      ];
      return u.unshift(l), {
        name: "Ruby",
        aliases: [
          "rb",
          "gemspec",
          "podspec",
          "thor",
          "irb"
        ],
        keywords: r,
        illegal: /\/\*/,
        contains: [n2.SHEBANG({ binary: "ruby" })].concat(K).concat(u).concat(S)
      };
    }
    function Gw(n2) {
      const e = n2.regex, t = /(r#)?/, o = e.concat(t, n2.UNDERSCORE_IDENT_RE), i2 = e.concat(t, n2.IDENT_RE), s = {
        className: "title.function.invoke",
        relevance: 0,
        begin: e.concat(
          /\b/,
          /(?!let|for|while|if|else|match\b)/,
          i2,
          e.lookahead(/\s*\(/)
        )
      }, r = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
        "abstract",
        "as",
        "async",
        "await",
        "become",
        "box",
        "break",
        "const",
        "continue",
        "crate",
        "do",
        "dyn",
        "else",
        "enum",
        "extern",
        "false",
        "final",
        "fn",
        "for",
        "if",
        "impl",
        "in",
        "let",
        "loop",
        "macro",
        "match",
        "mod",
        "move",
        "mut",
        "override",
        "priv",
        "pub",
        "ref",
        "return",
        "self",
        "Self",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "try",
        "type",
        "typeof",
        "union",
        "unsafe",
        "unsized",
        "use",
        "virtual",
        "where",
        "while",
        "yield"
      ], l = [
        "true",
        "false",
        "Some",
        "None",
        "Ok",
        "Err"
      ], u = [
        // functions
        "drop ",
        // traits
        "Copy",
        "Send",
        "Sized",
        "Sync",
        "Drop",
        "Fn",
        "FnMut",
        "FnOnce",
        "ToOwned",
        "Clone",
        "Debug",
        "PartialEq",
        "PartialOrd",
        "Eq",
        "Ord",
        "AsRef",
        "AsMut",
        "Into",
        "From",
        "Default",
        "Iterator",
        "Extend",
        "IntoIterator",
        "DoubleEndedIterator",
        "ExactSizeIterator",
        "SliceConcatExt",
        "ToString",
        // macros
        "assert!",
        "assert_eq!",
        "bitflags!",
        "bytes!",
        "cfg!",
        "col!",
        "concat!",
        "concat_idents!",
        "debug_assert!",
        "debug_assert_eq!",
        "env!",
        "eprintln!",
        "panic!",
        "file!",
        "format!",
        "format_args!",
        "include_bytes!",
        "include_str!",
        "line!",
        "local_data_key!",
        "module_path!",
        "option_env!",
        "print!",
        "println!",
        "select!",
        "stringify!",
        "try!",
        "unimplemented!",
        "unreachable!",
        "vec!",
        "write!",
        "writeln!",
        "macro_rules!",
        "assert_ne!",
        "debug_assert_ne!"
      ], c2 = [
        "i8",
        "i16",
        "i32",
        "i64",
        "i128",
        "isize",
        "u8",
        "u16",
        "u32",
        "u64",
        "u128",
        "usize",
        "f32",
        "f64",
        "str",
        "char",
        "bool",
        "Box",
        "Option",
        "Result",
        "String",
        "Vec"
      ];
      return {
        name: "Rust",
        aliases: ["rs"],
        keywords: {
          $pattern: n2.IDENT_RE + "!?",
          type: c2,
          keyword: a,
          literal: l,
          built_in: u
        },
        illegal: "</",
        contains: [
          n2.C_LINE_COMMENT_MODE,
          n2.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
          n2.inherit(n2.QUOTE_STRING_MODE, {
            begin: /b?"/,
            illegal: null
          }),
          {
            className: "symbol",
            // negative lookahead to avoid matching `'`
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
          },
          {
            scope: "string",
            variants: [
              { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
              {
                begin: /b?'/,
                end: /'/,
                contains: [
                  {
                    scope: "char.escape",
                    match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
                  }
                ]
              }
            ]
          },
          {
            className: "number",
            variants: [
              { begin: "\\b0b([01_]+)" + r },
              { begin: "\\b0o([0-7_]+)" + r },
              { begin: "\\b0x([A-Fa-f0-9_]+)" + r },
              { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r }
            ],
            relevance: 0
          },
          {
            begin: [
              /fn/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.function"
            }
          },
          {
            className: "meta",
            begin: "#!?\\[",
            end: "\\]",
            contains: [
              {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [
                  n2.BACKSLASH_ESCAPE
                ]
              }
            ]
          },
          {
            begin: [
              /let/,
              /\s+/,
              /(?:mut\s+)?/,
              o
            ],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          },
          // must come before impl/for rule later
          {
            begin: [
              /for/,
              /\s+/,
              o,
              /\s+/,
              /in/
            ],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          },
          {
            begin: [
              /type/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: [
              /(?:trait|enum|struct|union|impl|for)/,
              /\s+/,
              o
            ],
            className: {
              1: "keyword",
              3: "title.class"
            }
          },
          {
            begin: n2.IDENT_RE + "::",
            keywords: {
              keyword: "Self",
              built_in: u,
              type: c2
            }
          },
          {
            className: "punctuation",
            begin: "->"
          },
          s
        ]
      };
    }
    const Yw = (n2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: n2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: {
        className: "built_in",
        begin: /[\w-]+(?=\()/
      },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE
        ]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: n2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: {
        className: "attr",
        begin: /--[A-Za-z_][A-Za-z0-9_-]*/
      }
    }), Jw = [
      "a",
      "abbr",
      "address",
      "article",
      "aside",
      "audio",
      "b",
      "blockquote",
      "body",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "dd",
      "del",
      "details",
      "dfn",
      "div",
      "dl",
      "dt",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "mark",
      "menu",
      "nav",
      "object",
      "ol",
      "optgroup",
      "option",
      "p",
      "picture",
      "q",
      "quote",
      "samp",
      "section",
      "select",
      "source",
      "span",
      "strong",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "ul",
      "var",
      "video"
    ], Zw = [
      "defs",
      "g",
      "marker",
      "mask",
      "pattern",
      "svg",
      "switch",
      "symbol",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feFlood",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence",
      "linearGradient",
      "radialGradient",
      "stop",
      "circle",
      "ellipse",
      "image",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "text",
      "use",
      "textPath",
      "tspan",
      "foreignObject",
      "clipPath"
    ], Xw = [
      ...Jw,
      ...Zw
    ], Qw = [
      "any-hover",
      "any-pointer",
      "aspect-ratio",
      "color",
      "color-gamut",
      "color-index",
      "device-aspect-ratio",
      "device-height",
      "device-width",
      "display-mode",
      "forced-colors",
      "grid",
      "height",
      "hover",
      "inverted-colors",
      "monochrome",
      "orientation",
      "overflow-block",
      "overflow-inline",
      "pointer",
      "prefers-color-scheme",
      "prefers-contrast",
      "prefers-reduced-motion",
      "prefers-reduced-transparency",
      "resolution",
      "scan",
      "scripting",
      "update",
      "width",
      // TODO: find a better solution?
      "min-width",
      "max-width",
      "min-height",
      "max-height"
    ].sort().reverse(), e1 = [
      "active",
      "any-link",
      "blank",
      "checked",
      "current",
      "default",
      "defined",
      "dir",
      // dir()
      "disabled",
      "drop",
      "empty",
      "enabled",
      "first",
      "first-child",
      "first-of-type",
      "fullscreen",
      "future",
      "focus",
      "focus-visible",
      "focus-within",
      "has",
      // has()
      "host",
      // host or host()
      "host-context",
      // host-context()
      "hover",
      "indeterminate",
      "in-range",
      "invalid",
      "is",
      // is()
      "lang",
      // lang()
      "last-child",
      "last-of-type",
      "left",
      "link",
      "local-link",
      "not",
      // not()
      "nth-child",
      // nth-child()
      "nth-col",
      // nth-col()
      "nth-last-child",
      // nth-last-child()
      "nth-last-col",
      // nth-last-col()
      "nth-last-of-type",
      //nth-last-of-type()
      "nth-of-type",
      //nth-of-type()
      "only-child",
      "only-of-type",
      "optional",
      "out-of-range",
      "past",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "right",
      "root",
      "scope",
      "target",
      "target-within",
      "user-invalid",
      "valid",
      "visited",
      "where"
      // where()
    ].sort().reverse(), n1 = [
      "after",
      "backdrop",
      "before",
      "cue",
      "cue-region",
      "first-letter",
      "first-line",
      "grammar-error",
      "marker",
      "part",
      "placeholder",
      "selection",
      "slotted",
      "spelling-error"
    ].sort().reverse(), t1 = [
      "accent-color",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "all",
      "anchor-name",
      "animation",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "appearance",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "baseline-shift",
      "block-size",
      "border",
      "border-block",
      "border-block-color",
      "border-block-end",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-style",
      "border-block-width",
      "border-bottom",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-color",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline",
      "border-inline-color",
      "border-inline-end",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-style",
      "border-inline-width",
      "border-left",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-radius",
      "border-right",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-spacing",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-style",
      "border-top",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "border-width",
      "bottom",
      "box-align",
      "box-decoration-break",
      "box-direction",
      "box-flex",
      "box-flex-group",
      "box-lines",
      "box-ordinal-group",
      "box-orient",
      "box-pack",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "caption-side",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "columns",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-size",
      "contain-intrinsic-width",
      "container",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cue",
      "cue-after",
      "cue-before",
      "cursor",
      "cx",
      "cy",
      "direction",
      "display",
      "dominant-baseline",
      "empty-cells",
      "enable-background",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex",
      "flex-basis",
      "flex-direction",
      "flex-flow",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "flow",
      "font",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-smooth",
      "font-smoothing",
      "font-stretch",
      "font-style",
      "font-synthesis",
      "font-synthesis-position",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "grid",
      "grid-area",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column",
      "grid-column-end",
      "grid-column-start",
      "grid-gap",
      "grid-row",
      "grid-row-end",
      "grid-row-start",
      "grid-template",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "hanging-punctuation",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "icon",
      "image-orientation",
      "image-rendering",
      "image-resolution",
      "ime-mode",
      "initial-letter",
      "initial-letter-align",
      "inline-size",
      "inset",
      "inset-area",
      "inset-block",
      "inset-block-end",
      "inset-block-start",
      "inset-inline",
      "inset-inline-end",
      "inset-inline-start",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "kerning",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-height",
      "line-height-step",
      "list-style",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin",
      "margin-block",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-trim",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marks",
      "mask",
      "mask-border",
      "mask-border-mode",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-border-slice",
      "mask-border-source",
      "mask-border-width",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-position",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-auto-flow",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "nav-down",
      "nav-index",
      "nav-left",
      "nav-right",
      "nav-up",
      "none",
      "normal",
      "object-fit",
      "object-position",
      "offset",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "orphans",
      "outline",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "overscroll-behavior",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "padding",
      "padding-block",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-break-after",
      "page-break-before",
      "page-break-inside",
      "paint-order",
      "pause",
      "pause-after",
      "pause-before",
      "perspective",
      "perspective-origin",
      "place-content",
      "place-items",
      "place-self",
      "pointer-events",
      "position",
      "position-anchor",
      "position-visibility",
      "print-color-adjust",
      "quotes",
      "r",
      "resize",
      "rest",
      "rest-after",
      "rest-before",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "scale",
      "scroll-behavior",
      "scroll-margin",
      "scroll-margin-block",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-padding",
      "scroll-padding-block",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-timeline",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "speak",
      "speak-as",
      "src",
      // @font-face
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-all",
      "text-align-last",
      "text-anchor",
      "text-combine-upright",
      "text-decoration",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "unicode-bidi",
      "user-modify",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-name",
      "visibility",
      "voice-balance",
      "voice-duration",
      "voice-family",
      "voice-pitch",
      "voice-range",
      "voice-rate",
      "voice-stress",
      "voice-volume",
      "white-space",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "word-wrap",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ].sort().reverse();
    function o1(n2) {
      const e = Yw(n2), t = n1, o = e1, i2 = "@[a-z-]+", s = "and or not only", a = {
        className: "variable",
        begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
        relevance: 0
      };
      return {
        name: "SCSS",
        case_insensitive: true,
        illegal: "[=/|']",
        contains: [
          n2.C_LINE_COMMENT_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          // to recognize keyframe 40% etc which are outside the scope of our
          // attribute value mode
          e.CSS_NUMBER_MODE,
          {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          },
          {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          },
          e.ATTRIBUTE_SELECTOR_MODE,
          {
            className: "selector-tag",
            begin: "\\b(" + Xw.join("|") + ")\\b",
            // was there, before, but why?
            relevance: 0
          },
          {
            className: "selector-pseudo",
            begin: ":(" + o.join("|") + ")"
          },
          {
            className: "selector-pseudo",
            begin: ":(:)?(" + t.join("|") + ")"
          },
          a,
          {
            // pseudo-selector params
            begin: /\(/,
            end: /\)/,
            contains: [e.CSS_NUMBER_MODE]
          },
          e.CSS_VARIABLE,
          {
            className: "attribute",
            begin: "\\b(" + t1.join("|") + ")\\b"
          },
          { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
          {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [
              e.BLOCK_COMMENT,
              a,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE,
              n2.QUOTE_STRING_MODE,
              n2.APOS_STRING_MODE,
              e.IMPORTANT,
              e.FUNCTION_DISPATCH
            ]
          },
          // matching these here allows us to treat them more like regular CSS
          // rules so everything between the {} gets regular rule highlighting,
          // which is what we want for page and font-face
          {
            begin: "@(page|font-face)",
            keywords: {
              $pattern: i2,
              keyword: "@page @font-face"
            }
          },
          {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: s,
              attribute: Qw.join(" ")
            },
            contains: [
              {
                begin: i2,
                className: "keyword"
              },
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              a,
              n2.QUOTE_STRING_MODE,
              n2.APOS_STRING_MODE,
              e.HEXCOLOR,
              e.CSS_NUMBER_MODE
            ]
          },
          e.FUNCTION_DISPATCH
        ]
      };
    }
    function i1(n2) {
      return {
        name: "Shell Session",
        aliases: [
          "console",
          "shellsession"
        ],
        contains: [
          {
            className: "meta.prompt",
            // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
            // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
            // echo /path/to/home > t.exe
            begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
            starts: {
              end: /[^\\](?=\s*$)/,
              subLanguage: "bash"
            }
          }
        ]
      };
    }
    function s1(n2) {
      const e = n2.regex, t = n2.COMMENT("--", "$"), o = {
        scope: "string",
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [{ match: /''/ }]
          }
        ]
      }, i2 = {
        begin: /"/,
        end: /"/,
        contains: [{ match: /""/ }]
      }, s = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ], r = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ], a = [
        "bigint",
        "binary",
        "blob",
        "boolean",
        "char",
        "character",
        "clob",
        "date",
        "dec",
        "decfloat",
        "decimal",
        "float",
        "int",
        "integer",
        "interval",
        "nchar",
        "nclob",
        "national",
        "numeric",
        "real",
        "row",
        "smallint",
        "time",
        "timestamp",
        "varchar",
        "varying",
        // modifier (character varying)
        "varbinary"
      ], l = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ], u = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year"
      ], c2 = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket"
      ], d = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ], p2 = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ], _ = c2, m = [
        ...u,
        ...l
      ].filter((x) => !c2.includes(x)), f = {
        scope: "variable",
        match: /@[a-z0-9][a-z0-9_]*/
      }, b = {
        scope: "operator",
        match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0
      }, h2 = {
        match: e.concat(/\b/, e.either(..._), /\s*\(/),
        relevance: 0,
        keywords: { built_in: _ }
      };
      function y(x) {
        return e.concat(
          /\b/,
          e.either(...x.map((S) => S.replace(/\s+/, "\\s+"))),
          /\b/
        );
      }
      const C = {
        scope: "keyword",
        match: y(p2),
        relevance: 0
      };
      function v(x, {
        exceptions: S,
        when: F
      } = {}) {
        const Y = F;
        return S = S || [], x.map((q) => q.match(/\|\d+$/) || S.includes(q) ? q : Y(q) ? `${q}|0` : q);
      }
      return {
        name: "SQL",
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: v(m, { when: (x) => x.length < 3 }),
          literal: s,
          type: a,
          built_in: d
        },
        contains: [
          {
            scope: "type",
            match: y(r)
          },
          C,
          h2,
          f,
          o,
          i2,
          n2.C_NUMBER_MODE,
          n2.C_BLOCK_COMMENT_MODE,
          t,
          b
        ]
      };
    }
    function s_(n2) {
      return n2 ? typeof n2 == "string" ? n2 : n2.source : null;
    }
    function _i(n2) {
      return qe("(?=", n2, ")");
    }
    function qe(...n2) {
      return n2.map((t) => s_(t)).join("");
    }
    function r1(n2) {
      const e = n2[n2.length - 1];
      return typeof e == "object" && e.constructor === Object ? (n2.splice(n2.length - 1, 1), e) : {};
    }
    function zn(...n2) {
      return "(" + (r1(n2).capture ? "" : "?:") + n2.map((o) => s_(o)).join("|") + ")";
    }
    const Ml = (n2) => qe(
      /\b/,
      n2,
      /\w$/.test(n2) ? /\b/ : /\B/
    ), a1 = [
      "Protocol",
      // contextual
      "Type"
      // contextual
    ].map(Ml), Sc = [
      "init",
      "self"
    ].map(Ml), l1 = [
      "Any",
      "Self"
    ], sa = [
      // strings below will be fed into the regular `keywords` engine while regex
      // will result in additional modes being created to scan for those keywords to
      // avoid conflicts with other rules
      "actor",
      "any",
      // contextual
      "associatedtype",
      "async",
      "await",
      /as\?/,
      // operator
      /as!/,
      // operator
      "as",
      // operator
      "borrowing",
      // contextual
      "break",
      "case",
      "catch",
      "class",
      "consume",
      // contextual
      "consuming",
      // contextual
      "continue",
      "convenience",
      // contextual
      "copy",
      // contextual
      "default",
      "defer",
      "deinit",
      "didSet",
      // contextual
      "distributed",
      "do",
      "dynamic",
      // contextual
      "each",
      "else",
      "enum",
      "extension",
      "fallthrough",
      /fileprivate\(set\)/,
      "fileprivate",
      "final",
      // contextual
      "for",
      "func",
      "get",
      // contextual
      "guard",
      "if",
      "import",
      "indirect",
      // contextual
      "infix",
      // contextual
      /init\?/,
      /init!/,
      "inout",
      /internal\(set\)/,
      "internal",
      "in",
      "is",
      // operator
      "isolated",
      // contextual
      "nonisolated",
      // contextual
      "lazy",
      // contextual
      "let",
      "macro",
      "mutating",
      // contextual
      "nonmutating",
      // contextual
      /open\(set\)/,
      // contextual
      "open",
      // contextual
      "operator",
      "optional",
      // contextual
      "override",
      // contextual
      "package",
      "postfix",
      // contextual
      "precedencegroup",
      "prefix",
      // contextual
      /private\(set\)/,
      "private",
      "protocol",
      /public\(set\)/,
      "public",
      "repeat",
      "required",
      // contextual
      "rethrows",
      "return",
      "set",
      // contextual
      "some",
      // contextual
      "static",
      "struct",
      "subscript",
      "super",
      "switch",
      "throws",
      "throw",
      /try\?/,
      // operator
      /try!/,
      // operator
      "try",
      // operator
      "typealias",
      /unowned\(safe\)/,
      // contextual
      /unowned\(unsafe\)/,
      // contextual
      "unowned",
      // contextual
      "var",
      "weak",
      // contextual
      "where",
      "while",
      "willSet"
      // contextual
    ], xc = [
      "false",
      "nil",
      "true"
    ], u1 = [
      "assignment",
      "associativity",
      "higherThan",
      "left",
      "lowerThan",
      "none",
      "right"
    ], c1 = [
      "#colorLiteral",
      "#column",
      "#dsohandle",
      "#else",
      "#elseif",
      "#endif",
      "#error",
      "#file",
      "#fileID",
      "#fileLiteral",
      "#filePath",
      "#function",
      "#if",
      "#imageLiteral",
      "#keyPath",
      "#line",
      "#selector",
      "#sourceLocation",
      "#warning"
    ], Tc = [
      "abs",
      "all",
      "any",
      "assert",
      "assertionFailure",
      "debugPrint",
      "dump",
      "fatalError",
      "getVaList",
      "isKnownUniquelyReferenced",
      "max",
      "min",
      "numericCast",
      "pointwiseMax",
      "pointwiseMin",
      "precondition",
      "preconditionFailure",
      "print",
      "readLine",
      "repeatElement",
      "sequence",
      "stride",
      "swap",
      "swift_unboxFromSwiftValueWithType",
      "transcode",
      "type",
      "unsafeBitCast",
      "unsafeDowncast",
      "withExtendedLifetime",
      "withUnsafeMutablePointer",
      "withUnsafePointer",
      "withVaList",
      "withoutActuallyEscaping",
      "zip"
    ], r_ = zn(
      /[/=\-+!*%<>&|^~?]/,
      /[\u00A1-\u00A7]/,
      /[\u00A9\u00AB]/,
      /[\u00AC\u00AE]/,
      /[\u00B0\u00B1]/,
      /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
      /[\u2016-\u2017]/,
      /[\u2020-\u2027]/,
      /[\u2030-\u203E]/,
      /[\u2041-\u2053]/,
      /[\u2055-\u205E]/,
      /[\u2190-\u23FF]/,
      /[\u2500-\u2775]/,
      /[\u2794-\u2BFF]/,
      /[\u2E00-\u2E7F]/,
      /[\u3001-\u3003]/,
      /[\u3008-\u3020]/,
      /[\u3030]/
    ), a_ = zn(
      r_,
      /[\u0300-\u036F]/,
      /[\u1DC0-\u1DFF]/,
      /[\u20D0-\u20FF]/,
      /[\uFE00-\uFE0F]/,
      /[\uFE20-\uFE2F]/
      // TODO: The following characters are also allowed, but the regex isn't supported yet.
      // /[\u{E0100}-\u{E01EF}]/u
    ), ra = qe(r_, a_, "*"), l_ = zn(
      /[a-zA-Z_]/,
      /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
      /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
      /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
      /[\u1E00-\u1FFF]/,
      /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
      /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
      /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
      /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
      /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
      /[\uFE47-\uFEFE\uFF00-\uFFFD]/
      // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
      // The following characters are also allowed, but the regexes aren't supported yet.
      // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
      // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
      // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
      // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
    ), Ws = zn(
      l_,
      /\d/,
      /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
    ), Nt = qe(l_, Ws, "*"), ks = qe(/[A-Z]/, Ws, "*"), d1 = [
      "attached",
      "autoclosure",
      qe(/convention\(/, zn("swift", "block", "c"), /\)/),
      "discardableResult",
      "dynamicCallable",
      "dynamicMemberLookup",
      "escaping",
      "freestanding",
      "frozen",
      "GKInspectable",
      "IBAction",
      "IBDesignable",
      "IBInspectable",
      "IBOutlet",
      "IBSegueAction",
      "inlinable",
      "main",
      "nonobjc",
      "NSApplicationMain",
      "NSCopying",
      "NSManaged",
      qe(/objc\(/, Nt, /\)/),
      "objc",
      "objcMembers",
      "propertyWrapper",
      "requires_stored_property_inits",
      "resultBuilder",
      "Sendable",
      "testable",
      "UIApplicationMain",
      "unchecked",
      "unknown",
      "usableFromInline",
      "warn_unqualified_access"
    ], p1 = [
      "iOS",
      "iOSApplicationExtension",
      "macOS",
      "macOSApplicationExtension",
      "macCatalyst",
      "macCatalystApplicationExtension",
      "watchOS",
      "watchOSApplicationExtension",
      "tvOS",
      "tvOSApplicationExtension",
      "swift"
    ];
    function _1(n2) {
      const e = {
        match: /\s+/,
        relevance: 0
      }, t = n2.COMMENT(
        "/\\*",
        "\\*/",
        { contains: ["self"] }
      ), o = [
        n2.C_LINE_COMMENT_MODE,
        t
      ], i2 = {
        match: [
          /\./,
          zn(...a1, ...Sc)
        ],
        className: { 2: "keyword" }
      }, s = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: qe(/\./, zn(...sa)),
        relevance: 0
      }, r = sa.filter((ge) => typeof ge == "string").concat(["_|0"]), a = sa.filter((ge) => typeof ge != "string").concat(l1).map(Ml), l = { variants: [
        {
          className: "keyword",
          match: zn(...a, ...Sc)
        }
      ] }, u = {
        $pattern: zn(
          /\b\w+/,
          // regular keywords
          /#\w+/
          // number keywords
        ),
        keyword: r.concat(c1),
        literal: xc
      }, c2 = [
        i2,
        s,
        l
      ], d = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: qe(/\./, zn(...Tc)),
        relevance: 0
      }, p2 = {
        className: "built_in",
        match: qe(/\b/, zn(...Tc), /(?=\()/)
      }, _ = [
        d,
        p2
      ], m = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
      }, f = {
        className: "operator",
        relevance: 0,
        variants: [
          { match: ra },
          {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: `\\.(\\.|${a_})+`
          }
        ]
      }, b = [
        m,
        f
      ], h2 = "([0-9]_*)+", y = "([0-9a-fA-F]_*)+", C = {
        className: "number",
        relevance: 0,
        variants: [
          // decimal floating-point-literal (subsumes decimal-literal)
          { match: `\\b(${h2})(\\.(${h2}))?([eE][+-]?(${h2}))?\\b` },
          // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
          { match: `\\b0x(${y})(\\.(${y}))?([pP][+-]?(${h2}))?\\b` },
          // octal-literal
          { match: /\b0o([0-7]_*)+\b/ },
          // binary-literal
          { match: /\b0b([01]_*)+\b/ }
        ]
      }, v = (ge = "") => ({
        className: "subst",
        variants: [
          { match: qe(/\\/, ge, /[0\\tnr"']/) },
          { match: qe(/\\/, ge, /u\{[0-9a-fA-F]{1,8}\}/) }
        ]
      }), x = (ge = "") => ({
        className: "subst",
        match: qe(/\\/, ge, /[\t ]*(?:[\r\n]|\r\n)/)
      }), S = (ge = "") => ({
        className: "subst",
        label: "interpol",
        begin: qe(/\\/, ge, /\(/),
        end: /\)/
      }), F = (ge = "") => ({
        begin: qe(ge, /"""/),
        end: qe(/"""/, ge),
        contains: [
          v(ge),
          x(ge),
          S(ge)
        ]
      }), Y = (ge = "") => ({
        begin: qe(ge, /"/),
        end: qe(/"/, ge),
        contains: [
          v(ge),
          S(ge)
        ]
      }), q = {
        className: "string",
        variants: [
          F(),
          F("#"),
          F("##"),
          F("###"),
          Y(),
          Y("#"),
          Y("##"),
          Y("###")
        ]
      }, K = [
        n2.BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [n2.BACKSLASH_ESCAPE]
        }
      ], ie2 = {
        begin: /\/[^\s](?=[^/\n]*\/)/,
        end: /\//,
        contains: K
      }, ce = (ge) => {
        const Hn = qe(ge, /\//), Nn = qe(/\//, ge);
        return {
          begin: Hn,
          end: Nn,
          contains: [
            ...K,
            {
              scope: "comment",
              begin: `#(?!.*${Nn})`,
              end: /$/
            }
          ]
        };
      }, ve = {
        scope: "regexp",
        variants: [
          ce("###"),
          ce("##"),
          ce("#"),
          ie2
        ]
      }, he = { match: qe(/`/, Nt, /`/) }, de = {
        className: "variable",
        match: /\$\d+/
      }, pe = {
        className: "variable",
        match: `\\$${Ws}+`
      }, N = [
        he,
        de,
        pe
      ], L = {
        match: /(@|#(un)?)available/,
        scope: "keyword",
        starts: { contains: [
          {
            begin: /\(/,
            end: /\)/,
            keywords: p1,
            contains: [
              ...b,
              C,
              q
            ]
          }
        ] }
      }, V = {
        scope: "keyword",
        match: qe(/@/, zn(...d1), _i(zn(/\(/, /\s+/)))
      }, te = {
        scope: "meta",
        match: qe(/@/, Nt)
      }, ae = [
        L,
        V,
        te
      ], ye = {
        match: _i(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            // Common Apple frameworks, for relevance boost
            className: "type",
            match: qe(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Ws, "+")
          },
          {
            // Type identifier
            className: "type",
            match: ks,
            relevance: 0
          },
          {
            // Optional type
            match: /[?!]+/,
            relevance: 0
          },
          {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
          },
          {
            // Protocol composition
            match: qe(/\s+&\s+/, _i(ks)),
            relevance: 0
          }
        ]
      }, Pe = {
        begin: /</,
        end: />/,
        keywords: u,
        contains: [
          ...o,
          ...c2,
          ...ae,
          m,
          ye
        ]
      };
      ye.contains.push(Pe);
      const vn = {
        match: qe(Nt, /\s*:/),
        keywords: "_|0",
        relevance: 0
      }, $e = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: u,
        contains: [
          "self",
          vn,
          ...o,
          ve,
          ...c2,
          ..._,
          ...b,
          C,
          q,
          ...N,
          ...ae,
          ye
        ]
      }, Ge = {
        begin: /</,
        end: />/,
        keywords: "repeat each",
        contains: [
          ...o,
          ye
        ]
      }, Gn = {
        begin: zn(
          _i(qe(Nt, /\s*:/)),
          _i(qe(Nt, /\s+/, Nt, /\s*:/))
        ),
        end: /:/,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            match: /\b_\b/
          },
          {
            className: "params",
            match: Nt
          }
        ]
      }, Cn = {
        begin: /\(/,
        end: /\)/,
        keywords: u,
        contains: [
          Gn,
          ...o,
          ...c2,
          ...b,
          C,
          q,
          ...ae,
          ye,
          $e
        ],
        endsParent: true,
        illegal: /["']/
      }, ot = {
        match: [
          /(func|macro)/,
          /\s+/,
          zn(he.match, Nt, ra)
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          Ge,
          Cn,
          e
        ],
        illegal: [
          /\[/,
          /%/
        ]
      }, Sn = {
        match: [
          /\b(?:subscript|init[?!]?)/,
          /\s*(?=[<(])/
        ],
        className: { 1: "keyword" },
        contains: [
          Ge,
          Cn,
          e
        ],
        illegal: /\[|%/
      }, it = {
        match: [
          /operator/,
          /\s+/,
          ra
        ],
        className: {
          1: "keyword",
          3: "title"
        }
      }, xt = {
        begin: [
          /precedencegroup/,
          /\s+/,
          ks
        ],
        className: {
          1: "keyword",
          3: "title"
        },
        contains: [ye],
        keywords: [
          ...u1,
          ...xc
        ],
        end: /}/
      }, ft = {
        match: [
          /class\b/,
          /\s+/,
          /func\b/,
          /\s+/,
          /\b[A-Za-z_][A-Za-z0-9_]*\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword",
          5: "title.function"
        }
      }, Yn = {
        match: [
          /class\b/,
          /\s+/,
          /var\b/
        ],
        scope: {
          1: "keyword",
          3: "keyword"
        }
      }, gt = {
        begin: [
          /(struct|protocol|class|extension|enum|actor)/,
          /\s+/,
          Nt,
          /\s*/
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        },
        keywords: u,
        contains: [
          Ge,
          ...c2,
          {
            begin: /:/,
            end: /\{/,
            keywords: u,
            contains: [
              {
                scope: "title.class.inherited",
                match: ks
              },
              ...c2
            ],
            relevance: 0
          }
        ]
      };
      for (const ge of q.variants) {
        const Hn = ge.contains.find((se) => se.label === "interpol");
        Hn.keywords = u;
        const Nn = [
          ...c2,
          ..._,
          ...b,
          C,
          q,
          ...N
        ];
        Hn.contains = [
          ...Nn,
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              "self",
              ...Nn
            ]
          }
        ];
      }
      return {
        name: "Swift",
        keywords: u,
        contains: [
          ...o,
          ot,
          Sn,
          ft,
          Yn,
          gt,
          it,
          xt,
          {
            beginKeywords: "import",
            end: /$/,
            contains: [...o],
            relevance: 0
          },
          ve,
          ...c2,
          ..._,
          ...b,
          C,
          q,
          ...N,
          ...ae,
          ye,
          $e
        ]
      };
    }
    const Gs = "[A-Za-z$_][0-9A-Za-z$_]*", u_ = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends",
      // It's reached stage 3, which is "recommended for implementation":
      "using"
    ], c_ = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ], d_ = [
      // Fundamental objects
      "Object",
      "Function",
      "Boolean",
      "Symbol",
      // numbers and dates
      "Math",
      "Date",
      "Number",
      "BigInt",
      // text
      "String",
      "RegExp",
      // Indexed collections
      "Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Int32Array",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      // Structured data
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      // Control abstraction objects
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Internationalization
      "Intl",
      // WebAssembly
      "WebAssembly"
    ], p_ = [
      "Error",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ], __ = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ], m_ = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "sessionStorage",
      "module",
      "global"
      // Node.js
    ], f_ = [].concat(
      __,
      d_,
      p_
    );
    function m1(n2) {
      const e = n2.regex, t = (L, { after: V }) => {
        const te = "</" + L[0].slice(1);
        return L.input.indexOf(te, V) !== -1;
      }, o = Gs, i2 = {
        begin: "<>",
        end: "</>"
      }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, r = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (L, V) => {
          const te = L[0].length + L.index, ae = L.input[te];
          if (
            // HTML should not include another raw `<` inside a tag
            // nested type?
            // `<Array<Array<number>>`, etc.
            ae === "<" || // the , gives away that this is not HTML
            // `<T, A extends keyof T, V>`
            ae === ","
          ) {
            V.ignoreMatch();
            return;
          }
          ae === ">" && (t(L, { after: te }) || V.ignoreMatch());
          let ye;
          const Pe = L.input.substring(te);
          if (ye = Pe.match(/^\s*=/)) {
            V.ignoreMatch();
            return;
          }
          if ((ye = Pe.match(/^\s+extends\s+/)) && ye.index === 0) {
            V.ignoreMatch();
            return;
          }
        }
      }, a = {
        $pattern: Gs,
        keyword: u_,
        literal: c_,
        built_in: f_,
        "variable.language": m_
      }, l = "[0-9](_?[0-9])*", u = `\\.(${l})`, c2 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${c2})((${u})|\\.)?|(${u}))[eE][+-]?(${l})\\b` },
          { begin: `\\b(${c2})\\b((${u})\\b|\\.)?|(${u})\\b` },
          // DecimalBigIntegerLiteral
          { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      }, p2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: a,
        contains: []
        // defined later
      }, _ = {
        begin: ".?html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "xml"
        }
      }, m = {
        begin: ".?css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "css"
        }
      }, f = {
        begin: ".?gql`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            n2.BACKSLASH_ESCAPE,
            p2
          ],
          subLanguage: "graphql"
        }
      }, b = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          n2.BACKSLASH_ESCAPE,
          p2
        ]
      }, y = {
        className: "comment",
        variants: [
          n2.COMMENT(
            /\/\*\*(?!\/)/,
            "\\*/",
            {
              relevance: 0,
              contains: [
                {
                  begin: "(?=@[A-Za-z]+)",
                  relevance: 0,
                  contains: [
                    {
                      className: "doctag",
                      begin: "@[A-Za-z]+"
                    },
                    {
                      className: "type",
                      begin: "\\{",
                      end: "\\}",
                      excludeEnd: true,
                      excludeBegin: true,
                      relevance: 0
                    },
                    {
                      className: "variable",
                      begin: o + "(?=\\s*(-)|$)",
                      endsParent: true,
                      relevance: 0
                    },
                    // eat spaces (not newlines) so we can find
                    // types or variables
                    {
                      begin: /(?=[^\n])\s/,
                      relevance: 0
                    }
                  ]
                }
              ]
            }
          ),
          n2.C_BLOCK_COMMENT_MODE,
          n2.C_LINE_COMMENT_MODE
        ]
      }, C = [
        n2.APOS_STRING_MODE,
        n2.QUOTE_STRING_MODE,
        _,
        m,
        f,
        b,
        // Skip numbers when they are part of a variable name
        { match: /\$\d+/ },
        d
        // This is intentional:
        // See https://github.com/highlightjs/highlight.js/issues/3288
        // hljs.REGEXP_MODE
      ];
      p2.contains = C.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: a,
        contains: [
          "self"
        ].concat(C)
      });
      const v = [].concat(y, p2.contains), x = v.concat([
        // eat recursive parens in sub expressions
        {
          begin: /(\s*)\(/,
          end: /\)/,
          keywords: a,
          contains: ["self"].concat(v)
        }
      ]), S = {
        className: "params",
        // convert this to negative lookbehind in v12
        begin: /(\s*)\(/,
        // to match the parms with
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: a,
        contains: x
      }, F = {
        variants: [
          // class Car extends vehicle
          {
            match: [
              /class/,
              /\s+/,
              o,
              /\s+/,
              /extends/,
              /\s+/,
              e.concat(o, "(", e.concat(/\./, o), ")*")
            ],
            scope: {
              1: "keyword",
              3: "title.class",
              5: "keyword",
              7: "title.class.inherited"
            }
          },
          // class Car
          {
            match: [
              /class/,
              /\s+/,
              o
            ],
            scope: {
              1: "keyword",
              3: "title.class"
            }
          }
        ]
      }, Y = {
        relevance: 0,
        match: e.either(
          // Hard coded exceptions
          /\bJSON/,
          // Float32Array, OutT
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          // CSSFactory, CSSFactoryT
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          // FPs, FPsT
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
          // P
          // single letters are not highlighted
          // BLAH
          // this will be flagged as a UPPER_CASE_CONSTANT instead
        ),
        className: "title.class",
        keywords: {
          _: [
            // se we still get relevance credit for JS library classes
            ...d_,
            ...p_
          ]
        }
      }, q = {
        label: "use_strict",
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      }, K = {
        variants: [
          {
            match: [
              /function/,
              /\s+/,
              o,
              /(?=\s*\()/
            ]
          },
          // anonymous function
          {
            match: [
              /function/,
              /\s*(?=\()/
            ]
          }
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        label: "func.def",
        contains: [S],
        illegal: /%/
      }, ie2 = {
        relevance: 0,
        match: /\b[A-Z][A-Z_0-9]+\b/,
        className: "variable.constant"
      };
      function ce(L) {
        return e.concat("(?!", L.join("|"), ")");
      }
      const ve = {
        match: e.concat(
          /\b/,
          ce([
            ...__,
            "super",
            "import"
          ].map((L) => `${L}\\s*\\(`)),
          o,
          e.lookahead(/\s*\(/)
        ),
        className: "title.function",
        relevance: 0
      }, he = {
        begin: e.concat(/\./, e.lookahead(
          e.concat(o, /(?![0-9A-Za-z$_(])/)
        )),
        end: o,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, de = {
        match: [
          /get|set/,
          /\s+/,
          o,
          /(?=\()/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          {
            // eat to avoid empty params
            begin: /\(\)/
          },
          S
        ]
      }, pe = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n2.UNDERSCORE_IDENT_RE + ")\\s*=>", N = {
        match: [
          /const|var|let/,
          /\s+/,
          o,
          /\s*/,
          /=\s*/,
          /(async\s*)?/,
          // async is optional
          e.lookahead(pe)
        ],
        keywords: "async",
        className: {
          1: "keyword",
          3: "title.function"
        },
        contains: [
          S
        ]
      };
      return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: a,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: Y },
        illegal: /#(?![$_A-z])/,
        contains: [
          n2.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          q,
          n2.APOS_STRING_MODE,
          n2.QUOTE_STRING_MODE,
          _,
          m,
          f,
          b,
          y,
          // Skip numbers when they are part of a variable name
          { match: /\$\d+/ },
          d,
          Y,
          {
            scope: "attr",
            match: o + e.lookahead(":"),
            relevance: 0
          },
          N,
          {
            // "value" container
            begin: "(" + n2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [
              y,
              n2.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: pe,
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: n2.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: a,
                        contains: x
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                match: /\s+/,
                relevance: 0
              },
              {
                // JSX
                variants: [
                  { begin: i2.begin, end: i2.end },
                  { match: s },
                  {
                    begin: r.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": r.isTrulyOpeningTag,
                    end: r.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: r.begin,
                    end: r.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ]
          },
          K,
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: "\\b(?!function)" + n2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            label: "func.def",
            contains: [
              S,
              n2.inherit(n2.TITLE_MODE, { begin: o, className: "title.function" })
            ]
          },
          // catch ... so it won't trigger the property rule below
          {
            match: /\.\.\./,
            relevance: 0
          },
          he,
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            match: "\\$" + o,
            relevance: 0
          },
          {
            match: [/\bconstructor(?=\s*\()/],
            className: { 1: "title.function" },
            contains: [S]
          },
          ve,
          ie2,
          F,
          de,
          {
            match: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    function f1(n2) {
      const e = n2.regex, t = m1(n2), o = Gs, i2 = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "symbol",
        "bigint",
        "unknown"
      ], s = {
        begin: [
          /namespace/,
          /\s+/,
          n2.IDENT_RE
        ],
        beginScope: {
          1: "keyword",
          3: "title.class"
        }
      }, r = {
        beginKeywords: "interface",
        end: /\{/,
        excludeEnd: true,
        keywords: {
          keyword: "interface extends",
          built_in: i2
        },
        contains: [t.exports.CLASS_REFERENCE]
      }, a = {
        className: "meta",
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      }, l = [
        "type",
        // "namespace",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly",
        "enum",
        "override",
        "satisfies"
      ], u = {
        $pattern: Gs,
        keyword: u_.concat(l),
        literal: c_,
        built_in: f_.concat(i2),
        "variable.language": m_
      }, c2 = {
        className: "meta",
        begin: "@" + o
      }, d = (f, b, h2) => {
        const y = f.contains.findIndex((C) => C.label === b);
        if (y === -1)
          throw new Error("can not find mode to replace");
        f.contains.splice(y, 1, h2);
      };
      Object.assign(t.keywords, u), t.exports.PARAMS_CONTAINS.push(c2);
      const p2 = t.contains.find((f) => f.scope === "attr"), _ = Object.assign(
        {},
        p2,
        { match: e.concat(o, e.lookahead(/\s*\?:/)) }
      );
      t.exports.PARAMS_CONTAINS.push([
        t.exports.CLASS_REFERENCE,
        // class reference for highlighting the params types
        p2,
        // highlight the params key
        _
        // Added for optional property assignment highlighting
      ]), t.contains = t.contains.concat([
        c2,
        s,
        r,
        _
        // Added for optional property assignment highlighting
      ]), d(t, "shebang", n2.SHEBANG()), d(t, "use_strict", a);
      const m = t.contains.find((f) => f.label === "func.def");
      return m.relevance = 0, Object.assign(t, {
        name: "TypeScript",
        aliases: [
          "ts",
          "tsx",
          "mts",
          "cts"
        ]
      }), t;
    }
    function g1(n2) {
      const e = n2.regex, t = {
        className: "string",
        begin: /"(""|[^/n])"C\b/
      }, o = {
        className: "string",
        begin: /"/,
        end: /"/,
        illegal: /\n/,
        contains: [
          {
            // double quote escape
            begin: /""/
          }
        ]
      }, i2 = /\d{1,2}\/\d{1,2}\/\d{4}/, s = /\d{4}-\d{1,2}-\d{1,2}/, r = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
        className: "literal",
        variants: [
          {
            // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
            begin: e.concat(/# */, e.either(s, i2), / *#/)
          },
          {
            // #H:mm[:ss]# (24h Time)
            begin: e.concat(/# */, a, / *#/)
          },
          {
            // #h[:mm[:ss]] A# (12h Time)
            begin: e.concat(/# */, r, / *#/)
          },
          {
            // date plus time
            begin: e.concat(
              /# */,
              e.either(s, i2),
              / +/,
              e.either(r, a),
              / *#/
            )
          }
        ]
      }, u = {
        className: "number",
        relevance: 0,
        variants: [
          {
            // Float
            begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
          },
          {
            // Integer (base 10)
            begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 16)
            begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 8)
            begin: /&O[0-7_]+((U?[SIL])|[%&])?/
          },
          {
            // Integer (base 2)
            begin: /&B[01_]+((U?[SIL])|[%&])?/
          }
        ]
      }, c2 = {
        className: "label",
        begin: /^\w+:/
      }, d = n2.COMMENT(/'''/, /$/, { contains: [
        {
          className: "doctag",
          begin: /<\/?/,
          end: />/
        }
      ] }), p2 = n2.COMMENT(null, /$/, { variants: [
        { begin: /'/ },
        {
          // TODO: Use multi-class for leading spaces
          begin: /([\t ]|^)REM(?=\s)/
        }
      ] });
      return {
        name: "Visual Basic .NET",
        aliases: ["vb"],
        case_insensitive: true,
        classNameAliases: { label: "symbol" },
        keywords: {
          keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
          built_in: (
            // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
            "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
          ),
          type: (
            // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
            "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
          ),
          literal: "true false nothing"
        },
        illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
        contains: [
          t,
          o,
          l,
          u,
          c2,
          d,
          p2,
          {
            className: "meta",
            // TODO: Use multi-class for indentation once available
            begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
            end: /$/,
            keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
            contains: [p2]
          }
        ]
      };
    }
    function h1(n2) {
      n2.regex;
      const e = n2.COMMENT(/\(;/, /;\)/);
      e.contains.push("self");
      const t = n2.COMMENT(/;;/, /$/), o = [
        "anyfunc",
        "block",
        "br",
        "br_if",
        "br_table",
        "call",
        "call_indirect",
        "data",
        "drop",
        "elem",
        "else",
        "end",
        "export",
        "func",
        "global.get",
        "global.set",
        "local.get",
        "local.set",
        "local.tee",
        "get_global",
        "get_local",
        "global",
        "if",
        "import",
        "local",
        "loop",
        "memory",
        "memory.grow",
        "memory.size",
        "module",
        "mut",
        "nop",
        "offset",
        "param",
        "result",
        "return",
        "select",
        "set_global",
        "set_local",
        "start",
        "table",
        "tee_local",
        "then",
        "type",
        "unreachable"
      ], i2 = {
        begin: [
          /(?:func|call|call_indirect)/,
          /\s+/,
          /\$[^\s)]+/
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      }, s = {
        className: "variable",
        begin: /\$[\w_]+/
      }, r = {
        match: /(\((?!;)|\))+/,
        className: "punctuation",
        relevance: 0
      }, a = {
        className: "number",
        relevance: 0,
        // borrowed from Prism, TODO: split out into variants
        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
      }, l = {
        // look-ahead prevents us from gobbling up opcodes
        match: /(i32|i64|f32|f64)(?!\.)/,
        className: "type"
      }, u = {
        className: "keyword",
        // borrowed from Prism, TODO: split out into variants
        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
      };
      return {
        name: "WebAssembly",
        keywords: {
          $pattern: /[\w.]+/,
          keyword: o
        },
        contains: [
          t,
          e,
          {
            match: [
              /(?:offset|align)/,
              /\s*/,
              /=/
            ],
            className: {
              1: "keyword",
              3: "operator"
            }
          },
          s,
          r,
          i2,
          n2.QUOTE_STRING_MODE,
          l,
          u,
          a
        ]
      };
    }
    function v1(n2) {
      const e = n2.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), o = /[\p{L}0-9._:-]+/u, i2 = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      }, s = {
        begin: /\s/,
        contains: [
          {
            className: "keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      }, r = n2.inherit(s, {
        begin: /\(/,
        end: /\)/
      }), a = n2.inherit(n2.APOS_STRING_MODE, { className: "string" }), l = n2.inherit(n2.QUOTE_STRING_MODE, { className: "string" }), u = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: o,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [i2]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [i2]
                  },
                  { begin: /[^\s"'=<>`]+/ }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        unicodeRegex: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              s,
              l,
              a,
              r,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      s,
                      r,
                      l,
                      a
                    ]
                  }
                ]
              }
            ]
          },
          n2.COMMENT(
            /<!--/,
            /-->/,
            { relevance: 10 }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          i2,
          // xml processing instructions
          {
            className: "meta",
            end: /\?>/,
            variants: [
              {
                begin: /<\?xml/,
                relevance: 10,
                contains: [
                  l
                ]
              },
              {
                begin: /<\?[a-z][a-z0-9]+/
              }
            ]
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending bracket.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [u],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [u],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: e.concat(
              /</,
              e.lookahead(e.concat(
                t,
                // <tag/>
                // <tag>
                // <tag ...
                e.either(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: t,
                relevance: 0,
                starts: u
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: e.concat(
              /<\//,
              e.lookahead(e.concat(
                t,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: t,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    function b1(n2) {
      const e = "true false yes no null", t = "[\\w#;/?:@&=+$,.~*'()[\\]]+", o = {
        className: "attr",
        variants: [
          // added brackets support and special char support
          { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
          {
            // double quoted keys - with brackets and special char support
            begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
          },
          {
            // single quoted keys - with brackets and special char support
            begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
          }
        ]
      }, i2 = {
        className: "template-variable",
        variants: [
          {
            // jinja templates Ansible
            begin: /\{\{/,
            end: /\}\}/
          },
          {
            // Ruby i18n
            begin: /%\{/,
            end: /\}/
          }
        ]
      }, s = {
        className: "string",
        relevance: 0,
        begin: /'/,
        end: /'/,
        contains: [
          {
            match: /''/,
            scope: "char.escape",
            relevance: 0
          }
        ]
      }, r = {
        className: "string",
        relevance: 0,
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          { begin: /\S+/ }
        ],
        contains: [
          n2.BACKSLASH_ESCAPE,
          i2
        ]
      }, a = n2.inherit(r, { variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {
              begin: /''/,
              relevance: 0
            }
          ]
        },
        {
          begin: /"/,
          end: /"/
        },
        { begin: /[^\s,{}[\]]+/ }
      ] }), p2 = {
        className: "number",
        begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
      }, _ = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: e,
        relevance: 0
      }, m = {
        begin: /\{/,
        end: /\}/,
        contains: [_],
        illegal: "\\n",
        relevance: 0
      }, f = {
        begin: "\\[",
        end: "\\]",
        contains: [_],
        illegal: "\\n",
        relevance: 0
      }, b = [
        o,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + t
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + t + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + t
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + t
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + n2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + n2.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        n2.HASH_COMMENT_MODE,
        {
          beginKeywords: e,
          keywords: { literal: e }
        },
        p2,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: n2.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        m,
        f,
        s,
        r
      ], h2 = [...b];
      return h2.pop(), h2.push(a), _.contains = h2, {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: b
      };
    }
    const k1 = {
      arduino: nw,
      bash: tw,
      c: ow,
      cpp: iw,
      csharp: sw,
      css: mw,
      diff: fw,
      go: gw,
      graphql: hw,
      ini: vw,
      java: bw,
      javascript: Ew,
      json: Cw,
      kotlin: xw,
      less: Lw,
      lua: Dw,
      makefile: Bw,
      markdown: Pw,
      objectivec: $w,
      perl: zw,
      php: Fw,
      "php-template": Hw,
      plaintext: Uw,
      python: qw,
      "python-repl": Kw,
      r: Vw,
      ruby: Ww,
      rust: Gw,
      scss: o1,
      shell: i1,
      sql: s1,
      swift: _1,
      typescript: f1,
      vbnet: g1,
      wasm: h1,
      xml: v1,
      yaml: b1
    };
    function y1(n2) {
      return n2 && n2.__esModule && Object.prototype.hasOwnProperty.call(n2, "default") ? n2.default : n2;
    }
    var aa, Ac;
    function j1() {
      if (Ac) return aa;
      Ac = 1;
      function n2(j) {
        return j instanceof Map ? j.clear = j.delete = j.set = function() {
          throw new Error("map is read-only");
        } : j instanceof Set && (j.add = j.clear = j.delete = function() {
          throw new Error("set is read-only");
        }), Object.freeze(j), Object.getOwnPropertyNames(j).forEach((M) => {
          const $ = j[M], _e = typeof $;
          (_e === "object" || _e === "function") && !Object.isFrozen($) && n2($);
        }), j;
      }
      class e {
        /**
         * @param {CompiledMode} mode
         */
        constructor(M) {
          M.data === void 0 && (M.data = {}), this.data = M.data, this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      }
      function t(j) {
        return j.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function o(j, ...M) {
        const $ = /* @__PURE__ */ Object.create(null);
        for (const _e in j)
          $[_e] = j[_e];
        return M.forEach(function(_e) {
          for (const Xe in _e)
            $[Xe] = _e[Xe];
        }), /** @type {T} */
        $;
      }
      const i2 = "</span>", s = (j) => !!j.scope, r = (j, { prefix: M }) => {
        if (j.startsWith("language:"))
          return j.replace("language:", "language-");
        if (j.includes(".")) {
          const $ = j.split(".");
          return [
            `${M}${$.shift()}`,
            ...$.map((_e, Xe) => `${_e}${"_".repeat(Xe + 1)}`)
          ].join(" ");
        }
        return `${M}${j}`;
      };
      class a {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(M, $) {
          this.buffer = "", this.classPrefix = $.classPrefix, M.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(M) {
          this.buffer += t(M);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(M) {
          if (!s(M)) return;
          const $ = r(
            M.scope,
            { prefix: this.classPrefix }
          );
          this.span($);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(M) {
          s(M) && (this.buffer += i2);
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(M) {
          this.buffer += `<span class="${M}">`;
        }
      }
      const l = (j = {}) => {
        const M = { children: [] };
        return Object.assign(M, j), M;
      };
      class u {
        constructor() {
          this.rootNode = l(), this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(M) {
          this.top.children.push(M);
        }
        /** @param {string} scope */
        openNode(M) {
          const $ = l({ scope: M });
          this.add($), this.stack.push($);
        }
        closeNode() {
          if (this.stack.length > 1)
            return this.stack.pop();
        }
        closeAllNodes() {
          for (; this.closeNode(); ) ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(M) {
          return this.constructor._walk(M, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(M, $) {
          return typeof $ == "string" ? M.addText($) : $.children && (M.openNode($), $.children.forEach((_e) => this._walk(M, _e)), M.closeNode($)), M;
        }
        /**
         * @param {Node} node
         */
        static _collapse(M) {
          typeof M != "string" && M.children && (M.children.every(($) => typeof $ == "string") ? M.children = [M.children.join("")] : M.children.forEach(($) => {
            u._collapse($);
          }));
        }
      }
      class c2 extends u {
        /**
         * @param {*} options
         */
        constructor(M) {
          super(), this.options = M;
        }
        /**
         * @param {string} text
         */
        addText(M) {
          M !== "" && this.add(M);
        }
        /** @param {string} scope */
        startScope(M) {
          this.openNode(M);
        }
        endScope() {
          this.closeNode();
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        __addSublanguage(M, $) {
          const _e = M.root;
          $ && (_e.scope = `language:${$}`), this.add(_e);
        }
        toHTML() {
          return new a(this, this.options).value();
        }
        finalize() {
          return this.closeAllNodes(), true;
        }
      }
      function d(j) {
        return j ? typeof j == "string" ? j : j.source : null;
      }
      function p2(j) {
        return f("(?=", j, ")");
      }
      function _(j) {
        return f("(?:", j, ")*");
      }
      function m(j) {
        return f("(?:", j, ")?");
      }
      function f(...j) {
        return j.map(($) => d($)).join("");
      }
      function b(j) {
        const M = j[j.length - 1];
        return typeof M == "object" && M.constructor === Object ? (j.splice(j.length - 1, 1), M) : {};
      }
      function h2(...j) {
        return "(" + (b(j).capture ? "" : "?:") + j.map((_e) => d(_e)).join("|") + ")";
      }
      function y(j) {
        return new RegExp(j.toString() + "|").exec("").length - 1;
      }
      function C(j, M) {
        const $ = j && j.exec(M);
        return $ && $.index === 0;
      }
      const v = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function x(j, { joinWith: M }) {
        let $ = 0;
        return j.map((_e) => {
          $ += 1;
          const Xe = $;
          let Ye = d(_e), ee = "";
          for (; Ye.length > 0; ) {
            const Z = v.exec(Ye);
            if (!Z) {
              ee += Ye;
              break;
            }
            ee += Ye.substring(0, Z.index), Ye = Ye.substring(Z.index + Z[0].length), Z[0][0] === "\\" && Z[1] ? ee += "\\" + String(Number(Z[1]) + Xe) : (ee += Z[0], Z[0] === "(" && $++);
          }
          return ee;
        }).map((_e) => `(${_e})`).join(M);
      }
      const S = /\b\B/, F = "[a-zA-Z]\\w*", Y = "[a-zA-Z_]\\w*", q = "\\b\\d+(\\.\\d+)?", K = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", ie2 = "\\b(0b[01]+)", ce = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ve = (j = {}) => {
        const M = /^#![ ]*\//;
        return j.binary && (j.begin = f(
          M,
          /.*\b/,
          j.binary,
          /\b.*/
        )), o({
          scope: "meta",
          begin: M,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": ($, _e) => {
            $.index !== 0 && _e.ignoreMatch();
          }
        }, j);
      }, he = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      }, de = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [he]
      }, pe = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [he]
      }, N = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      }, L = function(j, M, $ = {}) {
        const _e = o(
          {
            scope: "comment",
            begin: j,
            end: M,
            contains: []
          },
          $
        );
        _e.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const Xe = h2(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        return _e.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: f(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              Xe,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        ), _e;
      }, V = L("//", "$"), te = L("/\\*", "\\*/"), ae = L("#", "$"), ye = {
        scope: "number",
        begin: q,
        relevance: 0
      }, Pe = {
        scope: "number",
        begin: K,
        relevance: 0
      }, vn = {
        scope: "number",
        begin: ie2,
        relevance: 0
      }, $e = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [
          he,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [he]
          }
        ]
      }, Ge = {
        scope: "title",
        begin: F,
        relevance: 0
      }, Gn = {
        scope: "title",
        begin: Y,
        relevance: 0
      }, Cn = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + Y,
        relevance: 0
      };
      var Sn = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: de,
        BACKSLASH_ESCAPE: he,
        BINARY_NUMBER_MODE: vn,
        BINARY_NUMBER_RE: ie2,
        COMMENT: L,
        C_BLOCK_COMMENT_MODE: te,
        C_LINE_COMMENT_MODE: V,
        C_NUMBER_MODE: Pe,
        C_NUMBER_RE: K,
        END_SAME_AS_BEGIN: function(j) {
          return Object.assign(
            j,
            {
              /** @type {ModeCallback} */
              "on:begin": (M, $) => {
                $.data._beginMatch = M[1];
              },
              /** @type {ModeCallback} */
              "on:end": (M, $) => {
                $.data._beginMatch !== M[1] && $.ignoreMatch();
              }
            }
          );
        },
        HASH_COMMENT_MODE: ae,
        IDENT_RE: F,
        MATCH_NOTHING_RE: S,
        METHOD_GUARD: Cn,
        NUMBER_MODE: ye,
        NUMBER_RE: q,
        PHRASAL_WORDS_MODE: N,
        QUOTE_STRING_MODE: pe,
        REGEXP_MODE: $e,
        RE_STARTERS_RE: ce,
        SHEBANG: ve,
        TITLE_MODE: Ge,
        UNDERSCORE_IDENT_RE: Y,
        UNDERSCORE_TITLE_MODE: Gn
      });
      function it(j, M) {
        j.input[j.index - 1] === "." && M.ignoreMatch();
      }
      function xt(j, M) {
        j.className !== void 0 && (j.scope = j.className, delete j.className);
      }
      function ft(j, M) {
        M && j.beginKeywords && (j.begin = "\\b(" + j.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", j.__beforeBegin = it, j.keywords = j.keywords || j.beginKeywords, delete j.beginKeywords, j.relevance === void 0 && (j.relevance = 0));
      }
      function Yn(j, M) {
        Array.isArray(j.illegal) && (j.illegal = h2(...j.illegal));
      }
      function gt(j, M) {
        if (j.match) {
          if (j.begin || j.end) throw new Error("begin & end are not supported with match");
          j.begin = j.match, delete j.match;
        }
      }
      function ge(j, M) {
        j.relevance === void 0 && (j.relevance = 1);
      }
      const Hn = (j, M) => {
        if (!j.beforeMatch) return;
        if (j.starts) throw new Error("beforeMatch cannot be used with starts");
        const $ = Object.assign({}, j);
        Object.keys(j).forEach((_e) => {
          delete j[_e];
        }), j.keywords = $.keywords, j.begin = f($.beforeMatch, p2($.begin)), j.starts = {
          relevance: 0,
          contains: [
            Object.assign($, { endsParent: true })
          ]
        }, j.relevance = 0, delete $.beforeMatch;
      }, Nn = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ], se = "keyword";
      function Ln(j, M, $ = se) {
        const _e = /* @__PURE__ */ Object.create(null);
        return typeof j == "string" ? Xe($, j.split(" ")) : Array.isArray(j) ? Xe($, j) : Object.keys(j).forEach(function(Ye) {
          Object.assign(
            _e,
            Ln(j[Ye], M, Ye)
          );
        }), _e;
        function Xe(Ye, ee) {
          M && (ee = ee.map((Z) => Z.toLowerCase())), ee.forEach(function(Z) {
            const me = Z.split("|");
            _e[me[0]] = [Ye, Ue(me[0], me[1])];
          });
        }
      }
      function Ue(j, M) {
        return M ? Number(M) : Me(j) ? 0 : 1;
      }
      function Me(j) {
        return Nn.includes(j.toLowerCase());
      }
      const Dn = {}, un = (j) => {
        console.error(j);
      }, ht = (j, ...M) => {
        console.log(`WARN: ${j}`, ...M);
      }, Bn = (j, M) => {
        Dn[`${j}/${M}`] || (console.log(`Deprecated as of ${j}. ${M}`), Dn[`${j}/${M}`] = true);
      }, P = new Error();
      function J(j, M, { key: $ }) {
        let _e = 0;
        const Xe = j[$], Ye = {}, ee = {};
        for (let Z = 1; Z <= M.length; Z++)
          ee[Z + _e] = Xe[Z], Ye[Z + _e] = true, _e += y(M[Z - 1]);
        j[$] = ee, j[$]._emit = Ye, j[$]._multi = true;
      }
      function be(j) {
        if (Array.isArray(j.begin)) {
          if (j.skip || j.excludeBegin || j.returnBegin)
            throw un("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), P;
          if (typeof j.beginScope != "object" || j.beginScope === null)
            throw un("beginScope must be object"), P;
          J(j, j.begin, { key: "beginScope" }), j.begin = x(j.begin, { joinWith: "" });
        }
      }
      function Re(j) {
        if (Array.isArray(j.end)) {
          if (j.skip || j.excludeEnd || j.returnEnd)
            throw un("skip, excludeEnd, returnEnd not compatible with endScope: {}"), P;
          if (typeof j.endScope != "object" || j.endScope === null)
            throw un("endScope must be object"), P;
          J(j, j.end, { key: "endScope" }), j.end = x(j.end, { joinWith: "" });
        }
      }
      function pn(j) {
        j.scope && typeof j.scope == "object" && j.scope !== null && (j.beginScope = j.scope, delete j.scope);
      }
      function Jn(j) {
        pn(j), typeof j.beginScope == "string" && (j.beginScope = { _wrap: j.beginScope }), typeof j.endScope == "string" && (j.endScope = { _wrap: j.endScope }), be(j), Re(j);
      }
      function ui(j) {
        function M(ee, Z) {
          return new RegExp(
            d(ee),
            "m" + (j.case_insensitive ? "i" : "") + (j.unicodeRegex ? "u" : "") + (Z ? "g" : "")
          );
        }
        class $ {
          constructor() {
            this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
          }
          // @ts-ignore
          addRule(Z, me) {
            me.position = this.position++, this.matchIndexes[this.matchAt] = me, this.regexes.push([me, Z]), this.matchAt += y(Z) + 1;
          }
          compile() {
            this.regexes.length === 0 && (this.exec = () => null);
            const Z = this.regexes.map((me) => me[1]);
            this.matcherRe = M(x(Z, { joinWith: "|" }), true), this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(Z) {
            this.matcherRe.lastIndex = this.lastIndex;
            const me = this.matcherRe.exec(Z);
            if (!me)
              return null;
            const kn = me.findIndex((di, Mr) => Mr > 0 && di !== void 0), _n = this.matchIndexes[kn];
            return me.splice(0, kn), Object.assign(me, _n);
          }
        }
        class _e {
          constructor() {
            this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(Z) {
            if (this.multiRegexes[Z]) return this.multiRegexes[Z];
            const me = new $();
            return this.rules.slice(Z).forEach(([kn, _n]) => me.addRule(kn, _n)), me.compile(), this.multiRegexes[Z] = me, me;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(Z, me) {
            this.rules.push([Z, me]), me.type === "begin" && this.count++;
          }
          /** @param {string} s */
          exec(Z) {
            const me = this.getMatcher(this.regexIndex);
            me.lastIndex = this.lastIndex;
            let kn = me.exec(Z);
            if (this.resumingScanAtSamePosition() && !(kn && kn.index === this.lastIndex)) {
              const _n = this.getMatcher(0);
              _n.lastIndex = this.lastIndex + 1, kn = _n.exec(Z);
            }
            return kn && (this.regexIndex += kn.position + 1, this.regexIndex === this.count && this.considerAll()), kn;
          }
        }
        function Xe(ee) {
          const Z = new _e();
          return ee.contains.forEach((me) => Z.addRule(me.begin, { rule: me, type: "begin" })), ee.terminatorEnd && Z.addRule(ee.terminatorEnd, { type: "end" }), ee.illegal && Z.addRule(ee.illegal, { type: "illegal" }), Z;
        }
        function Ye(ee, Z) {
          const me = (
            /** @type CompiledMode */
            ee
          );
          if (ee.isCompiled) return me;
          [
            xt,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            gt,
            Jn,
            Hn
          ].forEach((_n) => _n(ee, Z)), j.compilerExtensions.forEach((_n) => _n(ee, Z)), ee.__beforeBegin = null, [
            ft,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            Yn,
            // default to 1 relevance if not specified
            ge
          ].forEach((_n) => _n(ee, Z)), ee.isCompiled = true;
          let kn = null;
          return typeof ee.keywords == "object" && ee.keywords.$pattern && (ee.keywords = Object.assign({}, ee.keywords), kn = ee.keywords.$pattern, delete ee.keywords.$pattern), kn = kn || /\w+/, ee.keywords && (ee.keywords = Ln(ee.keywords, j.case_insensitive)), me.keywordPatternRe = M(kn, true), Z && (ee.begin || (ee.begin = /\B|\b/), me.beginRe = M(me.begin), !ee.end && !ee.endsWithParent && (ee.end = /\B|\b/), ee.end && (me.endRe = M(me.end)), me.terminatorEnd = d(me.end) || "", ee.endsWithParent && Z.terminatorEnd && (me.terminatorEnd += (ee.end ? "|" : "") + Z.terminatorEnd)), ee.illegal && (me.illegalRe = M(
            /** @type {RegExp | string} */
            ee.illegal
          )), ee.contains || (ee.contains = []), ee.contains = [].concat(...ee.contains.map(function(_n) {
            return X(_n === "self" ? ee : _n);
          })), ee.contains.forEach(function(_n) {
            Ye(
              /** @type Mode */
              _n,
              me
            );
          }), ee.starts && Ye(ee.starts, Z), me.matcher = Xe(me), me;
        }
        if (j.compilerExtensions || (j.compilerExtensions = []), j.contains && j.contains.includes("self"))
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return j.classNameAliases = o(j.classNameAliases || {}), Ye(
          /** @type Mode */
          j
        );
      }
      function A(j) {
        return j ? j.endsWithParent || A(j.starts) : false;
      }
      function X(j) {
        return j.variants && !j.cachedVariants && (j.cachedVariants = j.variants.map(function(M) {
          return o(j, { variants: null }, M);
        })), j.cachedVariants ? j.cachedVariants : A(j) ? o(j, { starts: j.starts ? o(j.starts) : null }) : Object.isFrozen(j) ? o(j) : j;
      }
      var le = "11.11.1";
      class De extends Error {
        constructor(M, $) {
          super(M), this.name = "HTMLInjectionError", this.html = $;
        }
      }
      const Se = t, bn = o, Pn = Symbol("nomatch"), Zt = 7, ci = function(j) {
        const M = /* @__PURE__ */ Object.create(null), $ = /* @__PURE__ */ Object.create(null), _e = [];
        let Xe = true;
        const Ye = "Could not find the language '{}', did you forget to load/include a language module?", ee = { disableAutodetect: true, name: "Plain text", contains: [] };
        let Z = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: c2
        };
        function me(B) {
          return Z.noHighlightRe.test(B);
        }
        function kn(B) {
          let oe = B.className + " ";
          oe += B.parentNode ? B.parentNode.className : "";
          const Ne = Z.languageDetectRe.exec(oe);
          if (Ne) {
            const Je = Xt(Ne[1]);
            return Je || (ht(Ye.replace("{}", Ne[1])), ht("Falling back to no-highlight mode for this block.", B)), Je ? Ne[1] : "no-highlight";
          }
          return oe.split(/\s+/).find((Je) => me(Je) || Xt(Je));
        }
        function _n(B, oe, Ne) {
          let Je = "", gn = "";
          typeof oe == "object" ? (Je = B, Ne = oe.ignoreIllegals, gn = oe.language) : (Bn("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Bn("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), gn = B, Je = oe), Ne === void 0 && (Ne = true);
          const vt = {
            code: Je,
            language: gn
          };
          Qi("before:highlight", vt);
          const Qt = vt.result ? vt.result : di(vt.language, vt.code, Ne);
          return Qt.code = vt.code, Qi("after:highlight", Qt), Qt;
        }
        function di(B, oe, Ne, Je) {
          const gn = /* @__PURE__ */ Object.create(null);
          function vt(U, ne) {
            return U.keywords[ne];
          }
          function Qt() {
            if (!ke.keywords) {
              xn.addText(Ze);
              return;
            }
            let U = 0;
            ke.keywordPatternRe.lastIndex = 0;
            let ne = ke.keywordPatternRe.exec(Ze), Ee = "";
            for (; ne; ) {
              Ee += Ze.substring(U, ne.index);
              const Fe = At.case_insensitive ? ne[0].toLowerCase() : ne[0], On = vt(ke, Fe);
              if (On) {
                const [Ft, K_] = On;
                if (xn.addText(Ee), Ee = "", gn[Fe] = (gn[Fe] || 0) + 1, gn[Fe] <= Zt && (ts += K_), Ft.startsWith("_"))
                  Ee += ne[0];
                else {
                  const V_ = At.classNameAliases[Ft] || Ft;
                  Tt(ne[0], V_);
                }
              } else
                Ee += ne[0];
              U = ke.keywordPatternRe.lastIndex, ne = ke.keywordPatternRe.exec(Ze);
            }
            Ee += Ze.substring(U), xn.addText(Ee);
          }
          function es() {
            if (Ze === "") return;
            let U = null;
            if (typeof ke.subLanguage == "string") {
              if (!M[ke.subLanguage]) {
                xn.addText(Ze);
                return;
              }
              U = di(ke.subLanguage, Ze, true, Yl[ke.subLanguage]), Yl[ke.subLanguage] = /** @type {CompiledMode} */
              U._top;
            } else
              U = Rr(Ze, ke.subLanguage.length ? ke.subLanguage : null);
            ke.relevance > 0 && (ts += U.relevance), xn.__addSublanguage(U._emitter, U.language);
          }
          function Zn() {
            ke.subLanguage != null ? es() : Qt(), Ze = "";
          }
          function Tt(U, ne) {
            U !== "" && (xn.startScope(ne), xn.addText(U), xn.endScope());
          }
          function Kl(U, ne) {
            let Ee = 1;
            const Fe = ne.length - 1;
            for (; Ee <= Fe; ) {
              if (!U._emit[Ee]) {
                Ee++;
                continue;
              }
              const On = At.classNameAliases[U[Ee]] || U[Ee], Ft = ne[Ee];
              On ? Tt(Ft, On) : (Ze = Ft, Qt(), Ze = ""), Ee++;
            }
          }
          function Vl(U, ne) {
            return U.scope && typeof U.scope == "string" && xn.openNode(At.classNameAliases[U.scope] || U.scope), U.beginScope && (U.beginScope._wrap ? (Tt(Ze, At.classNameAliases[U.beginScope._wrap] || U.beginScope._wrap), Ze = "") : U.beginScope._multi && (Kl(U.beginScope, ne), Ze = "")), ke = Object.create(U, { parent: { value: ke } }), ke;
          }
          function Wl(U, ne, Ee) {
            let Fe = C(U.endRe, Ee);
            if (Fe) {
              if (U["on:end"]) {
                const On = new e(U);
                U["on:end"](ne, On), On.isMatchIgnored && (Fe = false);
              }
              if (Fe) {
                for (; U.endsParent && U.parent; )
                  U = U.parent;
                return U;
              }
            }
            if (U.endsWithParent)
              return Wl(U.parent, ne, Ee);
          }
          function z_(U) {
            return ke.matcher.regexIndex === 0 ? (Ze += U[0], 1) : (Br = true, 0);
          }
          function F_(U) {
            const ne = U[0], Ee = U.rule, Fe = new e(Ee), On = [Ee.__beforeBegin, Ee["on:begin"]];
            for (const Ft of On)
              if (Ft && (Ft(U, Fe), Fe.isMatchIgnored))
                return z_(ne);
            return Ee.skip ? Ze += ne : (Ee.excludeBegin && (Ze += ne), Zn(), !Ee.returnBegin && !Ee.excludeBegin && (Ze = ne)), Vl(Ee, U), Ee.returnBegin ? 0 : ne.length;
          }
          function H_(U) {
            const ne = U[0], Ee = oe.substring(U.index), Fe = Wl(ke, U, Ee);
            if (!Fe)
              return Pn;
            const On = ke;
            ke.endScope && ke.endScope._wrap ? (Zn(), Tt(ne, ke.endScope._wrap)) : ke.endScope && ke.endScope._multi ? (Zn(), Kl(ke.endScope, U)) : On.skip ? Ze += ne : (On.returnEnd || On.excludeEnd || (Ze += ne), Zn(), On.excludeEnd && (Ze = ne));
            do
              ke.scope && xn.closeNode(), !ke.skip && !ke.subLanguage && (ts += ke.relevance), ke = ke.parent;
            while (ke !== Fe.parent);
            return Fe.starts && Vl(Fe.starts, U), On.returnEnd ? 0 : ne.length;
          }
          function U_() {
            const U = [];
            for (let ne = ke; ne !== At; ne = ne.parent)
              ne.scope && U.unshift(ne.scope);
            U.forEach((ne) => xn.openNode(ne));
          }
          let ns = {};
          function Gl(U, ne) {
            const Ee = ne && ne[0];
            if (Ze += U, Ee == null)
              return Zn(), 0;
            if (ns.type === "begin" && ne.type === "end" && ns.index === ne.index && Ee === "") {
              if (Ze += oe.slice(ne.index, ne.index + 1), !Xe) {
                const Fe = new Error(`0 width match regex (${B})`);
                throw Fe.languageName = B, Fe.badRule = ns.rule, Fe;
              }
              return 1;
            }
            if (ns = ne, ne.type === "begin")
              return F_(ne);
            if (ne.type === "illegal" && !Ne) {
              const Fe = new Error('Illegal lexeme "' + Ee + '" for mode "' + (ke.scope || "<unnamed>") + '"');
              throw Fe.mode = ke, Fe;
            } else if (ne.type === "end") {
              const Fe = H_(ne);
              if (Fe !== Pn)
                return Fe;
            }
            if (ne.type === "illegal" && Ee === "")
              return Ze += `
`, 1;
            if (Dr > 1e5 && Dr > ne.index * 3)
              throw new Error("potential infinite loop, way more iterations than matches");
            return Ze += Ee, Ee.length;
          }
          const At = Xt(B);
          if (!At)
            throw un(Ye.replace("{}", B)), new Error('Unknown language: "' + B + '"');
          const q_ = ui(At);
          let Lr = "", ke = Je || q_;
          const Yl = {}, xn = new Z.__emitter(Z);
          U_();
          let Ze = "", ts = 0, ko = 0, Dr = 0, Br = false;
          try {
            if (At.__emitTokens)
              At.__emitTokens(oe, xn);
            else {
              for (ke.matcher.considerAll(); ; ) {
                Dr++, Br ? Br = false : ke.matcher.considerAll(), ke.matcher.lastIndex = ko;
                const U = ke.matcher.exec(oe);
                if (!U) break;
                const ne = oe.substring(ko, U.index), Ee = Gl(ne, U);
                ko = U.index + Ee;
              }
              Gl(oe.substring(ko));
            }
            return xn.finalize(), Lr = xn.toHTML(), {
              language: B,
              value: Lr,
              relevance: ts,
              illegal: false,
              _emitter: xn,
              _top: ke
            };
          } catch (U) {
            if (U.message && U.message.includes("Illegal"))
              return {
                language: B,
                value: Se(oe),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: U.message,
                  index: ko,
                  context: oe.slice(ko - 100, ko + 100),
                  mode: U.mode,
                  resultSoFar: Lr
                },
                _emitter: xn
              };
            if (Xe)
              return {
                language: B,
                value: Se(oe),
                illegal: false,
                relevance: 0,
                errorRaised: U,
                _emitter: xn,
                _top: ke
              };
            throw U;
          }
        }
        function Mr(B) {
          const oe = {
            value: Se(B),
            illegal: false,
            relevance: 0,
            _top: ee,
            _emitter: new Z.__emitter(Z)
          };
          return oe._emitter.addText(B), oe;
        }
        function Rr(B, oe) {
          oe = oe || Z.languages || Object.keys(M);
          const Ne = Mr(B), Je = oe.filter(Xt).filter(ql).map(
            (Zn) => di(Zn, B, false)
          );
          Je.unshift(Ne);
          const gn = Je.sort((Zn, Tt) => {
            if (Zn.relevance !== Tt.relevance) return Tt.relevance - Zn.relevance;
            if (Zn.language && Tt.language) {
              if (Xt(Zn.language).supersetOf === Tt.language)
                return 1;
              if (Xt(Tt.language).supersetOf === Zn.language)
                return -1;
            }
            return 0;
          }), [vt, Qt] = gn, es = vt;
          return es.secondBest = Qt, es;
        }
        function A_(B, oe, Ne) {
          const Je = oe && $[oe] || Ne;
          B.classList.add("hljs"), B.classList.add(`language-${Je}`);
        }
        function Ir(B) {
          let oe = null;
          const Ne = kn(B);
          if (me(Ne)) return;
          if (Qi(
            "before:highlightElement",
            { el: B, language: Ne }
          ), B.dataset.highlighted) {
            console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", B);
            return;
          }
          if (B.children.length > 0 && (Z.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(B)), Z.throwUnescapedHTML))
            throw new De(
              "One of your code blocks includes unescaped HTML.",
              B.innerHTML
            );
          oe = B;
          const Je = oe.textContent, gn = Ne ? _n(Je, { language: Ne, ignoreIllegals: true }) : Rr(Je);
          B.innerHTML = gn.value, B.dataset.highlighted = "yes", A_(B, Ne, gn.language), B.result = {
            language: gn.language,
            // TODO: remove with version 11.0
            re: gn.relevance,
            relevance: gn.relevance
          }, gn.secondBest && (B.secondBest = {
            language: gn.secondBest.language,
            relevance: gn.secondBest.relevance
          }), Qi("after:highlightElement", { el: B, result: gn, text: Je });
        }
        function N_(B) {
          Z = bn(Z, B);
        }
        const O_ = () => {
          Xi(), Bn("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function M_() {
          Xi(), Bn("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let Hl = false;
        function Xi() {
          function B() {
            Xi();
          }
          if (document.readyState === "loading") {
            Hl || window.addEventListener("DOMContentLoaded", B, false), Hl = true;
            return;
          }
          document.querySelectorAll(Z.cssSelector).forEach(Ir);
        }
        function R_(B, oe) {
          let Ne = null;
          try {
            Ne = oe(j);
          } catch (Je) {
            if (un("Language definition for '{}' could not be registered.".replace("{}", B)), Xe)
              un(Je);
            else
              throw Je;
            Ne = ee;
          }
          Ne.name || (Ne.name = B), M[B] = Ne, Ne.rawDefinition = oe.bind(null, j), Ne.aliases && Ul(Ne.aliases, { languageName: B });
        }
        function I_(B) {
          delete M[B];
          for (const oe of Object.keys($))
            $[oe] === B && delete $[oe];
        }
        function L_() {
          return Object.keys(M);
        }
        function Xt(B) {
          return B = (B || "").toLowerCase(), M[B] || M[$[B]];
        }
        function Ul(B, { languageName: oe }) {
          typeof B == "string" && (B = [B]), B.forEach((Ne) => {
            $[Ne.toLowerCase()] = oe;
          });
        }
        function ql(B) {
          const oe = Xt(B);
          return oe && !oe.disableAutodetect;
        }
        function D_(B) {
          B["before:highlightBlock"] && !B["before:highlightElement"] && (B["before:highlightElement"] = (oe) => {
            B["before:highlightBlock"](
              Object.assign({ block: oe.el }, oe)
            );
          }), B["after:highlightBlock"] && !B["after:highlightElement"] && (B["after:highlightElement"] = (oe) => {
            B["after:highlightBlock"](
              Object.assign({ block: oe.el }, oe)
            );
          });
        }
        function B_(B) {
          D_(B), _e.push(B);
        }
        function P_(B) {
          const oe = _e.indexOf(B);
          oe !== -1 && _e.splice(oe, 1);
        }
        function Qi(B, oe) {
          const Ne = B;
          _e.forEach(function(Je) {
            Je[Ne] && Je[Ne](oe);
          });
        }
        function $_(B) {
          return Bn("10.7.0", "highlightBlock will be removed entirely in v12.0"), Bn("10.7.0", "Please use highlightElement now."), Ir(B);
        }
        Object.assign(j, {
          highlight: _n,
          highlightAuto: Rr,
          highlightAll: Xi,
          highlightElement: Ir,
          // TODO: Remove with v12 API
          highlightBlock: $_,
          configure: N_,
          initHighlighting: O_,
          initHighlightingOnLoad: M_,
          registerLanguage: R_,
          unregisterLanguage: I_,
          listLanguages: L_,
          getLanguage: Xt,
          registerAliases: Ul,
          autoDetection: ql,
          inherit: bn,
          addPlugin: B_,
          removePlugin: P_
        }), j.debugMode = function() {
          Xe = false;
        }, j.safeMode = function() {
          Xe = true;
        }, j.versionString = le, j.regex = {
          concat: f,
          lookahead: p2,
          either: h2,
          optional: m,
          anyNumberOfTimes: _
        };
        for (const B in Sn)
          typeof Sn[B] == "object" && n2(Sn[B]);
        return Object.assign(j, Sn), j;
      }, Un = ci({});
      return Un.newInstance = () => ci({}), aa = Un, Un.HighlightJS = Un, Un.default = Un, aa;
    }
    var w1 = /* @__PURE__ */ j1();
    const E1 = /* @__PURE__ */ y1(w1), Nc = {}, C1 = "hljs-";
    function S1(n2) {
      const e = E1.newInstance();
      return n2 && s(n2), {
        highlight: t,
        highlightAuto: o,
        listLanguages: i2,
        register: s,
        registerAlias: r,
        registered: a
      };
      function t(l, u, c2) {
        const d = c2 || Nc, p2 = typeof d.prefix == "string" ? d.prefix : C1;
        if (!e.getLanguage(l))
          throw new Error("Unknown language: `" + l + "` is not registered");
        e.configure({ __emitter: x1, classPrefix: p2 });
        const _ = (
          /** @type {HighlightResult & {_emitter: HastEmitter}} */
          e.highlight(u, { ignoreIllegals: true, language: l })
        );
        if (_.errorRaised)
          throw new Error("Could not highlight with `Highlight.js`", {
            cause: _.errorRaised
          });
        const m = _._emitter.root, f = (
          /** @type {RootData} */
          m.data
        );
        return f.language = _.language, f.relevance = _.relevance, m;
      }
      function o(l, u) {
        const d = (u || Nc).subset || i2();
        let p2 = -1, _ = 0, m;
        for (; ++p2 < d.length; ) {
          const f = d[p2];
          if (!e.getLanguage(f)) continue;
          const b = t(f, l, u);
          b.data && b.data.relevance !== void 0 && b.data.relevance > _ && (_ = b.data.relevance, m = b);
        }
        return m || {
          type: "root",
          children: [],
          data: { language: void 0, relevance: _ }
        };
      }
      function i2() {
        return e.listLanguages();
      }
      function s(l, u) {
        if (typeof l == "string")
          e.registerLanguage(l, u);
        else {
          let c2;
          for (c2 in l)
            Object.hasOwn(l, c2) && e.registerLanguage(c2, l[c2]);
        }
      }
      function r(l, u) {
        if (typeof l == "string")
          e.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof u == "string" ? u : [...u],
            { languageName: l }
          );
        else {
          let c2;
          for (c2 in l)
            if (Object.hasOwn(l, c2)) {
              const d = l[c2];
              e.registerAliases(
                // Note: copy needed because hljs doesnt accept readonly arrays yet.
                typeof d == "string" ? d : [...d],
                { languageName: c2 }
              );
            }
        }
      }
      function a(l) {
        return !!e.getLanguage(l);
      }
    }
    class x1 {
      /**
       * @param {Readonly<HljsOptions>} options
       *   Configuration.
       * @returns
       *   Instance.
       */
      constructor(e) {
        this.options = e, this.root = {
          type: "root",
          children: [],
          data: { language: void 0, relevance: 0 }
        }, this.stack = [this.root];
      }
      /**
       * @param {string} value
       *   Text to add.
       * @returns {undefined}
       *   Nothing.
       *
       */
      addText(e) {
        if (e === "") return;
        const t = this.stack[this.stack.length - 1], o = t.children[t.children.length - 1];
        o && o.type === "text" ? o.value += e : t.children.push({ type: "text", value: e });
      }
      /**
       *
       * @param {unknown} rawName
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      startScope(e) {
        this.openNode(String(e));
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      endScope() {
        this.closeNode();
      }
      /**
       * @param {HastEmitter} other
       *   Other emitter.
       * @param {string} name
       *   Name of the sublanguage.
       * @returns {undefined}
       *   Nothing.
       */
      __addSublanguage(e, t) {
        const o = this.stack[this.stack.length - 1], i2 = (
          /** @type {Array<ElementContent>} */
          e.root.children
        );
        t ? o.children.push({
          type: "element",
          tagName: "span",
          properties: { className: [t] },
          children: i2
        }) : o.children.push(...i2);
      }
      /**
       * @param {string} name
       *   Name to add.
       * @returns {undefined}
       *   Nothing.
       */
      openNode(e) {
        const t = this, o = e.split(".").map(function(r, a) {
          return a ? r + "_".repeat(a) : t.options.classPrefix + r;
        }), i2 = this.stack[this.stack.length - 1], s = {
          type: "element",
          tagName: "span",
          properties: { className: o },
          children: []
        };
        i2.children.push(s), this.stack.push(s);
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      closeNode() {
        this.stack.pop();
      }
      /**
       * @returns {undefined}
       *   Nothing.
       */
      finalize() {
      }
      /**
       * @returns {string}
       *   Nothing.
       */
      toHTML() {
        return "";
      }
    }
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    function T1(n2) {
      const e = document.createElement("textarea");
      e.value = n2, e.contentEditable = "true", e.style.position = "fixed", document.body.appendChild(e), e.focus(), e.select();
      const t = document.execCommand("copy");
      return e.remove(), t;
    }
    function A1(n2) {
      return navigator.clipboard !== void 0 ? navigator.clipboard.writeText(n2) : new Promise((e, t) => {
        const o = T1(n2);
        o ? e(true) : t(o);
      });
    }
    const N1 = { class: "code-block-toolbar" }, O1 = { class: "wrap editable" }, M1 = { class: "wrap" }, R1 = { class: "language readonly" }, I1 = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, t = ref("content_copy"), o = computed({
          get() {
            return e.node.attrs.language;
          },
          set(u) {
            e.updateAttributes({ language: u });
          }
        }), i2 = computed({
          get() {
            return e.node.attrs.wrap;
          },
          set(u) {
            e.updateAttributes({ wrap: u });
          }
        }), s = computed(() => i2.value ? "text_select_move_down" : "format_text_wrap");
        function r(u) {
          o.value = u;
        }
        function a() {
          const u = e.node.content.content[0].text;
          A1(u).then(() => {
            t.value = "done", setTimeout(() => {
              t.value = "content_copy";
            }, 2e3);
          });
        }
        function l() {
          i2.value = !i2.value;
        }
        return (u, c2) => (openBlock(), createBlock(unref(Jt), mergeProps(e, { class: "o-code-block-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", N1, [
              createBaseVNode("div", O1, [
                createVNode(unref(g0), {
                  language: o.value,
                  onSelect: r
                }, null, 8, ["language"])
              ]),
              createBaseVNode("div", M1, [
                createBaseVNode("div", R1, toDisplayString(o.value), 1),
                createVNode(unref(Ke), {
                  icon: s.value,
                  "icon-class": { "rotate-270": i2.value },
                  tooltip: "Wrap",
                  class: "editable",
                  onClick: l
                }, null, 8, ["icon", "icon-class"]),
                createVNode(unref(Ke), {
                  icon: t.value,
                  tooltip: "Copy",
                  onClick: a
                }, null, 8, ["icon"])
              ])
            ]),
            createBaseVNode("pre", null, [
              createVNode(unref(Yt), {
                as: "code",
                class: normalizeClass({ wrap: i2.value })
              }, null, 8, ["class"])
            ])
          ]),
          _: 1
        }, 16));
      }
    }), L1 = S1(k1), D1 = Qj.extend({
      draggable: true,
      addAttributes() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          wrap: {
            default: true,
            rendered: false
          }
        };
      },
      addNodeView() {
        return wt(I1);
      }
    }).configure({
      languageClassPrefix: "language-",
      defaultLanguage: "bash",
      lowlight: L1
    }), B1 = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, t = computed(() => e.node.attrs.level);
        return (o, i2) => (openBlock(), createBlock(unref(Jt), mergeProps(e, {
          class: ["o-heading-view", `h${t.value}`],
          style: `text-align: ${o.node.attrs.textAlign}`
        }), {
          default: withCtx(() => [
            createVNode(unref(Yt))
          ]),
          _: 1
        }, 16, ["class", "style"]));
      }
    }), P1 = dp.extend({
      draggable: true,
      addNodeView() {
        return wt(B1);
      }
    }), $1 = { class: "horizontal" }, z1 = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2;
        return (t, o) => (openBlock(), createBlock(unref(Jt), mergeProps(e, { class: "o-horizontal-view" }), {
          default: withCtx(() => [
            createBaseVNode("div", $1, [
              createVNode(unref(Yt), {
                as: "div",
                class: "divider"
              })
            ])
          ]),
          _: 1
        }, 16));
      }
    }), F1 = gp.extend({
      draggable: true,
      addNodeView() {
        return wt(z1);
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const H1 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, U1 = Node.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["img", mergeAttributes(this.options.HTMLAttributes, n2)];
      },
      addCommands() {
        return {
          setImage: (n2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: n2
          })
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: H1,
            type: this.type,
            getAttributes: (n2) => {
              const [, , e, t, o] = n2;
              return { src: t, alt: e, title: o };
            }
          })
        ];
      }
    }), q1 = U1.extend({
      draggable: true,
      addAttributes() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          size: {
            default: "",
            rendered: false
          },
          // small, medium, large
          ratio: {
            default: "",
            rendered: false
          },
          isDraggable: {
            default: true,
            renderHTML: (e) => ({})
          }
        };
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        return e.size = n2.attrs.size, e.ratio = n2.attrs.ratio, ["img", mergeAttributes(this.options.HTMLAttributes, e)];
      }
    }), K1 = {
      key: 1,
      class: "image-container"
    }, V1 = { key: 1 }, W1 = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, { isEditable: t } = Le(), o = ref(false), i2 = ref(false), s = ref({}), r = ref(null), a = ref(false), l = computed(() => e.node.attrs), u = computed({
          get() {
            return e.node.attrs.src;
          },
          set(h2) {
            e.updateAttributes({ src: h2 });
          }
        }), c2 = computed({
          get() {
            return e.node.attrs.title;
          },
          set(h2) {
            e.updateAttributes({ title: h2 });
          }
        });
        function d() {
          a.value = true, setTimeout(() => {
            var h2;
            (h2 = r.value) == null || h2.focus();
          }, 0);
        }
        function p2() {
          a.value = false;
        }
        function _() {
          u.value === "init" && b(true);
        }
        function m(h2) {
          switch (o.value = false, h2.value) {
            case "replace":
              b(true);
              break;
          }
        }
        function f(h2) {
          u.value = h2, b(false);
        }
        function b(h2) {
          i2.value = h2;
        }
        return onMounted(() => {
          b(u.value === "init");
        }), (h2, y) => {
          var C;
          return openBlock(), createBlock(unref(Jt), mergeProps(e, {
            class: ["o-image-view", {
              "with-caption": l.value.alt,
              "with-ratio": l.value.ratio,
              readonly: !((C = h2.editor) != null && C.isEditable),
              init: u.value === "init"
            }],
            size: l.value.size,
            as: "div",
            onClick: _
          }), {
            default: withCtx(() => [
              createVNode(unref($i), {
                modelValue: i2.value,
                "onUpdate:modelValue": y[1] || (y[1] = (v) => i2.value = v),
                placement: u.value === "init" ? "bottom" : "top",
                "show-arrow": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(wp), {
                    val: u.value === "init" ? "" : u.value,
                    type: "image",
                    onInput: f
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var v;
                  return [
                    u.value === "init" ? (openBlock(), createBlock(unref(bp), {
                      key: 0,
                      icon: "image",
                      placeholder: "Add an image"
                    })) : (openBlock(), createElementBlock("div", K1, [
                      unref(t) ? (openBlock(), createBlock(unref(kp), mergeProps({ key: 0 }, e, { onAction: m }), {
                        default: withCtx(() => [
                          createVNode(unref(Ke), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: d
                          })
                        ]),
                        _: 1
                      }, 16)) : createCommentVNode("", true),
                      createBaseVNode("img", mergeProps(l.value, {
                        draggable: "true",
                        "data-drag-handle": ""
                      }), null, 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: d
                      }, [
                        (v = h2.editor) != null && v.isEditable && a.value ? (openBlock(), createBlock(unref(ai), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: r,
                          class: "caption-input",
                          modelValue: c2.value,
                          "onUpdate:modelValue": y[0] || (y[0] = (x) => c2.value = x),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: p2
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", V1, toDisplayString(c2.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(bl), {
                modelValue: o.value,
                "onUpdate:modelValue": y[2] || (y[2] = (v) => o.value = v),
                event: s.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(ri), mergeProps(e, { onAction: m }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class", "size"]);
        };
      }
    }), G1 = q1.extend({
      addNodeView() {
        return wt(W1);
      }
    }).configure({
      inline: true
    }), Y1 = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", J1 = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", si = (n2, e) => {
      for (const t in e)
        n2[t] = e[t];
      return n2;
    }, za = "numeric", Fa = "ascii", Ha = "alpha", wi = "asciinumeric", vi = "alphanumeric", Ua = "domain", g_ = "emoji", Z1 = "scheme", X1 = "slashscheme", la = "whitespace";
    function Q1(n2, e) {
      return n2 in e || (e[n2] = []), e[n2];
    }
    function Eo(n2, e, t) {
      e[za] && (e[wi] = true, e[vi] = true), e[Fa] && (e[wi] = true, e[Ha] = true), e[wi] && (e[vi] = true), e[Ha] && (e[vi] = true), e[vi] && (e[Ua] = true), e[g_] && (e[Ua] = true);
      for (const o in e) {
        const i2 = Q1(o, t);
        i2.indexOf(n2) < 0 && i2.push(n2);
      }
    }
    function eE(n2, e) {
      const t = {};
      for (const o in e)
        e[o].indexOf(n2) >= 0 && (t[o] = true);
      return t;
    }
    function qn(n2 = null) {
      this.j = {}, this.jr = [], this.jd = null, this.t = n2;
    }
    qn.groups = {};
    qn.prototype = {
      accepts() {
        return !!this.t;
      },
      /**
       * Follow an existing transition from the given input to the next state.
       * Does not mutate.
       * @param {string} input character or token type to transition on
       * @returns {?State<T>} the next state, if any
       */
      go(n2) {
        const e = this, t = e.j[n2];
        if (t)
          return t;
        for (let o = 0; o < e.jr.length; o++) {
          const i2 = e.jr[o][0], s = e.jr[o][1];
          if (s && i2.test(n2))
            return s;
        }
        return e.jd;
      },
      /**
       * Whether the state has a transition for the given input. Set the second
       * argument to true to only look for an exact match (and not a default or
       * regular-expression-based transition)
       * @param {string} input
       * @param {boolean} exactOnly
       */
      has(n2, e = false) {
        return e ? n2 in this.j : !!this.go(n2);
      },
      /**
       * Short for "transition all"; create a transition from the array of items
       * in the given list to the same final resulting state.
       * @param {string | string[]} inputs Group of inputs to transition on
       * @param {Transition<T> | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       */
      ta(n2, e, t, o) {
        for (let i2 = 0; i2 < n2.length; i2++)
          this.tt(n2[i2], e, t, o);
      },
      /**
       * Short for "take regexp transition"; defines a transition for this state
       * when it encounters a token which matches the given regular expression
       * @param {RegExp} regexp Regular expression transition (populate first)
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      tr(n2, e, t, o) {
        o = o || qn.groups;
        let i2;
        return e && e.j ? i2 = e : (i2 = new qn(e), t && o && Eo(e, t, o)), this.jr.push([n2, i2]), i2;
      },
      /**
       * Short for "take transitions", will take as many sequential transitions as
       * the length of the given input and returns the
       * resulting final state.
       * @param {string | string[]} input
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of token groups
       * @returns {State<T>} taken after the given input
       */
      ts(n2, e, t, o) {
        let i2 = this;
        const s = n2.length;
        if (!s)
          return i2;
        for (let r = 0; r < s - 1; r++)
          i2 = i2.tt(n2[r]);
        return i2.tt(n2[s - 1], e, t, o);
      },
      /**
       * Short for "take transition", this is a method for building/working with
       * state machines.
       *
       * If a state already exists for the given input, returns it.
       *
       * If a token is specified, that state will emit that token when reached by
       * the linkify engine.
       *
       * If no state exists, it will be initialized with some default transitions
       * that resemble existing default transitions.
       *
       * If a state is given for the second argument, that state will be
       * transitioned to on the given input regardless of what that input
       * previously did.
       *
       * Specify a token group flags to define groups that this token belongs to.
       * The token will be added to corresponding entires in the given groups
       * object.
       *
       * @param {string} input character, token type to transition on
       * @param {T | State<T>} [next] Transition options
       * @param {Flags} [flags] Collections flags to add token to
       * @param {Collections<T>} [groups] Master list of groups
       * @returns {State<T>} taken after the given input
       */
      tt(n2, e, t, o) {
        o = o || qn.groups;
        const i2 = this;
        if (e && e.j)
          return i2.j[n2] = e, e;
        const s = e;
        let r, a = i2.go(n2);
        if (a ? (r = new qn(), si(r.j, a.j), r.jr.push.apply(r.jr, a.jr), r.jd = a.jd, r.t = a.t) : r = new qn(), s) {
          if (o)
            if (r.t && typeof r.t == "string") {
              const l = si(eE(r.t, o), t);
              Eo(s, l, o);
            } else t && Eo(s, t, o);
          r.t = s;
        }
        return i2.j[n2] = r, r;
      }
    };
    const we = (n2, e, t, o, i2) => n2.ta(e, t, o, i2), on = (n2, e, t, o, i2) => n2.tr(e, t, o, i2), Oc = (n2, e, t, o, i2) => n2.ts(e, t, o, i2), D = (n2, e, t, o, i2) => n2.tt(e, t, o, i2), Kt = "WORD", qa = "UWORD", h_ = "ASCIINUMERICAL", v_ = "ALPHANUMERICAL", Ui = "LOCALHOST", Ka = "TLD", Va = "UTLD", Ms = "SCHEME", Vo = "SLASH_SCHEME", Rl = "NUM", Wa = "WS", Il = "NL", Ei = "OPENBRACE", Ci = "CLOSEBRACE", Ys = "OPENBRACKET", Js = "CLOSEBRACKET", Zs = "OPENPAREN", Xs = "CLOSEPAREN", Qs = "OPENANGLEBRACKET", er = "CLOSEANGLEBRACKET", nr = "FULLWIDTHLEFTPAREN", tr = "FULLWIDTHRIGHTPAREN", or = "LEFTCORNERBRACKET", ir = "RIGHTCORNERBRACKET", sr = "LEFTWHITECORNERBRACKET", rr = "RIGHTWHITECORNERBRACKET", ar = "FULLWIDTHLESSTHAN", lr = "FULLWIDTHGREATERTHAN", ur = "AMPERSAND", Ll = "APOSTROPHE", cr = "ASTERISK", oo = "AT", dr = "BACKSLASH", pr = "BACKTICK", _r = "CARET", so = "COLON", Dl = "COMMA", mr = "DOLLAR", Mt = "DOT", fr = "EQUALS", Bl = "EXCLAMATION", rt = "HYPHEN", Si = "PERCENT", gr = "PIPE", hr = "PLUS", vr = "POUND", xi = "QUERY", Pl = "QUOTE", b_ = "FULLWIDTHMIDDLEDOT", $l = "SEMI", Rt = "SLASH", Ti = "TILDE", br = "UNDERSCORE", k_ = "EMOJI", kr = "SYM";
    var y_ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      WORD: Kt,
      UWORD: qa,
      ASCIINUMERICAL: h_,
      ALPHANUMERICAL: v_,
      LOCALHOST: Ui,
      TLD: Ka,
      UTLD: Va,
      SCHEME: Ms,
      SLASH_SCHEME: Vo,
      NUM: Rl,
      WS: Wa,
      NL: Il,
      OPENBRACE: Ei,
      CLOSEBRACE: Ci,
      OPENBRACKET: Ys,
      CLOSEBRACKET: Js,
      OPENPAREN: Zs,
      CLOSEPAREN: Xs,
      OPENANGLEBRACKET: Qs,
      CLOSEANGLEBRACKET: er,
      FULLWIDTHLEFTPAREN: nr,
      FULLWIDTHRIGHTPAREN: tr,
      LEFTCORNERBRACKET: or,
      RIGHTCORNERBRACKET: ir,
      LEFTWHITECORNERBRACKET: sr,
      RIGHTWHITECORNERBRACKET: rr,
      FULLWIDTHLESSTHAN: ar,
      FULLWIDTHGREATERTHAN: lr,
      AMPERSAND: ur,
      APOSTROPHE: Ll,
      ASTERISK: cr,
      AT: oo,
      BACKSLASH: dr,
      BACKTICK: pr,
      CARET: _r,
      COLON: so,
      COMMA: Dl,
      DOLLAR: mr,
      DOT: Mt,
      EQUALS: fr,
      EXCLAMATION: Bl,
      HYPHEN: rt,
      PERCENT: Si,
      PIPE: gr,
      PLUS: hr,
      POUND: vr,
      QUERY: xi,
      QUOTE: Pl,
      FULLWIDTHMIDDLEDOT: b_,
      SEMI: $l,
      SLASH: Rt,
      TILDE: Ti,
      UNDERSCORE: br,
      EMOJI: k_,
      SYM: kr
    });
    const Ht = /[a-z]/, mi = new RegExp("\\p{L}", "u"), ua = new RegExp("\\p{Emoji}", "u"), Ut = /\d/, ca = /\s/, Mc = "\r", da = `
`, nE = "", tE = "", pa = "";
    let ys = null, js = null;
    function oE(n2 = []) {
      const e = {};
      qn.groups = e;
      const t = new qn();
      ys == null && (ys = Rc(Y1)), js == null && (js = Rc(J1)), D(t, "'", Ll), D(t, "{", Ei), D(t, "}", Ci), D(t, "[", Ys), D(t, "]", Js), D(t, "(", Zs), D(t, ")", Xs), D(t, "<", Qs), D(t, ">", er), D(t, "", nr), D(t, "", tr), D(t, "", or), D(t, "", ir), D(t, "", sr), D(t, "", rr), D(t, "", ar), D(t, "", lr), D(t, "&", ur), D(t, "*", cr), D(t, "@", oo), D(t, "`", pr), D(t, "^", _r), D(t, ":", so), D(t, ",", Dl), D(t, "$", mr), D(t, ".", Mt), D(t, "=", fr), D(t, "!", Bl), D(t, "-", rt), D(t, "%", Si), D(t, "|", gr), D(t, "+", hr), D(t, "#", vr), D(t, "?", xi), D(t, '"', Pl), D(t, "/", Rt), D(t, ";", $l), D(t, "~", Ti), D(t, "_", br), D(t, "\\", dr), D(t, "", b_);
      const o = on(t, Ut, Rl, {
        [za]: true
      });
      on(o, Ut, o);
      const i2 = on(o, Ht, h_, {
        [wi]: true
      }), s = on(o, mi, v_, {
        [vi]: true
      }), r = on(t, Ht, Kt, {
        [Fa]: true
      });
      on(r, Ut, i2), on(r, Ht, r), on(i2, Ut, i2), on(i2, Ht, i2);
      const a = on(t, mi, qa, {
        [Ha]: true
      });
      on(a, Ht), on(a, Ut, s), on(a, mi, a), on(s, Ut, s), on(s, Ht), on(s, mi, s);
      const l = D(t, da, Il, {
        [la]: true
      }), u = D(t, Mc, Wa, {
        [la]: true
      }), c2 = on(t, ca, Wa, {
        [la]: true
      });
      D(t, pa, c2), D(u, da, l), D(u, pa, c2), on(u, ca, c2), D(c2, Mc), D(c2, da), on(c2, ca, c2), D(c2, pa, c2);
      const d = on(t, ua, k_, {
        [g_]: true
      });
      D(d, "#"), on(d, ua, d), D(d, nE, d);
      const p2 = D(d, tE);
      D(p2, "#"), on(p2, ua, d);
      const _ = [[Ht, r], [Ut, i2]], m = [[Ht, null], [mi, a], [Ut, s]];
      for (let f = 0; f < ys.length; f++)
        eo(t, ys[f], Ka, Kt, _);
      for (let f = 0; f < js.length; f++)
        eo(t, js[f], Va, qa, m);
      Eo(Ka, {
        tld: true,
        ascii: true
      }, e), Eo(Va, {
        utld: true,
        alpha: true
      }, e), eo(t, "file", Ms, Kt, _), eo(t, "mailto", Ms, Kt, _), eo(t, "http", Vo, Kt, _), eo(t, "https", Vo, Kt, _), eo(t, "ftp", Vo, Kt, _), eo(t, "ftps", Vo, Kt, _), Eo(Ms, {
        scheme: true,
        ascii: true
      }, e), Eo(Vo, {
        slashscheme: true,
        ascii: true
      }, e), n2 = n2.sort((f, b) => f[0] > b[0] ? 1 : -1);
      for (let f = 0; f < n2.length; f++) {
        const b = n2[f][0], y = n2[f][1] ? {
          [Z1]: true
        } : {
          [X1]: true
        };
        b.indexOf("-") >= 0 ? y[Ua] = true : Ht.test(b) ? Ut.test(b) ? y[wi] = true : y[Fa] = true : y[za] = true, Oc(t, b, b, y);
      }
      return Oc(t, "localhost", Ui, {
        ascii: true
      }), t.jd = new qn(kr), {
        start: t,
        tokens: si({
          groups: e
        }, y_)
      };
    }
    function j_(n2, e) {
      const t = iE(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), o = t.length, i2 = [];
      let s = 0, r = 0;
      for (; r < o; ) {
        let a = n2, l = null, u = 0, c2 = null, d = -1, p2 = -1;
        for (; r < o && (l = a.go(t[r])); )
          a = l, a.accepts() ? (d = 0, p2 = 0, c2 = a) : d >= 0 && (d += t[r].length, p2++), u += t[r].length, s += t[r].length, r++;
        s -= d, r -= p2, u -= d, i2.push({
          t: c2.t,
          // token type/name
          v: e.slice(s - u, s),
          // string value
          s: s - u,
          // start index
          e: s
          // end index (excluding)
        });
      }
      return i2;
    }
    function iE(n2) {
      const e = [], t = n2.length;
      let o = 0;
      for (; o < t; ) {
        let i2 = n2.charCodeAt(o), s, r = i2 < 55296 || i2 > 56319 || o + 1 === t || (s = n2.charCodeAt(o + 1)) < 56320 || s > 57343 ? n2[o] : n2.slice(o, o + 2);
        e.push(r), o += r.length;
      }
      return e;
    }
    function eo(n2, e, t, o, i2) {
      let s;
      const r = e.length;
      for (let a = 0; a < r - 1; a++) {
        const l = e[a];
        n2.j[l] ? s = n2.j[l] : (s = new qn(o), s.jr = i2.slice(), n2.j[l] = s), n2 = s;
      }
      return s = new qn(t), s.jr = i2.slice(), n2.j[e[r - 1]] = s, s;
    }
    function Rc(n2) {
      const e = [], t = [];
      let o = 0, i2 = "0123456789";
      for (; o < n2.length; ) {
        let s = 0;
        for (; i2.indexOf(n2[o + s]) >= 0; )
          s++;
        if (s > 0) {
          e.push(t.join(""));
          for (let r = parseInt(n2.substring(o, o + s), 10); r > 0; r--)
            t.pop();
          o += s;
        } else
          t.push(n2[o]), o++;
      }
      return e;
    }
    const qi = {
      defaultProtocol: "http",
      events: null,
      format: Ic,
      formatHref: Ic,
      nl2br: false,
      tagName: "a",
      target: null,
      rel: null,
      validate: true,
      truncate: 1 / 0,
      className: null,
      attributes: null,
      ignoreTags: [],
      render: null
    };
    function zl(n2, e = null) {
      let t = si({}, qi);
      n2 && (t = si(t, n2 instanceof zl ? n2.o : n2));
      const o = t.ignoreTags, i2 = [];
      for (let s = 0; s < o.length; s++)
        i2.push(o[s].toUpperCase());
      this.o = t, e && (this.defaultRender = e), this.ignoreTags = i2;
    }
    zl.prototype = {
      o: qi,
      /**
       * @type string[]
       */
      ignoreTags: [],
      /**
       * @param {IntermediateRepresentation} ir
       * @returns {any}
       */
      defaultRender(n2) {
        return n2;
      },
      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options.
       * @param {MultiToken} token
       * @returns {boolean}
       */
      check(n2) {
        return this.get("validate", n2.toString(), n2);
      },
      // Private methods
      /**
       * Resolve an option's value based on the value of the option and the given
       * params. If operator and token are specified and the target option is
       * callable, automatically calls the function with the given argument.
       * @template {keyof Opts} K
       * @param {K} key Name of option to use
       * @param {string} [operator] will be passed to the target option if it's a
       * function. If not specified, RAW function value gets returned
       * @param {MultiToken} [token] The token from linkify.tokenize
       * @returns {Opts[K] | any}
       */
      get(n2, e, t) {
        const o = e != null;
        let i2 = this.o[n2];
        return i2 && (typeof i2 == "object" ? (i2 = t.t in i2 ? i2[t.t] : qi[n2], typeof i2 == "function" && o && (i2 = i2(e, t))) : typeof i2 == "function" && o && (i2 = i2(e, t.t, t)), i2);
      },
      /**
       * @template {keyof Opts} L
       * @param {L} key Name of options object to use
       * @param {string} [operator]
       * @param {MultiToken} [token]
       * @returns {Opts[L] | any}
       */
      getObj(n2, e, t) {
        let o = this.o[n2];
        return typeof o == "function" && e != null && (o = o(e, t.t, t)), o;
      },
      /**
       * Convert the given token to a rendered element that may be added to the
       * calling-interface's DOM
       * @param {MultiToken} token Token to render to an HTML element
       * @returns {any} Render result; e.g., HTML string, DOM element, React
       *   Component, etc.
       */
      render(n2) {
        const e = n2.render(this);
        return (this.get("render", null, n2) || this.defaultRender)(e, n2.t, n2);
      }
    };
    function Ic(n2) {
      return n2;
    }
    function w_(n2, e) {
      this.t = "token", this.v = n2, this.tk = e;
    }
    w_.prototype = {
      isLink: false,
      /**
       * Return the string this token represents.
       * @return {string}
       */
      toString() {
        return this.v;
      },
      /**
       * What should the value for this token be in the `href` HTML attribute?
       * Returns the `.toString` value by default.
       * @param {string} [scheme]
       * @return {string}
       */
      toHref(n2) {
        return this.toString();
      },
      /**
       * @param {Options} options Formatting options
       * @returns {string}
       */
      toFormattedString(n2) {
        const e = this.toString(), t = n2.get("truncate", e, this), o = n2.get("format", e, this);
        return t && o.length > t ? o.substring(0, t) + "" : o;
      },
      /**
       *
       * @param {Options} options
       * @returns {string}
       */
      toFormattedHref(n2) {
        return n2.get("formatHref", this.toHref(n2.get("defaultProtocol")), this);
      },
      /**
       * The start index of this token in the original input string
       * @returns {number}
       */
      startIndex() {
        return this.tk[0].s;
      },
      /**
       * The end index of this token in the original input string (up to this
       * index but not including it)
       * @returns {number}
       */
      endIndex() {
        return this.tk[this.tk.length - 1].e;
      },
      /**
      	Returns an object  of relevant values for this token, which includes keys
      	* type - Kind of token ('url', 'email', etc.)
      	* value - Original text
      	* href - The value that should be added to the anchor tag's href
      		attribute
      		@method toObject
      	@param {string} [protocol] `'http'` by default
      */
      toObject(n2 = qi.defaultProtocol) {
        return {
          type: this.t,
          value: this.toString(),
          isLink: this.isLink,
          href: this.toHref(n2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       *
       * @param {Options} options Formatting option
       */
      toFormattedObject(n2) {
        return {
          type: this.t,
          value: this.toFormattedString(n2),
          isLink: this.isLink,
          href: this.toFormattedHref(n2),
          start: this.startIndex(),
          end: this.endIndex()
        };
      },
      /**
       * Whether this token should be rendered as a link according to the given options
       * @param {Options} options
       * @returns {boolean}
       */
      validate(n2) {
        return n2.get("validate", this.toString(), this);
      },
      /**
       * Return an object that represents how this link should be rendered.
       * @param {Options} options Formattinng options
       */
      render(n2) {
        const e = this, t = this.toHref(n2.get("defaultProtocol")), o = n2.get("formatHref", t, this), i2 = n2.get("tagName", t, e), s = this.toFormattedString(n2), r = {}, a = n2.get("className", t, e), l = n2.get("target", t, e), u = n2.get("rel", t, e), c2 = n2.getObj("attributes", t, e), d = n2.getObj("events", t, e);
        return r.href = o, a && (r.class = a), l && (r.target = l), u && (r.rel = u), c2 && si(r, c2), {
          tagName: i2,
          attributes: r,
          content: s,
          eventListeners: d
        };
      }
    };
    function Or(n2, e) {
      class t extends w_ {
        constructor(i2, s) {
          super(i2, s), this.t = n2;
        }
      }
      for (const o in e)
        t.prototype[o] = e[o];
      return t.t = n2, t;
    }
    const Lc = Or("email", {
      isLink: true,
      toHref() {
        return "mailto:" + this.toString();
      }
    }), Dc = Or("text"), sE = Or("nl"), ws = Or("url", {
      isLink: true,
      /**
      	Lowercases relevant parts of the domain and adds the protocol if
      	required. Note that this will not escape unsafe HTML characters in the
      	URL.
      		@param {string} [scheme] default scheme (e.g., 'https')
      	@return {string} the full href
      */
      toHref(n2 = qi.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${n2}://${this.v}`;
      },
      /**
       * Check whether this URL token has a protocol
       * @return {boolean}
       */
      hasProtocol() {
        const n2 = this.tk;
        return n2.length >= 2 && n2[0].t !== Ui && n2[1].t === so;
      }
    }), st = (n2) => new qn(n2);
    function rE({
      groups: n2
    }) {
      const e = n2.domain.concat([ur, cr, oo, dr, pr, _r, mr, fr, rt, Rl, Si, gr, hr, vr, Rt, kr, Ti, br]), t = [so, Dl, Mt, Bl, Si, xi, Pl, $l, Qs, er, Ei, Ci, Js, Ys, Zs, Xs, nr, tr, or, ir, sr, rr, ar, lr], o = [ur, Ll, cr, dr, pr, _r, mr, fr, rt, Ei, Ci, Si, gr, hr, vr, xi, Rt, kr, Ti, br], i2 = st(), s = D(i2, Ti);
      we(s, o, s), we(s, n2.domain, s);
      const r = st(), a = st(), l = st();
      we(i2, n2.domain, r), we(i2, n2.scheme, a), we(i2, n2.slashscheme, l), we(r, o, s), we(r, n2.domain, r);
      const u = D(r, oo);
      D(s, oo, u), D(a, oo, u), D(l, oo, u);
      const c2 = D(s, Mt);
      we(c2, o, s), we(c2, n2.domain, s);
      const d = st();
      we(u, n2.domain, d), we(d, n2.domain, d);
      const p2 = D(d, Mt);
      we(p2, n2.domain, d);
      const _ = st(Lc);
      we(p2, n2.tld, _), we(p2, n2.utld, _), D(u, Ui, _);
      const m = D(d, rt);
      D(m, rt, m), we(m, n2.domain, d), we(_, n2.domain, d), D(_, Mt, p2), D(_, rt, m);
      const f = D(_, so);
      we(f, n2.numeric, Lc);
      const b = D(r, rt), h2 = D(r, Mt);
      D(b, rt, b), we(b, n2.domain, r), we(h2, o, s), we(h2, n2.domain, r);
      const y = st(ws);
      we(h2, n2.tld, y), we(h2, n2.utld, y), we(y, n2.domain, r), we(y, o, s), D(y, Mt, h2), D(y, rt, b), D(y, oo, u);
      const C = D(y, so), v = st(ws);
      we(C, n2.numeric, v);
      const x = st(ws), S = st();
      we(x, e, x), we(x, t, S), we(S, e, x), we(S, t, S), D(y, Rt, x), D(v, Rt, x);
      const F = D(a, so), Y = D(l, so), q = D(Y, Rt), K = D(q, Rt);
      we(a, n2.domain, r), D(a, Mt, h2), D(a, rt, b), we(l, n2.domain, r), D(l, Mt, h2), D(l, rt, b), we(F, n2.domain, x), D(F, Rt, x), D(F, xi, x), we(K, n2.domain, x), we(K, e, x), D(K, Rt, x);
      const ie2 = [
        [Ei, Ci],
        // {}
        [Ys, Js],
        // []
        [Zs, Xs],
        // ()
        [Qs, er],
        // <>
        [nr, tr],
        // 
        [or, ir],
        // 
        [sr, rr],
        // 
        [ar, lr]
        // 
      ];
      for (let ce = 0; ce < ie2.length; ce++) {
        const [ve, he] = ie2[ce], de = D(x, ve);
        D(S, ve, de), D(de, he, x);
        const pe = st(ws);
        we(de, e, pe);
        const N = st();
        we(de, t), we(pe, e, pe), we(pe, t, N), we(N, e, pe), we(N, t, N), D(pe, he, x), D(N, he, x);
      }
      return D(i2, Ui, y), D(i2, Il, sE), {
        start: i2,
        tokens: y_
      };
    }
    function aE(n2, e, t) {
      let o = t.length, i2 = 0, s = [], r = [];
      for (; i2 < o; ) {
        let a = n2, l = null, u = null, c2 = 0, d = null, p2 = -1;
        for (; i2 < o && !(l = a.go(t[i2].t)); )
          r.push(t[i2++]);
        for (; i2 < o && (u = l || a.go(t[i2].t)); )
          l = null, a = u, a.accepts() ? (p2 = 0, d = a) : p2 >= 0 && p2++, i2++, c2++;
        if (p2 < 0)
          i2 -= c2, i2 < o && (r.push(t[i2]), i2++);
        else {
          r.length > 0 && (s.push(_a(Dc, e, r)), r = []), i2 -= p2, c2 -= p2;
          const _ = d.t, m = t.slice(i2 - c2, i2);
          s.push(_a(_, e, m));
        }
      }
      return r.length > 0 && s.push(_a(Dc, e, r)), s;
    }
    function _a(n2, e, t) {
      const o = t[0].s, i2 = t[t.length - 1].e, s = e.slice(o, i2);
      return new n2(s, t);
    }
    const lE = typeof console < "u" && console && console.warn || (() => {
    }), uE = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Qe = {
      scanner: null,
      parser: null,
      tokenQueue: [],
      pluginQueue: [],
      customSchemes: [],
      initialized: false
    };
    function cE() {
      return qn.groups = {}, Qe.scanner = null, Qe.parser = null, Qe.tokenQueue = [], Qe.pluginQueue = [], Qe.customSchemes = [], Qe.initialized = false, Qe;
    }
    function Bc(n2, e = false) {
      if (Qe.initialized && lE(`linkifyjs: already initialized - will not register custom scheme "${n2}" ${uE}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n2))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
      Qe.customSchemes.push([n2, e]);
    }
    function dE() {
      Qe.scanner = oE(Qe.customSchemes);
      for (let n2 = 0; n2 < Qe.tokenQueue.length; n2++)
        Qe.tokenQueue[n2][1]({
          scanner: Qe.scanner
        });
      Qe.parser = rE(Qe.scanner.tokens);
      for (let n2 = 0; n2 < Qe.pluginQueue.length; n2++)
        Qe.pluginQueue[n2][1]({
          scanner: Qe.scanner,
          parser: Qe.parser
        });
      return Qe.initialized = true, Qe;
    }
    function Fl(n2) {
      return Qe.initialized || dE(), aE(Qe.parser.start, n2, j_(Qe.scanner.start, n2));
    }
    Fl.scan = j_;
    function E_(n2, e = null, t = null) {
      if (e && typeof e == "object") {
        if (t)
          throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        t = e, e = null;
      }
      const o = new zl(t), i2 = Fl(n2), s = [];
      for (let r = 0; r < i2.length; r++) {
        const a = i2[r];
        a.isLink && (!e || a.t === e) && o.check(a) && s.push(a.toFormattedObject(o));
      }
      return s;
    }
    function pE(n2) {
      return n2.length === 1 ? n2[0].isLink : n2.length === 3 && n2[1].isLink ? ["()", "[]"].includes(n2[0].value + n2[2].value) : false;
    }
    function _E(n2) {
      return new dn({
        key: new en("autolink"),
        appendTransaction: (e, t, o) => {
          const i2 = e.some((u) => u.docChanged) && !t.doc.eq(o.doc), s = e.some((u) => u.getMeta("preventAutolink"));
          if (!i2 || s)
            return;
          const { tr: r } = o, a = combineTransactionSteps(t.doc, [...e]);
          if (getChangedRanges(a).forEach(({ newRange: u }) => {
            const c2 = findChildrenInRange(o.doc, u, (_) => _.isTextblock);
            let d, p2;
            if (c2.length > 1 ? (d = c2[0], p2 = o.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : c2.length && o.doc.textBetween(u.from, u.to, " ", " ").endsWith(" ") && (d = c2[0], p2 = o.doc.textBetween(d.pos, u.to, void 0, " ")), d && p2) {
              const _ = p2.split(" ").filter((h2) => h2 !== "");
              if (_.length <= 0)
                return false;
              const m = _[_.length - 1], f = d.pos + p2.lastIndexOf(m);
              if (!m)
                return false;
              const b = Fl(m).map((h2) => h2.toObject(n2.defaultProtocol));
              if (!pE(b))
                return false;
              b.filter((h2) => h2.isLink).map((h2) => ({
                ...h2,
                from: f + h2.start + 1,
                to: f + h2.end + 1
              })).filter((h2) => o.schema.marks.code ? !o.doc.rangeHasMark(h2.from, h2.to, o.schema.marks.code) : true).filter((h2) => n2.validate(h2.value)).filter((h2) => n2.shouldAutoLink(h2.value)).forEach((h2) => {
                getMarksBetween(h2.from, h2.to, o.doc).some((y) => y.mark.type === n2.type) || r.addMark(h2.from, h2.to, n2.type.create({
                  href: h2.href
                }));
              });
            }
          }), !!r.steps.length)
            return r;
        }
      });
    }
    function mE(n2) {
      return new dn({
        key: new en("handleClickLink"),
        props: {
          handleClick: (e, t, o) => {
            var i2, s;
            if (o.button !== 0 || !e.editable)
              return false;
            let r = o.target;
            const a = [];
            for (; r.nodeName !== "DIV"; )
              a.push(r), r = r.parentNode;
            if (!a.find((p2) => p2.nodeName === "A"))
              return false;
            const l = getAttributes(e.state, n2.type.name), u = o.target, c2 = (i2 = u == null ? void 0 : u.href) !== null && i2 !== void 0 ? i2 : l.href, d = (s = u == null ? void 0 : u.target) !== null && s !== void 0 ? s : l.target;
            return u && c2 ? (window.open(c2, d), true) : false;
          }
        }
      });
    }
    function fE(n2) {
      return new dn({
        key: new en("handlePasteLink"),
        props: {
          handlePaste: (e, t, o) => {
            const { state: i2 } = e, { selection: s } = i2, { empty: r } = s;
            if (r)
              return false;
            let a = "";
            o.content.forEach((u) => {
              a += u.textContent;
            });
            const l = E_(a, { defaultProtocol: n2.defaultProtocol }).find((u) => u.isLink && u.value === a);
            return !a || !l ? false : n2.editor.commands.setMark(n2.type, {
              href: l.href
            });
          }
        }
      });
    }
    const gE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
    function yo(n2, e) {
      const t = [
        "http",
        "https",
        "ftp",
        "ftps",
        "mailto",
        "tel",
        "callto",
        "sms",
        "cid",
        "xmpp"
      ];
      return e && e.forEach((o) => {
        const i2 = typeof o == "string" ? o : o.scheme;
        i2 && t.push(i2);
      }), !n2 || n2.replace(gE, "").match(new RegExp(
        // eslint-disable-next-line no-useless-escape
        `^(?:(?:${t.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
        "i"
      ));
    }
    const C_ = Mark.create({
      name: "link",
      priority: 1e3,
      keepOnSplit: false,
      exitable: true,
      onCreate() {
        this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((n2) => {
          if (typeof n2 == "string") {
            Bc(n2);
            return;
          }
          Bc(n2.scheme, n2.optionalSlashes);
        });
      },
      onDestroy() {
        cE();
      },
      inclusive() {
        return this.options.autolink;
      },
      addOptions() {
        return {
          openOnClick: true,
          linkOnPaste: true,
          autolink: true,
          protocols: [],
          defaultProtocol: "http",
          HTMLAttributes: {
            target: "_blank",
            rel: "noopener noreferrer nofollow",
            class: null
          },
          isAllowedUri: (n2, e) => !!yo(n2, e.protocols),
          validate: (n2) => !!n2,
          shouldAutoLink: (n2) => !!n2
        };
      },
      addAttributes() {
        return {
          href: {
            default: null,
            parseHTML(n2) {
              return n2.getAttribute("href");
            }
          },
          target: {
            default: this.options.HTMLAttributes.target
          },
          rel: {
            default: this.options.HTMLAttributes.rel
          },
          class: {
            default: this.options.HTMLAttributes.class
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "a[href]",
            getAttrs: (n2) => {
              const e = n2.getAttribute("href");
              return !e || !this.options.isAllowedUri(e, {
                defaultValidate: (t) => !!yo(t, this.options.protocols),
                protocols: this.options.protocols,
                defaultProtocol: this.options.defaultProtocol
              }) ? false : null;
            }
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return this.options.isAllowedUri(n2.href, {
          defaultValidate: (e) => !!yo(e, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? ["a", mergeAttributes(this.options.HTMLAttributes, n2), 0] : [
          "a",
          mergeAttributes(this.options.HTMLAttributes, { ...n2, href: "" }),
          0
        ];
      },
      addCommands() {
        return {
          setLink: (n2) => ({ chain: e }) => {
            const { href: t } = n2;
            return this.options.isAllowedUri(t, {
              defaultValidate: (o) => !!yo(o, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().setMark(this.name, n2).setMeta("preventAutolink", true).run() : false;
          },
          toggleLink: (n2) => ({ chain: e }) => {
            const { href: t } = n2;
            return this.options.isAllowedUri(t, {
              defaultValidate: (o) => !!yo(o, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            }) ? e().toggleMark(this.name, n2, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() : false;
          },
          unsetLink: () => ({ chain: n2 }) => n2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run()
        };
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: (n2) => {
              const e = [];
              if (n2) {
                const { protocols: t, defaultProtocol: o } = this.options, i2 = E_(n2).filter((s) => s.isLink && this.options.isAllowedUri(s.value, {
                  defaultValidate: (r) => !!yo(r, t),
                  protocols: t,
                  defaultProtocol: o
                }));
                i2.length && i2.forEach((s) => e.push({
                  text: s.value,
                  data: {
                    href: s.href
                  },
                  index: s.start
                }));
              }
              return e;
            },
            type: this.type,
            getAttributes: (n2) => {
              var e;
              return {
                href: (e = n2.data) === null || e === void 0 ? void 0 : e.href
              };
            }
          })
        ];
      },
      addProseMirrorPlugins() {
        const n2 = [], { protocols: e, defaultProtocol: t } = this.options;
        return this.options.autolink && n2.push(_E({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (o) => this.options.isAllowedUri(o, {
            defaultValidate: (i2) => !!yo(i2, e),
            protocols: e,
            defaultProtocol: t
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })), this.options.openOnClick === true && n2.push(mE({
          type: this.type
        })), this.options.linkOnPaste && n2.push(fE({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })), n2;
      }
    });
    function hE(n2) {
      return new dn({
        key: new en("handleClickSelectLink"),
        props: {
          handleClick: (e, t, o) => {
            const { schema: i2, doc: s, tr: r } = e.state, a = getMarkRange(s.resolve(t), i2.marks.link);
            if (!a) return false;
            const l = s.resolve(a.from), u = s.resolve(a.to), c2 = r.setSelection(new Ce(l, u));
            return e.dispatch(c2), true;
          }
        }
      });
    }
    const vE = C_.extend({
      addProseMirrorPlugins() {
        var n2;
        return [
          ...((n2 = this.parent) == null ? void 0 : n2.call(this)) || [],
          hE({
            type: this.type
          })
        ];
      }
    }).configure({
      openOnClick: false
    }), bE = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2;
        return (t, o) => (openBlock(), createBlock(unref(Jt), mergeProps(e, { class: "o-paragraph-view" }), {
          default: withCtx(() => [
            createVNode(unref(Yt), {
              as: "p",
              style: normalizeStyle(`text-align: ${t.node.attrs.textAlign}`)
            }, null, 8, ["style"])
          ]),
          _: 1
        }, 16));
      }
    }), kE = hp.extend({
      draggable: false,
      addNodeView() {
        return wt(bE, {
          stopEvent: () => false
        });
      }
    }), S_ = Node.create({
      name: "tableCell",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (n2) => {
              const e = n2.getAttribute("colwidth");
              return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
            }
          }
        };
      },
      tableRole: "cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "td" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["td", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      }
    }), yE = { class: "add" }, jE = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { isEditable: o, run: i2 } = Le(), s = ref(false);
        function r() {
          s.value = true;
        }
        function a() {
          l("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function l(u, c2 = {}) {
          u === "tableDeleteRow" && (s.value = false), setTimeout(() => {
            i2(e.editor, u, c2);
          }, 0);
        }
        return (u, c2) => (openBlock(), createBlock(unref(al), mergeProps({
          class: "o-table-cell-view",
          as: "td"
        }, u.node.attrs, {
          style: { background: u.node.attrs.background }
        }), {
          default: withCtx(() => [
            unref(o) ? (openBlock(), createBlock(unref($i), {
              key: 0,
              modelValue: s.value,
              "onUpdate:modelValue": c2[2] || (c2[2] = (d) => s.value = d),
              placement: "left",
              "tippy-class": "o-row-popover",
              offset: [16, 40],
              "hide-click-outside": ""
            }, {
              "popover-content": withCtx(() => [
                createVNode(unref(yn), {
                  icon: "select_all",
                  tooltip: unref(t)("table.removeColumn"),
                  onClick: a
                }, null, 8, ["tooltip"]),
                createVNode(unref(yn), {
                  icon: "delete",
                  tooltip: unref(t)("table.removeRow"),
                  onClick: c2[1] || (c2[1] = (d) => l("tableDeleteRow"))
                }, null, 8, ["tooltip"])
              ]),
              default: withCtx(() => [
                createBaseVNode("section", {
                  class: normalizeClass(["row-handler", { active: s.value }]),
                  onClick: r
                }, [
                  createBaseVNode("div", yE, [
                    c2[3] || (c2[3] = createBaseVNode("div", { class: "indicator" }, [
                      createBaseVNode("svg", {
                        width: "3",
                        height: "3",
                        viewBox: "0 0 3 3",
                        fill: "none"
                      }, [
                        createBaseVNode("circle", {
                          cx: "1.5",
                          cy: "1.5",
                          r: "1.5",
                          fill: "#BBBFC4"
                        })
                      ])
                    ], -1)),
                    createVNode(unref(Ra), {
                      icon: "add_circle",
                      color: unref(ze).blue,
                      tooltip: unref(t)("table.addRow"),
                      placement: "left",
                      onClick: c2[0] || (c2[0] = withModifiers((d) => l("tableAddRow"), ["stop"]))
                    }, null, 8, ["color", "tooltip"])
                  ])
                ], 2)
              ]),
              _: 1
            }, 8, ["modelValue"])) : createCommentVNode("", true),
            createVNode(unref(Yt))
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), wE = S_.extend({
      addAttributes() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return wt(jE, {
          stopEvent: () => false
        });
      }
    }), x_ = Node.create({
      name: "tableHeader",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      addAttributes() {
        return {
          colspan: {
            default: 1
          },
          rowspan: {
            default: 1
          },
          colwidth: {
            default: null,
            parseHTML: (n2) => {
              const e = n2.getAttribute("colwidth");
              return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
            }
          }
        };
      },
      tableRole: "header_cell",
      isolating: true,
      parseHTML() {
        return [
          { tag: "th" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["th", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      }
    }), EE = { class: "add" }, CE = { class: "add" }, SE = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, { tr: t } = Ae(), { isEditable: o, run: i2 } = Le(), s = ref(false), r = ref(false);
        function a() {
          setTimeout(() => {
            s.value = true;
          }, 0);
        }
        function l() {
          r.value = true;
        }
        function u() {
          s.value = false, d("tableSelectColumn", {
            pos: e.getPos()
          });
        }
        function c2() {
          d("tableSelectRow", {
            pos: e.getPos()
          });
        }
        function d(p2, _ = {}) {
          p2 === "tableDeleteRow" ? r.value = false : p2 === "tableDeleteColumn" && (s.value = false), setTimeout(() => {
            i2(e.editor, p2, _);
          }, 0);
        }
        return (p2, _) => (openBlock(), createBlock(unref(al), mergeProps({
          class: "o-table-header-view",
          as: "th"
        }, p2.node.attrs, {
          style: { background: p2.node.attrs.background }
        }), {
          default: withCtx(() => [
            unref(o) ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
              createVNode(unref($i), {
                modelValue: s.value,
                "onUpdate:modelValue": _[2] || (_[2] = (m) => s.value = m),
                placement: "top",
                "tippy-class": "o-column-popover",
                offset: [0, 20],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(yn), {
                    icon: "select_all",
                    tooltip: unref(t)("table.removeColumn"),
                    onClick: u
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(yn), {
                    icon: "delete",
                    tooltip: unref(t)("table.removeColumn"),
                    onClick: _[1] || (_[1] = (m) => d("tableDeleteColumn"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["col-handler", { active: s.value }]),
                    onClick: a
                  }, [
                    createBaseVNode("div", EE, [
                      _[6] || (_[6] = createBaseVNode("div", { class: "indicator" }, [
                        createBaseVNode("svg", {
                          width: "3",
                          height: "3",
                          viewBox: "0 0 3 3",
                          fill: "none"
                        }, [
                          createBaseVNode("circle", {
                            cx: "1.5",
                            cy: "1.5",
                            r: "1.5",
                            fill: "#BBBFC4"
                          })
                        ])
                      ], -1)),
                      createVNode(unref(Ra), {
                        icon: "add_circle",
                        color: unref(ze).blue,
                        tooltip: unref(t)("table.addColumn"),
                        onClick: _[0] || (_[0] = withModifiers((m) => d("tableAddColumn"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createVNode(unref($i), {
                modelValue: r.value,
                "onUpdate:modelValue": _[5] || (_[5] = (m) => r.value = m),
                placement: "left",
                "tippy-class": "o-row-popover",
                offset: [15, 40],
                "hide-click-outside": ""
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(yn), {
                    icon: "select_all",
                    tooltip: unref(t)("table.removeColumn"),
                    onClick: c2
                  }, null, 8, ["tooltip"]),
                  createVNode(unref(yn), {
                    icon: "delete",
                    tooltip: unref(t)("table.removeRow"),
                    onClick: _[4] || (_[4] = (m) => d("tableDeleteRow"))
                  }, null, 8, ["tooltip"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("section", {
                    class: normalizeClass(["row-handler", { active: r.value }]),
                    onClick: l
                  }, [
                    createBaseVNode("div", CE, [
                      _[7] || (_[7] = createBaseVNode("div", { class: "indicator" }, [
                        createBaseVNode("svg", {
                          width: "3",
                          height: "3",
                          viewBox: "0 0 3 3",
                          fill: "none"
                        }, [
                          createBaseVNode("circle", {
                            cx: "1.5",
                            cy: "1.5",
                            r: "1.5",
                            fill: "#BBBFC4"
                          })
                        ])
                      ], -1)),
                      createVNode(unref(Ra), {
                        icon: "add_circle",
                        color: unref(ze).blue,
                        tooltip: unref(t)("table.addRow"),
                        placement: "left",
                        onClick: _[3] || (_[3] = withModifiers((m) => d("tableAddRow"), ["stop"]))
                      }, null, 8, ["color", "tooltip"])
                    ])
                  ], 2)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 64)) : createCommentVNode("", true),
            createVNode(unref(Yt))
          ]),
          _: 1
        }, 16, ["style"]));
      }
    }), xE = x_.extend({
      addAttributes() {
        var n2;
        return {
          ...(n2 = this.parent) == null ? void 0 : n2.call(this),
          background: {
            default: ""
          }
        };
      },
      addNodeView() {
        return wt(SE, {
          stopEvent: () => false
        });
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const TE = Node.create({
      name: "table-wrapper",
      group: "block",
      content: "table",
      draggable: true,
      parseHTML() {
        return [{ tag: "table-wrapper" }];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["table-wrapper", mergeAttributes(n2), 0];
      }
    }), AE = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, t = inject("sideNode", { value: false }), o = ref(false), i2 = computed(() => {
          const { selection: r } = e.editor.view.state, a = r.from, l = e.getPos(), u = l + e.node.nodeSize;
          return a >= l && a <= u;
        });
        function s(r) {
          o.value = r;
        }
        return watch(i2, (r) => {
          s(r);
        }), (r, a) => (openBlock(), createBlock(unref(Jt), mergeProps(e, {
          class: ["o-table-wrapper-view", { "side-node-enabled": unref(t) }]
        }), {
          default: withCtx(() => [
            createVNode(unref(Yt), { as: "table" })
          ]),
          _: 1
        }, 16, ["class"]));
      }
    }), NE = TE.extend({
      addNodeView() {
        return wt(AE, {
          stopEvent: () => false
        });
      }
    });
    /**
     *  Copyright 2025 Yiitap 
     *  @license MIT
    **/
    const OE = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, ME = Node.create({
      name: "video",
      draggable: true,
      addOptions() {
        return {
          inline: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      addAttributes() {
        return {
          // small, medium, large
          caption: {
            default: "",
            rendered: false
          },
          src: {
            default: null,
            parseHTML: (n2) => {
              var e;
              return ((e = n2.firstElementChild) == null ? void 0 : e.src) ?? "";
            }
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "video"
          }
        ];
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        return [
          "video",
          {
            caption: n2.attrs.caption
          },
          ["source", mergeAttributes(this.options.HTMLAttributes, e)]
        ];
      },
      addCommands() {
        return {
          setVideo: (n2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: n2
          })
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: OE,
            type: this.type,
            getAttributes: (n2) => {
              const [e] = n2;
              return { src: e };
            }
          })
        ];
      }
    }), RE = {
      key: 1,
      class: "video-container"
    }, IE = { key: 1 }, LE = /* @__PURE__ */ defineComponent({
      __name: "view",
      props: En,
      setup(n2) {
        const e = n2, { isEditable: t } = Le(), o = ref(false), i2 = ref({}), s = ref(null), r = ref(false), a = ref(false), l = computed({
          get() {
            return e.node.attrs.caption;
          },
          set(h2) {
            e.updateAttributes({ caption: h2 });
          }
        }), u = computed({
          get() {
            return e.node.attrs.src;
          },
          set(h2) {
            e.updateAttributes({ src: h2 });
          }
        });
        function c2(h2) {
          switch (o.value = false, h2.value) {
            case "replace":
              b(true);
              break;
          }
        }
        function d() {
          r.value = true, setTimeout(() => {
            var h2;
            (h2 = s.value) == null || h2.focus();
          }, 0);
        }
        function p2() {
          r.value = false;
        }
        function _() {
          u.value === "init" && b(true);
        }
        function m(h2) {
          o.value = true, i2.value = h2;
        }
        function f(h2) {
          u.value = h2, b(false);
        }
        function b(h2) {
          a.value = h2;
        }
        return onMounted(() => {
          b(u.value === "init");
        }), (h2, y) => {
          var C;
          return openBlock(), createBlock(unref(Jt), mergeProps(e, {
            class: ["o-video-view", {
              readonly: !((C = h2.editor) != null && C.isEditable),
              init: u.value === "init"
            }],
            as: "div",
            onContextmenu: withModifiers(m, ["prevent"]),
            onClick: _
          }), {
            default: withCtx(() => [
              createVNode(unref($i), {
                modelValue: a.value,
                "onUpdate:modelValue": y[1] || (y[1] = (v) => a.value = v),
                placement: u.value === "init" ? "bottom" : "top"
              }, {
                "popover-content": withCtx(() => [
                  createVNode(unref(wp), {
                    val: u.value === "init" ? "" : u.value,
                    type: "video",
                    onInput: f
                  }, null, 8, ["val"])
                ]),
                default: withCtx(() => {
                  var v;
                  return [
                    u.value === "init" ? (openBlock(), createBlock(unref(bp), {
                      key: 0,
                      icon: "videocam",
                      placeholder: "Add a video"
                    })) : (openBlock(), createElementBlock("div", RE, [
                      y[3] || (y[3] = createBaseVNode("div", { class: "video-cover" }, null, -1)),
                      unref(t) ? (openBlock(), createBlock(unref(kp), mergeProps({ key: 0 }, e, { onAction: c2 }), {
                        default: withCtx(() => [
                          createVNode(unref(Ke), {
                            icon: "subtitles",
                            tooltip: "image.caption",
                            onClick: d
                          })
                        ]),
                        _: 1
                      }, 16)) : createCommentVNode("", true),
                      createBaseVNode("video", mergeProps(h2.node.attrs, {
                        draggable: "true",
                        "data-drag-handle": "",
                        controls: ""
                      }), [
                        createBaseVNode("source", normalizeProps(guardReactiveProps(h2.node.attrs)), null, 16)
                      ], 16),
                      createBaseVNode("div", {
                        class: "caption",
                        onClick: d
                      }, [
                        (v = h2.editor) != null && v.isEditable && r.value ? (openBlock(), createBlock(unref(ai), {
                          key: 0,
                          ref_key: "captionInput",
                          ref: s,
                          class: "caption-input",
                          modelValue: l.value,
                          "onUpdate:modelValue": y[0] || (y[0] = (x) => l.value = x),
                          type: "text",
                          placeholder: "Input caption",
                          autosize: "",
                          onBlur: p2
                        }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("span", IE, toDisplayString(l.value), 1))
                      ])
                    ]))
                  ];
                }),
                _: 1
              }, 8, ["modelValue", "placement"]),
              createVNode(unref(bl), {
                modelValue: o.value,
                "onUpdate:modelValue": y[2] || (y[2] = (v) => o.value = v),
                event: i2.value
              }, {
                default: withCtx(() => [
                  createVNode(unref(ri), mergeProps(e, { onAction: c2 }), null, 16)
                ]),
                _: 1
              }, 8, ["modelValue", "event"])
            ]),
            _: 1
          }, 16, ["class"]);
        };
      }
    }), DE = ME.extend({
      addNodeView() {
        return wt(LE);
      }
    }), BE = [
      "BackColor",
      "Focus",
      "FontFamily",
      "ForeColor",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline",
      "OHorizontalRule",
      "OUniqueID"
    ], PE = [
      "BackColor",
      "Blockquote",
      "Bold",
      "BulletList",
      "Code",
      "CodeBlockLowlight",
      "Focus",
      "FontFamily",
      "ForeColor",
      "HorizontalRule",
      "Image",
      "Italic",
      "Link",
      "ListItem",
      "OrderedList",
      "Strike",
      "Table",
      "TaskItem",
      "TaskList",
      "TextAlign",
      "Typography",
      "Underline"
    ], $E = [
      "OBlockquote",
      "OCallout",
      "OCodeBlock",
      "OColon",
      "OColorHighlighter",
      "OColumnExtension",
      "ODiagram",
      "ODoc",
      "ODraggableItem",
      "OEmbed",
      "OFocus",
      "OFontFamily",
      "OFormatClear",
      "OHeading",
      "OHorizontalRule",
      "OIframe",
      "OImage",
      "OIndent",
      "OInsertHtml",
      "OKatexBlock",
      "OKatexInline",
      "OLineHeight",
      "OLink",
      "OModelViewer",
      "OParagraph",
      "OPrint",
      "OSlash",
      "OSlashZh",
      "OTOC",
      "OTableWrapper",
      "OTitle",
      "OTodoItem",
      "OTrailingNode",
      "OUniqueID",
      "OVideo"
    ], zE = [...PE, ...$E], FE = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, HE = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, UE = Mark.create({
      name: "highlight",
      addOptions() {
        return {
          multicolor: false,
          HTMLAttributes: {}
        };
      },
      addAttributes() {
        return this.options.multicolor ? {
          color: {
            default: null,
            parseHTML: (n2) => n2.getAttribute("data-color") || n2.style.backgroundColor,
            renderHTML: (n2) => n2.color ? {
              "data-color": n2.color,
              style: `background-color: ${n2.color}; color: inherit`
            } : {}
          }
        } : {};
      },
      parseHTML() {
        return [
          {
            tag: "mark"
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["mark", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setHighlight: (n2) => ({ commands: e }) => e.setMark(this.name, n2),
          toggleHighlight: (n2) => ({ commands: e }) => e.toggleMark(this.name, n2),
          unsetHighlight: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: FE,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: HE,
            type: this.type
          })
        ];
      }
    }), qE = Extension.create({
      name: "focus",
      addOptions() {
        return {
          className: "has-focus",
          mode: "all"
        };
      },
      addProseMirrorPlugins() {
        return [
          new dn({
            key: new en("focus"),
            props: {
              decorations: ({ doc: n2, selection: e }) => {
                const { isEditable: t, isFocused: o } = this.editor, { anchor: i2 } = e, s = [];
                if (!t || !o)
                  return He.create(n2, []);
                let r = 0;
                this.options.mode === "deepest" && n2.descendants((l, u) => {
                  if (l.isText)
                    return;
                  if (!(i2 >= u && i2 <= u + l.nodeSize - 1))
                    return false;
                  r += 1;
                });
                let a = 0;
                return n2.descendants((l, u) => {
                  if (l.isText || !(i2 >= u && i2 <= u + l.nodeSize - 1))
                    return false;
                  if (a += 1, this.options.mode === "deepest" && r - a > 0 || this.options.mode === "shallowest" && a > 1)
                    return this.options.mode === "deepest";
                  s.push(hn.node(u, u + l.nodeSize, {
                    class: this.options.className
                  }));
                }), He.create(n2, s);
              }
            }
          })
        ];
      }
    }), KE = Extension.create({
      name: "fontFamily",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              fontFamily: {
                default: null,
                parseHTML: (n2) => n2.style.fontFamily,
                renderHTML: (n2) => n2.fontFamily ? {
                  style: `font-family: ${n2.fontFamily}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setFontFamily: (n2) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: n2 }).run(),
          unsetFontFamily: () => ({ chain: n2 }) => n2().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
        };
      }
    }), VE = Extension.create({
      name: "color",
      addOptions() {
        return {
          types: ["textStyle"]
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              color: {
                default: null,
                parseHTML: (n2) => {
                  var e;
                  return (e = n2.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
                },
                renderHTML: (n2) => n2.color ? {
                  style: `color: ${n2.color}`
                } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setColor: (n2) => ({ chain: e }) => e().setMark("textStyle", { color: n2 }).run(),
          unsetColor: () => ({ chain: n2 }) => n2().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
        };
      }
    }), WE = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, GE = Node.create({
      name: "image",
      addOptions() {
        return {
          inline: false,
          allowBase64: false,
          HTMLAttributes: {}
        };
      },
      inline() {
        return this.options.inline;
      },
      group() {
        return this.options.inline ? "inline" : "block";
      },
      draggable: true,
      addAttributes() {
        return {
          src: {
            default: null
          },
          alt: {
            default: null
          },
          title: {
            default: null
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["img", mergeAttributes(this.options.HTMLAttributes, n2)];
      },
      addCommands() {
        return {
          setImage: (n2) => ({ commands: e }) => e.insertContent({
            type: this.name,
            attrs: n2
          })
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: WE,
            type: this.type,
            getAttributes: (n2) => {
              const [, , e, t, o] = n2;
              return { src: t, alt: e, title: o };
            }
          })
        ];
      }
    }), YE = /^\s*(\[([( |x])?\])\s$/, JE = Node.create({
      name: "taskItem",
      addOptions() {
        return {
          nested: false,
          HTMLAttributes: {},
          taskListTypeName: "taskList"
        };
      },
      content() {
        return this.options.nested ? "paragraph block*" : "paragraph+";
      },
      defining: true,
      addAttributes() {
        return {
          checked: {
            default: false,
            keepOnSplit: false,
            parseHTML: (n2) => {
              const e = n2.getAttribute("data-checked");
              return e === "" || e === "true";
            },
            renderHTML: (n2) => ({
              "data-checked": n2.checked
            })
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: `li[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ node: n2, HTMLAttributes: e }) {
        return [
          "li",
          mergeAttributes(this.options.HTMLAttributes, e, {
            "data-type": this.name
          }),
          [
            "label",
            [
              "input",
              {
                type: "checkbox",
                checked: n2.attrs.checked ? "checked" : null
              }
            ],
            ["span"]
          ],
          ["div", 0]
        ];
      },
      addKeyboardShortcuts() {
        const n2 = {
          Enter: () => this.editor.commands.splitListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        return this.options.nested ? {
          ...n2,
          Tab: () => this.editor.commands.sinkListItem(this.name)
        } : n2;
      },
      addNodeView() {
        return ({ node: n2, HTMLAttributes: e, getPos: t, editor: o }) => {
          const i2 = document.createElement("li"), s = document.createElement("label"), r = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
          return s.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (u) => u.preventDefault()), a.addEventListener("change", (u) => {
            if (!o.isEditable && !this.options.onReadOnlyChecked) {
              a.checked = !a.checked;
              return;
            }
            const { checked: c2 } = u.target;
            o.isEditable && typeof t == "function" && o.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: d }) => {
              const p2 = t();
              if (typeof p2 != "number")
                return false;
              const _ = d.doc.nodeAt(p2);
              return d.setNodeMarkup(p2, void 0, {
                ..._ == null ? void 0 : _.attrs,
                checked: c2
              }), true;
            }).run(), !o.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(n2, c2) || (a.checked = !a.checked));
          }), Object.entries(this.options.HTMLAttributes).forEach(([u, c2]) => {
            i2.setAttribute(u, c2);
          }), i2.dataset.checked = n2.attrs.checked, a.checked = n2.attrs.checked, s.append(a, r), i2.append(s, l), Object.entries(e).forEach(([u, c2]) => {
            i2.setAttribute(u, c2);
          }), {
            dom: i2,
            contentDOM: l,
            update: (u) => u.type !== this.type ? false : (i2.dataset.checked = u.attrs.checked, a.checked = u.attrs.checked, true)
          };
        };
      },
      addInputRules() {
        return [
          wrappingInputRule({
            find: YE,
            type: this.type,
            getAttributes: (n2) => ({
              checked: n2[n2.length - 1] === "x"
            })
          })
        ];
      }
    }), ZE = Node.create({
      name: "taskList",
      addOptions() {
        return {
          itemTypeName: "taskItem",
          HTMLAttributes: {}
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          {
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["ul", mergeAttributes(this.options.HTMLAttributes, n2, { "data-type": this.name }), 0];
      },
      addCommands() {
        return {
          toggleTaskList: () => ({ commands: n2 }) => n2.toggleList(this.name, this.options.itemTypeName)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        };
      }
    }), XE = Extension.create({
      name: "textAlign",
      addOptions() {
        return {
          types: [],
          alignments: ["left", "center", "right", "justify"],
          defaultAlignment: null
        };
      },
      addGlobalAttributes() {
        return [
          {
            types: this.options.types,
            attributes: {
              textAlign: {
                default: this.options.defaultAlignment,
                parseHTML: (n2) => {
                  const e = n2.style.textAlign;
                  return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
                },
                renderHTML: (n2) => n2.textAlign ? { style: `text-align: ${n2.textAlign}` } : {}
              }
            }
          }
        ];
      },
      addCommands() {
        return {
          setTextAlign: (n2) => ({ commands: e }) => this.options.alignments.includes(n2) ? this.options.types.map((t) => e.updateAttributes(t, { textAlign: n2 })).every((t) => t) : false,
          unsetTextAlign: () => ({ commands: n2 }) => this.options.types.map((e) => n2.resetAttributes(e, "textAlign")).every((e) => e)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
          "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
          "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
          "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
        };
      }
    }), QE = (n2) => textInputRule({
      find: /--$/,
      replace: n2 ?? ""
    }), eC = (n2) => textInputRule({
      find: /\.\.\.$/,
      replace: n2 ?? ""
    }), nC = (n2) => textInputRule({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
      replace: n2 ?? ""
    }), tC = (n2) => textInputRule({
      find: /"$/,
      replace: n2 ?? ""
    }), oC = (n2) => textInputRule({
      find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
      replace: n2 ?? ""
    }), iC = (n2) => textInputRule({
      find: /'$/,
      replace: n2 ?? ""
    }), sC = (n2) => textInputRule({
      find: /<-$/,
      replace: n2 ?? ""
    }), rC = (n2) => textInputRule({
      find: /->$/,
      replace: n2 ?? ""
    }), aC = (n2) => textInputRule({
      find: /\(c\)$/,
      replace: n2 ?? ""
    }), lC = (n2) => textInputRule({
      find: /\(tm\)$/,
      replace: n2 ?? ""
    }), uC = (n2) => textInputRule({
      find: /\(sm\)$/,
      replace: n2 ?? ""
    }), cC = (n2) => textInputRule({
      find: /\(r\)$/,
      replace: n2 ?? ""
    }), dC = (n2) => textInputRule({
      find: /(?:^|\s)(1\/2)\s$/,
      replace: n2 ?? ""
    }), pC = (n2) => textInputRule({
      find: /\+\/-$/,
      replace: n2 ?? ""
    }), _C = (n2) => textInputRule({
      find: /!=$/,
      replace: n2 ?? ""
    }), mC = (n2) => textInputRule({
      find: /<<$/,
      replace: n2 ?? ""
    }), fC = (n2) => textInputRule({
      find: />>$/,
      replace: n2 ?? ""
    }), gC = (n2) => textInputRule({
      find: /\d+\s?([*x])\s?\d+$/,
      replace: n2 ?? ""
    }), hC = (n2) => textInputRule({
      find: /\^2$/,
      replace: n2 ?? ""
    }), vC = (n2) => textInputRule({
      find: /\^3$/,
      replace: n2 ?? ""
    }), bC = (n2) => textInputRule({
      find: /(?:^|\s)(1\/4)\s$/,
      replace: n2 ?? ""
    }), kC = (n2) => textInputRule({
      find: /(?:^|\s)(3\/4)\s$/,
      replace: n2 ?? ""
    }), yC = Extension.create({
      name: "typography",
      addOptions() {
        return {
          closeDoubleQuote: "",
          closeSingleQuote: "",
          copyright: "",
          ellipsis: "",
          emDash: "",
          laquo: "",
          leftArrow: "",
          multiplication: "",
          notEqual: "",
          oneHalf: "",
          oneQuarter: "",
          openDoubleQuote: "",
          openSingleQuote: "",
          plusMinus: "",
          raquo: "",
          registeredTrademark: "",
          rightArrow: "",
          servicemark: "",
          superscriptThree: "",
          superscriptTwo: "",
          threeQuarters: "",
          trademark: ""
        };
      },
      addInputRules() {
        const n2 = [];
        return this.options.emDash !== false && n2.push(QE(this.options.emDash)), this.options.ellipsis !== false && n2.push(eC(this.options.ellipsis)), this.options.openDoubleQuote !== false && n2.push(nC(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== false && n2.push(tC(this.options.closeDoubleQuote)), this.options.openSingleQuote !== false && n2.push(oC(this.options.openSingleQuote)), this.options.closeSingleQuote !== false && n2.push(iC(this.options.closeSingleQuote)), this.options.leftArrow !== false && n2.push(sC(this.options.leftArrow)), this.options.rightArrow !== false && n2.push(rC(this.options.rightArrow)), this.options.copyright !== false && n2.push(aC(this.options.copyright)), this.options.trademark !== false && n2.push(lC(this.options.trademark)), this.options.servicemark !== false && n2.push(uC(this.options.servicemark)), this.options.registeredTrademark !== false && n2.push(cC(this.options.registeredTrademark)), this.options.oneHalf !== false && n2.push(dC(this.options.oneHalf)), this.options.plusMinus !== false && n2.push(pC(this.options.plusMinus)), this.options.notEqual !== false && n2.push(_C(this.options.notEqual)), this.options.laquo !== false && n2.push(mC(this.options.laquo)), this.options.raquo !== false && n2.push(fC(this.options.raquo)), this.options.multiplication !== false && n2.push(gC(this.options.multiplication)), this.options.superscriptTwo !== false && n2.push(hC(this.options.superscriptTwo)), this.options.superscriptThree !== false && n2.push(vC(this.options.superscriptThree)), this.options.oneQuarter !== false && n2.push(bC(this.options.oneQuarter)), this.options.threeQuarters !== false && n2.push(kC(this.options.threeQuarters)), n2;
      }
    }), jC = Mark.create({
      name: "underline",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "u"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (n2) => n2.includes("underline") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["u", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      },
      addCommands() {
        return {
          setUnderline: () => ({ commands: n2 }) => n2.setMark(this.name),
          toggleUnderline: () => ({ commands: n2 }) => n2.toggleMark(this.name),
          unsetUnderline: () => ({ commands: n2 }) => n2.unsetMark(this.name)
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-u": () => this.editor.commands.toggleUnderline(),
          "Mod-U": () => this.editor.commands.toggleUnderline()
        };
      }
    }), T_ = Node.create({
      name: "tableRow",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "(tableCell | tableHeader)*",
      tableRole: "row",
      parseHTML() {
        return [
          { tag: "tr" }
        ];
      },
      renderHTML({ HTMLAttributes: n2 }) {
        return ["tr", mergeAttributes(this.options.HTMLAttributes, n2), 0];
      }
    }), wC = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: n2, tr: e } = Ae(), { onCommand: t } = Le();
        return {
          locale: n2,
          tr: e,
          onCommand: t
        };
      },
      data() {
        return {
          view: "main",
          selectedIndex: 0
        };
      },
      components: {
        ODivider: pt,
        OIcon: ue,
        OList: Ct,
        OListItem: _t
      },
      watch: {
        items() {
          this.selectedIndex = 0;
        }
      },
      methods: {
        onClick(n2) {
          switch (n2.value) {
            default:
              this.run(n2);
              break;
          }
          return true;
        },
        run(n2) {
          const e = this.editor.chain().focus().deleteRange(this.range), t = this.editor.commands;
          switch (n2.value) {
            case "codeBlock":
              t.deleteRange(this.range), this.editor.commands.setCodeBlock({ language: "bash" });
              break;
            case "content":
              t.deleteRange(this.range), this.editor.commands.insertContent(n2.options.content);
              break;
            case "emoji":
              t.deleteRange(this.range), this.editor.commands.insertContent(":");
              break;
            case "taskList":
              t.deleteRange(this.range), this.editor.commands.toggleTaskList();
              break;
            default:
              this.onCommand(t, e, n2.value, n2.options);
              break;
          }
        },
        onKeyDown({ event: n2 }) {
          return n2.key === "ArrowUp" ? (this.upHandler(), true) : n2.key === "ArrowDown" ? (this.downHandler(), true) : n2.key === "Enter" ? (this.enterHandler(), true) : false;
        },
        upHandler() {
          this.selectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length;
        },
        downHandler() {
          this.selectedIndex = (this.selectedIndex + 1) % this.items.length;
        },
        enterHandler() {
          this.selectItem(this.selectedIndex);
        },
        selectItem(n2) {
          const e = this.items[n2];
          e && this.onClick(e);
        },
        setEmoji(n2) {
          this.onClick({ value: "content", options: { content: n2 } });
        }
      },
      computed: {
        basicBlocks() {
          return Zi.slice(1);
        }
      },
      mounted() {
        this.selectedIndex = 0;
      }
    }, EC = {
      key: 0,
      class: "view-main"
    }, CC = { class: "group o-tips" }, SC = { class: "o-tips" }, xC = {
      key: 1,
      class: "item"
    }, TC = {
      key: 1,
      class: "view-emoji"
    }, AC = {
      key: 2,
      class: "view-emoji"
    };
    function NC(n2, e, t, o, i2, s) {
      const r = resolveComponent("o-divider"), a = resolveComponent("o-icon"), l = resolveComponent("o-list-item"), u = resolveComponent("o-list");
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(["o-slash-view o-shadow-3 o-menu o-scroll", `view-${i2.view}`])
      }, [
        i2.view === "main" ? (openBlock(), createElementBlock("section", EC, [
          createVNode(u, {
            hoverable: "",
            clickable: ""
          }, {
            default: withCtx(() => [
              t.items.length ? (openBlock(true), createElementBlock(Fragment$1, { key: 0 }, renderList(t.items, (c2, d) => (openBlock(), createElementBlock(Fragment$1, { key: d }, [
                c2.group ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                  d > 0 ? (openBlock(), createBlock(r, { key: 0 })) : createCommentVNode("", true),
                  createBaseVNode("div", CC, toDisplayString(o.tr(c2.group)), 1)
                ], 64)) : createCommentVNode("", true),
                createVNode(l, {
                  class: normalizeClass(["item", { "is-active": d === i2.selectedIndex }]),
                  clickable: "",
                  onClick: (p2) => s.onClick(c2)
                }, {
                  prefix: withCtx(() => [
                    createVNode(a, {
                      name: c2.icon,
                      color: c2.color
                    }, null, 8, ["name", "color"])
                  ]),
                  suffix: withCtx(() => [
                    createBaseVNode("span", SC, toDisplayString(c2.tips), 1)
                  ]),
                  default: withCtx(() => [
                    createTextVNode(" " + toDisplayString(o.tr(c2.label)), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])
              ], 64))), 128)) : (openBlock(), createElementBlock("div", xC, "No result"))
            ]),
            _: 1
          })
        ])) : i2.view === "emoji" ? (openBlock(), createElementBlock("section", TC)) : i2.view === "ai" ? (openBlock(), createElementBlock("section", AC)) : createCommentVNode("", true)
      ], 2);
    }
    const OC = /* @__PURE__ */ yl(wC, [["render", NC]]), Pc = {
      items: ({ query: n2 }) => vl.filter(
        (e) => e.value.toLowerCase().startsWith(n2.toLowerCase())
      ),
      render: () => {
        let n2, e;
        return {
          onStart: (t) => {
            n2 = new ll(OC, {
              props: t,
              editor: t.editor
            }), e = jt("body", {
              getReferenceClientRect: t.clientRect,
              appendTo: () => document.body,
              content: n2.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false
            });
          },
          onUpdate(t) {
            n2.updateProps(t), e[0].setProps({
              getReferenceClientRect: t.clientRect
            });
          },
          onKeyDown(t) {
            var o;
            return t.event.key === "Escape" ? (e[0].hide(), n2.destroy(), true) : (o = n2.ref) == null ? void 0 : o.onKeyDown(t);
          },
          onExit() {
            e[0].destroy(), n2.destroy();
          }
        };
      }
    }, MC = {
      props: {
        items: {
          type: Array,
          required: true
        },
        command: {
          type: Function,
          required: true
        },
        editor: {
          type: Object
        },
        range: {
          type: Object
        }
      },
      setup() {
        const { locale: n2, tr: e } = Ae(), { run: t } = Le();
        return {
          locale: n2,
          tr: e,
          run: t
        };
      },
      data() {
        return {
          view: "main"
        };
      },
      components: {
        OEmojiSelect: wl
      },
      methods: {
        onSelect(n2) {
          this.editor.commands.deleteRange(this.range), this.editor.commands.insertContent(n2.emoji), this.editor.chain().focus();
        },
        onKeyDown({ event: n2 }) {
          return false;
        }
      }
    }, RC = { class: "o-colon-view" };
    function IC(n2, e, t, o, i2, s) {
      const r = resolveComponent("o-emoji-select");
      return openBlock(), createElementBlock("section", RC, [
        createVNode(r, {
          items: t.items,
          onSelect: s.onSelect
        }, null, 8, ["items", "onSelect"])
      ]);
    }
    const LC = /* @__PURE__ */ yl(MC, [["render", IC]]), DC = {
      items: ({ query: n2 }) => jp(n2),
      render: () => {
        let n2, e;
        return {
          onStart: (t) => {
            n2 = new ll(LC, {
              props: t,
              editor: t.editor
            }), e = jt("body", {
              getReferenceClientRect: t.clientRect,
              appendTo: () => document.body,
              content: n2.element,
              showOnCreate: true,
              interactive: true,
              trigger: "manual",
              placement: "bottom-start",
              arrow: false,
              onShow(o) {
                o.popper.classList.add("emoji-tippy");
              }
            });
          },
          onUpdate(t) {
            n2.updateProps(t), e[0].setProps({
              getReferenceClientRect: t.clientRect
            });
          },
          onKeyDown(t) {
            var o;
            return t.event.key === "Escape" ? (e[0].hide(), n2.destroy(), true) : (o = n2.ref) == null ? void 0 : o.onKeyDown(t);
          },
          onExit() {
            e[0].destroy(), n2.destroy();
          }
        };
      }
    }, BC = {
      // default
      BackColor: UE.configure({
        multicolor: true
      }),
      Focus: qE,
      ForeColor: VE,
      FontFamily: KE,
      Image: GE,
      Link: C_,
      TextAlign: XE.configure({
        types: ["heading", "paragraph"]
      }),
      // task
      TaskItem: JE,
      TaskList: ZE.configure({
        itemTypeName: "taskItem"
      }),
      Underline: jC,
      Typography: yC,
      // Custom extensions
      OColon: Ky.configure({
        suggestion: DC
      }),
      OSlash: qy.configure({
        suggestion: Pc
      }),
      OSlashZh: Vy.configure({
        suggestion: Pc
      }),
      // OTOC: TOC,
      // OModelViewer: ModelViewer,
      OBlockquote: Gy,
      OCallout: ej,
      OCodeBlock: D1,
      OColorHighlighter: Ak,
      OHeading: P1,
      OHorizontalRule: F1,
      OImage: G1,
      OLink: vE.configure({
        openOnClick: false
      }),
      OParagraph: kE,
      OTrailingNode: Ly,
      // OColumnExtension: ColumnExtension,
      // OColon: Colon.configure({
      //   suggestion: colonSuggestion
      // }),
      OUniqueID: Fy.configure({
        attributeName: "data-id",
        enableRender: false,
        types: [
          "blockquote",
          "codeBlock",
          "callout",
          "heading",
          "image",
          "paragraph",
          "table-wrapper",
          "video"
        ]
      }),
      OVideo: DE
    };
    class PC {
      constructor(e) {
        return BC[e];
      }
    }
    const $C = [
      NE,
      Ry.configure({
        resizable: true
      }),
      T_,
      xE,
      wE
    ];
    $p.configure({
      resizable: true
    });
    const zC = ["data-theme"], FC = /* @__PURE__ */ defineComponent({
      __name: "YiiEditor",
      props: {
        content: {
          type: [String, Object],
          default: ""
        },
        editable: {
          type: Boolean,
          default: true
        },
        locale: {
          type: String,
          default: "en"
        },
        darkMode: {
          type: Boolean,
          default: false
        },
        showMainMenu: {
          type: Boolean,
          default: false
        },
        showBubbleMenu: {
          type: Boolean,
          default: false
        },
        showFloatingMenu: {
          type: Boolean,
          default: false
        },
        showSideMenu: {
          type: Boolean,
          default: false
        },
        showSideNode: {
          type: Boolean,
          default: false
        },
        showContent: {
          type: Boolean,
          default: true
        },
        showGuide: {
          type: Boolean,
          default: false
        },
        scrollable: {
          type: Boolean,
          default: false
        },
        editorProps: {
          type: Object,
          default: function() {
            return {};
          }
        },
        extensions: {
          type: Array,
          default: function() {
            return [];
          }
        },
        mainMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        tableMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        bubbleMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        floatingMenu: {
          type: Array,
          default: function() {
            return [];
          }
        },
        pageView: {
          type: String,
          default: "page"
        },
        options: {
          type: Object,
          default: function() {
            return {};
          }
        }
      },
      emits: ["transaction", "update"],
      setup(n2, { expose: e, emit: t }) {
        const o = n2, i2 = t, { tr: s } = Ae(), r = ref(false), a = ref(true), l = ref("en"), u = ref(false);
        provide("darkMode", r), provide("isEditable", a), provide("locale", l), provide("sideNode", u);
        const c2 = computed(() => b()), d = Lg({
          editable: o.editable,
          content: o.content,
          extensions: c2.value,
          onUpdate: () => {
            var C, v;
            const h2 = (C = d.value) == null ? void 0 : C.getJSON(), y = (v = d.value) == null ? void 0 : v.getHTML();
            i2("update", { json: h2, html: y });
          },
          onTransaction: ({ editor: h2, transaction: y }) => {
            i2("transaction", { editor: h2, transaction: y });
          }
        }), p2 = computed(() => ({
          editor: d.value,
          menu: o.mainMenu
        })), _ = computed(() => ({
          editor: d.value,
          menu: o.bubbleMenu
        })), m = computed(() => ({
          editor: d.value,
          menu: o.floatingMenu
        })), f = computed(() => ({
          editor: d.value,
          menu: []
        }));
        function b() {
          const h2 = [];
          o.extensions.includes("OColumn") || h2.push(
            $d.extend({
              content: "heading block*"
            })
          ), h2.push(
            Nk.configure({
              placeholder: ({ editor: C, node: v, pos: x }) => {
                if (v.type.name === "heading") {
                  const S = v.attrs.level;
                  return x > 0 ? `H${S}` : s("label.untitled");
                } else return v.type.name === "paragraph" ? s("label.typeForCommands") : "";
              }
            })
          ), h2.push(wv), h2.push(
            yv.configure({
              document: false,
              blockquote: o.extensions.includes("OBlockquote") ? false : {},
              codeBlock: false,
              heading: o.extensions.includes("OHeading") ? false : {
                levels: [1, 2, 3, 4, 5]
              },
              paragraph: o.extensions.includes("OParagraph") ? false : {},
              dropcursor: {
                width: 5,
                color: "skyblue",
                class: "yiitap-dropcursor"
              },
              horizontalRule: false
            })
          );
          const y = BE.concat(o.extensions);
          for (const C of y)
            if (typeof C == "string") {
              if (!zE.includes(C))
                continue;
              switch (C) {
                case "Table":
                  h2.push(...$C);
                  break;
                default:
                  try {
                    const v = new PC(C);
                    h2.push(v);
                  } catch (v) {
                    console.error(v.message);
                  }
                  break;
              }
            } else
              h2.push(C);
          return h2;
        }
        return watch(
          () => o.darkMode,
          (h2) => {
            r.value = h2;
          }
        ), watch(
          () => o.locale,
          (h2) => {
            l.value = h2;
          }
        ), watch(
          () => o.editable,
          (h2) => {
            var y;
            (y = d.value) == null || y.setEditable(h2), a.value = h2;
          }
        ), onBeforeMount(() => {
          r.value = o.darkMode, l.value = o.locale, u.value = !o.showSideMenu && o.showSideNode;
        }), e({
          editor: d,
          darkModeAlt: r,
          localeAlt: l
        }), (h2, y) => {
          var C, v, x;
          return openBlock(), createElementBlock("main", {
            class: "yiitap yiitap-editor",
            "data-theme": r.value ? "dark" : ""
          }, [
            n2.showMainMenu ? (openBlock(), createBlock(ck, mergeProps({ key: 0 }, p2.value, { class: "desktop-only" }), {
              left: withCtx(() => [
                renderSlot(h2.$slots, "toolbar-left")
              ]),
              right: withCtx(() => [
                renderSlot(h2.$slots, "toolbar-right")
              ]),
              _: 3
            }, 16)) : createCommentVNode("", true),
            (C = unref(d)) != null && C.isEditable && n2.showBubbleMenu ? (openBlock(), createBlock(_k, normalizeProps(mergeProps({ key: 1 }, _.value)), null, 16)) : createCommentVNode("", true),
            (v = unref(d)) != null && v.isEditable && n2.showFloatingMenu ? (openBlock(), createBlock(gk, normalizeProps(mergeProps({ key: 2 }, m.value)), null, 16)) : createCommentVNode("", true),
            (x = unref(d)) != null && x.isEditable && n2.showSideMenu ? (openBlock(), createBlock(Tk, normalizeProps(mergeProps({ key: 3 }, f.value)), null, 16)) : createCommentVNode("", true),
            createVNode(unref(Rg), {
              class: normalizeClass(["editor-content", n2.pageView]),
              editor: unref(d)
            }, null, 8, ["class", "editor"])
          ], 8, zC);
        };
      }
    });
    const BasicFeaturesArticle = `
<h1>Introduction</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em> </em></strong></span>is a WYSIWYG rich-text block-based editor built on top of <span style="font-family: &quot;Arial Black&quot;">tiptap</span>.</p><h2>Callout</h2><div icon="" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong>Announcement</strong></p><p>Make writing stand out.</p></div><h2>Blockquote</h2><blockquote><p>A gentleman should constantly strike to become stronger just like the evolution of the universe.</p><p>A gentleman should generously cultivate to become tolerant just like the earth bears everything on it.</p></blockquote><h2>Table</h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th4</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)">Cell Background</span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p>Merged Cell</p></td></tr></tbody></table></table-wrapper><h2>Image</h2><blockquote><p>A picture is worth a thousand of words.</p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="Title" size="large" ratio="5/1"></p><h2>Video</h2><video caption="Caption"><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2>Model View</h2><h2>List</h2><h3>Unordered List</h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3>Ordered List</h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3>Task</h3><ul data-type="taskList"><li data-checked="true" data-type="taskItem"><label><input type="checkbox" checked="checked"><span></span></label><div><p>Model Viewer</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Diagram</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Math Formula</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Draggable handler for all blocks</p></div></li></ul><h2>Code Block</h2><blockquote><p>Friendly to developer, with syntax highlight.</p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Shortcut</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Remarks</p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Heading</p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Blockquote</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p>Code Block</p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2>Typography</h2><h3>Heading 3</h3><h4>Heading 4</h4><h3>Paragraph</h3><p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p><p>Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals.</p><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p><p>Whether 60 or 16, there is in every human beings heart the lure of wonder, the unfailing childlike appetite of whats next and the joy of the game of living. In the center of your heart and my heart there is a wireless station: so long as it receives messages of beauty, hope, cheer, courage and power from men and from the Infinite, so long are you young.</p><p>When the aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you are grown old, even at 20, but as long as your aerials are up, to catch waves of optimism, there is hope you may die young at 80.</p><h3>Smart</h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Title</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Input</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Output</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>Copyright</p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Right</p></td><td colspan="1" rowspan="1" background=""><p><code>(r)</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Arrow</p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Not equal</p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Ratio</p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code>&nbsp;&nbsp;<code>1/4</code>&nbsp;&nbsp;<code>3/4</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>  &nbsp;</p></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Dash</p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h3>Color Highlighter</h3><p>#abc, #00ff00, Info color #2080f0</p><h2>Text</h2><p><span style="font-family: &quot;Arial Black&quot;"><strong>Bold text</strong></span></p><p><em>Italic text</em></p><p><u>Underline text</u></p><p><s>Strike through text</s></p><hr><p><code>Inline code</code></p><p><span style="color: rgb(255, 77, 79)">Text with color</span></p><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit">Text with highlight background</mark></p><p></p>
`;
    const BasicFeaturesArticleZh = `
<h1>Yiitap</h1><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/yiitap/yiitap"><span style="color: rgb(24, 144, 255)"><strong>YiitapEditor</strong></span></a><span style="color: rgb(24, 144, 255)"><strong><em>&nbsp;</em></strong></span><a target="_blank" rel="noopener noreferrer nofollow" href="https://tiptap.dev/"><span style="font-family: system-ui">Tiptap</span></a></p><h2></h2><div icon="" bordercolor="#dddddd" bordercolordark="#333333" backcolor="#eeeeee" backcolordark="rgba(101, 117, 133, 0.16)" data-type="callout"><p><strong></strong></p><p></p></div><h2></h2><blockquote><p><br></p></blockquote><h2></h2><table-wrapper><table style="min-width: 100px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th1</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th2</p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center">Th3</p></th><th colspan="1" rowspan="1" background=""><p>Th3</p></th></tr><tr><td colspan="1" rowspan="1" background=""><p>List</p></td><td colspan="1" rowspan="1" background=""><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 1</p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p>Task 2</p></div></li></ul></td><td colspan="1" rowspan="1" background=""><ul><li><p>List item 1</p></li><li><p>List item 2</p></li></ul></td><td colspan="1" rowspan="1" background=""><ol><li><p>Number one</p></li><li><p>Number two</p></li></ol></td></tr><tr><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td><td colspan="1" rowspan="1" background=""><p>Text</p></td></tr><tr><td colspan="1" rowspan="1" background="#1890ff"><p><span style="color: rgb(255, 255, 255)"></span></p></td><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="2" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><blockquote><p></p></blockquote><p><img src="https://share.pileax.ai/logo.svg" alt="Caption" title="" size="large" ratio="5/1"></p><h2></h2><video caption=""><source src="https://dhweb-app.oss-cn-hangzhou.aliyuncs.com/video/An-225.mp4"></video><h2></h2><h3></h3><ul><li><p>List Item 1</p><ul><li><p>List Item 1.1</p></li><li><p>List Item 1.21</p></li></ul></li><li><p>List Item 2</p></li><li><p>List Item 3</p></li></ul><h3></h3><blockquote><p>PDCA</p></blockquote><ol><li><p>Plan</p><ol><li><p>Plan 1</p></li><li><p>Plan 2</p></li></ol></li><li><p>Do</p></li><li><p>Check</p></li><li><p>Adust</p></li></ol><h3></h3><ul data-type="taskList"><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li><li data-checked="false" data-type="taskItem"><label><input type="checkbox"><span></span></label><div><p></p></div></li></ul><h2></h2><blockquote><p></p></blockquote><h3>Bash</h3><pre><code class="language-javascript">const name = 'JavaScript';
console.log('Hello, world', name);</code></pre><h3>Go</h3><pre><code class="language-go">package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}</code></pre><h2>Markdown</h2><table-wrapper><table style="min-width: 340px"><colgroup><col style="width: 290px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" colwidth="290" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>#</code> <code>##</code> <code>###</code> <code>####</code> <code>#####</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" colwidth="290" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>\`\`\`</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><h3> 3</h3><h4> 4</h4><h3></h3><p></p><p></p><p></p><p></p><p></p><h3></h3><table-wrapper><table style="min-width: 75px"><colgroup><col style="min-width: 25px"><col style="min-width: 25px"><col style="min-width: 25px"></colgroup><tbody><tr><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th><th colspan="1" rowspan="1" background=""><p style="text-align: center"></p></th></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>(c)</code>&nbsp; <code>(r)</code>&nbsp; <code>(tm)</code>&nbsp;</p></td><td colspan="1" rowspan="1" background=""><p>   </p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>&gt;&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>-&gt;</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>!=</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>1/2</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr><tr><td colspan="1" rowspan="1" background=""><p></p></td><td colspan="1" rowspan="1" background=""><p><code>--</code></p></td><td colspan="1" rowspan="1" background=""><p></p></td></tr></tbody></table></table-wrapper><h2></h2><ul><li><p><span style="font-family: &quot;Arial Black&quot;"><strong></strong></span></p></li><li><p><em></em></p></li><li><p><u></u></p></li><li><p><s></s></p></li><li><p><code></code></p></li><li><p><span style="color: rgb(255, 77, 79)"> </span></p></li><li><p><mark data-color="#FBF3DB" style="background-color: #FBF3DB; color: inherit"></mark></p></li></ul><p></p>
`;
    const _hoisted_1$1 = ["href"];
    const _hoisted_2$1 = ["src"];
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "VersionBadge",
      props: {
        package: {}
      },
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("a", {
            href: `https://www.npmjs.com/package/${_ctx.package}`,
            target: "_blank",
            rel: "noopener noreferrer"
          }, [
            createBaseVNode("img", {
              src: `https://img.shields.io/npm/v/${_ctx.package}.svg`,
              alt: "NPM version"
            }, null, 8, _hoisted_2$1)
          ], 8, _hoisted_1$1);
        };
      }
    });
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const VersionBadge = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-8d0105bf"]]);
    const _hoisted_1 = { class: "layout-toolbar" };
    const _hoisted_2 = { class: "info" };
    const _hoisted_3 = { class: "version" };
    const _hoisted_4 = { class: "actions" };
    const _hoisted_5 = { class: "toolbar" };
    const _hoisted_6 = { class: "layout-content" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "Demo",
      emits: ["mode"],
      setup(__props, { emit: __emit }) {
        const emit2 = __emit;
        const yiiEditor = ref();
        const locale = ref("en");
        const darkMode = ref(false);
        const editable = ref(true);
        const showDrawer = ref(false);
        provide("locale", locale);
        provide("darkMode", darkMode);
        const options = computed(() => {
          return {
            locale: locale.value,
            darkMode: darkMode.value,
            editable: editable.value,
            content: content.value,
            showMainMenu: false,
            showBubbleMenu: true,
            showFloatingMenu: true,
            showSideMenu: true,
            // showSideNode: true,
            pageView: "page",
            mainMenu: [
              "bold",
              "italic",
              "text-format-dropdown",
              "separator",
              "heading",
              "font-family",
              "text-color-dropdown",
              "fore-color",
              "back-color",
              "clearFormat",
              "separator",
              "align-dropdown",
              "separator",
              "horizontalRule",
              "blockquote",
              "list-dropdown",
              "codeBlock",
              "link",
              "image",
              "video",
              "table",
              "callout",
              "emoji"
            ],
            extensions: [
              "OBlockquote",
              "OCallout",
              "OCodeBlock",
              "OColon",
              "OColorHighlighter",
              "OHeading",
              "OImage",
              "OParagraph",
              "OSlash",
              "OSlashZh",
              "OLink",
              "OTrailingNode",
              "OVideo"
            ]
          };
        });
        const content = computed(() => {
          return locale.value === "zh" ? BasicFeaturesArticleZh : BasicFeaturesArticle;
        });
        function onToggleDrawer() {
          showDrawer.value = !showDrawer.value;
        }
        function onGithub() {
          window.open("https://github.com/yiitap/yiitap", "_blank");
        }
        function onMode() {
          emit2("mode", darkMode.value);
        }
        function onUpdate({ json, html }) {
        }
        watch(locale, (newValue) => {
          var _a2;
          (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor.commands.setContent(content.value);
        });
        onMounted(() => {
        });
        return (_ctx, _cache) => {
          var _a2, _b2;
          return openBlock(), createElementBlock("section", {
            class: normalizeClass(["page-demo", { dark: darkMode.value }])
          }, [
            createBaseVNode("section", _hoisted_1, [
              createBaseVNode("header", null, [
                createBaseVNode("section", _hoisted_2, [
                  _cache[4] || (_cache[4] = createBaseVNode("img", {
                    src: _imports_0,
                    alt: "Logo"
                  }, null, -1)),
                  _cache[5] || (_cache[5] = createBaseVNode("div", { class: "title" }, "Yiitap", -1)),
                  createBaseVNode("div", _hoisted_3, [
                    createVNode(VersionBadge, { package: "@yiitap/vue" })
                  ])
                ]),
                createBaseVNode("section", _hoisted_4, [
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onGithub
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ue), { name: "github" })
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Button), {
                    quaternary: "",
                    onClick: onToggleDrawer
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ue), { name: "menu" })
                    ]),
                    _: 1
                  })
                ])
              ]),
              createBaseVNode("div", _hoisted_5, [
                createVNode(unref(ck), {
                  editor: (_a2 = yiiEditor.value) == null ? void 0 : _a2.editor,
                  menu: options.value.mainMenu,
                  "data-theme": darkMode.value ? "dark" : ""
                }, null, 8, ["editor", "menu", "data-theme"])
              ])
            ]),
            createBaseVNode("section", _hoisted_6, [
              createVNode(unref(FC), mergeProps({
                ref_key: "yiiEditor",
                ref: yiiEditor
              }, options.value, { onUpdate }), null, 16)
            ]),
            createVNode(unref(NDrawer), {
              show: showDrawer.value,
              "onUpdate:show": _cache[3] || (_cache[3] = ($event) => showDrawer.value = $event),
              "default-width": 400,
              placement: "right",
              resizable: ""
            }, {
              default: withCtx(() => [
                createVNode(unref(NDrawerContent), {
                  title: "Yii Editor",
                  closable: ""
                }, {
                  default: withCtx(() => [
                    createVNode(unref(NForm), {
                      ref: "form",
                      "label-placement": "left",
                      "label-width": "auto"
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(NFormItem), { label: "Language" }, {
                          default: withCtx(() => [
                            createVNode(unref(NRadioGroup), {
                              value: locale.value,
                              "onUpdate:value": _cache[0] || (_cache[0] = ($event) => locale.value = $event),
                              name: "radiogroup1"
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(NSpace), null, {
                                  default: withCtx(() => [
                                    createVNode(unref(NRadio), { value: "en" }, {
                                      default: withCtx(() => _cache[6] || (_cache[6] = [
                                        createTextVNode(" English ")
                                      ])),
                                      _: 1
                                    }),
                                    createVNode(unref(NRadio), { value: "zh" }, {
                                      default: withCtx(() => _cache[7] || (_cache[7] = [
                                        createTextVNode("  ")
                                      ])),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Mode" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: darkMode.value,
                              "onUpdate:value": [
                                _cache[1] || (_cache[1] = ($event) => darkMode.value = $event),
                                onMode
                              ]
                            }, {
                              checked: withCtx(() => _cache[8] || (_cache[8] = [
                                createTextVNode(" Dark ")
                              ])),
                              unchecked: withCtx(() => _cache[9] || (_cache[9] = [
                                createTextVNode(" Light ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        }),
                        createVNode(unref(NFormItem), { label: "Edit" }, {
                          default: withCtx(() => [
                            createVNode(unref(NSwitch), {
                              value: editable.value,
                              "onUpdate:value": _cache[2] || (_cache[2] = ($event) => editable.value = $event)
                            }, {
                              checked: withCtx(() => _cache[10] || (_cache[10] = [
                                createTextVNode(" Editable ")
                              ])),
                              unchecked: withCtx(() => _cache[11] || (_cache[11] = [
                                createTextVNode(" Readonly ")
                              ])),
                              _: 1
                            }, 8, ["value"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["show"]),
            createVNode(unref(VC), {
              editor: (_b2 = yiiEditor.value) == null ? void 0 : _b2.editor,
              "max-level": 3
            }, null, 8, ["editor"])
          ], 2);
        };
      }
    });
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const darkMode = ref(false);
        const theme = computed(() => {
          return darkMode.value ? darkTheme : null;
        });
        function onMode(value) {
          darkMode.value = value;
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(NConfigProvider), { theme: theme.value }, {
            default: withCtx(() => [
              createVNode(_sfc_main$1, { onMode })
            ]),
            _: 1
          }, 8, ["theme"]);
        };
      }
    });
    const app = createApp(_sfc_main);
    app.mount("#app");
  }
});
export default require_index_001();
